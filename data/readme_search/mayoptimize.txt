conditionally optimize julia code writing performance reference perform bound checking version assumes valid indices avoid heavily optimized requires loop vectorization mayoptimize package variants available single documentation usage summarized following short example using function foo type abstractarray real optimlevel zero compute sum values maybe inbounds eachindex fill vectorized return note loops preceded macros arguments parameter expression block argument simple macro compiled determined debug debugging performs avoids vectorize provided specified specifying simd hence called decided method dispatcher according abstract types exported calling executes checks bounds finally vectorizes easy provide default users bother choosing instance assuming checked issues indexing makes difference write decide change optimization level installation hit key switch manager repl pkg prompt add packages examples left divison triangular matrix extends base linear algebra methods ldiv division vector linearalgebra opt operation overwritten stored standard probably blas compile settings figures obtained amd ryzen threadripper core processor efficient chosen gain compared implementation innermost look src linalg realize identical changes pretty straightforward cholesky decomposition pivoting hermitian regular uopper lower factor returned unchanged apart piracy rounding errors result calls illustrated faster matrices size equal spite run threads whereas executed thread specifies algorithm choleskybanachiewiczloweri choleskybanachiewiczlowerii choleskybanachiewiczupper choleskycroutlower choleskycroutupperi choleskycroutupperii choose choleskybanachiewiczlower factorization banachiewicz row conversely fastest choices optimal testing machine float levels