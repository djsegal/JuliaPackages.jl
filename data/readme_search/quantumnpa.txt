quantumnpa code npa julia development names functions entire project change prerequisites using pkg add combinatorics jump scs blockdiagonals try include dot line isn typo able call internal conveniently instead qnpa load function global variable main module examples maximise chsh level hierarchy dichotomic max svetlichny generic method note spaces string party labels aaa zzz modified specify equality inequality arguments keyword lists operators expectation values respectively set lower bound zero example subject variables projectors supported form projector sqrt cglmp defined construct operator guessing probability setting statistics create argument true means corresponding numbered output directly identity minus ones meant collins gisin projection convenient value eve correctly guesses alice bob joint outcome sum ideal violating correlations mixed noise actual constraints imposed array returns default solver calls doesn require license solve relaxation quantum optimisation mosek file mosektools optimizer don time model separately minimization objective type affexpr mathoptinterface equalto float vector variableref positivesemidefiniteconetriangle constraint mode automatic cachingoptimizer empty name optimize splitting conic brendan donoghue stanford university cones primal dual free vars psd ssize settings eps abs rel infeas alpha scale adaptive iters normalize rho acceleration lookback interval lin sys sparse direct nnz iter pri res dua gap obj status solved timings total setup accel assigned assign suppress calling verbose false silent returned basic features arithmetic conjugates types associate parties moment fourier unitary zbff brown fawzi represented predefined conj illustrate manipulation monomials polynomials kinds expressions matrix coefficients dimensions added subtracted multiplied match library represent parameters input power index strictly positive integer integers increasing representing associated uppercase alphabetic character characters separated underscores converted stored internally inside considered commute intersection vectors called arrays ranges parameter optional defaults omitted range inputs fourth indicates intend outputs measurement outcomes preceding starting aware printed illustrating monomial element commutation relations evaluations notice starts moves front expression cancelled writing macros automatically standard macro invocation essentially running following special shouldn mix unless consider unrelated finally worth stressing objects manipulated sorts putting data structures dimensional int kron union polynomial adjoint eltype analysing modifying deconstructing consisting single typeof ensure object promote datatype copy original modify safely changing suggest access coefficient base keyset dict entries keys act iterators pairs nonzero contexts iterator expected collect pair printf iterate lexicographical sort help analyse return individual collections instance local list assuming definitions immediately elements optionally dictionary useful constructing intermediate levels short appear covers upper triangular treats ops indices indexed enumerate min haskey push else conjugate comes lexicographically comparisons reason inequalities compare error methoderror matching isless comments implementation section details implemented mainly people understand idea pretty straightforward compute products appearing check results translate aims support simplifying commonly encountered handled abstract src primitive concrete subtypes etc created user linear combinations collective throughout assumed common properties interchangeable significant extent particular passed structs fields depends field unitaries boolean tracking conjugated containing constructors capitalised fieldnames exported prefix codebase defines implementations key overriden behaviour correct generically fine hermitian determined depending specialised versions version toggles definition generated amounts multiply especially product simplified rule concatenate multiplicative allows possibility scaling factors multiplications future unnormalised squares multiple currently sufficient practice multiplication usually fallen simplest nontrivial rules otherwise join near beginning determines takes opsx opsy basically multiplies repeats result concatenation remaining normal word contains described look contents accessing tuple left valid precede length contain required commutes reduced canonical lexicographic allow followed nonempty twice conjucate particularly responsible maintaining conventions recommended build start readable makes easy generate invalid avoided terms mapping coeffients assignment setindex remove term deletes entry constructor simply care break assumptions elsewhere mentioned latter define acknowledgements started postdoc laboratoire information quantique universit libre bruxelles belgium november continued quantinuum