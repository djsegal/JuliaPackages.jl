julia expression convertor quickstart pkg clone import sexpr main usage lines output extension files program port clojure syntax default takes outputs version flip direction positional arguments file directory dump stdout multiple sjulia dir specified optional invert code print instead cat input stdin read ignores args blank exist top level forms type int write empty argument throw error add qualifies lisp times defaults clj cljs wisp help message exit test programs transpile overview project aims interoperable expr objects seen lispsyntax similar idea imho bit allow convert minus special aren supported makes python route pycall via hylang wispjs benefit awkward macro languages avoided necessitates wrapping hymodel ridiculous module system broken javascript resolving variable names properly final goal interoperability macroexpand operation able folder temp created macroexpanded converted written third unfortunately intermediary step resolve imports alternatively str string breaks highlighters annoying probably thinking learn muck internals learned mission accomplished self hosting means hopefully package soon dealing google closure compiler leiningen java jvm dependencies larger solved consider unwieldy practical effectively reader portion implementing else using inbuilt mechanisms atoms nil translates exactly true false surprises constants compile float types rational character atom starting newline space tab formfeed backspace return escapes unicode octal support handled strict giving literal silently term strategy xyz sequence characters inside double quotes multiline strings allowed padding subtracted keyword basically symbol starts confusingly called symbols variables keywords colons resolved current namespace behavior compiles normal namespacing issues don identifier function relatively consistent semantics lenient limitation regular ones won suffice todo option escaped ascii available ugly avoids pain depending defined union collections list quoted evaluated transpiled lists evaluate tuples vector transpiles array map dict form set short circuit expect circuiting defines purpose family getting setting slicing arrays aget ref preferred typing auto useful defintions curly parameterized dot call access note equivalent modules creates visually indent spaces haven figured hash dispatch wraps meh priority contrary expectations separate statement cartesian productable expand shorten writing ideally define export sense view flat definitions tuple lisps common following convention exprs returns results standard evaluates branches var value binds pairs values implicit name params body defn docstring named docstrings ignored def dedicated include todos loop recur doesn try catch finally vars lazy iterators destructuring rest param defmulti related mean deftype prepend requires distinction macros involve entire simple leaving requirement deref choose denote macrocall future maybe abusing html div helloworld calls worse defmacro expected definition passed translated whatever produce desired rehydrate translate native ast quote escape equal stop gensym pass running actually esc unclear translation changed putting backtick quoting original obfuscation unquote expressions splice unquotes expands layer returned