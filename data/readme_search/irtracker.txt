irtracker previously dynamiccomputationgraphs aim project provide graph representation suitable dynamic models occur probabilistic programming languages stochastic control flow model recursion implement approach traditional ideas operator overloading source transformations resulting data structure extended wengert list generalization lists backward mode records operations preserves hierarchy function calls nested instead linearized carry arbitrary metadata customizable context system similar cassette able perform usual forward computation performance overhead interpretation record expression nodes representing calculation raw expr equivalent allowing convert meta information original code random variable types conditions etc applicable mutable update subgraphs evaluation changing design basic idea tape consisting instructions executed including type linearly statements execution contain extract inserting recording statement instruction look simple geom rand main unless return using irtools format trace follows assumption returns value time julia printlevels track arg default rng huge mersenne twister constant float false goto add int simplified graphical form result expanded levels output indented lines indicate inner recorded recursive intermediate values dependencies pointers bit cryptic contains following linked corresponding ssa annotated brackets block arguments associated expressions prefixed path numbered referred pass trivial branching actually written literal label blocks paragraph signs position branch note argument stands constants literals angle makes debugging transformed easier furthermore assignments jumped branches respective notation zero generic method true references adding adjoint abstract abstractnode subtypes special inbounds primitive builtin intrinsic changed containing recursively call jump implementation constructing extending beginning somehow tracked saveir quotenode tapeconstant trackedargument tuple trackedcall trackedvariable trackedjump trackedreturn extra graphrecorder object onto reified whatever plus preparations finally replaced trackcall depending current notion contexts transformation implemented dynamo essence fancier generated operate codeinfo completely rebuilt insert tracking creating node passing actual target reason jumps additional runtime logic determines differentiate serving stopping purpose usage happen multiple times loop splice inlined statically determined indices locations noticed functions passed dispatch internal overload behaviour providing custom implementations tracker change considered primitively differentiable application recurse examples readme test trying currently couple runtests interface args nestedcallnode graphs inspect top level sin children parent getchildren element array getparent normal indexing access provided referenced results directly backwards transitively implementing require according pair left corresponds dependents query direction detailed iterface various properties typeof getvalue methods location getlocation available indexed getir graphapi tapeexpr functionality create subtype abstracttrackingcontext limit maximum avoid start struct depthlimitcontext maxlevel little helper increase ctx import canrecur tracknested recur trackednested repr argumenttuple tapevalue info nodeinfo recordnestedcall fallback primitivenode defaulttrackingcontext tracks isbuiltin library moment overloadable trackedconstant trackedprimitive trackedspecial fallbacks explained forced otherwise manually construct structures complex folder