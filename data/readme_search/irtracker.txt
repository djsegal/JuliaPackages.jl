irtracker previously dynamiccomputationgraphs aim project provide graph representation suitable dynamic models occur probabilistic programming languages stochastic control flow model recursion implement approach traditional ideas operator overloading source transformations resulting data structure extended wengert list generalization lists backward mode records operations preserves hierarchy function calls nested instead linearized carry arbitrary metadata customizable context system similar cassette able perform usual forward computation performance overhead interpretation record expression nodes representing calculation raw expr equivalent allowing convert meta information original code random variable types conditions etc applicable mutable update subgraphs evaluation changing design basic idea tape consisting instructions executed including type linearly statements execution contain extract inserting recording statement instruction look simple geom rand main unless return using irtools format trace follows assumption returns value time julia printlevels track int arg typeof float default rng mersennetwister false bool goto add result expanded levels output huge indented lines indicate inner recorded recursive intermediate values dependencies pointers bit cryptic contains following linked corresponding ssa annotated brackets block arguments associated expressions prefixed path numbered referred pass trivial branching actually written literal form label blocks paragraph signs position branch note argument stands constants literals angle makes debugging transformed easier shown special foreigncall furthermore assignments jumped branches respective notation zero generic method true spurious represent empty varargs references adding adjoint abstract abstractnode subtypes inbounds primitive builtin intrinsic changed containing recursively call jump implementation constructing extending constant beginning somehow tracked saveir quotenode tapeconstant trackedargument base tuple trackedcall trackedvariable trackedjump trackedreturn extra graphrecorder object onto reified whatever plus preparations finally replaced trackcall depending current notion contexts transformation implemented dynamo essence fancier generated operate codeinfo completely rebuilt insert tracking creating node passing actual target reason jumps additional runtime logic determines differentiate serving stopping purpose usage happen multiple times loop spliced inlined statically determined indices locations noticed functions passed dispatch internal overload behaviour providing custom implementations tracker change considered primitively differentiable application recurse examples readme test trying currently couple runtests interface args nestedcallnode graphs inspect top level sin children parent getchildren element array getparent normal indexing access provided referenced results directly backwards transitively implementing require according pair left corresponds dependents query direction detailed iterface various properties tapecall tapereference argumentnode getvalue getfunction methods getarguments location getlocation available indexed getir graphapi tapeexpr functionality create subtype abstracttrackingcontext limit maximum avoid start struct depthlimitcontext maxlevel little helper increase ctx import canrecur tracknested recur trackednested repr argumenttuple tapevalue info nodeinfo recordnestedcall fallback primitivenode defaulttrackingcontext tracks isbuiltin library moment overloadable trackedconstant trackedprimitive trackedspecial fallbacks explained forced otherwise manually construct structures complex folder