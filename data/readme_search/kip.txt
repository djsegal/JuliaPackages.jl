kip alternative module system julia goal robust easier packages don names instead modules identified file versions package overwriting favors putting dependency info inline require reduces indirection repl final key difference installs dependencies runtime installed run update occasionally local cache plain git repositories installation pkg clone add code config startup import haskey eval using built available files api consists macro function party string imports symbol takes path list symbols name locally pass pair explain syntax parameter example relative resolved pwd editing dirname familiar people unix machines assuming hood check called joinpath exists load otherwise tries paths main src enables save bit typing feel couple types absolute users jkroso github actually pretty complex enable specify ref tag commit branch haven specified reponame prefixed looks semver query tags repo matches finally repository isn completion applied runs fetch past time version native support registered dir metadata loaded compare exactly equivalent benchmark likelihood duplicate respective caches especially doesn provide supports looking contents requiring unbox wrapper normally provides match handling running arbitrary machine declared pipe results piped hand curl url remote docker instance btw echo encode projects jest demonstrates mixed nice writing cli programs script downloaded user uri parser enabled directly readme ipynb didn worry installing prospective features automatic reloading listen changes automatically reload workspace tree linting kips ability multiple double edged sword upside developers breaking instantly dependent downside common issues passing type instances fourth direct subtle hard recognize aware happen solution static analysis tool potential sense