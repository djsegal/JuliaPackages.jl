<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-basisfunctionexpansions" class="anchor" aria-hidden="true" href="#basisfunctionexpansions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BasisFunctionExpansions</h1>
<p><a href="https://travis-ci.org/baggepinnen/BasisFunctionExpansions.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/610b674a754d4fd5a2451f37b0eec914ac759e17/68747470733a2f2f7472617669732d63692e6f72672f626167676570696e6e656e2f426173697346756e6374696f6e457870616e73696f6e732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/baggepinnen/BasisFunctionExpansions.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/baggepinnen/BasisFunctionExpansions.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/961e4377e9a899e0c443c6bed23fae57c0431190/68747470733a2f2f636f6465636f762e696f2f67682f626167676570696e6e656e2f426173697346756e6374696f6e457870616e73696f6e732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/baggepinnen/BasisFunctionExpansions.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a>
<a href="https://baggepinnen.github.io/BasisFunctionExpansions.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/f7b92a177c912c1cc007fc9b40f17ff3ee3bb414/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a>
<a href="https://baggepinnen.github.io/BasisFunctionExpansions.jl/latest" rel="nofollow"><img src="https://camo.githubusercontent.com/57bae07ecd50a99519ad0516d91f4ec8f0f48e12/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width:100%;"> (Latest is recommended)</a></p>
<p>A Julia toolbox for approximation of functions using basis-function expansions (BFEs).</p>
<p>BFEs are useful when one wants to estimate an arbitrary/unknown/complicated functional relationship between (in the simple case) two variables, <code>y</code> and <code>v</code>. In simple linear regression, we might consider a functional relationship <code>y = ϕ(v) = αv + β</code>, with parameters <code>α</code> and <code>β</code>. However, if the function <code>ϕ</code> has an arbitrary nonlinar form, it might be hard to come up with suitable basis functions to use for linear regression. This package provides a set of convenient methods to estimate <code>ϕ(v)</code> as a linear combination of basis functions, such as radial basis functions, for situations where <code>v</code> has a single or multiple dimensions.</p>
<p>Currently supported basis functions are</p>
<ul>
<li>Radial Basis Functions <code>UniformRBFE, MultiRBFE, MultiUniformRBFE, MultiDiagonalRBFE</code></li>
</ul>
<h1><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h1>
<p>We demonstrate typical usage with some examples. Further usage examples in the context of reinforcement learning are provided at <a href="https://baggepinnen.github.io/" rel="nofollow">baggepinnen.github.io</a></p>
<p>The idea is to create an object representing an expansion. This object contains information regarding the domain of the expansion, which type of basis functions used and how many. These objects are, once created, callable with a scheduling vector/matrix. A call like this returns a vector/matrix of basis function activations.</p>
<p>To reconstruct a signal, a linear combination of basis functions must be estimated. To facilitate this, a second type of object is available: <code>BasisFunctionApproximation</code>. Once created, <code>BasisFunctionApproximation</code>s are callable with a scheduling signal and return an estimate of the output. The parameter estimation is performed behind the scenes using standard linear regression (least-squares). An optional regularization parameter can be supplied if needed, see <code>?BasisFunctionApproximation</code> for help.</p>
<p>Plotting functionality requires <code>Plots.jl</code></p>
<h2><a id="user-content-single-dimension" class="anchor" aria-hidden="true" href="#single-dimension"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single dimension</h2>
<p>We start by simulating a signal <code>y</code> and a scheduling signal <code>v</code>. The task is to estimate a function <code>y = ϕ(v)</code>, where <code>ϕ</code> is a basis-function expansion.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> DSP <span class="pl-c"><span class="pl-c">#</span> For filt</span>
N <span class="pl-k">=</span> <span class="pl-c1">1000</span>
v <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, stop<span class="pl-k">=</span><span class="pl-c1">10</span>, length<span class="pl-k">=</span>N) <span class="pl-c"><span class="pl-c">#</span> Scheduling signal</span>
y <span class="pl-k">=</span> <span class="pl-c1">randn</span>(N) <span class="pl-c"><span class="pl-c">#</span> Signal to be approximated</span>
y <span class="pl-k">=</span> <span class="pl-c1">filt</span>(<span class="pl-c1">ones</span>(<span class="pl-c1">500</span>)<span class="pl-k">/</span><span class="pl-c1">500</span>,[<span class="pl-c1">1</span>],y)</pre></div>
<p>Next, we setup the basis-function expansion object <code>rbf</code> and use it to create a reconstruction object <code>bfa</code></p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> BasisFunctionExpansions, Plots
Nv  <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-c"><span class="pl-c">#</span> Number of basis functions</span>
rbf <span class="pl-k">=</span> <span class="pl-c1">UniformRBFE</span>(v,Nv, normalize<span class="pl-k">=</span><span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">#</span> Approximate using radial basis functions with constant width</span>
bfa <span class="pl-k">=</span> <span class="pl-c1">BasisFunctionApproximation</span>(y,v,rbf,<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> Create approximation object</span>
ŷ   <span class="pl-k">=</span> <span class="pl-c1">bfa</span>(v) <span class="pl-c"><span class="pl-c">#</span> Reconstruct signal using approximation object</span>
<span class="pl-c1">scatter</span>(v,y, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Signal<span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter!</span>(v,ŷ, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reconstruction<span class="pl-pds">"</span></span>)</pre></div>
<p>For comparison, we can also plot the regular linear regression <code>y = α₀ + α₁x + α₂x²... αₙxⁿ</code> for varying orders of <code>n</code>.</p>
<div class="highlight highlight-source-julia"><pre>A <span class="pl-k">=</span> v<span class="pl-k">.^</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">3</span>)<span class="pl-k">'</span>
ŷ_linreg <span class="pl-k">=</span> [A[:,<span class="pl-c1">1</span><span class="pl-k">:</span>i]<span class="pl-k">*</span>(A[:,<span class="pl-c1">1</span><span class="pl-k">:</span>i]<span class="pl-k">\</span>y) <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">4</span>]
<span class="pl-c1">plot!</span>(v,<span class="pl-c1">hcat</span>(ŷ_linreg<span class="pl-k">...</span>), lab<span class="pl-k">=</span><span class="pl-c1">reshape</span>([<span class="pl-s"><span class="pl-pds">"</span>Linear regression order <span class="pl-v">$i</span><span class="pl-pds">"</span></span> <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>],<span class="pl-c1">1</span>,:))</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/onedim.png"><img src="figs/onedim.png" alt="window" style="max-width:100%;"></a></p>
<p>As we can see from the figure, the linear combination of basis functions forming the reconstruction has learnt the overall structure of the signal <code>y</code>. To capture more detail, one can try to increase the number of basis functions. The final choice of this number is a tradeoff between reconstruction bias and variance, where a high number of basis functions can model the signal in great detail, but may increase the variance if data is sparse.</p>
<h2><a id="user-content-multiple-dimensions" class="anchor" aria-hidden="true" href="#multiple-dimensions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple dimensions</h2>
<p>We now demonstrate the same thing but with <code>v ∈ ℜ²</code>. To create a nice plot, we let <code>v</code> form a spiral with increasing radius.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> BasisFunctionExpansions, DSP
N <span class="pl-k">=</span> <span class="pl-c1">1000</span>
x <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, stop<span class="pl-k">=</span><span class="pl-c1">4</span>pi, length<span class="pl-k">=</span>N)
v <span class="pl-k">=</span> [<span class="pl-c1">cos</span>.(x) <span class="pl-c1">sin</span>.(x)]<span class="pl-k">.</span><span class="pl-k">*</span>x <span class="pl-c"><span class="pl-c">#</span> Scheduling signal</span>
y <span class="pl-k">=</span> <span class="pl-c1">randn</span>(N) <span class="pl-c"><span class="pl-c">#</span> Signal to be approximated</span>
y <span class="pl-k">=</span> <span class="pl-c1">filt</span>(<span class="pl-c1">ones</span>(<span class="pl-c1">500</span>)<span class="pl-k">./</span><span class="pl-c1">500</span>,[<span class="pl-c1">1</span>],y)</pre></div>
<p>Now we're creating a two-dimensional basis-function expansion using ten functions in each dimension (for a total of 10*10=100 parameters).</p>
<div class="highlight highlight-source-julia"><pre>Nv  <span class="pl-k">=</span> [<span class="pl-c1">10</span>,<span class="pl-c1">10</span>] <span class="pl-c"><span class="pl-c">#</span> Number of basis functions along each dimension</span>
rbf <span class="pl-k">=</span> <span class="pl-c1">MultiUniformRBFE</span>(v,Nv, normalize<span class="pl-k">=</span><span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">#</span> Approximate using radial basis functions with constant width (Not isotropic, but all functions have the same diagonal covariance matrix)</span>
bfa <span class="pl-k">=</span> <span class="pl-c1">BasisFunctionApproximation</span>(y,v,rbf,<span class="pl-c1">0.0001</span>) <span class="pl-c"><span class="pl-c">#</span> Create approximation object</span>
ŷ   <span class="pl-k">=</span> <span class="pl-c1">bfa</span>(v) <span class="pl-c"><span class="pl-c">#</span> Reconstruct signal using approximation object</span>
<span class="pl-c1">scatter3d</span>(v[:,<span class="pl-c1">1</span>],v[:,<span class="pl-c1">2</span>],y, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Signal<span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter3d!</span>(v[:,<span class="pl-c1">1</span>],v[:,<span class="pl-c1">2</span>],ŷ, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reconstruction<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/multidim.gif"><img src="figs/multidim.gif" alt="window" style="max-width:100%;"></a></p>
<p>To visualize also the basis functions, we can simply call <code>plot!(rbf)</code> (the exclamation mark adds to the current plot instead of creating a new one).
Below is an example when a 5x5 BFE is visualized using <code>plotly</code> as backend.</p>
<p><a target="_blank" rel="noopener noreferrer" href="figs/multibase.png"><img src="figs/multibase.png" alt="window" style="max-width:100%;"></a></p>
<h3><a id="user-content-nonuniform-covariance" class="anchor" aria-hidden="true" href="#nonuniform-covariance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nonuniform covariance</h3>
<p>We can let all centers have different (diagonal) covariance matrices using the type <code>MultiDiagonalRBFE</code>. In this case, good center locations and covariances are estimated using K-means clustering. With this strategy, we can usually get away with much fewer basis functions compared to a uniform grid. A drawback is that we must know in advance which area of the scheduling signal space is of interest.</p>
<div class="highlight highlight-source-julia"><pre>Nc   <span class="pl-k">=</span> <span class="pl-c1">8</span>
rbf  <span class="pl-k">=</span> <span class="pl-c1">MultiDiagonalRBFE</span>(v,Nc, normalize<span class="pl-k">=</span><span class="pl-c1">true</span>)
bfa  <span class="pl-k">=</span> <span class="pl-c1">BasisFunctionApproximation</span>(y,v,rbf,<span class="pl-c1">0.0001</span>)
yhat <span class="pl-k">=</span> <span class="pl-c1">bfa</span>(v)
<span class="pl-c1">scatter3d</span>(v[:,<span class="pl-c1">1</span>],v[:,<span class="pl-c1">2</span>],y, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Signal<span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter3d!</span>(v[:,<span class="pl-c1">1</span>],v[:,<span class="pl-c1">2</span>],yhat, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reconstruction<span class="pl-pds">"</span></span>)</pre></div>
<h3><a id="user-content-full-covariance" class="anchor" aria-hidden="true" href="#full-covariance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Full covariance</h3>
<p>For the type <code>MultiRBFE</code> The covariance matrix and center locations are esimated using K-means.</p>
<div class="highlight highlight-source-julia"><pre>Nc   <span class="pl-k">=</span> <span class="pl-c1">8</span>                            <span class="pl-c"><span class="pl-c">#</span> Number of centers/BFs</span>
rbf  <span class="pl-k">=</span> <span class="pl-c1">MultiRBFE</span>(v,Nc, normalize<span class="pl-k">=</span><span class="pl-c1">true</span>)
bfa  <span class="pl-k">=</span> <span class="pl-c1">BasisFunctionApproximation</span>(y,v,rbf,<span class="pl-c1">0.0001</span>)
yhat <span class="pl-k">=</span> <span class="pl-c1">bfa</span>(v)
<span class="pl-c1">scatter3d</span>(v[:,<span class="pl-c1">1</span>],v[:,<span class="pl-c1">2</span>],y, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Signal<span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter3d!</span>(v[:,<span class="pl-c1">1</span>],v[:,<span class="pl-c1">2</span>],yhat, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reconstruction<span class="pl-pds">"</span></span>)</pre></div>
<h1><a id="user-content-dynamics-modeling" class="anchor" aria-hidden="true" href="#dynamics-modeling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dynamics modeling</h1>
<h2><a id="user-content-lpv-arx-modeling" class="anchor" aria-hidden="true" href="#lpv-arx-modeling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LPV ARX modeling</h2>
<p>We can use basis-function expansions for identification of elementary, non-linear dynamics models.
Consider the following dynamical system, with a non-linearity on the input
<code>A(z)y = B(z)√(|u|)</code>
We can simulate this system using the code</p>
<div class="highlight highlight-source-julia"><pre>A <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.7</span><span class="pl-k">*</span><span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> A(z) coeffs</span>
B <span class="pl-k">=</span> [<span class="pl-c1">10</span>,<span class="pl-c1">5</span>]        <span class="pl-c"><span class="pl-c">#</span> B(z) coeffs</span>
u <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">100</span>)    <span class="pl-c"><span class="pl-c">#</span> Simulate 100 time steps with Gaussian input</span>
y <span class="pl-k">=</span> <span class="pl-c1">filt</span>(B,A,<span class="pl-c1">sqrt</span>.(<span class="pl-c1">abs</span>.(u)))</pre></div>
<p>We can now try to fit a regular ARX model to this input-output data</p>
<div class="highlight highlight-source-julia"><pre>yr,A  <span class="pl-k">=</span> <span class="pl-c1">getARXregressor</span>(y,u,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> We assume that we know the system order 3,2</span>
x     <span class="pl-k">=</span> A<span class="pl-k">\</span>yr                     <span class="pl-c"><span class="pl-c">#</span> Fit using standard least-squares</span>
e_arx <span class="pl-k">=</span> <span class="pl-k">√</span>(<span class="pl-c1">mean</span>((yr <span class="pl-k">-</span> A<span class="pl-k">*</span>x)<span class="pl-k">.^</span><span class="pl-c1">2</span>))   <span class="pl-c"><span class="pl-c">#</span> Calculate RMS error (4.2553882233771025)</span>
<span class="pl-c1">plot</span>([yr A<span class="pl-k">*</span>x], lab<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>Signal<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>ARX prediction<span class="pl-pds">"</span></span>])</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/arx.png"><img src="figs/arx.png" alt="window" style="max-width:100%;"></a></p>
<p>Due to the non-linearity at the input of the system, the linear model fails to fit the data well. Our next attempt is a non-linear model based on BFEs. We select the simplest form of multi-dimensional BFE, <code>MultiUniformRBFE</code> and further select to cover the state-space with 2 basis functions along each dimension corresponding to <code>y</code>, and 4 basis functions along each dimension corresponding to <code>u</code> for a total of 2^2*4^3=256 parameters (4 basis functions is the smallest number that can somewhat accurately fit <code>√(|u|)</code>). The number of parameters in this case is large compared to the number of data points, we will need some regularization to fit this model properly. The regularization choice is made when forming the <code>BasisFunctionApproximation</code> and the strength is determined by the last argument <code>1e-3</code> in this case.</p>
<div class="highlight highlight-source-julia"><pre>bfe   <span class="pl-k">=</span> <span class="pl-c1">MultiUniformRBFE</span>(A,[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">4</span>,<span class="pl-c1">4</span>,<span class="pl-c1">4</span>], normalize<span class="pl-k">=</span><span class="pl-c1">true</span>)
bfa   <span class="pl-k">=</span> <span class="pl-c1">BasisFunctionApproximation</span>(yr,A,bfe, <span class="pl-c1">1e-3</span>)
e_bfe <span class="pl-k">=</span> <span class="pl-k">√</span>(<span class="pl-c1">mean</span>((yr <span class="pl-k">-</span> <span class="pl-c1">bfa</span>(A))<span class="pl-k">.^</span><span class="pl-c1">2</span>)) <span class="pl-c"><span class="pl-c">#</span> (0.005174261451622258)</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/bfe.png"><img src="figs/bfe.png" alt="window" style="max-width:100%;"></a></p>
<p>The non-linear model fits the data much better!</p>
<p>We also note that if we knew in advance that the system is linear with a non-linearity on the input, we could do this in a slightly more efficient way by incorporating lagged values of <code>y</code> directly in the regressor, instead of expanding the lagged values of <code>y</code> in a BFE. If we knew the exact non-linearity, we could simply transform our measured signal <code>u</code> and use it as input. With the LPV model, however, we can estimate the shape of the non-linearity.</p>
<h2><a id="user-content-lpv-state-space-modeling" class="anchor" aria-hidden="true" href="#lpv-state-space-modeling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LPV State-space modeling</h2>
<p>We can also estimate a state-space model with varying coefficient matrices, i.e. a model on the form
<code>x(t+1) = A(v)x(t) + B(v)u(t)</code></p>
<p>This is accomplished using the built in convenience functions</p>
<div class="highlight highlight-source-julia"><pre>nc    <span class="pl-k">=</span> <span class="pl-c1">10</span>                                        <span class="pl-c"><span class="pl-c">#</span> Number of centers</span>
model <span class="pl-k">=</span> <span class="pl-c1">LPVSS</span>(x, u, nc; normalize<span class="pl-k">=</span><span class="pl-c1">true</span>, λ <span class="pl-k">=</span> <span class="pl-c1">1e-3</span>) <span class="pl-c"><span class="pl-c">#</span> Estimate a model</span>
xh    <span class="pl-k">=</span> <span class="pl-c1">model</span>(x,u)                                <span class="pl-c"><span class="pl-c">#</span> Form prediction</span></pre></div>
<p>See <code>?LPVSS</code> for more details and a runnable example that produces a plot.</p>
<h1><a id="user-content-learn-more" class="anchor" aria-hidden="true" href="#learn-more"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Learn more</h1>
<p>Functionality in this package is used in the packages</p>
<ul>
<li><a href="https://github.com/baggepinnen/Robotlib.jl">Robotlib.jl</a></li>
<li><a href="https://github.com/baggepinnen/LPVSpectral.jl">LPVSpectral.jl</a></li>
<li><a href="https://github.com/baggepinnen/DynamicMovementPrimitives.jl">DynamicMovementPrimitives.jl</a></li>
</ul>
<p>And in the papers</p>
<ul>
<li><a href="http://lup.lub.lu.se/record/ac32368e-e199-44ff-b76a-36668ac7d595" rel="nofollow">"Linear Parameter-Varying Spectral Decomposition"
Bagge Carlson, Fredrik; Robertsson, Anders and Johansson, Rolf
(2017) American Control Conference Conference</a></li>
<li><a href="http://lup.lub.lu.se/record/7613758" rel="nofollow">"Modeling and Identification of Position and Temperature Dependent Friction Phenomena without Temperature Sensing"
Bagge Carlson, Fredrik; Robertsson, Anders and Johansson, Rolf
(2015) IEEE/RSJ International Conference on Intelligent Robots and Systems</a></li>
</ul>
<h1><a id="user-content-gradients" class="anchor" aria-hidden="true" href="#gradients"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gradients</h1>
<p>BasisFunctionExpansions plays nice with <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff.jl</a> and <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a></p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> ReverseDiff
julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)
julia<span class="pl-k">&gt;</span> ReverseDiff<span class="pl-k">.</span><span class="pl-c1">gradient</span>(bfa,a) <span class="pl-c"><span class="pl-c">#</span> bfa here comes from the Multi-dim example</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Float64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1.29364</span>  <span class="pl-k">-</span><span class="pl-c1">0.536586</span>

julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">0.0001</span> <span class="pl-c"><span class="pl-c">#</span> Finite difference for validation</span>
<span class="pl-c1">0.0001</span>

julia<span class="pl-k">&gt;</span> [(<span class="pl-c1">bfa</span>(a<span class="pl-k">+</span>[h <span class="pl-c1">0</span>]) <span class="pl-k">-</span> <span class="pl-c1">bfa</span>(a))<span class="pl-k">/</span>h (<span class="pl-c1">bfa</span>(a<span class="pl-k">+</span>[<span class="pl-c1">0</span> h]) <span class="pl-k">-</span> <span class="pl-c1">bfa</span>(a))<span class="pl-k">/</span>h]
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Float64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1.29363</span>  <span class="pl-k">-</span><span class="pl-c1">0.536488</span></pre></div>
<p>Note: for <code>ForwardDiff.jl</code> to work, you have to use <code>ForwardDiff.jacobian</code> instead of  <code>ForwardDiff.gradient</code>.</p>
<p>See <code>?ReverseDiff.gradient</code> for tips regarding high performance gradient calculation through preallocation of GradientConfig and prerecording of <code>bfa</code>.</p>
<h1><a id="user-content-another-example" class="anchor" aria-hidden="true" href="#another-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Another example</h1>
<div class="highlight highlight-source-julia"><pre>N   <span class="pl-k">=</span> <span class="pl-c1">200</span>
v   <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, stop<span class="pl-k">=</span><span class="pl-c1">10</span>, length<span class="pl-k">=</span>N)
y   <span class="pl-k">=</span> <span class="pl-c1">0.1</span><span class="pl-k">.*</span>(v<span class="pl-k">.-</span><span class="pl-c1">2</span>)<span class="pl-k">.*</span>(v<span class="pl-k">.-</span><span class="pl-c1">7</span>) <span class="pl-k">.+</span> <span class="pl-c1">0.2</span><span class="pl-c1">randn</span>(N)
rbf <span class="pl-k">=</span> <span class="pl-c1">UniformRBFE</span>(v, <span class="pl-c1">5</span>, normalize <span class="pl-k">=</span> <span class="pl-c1">true</span>)
bfa <span class="pl-k">=</span> <span class="pl-c1">BasisFunctionApproximation</span>(y,v,rbf)

<span class="pl-c1">scatter</span>(v,y,lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Signal<span class="pl-pds">"</span></span>,c<span class="pl-k">=</span><span class="pl-c1">:orange</span>, subplot<span class="pl-k">=</span><span class="pl-c1">1</span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\$</span>v<span class="pl-cce">\$</span><span class="pl-pds">"</span></span>, size<span class="pl-k">=</span>(<span class="pl-c1">600</span>,<span class="pl-c1">300</span>))
<span class="pl-c1">plot!</span>(rbf)
<span class="pl-c1">plot!</span>(v,<span class="pl-c1">bfa</span>(v),lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reconstruction<span class="pl-pds">"</span></span>,c<span class="pl-k">=</span><span class="pl-c1">:blue</span>,linewidth<span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/singlebase.png"><img src="figs/singlebase.png" alt="window" style="max-width:100%;"></a></p>
<h1><a id="user-content-selecting-the-number-of-basis-functions" class="anchor" aria-hidden="true" href="#selecting-the-number-of-basis-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Selecting the number of basis functions</h1>
<p>A simple way of choosing the number of basis functions is to plot an L-curve (parameter vs. error). A suitable number is where the kink in the curve occurs, for this example at around 6 basis functions.</p>
<div class="highlight highlight-source-julia"><pre>N    <span class="pl-k">=</span> <span class="pl-c1">200</span>
v    <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, stop<span class="pl-k">=</span><span class="pl-c1">10</span>, length<span class="pl-k">=</span>N)
y    <span class="pl-k">=</span> <span class="pl-c1">0.1</span><span class="pl-k">.*</span>(v<span class="pl-k">.-</span><span class="pl-c1">2</span>)<span class="pl-k">.*</span>(v<span class="pl-k">.-</span><span class="pl-c1">7</span>) <span class="pl-k">.+</span> <span class="pl-c1">0.2</span><span class="pl-c1">randn</span>(N)
nvec <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">100</span>
lcurve <span class="pl-k">=</span> <span class="pl-c1">map</span>(nvec) <span class="pl-k">do</span> n
  rbf <span class="pl-k">=</span> <span class="pl-c1">UniformRBFE</span>(v, n, normalize <span class="pl-k">=</span> <span class="pl-c1">true</span>)
  bfa <span class="pl-k">=</span> <span class="pl-c1">BasisFunctionApproximation</span>(y,v,rbf)
  <span class="pl-c1">std</span>(y<span class="pl-k">-</span><span class="pl-c1">bfa</span>(v))
<span class="pl-k">end</span>

<span class="pl-c1">plot</span>(nvec, lcurve, yscale<span class="pl-k">=</span><span class="pl-c1">:log10</span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>RMS Error<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Number of basis functions<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/lcurve.png"><img src="figs/lcurve.png" alt="window" style="max-width:100%;"></a></p>
<h1><a id="user-content-citing" class="anchor" aria-hidden="true" href="#citing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Citing</h1>
<p>This package was developed for the thesis
<a href="https://www.control.lth.se/staff/fredrik-bagge-carlson/" rel="nofollow">Bagge Carlson, F.</a>, <a href="https://lup.lub.lu.se/search/publication/ffb8dc85-ce12-4f75-8f2b-0881e492f6c0" rel="nofollow">"Machine Learning and System Identification for Estimation in Physical Systems"</a> (PhD Thesis 2018).</p>
<div class="highlight highlight-text-bibtex"><pre><span class="pl-k">@thesis</span>{<span class="pl-en">bagge2018</span>,
  <span class="pl-s">title</span>        = <span class="pl-s"><span class="pl-pds">{</span>Machine Learning and System Identification for Estimation in Physical Systems<span class="pl-pds">}</span></span>,
  <span class="pl-s">author</span>       = <span class="pl-s"><span class="pl-pds">{</span>Bagge Carlson, Fredrik<span class="pl-pds">}</span></span>,
  <span class="pl-s">keyword</span>      = <span class="pl-s"><span class="pl-pds">{</span>Machine Learning,System Identification,Robotics,Spectral estimation,Calibration,State estimation<span class="pl-pds">}</span></span>,
  <span class="pl-s">month</span>        = <span class="pl-s"><span class="pl-pds">{</span>12<span class="pl-pds">}</span></span>,
  <span class="pl-s">type</span>         = <span class="pl-s"><span class="pl-pds">{</span>PhD Thesis<span class="pl-pds">}</span></span>,
  <span class="pl-s">number</span>       = <span class="pl-s"><span class="pl-pds">{</span>TFRT-1122<span class="pl-pds">}</span></span>,
  <span class="pl-s">institution</span>  = <span class="pl-s"><span class="pl-pds">{</span>Dept. Automatic Control, Lund University, Sweden<span class="pl-pds">}</span></span>,
  <span class="pl-s">year</span>         = <span class="pl-s"><span class="pl-pds">{</span>2018<span class="pl-pds">}</span></span>,
  <span class="pl-s">url</span>          = <span class="pl-s"><span class="pl-pds">{</span>https://lup.lub.lu.se/search/publication/ffb8dc85-ce12-4f75-8f2b-0881e492f6c0<span class="pl-pds">}</span></span>,
}</pre></div>
</article></div>