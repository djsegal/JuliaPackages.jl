<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a href="https://codecov.io/gh/jessymilare/FlagSets.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/cdba58e6b81d0872529c508583af76e97bb7941751a36fa3d978c5972a5c65a1/68747470733a2f2f636f6465636f762e696f2f67682f6a657373796d696c6172652f466c6167536574732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d39424556494a48303845" alt="codecov" data-canonical-src="https://codecov.io/gh/jessymilare/FlagSets.jl/branch/master/graph/badge.svg?token=9BEVIJH08E" style="max-width: 100%;"></a>
<a href="https://travis-ci.com/jessymilare/FlagSets.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/7390e9d66ec16375ad5fac5b741e120b0fb3276223c3d1ed0f1f15e18744378b/68747470733a2f2f7472617669732d63692e636f6d2f6a657373796d696c6172652f466c6167536574732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jessymilare/FlagSets.jl.svg?branch=master" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-flagsetsjl" class="anchor" aria-hidden="true" href="#flagsetsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FlagSets.jl</h1>
<p dir="auto"><code>FlagSet.jl</code> provides an <code>Enum</code>-like type for bit flag option values. The main features
are:</p>
<ol dir="auto">
<li>Flags have implicit numbering with incrementing powers of 2.</li>
<li>Binary OR (<code>|</code>), AND (<code>&amp;</code>) and XOR(<code>⊻</code>) operations are supported among members.</li>
<li>Set operations like <code>union</code>, <code>intersect</code>, <code>setdiff</code>, <code>in</code> and <code>issubset</code> are also
supported.</li>
<li>Values are pretty-printed, showing the FlagSet type and each flag set.</li>
</ol>
<p dir="auto">This implementation is based on <a href="https://github.com/jmert/BitFlags.jl">BitFlags</a>, with
some differences:</p>
<ol dir="auto">
<li>Each flag set is treated as a set of flags and internally represented as an <code>Integer</code>
(whose bits 1 corresponds to the flags in the set).</li>
<li>The empty flag set (corresponding to 0) is always valid.</li>
<li>The macros <code>@symbol_flagset</code> and <code>@flagset</code> don't create a constant for each flag.</li>
<li>Each flag can be represented by objects of arbitrary type (new in 0.3).</li>
</ol>
<p dir="auto"><em>Note:</em> A breaking change has been introduced in version 0.3. The macro <code>@symbol_flagset</code>
corresponds to the old <code>@flagset</code> macro and the latter has been made more general.</p>
<h2 dir="auto"><a id="user-content-symbol-flag-sets" class="anchor" aria-hidden="true" href="#symbol-flag-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Symbol flag sets</h2>
<p dir="auto">To create a new <code>FlagSet{Symbol}</code> type, you can use the <code>@symbol_flagset</code> macro
(old syntax) or the more general and flexible <code>@flagset</code> macro.
You need to provide a type name, an optional integer type, and a list of the flag
names (with optional associated bits).
A new definition can be given in inline form:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@symbol_flagset FlagSetName[::BaseType] flag_1[=bit_1] flag_2[=bit_2] ...

@flagset FlagSetName [{Symbol,BaseType}] [bit_1 --&gt;] :flag_1 [bit_2 --&gt;] :flag_2 ..."><pre><span class="pl-c1">@symbol_flagset</span> FlagSetName[<span class="pl-k">::</span><span class="pl-c1">BaseType</span>] flag_1[<span class="pl-k">=</span>bit_1] flag_2[<span class="pl-k">=</span>bit_2] <span class="pl-k">...</span>

<span class="pl-c1">@flagset</span> FlagSetName [{Symbol,BaseType}] [bit_1 <span class="pl-k">--&gt;</span>] <span class="pl-c1">:flag_1</span> [bit_2 <span class="pl-k">--&gt;</span>] <span class="pl-c1">:flag_2</span> <span class="pl-k">...</span></pre></div>
<p dir="auto">or as a block definition:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@symbol_flagset FlagSetName[::BaseType] begin
    flag_1[=bit_1]
    flag_2[=bit_2]
    ...
end

@flagset FlagSetName [{Symbol,BaseType}] begin
    [bit_1 --&gt;] :flag_1
    [bit_2 --&gt;] :flag_2
    ...
end"><pre><span class="pl-c1">@symbol_flagset</span> FlagSetName[<span class="pl-k">::</span><span class="pl-c1">BaseType</span>] <span class="pl-k">begin</span>
    flag_1[<span class="pl-k">=</span>bit_1]
    flag_2[<span class="pl-k">=</span>bit_2]
    <span class="pl-k">...</span>
<span class="pl-k">end</span>

<span class="pl-c1">@flagset</span> FlagSetName [{Symbol,BaseType}] <span class="pl-k">begin</span>
    [bit_1 <span class="pl-k">--&gt;</span>] <span class="pl-c1">:flag_1</span>
    [bit_2 <span class="pl-k">--&gt;</span>] <span class="pl-c1">:flag_2</span>
    <span class="pl-k">...</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Automatic numbering starts at 1. In the following example, we build an 8-bit <code>FlagSet</code>
with no value for bit 3 (value of 4).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @flagset FontFlags1 :bold :italic 8 --&gt; :large"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@flagset</span> FontFlags1 <span class="pl-c1">:bold</span> <span class="pl-c1">:italic</span> <span class="pl-c1">8</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">:large</span></pre></div>
<p dir="auto">Instances can be created from integers or flag names and composed with bitwise operations.
Flag names can be symbols or keyword arguments.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; FontFlags1(1)
FontFlags1 with 1 element:
  :bold

julia&gt; FontFlags1(:bold, :italic)
FontFlags1 with 2 elements:
  :bold
  :italic

julia&gt; FontFlags1(bold = true, italic = false, large = true)
FontFlags1 with 2 elements:
  :bold
  :large

julia&gt; FontFlags1(3) | FontFlags1(8)
FontFlags1 with 3 elements:
  :bold
  :italic
  :large"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">1</span>)
FontFlags1 with <span class="pl-c1">1</span> element<span class="pl-k">:</span>
  <span class="pl-c1">:bold</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">:bold</span>, <span class="pl-c1">:italic</span>)
FontFlags1 with <span class="pl-c1">2</span> elements<span class="pl-k">:</span>
  <span class="pl-c1">:bold</span>
  <span class="pl-c1">:italic</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">FontFlags1</span>(bold <span class="pl-k">=</span> <span class="pl-c1">true</span>, italic <span class="pl-k">=</span> <span class="pl-c1">false</span>, large <span class="pl-k">=</span> <span class="pl-c1">true</span>)
FontFlags1 with <span class="pl-c1">2</span> elements<span class="pl-k">:</span>
  <span class="pl-c1">:bold</span>
  <span class="pl-c1">:large</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">3</span>) <span class="pl-k">|</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">8</span>)
FontFlags1 with <span class="pl-c1">3</span> elements<span class="pl-k">:</span>
  <span class="pl-c1">:bold</span>
  <span class="pl-c1">:italic</span>
  <span class="pl-c1">:large</span></pre></div>
<p dir="auto">Flag sets support iteration and other set operations</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; for flag in FontFlags1(3); println(flag) end
bold
italic

julia&gt; :bold in FontFlags1(3)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> flag <span class="pl-k">in</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">3</span>); <span class="pl-c1">println</span>(flag) <span class="pl-k">end</span>
bold
italic

julia<span class="pl-k">&gt;</span> <span class="pl-c1">:bold</span> <span class="pl-k">in</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Conversion to and from integers is permitted, but only when the integer contains valid
bits for the flag set type.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Int(FontFlags1(:bold))
1

julia&gt; Integer(FontFlags1(:italic))    # Abstract Integer uses base type
0x00000002

julia&gt; FontFlags1(9)
FontFlags1 with 2 elements:
  :bold
  :large

julia&gt; FontFlags1(4)
ERROR: ArgumentError: invalid value for FlagSet FontFlags1: 4
Stacktrace:
..."><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Int</span>(<span class="pl-c1">FontFlags1</span>(<span class="pl-c1">:bold</span>))
<span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Integer</span>(<span class="pl-c1">FontFlags1</span>(<span class="pl-c1">:italic</span>))    <span class="pl-c"><span class="pl-c">#</span> Abstract Integer uses base type</span>
<span class="pl-c1">0x00000002</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">9</span>)
FontFlags1 with <span class="pl-c1">2</span> elements<span class="pl-k">:</span>
  <span class="pl-c1">:bold</span>
  <span class="pl-c1">:large</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">4</span>)
ERROR<span class="pl-k">:</span> ArgumentError<span class="pl-k">:</span> invalid value <span class="pl-k">for</span> FlagSet FontFlags1<span class="pl-k">:</span> <span class="pl-c1">4</span>
Stacktrace<span class="pl-k">:</span>
<span class="pl-k">...</span></pre></div>
<p dir="auto">Supplying a different BaseType:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @flagset FontFlags2 {Symbol,UInt8} :bold :italic 8 --&gt; :large

# Or let the macro infer the flag type
julia&gt; @flagset FontFlags3 {_,UInt8} :bold :italic 8 --&gt; :large

julia&gt; Integer(FontFlags2(:italic))
0x02

julia&gt; Integer(FontFlags3(:italic))
0x02

julia&gt; eltype(FontFlags2) == eltype(FontFlags3) == Symbol
true"><pre class="notranslate"><code>julia&gt; @flagset FontFlags2 {Symbol,UInt8} :bold :italic 8 --&gt; :large

# Or let the macro infer the flag type
julia&gt; @flagset FontFlags3 {_,UInt8} :bold :italic 8 --&gt; :large

julia&gt; Integer(FontFlags2(:italic))
0x02

julia&gt; Integer(FontFlags3(:italic))
0x02

julia&gt; eltype(FontFlags2) == eltype(FontFlags3) == Symbol
true
</code></pre></div>
<p dir="auto">The empty and the full set can be created with <code>typemin</code> and <code>typemax</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; typemin(FontFlags1)
FontFlags1([])

julia&gt; typemax(FontFlags1)
FontFlags1 with 3 elements:
  :bold
  :italic
  :large"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">typemin</span>(FontFlags1)
<span class="pl-c1">FontFlags1</span>([])

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typemax</span>(FontFlags1)
FontFlags1 with <span class="pl-c1">3</span> elements<span class="pl-k">:</span>
  <span class="pl-c1">:bold</span>
  <span class="pl-c1">:italic</span>
  <span class="pl-c1">:large</span></pre></div>
<h2 dir="auto"><a id="user-content-flag-sets-with-custom-flag-type" class="anchor" aria-hidden="true" href="#flag-sets-with-custom-flag-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Flag sets with custom flag type</h2>
<p dir="auto">The syntax of <code>@flagset</code> macro is similar (but incompatible) with <code>@symbol_flagset</code>.
These are the most important differences:</p>
<ol dir="auto">
<li>The flags are evaluated (during macroexpansion).</li>
<li>The creator from flag values is absent, used <code>T([flags...])</code> instead.</li>
<li>To provide an explicit associated bit, use the following syntax: <code>bit --&gt; flag</code>.</li>
<li>To provide a key to be used as keyword argument, use the following syntax:
<code>key = [bit --&gt;] flag</code> (note that the key comes before the bit, if it is also supplied).</li>
<li><code>FlagType</code> and/or <code>BaseType</code> can be supplied between braces.</li>
</ol>
<p dir="auto">In the example below, the type <code>RoundingFlags1</code> is created only from flag values.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @flagset RoundingFlags1 RoundDown RoundUp RoundNearest

julia&gt; RoundingFlags1([RoundDown, RoundUp])
RoundingFlags1 with 2 elements:
  RoundingMode{:Down}()
  RoundingMode{:Up}()

julia&gt; Integer(RoundingFlags1([RoundDown, RoundUp]))
0x00000003"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@flagset</span> RoundingFlags1 RoundDown RoundUp RoundNearest

julia<span class="pl-k">&gt;</span> <span class="pl-c1">RoundingFlags1</span>([RoundDown, RoundUp])
RoundingFlags1 with <span class="pl-c1">2</span> elements<span class="pl-k">:</span>
  <span class="pl-c1">RoundingMode</span><span class="pl-c1">{:Down}</span>()
  <span class="pl-c1">RoundingMode</span><span class="pl-c1">{:Up}</span>()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Integer</span>(<span class="pl-c1">RoundingFlags1</span>([RoundDown, RoundUp]))
<span class="pl-c1">0x00000003</span></pre></div>
<p dir="auto"><code>RoundingFlags2</code> uses flags with custom bits for some flags:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @flagset RoundingFlags2 RoundDown 4--&gt; RoundUp 8 --&gt; RoundNearest

julia&gt; Integer(RoundingFlags2([RoundDown, RoundUp]))
0x00000005"><pre class="notranslate"><code>julia&gt; @flagset RoundingFlags2 RoundDown 4--&gt; RoundUp 8 --&gt; RoundNearest

julia&gt; Integer(RoundingFlags2([RoundDown, RoundUp]))
0x00000005
</code></pre></div>
<p dir="auto"><code>RoundingFlags3</code> also specifies keys for flags (except the last), flag and base types:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @flagset RoundingFlags3 {Any,UInt8} begin
    down = RoundDown
    up = RoundUp
    near = 16 --&gt; RoundNearest
    64 --&gt; RoundNearestTiesUp
end

julia&gt; RoundingFlags3(up = true, near = true)
RoundingFlags3 with 2 elements:
  RoundingMode{:Up}()
  RoundingMode{:Nearest}()

julia&gt; eltype(RoundingFlags3)
Any

julia&gt; typeof(Integer(RoundingFlags3()))
UInt8"><pre class="notranslate"><code>julia&gt; @flagset RoundingFlags3 {Any,UInt8} begin
    down = RoundDown
    up = RoundUp
    near = 16 --&gt; RoundNearest
    64 --&gt; RoundNearestTiesUp
end

julia&gt; RoundingFlags3(up = true, near = true)
RoundingFlags3 with 2 elements:
  RoundingMode{:Up}()
  RoundingMode{:Nearest}()

julia&gt; eltype(RoundingFlags3)
Any

julia&gt; typeof(Integer(RoundingFlags3()))
UInt8
</code></pre></div>
<h2 dir="auto"><a id="user-content-printing" class="anchor" aria-hidden="true" href="#printing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Printing</h2>
<p dir="auto">Printing a <code>FlagSet</code> subtype shows usefull information about it:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; FontFlags1
FlagSet FontFlags1:
 0x01 --&gt; :bold
 0x02 --&gt; :italic
 0x08 --&gt; :large

julia&gt; RoundingFlags3
FlagSet RoundingFlags3:
 0x00000001 --&gt; RoundingMode{:Down}()
 0x00000002 --&gt; RoundingMode{:Up}()
 0x00000010 --&gt; RoundingMode{:Nearest}()
 0x00000040 --&gt; RoundingMode{:NearestTiesUp}()"><pre>julia<span class="pl-k">&gt;</span> FontFlags1
FlagSet FontFlags1<span class="pl-k">:</span>
 <span class="pl-c1">0x01</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">:bold</span>
 <span class="pl-c1">0x02</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">:italic</span>
 <span class="pl-c1">0x08</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">:large</span>

julia<span class="pl-k">&gt;</span> RoundingFlags3
FlagSet RoundingFlags3<span class="pl-k">:</span>
 <span class="pl-c1">0x00000001</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">RoundingMode</span><span class="pl-c1">{:Down}</span>()
 <span class="pl-c1">0x00000002</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">RoundingMode</span><span class="pl-c1">{:Up}</span>()
 <span class="pl-c1">0x00000010</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">RoundingMode</span><span class="pl-c1">{:Nearest}</span>()
 <span class="pl-c1">0x00000040</span> <span class="pl-k">--&gt;</span> <span class="pl-c1">RoundingMode</span><span class="pl-c1">{:NearestTiesUp}</span>()</pre></div>
<p dir="auto">In a compact context (such as in multi-dimensional arrays), the pretty-printing
takes on a shorter form:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; [FontFlags1(), FontFlags1(:bold, :large)]
2-element Vector{FontFlags1}:
 FontFlags1([])
 FontFlags1([:bold, :large])

julia&gt; [RoundingFlags3() RoundingFlags3([RoundUp, RoundNearest])]
1×2 Matrix{RoundingFlags3}:
 RoundingFlags3(0x00000000)  RoundingFlags3(0x00000012)

julia&gt; show(IOContext(stdout, :compact =&gt; true), FontFlags1(:bold, :large))
FontFlags1(0x09)"><pre>julia<span class="pl-k">&gt;</span> [<span class="pl-c1">FontFlags1</span>(), <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">:bold</span>, <span class="pl-c1">:large</span>)]
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{FontFlags1}<span class="pl-k">:</span>
 <span class="pl-c1">FontFlags1</span>([])
 <span class="pl-c1">FontFlags1</span>([<span class="pl-c1">:bold</span>, <span class="pl-c1">:large</span>])

julia<span class="pl-k">&gt;</span> [<span class="pl-c1">RoundingFlags3</span>() <span class="pl-c1">RoundingFlags3</span>([RoundUp, RoundNearest])]
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{RoundingFlags3}<span class="pl-k">:</span>
 <span class="pl-c1">RoundingFlags3</span>(<span class="pl-c1">0x00000000</span>)  <span class="pl-c1">RoundingFlags3</span>(<span class="pl-c1">0x00000012</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">show</span>(<span class="pl-c1">IOContext</span>(<span class="pl-c1">stdout</span>, <span class="pl-c1">:compact</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>), <span class="pl-c1">FontFlags1</span>(<span class="pl-c1">:bold</span>, <span class="pl-c1">:large</span>))
<span class="pl-c1">FontFlags1</span>(<span class="pl-c1">0x09</span>)</pre></div>
<h2 dir="auto"><a id="user-content-inputoutput" class="anchor" aria-hidden="true" href="#inputoutput"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Input/Output</h2>
<p dir="auto"><code>FlagSet</code>s support writing to and reading from streams as integers:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; io = IOBuffer();

julia&gt; write(io, UInt8(9));

julia&gt; seekstart(io);

julia&gt; read(io, FontFlags1)
FontFlags1 with 2 elements:
  :bold
  :large"><pre>julia<span class="pl-k">&gt;</span> io <span class="pl-k">=</span> <span class="pl-c1">IOBuffer</span>();

julia<span class="pl-k">&gt;</span> <span class="pl-c1">write</span>(io, <span class="pl-c1">UInt8</span>(<span class="pl-c1">9</span>));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">seekstart</span>(io);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">read</span>(io, FontFlags1)
FontFlags1 with <span class="pl-c1">2</span> elements<span class="pl-k">:</span>
  <span class="pl-c1">:bold</span>
  <span class="pl-c1">:large</span></pre></div>
</article></div>