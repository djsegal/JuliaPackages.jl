<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-plantgeomjl" class="anchor" aria-hidden="true" href="#plantgeomjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PlantGeom.jl</h1>
<p dir="auto"><a href="https://VEZY.github.io/PlantGeom.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://VEZY.github.io/PlantGeom.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/VEZY/PlantGeom.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/VEZY/PlantGeom.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/VEZY/PlantGeom.jl">PlantGeom</a>, a package for everything 3D in plants.</p>
<h2 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h2>
<p dir="auto">The package is designed around <a href="https://github.com/VEZY/MultiScaleTreeGraph.jl">MultiScaleTreeGraph</a> that serves as the basic structure for the plant topology and attributes.</p>
<p dir="auto">The package provides different functionalities, the main ones being:</p>
<ul dir="auto">
<li>IO for the OPF file format (see <a href="@ref"><code>read_opf</code></a> and <a href="@ref"><code>write_opf</code></a>);</li>
<li>plotting using <a href="@ref"><code>viz</code></a> and <a href="@ref"><code>viz!</code></a>, optionally using coloring by attribute;</li>
<li>mesh transformations using <a href="@ref"><code>transform_mesh!</code></a></li>
</ul>
<p dir="auto">Note that <code>:geometry</code> is a reserved attribute in nodes (<em>e.g.</em> organs) used for the 3D geometry. It is stored as a special structure (<a href="@ref"><code>geometry</code></a>).</p>
<h2 dir="auto"><a id="user-content-example-usage" class="anchor" aria-hidden="true" href="#example-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example usage</h2>
<p dir="auto">Read an example OPF:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PlantGeom, MultiScaleTreeGraph

file = joinpath(dirname(dirname(pathof(PlantGeom))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.opf&quot;)
mtg = read_opf(file)"><pre><span class="pl-k">using</span> PlantGeom, MultiScaleTreeGraph

file <span class="pl-k">=</span> <span class="pl-c1">joinpath</span>(<span class="pl-c1">dirname</span>(<span class="pl-c1">dirname</span>(<span class="pl-c1">pathof</span>(PlantGeom))),<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>files<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>simple_plant.opf<span class="pl-pds">"</span></span>)
mtg <span class="pl-k">=</span> <span class="pl-c1">read_opf</span>(file)</pre></div>
<p dir="auto">Plot the plant geometry:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using GLMakie # Choose a Makie backend here.
viz(mtg)"><pre><span class="pl-k">using</span> GLMakie <span class="pl-c"><span class="pl-c">#</span> Choose a Makie backend here.</span>
<span class="pl-c1">viz</span>(mtg)</pre></div>
<p dir="auto"><code>viz</code> search for the <code>:geometry</code> attribute in the MTG nodes, and computes the meshes using the reference meshes and the transformation matrices to plot the 3d geometry of the plants.</p>
<p dir="auto">Colour by attribute, <em>e.g.</em> using the mesh max Z coordinates:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="transform!(mtg, refmesh_to_mesh!, zmax =&gt; :z_max, ignore_nothing = true)
viz(mtg, color = :z_max)"><pre><span class="pl-c1">transform!</span>(mtg, refmesh_to_mesh!, zmax <span class="pl-k">=&gt;</span> <span class="pl-c1">:z_max</span>, ignore_nothing <span class="pl-k">=</span> <span class="pl-c1">true</span>)
<span class="pl-c1">viz</span>(mtg, color <span class="pl-k">=</span> <span class="pl-c1">:z_max</span>)</pre></div>
<p dir="auto">By design the 3D geometry of each node is stored in the <code>:geometry</code> attribute. It stores a reference mesh, a transformation matrix, and the resulting mesh. The resulting mesh is computed lazily, meaning it is computed only the first time it is needed. To compute it explicitly, you can use <code>refmesh_to_mesh!</code> (like above):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="transform!(mtg, refmesh_to_mesh!)"><pre><span class="pl-c1">transform!</span>(mtg, refmesh_to_mesh!)</pre></div>
<h2 dir="auto"><a id="user-content-roadmap" class="anchor" aria-hidden="true" href="#roadmap"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Roadmap</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Add <code>read_opf()</code></li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Add <code>write_opf()</code>.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Use pointers to ref meshes instead of an index. It will be more simple then.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add <code>read_ops()</code></li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Add recipe for MTG diagram (no geometry )</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Use Primitives from Meshes as reference meshes:
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> I added cylinder, but remove it whenever it is available from Meshes.jl.</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Import reference meshes from disk (e.g. export from blender). This is done for the cylinder. Document it.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add a ref mesh for wood</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add a ref mesh for a leaf</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add tutorials:
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> How to plot with Plots.jl</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> How to plot with Makie.jl</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> How to build a geometry using attributes and reference meshes</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> How to build a plant + geometry manually and recursively</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Manage different kind of information into an MTG:
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Mesh for the nodes</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Reference meshes + transformation matrix (e.g. from OPF)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Reference meshes + Length and/or Width/diameter for scaling. If only Length, scale the whole mesh by a factor, if Length + Width, scale accordingly</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Remove coffee.opf from tests and add PlantBiophysics as a dependency instead. It will make PlantGeom much lighter.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Improve the OPF parser using e.g. our own XML parser. See <a href="https://github.com/ordovician/PLists.jl">https://github.com/ordovician/PLists.jl</a> for an example pure Julia XML parser, and the corresponding <a href="https://blog.devgenius.io/how-to-easily-write-an-xml-parser-in-julia-7cd02f19d8c6" rel="nofollow">blogpost here</a>. Make the reading in parallel ? For reference, reading a 80Mo OPF takes 8Go of memory and 4.5 minutes... -&gt; The issue came from SVectors that took forever to be allocated. I replaced them by normal vectors. It is much faster now (~11s on my computer).</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Make read_opf even faster (we should aim for e.g. 2-3s for an 80Mo OPF (largest file we have). We can make it parallel, but I think we can improve some things first (e.g. using structs instead of Dicts everywhere).</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Improve the OPF writer similarly. It takes forever writing to disk.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add a section about the OPF format.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Fix the example simple OPF -&gt; use one cylinder only, fix the scales of each node.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Fix the coffee OPF -&gt; scales are wrong (Metamer = 6 -&gt; 3, Leaf = 2 -&gt; 3) + Fix the MTG accordingly</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add tests using both simple_plant.opf and simple_plant.mtg to make sure both work the same way.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Fix the OPF writer: follow nodes are placed as siblings not children.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Make it compatible with <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">https://github.com/JuliaGeometry/GeometryBasics.jl</a></li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Compute the vertex normals properly when writting the OPF to disk</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Use the MakieCore package instead of Makie.jl to avoid the heavy dependencies of Makie.jl</li>
</ul>
</article></div>