<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-chunkedarraysjl" class="anchor" aria-hidden="true" href="#chunkedarraysjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ChunkedArrays.jl</h1>
<p><a href="https://travis-ci.org/ChrisRackauckas/ChunkedArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e7e826ea358108cd12693a1be35c7b92e60d034c/68747470733a2f2f7472617669732d63692e6f72672f43687269735261636b6175636b61732f4368756e6b65644172726179732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/ChrisRackauckas/ChunkedArrays.jl.svg?branch=master" style="max-width:100%;"></a> <a href="https://ci.appveyor.com/project/ChrisRackauckas/chunkedarrays-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/1e78447eb8b44090628b3226aa724a83a810799a/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f32666d3663383661656c616a793767633f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/2fm6c86aelajy7gc?svg=true" style="max-width:100%;"></a></p>
<p>ChunkedArrays.jl is a package for increasing the performance of arrays generated
inside of loops. Some basic benchmarks show chunked arrays being almost 50%
faster than naive approaches. One use case for this is using random numbers in
a loop. It's well known that for many reasons (including SIMD) that generating
1000 random number generators at once using <code>rand(1000)</code> is faster than generating
1000 random numbers in separate calls of <code>rand()</code>. ChunkedArrays allows you to
generate your arrays in larger amounts, but provides a convenient wrapper to hide the
details. Also included is the ability to generate the next buffer in parallel,
which allows you to utilize your array chunk and have it replaced with a new
chunk generated by a different process, maximizing efficiency.</p>
<h1><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h1>
<p>To install the package, simply use</p>
<div class="highlight highlight-source-julia"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>ChunkedArrays<span class="pl-pds">"</span></span>)
<span class="pl-k">using</span> ChunkedArrays</pre></div>
<p>Note that version v0.0.2 is the last version which targets Julia v0.4. The current master has some changes which only work on v0.5. For an up-to-date version with v0.4 compatibility, check out the v0.4-compat branch.</p>
<h1><a id="user-content-using-the-package" class="anchor" aria-hidden="true" href="#using-the-package"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using the Package</h1>
<p>You can define a ChunkedArray in one of the three forms:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">ChunkedArray</span>(chunkfunc<span class="pl-k">::</span><span class="pl-c1">Function</span>,bufferSize<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span>BUFFER_SIZE_DEFAULT,T<span class="pl-k">::</span><span class="pl-c1">Type</span><span class="pl-k">=</span>Float64;parallel<span class="pl-k">=</span>PARALLEL_DEFAULT)
<span class="pl-c1">ChunkedArray</span>(chunkfunc<span class="pl-k">::</span><span class="pl-c1">Function</span>,outputSize<span class="pl-k">::</span><span class="pl-c1">NTuple</span>,bufferSize<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span>BUFFER_SIZE_DEFAULT,T<span class="pl-k">::</span><span class="pl-c1">Type</span><span class="pl-k">=</span>Float64;parallel<span class="pl-k">=</span>PARALLEL_DEFAULT)
<span class="pl-c1">ChunkedArray</span>(chunkfunc,randPrototype<span class="pl-k">::</span><span class="pl-c1">AbstractArray</span>,bufferSize<span class="pl-k">=</span>BUFFER_SIZE_DEFAULT;parallel<span class="pl-k">=</span>PARALLEL_DEFAULT)</pre></div>
<p>Then, to generate the next value in the array, you use the <code>next</code> function like:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">next</span>(chunked)</pre></div>
<h1><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Examples</h1>
<p>Let's say for example we wished to generate a bunch of standard normal random
numbers in a loop. The naive way to do this is via</p>
<div class="highlight highlight-source-julia"><pre>j<span class="pl-k">=</span><span class="pl-c1">0.0</span>
<span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>loopSize
  j <span class="pl-k">+=</span> <span class="pl-c1">randn</span>()
<span class="pl-k">end</span></pre></div>
<p>To use a ChunkedArray which outputs standard normal random numbers, we would use
the definition the following:</p>
<div class="highlight highlight-source-julia"><pre>chunkRand <span class="pl-k">=</span> <span class="pl-c1">ChunkedArray</span>(randn)
j<span class="pl-k">=</span><span class="pl-c1">0.0</span>
<span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>loopSize
  j <span class="pl-k">+=</span> <span class="pl-c1">next</span>(chunkRand)
<span class="pl-k">end</span></pre></div>
<p>This uses the constructor <code>ChunkedArray(chunkfunc::Function,bufferSize::Int=BUFFER_SIZE_DEFAULT,T::Type=Float64,parallel=PARALLEL_DEFAULT)</code>
which has a buffer size of 1000 and does not use parallel generation. Note that you
do not need to be running multiple processes for parallel generation to work.
If we instead wished to generate <code>randn(4,2)</code> each time in the loop, we can
specify the dimensions:</p>
<div class="highlight highlight-source-julia"><pre>chunkRand <span class="pl-k">=</span> <span class="pl-c1">ChunkedArray</span>(randn,(<span class="pl-c1">4</span>,<span class="pl-c1">2</span>))
j<span class="pl-k">=</span>[<span class="pl-c1">0</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">0</span>]
<span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>loopSize
  j <span class="pl-k">+=</span> <span class="pl-c1">next</span>(chunkRand)
<span class="pl-k">end</span></pre></div>
<p>or simply give it a prototype:</p>
<div class="highlight highlight-source-julia"><pre>j<span class="pl-k">=</span>[<span class="pl-c1">0</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">0</span>]
chunkRand <span class="pl-k">=</span> <span class="pl-c1">ChunkedArray</span>(randn,j)
<span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>loopSize
  j <span class="pl-k">+=</span> <span class="pl-c1">next</span>(chunkRand)
<span class="pl-k">end</span></pre></div>
<p>and it will generate standard normals of <code>similar(j)</code>.</p>
<h1><a id="user-content-benchmarks" class="anchor" aria-hidden="true" href="#benchmarks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Benchmarks</h1>
<p>These benchmarks can be found in the test folder. For small runs (which are required
for CI) there is little difference, but as the loop size increases the difference
grows.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">const</span> loopSize <span class="pl-k">=</span> <span class="pl-c1">1000000</span>
<span class="pl-k">const</span> buffSize <span class="pl-k">=</span> <span class="pl-c1">10000</span>
<span class="pl-k">const</span> numRuns <span class="pl-k">=</span> <span class="pl-c1">400</span>
Test Results For Average Time<span class="pl-k">:</span>
One<span class="pl-k">-</span>by<span class="pl-k">-</span>one<span class="pl-k">:</span>                             <span class="pl-c1">0.148530531075</span>
Thousand<span class="pl-k">-</span>by<span class="pl-k">-</span>Thousand<span class="pl-k">:</span>                   <span class="pl-c1">0.189417186075</span>
Altogether<span class="pl-k">:</span>                             <span class="pl-c1">0.2057703961</span>
Hundred<span class="pl-k">-</span>by<span class="pl-k">-</span>hundred<span class="pl-k">:</span>                     <span class="pl-c1">0.191497048</span>
Take at Beginning<span class="pl-k">:</span>                      <span class="pl-c1">0.20445405967500002</span>
Pre<span class="pl-k">-</span>made Rands<span class="pl-k">:</span>                         <span class="pl-c1">0.16260088565</span>
Chunked Rands Premade<span class="pl-k">:</span>                  <span class="pl-c1">0.1032136674</span>
Chunked Rands <span class="pl-c1">10000</span> buffer<span class="pl-k">:</span>             <span class="pl-c1">0.10846818174999999</span>
Chunked Rands Direct<span class="pl-k">:</span>                   <span class="pl-c1">0.134752111825</span>
Chunked Rands Max buffer<span class="pl-k">:</span>               <span class="pl-c1">0.120411857925</span>
Parallel Chunked Rands <span class="pl-c1">10000</span> buffer<span class="pl-k">:</span>    <span class="pl-c1">0.1276476319</span></pre></div>
</article></div>