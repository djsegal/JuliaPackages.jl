<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-bijectorsjl" class="anchor" aria-hidden="true" href="#bijectorsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Bijectors.jl</h1>
<p dir="auto"><a href="https://turinglang.github.io/Bijectors.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/TuringLang/Bijectors.jl/actions?query=workflow%3A%22Interface+tests%22+branch%3Amaster"><img src="https://github.com/TuringLang/Bijectors.jl/workflows/Interface%20tests/badge.svg?branch=master" alt="Interface tests" style="max-width: 100%;"></a>
<a href="https://github.com/TuringLang/Bijectors.jl/actions?query=workflow%3A%22AD+tests%22+branch%3Amaster"><img src="https://github.com/TuringLang/Bijectors.jl/workflows/AD%20tests/badge.svg?branch=master" alt="AD tests" style="max-width: 100%;"></a></p>
<p dir="auto">This package implements a set of functions for transforming constrained random variables (e.g. simplexes, intervals) to Euclidean space. The 3 main functions implemented in this package are the <code>link</code>, <code>invlink</code> and <code>logpdf_with_trans</code> for a number of distributions. The distributions supported are:</p>
<ol dir="auto">
<li><code>RealDistribution</code>: <code>Union{Cauchy, Gumbel, Laplace, Logistic, NoncentralT, Normal, NormalCanon, TDist}</code>,</li>
<li><code>PositiveDistribution</code>: <code>Union{BetaPrime, Chi, Chisq, Erlang, Exponential, FDist, Frechet, Gamma, InverseGamma, InverseGaussian, Kolmogorov, LogNormal, NoncentralChisq, NoncentralF, Rayleigh, Weibull}</code>,</li>
<li><code>UnitDistribution</code>: <code>Union{Beta, KSOneSided, NoncentralBeta}</code>,</li>
<li><code>SimplexDistribution</code>: <code>Union{Dirichlet}</code>,</li>
<li><code>PDMatDistribution</code>: <code>Union{InverseWishart, Wishart}</code>, and</li>
<li><code>TransformDistribution</code>: <code>Union{T, Truncated{T}} where T&lt;:ContinuousUnivariateDistribution</code>.</li>
</ol>
<p dir="auto">All exported names from the <a href="https://github.com/TuringLang/Bijectors.jl">Distributions.jl</a> package are reexported from <code>Bijectors</code>.</p>
<p dir="auto">Bijectors.jl also provides a nice interface for working with these maps: composition, inversion, etc.
The following table lists mathematical operations for a bijector and the corresponding code in Bijectors.jl.</p>
<table>
<thead>
<tr>
<th align="center">Operation</th>
<th align="center">Method</th>
<th align="center">Automatic</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>b ↦ b⁻¹</code></td>
<td align="center"><code>inverse(b)</code></td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center"><code>(b₁, b₂) ↦ (b₁ ∘ b₂)</code></td>
<td align="center"><code>b₁ ∘ b₂</code></td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center"><code>(b₁, b₂) ↦ [b₁, b₂]</code></td>
<td align="center"><code>stack(b₁, b₂)</code></td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center"><code>x ↦ b(x)</code></td>
<td align="center"><code>b(x)</code></td>
<td align="center">×</td>
</tr>
<tr>
<td align="center"><code>y ↦ b⁻¹(y)</code></td>
<td align="center"><code>inverse(b)(y)</code></td>
<td align="center">×</td>
</tr>
<tr>
<td align="center"><code>x ↦ log｜det J(b, x)｜</code></td>
<td align="center"><code>logabsdetjac(b, x)</code></td>
<td align="center">AD</td>
</tr>
<tr>
<td align="center"><code>x ↦ b(x), log｜det J(b, x)｜</code></td>
<td align="center"><code>with_logabsdet_jacobian(b, x)</code></td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center"><code>p ↦ q := b_* p</code></td>
<td align="center"><code>q = transformed(p, b)</code></td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center"><code>y ∼ q</code></td>
<td align="center"><code>y = rand(q)</code></td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center"><code>p ↦ b</code> such that <code>support(b_* p) = ℝᵈ</code></td>
<td align="center"><code>bijector(p)</code></td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center"><code>(x ∼ p, b(x), log｜det J(b, x)｜, log q(y))</code></td>
<td align="center"><code>forward(q)</code></td>
<td align="center">✓</td>
</tr>
</tbody>
</table>
<p dir="auto">In this table, <code>b</code> denotes a <code>Bijector</code>, <code>J(b, x)</code> denotes the Jacobian of <code>b</code> evaluated at <code>x</code>, <code>b_*</code> denotes the <a href="https://www.wikiwand.com/en/Pushforward_measure" rel="nofollow">push-forward</a> of <code>p</code> by <code>b</code>, and <code>x ∼ p</code> denotes <code>x</code> sampled from the distribution with density <code>p</code>.</p>
<p dir="auto">The "Automatic" column in the table refers to whether or not you are required to implement the feature for a custom <code>Bijector</code>. "AD" refers to the fact that this can be implemented "automatically" using automatic differentiation, e.g. ForwardDiff.jl.</p>
<h2 dir="auto"><a id="user-content-functions" class="anchor" aria-hidden="true" href="#functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Functions</h2>
<ol dir="auto">
<li><code>link</code>: maps a sample of a random distribution <code>dist</code> from its support to a value in ℝⁿ. Example:</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Bijectors

julia&gt; dist = Beta(2, 2)
Beta{Float64}(α=2.0, β=2.0)

julia&gt; x = rand(dist)
0.7472542331020509

julia&gt; y = link(dist, x)
1.084021356473311"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Bijectors

julia<span class="pl-k">&gt;</span> dist <span class="pl-k">=</span> <span class="pl-c1">Beta</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">Beta</span><span class="pl-c1">{Float64}</span>(α<span class="pl-k">=</span><span class="pl-c1">2.0</span>, β<span class="pl-k">=</span><span class="pl-c1">2.0</span>)

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(dist)
<span class="pl-c1">0.7472542331020509</span>

julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">link</span>(dist, x)
<span class="pl-c1">1.084021356473311</span></pre></div>
<ol start="2" dir="auto">
<li><code>invlink</code>: the inverse of the <code>link</code> function. Example:</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; z = invlink(dist, y)
0.7472542331020509

julia&gt; x ≈ z
true"><pre>julia<span class="pl-k">&gt;</span> z <span class="pl-k">=</span> <span class="pl-c1">invlink</span>(dist, y)
<span class="pl-c1">0.7472542331020509</span>

julia<span class="pl-k">&gt;</span> x <span class="pl-k">≈</span> z
<span class="pl-c1">true</span></pre></div>
<ol start="3" dir="auto">
<li><code>logpdf_with_trans</code>: finds <code>log</code> of the (transformed) probability density function of a distribution <code>dist</code> at a sample <code>x</code>. Example:</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Bijectors

julia&gt; dist = Dirichlet(2, 3)
Dirichlet{Float64}(alpha=[3.0, 3.0])

julia&gt; x = rand(dist)
2-element Array{Float64,1}:
 0.46094823621110165
 0.5390517637888984

julia&gt; logpdf_with_trans(dist, x, false) # ignoring the transformation
0.6163709733893024

julia&gt; logpdf_with_trans(dist, x, true) # considering the transformation
-0.7760422307471244"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Bijectors

julia<span class="pl-k">&gt;</span> dist <span class="pl-k">=</span> <span class="pl-c1">Dirichlet</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
<span class="pl-c1">Dirichlet</span><span class="pl-c1">{Float64}</span>(alpha<span class="pl-k">=</span>[<span class="pl-c1">3.0</span>, <span class="pl-c1">3.0</span>])

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(dist)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.46094823621110165</span>
 <span class="pl-c1">0.5390517637888984</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf_with_trans</span>(dist, x, <span class="pl-c1">false</span>) <span class="pl-c"><span class="pl-c">#</span> ignoring the transformation</span>
<span class="pl-c1">0.6163709733893024</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf_with_trans</span>(dist, x, <span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">#</span> considering the transformation</span>
<span class="pl-k">-</span><span class="pl-c1">0.7760422307471244</span></pre></div>
<h2 dir="auto"><a id="user-content-bijector-interface" class="anchor" aria-hidden="true" href="#bijector-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>Bijector</code> interface</h2>
<p dir="auto">A <code>Bijector</code> is a differentiable bijection with a differentiable inverse. That's basically it.</p>
<p dir="auto">The primary application of <code>Bijector</code>s is the (very profitable) business of transforming (usually continuous) probability densities. If we transfrom a random variable <code>x ~ p(x)</code> to <code>y = b(x)</code> where <code>b</code> is a <code>Bijector</code>, we also get a canonical density <code>q(y) = p(b⁻¹(y)) |det J(b⁻¹, y)|</code> for <code>y</code>. Here <code>J(b⁻¹, y)</code> is the Jacobian of the inverse transform evaluated at <code>y</code>. <code>q</code> is also known as the <em>push-forward</em> of <code>p</code> by <code>b</code> in measure theory.</p>
<p dir="auto">There's plenty of different reasons why one would want to do something like this. It can be because your <code>p</code> has non-zero probability (support) on a closed interval <code>[a, b]</code> and you want to use AD without having to worry about reaching the boundary. E.g. <code>Beta</code> has support <code>[0, 1]</code> so if we could transform <code>p = Beta</code> into a density <code>q</code> with support on ℝ, we could instead compute the derivative of <code>logpdf(q, y)</code> wrt. <code>y</code>, and then transform back <code>x = b⁻¹(y)</code>. This is very useful for certain inference methods, e.g. Hamiltonian Monte-Carlo, where we need to take the derivative of the logpdf-computation wrt. input.</p>
<p dir="auto">Another use-case is constructing a <em>parameterized</em> <code>Bijector</code> and consider transforming a "simple" density, e.g. <code>MvNormal</code>, to match a more complex density. One class of such bijectors is <em>Normalizing Flows (NFs)</em> which are compositions of differentiable and invertible neural networks, i.e. composition of a particular family of parameterized bijectors.[1] We'll see an example of this later on.</p>
<h3 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic usage</h3>
<p dir="auto">Other than the <code>logpdf_with_trans</code> methods, the package also provides a more composable interface through the <code>Bijector</code> types. Consider for example the one from above with <code>Beta(2, 2)</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Random; Random.seed!(42);

julia&gt; using Bijectors; using Bijectors: Logit

julia&gt; dist = Beta(2, 2)
Beta{Float64}(α=2.0, β=2.0)

julia&gt; x = rand(dist)
0.36888689965963756

julia&gt; b = bijector(dist) # bijection (0, 1) → ℝ
Logit{Float64}(0.0, 1.0)

julia&gt; y = b(x)
-0.5369949942509267"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Random; Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">42</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Bijectors; <span class="pl-k">using</span> Bijectors<span class="pl-k">:</span> Logit

julia<span class="pl-k">&gt;</span> dist <span class="pl-k">=</span> <span class="pl-c1">Beta</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">Beta</span><span class="pl-c1">{Float64}</span>(α<span class="pl-k">=</span><span class="pl-c1">2.0</span>, β<span class="pl-k">=</span><span class="pl-c1">2.0</span>)

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(dist)
<span class="pl-c1">0.36888689965963756</span>

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">bijector</span>(dist) <span class="pl-c"><span class="pl-c">#</span> bijection (0, 1) → ℝ</span>
<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)

julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">b</span>(x)
<span class="pl-k">-</span><span class="pl-c1">0.5369949942509267</span></pre></div>
<p dir="auto">In this case we see that <code>bijector(d::Distribution)</code> returns the corresponding constrained-to-unconstrained bijection for <code>Beta</code>, which indeed is a <code>Logit</code> with <code>a = 0.0</code> and <code>b = 1.0</code>. The resulting <code>Logit &lt;: Bijector</code> has a method <code>(b::Logit)(x)</code> defined, allowing us to call it just like any other function. Comparing with the above example, <code>b(x) ≈ link(dist, x)</code>. Just to convince ourselves:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; b(x) ≈ link(dist, x)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">b</span>(x) <span class="pl-k">≈</span> <span class="pl-c1">link</span>(dist, x)
<span class="pl-c1">true</span></pre></div>
<h4 dir="auto"><a id="user-content-inversion" class="anchor" aria-hidden="true" href="#inversion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Inversion</h4>
<p dir="auto">What about <code>invlink</code>?</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; b⁻¹ = inverse(b)
Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0))

julia&gt; b⁻¹(y)
0.3688868996596376

julia&gt; b⁻¹(y) ≈ invlink(dist, y)
true"><pre>julia<span class="pl-k">&gt;</span> b⁻¹ <span class="pl-k">=</span> <span class="pl-c1">inverse</span>(b)
<span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">b⁻¹</span>(y)
<span class="pl-c1">0.3688868996596376</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">b⁻¹</span>(y) <span class="pl-k">≈</span> <span class="pl-c1">invlink</span>(dist, y)
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Pretty neat, huh? <code>Inverse{Logit}</code> is also a <code>Bijector</code> where we've defined <code>(ib::Inverse{&lt;:Logit})(y)</code> as the inverse transformation of <code>(b::Logit)(x)</code>. Note that it's not always the case that <code>inverse(b) isa Inverse</code>, e.g. the inverse of <code>Exp</code> is simply <code>Log</code> so <code>inverse(Exp()) isa Log</code> is true.</p>
<h4 dir="auto"><a id="user-content-composition" class="anchor" aria-hidden="true" href="#composition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Composition</h4>
<p dir="auto">Also, we can <em>compose</em> bijectors:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; id_y = (b ∘ b⁻¹)
Composed{Tuple{Inverse{Logit{Float64},0},Logit{Float64}},0}((Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0)), Logit{Float64}(0.0, 1.0)))

julia&gt; id_y(y) ≈ y
true"><pre>julia<span class="pl-k">&gt;</span> id_y <span class="pl-k">=</span> (b <span class="pl-k">∘</span> b⁻¹)
Composed{Tuple{Inverse{Logit{Float64},<span class="pl-c1">0</span>},Logit{Float64}},<span class="pl-c1">0</span>}((<span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)), <span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">id_y</span>(y) <span class="pl-k">≈</span> y
<span class="pl-c1">true</span></pre></div>
<p dir="auto">And since <code>Composed isa Bijector</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; id_x = inverse(id_y)
Composed{Tuple{Inverse{Logit{Float64},0},Logit{Float64}},0}((Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0)), Logit{Float64}(0.0, 1.0)))

julia&gt; id_x(x) ≈ x
true"><pre>julia<span class="pl-k">&gt;</span> id_x <span class="pl-k">=</span> <span class="pl-c1">inverse</span>(id_y)
Composed{Tuple{Inverse{Logit{Float64},<span class="pl-c1">0</span>},Logit{Float64}},<span class="pl-c1">0</span>}((<span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)), <span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">id_x</span>(x) <span class="pl-k">≈</span> x
<span class="pl-c1">true</span></pre></div>
<h4 dir="auto"><a id="user-content-logpdf-of-transformeddistribution" class="anchor" aria-hidden="true" href="#logpdf-of-transformeddistribution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>logpdf</code> of <code>TransformedDistribution</code></h4>
<p dir="auto">Thus far, we've seen that we can replicate the functionality provided by <code>link</code> and <code>invlink</code>. To replicate <code>logpdf_with_trans</code> we instead provide a <code>TransformedDistribution &lt;: Distribution</code> implementing the <code>Distribution</code> interface from Distributions.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Bijectors: TransformedDistribution

julia&gt; td = transformed(dist)
TransformedDistribution{Beta{Float64},Logit{Float64},Univariate}(
dist: Beta{Float64}(α=2.0, β=2.0)
transform: Logit{Float64}(0.0, 1.0)
)


julia&gt; td isa UnivariateDistribution
true

julia&gt; logpdf(td, y)
-1.123311289915276

julia&gt; logpdf_with_trans(dist, x, true)
-1.123311289915276"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Bijectors<span class="pl-k">:</span> TransformedDistribution

julia<span class="pl-k">&gt;</span> td <span class="pl-k">=</span> <span class="pl-c1">transformed</span>(dist)
<span class="pl-c1">TransformedDistribution</span><span class="pl-c1">{Beta{Float64},Logit{Float64},Univariate}</span>(
dist<span class="pl-k">:</span> <span class="pl-c1">Beta</span><span class="pl-c1">{Float64}</span>(α<span class="pl-k">=</span><span class="pl-c1">2.0</span>, β<span class="pl-k">=</span><span class="pl-c1">2.0</span>)
transform<span class="pl-k">:</span> <span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)
)


julia<span class="pl-k">&gt;</span> td <span class="pl-k">isa</span> UnivariateDistribution
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf</span>(td, y)
<span class="pl-k">-</span><span class="pl-c1">1.123311289915276</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf_with_trans</span>(dist, x, <span class="pl-c1">true</span>)
<span class="pl-k">-</span><span class="pl-c1">1.123311289915276</span></pre></div>
<p dir="auto">When computing <code>logpdf(td, y)</code> where <code>td</code> is the <em>transformed</em> distribution corresponding to <code>Beta(2, 2)</code>, it makes more semantic sense to compute the pdf of the <em>transformed</em> variable <code>y</code> rather than using the "un-transformed" variable <code>x</code> to do so, as we do in <code>logpdf_with_trans</code>. With that being said, we can also do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; logpdf_forward(td, x)
-1.123311289915276"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf_forward</span>(td, x)
<span class="pl-k">-</span><span class="pl-c1">1.123311289915276</span></pre></div>
<h4 dir="auto"><a id="user-content-logabsdetjac-and-with_logabsdet_jacobian" class="anchor" aria-hidden="true" href="#logabsdetjac-and-with_logabsdet_jacobian"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>logabsdetjac</code> and <code>with_logabsdet_jacobian</code></h4>
<p dir="auto">In the computation of both <code>logpdf</code> and <code>logpdf_forward</code> we need to compute <code>log(abs(det(jacobian(inverse(b), y))))</code> and <code>log(abs(det(jacobian(b, x))))</code>, respectively. This computation is available using the <code>logabsdetjac</code> method</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; logabsdetjac(b⁻¹, y)
-1.4575353795716655

julia&gt; logabsdetjac(b, x)
1.4575353795716655"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">logabsdetjac</span>(b⁻¹, y)
<span class="pl-k">-</span><span class="pl-c1">1.4575353795716655</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logabsdetjac</span>(b, x)
<span class="pl-c1">1.4575353795716655</span></pre></div>
<p dir="auto">Notice that</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; logabsdetjac(b, x) ≈ -logabsdetjac(b⁻¹, y)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">logabsdetjac</span>(b, x) <span class="pl-k">≈</span> <span class="pl-k">-</span><span class="pl-c1">logabsdetjac</span>(b⁻¹, y)
<span class="pl-c1">true</span></pre></div>
<p dir="auto">which is always the case for a differentiable bijection with differentiable inverse. Therefore if you want to compute <code>logabsdetjac(b⁻¹, y)</code> and we know that <code>logabsdetjac(b, b⁻¹(y))</code> is actually more efficient, we'll return <code>-logabsdetjac(b, b⁻¹(y))</code> instead. For some bijectors it might be easy to compute, say, the forward pass <code>b(x)</code>, but expensive to compute <code>b⁻¹(y)</code>. Because of this you might want to avoid doing anything "backwards", i.e. using <code>b⁻¹</code>. This is where <code>with_logabsdet_jacobian</code> comes to good use:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; with_logabsdet_jacobian(b, x)
(-0.5369949942509267, 1.4575353795716655)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">with_logabsdet_jacobian</span>(b, x)
(<span class="pl-k">-</span><span class="pl-c1">0.5369949942509267</span>, <span class="pl-c1">1.4575353795716655</span>)</pre></div>
<p dir="auto">Similarily</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; with_logabsdet_jacobian(inverse(b), y)
(0.3688868996596376, -1.4575353795716655)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">with_logabsdet_jacobian</span>(<span class="pl-c1">inverse</span>(b), y)
(<span class="pl-c1">0.3688868996596376</span>, <span class="pl-k">-</span><span class="pl-c1">1.4575353795716655</span>)</pre></div>
<p dir="auto">In fact, the purpose of <code>with_logabsdet_jacobian</code> is to just <em>do the right thing</em>, not necessarily "forward". In this function we'll have access to both the original value <code>x</code> and the transformed value <code>y</code>, so we can compute <code>logabsdetjac(b, x)</code> in either direction. Furthermore, in a lot of cases we can re-use a lot of the computation from <code>b(x)</code> in the computation of <code>logabsdetjac(b, x)</code>, or vice-versa. <code>with_logabsdet_jacobian(b, x)</code> will take advantage of such opportunities (if implemented).</p>
<h4 dir="auto"><a id="user-content-sampling-from-transformeddistribution" class="anchor" aria-hidden="true" href="#sampling-from-transformeddistribution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sampling from <code>TransformedDistribution</code></h4>
<p dir="auto">At this point we've only shown that we can replicate the existing functionality. But we said <code>TransformedDistribution isa Distribution</code>, so we also have <code>rand</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; y = rand(td)              # ∈ ℝ
0.999166054552483

julia&gt; x = inverse(td.transform)(y)  # transform back to interval [0, 1]
0.7308945834125756"><pre>julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(td)              <span class="pl-c"><span class="pl-c">#</span> ∈ ℝ</span>
<span class="pl-c1">0.999166054552483</span>

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">inverse</span>(td<span class="pl-k">.</span>transform)(y)  <span class="pl-c"><span class="pl-c">#</span> transform back to interval [0, 1]</span>
<span class="pl-c1">0.7308945834125756</span></pre></div>
<p dir="auto">This can be quite convenient if you have computations assuming input to be on the real line.</p>
<h4 dir="auto"><a id="user-content-univariate-advi-example" class="anchor" aria-hidden="true" href="#univariate-advi-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Univariate ADVI example</h4>
<p dir="auto">But the real utility of <code>TransformedDistribution</code> becomes more apparent when using <code>transformed(dist, b)</code> for any bijector <code>b</code>. To get the transformed distribution corresponding to the <code>Beta(2, 2)</code>, we called <code>transformed(dist)</code> before. This is simply an alias for <code>transformed(dist, bijector(dist))</code>. Remember <code>bijector(dist)</code> returns the constrained-to-constrained bijector for that particular <code>Distribution</code>. But we can of course construct a <code>TransformedDistribution</code> using different bijectors with the same <code>dist</code>. This is particularly useful in something called <em>Automatic Differentiation Variational Inference (ADVI)</em>.[2] An important part of ADVI is to approximate a constrained distribution, e.g. <code>Beta</code>, as follows:</p>
<ol dir="auto">
<li>Sample <code>x</code> from a <code>Normal</code> with parameters <code>μ</code> and <code>σ</code>, i.e. <code>x ~ Normal(μ, σ)</code>.</li>
<li>Transform <code>x</code> to <code>y</code> s.t. <code>y ∈ support(Beta)</code>, with the transform being a differentiable bijection with a differentiable inverse (a "bijector")</li>
</ol>
<p dir="auto">This then defines a probability density with same <em>support</em> as <code>Beta</code>! Of course, it's unlikely that it will be the same density, but it's an <em>approximation</em>. Creating such a distribution becomes trivial with <code>Bijector</code> and <code>TransformedDistribution</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; dist = Beta(2, 2)
Beta{Float64}(α=2.0, β=2.0)

julia&gt; b = bijector(dist)              # (0, 1) → ℝ
Logit{Float64}(0.0, 1.0)

julia&gt; b⁻¹ = inverse(b)                    # ℝ → (0, 1)
Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0))

julia&gt; td = transformed(Normal(), b⁻¹) # x ∼ 𝓝(0, 1) then b(x) ∈ (0, 1)
TransformedDistribution{Normal{Float64},Inverse{Logit{Float64},0},Univariate}(
dist: Normal{Float64}(μ=0.0, σ=1.0)
transform: Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0))
)


julia&gt; x = rand(td)                    # ∈ (0, 1)
0.538956748141868"><pre>julia<span class="pl-k">&gt;</span> dist <span class="pl-k">=</span> <span class="pl-c1">Beta</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">Beta</span><span class="pl-c1">{Float64}</span>(α<span class="pl-k">=</span><span class="pl-c1">2.0</span>, β<span class="pl-k">=</span><span class="pl-c1">2.0</span>)

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">bijector</span>(dist)              <span class="pl-c"><span class="pl-c">#</span> (0, 1) → ℝ</span>
<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)

julia<span class="pl-k">&gt;</span> b⁻¹ <span class="pl-k">=</span> <span class="pl-c1">inverse</span>(b)                    <span class="pl-c"><span class="pl-c">#</span> ℝ → (0, 1)</span>
<span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>))

julia<span class="pl-k">&gt;</span> td <span class="pl-k">=</span> <span class="pl-c1">transformed</span>(<span class="pl-c1">Normal</span>(), b⁻¹) <span class="pl-c"><span class="pl-c">#</span> x ∼ 𝓝(0, 1) then b(x) ∈ (0, 1)</span>
<span class="pl-c1">TransformedDistribution</span><span class="pl-c1">{Normal{Float64},Inverse{Logit{Float64},0},Univariate}</span>(
dist<span class="pl-k">:</span> <span class="pl-c1">Normal</span><span class="pl-c1">{Float64}</span>(μ<span class="pl-k">=</span><span class="pl-c1">0.0</span>, σ<span class="pl-k">=</span><span class="pl-c1">1.0</span>)
transform<span class="pl-k">:</span> <span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>))
)


julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(td)                    <span class="pl-c"><span class="pl-c">#</span> ∈ (0, 1)</span>
<span class="pl-c1">0.538956748141868</span></pre></div>
<p dir="auto">It's worth noting that <code>support(Beta)</code> is the <em>closed</em> interval <code>[0, 1]</code>, while the constrained-to-unconstrained bijection, <code>Logit</code> in this case, is only well-defined as a map <code>(0, 1) → ℝ</code> for the <em>open</em> interval <code>(0, 1)</code>. This is of course not an implementation detail. <code>ℝ</code> is itself open, thus no continuous bijection exists from a <em>closed</em> interval to <code>ℝ</code>. But since the boundaries of a closed interval has what's known as measure zero, this doesn't end up affecting the resulting density with support on the entire real line. In practice, this means that</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="td = transformed(Beta())

inverse(td.transform)(rand(td))"><pre>td <span class="pl-k">=</span> <span class="pl-c1">transformed</span>(<span class="pl-c1">Beta</span>())

<span class="pl-c1">inverse</span>(td<span class="pl-k">.</span>transform)(<span class="pl-c1">rand</span>(td))</pre></div>
<p dir="auto">will never result in <code>0</code> or <code>1</code> though any sample arbitrarily close to either <code>0</code> or <code>1</code> is possible. <em>Disclaimer: numerical accuracy is limited, so you might still see <code>0</code> and <code>1</code> if you're lucky.</em></p>
<h3 dir="auto"><a id="user-content-multivariate-advi-example" class="anchor" aria-hidden="true" href="#multivariate-advi-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multivariate ADVI example</h3>
<p dir="auto">We can also do <em>multivariate</em> ADVI using the <code>Stacked</code> bijector. <code>Stacked</code> gives us a way to combine univariate and/or multivariate bijectors into a singe multivariate bijector. Say you have a vector <code>x</code> of length 2 and you want to transform the first entry using <code>Exp</code> and the second entry using <code>Log</code>. <code>Stacked</code> gives you an easy and efficient way of representing such a bijector.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Random.seed!(42);

julia&gt; using Bijectors: Exp, Log, SimplexBijector

julia&gt; # Original distributions
       dists = (
           Beta(),
           InverseGamma(),
           Dirichlet(2, 3)
       );

julia&gt; # Construct the corresponding ranges
       ranges = [];

julia&gt; idx = 1;

julia&gt; for i = 1:length(dists)
           d = dists[i]
           push!(ranges, idx:idx + length(d) - 1)

           global idx
           idx += length(d)
       end;

julia&gt; ranges
3-element Array{Any,1}:
 1:1
 2:2
 3:4

julia&gt; # Base distribution; mean-field normal
       num_params = ranges[end][end]
4

julia&gt; d = MvNormal(zeros(num_params), ones(num_params))
DiagNormal(
dim: 4
μ: [0.0, 0.0, 0.0, 0.0]
Σ: [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]
)


julia&gt; # Construct the transform
       bs = bijector.(dists)     # constrained-to-unconstrained bijectors for dists
(Logit{Float64}(0.0, 1.0), Log{0}(), SimplexBijector{true}())

julia&gt; ibs = inverse.(bs)            # invert, so we get unconstrained-to-constrained
(Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0)), Exp{0}(), Inverse{SimplexBijector{true},1}(SimplexBijector{true}()))

julia&gt; sb = Stacked(ibs, ranges) # =&gt; Stacked &lt;: Bijector
Stacked{Tuple{Inverse{Logit{Float64},0},Exp{0},Inverse{SimplexBijector{true},1}},3}((Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0)), Exp{0}(), Inverse{SimplexBijector{true},1}(SimplexBijector{true}())), (1:1, 2:2, 3:4))

julia&gt; # Mean-field normal with unconstrained-to-constrained stacked bijector
       td = transformed(d, sb);

julia&gt; y = rand(td)
4-element Array{Float64,1}:
 0.36446726136766217
 0.6412195576273355 
 0.5067884173521743 
 0.4932115826478257 

julia&gt; 0.0 ≤ y[1] ≤ 1.0   # =&gt; true
true

julia&gt; 0.0 &lt; y[2]         # =&gt; true
true

julia&gt; sum(y[3:4]) ≈ 1.0  # =&gt; true
true"><pre>julia<span class="pl-k">&gt;</span> Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">42</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Bijectors<span class="pl-k">:</span> Exp, Log, SimplexBijector

julia<span class="pl-k">&gt;</span> <span class="pl-c"><span class="pl-c">#</span> Original distributions</span>
       dists <span class="pl-k">=</span> (
           <span class="pl-c1">Beta</span>(),
           <span class="pl-c1">InverseGamma</span>(),
           <span class="pl-c1">Dirichlet</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
       );

julia<span class="pl-k">&gt;</span> <span class="pl-c"><span class="pl-c">#</span> Construct the corresponding ranges</span>
       ranges <span class="pl-k">=</span> [];

julia<span class="pl-k">&gt;</span> idx <span class="pl-k">=</span> <span class="pl-c1">1</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(dists)
           d <span class="pl-k">=</span> dists[i]
           <span class="pl-c1">push!</span>(ranges, idx<span class="pl-k">:</span>idx <span class="pl-k">+</span> <span class="pl-c1">length</span>(d) <span class="pl-k">-</span> <span class="pl-c1">1</span>)

           <span class="pl-k">global</span> idx
           idx <span class="pl-k">+=</span> <span class="pl-c1">length</span>(d)
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> ranges
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>
 <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>
 <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c"><span class="pl-c">#</span> Base distribution; mean-field normal</span>
       num_params <span class="pl-k">=</span> ranges[<span class="pl-c1">end</span>][<span class="pl-c1">end</span>]
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> d <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">zeros</span>(num_params), <span class="pl-c1">ones</span>(num_params))
<span class="pl-c1">DiagNormal</span>(
dim<span class="pl-k">:</span> <span class="pl-c1">4</span>
μ: [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>]
Σ: [<span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span>]
)


julia<span class="pl-k">&gt;</span> <span class="pl-c"><span class="pl-c">#</span> Construct the transform</span>
       bs <span class="pl-k">=</span> <span class="pl-c1">bijector</span>.(dists)     <span class="pl-c"><span class="pl-c">#</span> constrained-to-unconstrained bijectors for dists</span>
(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>), <span class="pl-c1">Log</span><span class="pl-c1">{0}</span>(), <span class="pl-c1">SimplexBijector</span><span class="pl-c1">{true}</span>())

julia<span class="pl-k">&gt;</span> ibs <span class="pl-k">=</span> <span class="pl-c1">inverse</span>.(bs)            <span class="pl-c"><span class="pl-c">#</span> invert, so we get unconstrained-to-constrained</span>
(<span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)), <span class="pl-c1">Exp</span><span class="pl-c1">{0}</span>(), <span class="pl-c1">Inverse</span><span class="pl-c1">{SimplexBijector{true},1}</span>(<span class="pl-c1">SimplexBijector</span><span class="pl-c1">{true}</span>()))

julia<span class="pl-k">&gt;</span> sb <span class="pl-k">=</span> <span class="pl-c1">Stacked</span>(ibs, ranges) <span class="pl-c"><span class="pl-c">#</span> =&gt; Stacked &lt;: Bijector</span>
Stacked{Tuple{Inverse{Logit{Float64},<span class="pl-c1">0</span>},Exp{<span class="pl-c1">0</span>},Inverse{SimplexBijector{<span class="pl-c1">true</span>},<span class="pl-c1">1</span>}},<span class="pl-c1">3</span>}((<span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)), <span class="pl-c1">Exp</span><span class="pl-c1">{0}</span>(), <span class="pl-c1">Inverse</span><span class="pl-c1">{SimplexBijector{true},1}</span>(<span class="pl-c1">SimplexBijector</span><span class="pl-c1">{true}</span>())), (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">4</span>))

julia<span class="pl-k">&gt;</span> <span class="pl-c"><span class="pl-c">#</span> Mean-field normal with unconstrained-to-constrained stacked bijector</span>
       td <span class="pl-k">=</span> <span class="pl-c1">transformed</span>(d, sb);

julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(td)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.36446726136766217</span>
 <span class="pl-c1">0.6412195576273355</span> 
 <span class="pl-c1">0.5067884173521743</span> 
 <span class="pl-c1">0.4932115826478257</span> 

julia<span class="pl-k">&gt;</span> <span class="pl-c1">0.0</span> <span class="pl-k">≤</span> y[<span class="pl-c1">1</span>] <span class="pl-k">≤</span> <span class="pl-c1">1.0</span>   <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">0.0</span> <span class="pl-k">&lt;</span> y[<span class="pl-c1">2</span>]         <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(y[<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">4</span>]) <span class="pl-k">≈</span> <span class="pl-c1">1.0</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">true</span></pre></div>
<h3 dir="auto"><a id="user-content-normalizing-flows" class="anchor" aria-hidden="true" href="#normalizing-flows"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Normalizing flows</h3>
<p dir="auto">A very interesting application is that of <em>normalizing flows</em>.[1] Usually this is done by sampling from a multivariate normal distribution, and then transforming this to a target distribution using invertible neural networks. Currently there are two such transforms available in Bijectors.jl: <code>PlanarLayer</code> and <code>RadialLayer</code>. Let's create a flow with a single <code>PlanarLayer</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; d = MvNormal(zeros(2), ones(2));

julia&gt; b = PlanarLayer(2)
PlanarLayer{Array{Float64,2},Array{Float64,1}}([1.77786; -1.1449], [-0.468606; 0.156143], [-2.64199])

julia&gt; flow = transformed(d, b)
TransformedDistribution{MvNormal{Float64,PDMats.PDiagMat{Float64,Array{Float64,1}},Array{Float64,1}},PlanarLayer{Array{Float64,2},Array{Float64,1}},Multivariate}(
dist: DiagNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 1.0]
)

transform: PlanarLayer{Array{Float64,2},Array{Float64,1}}([1.77786; -1.1449], [-0.468606; 0.156143], [-2.64199])
)


julia&gt; flow isa MultivariateDistribution
true"><pre>julia<span class="pl-k">&gt;</span> d <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">2</span>), <span class="pl-c1">ones</span>(<span class="pl-c1">2</span>));

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">PlanarLayer</span>(<span class="pl-c1">2</span>)
<span class="pl-c1">PlanarLayer</span><span class="pl-c1">{Array{Float64,2},Array{Float64,1}}</span>([<span class="pl-c1">1.77786</span>; <span class="pl-k">-</span><span class="pl-c1">1.1449</span>], [<span class="pl-k">-</span><span class="pl-c1">0.468606</span>; <span class="pl-c1">0.156143</span>], [<span class="pl-k">-</span><span class="pl-c1">2.64199</span>])

julia<span class="pl-k">&gt;</span> flow <span class="pl-k">=</span> <span class="pl-c1">transformed</span>(d, b)
TransformedDistribution{MvNormal{Float64,PDMats<span class="pl-k">.</span>PDiagMat{Float64,Array{Float64,<span class="pl-c1">1</span>}},Array{Float64,<span class="pl-c1">1</span>}},PlanarLayer{Array{Float64,<span class="pl-c1">2</span>},Array{Float64,<span class="pl-c1">1</span>}},Multivariate}(
dist<span class="pl-k">:</span> <span class="pl-c1">DiagNormal</span>(
dim<span class="pl-k">:</span> <span class="pl-c1">2</span>
μ: [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>]
Σ: [<span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span>]
)

transform<span class="pl-k">:</span> <span class="pl-c1">PlanarLayer</span><span class="pl-c1">{Array{Float64,2},Array{Float64,1}}</span>([<span class="pl-c1">1.77786</span>; <span class="pl-k">-</span><span class="pl-c1">1.1449</span>], [<span class="pl-k">-</span><span class="pl-c1">0.468606</span>; <span class="pl-c1">0.156143</span>], [<span class="pl-k">-</span><span class="pl-c1">2.64199</span>])
)


julia<span class="pl-k">&gt;</span> flow <span class="pl-k">isa</span> MultivariateDistribution
<span class="pl-c1">true</span></pre></div>
<p dir="auto">That's it. Now we can sample from it using <code>rand</code> and compute the <code>logpdf</code>, like any other <code>Distribution</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; y = rand(flow)
2-element Array{Float64,1}:
 1.3337915588180933
 1.010861989639227 

julia&gt; logpdf(flow, y)         # uses inverse of `b`
-2.8996106373788293

julia&gt; x = rand(flow.dist)
2-element Array{Float64,1}:
 0.18702790710363  
 0.5181487878771377

julia&gt; logpdf_forward(flow, x) # more efficent and accurate
-1.9813114667203335"><pre>julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(flow)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1.3337915588180933</span>
 <span class="pl-c1">1.010861989639227</span> 

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf</span>(flow, y)         <span class="pl-c"><span class="pl-c">#</span> uses inverse of `b`</span>
<span class="pl-k">-</span><span class="pl-c1">2.8996106373788293</span>

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(flow<span class="pl-k">.</span>dist)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.18702790710363</span>  
 <span class="pl-c1">0.5181487878771377</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf_forward</span>(flow, x) <span class="pl-c"><span class="pl-c">#</span> more efficent and accurate</span>
<span class="pl-k">-</span><span class="pl-c1">1.9813114667203335</span></pre></div>
<p dir="auto">Similarily to the multivariate ADVI example, we could use <code>Stacked</code> to get a <em>bounded</em> flow:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; d = MvNormal(zeros(2), ones(2));

julia&gt; ibs = inverse.(bijector.((InverseGamma(2, 3), Beta())));

julia&gt; sb = stack(ibs...) # == Stacked(ibs) == Stacked(ibs, [i:i for i = 1:length(ibs)]
Stacked{Tuple{Exp{0},Inverse{Logit{Float64},0}},2}((Exp{0}(), Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0))), (1:1, 2:2))

julia&gt; b = sb ∘ PlanarLayer(2)
Composed{Tuple{PlanarLayer{Array{Float64,2},Array{Float64,1}},Stacked{Tuple{Exp{0},Inverse{Logit{Float64},0}},2}},1}((PlanarLayer{Array{Float64,2},Array{Float64,1}}([1.49138; 0.367563], [-0.886205; 0.684565], [-1.59058]), Stacked{Tuple{Exp{0},Inverse{Logit{Float64},0}},2}((Exp{0}(), Inverse{Logit{Float64},0}(Logit{Float64}(0.0, 1.0))), (1:1, 2:2))))

julia&gt; td = transformed(d, b);

julia&gt; y = rand(td)
2-element Array{Float64,1}:
 2.6493626783431035
 0.1833391433092443

julia&gt; 0 &lt; y[1]
true

julia&gt; 0 ≤ y[2] ≤ 1
true"><pre>julia<span class="pl-k">&gt;</span> d <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">2</span>), <span class="pl-c1">ones</span>(<span class="pl-c1">2</span>));

julia<span class="pl-k">&gt;</span> ibs <span class="pl-k">=</span> <span class="pl-c1">inverse</span>.(<span class="pl-c1">bijector</span>.((<span class="pl-c1">InverseGamma</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>), <span class="pl-c1">Beta</span>())));

julia<span class="pl-k">&gt;</span> sb <span class="pl-k">=</span> <span class="pl-c1">stack</span>(ibs<span class="pl-k">...</span>) <span class="pl-c"><span class="pl-c">#</span> == Stacked(ibs) == Stacked(ibs, [i:i for i = 1:length(ibs)]</span>
Stacked{Tuple{Exp{<span class="pl-c1">0</span>},Inverse{Logit{Float64},<span class="pl-c1">0</span>}},<span class="pl-c1">2</span>}((<span class="pl-c1">Exp</span><span class="pl-c1">{0}</span>(), <span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>))), (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>))

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> sb <span class="pl-k">∘</span> <span class="pl-c1">PlanarLayer</span>(<span class="pl-c1">2</span>)
Composed{Tuple{PlanarLayer{Array{Float64,<span class="pl-c1">2</span>},Array{Float64,<span class="pl-c1">1</span>}},Stacked{Tuple{Exp{<span class="pl-c1">0</span>},Inverse{Logit{Float64},<span class="pl-c1">0</span>}},<span class="pl-c1">2</span>}},<span class="pl-c1">1</span>}((<span class="pl-c1">PlanarLayer</span><span class="pl-c1">{Array{Float64,2},Array{Float64,1}}</span>([<span class="pl-c1">1.49138</span>; <span class="pl-c1">0.367563</span>], [<span class="pl-k">-</span><span class="pl-c1">0.886205</span>; <span class="pl-c1">0.684565</span>], [<span class="pl-k">-</span><span class="pl-c1">1.59058</span>]), Stacked{Tuple{Exp{<span class="pl-c1">0</span>},Inverse{Logit{Float64},<span class="pl-c1">0</span>}},<span class="pl-c1">2</span>}((<span class="pl-c1">Exp</span><span class="pl-c1">{0}</span>(), <span class="pl-c1">Inverse</span><span class="pl-c1">{Logit{Float64},0}</span>(<span class="pl-c1">Logit</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>))), (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>))))

julia<span class="pl-k">&gt;</span> td <span class="pl-k">=</span> <span class="pl-c1">transformed</span>(d, b);

julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(td)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2.6493626783431035</span>
 <span class="pl-c1">0.1833391433092443</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&lt;</span> y[<span class="pl-c1">1</span>]
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">≤</span> y[<span class="pl-c1">2</span>] <span class="pl-k">≤</span> <span class="pl-c1">1</span>
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Want to fit the flow?</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Tracker

julia&gt; b = PlanarLayer(2, param)                  # construct parameters using `param`
PlanarLayer{TrackedArray{…,Array{Float64,2}},TrackedArray{…,Array{Float64,1}}}([-1.05099; 0.502079] (tracked), [-0.216248; -0.706424] (tracked), [-4.33747] (tracked))

julia&gt; flow = transformed(d, b)
TransformedDistribution{MvNormal{Float64,PDMats.PDiagMat{Float64,Array{Float64,1}},Array{Float64,1}},PlanarLayer{TrackedArray{…,Array{Float64,2}},TrackedArray{…,Array{Float64,1}}},Multivariate}(
dist: DiagNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 1.0]
)

transform: PlanarLayer{TrackedArray{…,Array{Float64,2}},TrackedArray{…,Array{Float64,1}}}([-1.05099; 0.502079] (tracked), [-0.216248; -0.706424] (tracked), [-4.33747] (tracked))
)


julia&gt; rand(flow)
Tracked 2-element Array{Float64,1}:
  0.5992818950827451
 -0.6264187818605164

julia&gt; x = rand(flow.dist)
2-element Array{Float64,1}:
 -0.37240087577993225
  0.36901028455183293

julia&gt; Tracker.back!(logpdf_forward(flow, x), 1.0) # backprob

julia&gt; Tracker.grad(b.w)
2×1 Array{Float64,2}:
 -0.00037431072968105417
  0.0013039074681623036"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Tracker

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">PlanarLayer</span>(<span class="pl-c1">2</span>, param)                  <span class="pl-c"><span class="pl-c">#</span> construct parameters using `param`</span>
<span class="pl-c1">PlanarLayer</span><span class="pl-c1">{TrackedArray{…,Array{Float64,2}},TrackedArray{…,Array{Float64,1}}}</span>([<span class="pl-k">-</span><span class="pl-c1">1.05099</span>; <span class="pl-c1">0.502079</span>] (tracked), [<span class="pl-k">-</span><span class="pl-c1">0.216248</span>; <span class="pl-k">-</span><span class="pl-c1">0.706424</span>] (tracked), [<span class="pl-k">-</span><span class="pl-c1">4.33747</span>] (tracked))

julia<span class="pl-k">&gt;</span> flow <span class="pl-k">=</span> <span class="pl-c1">transformed</span>(d, b)
TransformedDistribution{MvNormal{Float64,PDMats<span class="pl-k">.</span>PDiagMat{Float64,Array{Float64,<span class="pl-c1">1</span>}},Array{Float64,<span class="pl-c1">1</span>}},PlanarLayer{TrackedArray{…,Array{Float64,<span class="pl-c1">2</span>}},TrackedArray{…,Array{Float64,<span class="pl-c1">1</span>}}},Multivariate}(
dist<span class="pl-k">:</span> <span class="pl-c1">DiagNormal</span>(
dim<span class="pl-k">:</span> <span class="pl-c1">2</span>
μ: [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>]
Σ: [<span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span>]
)

transform<span class="pl-k">:</span> <span class="pl-c1">PlanarLayer</span><span class="pl-c1">{TrackedArray{…,Array{Float64,2}},TrackedArray{…,Array{Float64,1}}}</span>([<span class="pl-k">-</span><span class="pl-c1">1.05099</span>; <span class="pl-c1">0.502079</span>] (tracked), [<span class="pl-k">-</span><span class="pl-c1">0.216248</span>; <span class="pl-k">-</span><span class="pl-c1">0.706424</span>] (tracked), [<span class="pl-k">-</span><span class="pl-c1">4.33747</span>] (tracked))
)


julia<span class="pl-k">&gt;</span> <span class="pl-c1">rand</span>(flow)
Tracked <span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
  <span class="pl-c1">0.5992818950827451</span>
 <span class="pl-k">-</span><span class="pl-c1">0.6264187818605164</span>

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(flow<span class="pl-k">.</span>dist)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">0.37240087577993225</span>
  <span class="pl-c1">0.36901028455183293</span>

julia<span class="pl-k">&gt;</span> Tracker<span class="pl-k">.</span><span class="pl-c1">back!</span>(<span class="pl-c1">logpdf_forward</span>(flow, x), <span class="pl-c1">1.0</span>) <span class="pl-c"><span class="pl-c">#</span> backprob</span>

julia<span class="pl-k">&gt;</span> Tracker<span class="pl-k">.</span><span class="pl-c1">grad</span>(b<span class="pl-k">.</span>w)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">1</span> Array{Float64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">0.00037431072968105417</span>
  <span class="pl-c1">0.0013039074681623036</span></pre></div>
<p dir="auto">We can easily create more complex flows by simply doing <code>PlanarLayer(10) ∘ PlanarLayer(10) ∘ RadialLayer(10)</code> and so on.</p>
<p dir="auto">In those cases, it might be useful to use Flux.jl's <code>Flux.params</code> to extract the parameters:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Flux

julia&gt; Flux.params(flow)
Params([[-1.05099; 0.502079] (tracked), [-0.216248; -0.706424] (tracked), [-4.33747] (tracked)])"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Flux

julia<span class="pl-k">&gt;</span> Flux<span class="pl-k">.</span><span class="pl-c1">params</span>(flow)
<span class="pl-c1">Params</span>([[<span class="pl-k">-</span><span class="pl-c1">1.05099</span>; <span class="pl-c1">0.502079</span>] (tracked), [<span class="pl-k">-</span><span class="pl-c1">0.216248</span>; <span class="pl-k">-</span><span class="pl-c1">0.706424</span>] (tracked), [<span class="pl-k">-</span><span class="pl-c1">4.33747</span>] (tracked)])</pre></div>
<p dir="auto">Another useful function is the <code>forward(d::Distribution)</code> method. It is similar to <code>with_logabsdet_jacobian(b::Bijector, x)</code> in the sense that it does a forward pass of the entire process "sample then transform" and returns all the most useful quantities in process using the most efficent computation path.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x, y, logjac, logpdf_y = forward(flow) # sample + transform and returns all the useful quantities in one pass
(x = [-0.839739, 0.169613], y = [-0.810354, 0.963392] (tracked), logabsdetjac = -0.0017416108706436628 (tracked), logpdf = -2.203100286792651 (tracked))"><pre>julia<span class="pl-k">&gt;</span> x, y, logjac, logpdf_y <span class="pl-k">=</span> <span class="pl-c1">forward</span>(flow) <span class="pl-c"><span class="pl-c">#</span> sample + transform and returns all the useful quantities in one pass</span>
(x <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">0.839739</span>, <span class="pl-c1">0.169613</span>], y <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">0.810354</span>, <span class="pl-c1">0.963392</span>] (tracked), logabsdetjac <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0.0017416108706436628</span> (tracked), logpdf <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">2.203100286792651</span> (tracked))</pre></div>
<p dir="auto">This method is for example useful when computing quantities such as the <em>expected lower bound (ELBO)</em> between this transformed distribution and some other joint density. If no analytical expression is available, we have to approximate the ELBO by a Monte Carlo estimate. But one term in the ELBO is the entropy of the base density, which we <em>do</em> know analytically in this case. Using the analytical expression for the entropy and then using a monte carlo estimate for the rest of the terms in the ELBO gives an estimate with lower variance than if we used the monte carlo estimate for the entire expectation.</p>
<h1 dir="auto"><a id="user-content-bibliography" class="anchor" aria-hidden="true" href="#bibliography"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Bibliography</h1>
<ol dir="auto">
<li>Rezende, D. J., &amp; Mohamed, S. (2015). Variational Inference With Normalizing Flows. <a href="https://arxiv.org/abs/1505.05770v6" rel="nofollow">arXiv:1505.05770</a>.</li>
<li>Kucukelbir, A., Tran, D., Ranganath, R., Gelman, A., &amp; Blei, D. M. (2016). Automatic Differentiation Variational Inference. <a href="https://arxiv.org/abs/1603.00788v1" rel="nofollow">arXiv:1603.00788</a>.</li>
</ol>
</article></div>