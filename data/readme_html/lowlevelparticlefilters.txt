<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-lowlevelparticlefilters" class="anchor" aria-hidden="true" href="#lowlevelparticlefilters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LowLevelParticleFilters</h1>
<p><a href="https://travis-ci.org/baggepinnen/LowLevelParticleFilters.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ffe48dadc72a611417aba3682e5d51113ffae291/68747470733a2f2f7472617669732d63692e6f72672f626167676570696e6e656e2f4c6f774c6576656c5061727469636c6546696c746572732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/baggepinnen/LowLevelParticleFilters.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/report.html" rel="nofollow"><img src="https://camo.githubusercontent.com/3816a79c5bbe0176a42ef4e32ace07c6f5c370c0/68747470733a2f2f6a756c696163692e6769746875622e696f2f4e616e6f736f6c646965725265706f7274732f706b676576616c5f6261646765732f4c2f4c6f774c6576656c5061727469636c6546696c746572732e737667" alt="PkgEval" data-canonical-src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/L/LowLevelParticleFilters.svg" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/baggepinnen/LowLevelParticleFilters.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/b9265629b0a9cc1023acefdf1fe257f4c65bad35/68747470733a2f2f636f6465636f762e696f2f67682f626167676570696e6e656e2f4c6f774c6576656c5061727469636c6546696c746572732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/baggepinnen/LowLevelParticleFilters.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>This readme is auto generated from the file <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/src/example_lineargaussian.jl">src/example_lineargaussian.jl</a> using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a></p>
<h1><a id="user-content-types" class="anchor" aria-hidden="true" href="#types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Types</h1>
<p>We provide a number of filter types</p>
<ul>
<li><code>ParticleFilter</code>: This filter is simple to use and assumes that both dynamics noise and measurement noise are additive.</li>
<li><code>AuxiliaryParticleFilter</code>: This filter is identical to <code>ParticleFilter</code>, but uses a slightly different proposal mechanism for new particles.</li>
<li><code>AdvancedParticleFilter</code>: This filter gives you more flexibility, at the expense of having to define a few more functions. More instructions on this type below.</li>
<li><code>KalmanFilter</code>. Is what you would expect. Has the same features as the particle filters, but is restricted to linear dynamics and gaussian noise.</li>
<li><code>UnscentedKalmanFilter</code>. Is also what you would expect. Has almost the same features as the kalman filters, but handle nonlinear dynamics and measurement model, still requires an additive Gaussian noise model.</li>
</ul>
<h1><a id="user-content-functionality" class="anchor" aria-hidden="true" href="#functionality"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functionality</h1>
<ul>
<li>Filtering</li>
<li>Smoothing</li>
<li>Parameter estimation using ML or PMMH (Particle Marginal Metropolis Hastings)</li>
</ul>
<h1><a id="user-content-usage-example" class="anchor" aria-hidden="true" href="#usage-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage example</h1>
<p>This example demostrates how we set up the filters, both PF and KF, for a simple linear system.</p>
<h2><a id="user-content-particle-filter" class="anchor" aria-hidden="true" href="#particle-filter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Particle filter</h2>
<p>Defining a particle filter is straightforward, one must define the distribution of the noise <code>df</code> in the dynamics function, <code>dynamics(x,u)</code> and the noise distribution <code>dg</code> in the measurement function <code>measurement(x)</code>. The distribution of the initial state <code>d0</code> must also be provided. An example for a linear Gaussian system is given below.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> LowLevelParticleFilters, LinearAlgebra, StaticArrays, Distributions, Plots</pre></div>
<p>Define problem</p>
<div class="highlight highlight-source-julia"><pre>n <span class="pl-k">=</span> <span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> Dimension of state</span>
m <span class="pl-k">=</span> <span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> Dimension of input</span>
p <span class="pl-k">=</span> <span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> Dimension of measurements</span>
N <span class="pl-k">=</span> <span class="pl-c1">500</span> <span class="pl-c"><span class="pl-c">#</span> Number of particles</span>

<span class="pl-k">const</span> dg <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(p,<span class="pl-c1">1.0</span>)          <span class="pl-c"><span class="pl-c">#</span> Measurement noise Distribution</span>
<span class="pl-k">const</span> df <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(n,<span class="pl-c1">1.0</span>)          <span class="pl-c"><span class="pl-c">#</span> Dynamics noise Distribution</span>
<span class="pl-k">const</span> d0 <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">randn</span>(n),<span class="pl-c1">2.0</span>)   <span class="pl-c"><span class="pl-c">#</span> Initial state Distribution</span></pre></div>
<p>Define random linear state-space system</p>
<div class="highlight highlight-source-julia"><pre>Tr <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n,n)
<span class="pl-k">const</span> A <span class="pl-k">=</span> <span class="pl-c1">SMatrix</span><span class="pl-c1">{n,n}</span>(Tr<span class="pl-k">*</span><span class="pl-c1">diagm</span>(<span class="pl-c1">0</span><span class="pl-k">=&gt;</span><span class="pl-c1">LinRange</span>(<span class="pl-c1">0.5</span>,<span class="pl-c1">0.95</span>,n))<span class="pl-k">/</span>Tr)
<span class="pl-k">const</span> B <span class="pl-k">=</span> <span class="pl-c1">@SMatrix</span> <span class="pl-c1">randn</span>(n,m)
<span class="pl-k">const</span> C <span class="pl-k">=</span> <span class="pl-c1">@SMatrix</span> <span class="pl-c1">randn</span>(p,n)</pre></div>
<p>The following two functions are required by the filter</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">dynamics</span>(x,u) <span class="pl-k">=</span> A<span class="pl-k">*</span>x <span class="pl-k">.+</span> B<span class="pl-k">*</span>u
<span class="pl-en">measurement</span>(x) <span class="pl-k">=</span> C<span class="pl-k">*</span>x
<span class="pl-en">vecvec_to_mat</span>(x) <span class="pl-k">=</span> <span class="pl-c1">copy</span>(<span class="pl-c1">reduce</span>(hcat, x)<span class="pl-k">'</span>) <span class="pl-c"><span class="pl-c">#</span> Helper function</span></pre></div>
<p>We are now ready to define and use a filter</p>
<div class="highlight highlight-source-julia"><pre>pf <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(N, dynamics, measurement, df, dg, d0)
xs,u,y <span class="pl-k">=</span> <span class="pl-c1">simulate</span>(pf,<span class="pl-c1">100</span>,df) <span class="pl-c"><span class="pl-c">#</span> We can simulate the model that the pf represents</span>
<span class="pl-c1">pf</span>(u[<span class="pl-c1">1</span>], y[<span class="pl-c1">1</span>]) <span class="pl-c"><span class="pl-c">#</span> Perform one filtering step using input u and measurement y</span>
<span class="pl-c1">particles</span>(pf) <span class="pl-c"><span class="pl-c">#</span> Query the filter for particles, try weights(pf) or expweights(pf) as well</span>
x̂ <span class="pl-k">=</span> <span class="pl-c1">weigthed_mean</span>(pf) <span class="pl-c"><span class="pl-c">#</span> using the current state</span></pre></div>
<p>If you want to perform filtering using vectors of inputs and measurements, try any of the functions</p>
<div class="highlight highlight-source-julia"><pre>x,w,we,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(pf, u, y) <span class="pl-c"><span class="pl-c">#</span> Filter whole vectors of signals</span>
x̂,ll <span class="pl-k">=</span> <span class="pl-c1">mean_trajectory</span>(pf, u, y)
<span class="pl-c1">trajectorydensity</span>(pf,x,w,y,xreal<span class="pl-k">=</span>xs)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/trajdens.png"><img src="figs/trajdens.png" alt="window" style="max-width:100%;"></a></p>
<p>To see how the performance varies with the number of particles, we simulate several times. The following code simulates the system and performs filtering using the simulated measuerments. We do this for varying number of time steps and varying number of particles.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">run_test</span>()
    particle_count <span class="pl-k">=</span> [<span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">50</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>, <span class="pl-c1">500</span>, <span class="pl-c1">1000</span>]
    time_steps <span class="pl-k">=</span> [<span class="pl-c1">20</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>]
    RMSE <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">length</span>(particle_count),<span class="pl-c1">length</span>(time_steps)) <span class="pl-c"><span class="pl-c">#</span> Store the RMS errors</span>
    propagated_particles <span class="pl-k">=</span> <span class="pl-c1">0</span>
    t <span class="pl-k">=</span> <span class="pl-c1">@elapsed</span> <span class="pl-k">for</span> (Ti,T) <span class="pl-k">=</span> <span class="pl-c1">enumerate</span>(time_steps)
        <span class="pl-k">for</span> (Ni,N) <span class="pl-k">=</span> <span class="pl-c1">enumerate</span>(particle_count)
            montecarlo_runs <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">maximum</span>(particle_count)<span class="pl-k">*</span><span class="pl-c1">maximum</span>(time_steps) <span class="pl-k">÷</span> T <span class="pl-k">÷</span> N
            E <span class="pl-k">=</span> <span class="pl-c1">sum</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>montecarlo_runs) <span class="pl-k">do</span> mc_run
                pf <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(N, dynamics, measurement, df, dg, d0) <span class="pl-c"><span class="pl-c">#</span> Create filter</span>
                u <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">randn</span>(<span class="pl-c1">2</span>))
                x <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">rand</span>(d0))
                y <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">sample_measurement</span>(pf,x,<span class="pl-c1">1</span>))
                error <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
                <span class="pl-c1">@inbounds</span> <span class="pl-k">for</span> t <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>T<span class="pl-k">-</span><span class="pl-c1">1</span>
                    <span class="pl-c1">pf</span>(u, y) <span class="pl-c"><span class="pl-c">#</span> Update the particle filter</span>
                    x <span class="pl-k">=</span> <span class="pl-c1">dynamics</span>(x,u) <span class="pl-k">+</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">rand</span>(df)) <span class="pl-c"><span class="pl-c">#</span> Simulate the true dynamics and add some noise</span>
                    y <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">sample_measurement</span>(pf,x,t)) <span class="pl-c"><span class="pl-c">#</span> Simulate a measuerment</span>
                    u <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">randn</span>(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> draw a random control input</span>
                    error <span class="pl-k">+=</span> <span class="pl-c1">sum</span>(abs2,x<span class="pl-k">-</span><span class="pl-c1">weigthed_mean</span>(pf))
                <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> t</span>
                <span class="pl-k">√</span>(error<span class="pl-k">/</span>T)
            <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> MC</span>
            RMSE[Ni,Ti] <span class="pl-k">=</span> E<span class="pl-k">/</span>montecarlo_runs
            propagated_particles <span class="pl-k">+=</span> montecarlo_runs<span class="pl-k">*</span>N<span class="pl-k">*</span>T
            <span class="pl-c1">@show</span> N
        <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> N</span>
        <span class="pl-c1">@show</span> T
    <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> T</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Propagated <span class="pl-v">$propagated_particles</span> particles in <span class="pl-v">$t</span> seconds for an average of <span class="pl-v">$(propagated_particles<span class="pl-k">/</span>t<span class="pl-k">/</span><span class="pl-c1">1000</span>)</span> particles per millisecond<span class="pl-pds">"</span></span>)
    <span class="pl-k">return</span> RMSE
<span class="pl-k">end</span>

<span class="pl-c1">@time</span> RMSE <span class="pl-k">=</span> <span class="pl-c1">run_test</span>()</pre></div>
<p>Propagated 8400000 particles in 3.568745383 seconds for an average of 2353.7683691344473 particles per millisecond</p>
<p>We then plot the results</p>
<div class="highlight highlight-source-julia"><pre>time_steps     <span class="pl-k">=</span> [<span class="pl-c1">20</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>]
particle_count <span class="pl-k">=</span> [<span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">50</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>, <span class="pl-c1">500</span>, <span class="pl-c1">1000</span>]
nT             <span class="pl-k">=</span> <span class="pl-c1">length</span>(time_steps)
leg            <span class="pl-k">=</span> <span class="pl-c1">reshape</span>([<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$(time_steps[i])</span> time steps<span class="pl-pds">"</span></span> <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>nT], <span class="pl-c1">1</span>,:)
<span class="pl-c1">plot</span>(particle_count,RMSE,xscale<span class="pl-k">=</span><span class="pl-c1">:log10</span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>RMS errors<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span> Number of particles<span class="pl-pds">"</span></span>, lab<span class="pl-k">=</span>leg)
<span class="pl-c1">gui</span>()</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/rmse.png"><img src="figs/rmse.png" alt="window" style="max-width:100%;"></a></p>
<h1><a id="user-content-smoothing" class="anchor" aria-hidden="true" href="#smoothing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Smoothing</h1>
<p>We also provide a particle smoother, based on forward filtering, backward simulation (FFBS)</p>
<div class="highlight highlight-source-julia"><pre>N     <span class="pl-k">=</span> <span class="pl-c1">2000</span> <span class="pl-c"><span class="pl-c">#</span> Number of particles</span>
T     <span class="pl-k">=</span> <span class="pl-c1">200</span> <span class="pl-c"><span class="pl-c">#</span> Number of time steps</span>
M     <span class="pl-k">=</span> <span class="pl-c1">100</span> <span class="pl-c"><span class="pl-c">#</span> Number of smoothed backwards trajectories</span>
pf    <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(N, dynamics, measurement, df, dg, d0)
du    <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> Control input distribution</span>
x,u,y <span class="pl-k">=</span> <span class="pl-c1">simulate</span>(pf,T,du) <span class="pl-c"><span class="pl-c">#</span> Simulate trajectory using the model in the filter</span>
<span class="pl-en">tosvec</span>(y) <span class="pl-k">=</span> <span class="pl-c1">reinterpret</span>(SVector{<span class="pl-c1">length</span>(y[<span class="pl-c1">1</span>]),Float64}, <span class="pl-c1">reduce</span>(hcat,y))[:] <span class="pl-k">|&gt;</span> copy
x,u,y <span class="pl-k">=</span> <span class="pl-c1">tosvec</span>.((x,u,y))

xb,ll <span class="pl-k">=</span> <span class="pl-c1">smooth</span>(pf, M, u, y) <span class="pl-c"><span class="pl-c">#</span> Sample smooting particles</span>
xbm   <span class="pl-k">=</span> <span class="pl-c1">smoothed_mean</span>(xb)   <span class="pl-c"><span class="pl-c">#</span> Calculate the mean of smoothing trajectories</span>
xbc   <span class="pl-k">=</span> <span class="pl-c1">smoothed_cov</span>(xb)    <span class="pl-c"><span class="pl-c">#</span> And covariance</span>
xbt   <span class="pl-k">=</span> <span class="pl-c1">smoothed_trajs</span>(xb)  <span class="pl-c"><span class="pl-c">#</span> Get smoothing trajectories</span>
xbs   <span class="pl-k">=</span> [<span class="pl-c1">diag</span>(xbc) <span class="pl-k">for</span> xbc <span class="pl-k">in</span> xbc] <span class="pl-k">|&gt;</span> vecvec_to_mat <span class="pl-k">.|</span><span class="pl-k">&gt;</span> sqrt
<span class="pl-c1">plot</span>(xbm<span class="pl-k">'</span>, ribbon<span class="pl-k">=</span><span class="pl-c1">2</span>xbs, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>PF smooth<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot!</span>(<span class="pl-c1">vecvec_to_mat</span>(x), l<span class="pl-k">=</span><span class="pl-c1">:dash</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/smooth.svg"><img src="figs/smooth.svg" alt="window" style="max-width:100%;"></a></p>
<p>We can plot the particles themselves as well</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">plot</span>(<span class="pl-c1">vecvec_to_mat</span>(x), l<span class="pl-k">=</span>(<span class="pl-c1">4</span>,), layout<span class="pl-k">=</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>), show<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c1">scatter!</span>(xbt[<span class="pl-c1">1</span>,:,:]', subplot<span class="pl-k">=</span><span class="pl-c1">1</span>, show<span class="pl-k">=</span><span class="pl-c1">false</span>, m<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">:black</span>, <span class="pl-c1">0.5</span>), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter!</span>(xbt[<span class="pl-c1">2</span>,:,:]', subplot<span class="pl-k">=</span><span class="pl-c1">2</span>, m<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">:black</span>, <span class="pl-c1">0.5</span>), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/smooth.png"><img src="figs/smooth.png" alt="window" style="max-width:100%;"></a></p>
<h1><a id="user-content-kalman-filter" class="anchor" aria-hidden="true" href="#kalman-filter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kalman filter</h1>
<p>A Kalman filter is easily created using the constructor. Many of the functions defined for particle filters, are defined also for Kalman filters, e.g.:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">eye</span>(n) <span class="pl-k">=</span> <span class="pl-c1">Matrix</span><span class="pl-c1">{Float64}</span>(I,n,n)
kf     <span class="pl-k">=</span> <span class="pl-c1">KalmanFilter</span>(A, B, C, <span class="pl-c1">0</span>, <span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), <span class="pl-c1">MvNormal</span>([<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>]))
ukf    <span class="pl-k">=</span> <span class="pl-c1">UnscentedKalmanFilter</span>(dynamics, measurement, <span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), <span class="pl-c1">MvNormal</span>([<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>]))
xf,xt,R,Rt,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> filtered, prediction, pred cov, filter cov, loglik</span>
xT,R,lls <span class="pl-k">=</span> <span class="pl-c1">smooth</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> Smoothed state, smoothed cov, loglik</span></pre></div>
<p>It can also be called in a loop like the <code>pf</code> above</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">for</span> t <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>T
    <span class="pl-c1">kf</span>(u,y) <span class="pl-c"><span class="pl-c">#</span> Performs both correct and predict!!</span>
    <span class="pl-c"><span class="pl-c">#</span> alternatively</span>
    ll <span class="pl-k">+=</span> <span class="pl-c1">correct!</span>(kf, y, t) <span class="pl-c"><span class="pl-c">#</span> Returns loglik</span>
    x   <span class="pl-k">=</span> <span class="pl-c1">state</span>(kf)
    R   <span class="pl-k">=</span> <span class="pl-c1">covariance</span>(kf)
    <span class="pl-c1">predict!</span>(kf, u, t)
<span class="pl-k">end</span></pre></div>
<h1><a id="user-content-troubleshooting" class="anchor" aria-hidden="true" href="#troubleshooting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Troubleshooting</h1>
<p>Tuning a particle filter can be quite the challenge. To assist with this, we provide som visualization tools</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">debugplot</span>(pf,u,y, runall<span class="pl-k">=</span><span class="pl-c1">true</span>, xreal<span class="pl-k">=</span>x) <span class="pl-c"><span class="pl-c">#</span> does not work well with gr() as backend, try pyplot()</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/debugplot.png"><img src="figs/debugplot.png" alt="window" style="max-width:100%;"></a></p>
<div class="highlight highlight-source-julia"><pre>Time     Surviving    Effective nbr of particles
<span class="pl-k">--------------------------------------------------------------</span>
t<span class="pl-k">:</span>     <span class="pl-c1">1</span>   <span class="pl-c1">1.000</span>    <span class="pl-c1">1000.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">2</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">551.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">3</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">453.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">4</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">384.3</span>
t<span class="pl-k">:</span>     <span class="pl-c1">5</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">340.9</span>
t<span class="pl-k">:</span>     <span class="pl-c1">6</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">310.5</span>
t<span class="pl-k">:</span>     <span class="pl-c1">7</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">280.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">8</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">265.9</span></pre></div>
<p>The plot displays all states and all measurements. The heatmap in the background represents the weighted particle distributions per time step. For the measurement sequences, the heatmap represent the distibutions of predicted measurements. The blue dots corresponds to measured values. In this case, we simulated the data and we had access to states as well, if we do not have that, just omit <code>xreal</code>.
You can also manually step through the time-series using</p>
<ul>
<li><code>commandplot(pf,u,y; kwargs...)</code>
For options to the debug plots, see <code>?pplot</code>.</li>
</ul>
<h1><a id="user-content-parameter-estimation" class="anchor" aria-hidden="true" href="#parameter-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parameter estimation</h1>
<p>We provide som basic functionality for maximum likelihood estimation and MAP estimation</p>
<h2><a id="user-content-ml-estimation" class="anchor" aria-hidden="true" href="#ml-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ML estimation</h2>
<p>Plot likelihood as function of the variance of the dynamics noise</p>
<div class="highlight highlight-source-julia"><pre>svec <span class="pl-k">=</span> <span class="pl-c1">exp10</span>.(<span class="pl-c1">LinRange</span>(<span class="pl-k">-</span><span class="pl-c1">1.5</span>,<span class="pl-c1">1.5</span>,<span class="pl-c1">60</span>))
llspf <span class="pl-k">=</span> <span class="pl-c1">map</span>(svec) <span class="pl-k">do</span> s
    df <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(n,s)
    pfs <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(<span class="pl-c1">2000</span>, dynamics, measurement, df, dg, d0)
    <span class="pl-c1">loglik</span>(pfs,u,y)
<span class="pl-k">end</span>
<span class="pl-c1">plot</span>(svec, llspf, xscale<span class="pl-k">=</span><span class="pl-c1">:log10</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Log-likelihood<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Dynamics noise standard deviation<span class="pl-pds">"</span></span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>PF<span class="pl-pds">"</span></span>)
<span class="pl-c1">vline!</span>([svec[<span class="pl-c1">findmax</span>(llspf)[<span class="pl-c1">2</span>]]], l<span class="pl-k">=</span>(<span class="pl-c1">:dash</span>,<span class="pl-c1">:blue</span>), primary<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p>We can do the same with a Kalman filter</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">eye</span>(n) <span class="pl-k">=</span> <span class="pl-c1">Matrix</span><span class="pl-c1">{Float64}</span>(I,n,n)
llskf <span class="pl-k">=</span> <span class="pl-c1">map</span>(svec) <span class="pl-k">do</span> s
    kfs <span class="pl-k">=</span> <span class="pl-c1">KalmanFilter</span>(A, B, C, <span class="pl-c1">0</span>, s<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), d0)
    <span class="pl-c1">loglik</span>(kfs,u,y)
<span class="pl-k">end</span>
<span class="pl-c1">plot!</span>(svec, llskf, yscale<span class="pl-k">=</span><span class="pl-c1">:identity</span>, xscale<span class="pl-k">=</span><span class="pl-c1">:log10</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Kalman<span class="pl-pds">"</span></span>, c<span class="pl-k">=</span><span class="pl-c1">:red</span>)
<span class="pl-c1">vline!</span>([svec[<span class="pl-c1">findmax</span>(llskf)[<span class="pl-c1">2</span>]]], l<span class="pl-k">=</span>(<span class="pl-c1">:dash</span>,<span class="pl-c1">:red</span>), primary<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/svec.png"><img src="figs/svec.png" alt="window" style="max-width:100%;"></a>
as we can see, the result is quite noisy due to the stochastic nature of particle filtering.</p>
<h3><a id="user-content-smoothing-using-kf" class="anchor" aria-hidden="true" href="#smoothing-using-kf"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Smoothing using KF</h3>
<div class="highlight highlight-source-julia"><pre>kf <span class="pl-k">=</span> <span class="pl-c1">KalmanFilter</span>(A, B, C, <span class="pl-c1">0</span>, <span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), <span class="pl-c1">MvNormal</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>))
xf,xh,R,Rt,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> filtered, prediction, pred cov, filter cov, loglik</span>
xT,R,lls <span class="pl-k">=</span> <span class="pl-c1">smooth</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> Smoothed state, smoothed cov, loglik</span></pre></div>
<p>Plot and compare PF and KF</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">plot</span>(<span class="pl-c1">vecvec_to_mat</span>(xT), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Kalman smooth<span class="pl-pds">"</span></span>, layout<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-c1">plot!</span>(xbm<span class="pl-k">'</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>pf smooth<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot!</span>(<span class="pl-c1">vecvec_to_mat</span>(x), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/smoothtrajs.svg"><img src="figs/smoothtrajs.svg" alt="window" style="max-width:100%;"></a></p>
<h2><a id="user-content-map-estiamtion" class="anchor" aria-hidden="true" href="#map-estiamtion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MAP estiamtion</h2>
<p>To solve a MAP estimation problem, we need to define a function that takes a parameter vector and returns a particle filter</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">filter_from_parameters</span>(θ,pf<span class="pl-k">=</span><span class="pl-c1">nothing</span>) <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(N, dynamics, measurement, <span class="pl-c1">MvNormal</span>(n,<span class="pl-c1">exp</span>(θ[<span class="pl-c1">1</span>])), <span class="pl-c1">MvNormal</span>(p,<span class="pl-c1">exp</span>(θ[<span class="pl-c1">2</span>])), d0)</pre></div>
<p>The call to <code>exp</code> on the parameters is so that we can define log-normal priors</p>
<div class="highlight highlight-source-julia"><pre>priors <span class="pl-k">=</span> [<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>),<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)]</pre></div>
<p>Now we call the function <code>log_likelihood_fun</code> that returns a function to be minimized</p>
<div class="highlight highlight-source-julia"><pre>ll <span class="pl-k">=</span> <span class="pl-c1">log_likelihood_fun</span>(filter_from_parameters,priors,u,y)</pre></div>
<p>Since this is a low-dimensional problem, we can plot the LL on a 2d-grid</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">meshgrid</span>(a,b)
    grid_a <span class="pl-k">=</span> [i <span class="pl-k">for</span> i <span class="pl-k">in</span> a, j <span class="pl-k">in</span> b]
    grid_b <span class="pl-k">=</span> [j <span class="pl-k">for</span> i <span class="pl-k">in</span> a, j <span class="pl-k">in</span> b]
    grid_a, grid_b
<span class="pl-k">end</span>
Nv       <span class="pl-k">=</span> <span class="pl-c1">20</span>
v        <span class="pl-k">=</span> <span class="pl-c1">LinRange</span>(<span class="pl-k">-</span><span class="pl-c1">0.7</span>,<span class="pl-c1">1</span>,Nv)
llxy     <span class="pl-k">=</span> (x,y) <span class="pl-k">-&gt;</span> <span class="pl-c1">ll</span>([x;y])
VGx, VGy <span class="pl-k">=</span> <span class="pl-c1">meshgrid</span>(v,v)
VGz      <span class="pl-k">=</span> <span class="pl-c1">llxy</span>.(VGx, VGy)
<span class="pl-c1">heatmap</span>(VGz, xticks<span class="pl-k">=</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>Nv,<span class="pl-c1">round</span>.(v,digits<span class="pl-k">=</span><span class="pl-c1">2</span>)),yticks<span class="pl-k">=</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>Nv,<span class="pl-c1">round</span>.(v,digits<span class="pl-k">=</span><span class="pl-c1">2</span>)), xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>sigma v<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>sigma w<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span> Yes, labels are reversed</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/heatmap.svg"><img src="figs/heatmap.svg" alt="window" style="max-width:100%;"></a></p>
<p>Something seems to be off with this figure as the hottest spot is not really where we would expect it</p>
<p>Optimization of the log likelihood can be done by, e.g., global/black box methods, see <a href="https://github.com/robertfeldt/BlackBoxOptim.jl">BlackBoxOptim.jl</a>. Standard tricks apply, such as performing the parameter search in log-space etc.</p>
<h2><a id="user-content-bayesian-inference-using-pmmh" class="anchor" aria-hidden="true" href="#bayesian-inference-using-pmmh"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bayesian inference using PMMH</h2>
<p>This is pretty cool. We procede like we did for MAP above, but when calling the function <code>metropolis</code>, we will get the entire posterior distribution of the parameter vector, for the small cost of a massive increase in computational cost.</p>
<div class="highlight highlight-source-julia"><pre>N <span class="pl-k">=</span> <span class="pl-c1">1000</span>
<span class="pl-en">filter_from_parameters</span>(θ,pf<span class="pl-k">=</span><span class="pl-c1">nothing</span>) <span class="pl-k">=</span> <span class="pl-c1">AuxiliaryParticleFilter</span>(N, dynamics, measurement, <span class="pl-c1">MvNormal</span>(n,<span class="pl-c1">exp</span>(θ[<span class="pl-c1">1</span>])), <span class="pl-c1">MvNormal</span>(p,<span class="pl-c1">exp</span>(θ[<span class="pl-c1">2</span>])), d0)</pre></div>
<p>The call to <code>exp</code> on the parameters is so that we can define log-normal priors</p>
<div class="highlight highlight-source-julia"><pre>priors <span class="pl-k">=</span> [<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>),<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)]
ll     <span class="pl-k">=</span> <span class="pl-c1">log_likelihood_fun</span>(filter_from_parameters,priors,u,y)
θ₀     <span class="pl-k">=</span> <span class="pl-c1">log</span>.([<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>]) <span class="pl-c"><span class="pl-c">#</span> Starting point</span></pre></div>
<p>We also need to define a function that suggests a new point from the "proposal distribution". This can be pretty much anything, but it has to be symmetric since I was lazy and simplified an equation.</p>
<div class="highlight highlight-source-julia"><pre>draw   <span class="pl-k">=</span> θ <span class="pl-k">-&gt;</span> θ <span class="pl-k">.+</span> <span class="pl-c1">rand</span>(<span class="pl-c1">MvNormal</span>(<span class="pl-c1">0.05</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)))
burnin <span class="pl-k">=</span> <span class="pl-c1">200</span>
<span class="pl-c1">@info</span> <span class="pl-s"><span class="pl-pds">"</span>Starting Metropolis algorithm<span class="pl-pds">"</span></span>
<span class="pl-c1">@time</span> theta, lls <span class="pl-k">=</span> <span class="pl-c1">metropolis</span>(ll, <span class="pl-c1">2000</span>, θ₀, draw) <span class="pl-c"><span class="pl-c">#</span> Run PMMH for 2000  iterations, takes about half a minute on my laptop</span>
thetam <span class="pl-k">=</span> <span class="pl-c1">reduce</span>(hcat, theta)<span class="pl-k">'</span>[burnin<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">end</span>,:] <span class="pl-c"><span class="pl-c">#</span> Build a matrix of the output (was vecofvec)</span>
<span class="pl-c1">histogram</span>(<span class="pl-c1">exp</span>.(thetam), layout<span class="pl-k">=</span>(<span class="pl-c1">3</span>,<span class="pl-c1">1</span>)); <span class="pl-c1">plot!</span>(lls[burnin<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">end</span>], subplot<span class="pl-k">=</span><span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span> Visualize</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/histogram.svg"><img src="figs/histogram.svg" alt="window" style="max-width:100%;"></a></p>
<p>If you are lucky, you can run the above threaded as well. I tried my best to make particle fitlers thread safe with their own rngs etc., but your milage may vary.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@time</span> thetalls <span class="pl-k">=</span> LowLevelParticleFilters<span class="pl-k">.</span><span class="pl-c1">metropolis_threaded</span>(burnin, ll, <span class="pl-c1">500</span>, θ₀, draw)
<span class="pl-c1">histogram</span>(<span class="pl-c1">exp</span>.(thetalls[:,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>]), layout<span class="pl-k">=</span><span class="pl-c1">3</span>)
<span class="pl-c1">plot!</span>(thetalls[:,<span class="pl-c1">3</span>], subplot<span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>
<h1><a id="user-content-advancedparticlefilter" class="anchor" aria-hidden="true" href="#advancedparticlefilter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AdvancedParticleFilter</h1>
<p>The <code>AdvancedParticleFilter</code> type requires you to implement the same functions as the regular <code>ParticleFilter</code>, but in this case you also need to handle sampling from the noise distributions yourself.
The function <code>dynamics</code> must have a method signature like below. It must provide one method that accepts state vector, control vector, time and <code>noise::Bool</code> that indicates whether or not to add noise to the state. If noise should be added, this should be done inside <code>dynamics</code> An example is given below</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">dynamics</span>(x,u,t,noise<span class="pl-k">=</span><span class="pl-c1">false</span>) <span class="pl-c"><span class="pl-c">#</span> It's important that this defaults to false</span>
    x <span class="pl-k">=</span> A<span class="pl-k">*</span>x <span class="pl-k">.+</span> B<span class="pl-k">*</span>u <span class="pl-c"><span class="pl-c">#</span> A simple dynamics model</span>
    <span class="pl-k">if</span> noise
        x <span class="pl-k">+=</span> <span class="pl-c1">rand</span>(df)
    <span class="pl-k">end</span>
    x
<span class="pl-k">end</span></pre></div>
<p>The <code>measurement_likelihood</code> function must have a method accepting state, measurement and time, and returning the log-likelihood of the measurement given the state, a simple example below:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">measurement_likelihood</span>(x,y,t)
    <span class="pl-c1">logpdf</span>(dg, C<span class="pl-k">*</span>x<span class="pl-k">-</span>y) <span class="pl-c"><span class="pl-c">#</span> A simple linear measurement model with normal additive noise</span>
<span class="pl-k">end</span></pre></div>
<p>This gives you very high flexibility. The noise model in either function can, for instance, be a function of the state, something that is not possible for the simple <code>ParticleFilter</code>
To be able to simulate the <code>AdvancedParticleFilter</code> like we did with the simple filter above, the <code>measurement</code> method with the signature <code>measurement(x,t,noise=false)</code> must be available and return a sample measurement given state (and possibly time). For our example measurement model above, this would look like this</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">measurement</span>(x,t,noise<span class="pl-k">=</span><span class="pl-c1">false</span>) <span class="pl-k">=</span> C<span class="pl-k">*</span>x <span class="pl-k">+</span> noise<span class="pl-k">*</span><span class="pl-c1">rand</span>(dg)</pre></div>
<p>We now create the <code>AdvancedParticleFilter</code> and use it in the same way as the other filters:</p>
<div class="highlight highlight-source-julia"><pre>apf <span class="pl-k">=</span> <span class="pl-c1">AdvancedParticleFilter</span>(N, dynamics, measurement, measurement_likelihood, df, d0)
x,w,we,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(apf, u, y)
<span class="pl-c1">trajectorydensity</span>(apf, x, we, y, xreal<span class="pl-k">=</span>xs)</pre></div>
<p>We can even use this type as an AuxiliaryParticleFilter</p>
<div class="highlight highlight-source-julia"><pre>apfa <span class="pl-k">=</span> <span class="pl-c1">AuxiliaryParticleFilter</span>(apf)
x,w,we,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(apfa, u, y)
<span class="pl-c1">trajectorydensity</span>(apfa, x, we, y, xreal<span class="pl-k">=</span>xs)
<span class="pl-c1">dimensiondensity</span>(apfa, x, we, y, <span class="pl-c1">1</span>, xreal<span class="pl-k">=</span>xs) <span class="pl-c"><span class="pl-c">#</span> Same as above, but only plots a single dimension</span></pre></div>
<h1><a id="user-content-high-performance-distributions" class="anchor" aria-hidden="true" href="#high-performance-distributions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>High performance Distributions</h1>
<p>When <code>using LowLevelParticleFilters</code>, a number of methods related to distributions are defined for static arrays, making <code>logpdf</code> etc. faster. We also provide a new kind of distribution: <code>TupleProduct &lt;: MultivariateDistribution</code> that behaves similarly to the <code>Product</code> distribution. The <code>TupleProduct</code> however stores the individual distributions in a tuple, has compile-time known length and supports <code>Mixed &lt;: ValueSupport</code>, meaning that it can be a product of both <code>Continuous</code> and <code>Discrete</code> dimensions, somthing not supported by the standard <code>Product</code>. Example</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> BenchmarkTools, LowLevelParticleFilters, Distributions
dt <span class="pl-k">=</span> <span class="pl-c1">TupleProduct</span>((<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Binomial</span>())) <span class="pl-c"><span class="pl-c">#</span> Mixed value support</span></pre></div>
<p>A small benchmark</p>
<div class="highlight highlight-source-julia"><pre>sv <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">randn</span>(<span class="pl-c1">2</span>)
d <span class="pl-k">=</span> <span class="pl-c1">Product</span>([<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)])
dt <span class="pl-k">=</span> <span class="pl-c1">TupleProduct</span>((<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)))
dm <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>d,<span class="pl-k">$</span>(<span class="pl-c1">Vector</span>(sv))) <span class="pl-c"><span class="pl-c">#</span> 32.449 ns (1 allocation: 32 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>dt,<span class="pl-k">$</span>(<span class="pl-c1">Vector</span>(sv))) <span class="pl-c"><span class="pl-c">#</span> 21.141 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>dm,<span class="pl-k">$</span>(<span class="pl-c1">Vector</span>(sv))) <span class="pl-c"><span class="pl-c">#</span> 48.745 ns (1 allocation: 96 bytes)</span></pre></div>
<p>@btime logpdf($d,$sv) # 22.651 ns (0 allocations: 0 bytes)
@btime logpdf($dt,$sv) # 0.021 ns (0 allocations: 0 bytes)
@btime logpdf($dm,$sv) # 0.021 ns (0 allocations: 0 bytes)
Without loading <code>LowLevelParticleFilters</code>, the timing for the native distributions are the following
<code>@btime logpdf($d,$sv) # 32.621 ns (1 allocation: 32 bytes)</code>
<code>@btime logpdf($dm,$sv) # 46.415 ns (1 allocation: 96 bytes)</code></p>
<p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p>
</article></div>