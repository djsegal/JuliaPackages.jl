<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-lowlevelparticlefilters" class="anchor" aria-hidden="true" href="#lowlevelparticlefilters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>LowLevelParticleFilters</h1>
<p><a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/actions"><img src="https://github.com/baggepinnen/LowLevelParticleFilters.jl/workflows/CI/badge.svg" alt="CI" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/baggepinnen/LowLevelParticleFilters.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/da2f877a783a46b833304ed2dcb7a7ff7e7c908ed919046059b3651518b4b296/68747470733a2f2f636f6465636f762e696f2f67682f626167676570696e6e656e2f4c6f774c6576656c5061727469636c6546696c746572732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/baggepinnen/LowLevelParticleFilters.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>This readme is auto generated from the file <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/src/example_lineargaussian.jl">src/example_lineargaussian.jl</a> using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a></p>
<h1><a id="user-content-types" class="anchor" aria-hidden="true" href="#types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Types</h1>
<p>We provide a number of filter types</p>
<ul>
<li><code>ParticleFilter</code>: This filter is simple to use and assumes that both dynamics noise and measurement noise are additive.</li>
<li><code>AuxiliaryParticleFilter</code>: This filter is identical to <code>ParticleFilter</code>, but uses a slightly different proposal mechanism for new particles.</li>
<li><code>AdvancedParticleFilter</code>: This filter gives you more flexibility, at the expense of having to define a few more functions. More instructions on this type below.</li>
<li><code>KalmanFilter</code>. Is what you would expect. Has the same features as the particle filters, but is restricted to linear dynamics and gaussian noise.</li>
<li><code>UnscentedKalmanFilter</code>. Is also what you would expect. Has almost the same features as the Kalman filters, but handle nonlinear dynamics and measurement model, still requires an additive Gaussian noise model.</li>
</ul>
<h1><a id="user-content-functionality" class="anchor" aria-hidden="true" href="#functionality"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functionality</h1>
<ul>
<li>Filtering</li>
<li>Smoothing</li>
<li>Parameter estimation using ML or PMMH (Particle Marginal Metropolis Hastings)</li>
</ul>
<h1><a id="user-content-usage-example" class="anchor" aria-hidden="true" href="#usage-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage example</h1>
<p>This example demonstrates how we set up the filters, both PF and KF, for a simple linear system.</p>
<h2><a id="user-content-particle-filter" class="anchor" aria-hidden="true" href="#particle-filter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Particle filter</h2>
<p>Defining a particle filter is straightforward, one must define the distribution of the noise <code>df</code> in the dynamics function, <code>dynamics(x,u)</code> and the noise distribution <code>dg</code> in the measurement function <code>measurement(x)</code>. The distribution of the initial state <code>d0</code> must also be provided. An example for a linear Gaussian system is given below.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using LowLevelParticleFilters, LinearAlgebra, StaticArrays, Distributions, Plots
"><pre><span class="pl-k">using</span> LowLevelParticleFilters, LinearAlgebra, StaticArrays, Distributions, Plots</pre></div>
<p>Define problem</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n = 2   # Dimension of state
m = 2   # Dimension of input
p = 2   # Dimension of measurements
N = 500 # Number of particles

const dg = MvNormal(p,1.0)          # Measurement noise Distribution
const df = MvNormal(n,1.0)          # Dynamics noise Distribution
const d0 = MvNormal(randn(n),2.0)   # Initial state Distribution
"><pre>n <span class="pl-k">=</span> <span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> Dimension of state</span>
m <span class="pl-k">=</span> <span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> Dimension of input</span>
p <span class="pl-k">=</span> <span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> Dimension of measurements</span>
N <span class="pl-k">=</span> <span class="pl-c1">500</span> <span class="pl-c"><span class="pl-c">#</span> Number of particles</span>

<span class="pl-k">const</span> dg <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(p,<span class="pl-c1">1.0</span>)          <span class="pl-c"><span class="pl-c">#</span> Measurement noise Distribution</span>
<span class="pl-k">const</span> df <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(n,<span class="pl-c1">1.0</span>)          <span class="pl-c"><span class="pl-c">#</span> Dynamics noise Distribution</span>
<span class="pl-k">const</span> d0 <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">randn</span>(n),<span class="pl-c1">2.0</span>)   <span class="pl-c"><span class="pl-c">#</span> Initial state Distribution</span></pre></div>
<p>Define random linear state-space system</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Tr = randn(n,n)
const A = SMatrix{n,n}(Tr*diagm(0=&gt;LinRange(0.5,0.95,n))/Tr)
const B = @SMatrix randn(n,m)
const C = @SMatrix randn(p,n)
"><pre>Tr <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n,n)
<span class="pl-k">const</span> A <span class="pl-k">=</span> <span class="pl-c1">SMatrix</span><span class="pl-c1">{n,n}</span>(Tr<span class="pl-k">*</span><span class="pl-c1">diagm</span>(<span class="pl-c1">0</span><span class="pl-k">=&gt;</span><span class="pl-c1">LinRange</span>(<span class="pl-c1">0.5</span>,<span class="pl-c1">0.95</span>,n))<span class="pl-k">/</span>Tr)
<span class="pl-k">const</span> B <span class="pl-k">=</span> <span class="pl-c1">@SMatrix</span> <span class="pl-c1">randn</span>(n,m)
<span class="pl-k">const</span> C <span class="pl-k">=</span> <span class="pl-c1">@SMatrix</span> <span class="pl-c1">randn</span>(p,n)</pre></div>
<p>The following two functions are required by the filter</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="dynamics(x,u) = A*x .+ B*u
measurement(x) = C*x
vecvec_to_mat(x) = copy(reduce(hcat, x)') # Helper function
"><pre><span class="pl-en">dynamics</span>(x,u) <span class="pl-k">=</span> A<span class="pl-k">*</span>x <span class="pl-k">.+</span> B<span class="pl-k">*</span>u
<span class="pl-en">measurement</span>(x) <span class="pl-k">=</span> C<span class="pl-k">*</span>x
<span class="pl-en">vecvec_to_mat</span>(x) <span class="pl-k">=</span> <span class="pl-c1">copy</span>(<span class="pl-c1">reduce</span>(hcat, x)<span class="pl-k">'</span>) <span class="pl-c"><span class="pl-c">#</span> Helper function</span></pre></div>
<p>We are now ready to define and use a filter</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="pf = ParticleFilter(N, dynamics, measurement, df, dg, d0)
xs,u,y = simulate(pf,200,df) # We can simulate the model that the pf represents
pf(u[1], y[1]) # Perform one filtering step using input u and measurement y
particles(pf) # Query the filter for particles, try weights(pf) or expweights(pf) as well
x̂ = weigthed_mean(pf) # using the current state
"><pre>pf <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(N, dynamics, measurement, df, dg, d0)
xs,u,y <span class="pl-k">=</span> <span class="pl-c1">simulate</span>(pf,<span class="pl-c1">200</span>,df) <span class="pl-c"><span class="pl-c">#</span> We can simulate the model that the pf represents</span>
<span class="pl-c1">pf</span>(u[<span class="pl-c1">1</span>], y[<span class="pl-c1">1</span>]) <span class="pl-c"><span class="pl-c">#</span> Perform one filtering step using input u and measurement y</span>
<span class="pl-c1">particles</span>(pf) <span class="pl-c"><span class="pl-c">#</span> Query the filter for particles, try weights(pf) or expweights(pf) as well</span>
x̂ <span class="pl-k">=</span> <span class="pl-c1">weigthed_mean</span>(pf) <span class="pl-c"><span class="pl-c">#</span> using the current state</span></pre></div>
<p>If you want to perform filtering using vectors of inputs and measurements, try any of the functions</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="x,w,we,ll = forward_trajectory(pf, u, y) # Filter whole vectors of signals
x̂,ll = mean_trajectory(pf, u, y)
trajectorydensity(pf,x,w,y,xreal=xs)
"><pre>x,w,we,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(pf, u, y) <span class="pl-c"><span class="pl-c">#</span> Filter whole vectors of signals</span>
x̂,ll <span class="pl-k">=</span> <span class="pl-c1">mean_trajectory</span>(pf, u, y)
<span class="pl-c1">trajectorydensity</span>(pf,x,w,y,xreal<span class="pl-k">=</span>xs)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/trajdens.png"><img src="figs/trajdens.png" alt="window" style="max-width:100%;"></a></p>
<p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, you may transform the output particles to <code>Matrix{MonteCarloMeasurements.Particles}</code> with the layout <code>T × n_states</code> using <code>Particles(x,we)</code>. Internally, the particles are then resampled such that they all have unit weight. This is conventient for making use of the <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/#Plotting-1" rel="nofollow">plotting facilities of MonteCarloMeasurements.jl</a>.</p>
<p>For a full usage example, see the benchmark section below or <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/src/example_lineargaussian.jl">example_lineargaussian.jl</a></p>
<h1><a id="user-content-smoothing" class="anchor" aria-hidden="true" href="#smoothing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Smoothing</h1>
<p>We also provide a particle smoother, based on forward filtering, backward simulation (FFBS)</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="N     = 2000 # Number of particles
T     = 200 # Number of time steps
M     = 100 # Number of smoothed backwards trajectories
pf    = ParticleFilter(N, dynamics, measurement, df, dg, d0)
du    = MvNormal(2,1) # Control input distribution
x,u,y = simulate(pf,T,du) # Simulate trajectory using the model in the filter
tosvec(y) = reinterpret(SVector{length(y[1]),Float64}, reduce(hcat,y))[:] |&gt; copy
x,u,y = tosvec.((x,u,y))

xb,ll = smooth(pf, M, u, y) # Sample smooting particles
xbm   = smoothed_mean(xb)   # Calculate the mean of smoothing trajectories
xbc   = smoothed_cov(xb)    # And covariance
xbt   = smoothed_trajs(xb)  # Get smoothing trajectories
xbs   = [diag(xbc) for xbc in xbc] |&gt; vecvec_to_mat .|&gt; sqrt
plot(xbm', ribbon=2xbs, lab=&quot;PF smooth&quot;)
plot!(vecvec_to_mat(x), l=:dash, lab=&quot;True&quot;)
"><pre>N     <span class="pl-k">=</span> <span class="pl-c1">2000</span> <span class="pl-c"><span class="pl-c">#</span> Number of particles</span>
T     <span class="pl-k">=</span> <span class="pl-c1">200</span> <span class="pl-c"><span class="pl-c">#</span> Number of time steps</span>
M     <span class="pl-k">=</span> <span class="pl-c1">100</span> <span class="pl-c"><span class="pl-c">#</span> Number of smoothed backwards trajectories</span>
pf    <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(N, dynamics, measurement, df, dg, d0)
du    <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> Control input distribution</span>
x,u,y <span class="pl-k">=</span> <span class="pl-c1">simulate</span>(pf,T,du) <span class="pl-c"><span class="pl-c">#</span> Simulate trajectory using the model in the filter</span>
<span class="pl-en">tosvec</span>(y) <span class="pl-k">=</span> <span class="pl-c1">reinterpret</span>(SVector{<span class="pl-c1">length</span>(y[<span class="pl-c1">1</span>]),Float64}, <span class="pl-c1">reduce</span>(hcat,y))[:] <span class="pl-k">|&gt;</span> copy
x,u,y <span class="pl-k">=</span> <span class="pl-c1">tosvec</span>.((x,u,y))

xb,ll <span class="pl-k">=</span> <span class="pl-c1">smooth</span>(pf, M, u, y) <span class="pl-c"><span class="pl-c">#</span> Sample smooting particles</span>
xbm   <span class="pl-k">=</span> <span class="pl-c1">smoothed_mean</span>(xb)   <span class="pl-c"><span class="pl-c">#</span> Calculate the mean of smoothing trajectories</span>
xbc   <span class="pl-k">=</span> <span class="pl-c1">smoothed_cov</span>(xb)    <span class="pl-c"><span class="pl-c">#</span> And covariance</span>
xbt   <span class="pl-k">=</span> <span class="pl-c1">smoothed_trajs</span>(xb)  <span class="pl-c"><span class="pl-c">#</span> Get smoothing trajectories</span>
xbs   <span class="pl-k">=</span> [<span class="pl-c1">diag</span>(xbc) <span class="pl-k">for</span> xbc <span class="pl-k">in</span> xbc] <span class="pl-k">|&gt;</span> vecvec_to_mat <span class="pl-k">.|</span><span class="pl-k">&gt;</span> sqrt
<span class="pl-c1">plot</span>(xbm<span class="pl-k">'</span>, ribbon<span class="pl-k">=</span><span class="pl-c1">2</span>xbs, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>PF smooth<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot!</span>(<span class="pl-c1">vecvec_to_mat</span>(x), l<span class="pl-k">=</span><span class="pl-c1">:dash</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/smooth.svg"><img src="figs/smooth.svg" alt="window" style="max-width:100%;"></a></p>
<p>We can plot the particles themselves as well</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="plot(vecvec_to_mat(x), l=(4,), layout=(2,1), show=false)
scatter!(xbt[1,:,:]', subplot=1, show=false, m=(1,:black, 0.5), lab=&quot;&quot;)
scatter!(xbt[2,:,:]', subplot=2, m=(1,:black, 0.5), lab=&quot;&quot;)
"><pre><span class="pl-c1">plot</span>(<span class="pl-c1">vecvec_to_mat</span>(x), l<span class="pl-k">=</span>(<span class="pl-c1">4</span>,), layout<span class="pl-k">=</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>), show<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c1">scatter!</span>(xbt[<span class="pl-c1">1</span>,:,:]', subplot<span class="pl-k">=</span><span class="pl-c1">1</span>, show<span class="pl-k">=</span><span class="pl-c1">false</span>, m<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">:black</span>, <span class="pl-c1">0.5</span>), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter!</span>(xbt[<span class="pl-c1">2</span>,:,:]', subplot<span class="pl-k">=</span><span class="pl-c1">2</span>, m<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">:black</span>, <span class="pl-c1">0.5</span>), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/smooth.png"><img src="figs/smooth.png" alt="window" style="max-width:100%;"></a></p>
<h1><a id="user-content-kalman-filter" class="anchor" aria-hidden="true" href="#kalman-filter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Kalman filter</h1>
<p>A Kalman filter is easily created using the constructor. Many of the functions defined for particle filters, are defined also for Kalman filters, e.g.:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="eye(n) = Matrix{Float64}(I,n,n)
kf     = KalmanFilter(A, B, C, 0, eye(n), eye(p), MvNormal([1.,1.]))
ukf    = UnscentedKalmanFilter(dynamics, measurement, eye(n), eye(p), MvNormal([1.,1.]))
xf,xt,R,Rt,ll = forward_trajectory(kf, u, y) # filtered, prediction, pred cov, filter cov, loglik
xT,R,lls = smooth(kf, u, y) # Smoothed state, smoothed cov, loglik
"><pre><span class="pl-en">eye</span>(n) <span class="pl-k">=</span> <span class="pl-c1">Matrix</span><span class="pl-c1">{Float64}</span>(I,n,n)
kf     <span class="pl-k">=</span> <span class="pl-c1">KalmanFilter</span>(A, B, C, <span class="pl-c1">0</span>, <span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), <span class="pl-c1">MvNormal</span>([<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>]))
ukf    <span class="pl-k">=</span> <span class="pl-c1">UnscentedKalmanFilter</span>(dynamics, measurement, <span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), <span class="pl-c1">MvNormal</span>([<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>]))
xf,xt,R,Rt,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> filtered, prediction, pred cov, filter cov, loglik</span>
xT,R,lls <span class="pl-k">=</span> <span class="pl-c1">smooth</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> Smoothed state, smoothed cov, loglik</span></pre></div>
<p>It can also be called in a loop like the <code>pf</code> above</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="for t = 1:T
    kf(u,y) # Performs both correct and predict!!
    # alternatively
    ll += correct!(kf, y, t) # Returns loglik
    x   = state(kf)
    R   = covariance(kf)
    predict!(kf, u, t)
end
"><pre><span class="pl-k">for</span> t <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>T
    <span class="pl-c1">kf</span>(u,y) <span class="pl-c"><span class="pl-c">#</span> Performs both correct and predict!!</span>
    <span class="pl-c"><span class="pl-c">#</span> alternatively</span>
    ll <span class="pl-k">+=</span> <span class="pl-c1">correct!</span>(kf, y, t) <span class="pl-c"><span class="pl-c">#</span> Returns loglik</span>
    x   <span class="pl-k">=</span> <span class="pl-c1">state</span>(kf)
    R   <span class="pl-k">=</span> <span class="pl-c1">covariance</span>(kf)
    <span class="pl-c1">predict!</span>(kf, u, t)
<span class="pl-k">end</span></pre></div>
<h1><a id="user-content-troubleshooting" class="anchor" aria-hidden="true" href="#troubleshooting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Troubleshooting</h1>
<p>Tuning a particle filter can be quite the challenge. To assist with this, we provide som visualization tools</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="debugplot(pf,u[1:30],y[1:30], runall=true, xreal=x[1:30])
"><pre><span class="pl-c1">debugplot</span>(pf,u[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">30</span>],y[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">30</span>], runall<span class="pl-k">=</span><span class="pl-c1">true</span>, xreal<span class="pl-k">=</span>x[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">30</span>])</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/debugplot.png"><img src="figs/debugplot.png" alt="window" style="max-width:100%;"></a></p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Time     Surviving    Effective nbr of particles
--------------------------------------------------------------
t:     1   1.000    1000.0
t:     2   1.000     551.0
t:     3   1.000     453.0
t:     4   1.000     384.3
t:     5   1.000     340.9
t:     6   1.000     310.5
t:     7   1.000     280.0
t:     8   1.000     265.9
"><pre>Time     Surviving    Effective nbr of particles
<span class="pl-k">--------------------------------------------------------------</span>
t<span class="pl-k">:</span>     <span class="pl-c1">1</span>   <span class="pl-c1">1.000</span>    <span class="pl-c1">1000.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">2</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">551.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">3</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">453.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">4</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">384.3</span>
t<span class="pl-k">:</span>     <span class="pl-c1">5</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">340.9</span>
t<span class="pl-k">:</span>     <span class="pl-c1">6</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">310.5</span>
t<span class="pl-k">:</span>     <span class="pl-c1">7</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">280.0</span>
t<span class="pl-k">:</span>     <span class="pl-c1">8</span>   <span class="pl-c1">1.000</span>     <span class="pl-c1">265.9</span></pre></div>
<p>The plot displays all states and all measurements. The heatmap in the background represents the weighted particle distributions per time step. For the measurement sequences, the heatmap represent the distibutions of predicted measurements. The blue dots corresponds to measured values. In this case, we simulated the data and we had access to states as well, if we do not have that, just omit <code>xreal</code>.
You can also manually step through the time-series using</p>
<ul>
<li><code>commandplot(pf,u,y; kwargs...)</code>
For options to the debug plots, see <code>?pplot</code>.</li>
</ul>
<h1><a id="user-content-parameter-estimation" class="anchor" aria-hidden="true" href="#parameter-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parameter estimation</h1>
<p>We provide som basic functionality for maximum likelihood estimation and MAP estimation</p>
<h2><a id="user-content-ml-estimation" class="anchor" aria-hidden="true" href="#ml-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ML estimation</h2>
<p>Plot likelihood as function of the variance of the dynamics noise</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="svec = exp10.(LinRange(-1.5,1.5,60))
llspf = map(svec) do s
    df = MvNormal(n,s)
    pfs = ParticleFilter(2000, dynamics, measurement, df, dg, d0)
    loglik(pfs,u,y)
end
plot( svec, llspf,
    xscale = :log10,
    title = &quot;Log-likelihood&quot;,
    xlabel = &quot;Dynamics noise standard deviation&quot;,
    lab = &quot;PF&quot;,
)
vline!([svec[findmax(llspf)[2]]], l=(:dash,:blue), primary=false)
"><pre>svec <span class="pl-k">=</span> <span class="pl-c1">exp10</span>.(<span class="pl-c1">LinRange</span>(<span class="pl-k">-</span><span class="pl-c1">1.5</span>,<span class="pl-c1">1.5</span>,<span class="pl-c1">60</span>))
llspf <span class="pl-k">=</span> <span class="pl-c1">map</span>(svec) <span class="pl-k">do</span> s
    df <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(n,s)
    pfs <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(<span class="pl-c1">2000</span>, dynamics, measurement, df, dg, d0)
    <span class="pl-c1">loglik</span>(pfs,u,y)
<span class="pl-k">end</span>
<span class="pl-c1">plot</span>( svec, llspf,
    xscale <span class="pl-k">=</span> <span class="pl-c1">:log10</span>,
    title <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Log-likelihood<span class="pl-pds">"</span></span>,
    xlabel <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Dynamics noise standard deviation<span class="pl-pds">"</span></span>,
    lab <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>PF<span class="pl-pds">"</span></span>,
)
<span class="pl-c1">vline!</span>([svec[<span class="pl-c1">findmax</span>(llspf)[<span class="pl-c1">2</span>]]], l<span class="pl-k">=</span>(<span class="pl-c1">:dash</span>,<span class="pl-c1">:blue</span>), primary<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p>We can do the same with a Kalman filter</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="eye(n) = Matrix{Float64}(I,n,n)
llskf = map(svec) do s
    kfs = KalmanFilter(A, B, C, 0, s^2*eye(n), eye(p), d0)
    loglik(kfs,u,y)
end
plot!(svec, llskf, yscale=:identity, xscale=:log10, lab=&quot;Kalman&quot;, c=:red)
vline!([svec[findmax(llskf)[2]]], l=(:dash,:red), primary=false)
"><pre><span class="pl-en">eye</span>(n) <span class="pl-k">=</span> <span class="pl-c1">Matrix</span><span class="pl-c1">{Float64}</span>(I,n,n)
llskf <span class="pl-k">=</span> <span class="pl-c1">map</span>(svec) <span class="pl-k">do</span> s
    kfs <span class="pl-k">=</span> <span class="pl-c1">KalmanFilter</span>(A, B, C, <span class="pl-c1">0</span>, s<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), d0)
    <span class="pl-c1">loglik</span>(kfs,u,y)
<span class="pl-k">end</span>
<span class="pl-c1">plot!</span>(svec, llskf, yscale<span class="pl-k">=</span><span class="pl-c1">:identity</span>, xscale<span class="pl-k">=</span><span class="pl-c1">:log10</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Kalman<span class="pl-pds">"</span></span>, c<span class="pl-k">=</span><span class="pl-c1">:red</span>)
<span class="pl-c1">vline!</span>([svec[<span class="pl-c1">findmax</span>(llskf)[<span class="pl-c1">2</span>]]], l<span class="pl-k">=</span>(<span class="pl-c1">:dash</span>,<span class="pl-c1">:red</span>), primary<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/svec.png"><img src="figs/svec.png" alt="window" style="max-width:100%;"></a>
as we can see, the result is quite noisy due to the stochastic nature of particle filtering.</p>
<h3><a id="user-content-smoothing-using-kf" class="anchor" aria-hidden="true" href="#smoothing-using-kf"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Smoothing using KF</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="kf = KalmanFilter(A, B, C, 0, eye(n), eye(p), MvNormal(2,1))
xf,xh,R,Rt,ll = forward_trajectory(kf, u, y) # filtered, prediction, pred cov, filter cov, loglik
xT,R,lls = smooth(kf, u, y) # Smoothed state, smoothed cov, loglik
"><pre>kf <span class="pl-k">=</span> <span class="pl-c1">KalmanFilter</span>(A, B, C, <span class="pl-c1">0</span>, <span class="pl-c1">eye</span>(n), <span class="pl-c1">eye</span>(p), <span class="pl-c1">MvNormal</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>))
xf,xh,R,Rt,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> filtered, prediction, pred cov, filter cov, loglik</span>
xT,R,lls <span class="pl-k">=</span> <span class="pl-c1">smooth</span>(kf, u, y) <span class="pl-c"><span class="pl-c">#</span> Smoothed state, smoothed cov, loglik</span></pre></div>
<p>Plot and compare PF and KF</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="plot(vecvec_to_mat(xT), lab=&quot;Kalman smooth&quot;, layout=2)
plot!(xbm', lab=&quot;pf smooth&quot;)
plot!(vecvec_to_mat(x), lab=&quot;true&quot;)
"><pre><span class="pl-c1">plot</span>(<span class="pl-c1">vecvec_to_mat</span>(xT), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Kalman smooth<span class="pl-pds">"</span></span>, layout<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-c1">plot!</span>(xbm<span class="pl-k">'</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>pf smooth<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot!</span>(<span class="pl-c1">vecvec_to_mat</span>(x), lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/smoothtrajs.svg"><img src="figs/smoothtrajs.svg" alt="window" style="max-width:100%;"></a></p>
<h2><a id="user-content-map-estiamtion" class="anchor" aria-hidden="true" href="#map-estiamtion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MAP estiamtion</h2>
<p>To solve a MAP estimation problem, we need to define a function that takes a parameter vector and returns a particle filter</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="filter_from_parameters(θ, pf = nothing) = ParticleFilter(
    N,
    dynamics,
    measurement,
    MvNormal(n, exp(θ[1])),
    MvNormal(p, exp(θ[2])),
    d0,
)
"><pre><span class="pl-en">filter_from_parameters</span>(θ, pf <span class="pl-k">=</span> <span class="pl-c1">nothing</span>) <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(
    N,
    dynamics,
    measurement,
    <span class="pl-c1">MvNormal</span>(n, <span class="pl-c1">exp</span>(θ[<span class="pl-c1">1</span>])),
    <span class="pl-c1">MvNormal</span>(p, <span class="pl-c1">exp</span>(θ[<span class="pl-c1">2</span>])),
    d0,
)</pre></div>
<p>The call to <code>exp</code> on the parameters is so that we can define log-normal priors</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="priors = [Normal(0,2),Normal(0,2)]
"><pre>priors <span class="pl-k">=</span> [<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>),<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)]</pre></div>
<p>Now we call the function <code>log_likelihood_fun</code> that returns a function to be minimized</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ll = log_likelihood_fun(filter_from_parameters,priors,u,y)
"><pre>ll <span class="pl-k">=</span> <span class="pl-c1">log_likelihood_fun</span>(filter_from_parameters,priors,u,y)</pre></div>
<p>Since this is a low-dimensional problem, we can plot the LL on a 2d-grid</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function meshgrid(a,b)
    grid_a = [i for i in a, j in b]
    grid_b = [j for i in a, j in b]
    grid_a, grid_b
end
Nv       = 20
v        = LinRange(-0.7,1,Nv)
llxy     = (x,y) -&gt; ll([x;y])
VGx, VGy = meshgrid(v,v)
VGz      = llxy.(VGx, VGy)
heatmap(
    VGz,
    xticks = (1:Nv, round.(v, digits = 2)),
    yticks = (1:Nv, round.(v, digits = 2)),
    xlabel = &quot;sigma v&quot;,
    ylabel = &quot;sigma w&quot;,
) # Yes, labels are reversed
"><pre><span class="pl-k">function</span> <span class="pl-en">meshgrid</span>(a,b)
    grid_a <span class="pl-k">=</span> [i <span class="pl-k">for</span> i <span class="pl-k">in</span> a, j <span class="pl-k">in</span> b]
    grid_b <span class="pl-k">=</span> [j <span class="pl-k">for</span> i <span class="pl-k">in</span> a, j <span class="pl-k">in</span> b]
    grid_a, grid_b
<span class="pl-k">end</span>
Nv       <span class="pl-k">=</span> <span class="pl-c1">20</span>
v        <span class="pl-k">=</span> <span class="pl-c1">LinRange</span>(<span class="pl-k">-</span><span class="pl-c1">0.7</span>,<span class="pl-c1">1</span>,Nv)
llxy     <span class="pl-k">=</span> (x,y) <span class="pl-k">-&gt;</span> <span class="pl-c1">ll</span>([x;y])
VGx, VGy <span class="pl-k">=</span> <span class="pl-c1">meshgrid</span>(v,v)
VGz      <span class="pl-k">=</span> <span class="pl-c1">llxy</span>.(VGx, VGy)
<span class="pl-c1">heatmap</span>(
    VGz,
    xticks <span class="pl-k">=</span> (<span class="pl-c1">1</span><span class="pl-k">:</span>Nv, <span class="pl-c1">round</span>.(v, digits <span class="pl-k">=</span> <span class="pl-c1">2</span>)),
    yticks <span class="pl-k">=</span> (<span class="pl-c1">1</span><span class="pl-k">:</span>Nv, <span class="pl-c1">round</span>.(v, digits <span class="pl-k">=</span> <span class="pl-c1">2</span>)),
    xlabel <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>sigma v<span class="pl-pds">"</span></span>,
    ylabel <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>sigma w<span class="pl-pds">"</span></span>,
) <span class="pl-c"><span class="pl-c">#</span> Yes, labels are reversed</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/heatmap.svg"><img src="figs/heatmap.svg" alt="window" style="max-width:100%;"></a></p>
<p>Something seems to be off with this figure as the hottest spot is not really where we would expect it</p>
<p>Optimization of the log likelihood can be done by, e.g., global/black box methods, see <a href="https://github.com/robertfeldt/BlackBoxOptim.jl">BlackBoxOptim.jl</a>. Standard tricks apply, such as performing the parameter search in log-space etc.</p>
<h2><a id="user-content-bayesian-inference-using-pmmh" class="anchor" aria-hidden="true" href="#bayesian-inference-using-pmmh"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Bayesian inference using PMMH</h2>
<p>This is pretty cool. We procede like we did for MAP above, but when calling the function <code>metropolis</code>, we will get the entire posterior distribution of the parameter vector, for the small cost of a massive increase in computational cost.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="N = 1000
filter_from_parameters(θ, pf = nothing) = AuxiliaryParticleFilter(
    N,
    dynamics,
    measurement,
    MvNormal(n, exp(θ[1])),
    MvNormal(p, exp(θ[2])),
    d0,
)
"><pre>N <span class="pl-k">=</span> <span class="pl-c1">1000</span>
<span class="pl-en">filter_from_parameters</span>(θ, pf <span class="pl-k">=</span> <span class="pl-c1">nothing</span>) <span class="pl-k">=</span> <span class="pl-c1">AuxiliaryParticleFilter</span>(
    N,
    dynamics,
    measurement,
    <span class="pl-c1">MvNormal</span>(n, <span class="pl-c1">exp</span>(θ[<span class="pl-c1">1</span>])),
    <span class="pl-c1">MvNormal</span>(p, <span class="pl-c1">exp</span>(θ[<span class="pl-c1">2</span>])),
    d0,
)</pre></div>
<p>The call to <code>exp</code> on the parameters is so that we can define log-normal priors</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="priors = [Normal(0,2),Normal(0,2)]
ll     = log_likelihood_fun(filter_from_parameters,priors,u,y)
θ₀     = log.([1.,1.]) # Starting point
"><pre>priors <span class="pl-k">=</span> [<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>),<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)]
ll     <span class="pl-k">=</span> <span class="pl-c1">log_likelihood_fun</span>(filter_from_parameters,priors,u,y)
θ₀     <span class="pl-k">=</span> <span class="pl-c1">log</span>.([<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>]) <span class="pl-c"><span class="pl-c">#</span> Starting point</span></pre></div>
<p>We also need to define a function that suggests a new point from the "proposal distribution". This can be pretty much anything, but it has to be symmetric since I was lazy and simplified an equation.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="draw   = θ -&gt; θ .+ rand(MvNormal(0.05ones(2)))
burnin = 200
@info &quot;Starting Metropolis algorithm&quot;
@time theta, lls = metropolis(ll, 1200, θ₀, draw) # Run PMMH for 1200  iterations, takes about half a minute on my laptop
thetam = reduce(hcat, theta)'[burnin+1:end,:] # Build a matrix of the output (was vecofvec)
histogram(exp.(thetam), layout=(3,1)); plot!(lls[burnin+1:end], subplot=3) # Visualize
"><pre>draw   <span class="pl-k">=</span> θ <span class="pl-k">-&gt;</span> θ <span class="pl-k">.+</span> <span class="pl-c1">rand</span>(<span class="pl-c1">MvNormal</span>(<span class="pl-c1">0.05</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)))
burnin <span class="pl-k">=</span> <span class="pl-c1">200</span>
<span class="pl-c1">@info</span> <span class="pl-s"><span class="pl-pds">"</span>Starting Metropolis algorithm<span class="pl-pds">"</span></span>
<span class="pl-c1">@time</span> theta, lls <span class="pl-k">=</span> <span class="pl-c1">metropolis</span>(ll, <span class="pl-c1">1200</span>, θ₀, draw) <span class="pl-c"><span class="pl-c">#</span> Run PMMH for 1200  iterations, takes about half a minute on my laptop</span>
thetam <span class="pl-k">=</span> <span class="pl-c1">reduce</span>(hcat, theta)<span class="pl-k">'</span>[burnin<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">end</span>,:] <span class="pl-c"><span class="pl-c">#</span> Build a matrix of the output (was vecofvec)</span>
<span class="pl-c1">histogram</span>(<span class="pl-c1">exp</span>.(thetam), layout<span class="pl-k">=</span>(<span class="pl-c1">3</span>,<span class="pl-c1">1</span>)); <span class="pl-c1">plot!</span>(lls[burnin<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">end</span>], subplot<span class="pl-k">=</span><span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span> Visualize</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/histogram.svg"><img src="figs/histogram.svg" alt="window" style="max-width:100%;"></a></p>
<p>If you are lucky, you can run the above threaded as well. I tried my best to make particle fitlers thread safe with their own rngs etc., but your milage may vary.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@time thetalls = LowLevelParticleFilters.metropolis_threaded(burnin, ll, 500, θ₀, draw)
histogram(exp.(thetalls[:,1:2]), layout=3)
plot!(thetalls[:,3], subplot=3)
"><pre><span class="pl-c1">@time</span> thetalls <span class="pl-k">=</span> LowLevelParticleFilters<span class="pl-k">.</span><span class="pl-c1">metropolis_threaded</span>(burnin, ll, <span class="pl-c1">500</span>, θ₀, draw)
<span class="pl-c1">histogram</span>(<span class="pl-c1">exp</span>.(thetalls[:,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>]), layout<span class="pl-k">=</span><span class="pl-c1">3</span>)
<span class="pl-c1">plot!</span>(thetalls[:,<span class="pl-c1">3</span>], subplot<span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>
<h1><a id="user-content-advancedparticlefilter" class="anchor" aria-hidden="true" href="#advancedparticlefilter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>AdvancedParticleFilter</h1>
<p>The <code>AdvancedParticleFilter</code> type requires you to implement the same functions as the regular <code>ParticleFilter</code>, but in this case you also need to handle sampling from the noise distributions yourself.
The function <code>dynamics</code> must have a method signature like below. It must provide one method that accepts state vector, control vector, time and <code>noise::Bool</code> that indicates whether or not to add noise to the state. If noise should be added, this should be done inside <code>dynamics</code> An example is given below</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Random
const rng = Random.MersenneTwister()
function dynamics(x,u,t,noise=false) # It's important that this defaults to false
    x = A*x .+ B*u # A simple dynamics model
    if noise
        x += rand(rng, df) # it's faster to supply your own rng
    end
    x
end
"><pre><span class="pl-k">using</span> Random
<span class="pl-k">const</span> rng <span class="pl-k">=</span> Random<span class="pl-k">.</span><span class="pl-c1">MersenneTwister</span>()
<span class="pl-k">function</span> <span class="pl-en">dynamics</span>(x,u,t,noise<span class="pl-k">=</span><span class="pl-c1">false</span>) <span class="pl-c"><span class="pl-c">#</span> It's important that this defaults to false</span>
    x <span class="pl-k">=</span> A<span class="pl-k">*</span>x <span class="pl-k">.+</span> B<span class="pl-k">*</span>u <span class="pl-c"><span class="pl-c">#</span> A simple dynamics model</span>
    <span class="pl-k">if</span> noise
        x <span class="pl-k">+=</span> <span class="pl-c1">rand</span>(rng, df) <span class="pl-c"><span class="pl-c">#</span> it's faster to supply your own rng</span>
    <span class="pl-k">end</span>
    x
<span class="pl-k">end</span></pre></div>
<p>The <code>measurement_likelihood</code> function must have a method accepting state, measurement and time, and returning the log-likelihood of the measurement given the state, a simple example below:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function measurement_likelihood(x,y,t)
    logpdf(dg, C*x-y) # A simple linear measurement model with normal additive noise
end
"><pre><span class="pl-k">function</span> <span class="pl-en">measurement_likelihood</span>(x,y,t)
    <span class="pl-c1">logpdf</span>(dg, C<span class="pl-k">*</span>x<span class="pl-k">-</span>y) <span class="pl-c"><span class="pl-c">#</span> A simple linear measurement model with normal additive noise</span>
<span class="pl-k">end</span></pre></div>
<p>This gives you very high flexibility. The noise model in either function can, for instance, be a function of the state, something that is not possible for the simple <code>ParticleFilter</code>
To be able to simulate the <code>AdvancedParticleFilter</code> like we did with the simple filter above, the <code>measurement</code> method with the signature <code>measurement(x,t,noise=false)</code> must be available and return a sample measurement given state (and possibly time). For our example measurement model above, this would look like this</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="measurement(x,t,noise=false) = C*x + noise*rand(rng, dg)
"><pre><span class="pl-en">measurement</span>(x,t,noise<span class="pl-k">=</span><span class="pl-c1">false</span>) <span class="pl-k">=</span> C<span class="pl-k">*</span>x <span class="pl-k">+</span> noise<span class="pl-k">*</span><span class="pl-c1">rand</span>(rng, dg)</pre></div>
<p>We now create the <code>AdvancedParticleFilter</code> and use it in the same way as the other filters:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="apf = AdvancedParticleFilter(N, dynamics, measurement, measurement_likelihood, df, d0)
x,w,we,ll = forward_trajectory(apf, u, y)
trajectorydensity(apf, x, we, y, xreal=xs)
"><pre>apf <span class="pl-k">=</span> <span class="pl-c1">AdvancedParticleFilter</span>(N, dynamics, measurement, measurement_likelihood, df, d0)
x,w,we,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(apf, u, y)
<span class="pl-c1">trajectorydensity</span>(apf, x, we, y, xreal<span class="pl-k">=</span>xs)</pre></div>
<p>We can even use this type as an AuxiliaryParticleFilter</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="apfa = AuxiliaryParticleFilter(apf)
x,w,we,ll = forward_trajectory(apfa, u, y)
trajectorydensity(apfa, x, we, y, xreal=xs)
dimensiondensity(apfa, x, we, y, 1, xreal=xs) # Same as above, but only plots a single dimension
"><pre>apfa <span class="pl-k">=</span> <span class="pl-c1">AuxiliaryParticleFilter</span>(apf)
x,w,we,ll <span class="pl-k">=</span> <span class="pl-c1">forward_trajectory</span>(apfa, u, y)
<span class="pl-c1">trajectorydensity</span>(apfa, x, we, y, xreal<span class="pl-k">=</span>xs)
<span class="pl-c1">dimensiondensity</span>(apfa, x, we, y, <span class="pl-c1">1</span>, xreal<span class="pl-k">=</span>xs) <span class="pl-c"><span class="pl-c">#</span> Same as above, but only plots a single dimension</span></pre></div>
<h1><a id="user-content-high-performance-distributions" class="anchor" aria-hidden="true" href="#high-performance-distributions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High performance Distributions</h1>
<p>When <code>using LowLevelParticleFilters</code>, a number of methods related to distributions are defined for static arrays, making <code>logpdf</code> etc. faster. We also provide a new kind of distribution: <code>TupleProduct &lt;: MultivariateDistribution</code> that behaves similarly to the <code>Product</code> distribution. The <code>TupleProduct</code> however stores the individual distributions in a tuple, has compile-time known length and supports <code>Mixed &lt;: ValueSupport</code>, meaning that it can be a product of both <code>Continuous</code> and <code>Discrete</code> dimensions, somthing not supported by the standard <code>Product</code>. Example</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using BenchmarkTools, LowLevelParticleFilters, Distributions
dt = TupleProduct((Normal(0,2), Normal(0,2), Binomial())) # Mixed value support
"><pre><span class="pl-k">using</span> BenchmarkTools, LowLevelParticleFilters, Distributions
dt <span class="pl-k">=</span> <span class="pl-c1">TupleProduct</span>((<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Binomial</span>())) <span class="pl-c"><span class="pl-c">#</span> Mixed value support</span></pre></div>
<p>A small benchmark</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sv = @SVector randn(2)
d = Product([Normal(0,2), Normal(0,2)])
dt = TupleProduct((Normal(0,2), Normal(0,2)))
dm = MvNormal(2, 2)
@btime logpdf($d,$(Vector(sv))) # 32.449 ns (1 allocation: 32 bytes)
@btime logpdf($dt,$(Vector(sv))) # 21.141 ns (0 allocations: 0 bytes)
@btime logpdf($dm,$(Vector(sv))) # 48.745 ns (1 allocation: 96 bytes)
"><pre>sv <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">randn</span>(<span class="pl-c1">2</span>)
d <span class="pl-k">=</span> <span class="pl-c1">Product</span>([<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)])
dt <span class="pl-k">=</span> <span class="pl-c1">TupleProduct</span>((<span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>)))
dm <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>d,<span class="pl-k">$</span>(<span class="pl-c1">Vector</span>(sv))) <span class="pl-c"><span class="pl-c">#</span> 32.449 ns (1 allocation: 32 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>dt,<span class="pl-k">$</span>(<span class="pl-c1">Vector</span>(sv))) <span class="pl-c"><span class="pl-c">#</span> 21.141 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>dm,<span class="pl-k">$</span>(<span class="pl-c1">Vector</span>(sv))) <span class="pl-c"><span class="pl-c">#</span> 48.745 ns (1 allocation: 96 bytes)</span></pre></div>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@btime logpdf($d,$sv) # 22.651 ns (0 allocations: 0 bytes)
@btime logpdf($dt,$sv) # 0.021 ns (0 allocations: 0 bytes)
@btime logpdf($dm,$sv) # 0.021 ns (0 allocations: 0 bytes)
"><pre><span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>d,<span class="pl-k">$</span>sv) <span class="pl-c"><span class="pl-c">#</span> 22.651 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>dt,<span class="pl-k">$</span>sv) <span class="pl-c"><span class="pl-c">#</span> 0.021 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>dm,<span class="pl-k">$</span>sv) <span class="pl-c"><span class="pl-c">#</span> 0.021 ns (0 allocations: 0 bytes)</span></pre></div>
<p>Without loading <code>LowLevelParticleFilters</code>, the timing for the native distributions are the following</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@btime logpdf($d,$sv) # 32.621 ns (1 allocation: 32 bytes)
@btime logpdf($dm,$sv) # 46.415 ns (1 allocation: 96 bytes)
"><pre><span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>d,<span class="pl-k">$</span>sv) <span class="pl-c"><span class="pl-c">#</span> 32.621 ns (1 allocation: 32 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">logpdf</span>(<span class="pl-k">$</span>dm,<span class="pl-k">$</span>sv) <span class="pl-c"><span class="pl-c">#</span> 46.415 ns (1 allocation: 96 bytes)</span></pre></div>
<h1><a id="user-content-benchmark-test" class="anchor" aria-hidden="true" href="#benchmark-test"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benchmark test</h1>
<p>To see how the performance varies with the number of particles, we simulate several times. The following code simulates the system and performs filtering using the simulated measuerments. We do this for varying number of time steps and varying number of particles.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Random
const rng = Random.MersenneTwister()
function run_test()
    particle_count = [10, 20, 50, 100, 200, 500, 1000]
    time_steps = [20, 100, 200]
    RMSE = zeros(length(particle_count),length(time_steps)) # Store the RMS errors
    propagated_particles = 0
    t = @elapsed for (Ti,T) = enumerate(time_steps)
        for (Ni,N) = enumerate(particle_count)
            montecarlo_runs = 2*maximum(particle_count)*maximum(time_steps) ÷ T ÷ N
            E = sum(1:montecarlo_runs) do mc_run
                pf = ParticleFilter(N, dynamics, measurement, df, dg, d0) # Create filter
                u = @SVector randn(2)
                x = SVector{2,Float64}(rand(rng, d0))
                y = SVector{2,Float64}(sample_measurement(pf,x,1))
                error = 0.0
                @inbounds for t = 1:T-1
                    pf(u, y) # Update the particle filter
                    x = dynamics(x,u) + SVector{2,Float64}(rand(rng, df)) # Simulate the true dynamics and add some noise
                    y = SVector{2,Float64}(sample_measurement(pf,x,t)) # Simulate a measuerment
                    u = @SVector randn(2) # draw a random control input
                    error += sum(abs2,x-weigthed_mean(pf))
                end # t
                √(error/T)
            end # MC
            RMSE[Ni,Ti] = E/montecarlo_runs
            propagated_particles += montecarlo_runs*N*T
            @show N
        end # N
        @show T
    end # T
    println(&quot;Propagated $propagated_particles particles in $t seconds for an average of $(propagated_particles/t/1000) particles per millisecond&quot;)
    return RMSE
end

@time RMSE = run_test()
"><pre><span class="pl-k">using</span> Random
<span class="pl-k">const</span> rng <span class="pl-k">=</span> Random<span class="pl-k">.</span><span class="pl-c1">MersenneTwister</span>()
<span class="pl-k">function</span> <span class="pl-en">run_test</span>()
    particle_count <span class="pl-k">=</span> [<span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">50</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>, <span class="pl-c1">500</span>, <span class="pl-c1">1000</span>]
    time_steps <span class="pl-k">=</span> [<span class="pl-c1">20</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>]
    RMSE <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">length</span>(particle_count),<span class="pl-c1">length</span>(time_steps)) <span class="pl-c"><span class="pl-c">#</span> Store the RMS errors</span>
    propagated_particles <span class="pl-k">=</span> <span class="pl-c1">0</span>
    t <span class="pl-k">=</span> <span class="pl-c1">@elapsed</span> <span class="pl-k">for</span> (Ti,T) <span class="pl-k">=</span> <span class="pl-c1">enumerate</span>(time_steps)
        <span class="pl-k">for</span> (Ni,N) <span class="pl-k">=</span> <span class="pl-c1">enumerate</span>(particle_count)
            montecarlo_runs <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">maximum</span>(particle_count)<span class="pl-k">*</span><span class="pl-c1">maximum</span>(time_steps) <span class="pl-k">÷</span> T <span class="pl-k">÷</span> N
            E <span class="pl-k">=</span> <span class="pl-c1">sum</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>montecarlo_runs) <span class="pl-k">do</span> mc_run
                pf <span class="pl-k">=</span> <span class="pl-c1">ParticleFilter</span>(N, dynamics, measurement, df, dg, d0) <span class="pl-c"><span class="pl-c">#</span> Create filter</span>
                u <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">randn</span>(<span class="pl-c1">2</span>)
                x <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">rand</span>(rng, d0))
                y <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">sample_measurement</span>(pf,x,<span class="pl-c1">1</span>))
                error <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
                <span class="pl-c1">@inbounds</span> <span class="pl-k">for</span> t <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>T<span class="pl-k">-</span><span class="pl-c1">1</span>
                    <span class="pl-c1">pf</span>(u, y) <span class="pl-c"><span class="pl-c">#</span> Update the particle filter</span>
                    x <span class="pl-k">=</span> <span class="pl-c1">dynamics</span>(x,u) <span class="pl-k">+</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">rand</span>(rng, df)) <span class="pl-c"><span class="pl-c">#</span> Simulate the true dynamics and add some noise</span>
                    y <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2,Float64}</span>(<span class="pl-c1">sample_measurement</span>(pf,x,t)) <span class="pl-c"><span class="pl-c">#</span> Simulate a measuerment</span>
                    u <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">randn</span>(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> draw a random control input</span>
                    error <span class="pl-k">+=</span> <span class="pl-c1">sum</span>(abs2,x<span class="pl-k">-</span><span class="pl-c1">weigthed_mean</span>(pf))
                <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> t</span>
                <span class="pl-k">√</span>(error<span class="pl-k">/</span>T)
            <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> MC</span>
            RMSE[Ni,Ti] <span class="pl-k">=</span> E<span class="pl-k">/</span>montecarlo_runs
            propagated_particles <span class="pl-k">+=</span> montecarlo_runs<span class="pl-k">*</span>N<span class="pl-k">*</span>T
            <span class="pl-c1">@show</span> N
        <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> N</span>
        <span class="pl-c1">@show</span> T
    <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> T</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Propagated <span class="pl-v">$propagated_particles</span> particles in <span class="pl-v">$t</span> seconds for an average of <span class="pl-v">$(propagated_particles<span class="pl-k">/</span>t<span class="pl-k">/</span><span class="pl-c1">1000</span>)</span> particles per millisecond<span class="pl-pds">"</span></span>)
    <span class="pl-k">return</span> RMSE
<span class="pl-k">end</span>

<span class="pl-c1">@time</span> RMSE <span class="pl-k">=</span> <span class="pl-c1">run_test</span>()</pre></div>
<p>Propagated 8400000 particles in 2.193401766 seconds for an average of 3829.6677472448064 particles per millisecond</p>
<p>We then plot the results</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="time_steps     = [20, 100, 200]
particle_count = [10, 20, 50, 100, 200, 500, 1000]
nT             = length(time_steps)
leg            = reshape([&quot;$(time_steps[i]) time steps&quot; for i = 1:nT], 1,:)
plot(particle_count,RMSE,xscale=:log10, ylabel=&quot;RMS errors&quot;, xlabel=&quot; Number of particles&quot;, lab=leg)
gui()
"><pre>time_steps     <span class="pl-k">=</span> [<span class="pl-c1">20</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>]
particle_count <span class="pl-k">=</span> [<span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">50</span>, <span class="pl-c1">100</span>, <span class="pl-c1">200</span>, <span class="pl-c1">500</span>, <span class="pl-c1">1000</span>]
nT             <span class="pl-k">=</span> <span class="pl-c1">length</span>(time_steps)
leg            <span class="pl-k">=</span> <span class="pl-c1">reshape</span>([<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$(time_steps[i])</span> time steps<span class="pl-pds">"</span></span> <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>nT], <span class="pl-c1">1</span>,:)
<span class="pl-c1">plot</span>(particle_count,RMSE,xscale<span class="pl-k">=</span><span class="pl-c1">:log10</span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>RMS errors<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span> Number of particles<span class="pl-pds">"</span></span>, lab<span class="pl-k">=</span>leg)
<span class="pl-c1">gui</span>()</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/rmse.png"><img src="figs/rmse.png" alt="window" style="max-width:100%;"></a></p>
<hr>
<p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p>
</article></div>