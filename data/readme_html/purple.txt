<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-purplejl" class="anchor" aria-hidden="true" href="#purplejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Purple.jl</h1>
<p align="center">
<a target="_blank" rel="noopener noreferrer" href="assets/turple.png"><img height="200" src="assets/turple.png" style="max-width:100%;"></a>
</p>
<br>
<p>This package implements an interesting staging mechanism in Julia -- for a pure subset of Julia functions, it allows <em>lifting</em> of a function defined by signature <code>f : R -&gt; R</code> to a function defined by signature <code>f : Sym{R} -&gt; Term</code> where <code>Sym{R}</code> is a <a href="https://symbolicutils.juliasymbolics.org/#creating_symbolic_expressions" rel="nofollow">SymbolicUtils.jl value</a> and <code>Term</code> is a <a href="https://symbolicutils.juliasymbolics.org/api/#symbols_and_terms" rel="nofollow">SymbolicUtils.jl term</a>.</p>
<blockquote>
<p>This package is based on the same fundamental idea as <a href="https://github.com/MasonProtter/SymbolicTracing.jl">SymbolicTracing.jl</a> but also exposes levels of granularity in tracing by leveraging the optimizer. In addition, insertion of staging conversion functions is computed during type inference and not runtime expansion of <code>@generated</code> functions.</p>
<p>In the future, parts of this package may move over to <a href="https://github.com/JuliaSymbolics">JuliaSymbolics</a>.</p>
</blockquote>
<h2><a id="user-content-background" class="anchor" aria-hidden="true" href="#background"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Background</h2>
<p>Julia has a wonderfully hackable compiler -- but after type inference, the current pipeline prevents users from exiting and re-entering the pipeline with inferred code. This is for good reason -- unsafe manipulations outside of the context of type inference will invalidate inference and/or otherwise prevent the compiler from ensuring that invariants required by inference hold. Additionally, because the natural place after inference/optimization for code is the runtime cache -- this use case of "leave and go again" is not sufficiently important to warrant careful consideration.</p>
<p>This package is a small attempt to remedy this issue by converting <code>executors</code> (e.g. functions which execute purely and have a natural denotational semantics from some mathematical space to another) into <code>stagers</code> (functions which don't execute normally, but instead create symbolic traces of execution).</p>
<p>Because runtime flows know the types of values which enter into callsites, a <code>stager</code> can create a typed symbolic representation of the runtime flow. This typed symbolic representation can be further compiled by re-emitting <code>Expr</code> instances, or otherwise operated on with the utilities of the <a href="https://juliasymbolics.org/" rel="nofollow">JuliaSymbolics</a> ecosystem.</p>
<p>At least, that's the intent -- as with all speculative compiler packages, this one is bound to have some thorns.</p>
<blockquote>
<p>For users who are familiar with <a href="https://github.com/FluxML/Mjolnir.jl">Mjolnir.jl</a> -- the idea is somewhat similar, except we rely upon Julia's native inference and optimization pipeline (which thus guarantees some modicum of stability).</p>
</blockquote>
<h2><a id="user-content-the-collapse" class="anchor" aria-hidden="true" href="#the-collapse"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Collapse</h2>
<p>This package is inspired by <a href="https://www.cs.purdue.edu/homes/rompf/papers/amin-popl18.pdf" rel="nofollow">Collapsing Towers of Interpreters</a>.</p>
</article></div>