<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-arrayviewsapl" class="anchor" aria-hidden="true" href="#arrayviewsapl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ArrayViewsAPL</h1>
<p><a href="https://travis-ci.org/timholy/ArrayViewsAPL.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/9e3a617d2c39faa2d8ee31d0a04b6db5d26571db/68747470733a2f2f7472617669732d63692e6f72672f74696d686f6c792f4172726179566965777341504c2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/timholy/ArrayViewsAPL.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p>This package is for developing array views based on staged functions, a new technology in Julia 0.4.
Compared to previous efforts, staged functions perform almost all the "work" at compile time,
allowing the results of construction and indexing to reduce to a single-line expression.</p>
<h3><a id="user-content-comparison-to-arrayviews-and-subarrays" class="anchor" aria-hidden="true" href="#comparison-to-arrayviews-and-subarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Comparison to ArrayViews and SubArrays</h3>
<p>This effort is complementary to Dahua Lin's excellent <a href="https://github.com/lindahua/ArrayViews.jl">ArrayViews.jl</a>.
That package's great strength is making linear indexing efficient when the parent is an Array and when the view is contiguous.
The purposes of this package are (1) to handle any <code>AbstractArray</code>, (2) to focus on making cartesian indexing efficient, and
(3) to optionally support slicing (i.e., dropping dimensions indexed with a scalar).</p>
<p>Aside from the differences in applicability and design, both approaches are very efficient.
Compared with ArrayViews, construction of the types here is even faster but linear indexing is not as fast.
An ideal solution would probably be to combine Dahua's ContiguousView type (to be used when applicable) with the approach here.</p>
<p>In base Julia, SubArrays are more general than the types used in ArrayViews, but they have a number of well-known performance problems.
In particular, their generality makes them very slow to construct.
Moreover, <a href="https://github.com/JuliaLang/julia/blob/6b85f4e9129b846a0779d712c3ea33fa99929b36/base/subarray.jl#L194-L205">SubArray indexing is delegated to linear indexing</a>,
which is bad if the parent array type doesn't support efficient linear indexing.
In general, cartesian indexing can be made efficient for a wider variety of array types, which is why that approach is emphasized here.</p>
<h3><a id="user-content-benefits-of-stagedfunctions" class="anchor" aria-hidden="true" href="#benefits-of-stagedfunctions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benefits of stagedfunctions</h3>
<p>As an example of the benefits of staged functions, consider making 2d slices of a 3d array,</p>
<div class="highlight highlight-source-julia"><pre>S1 <span class="pl-k">=</span> <span class="pl-c1">sliceview</span>(A, :, <span class="pl-c1">5</span>, :)
S2 <span class="pl-k">=</span> <span class="pl-c1">sliceview</span>(A, <span class="pl-c1">5</span>, :, :)</pre></div>
<p>For cartesian indexing, the natural approach is to replace <code>S1[i,j]</code> with <code>A[i,5,j]</code> and <code>S2[i,j]</code> with <code>A[5,i,j]</code>.
Doing so without any runtime overhead requires a method of <code>getindex</code> specialized for a <code>View{T,2,typeof(A),(UnitRange{Int},Int,UnitRange{Int})}</code> and a different one for a <code>View{T,2,typeof(A),(Int,UnitRange{Int},UnitRange{Int})}</code>.
One could generate all these methods using loops, but supporting just <code>Int</code>, <code>UnitRange</code>, and <code>StepRange</code> up to dimension 8 would require 3^8 = 6561 pre-generated variants of <code>getindex</code>.
In contrast, staged functions allow all of these to be generated on the fly for arbitrary dimensionality.
This is quite desirable given that any given Julia session is likely to use just a very small fraction of these possible methods.</p>
<h3><a id="user-content-status" class="anchor" aria-hidden="true" href="#status"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Status</h3>
<p>If you're running a recent version of Julia master, this works.</p>
<p>Currently two types of view-creation are supported: <code>subview</code> and <code>sliceview</code>.
<code>subview</code> duplicates Julia's current indexing rules (including dropping trailing dimensions of size 1), and <code>sliceview</code> is aimed at full APL support (currently it behaves analogously to Julia's <code>slice</code>).
See also <a href="https://github.com/JuliaLang/julia/issues/5949">https://github.com/JuliaLang/julia/issues/5949</a>. Use them similarly to Julia's <code>sub</code> and <code>slice</code>.</p>
</article></div>