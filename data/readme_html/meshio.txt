<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-meshio" class="anchor" aria-hidden="true" href="#meshio"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MeshIO</h1>
<p dir="auto"><a href="https://travis-ci.org/JuliaIO/MeshIO.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/2f5616eb68b878309b5b4556cf360e749b1f0479ca42b4832016b83af79d470f/68747470733a2f2f7472617669732d63692e6f72672f4a756c6961494f2f4d657368494f2e6a6c2e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaIO/MeshIO.jl.svg" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/SimonDanisch/meshio-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/f9d378de14babf77541f23dcc6b57cf0e4df88a000689d6655102c82da928c0f/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f64623533666a6e686270316d30626b382f6272616e63682f6d61737465723f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/db53fjnhbp1m0bk8/branch/master?svg=true" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/JuliaIO/MeshIO.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/2358f60d04daa83e5d093e32cd990214a23f4f2afd4ca7b0e877b6cdcf17aebb/687474703a2f2f636f6465636f762e696f2f6769746875622f4a756c6961494f2f4d657368494f2e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/JuliaIO/MeshIO.jl/coverage.svg?branch=master" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/JuliaIO/MeshIO.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/92a41013bd98e61a2134ce7249aa999042cd4069abef7d197295b9963e92ed24/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f4a756c6961494f2f4d657368494f2e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/JuliaIO/MeshIO.jl/badge.svg?branch=master&amp;service=github" style="max-width: 100%;"></a></p>
<p dir="auto">This package supports loading 3D model file formats: <code>obj</code>, <code>stl</code>, <code>ply</code>, <code>off</code> and <code>2DM</code>.
More 3D model formats will be supported in the future.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Enter package mode in the Julia REPL and run the following command:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add FileIO MeshIO"><pre>pkg<span class="pl-k">&gt;</span> add FileIO MeshIO</pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">Loading works over the <a href="https://github.com/JuliaIO/FileIO.jl">FileIO</a> interface.
This means loading a mesh is as simple as this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FileIO
mesh = load(&quot;path/to/mesh.obj&quot;)"><pre><span class="pl-k">using</span> FileIO
mesh <span class="pl-k">=</span> <span class="pl-c1">load</span>(<span class="pl-s"><span class="pl-pds">"</span>path/to/mesh.obj<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Displaying a mesh can be achieved with <a href="https://github.com/JuliaPlots/Makie.jl">Makie</a>.</p>
<p dir="auto">Functions for mesh manipulation can be found in <a href="https://github.com/JuliaGeometry">JuliaGeometry</a></p>
<h2 dir="auto"><a id="user-content-additional-information" class="anchor" aria-hidden="true" href="#additional-information"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Additional Information</h2>
<p dir="auto">MeshIO now has the HomogenousMesh type. Name is still not settled, but it's supposed to be a dense mesh with all attributes either having the length of one (constant over the whole mesh) or the same length (per vertex).
This meshtype holds a large variability for all the different attribute mixtures that I've encountered while trying to visualize things over at GLVisualize. This is the best type I've found so far to encode this large variability, without an explosion of functions.</p>
<p dir="auto">The focus is on conversion between different mesh types and creation of different mesh types.
This has led to some odd seeming design choices.
First, you can get an attribute via <code>decompose(::Type{AttributeType}, ::Mesh)</code>.
This will try to get this attribute, and if it has the wrong type try to convert it, or if it is not available try to create it.
So <code>decompose(Point3{Float32}, mesh)</code> on a mesh with vertices of type <code>Point3{Float64}</code> will return a vector of type <code>Point3{Float32}</code>.
Similarly, if you call <code>decompose(Normal{3, Float32}, mesh)</code> but the mesh doesn't have normals, it will call the function <code>normals(mesh.vertices, mesh.faces, Normal{3, Float32}</code>, which will create the normals for the mesh.
As most attributes are independent, this  enables us to easily create all kinds of conversions.
Also, I can define <code>decompose</code> for arbitrary geometric types.
<code>decompose{T}(Point3{T}, r::Rectangle)</code> can actually return the needed vertices for a rectangle.
This together with <code>convert</code> enables us to create mesh primitives like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="MeshType(Cube(...))
MeshType(Sphere(...))
MeshType(Volume, 0.4f0) #0.4f0 =&gt; isovalue"><pre><span class="pl-c1">MeshType</span>(<span class="pl-c1">Cube</span>(<span class="pl-k">...</span>))
<span class="pl-c1">MeshType</span>(<span class="pl-c1">Sphere</span>(<span class="pl-k">...</span>))
<span class="pl-c1">MeshType</span>(Volume, <span class="pl-c1">0.4f0</span>) <span class="pl-c"><span class="pl-c">#</span>0.4f0 =&gt; isovalue</span></pre></div>
<p dir="auto">Similarly, I can pass a meshtype to an IO function, which then parses only the attributes that I really need.
So passing <code>Mesh{Point3{Float32}, Face3{UInt32}}</code> to the obj importer will skip normals, uv coordinates etc, and automatically converts the given attributes to the right number type.</p>
<p dir="auto">To put this one level further, the <code>Face</code> type has the index offset relative to Julia's indexing as a parameter (e.g. <code>Face3{T, 0}</code> is 1 indexed). Also, you can index into an array with this face type, and it will convert the indexes correctly while accessing the array. So something like this always works, independent of the underlying index offset:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="v1, v2, v3 = vertices[face]"><pre>v1, v2, v3 <span class="pl-k">=</span> vertices[face]</pre></div>
<p dir="auto">Also, the importer is sensitive to this, so if you always want to work with 0-indexed faces (like it makes sense for opengl based visualizations), you can parse the mesh already as an 0-indexed mesh, by just defining the mesh format to use <code>Face3{T, -1}</code>. (only the OBJ importer yet)</p>
<p dir="auto">Small example to demonstrate the advantage for IO:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#Export takes any mesh
function write{M &lt;: Mesh}(msh::M, fn::File{:ply_binary})
    # even if the native mesh format doesn't have an array of dense points or faces, the correct ones will
    # now be created, or converted:
    vts = decompose(Point3{Float32}, msh) # I know ply_binary needs Point3{Float32}
    fcs = decompose(Face3{Int32, -1}, msh) # And 0 indexed Int32 faces.
    #write code...
end"><pre><span class="pl-c"><span class="pl-c">#</span>Export takes any mesh</span>
<span class="pl-k">function</span> <span class="pl-en">write</span><span class="pl-c1">{M &lt;: Mesh}</span>(msh<span class="pl-k">::</span><span class="pl-c1">M</span>, fn<span class="pl-k">::</span><span class="pl-c1">File{:ply_binary}</span>)
    <span class="pl-c"><span class="pl-c">#</span> even if the native mesh format doesn't have an array of dense points or faces, the correct ones will</span>
    <span class="pl-c"><span class="pl-c">#</span> now be created, or converted:</span>
    vts <span class="pl-k">=</span> <span class="pl-c1">decompose</span>(Point3{Float32}, msh) <span class="pl-c"><span class="pl-c">#</span> I know ply_binary needs Point3{Float32}</span>
    fcs <span class="pl-k">=</span> <span class="pl-c1">decompose</span>(Face3{Int32, <span class="pl-k">-</span><span class="pl-c1">1</span>}, msh) <span class="pl-c"><span class="pl-c">#</span> And 0 indexed Int32 faces.</span>
    <span class="pl-c"><span class="pl-c">#</span>write code...</span>
<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-todo" class="anchor" aria-hidden="true" href="#todo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>TODO</h2>
<ol dir="auto">
<li>Port all the other importers/exporters to use the new mesh type and the FileIO API</li>
<li>Include more meshtypes for more exotic formats</li>
<li>Write tests</li>
</ol>
</article></div>