<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-astarsearchjl" class="anchor" aria-hidden="true" href="#astarsearchjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>AStarSearch.jl</h1>
<p dir="auto"><a href="https://github.com/PaoloSarti/AStarSearch.jl/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/PaoloSarti/AStarSearch.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/PaoloSarti/AStarSearch.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/8382203f9499e47a87d494e1fa59fd84a32d0b52d1c60e1ebcd3881af9ebfb39/68747470733a2f2f636f6465636f762e696f2f67682f50616f6c6f53617274692f41537461725365617263682e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d536f3455724164363447" alt="codecov" data-canonical-src="https://codecov.io/gh/PaoloSarti/AStarSearch.jl/branch/main/graph/badge.svg?token=So4UrAd64G" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg" alt="Aqua QA" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="nofollow">A* Algorithm</a> in Julia. Other <a href="https://en.wikipedia.org/wiki/State_space_search" rel="nofollow">State Space Search</a> algorithms are also implemented as a baseline.</p>
<p dir="auto">This package exports the <code>astar</code> function that provides a generic implementation of the algorithm.
The type of the state is totally unrestricted, just provide the functions that give neighbour states and optionally an heuristic given a state and the goal and the algorithm will find the best path.</p>
<p dir="auto">Other implemented and exported functions to explore your state space are also exported: <code>depthfirst</code>, <code>breadthfirst</code>, <code>iterative_deepening</code>. These other functions are intended to be almost a transparent drop in replacement for the <code>astar</code> function, but they won't be able to use the heuristic.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">In the Julia Pkg REPL, type: <code>add AStarSearch</code></p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto"><code>astar(neighbours, start, goal; heuristic=defaultheuristic, cost=defaultcost, isgoal=defaultisgoal, hashfn=hash, timeout=Inf, maxcost=Inf)</code></p>
<p dir="auto">Execute the A* algorithm to get the best path from the start state to reach a goal condition.
Only the first 3 arguments are mandatory, all the others are optional.</p>
<p dir="auto">It returns a structure in which the <code>status</code> field is a Symbol that can be either:</p>
<ul dir="auto">
<li><code>:success</code>: the algorithm found a path from start to goal</li>
<li><code>:timeout</code>: the algorithm timed out, a partial path to the best state is returned in the <code>path</code> field</li>
<li><code>:nopath</code>: the algorithm didn't find any path to a goal, the path to the best state is still returned</li>
</ul>
<p dir="auto">The other fields are:</p>
<ul dir="auto">
<li><code>path</code>: an array of states from the start state to the goal or the best found state</li>
<li><code>cost</code>: the cost of the returned path</li>
<li><code>closedsetsize</code>: how many states the algorithm tested if they were a goal (size of the closed set)</li>
<li><code>opensetsize</code>: how many states were still in the open set when the algorithm ended</li>
</ul>
<h2 dir="auto"><a id="user-content-arguments" class="anchor" aria-hidden="true" href="#arguments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Arguments</h2>
<ul dir="auto">
<li><code>neighbours</code>: a function that takes a state and returns the neighbour states as an array (or iterable)</li>
<li><code>start</code>: the starting state, the type of the state is completely unrestricted</li>
<li><code>goal</code>: the goal state, the type is unrestricted, usually it's the same as the start</li>
<li><code>heuristic</code>: a function that given a state and the goal returns an estimate of the cost to reach goal. This estimate should be optimistic if you want to be sure to get the best path. Notice that the best path could be very expensive to find, so if you want a good but not guaranteed optimal path, you could multiply your heuristic by a constant, the algorithm will usually be much faster</li>
<li><code>cost</code>: a function that takes the current state and a neighbour and returns the cost to do that state transition. By default all transitions cost 1</li>
<li><code>isgoal</code>: a function that takes a state and the goal and evaluates if the goal is reached (by default ==)</li>
<li><code>hashfn</code>: a function that takes a state and returns a compact representation to use as dictionary key (usually one of UInt, Int, String), by default it is the base hash function. This is a very important field for composite states in order to avoid duplications. <em>WARNING</em> states with arrays as fields might return a different hash every time! If this is the case, please pass an hashfn that always returns the same value for the same state!</li>
<li><code>timeout</code>: timeout in number of seconds after which the algorithm stops returning the best partial path to the state with the lowest heuristic, by default it is unrestricted. Please notice that the algorithm wil run <em>AT LEAST</em> the specified time.</li>
<li><code>maxcost</code>: a maximum bound of the accumulated cost of the path, this can result in a :nopath result even if a path to the goal (with a greater cost) exists. By default it is Inf</li>
<li><code>enable_closedset</code>: keep track of already visited nodes to avoid visiting them again, you might want to disable this if you know there isn't any loop in the state space graph (by default true)</li>
</ul>
<h3 dir="auto"><a id="user-content-uninformed-search-algorithms" class="anchor" aria-hidden="true" href="#uninformed-search-algorithms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Uninformed Search Algorithms</h3>
<p dir="auto">This package exports also some uninformed search algorithms to compare the performance of astar, or to use when you don't have an explicit heuristic or cost. The interface of each function is almost identical, you can use any algorithm as a drop-in replacement for <code>astar</code>, but the parameters about cost and heuristic wil be ignored (<code>heuristic</code>, <code>cost</code>, <code>maxcost</code>), they have instead a <code>maxdepth</code> parameter to limit the depth of the search.</p>
<p dir="auto">The exported functions are:</p>
<ul dir="auto">
<li><code>depthfirst</code></li>
<li><code>breadthfirst</code></li>
<li><code>iterative_deepening</code></li>
</ul>
<h4 dir="auto"><a id="user-content-depth-first" class="anchor" aria-hidden="true" href="#depth-first"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Depth First</h4>
<p dir="auto">This algorithm expands the neighbours as far as it can until there are no more neighbours for a state or the <code>maxdepth</code> limit is reached. The <code>enable_closedset</code> is enabled by default to avoid loops, but it might hide some paths to the goal if multiple paths are possible.</p>
<h4 dir="auto"><a id="user-content-breadth-first" class="anchor" aria-hidden="true" href="#breadth-first"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Breadth First</h4>
<p dir="auto">This algorithm searches first all the states at the same depth, ensuring that the best solution is always found, but it is usually slower.</p>
<h4 dir="auto"><a id="user-content-iterative-deepening" class="anchor" aria-hidden="true" href="#iterative-deepening"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Iterative Deepening</h4>
<p dir="auto">This algorithm iteratively executes depth first search at different levels of <code>maxdepth</code> having the same properties as breadth first, with almost the speed of depth first search. But also here the <code>enable_closedset</code> is disabled by default as it uses depth first internally.</p>
<h3 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h3>
<p dir="auto">It's a very general algorithm so you can solve shortest paths in mazes but also all sorts of puzzles such as the <a href="https://en.wikipedia.org/wiki/15_puzzle" rel="nofollow">15 Puzzle</a>.
Both the maze example and the 15 Puzzle solver are in the <code>test</code> folder.</p>
<p dir="auto">If you want to find the best path in a maze using the manhattan heuristic you can do the following:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Test
using AStarSearch

# Directions are seen as cartesian indexes so that they can be added to a position to get the next position
const UP = CartesianIndex(-1, 0)
const DOWN = CartesianIndex(1, 0)
const LEFT = CartesianIndex(0, -1)
const RIGHT = CartesianIndex(0, 1)
const DIRECTIONS = [UP, DOWN, LEFT, RIGHT]

# manhattan distance between positions in the maze matrix
manhattan(a::CartesianIndex, b::CartesianIndex) = sum(abs.((b - a).I))
# check to be in the maze and filter out moves that go into walls
function mazeneighbours(maze, p)
  res = CartesianIndex[]
  for d in DIRECTIONS
      n = p + d
      if 1 ≤ n[1] ≤ size(maze)[1] &amp;&amp; 1 ≤ n[2] ≤ size(maze)[2] &amp;&amp; !maze[n]
          push!(res, n)
      end
  end
  return res
end

function solvemaze(maze, start, goal)
  currentmazeneighbours(state) = mazeneighbours(maze, state)
  # Here you can use any of the exported search functions, they all share the same interface, but they won't use the heuristic and the cost
  return astar(currentmazeneighbours, start, goal, heuristic=manhattan)
end

# 0 = free cell, 1 = wall
maze = [0 0 1 0 0;
        0 1 0 0 0;
        0 1 0 0 1;
        0 0 0 1 1;
        1 0 1 0 0] .== 1
start = CartesianIndex(1, 1)
goal = CartesianIndex(1, 5)

res = solvemaze(maze, start, goal)
@test res.status == :success
@test res.path ==  CartesianIndex{2}[
    CartesianIndex(1, 1),
    CartesianIndex(2, 1),
    CartesianIndex(3, 1),
    CartesianIndex(4, 1),
    CartesianIndex(4, 2),
    CartesianIndex(4, 3),
    CartesianIndex(3, 3),
    CartesianIndex(2, 3),
    CartesianIndex(2, 4),
    CartesianIndex(1, 4),
    CartesianIndex(1, 5)]
@test res.cost == 10"><pre><span class="pl-k">using</span> Test
<span class="pl-k">using</span> AStarSearch

<span class="pl-c"><span class="pl-c">#</span> Directions are seen as cartesian indexes so that they can be added to a position to get the next position</span>
<span class="pl-k">const</span> UP <span class="pl-k">=</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>)
<span class="pl-k">const</span> DOWN <span class="pl-k">=</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>)
<span class="pl-k">const</span> LEFT <span class="pl-k">=</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>)
<span class="pl-k">const</span> RIGHT <span class="pl-k">=</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>)
<span class="pl-k">const</span> DIRECTIONS <span class="pl-k">=</span> [UP, DOWN, LEFT, RIGHT]

<span class="pl-c"><span class="pl-c">#</span> manhattan distance between positions in the maze matrix</span>
<span class="pl-en">manhattan</span>(a<span class="pl-k">::</span><span class="pl-c1">CartesianIndex</span>, b<span class="pl-k">::</span><span class="pl-c1">CartesianIndex</span>) <span class="pl-k">=</span> <span class="pl-c1">sum</span>(<span class="pl-c1">abs</span>.((b <span class="pl-k">-</span> a)<span class="pl-k">.</span>I))
<span class="pl-c"><span class="pl-c">#</span> check to be in the maze and filter out moves that go into walls</span>
<span class="pl-k">function</span> <span class="pl-en">mazeneighbours</span>(maze, p)
  res <span class="pl-k">=</span> CartesianIndex[]
  <span class="pl-k">for</span> d <span class="pl-k">in</span> DIRECTIONS
      n <span class="pl-k">=</span> p <span class="pl-k">+</span> d
      <span class="pl-k">if</span> <span class="pl-c1">1</span> <span class="pl-k">≤</span> n[<span class="pl-c1">1</span>] <span class="pl-k">≤</span> <span class="pl-c1">size</span>(maze)[<span class="pl-c1">1</span>] <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">1</span> <span class="pl-k">≤</span> n[<span class="pl-c1">2</span>] <span class="pl-k">≤</span> <span class="pl-c1">size</span>(maze)[<span class="pl-c1">2</span>] <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>maze[n]
          <span class="pl-c1">push!</span>(res, n)
      <span class="pl-k">end</span>
  <span class="pl-k">end</span>
  <span class="pl-k">return</span> res
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">solvemaze</span>(maze, start, goal)
  <span class="pl-en">currentmazeneighbours</span>(state) <span class="pl-k">=</span> <span class="pl-c1">mazeneighbours</span>(maze, state)
  <span class="pl-c"><span class="pl-c">#</span> Here you can use any of the exported search functions, they all share the same interface, but they won't use the heuristic and the cost</span>
  <span class="pl-k">return</span> <span class="pl-c1">astar</span>(currentmazeneighbours, start, goal, heuristic<span class="pl-k">=</span>manhattan)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> 0 = free cell, 1 = wall</span>
maze <span class="pl-k">=</span> [<span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>;
        <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>;
        <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span>;
        <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>;
        <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>] <span class="pl-k">.==</span> <span class="pl-c1">1</span>
start <span class="pl-k">=</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
goal <span class="pl-k">=</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">5</span>)

res <span class="pl-k">=</span> <span class="pl-c1">solvemaze</span>(maze, start, goal)
<span class="pl-c1">@test</span> res<span class="pl-k">.</span>status <span class="pl-k">==</span> <span class="pl-c1">:success</span>
<span class="pl-c1">@test</span> res<span class="pl-k">.</span>path <span class="pl-k">==</span>  CartesianIndex{<span class="pl-c1">2</span>}[
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">3</span>, <span class="pl-c1">1</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">4</span>, <span class="pl-c1">1</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">4</span>, <span class="pl-c1">2</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">4</span>, <span class="pl-c1">3</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">4</span>),
    <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">5</span>)]
<span class="pl-c1">@test</span> res<span class="pl-k">.</span>cost <span class="pl-k">==</span> <span class="pl-c1">10</span></pre></div>
<h3 dir="auto"><a id="user-content-breaking-changes" class="anchor" aria-hidden="true" href="#breaking-changes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Breaking Changes</h3>
<h4 dir="auto"><a id="user-content-060" class="anchor" aria-hidden="true" href="#060"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>0.6.0</h4>
<p dir="auto">Removed <code>maxdepth</code> parameter, to improve memory usage, as <code>maxcost</code> is more powerful.</p>
<h4 dir="auto"><a id="user-content-050" class="anchor" aria-hidden="true" href="#050"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>0.5.0</h4>
<p dir="auto">Removed the <code>AbstractAStarSearch</code> base struct, the <code>astar</code> function is now the only supported interface by this package.</p>
<h4 dir="auto"><a id="user-content-040" class="anchor" aria-hidden="true" href="#040"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>0.4.0</h4>
<p dir="auto">Since this release the base <code>astar</code> API changes, requiring the <code>neighbours</code> function as the first argument, and the second and third argument are the starting state and the goal state. All the other functions, <code>heuristic</code>, <code>cost</code>, and <code>isgoal</code>, are optional keyword arguments, and they now all expect 2 arguments (current state and goal/next state in the case of the <code>cost</code> function).
The subtyping API is the same, but the main method was renamed <code>astar</code>, instead of <code>search</code></p>
<h4 dir="auto"><a id="user-content-030" class="anchor" aria-hidden="true" href="#030"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>0.3.0</h4>
<p dir="auto">The 0.3.0 release introduces a more strict type checking, requiring uniformity of types between the cost and the heuristics, to improve performance.<br>
If you get type errors, it will probably be because by default the cost is Int64, and you provided a Float heuristic.<br>
You can either provide the cost function that returns a float, or cast the heuristic to Int64.</p>
</article></div>