<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-quantumalgebrajl---quantum-operator-algebra-in-julia" class="anchor" aria-hidden="true" href="#quantumalgebrajl---quantum-operator-algebra-in-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>QuantumAlgebra.jl - quantum operator algebra in Julia</h1>
<p dir="auto"><a href="https://jfeist.github.io/QuantumAlgebra.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://jfeist.github.io/QuantumAlgebra.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/jfeist/QuantumAlgebra.jl/actions"><img src="https://github.com/jfeist/QuantumAlgebra.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jfeist/QuantumAlgebra.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/82e4cd0ef663dfe9a3b0b614057c14403ca751c5793b58da36a19fd888dd06d7/68747470733a2f2f636f6465636f762e696f2f67682f6a66656973742f5175616e74756d416c67656272612e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/jfeist/QuantumAlgebra.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://mybinder.org/v2/gh/jfeist/QuantumAlgebra.jl/main?filepath=examples" rel="nofollow"><img src="https://camo.githubusercontent.com/581c077bdbc6ca6899c86d0acc6145ae85e9d80e6f805a1071793dbe48917982/68747470733a2f2f6d7962696e6465722e6f72672f62616467655f6c6f676f2e737667" alt="Binder" data-canonical-src="https://mybinder.org/badge_logo.svg" style="max-width: 100%;"></a>
<a href="https://zenodo.org/badge/latestdoi/211471154" rel="nofollow"><img src="https://camo.githubusercontent.com/3ed36899a72982fb72d6953197e50d97c787737db7d6ce0e82500ce1b31546eb/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3231313437313135342e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/211471154.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package does quantum operator algebra (i.e., algebra with non-commuting
operators) in Julia, supporting bosonic, fermionic, and two-level system
operators, with arbitrary names and indices, as well as sums over any of the
indices. It defines an opinionated canonical form (normal ordering plus some
additional rules) to automatically simplify expressions. It is recommended to
use an interface that can display LaTeX formulas (e.g., Jupyter notebooks) for
convenient output formatting. While there is some documentation, it is not
always kept fully up to date, and it is recommended to look at the latest commit
messages to get an idea about new features etc. You can also check out the
notebooks in the <code>examples</code> folder, which can be viewed online with
<a href="https://nbviewer.jupyter.org/github/jfeist/QuantumAlgebra.jl/blob/main/examples/" rel="nofollow">nbviewer</a>
and tried out interactively with
<a href="https://mybinder.org/v2/gh/jfeist/QuantumAlgebra.jl/main?filepath=examples" rel="nofollow">Binder</a>.</p>
<h1 dir="auto"><a id="user-content-updates-in-v100" class="anchor" aria-hidden="true" href="#updates-in-v100"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Updates in v1.0.0</h1>
<p dir="auto">This is a major revision with some breaking changes. The backend has been almost
completely rewritten to make the code more efficient when dealing with large
expressions, and the interface has been cleaned up in several places.</p>
<h3 dir="auto"><a id="user-content-important-changes" class="anchor" aria-hidden="true" href="#important-changes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Important changes:</h3>
<ul dir="auto">
<li>Canonical normal form is <strong>not</strong> automatically enforced by default. In order
to transform expressions to normal form, use <code>normal_form(x)</code>. Since automatic
conversion to normal form can be convenient for interactive work, it can be
enabled with <code>QuantumAlgebra.auto_normal_form(true)</code>, or alternatively by
setting the environment variable <code>QUANTUMALGEBRA_AUTO_NORMAL_FORM</code> to <code>"true"</code>
(or any value that <code>parse(Bool,value)</code> parses as <code>true</code>) before <code>using QuantumAlgebra</code>.</li>
<li>The function to obtain expectation values is now <code>expval(A)</code> (instead of
<code>ExpVal</code>), and <code>expval_as_corrs(A)</code> to express an expectation value through a
correlator / cumulant expansion, e.g., ‚ü®<em>AB</em>‚ü© = ‚ü®<em>AB</em>‚ü©<sub>c</sub> -
‚ü®<em>A</em>‚ü©<sub>c</sub> ‚ü®<em>B</em>‚ü©<sub>c</sub>, with corresponding extensions for
products of more operators. Note that for a single operator, ‚ü®<em>A</em>‚ü©<sub>c</sub>
= ‚ü®<em>A</em>‚ü©, but we distinguish the two formally for clarity.</li>
<li>There is a new function <code>julia_expression(A)</code> that converts a QuantumAlgebra
object to a julia expression, which helps in using QuantumAlgebra to
programatically derive codes for numerical implementation. The object <code>A</code>
cannot contain any "bare" operators, but only expectation values or
correlators. See the documentation for more details.</li>
<li>QuantumAlgebra expressions are now printed in pretty format in the terminal
etc.</li>
</ul>
<h1 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h1>
<p dir="auto">The basic functions to create QuantumAlgebra expressions (which are of type
<code>QuExpr</code>) are</p>
<ul dir="auto">
<li>
<p dir="auto"><code>a(inds...)</code> and <code>adag(inds...)</code> for <em>a</em> and <em>a<sup>‚Ä†</sup></em>, the annihilation
and creation operators for a bosonic mode.</p>
</li>
<li>
<p dir="auto"><code>f(inds...)</code> and <code>fdag(inds...)</code> for <em>f</em> and <em>f<sup>‚Ä†</sup></em>, the annihilation
and creation operators for a fermionic mode.</p>
</li>
<li>
<p dir="auto"><code>œÉx(inds...)</code>, <code>œÉy(inds...)</code>, <code>œÉz(inds...)</code> for the Pauli matrices
<em>œÉ<sup>x,y,z</sup></em> for a two-level system (TLS).</p>
</li>
<li>
<p dir="auto"><code>œÉp(inds...)</code>, <code>œÉm(inds...)</code> for excitation and deexcitation operators
<em>œÉ<sup>¬±</sup></em> for a two-level system (TLS).</p>
</li>
<li>
<p dir="auto"><strong>Indices</strong>: All of these functions take an arbitrary number of indices as
arguments, which can be either integers (1,2,...) or symbolic, where symbolic
indices must be a single unicode character, with possibly an integer subindex:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using QuantumAlgebra

julia&gt; a()
a()

julia&gt; adag(:i)
a‚Ä†(i)

julia&gt; fdag(1,2,:i_9)
f‚Ä†(12i‚Çâ)

julia&gt; œÉx(:i_1, 1, :j, :k_2, :Œº_2, :‚óî_1, :üòÑ_121)
œÉÀ£(i‚ÇÅ1jk‚ÇÇŒº‚ÇÇ‚óî‚ÇÅüòÑ‚ÇÅ‚ÇÇ‚ÇÅ)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> QuantumAlgebra

julia<span class="pl-k">&gt;</span> <span class="pl-c1">a</span>()
<span class="pl-c1">a</span>()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">adag</span>(<span class="pl-c1">:i</span>)
a‚Ä†(i)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">fdag</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">:i_9</span>)
f‚Ä†(<span class="pl-c1">12</span>i‚Çâ)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">œÉx</span>(<span class="pl-c1">:i_1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">:j</span>, <span class="pl-c1">:k_2</span>, <span class="pl-c1">:Œº_2</span>, <span class="pl-c1">:‚óî_1</span>, <span class="pl-c1">:üòÑ_121</span>)
<span class="pl-c1">œÉÀ£</span>(i‚ÇÅ1jk‚ÇÇŒº‚ÇÇ‚óî‚ÇÅüòÑ‚ÇÅ‚ÇÇ‚ÇÅ)</pre></div>
</li>
<li>
<p dir="auto">You can define your own bosonic/fermionic/two-level system operators with a
set of macros:</p>
<ul dir="auto">
<li><code>@boson_ops name</code> defines new functions <code>$name()</code> and <code>$(name)dag()</code> for
bosonic species <code>name</code>.</li>
<li><code>@fermion_ops name</code> defines new functions <code>$name()</code> and <code>$(name)dag()</code> for
fermionic species <code>name</code>.</li>
<li><code>@tlsxyz_ops name</code> defines new functions <code>$(name)x()</code>, <code>$(name)y()</code> and
<code>$(name)z()</code> for the Pauli matrices for two-level system species <code>name</code>.</li>
<li><code>@tlspm_ops name</code> defines new functions <code>$(name)p()</code> and <code>$(name)m()</code> for
the two-level system excitation and deexcitation operators for species
<code>name</code>.</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @boson_ops b
(QuantumAlgebra.OpConstructors.b, QuantumAlgebra.OpConstructors.bdag)

julia&gt; bdag(:k)*b(:i)
b‚Ä†(k) b(i)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@boson_ops</span> b
(QuantumAlgebra<span class="pl-k">.</span>OpConstructors<span class="pl-k">.</span>b, QuantumAlgebra<span class="pl-k">.</span>OpConstructors<span class="pl-k">.</span>bdag)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">bdag</span>(<span class="pl-c1">:k</span>)<span class="pl-k">*</span><span class="pl-c1">b</span>(<span class="pl-c1">:i</span>)
b‚Ä†(k) <span class="pl-c1">b</span>(i)</pre></div>
<p dir="auto">Operators with different names are assumed to belong to different "species"
and always commute. For fermions, this is not always desired, since you might
want to use different named operators to refer to different kinds of states
for the same species (e.g., localized and itinerant electrons). This can be
achieved with the macro <code>@anticommuting_fermion_group</code>, which creates several
fermionic operators that mutually anticommute:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @anticommuting_fermion_group c d

julia&gt; normal_form(c()*d() + d()*c())
0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@anticommuting_fermion_group</span> c d

julia<span class="pl-k">&gt;</span> <span class="pl-c1">normal_form</span>(<span class="pl-c1">c</span>()<span class="pl-k">*</span><span class="pl-c1">d</span>() <span class="pl-k">+</span> <span class="pl-c1">d</span>()<span class="pl-k">*</span><span class="pl-c1">c</span>())
<span class="pl-c1">0</span></pre></div>
</li>
<li>
<p dir="auto"><code>param(name::Symbol,state='n',inds...)</code> to create a named parameter. <code>state</code> must be
one of <code>'r'</code>, <code>'n'</code>, or <code>'c'</code> for purely real, non-conjugated complex, and
conjugated complex parameters. More conveniently, parameters can be entered
with string macros <code>Pr"name_inds..."</code> and <code>Pc"name_inds..."</code> for real and
complex parameters:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Pr&quot;g_i,j_2,k&quot;
g(ij‚ÇÇk)

julia&gt; Pr&quot;g_i,j_2,k&quot; == param(:g,'r',:i,:j_2,:k)
true

julia&gt; Pc&quot;Œ±_3&quot; == param(:Œ±,3)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">Pr</span>"</span>g_i,j_2,k<span class="pl-pds">"</span></span>
<span class="pl-c1">g</span>(ij‚ÇÇk)

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">Pr</span>"</span>g_i,j_2,k<span class="pl-pds">"</span></span> <span class="pl-k">==</span> <span class="pl-c1">param</span>(<span class="pl-c1">:g</span>,<span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>,<span class="pl-c1">:i</span>,<span class="pl-c1">:j_2</span>,<span class="pl-c1">:k</span>)
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">Pc</span>"</span>Œ±_3<span class="pl-pds">"</span></span> <span class="pl-k">==</span> <span class="pl-c1">param</span>(<span class="pl-c1">:Œ±</span>,<span class="pl-c1">3</span>)
<span class="pl-c1">true</span></pre></div>
</li>
<li>
<p dir="auto">Arithmetic operations (<code>*</code>, <code>+</code>, <code>-</code>, <code>^</code>, <code>adjoint</code>=<code>'</code>) are supported
(exponents must be nonnegative integers), with any <code>Number</code> types integrating
automatically.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; 5*adag(:k)*f(3)*œÉx(3)
5 a‚Ä†(k) f(3) œÉÀ£(3)

julia&gt; (5//3+4im) * adag(:k)*f(3)*œÉx(3) + 9.4
9.4 + (5//3+4i) a‚Ä†(k) f(3) œÉÀ£(3)

julia&gt; (a(:i)*f(:k))'
f‚Ä†(k) a‚Ä†(i)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">5</span><span class="pl-k">*</span><span class="pl-c1">adag</span>(<span class="pl-c1">:k</span>)<span class="pl-k">*</span><span class="pl-c1">f</span>(<span class="pl-c1">3</span>)<span class="pl-k">*</span><span class="pl-c1">œÉx</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">5</span> a‚Ä†(k) <span class="pl-c1">f</span>(<span class="pl-c1">3</span>) <span class="pl-c1">œÉÀ£</span>(<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">5</span><span class="pl-k">//</span><span class="pl-c1">3</span><span class="pl-k">+</span><span class="pl-c1">4im</span>) <span class="pl-k">*</span> <span class="pl-c1">adag</span>(<span class="pl-c1">:k</span>)<span class="pl-k">*</span><span class="pl-c1">f</span>(<span class="pl-c1">3</span>)<span class="pl-k">*</span><span class="pl-c1">œÉx</span>(<span class="pl-c1">3</span>) <span class="pl-k">+</span> <span class="pl-c1">9.4</span>
<span class="pl-c1">9.4</span> <span class="pl-k">+</span> (<span class="pl-c1">5</span><span class="pl-k">//</span><span class="pl-c1">3</span><span class="pl-k">+</span><span class="pl-c1">4</span>i) a‚Ä†(k) <span class="pl-c1">f</span>(<span class="pl-c1">3</span>) <span class="pl-c1">œÉÀ£</span>(<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">a</span>(<span class="pl-c1">:i</span>)<span class="pl-k">*</span><span class="pl-c1">f</span>(<span class="pl-c1">:k</span>))<span class="pl-k">'</span>
f‚Ä†(k) a‚Ä†(i)</pre></div>
<p dir="auto">If you need a bare number as a QuantumAlgebra expression, you can use
<code>x*one(QuExpr)</code> (or <code>one(A)</code>, where <code>A</code> is any <code>QuExpr</code>).</p>
</li>
<li>
<p dir="auto"><code>‚àë(ind,A::QuExpr)</code> to represent an analytic sum over index <code>ind</code>. Since summed
indices have no semantic meaning, the index within the expression gets
replaced by a special numbered sum index <code>#·µ¢</code>, with <code>i=1,2,...</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ‚àë(:i,a(:i))
‚àë‚ÇÅ a(#‚ÇÅ)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">‚àë</span>(<span class="pl-c1">:i</span>,<span class="pl-c1">a</span>(<span class="pl-c1">:i</span>))
‚àë‚ÇÅ <span class="pl-c1">a</span>(<span class="pl-c"><span class="pl-c">#</span>‚ÇÅ)</span></pre></div>
</li>
<li>
<p dir="auto"><code>normal_form(A::QuExpr)</code> converts an expression to a well-defined "canonical"
order. To achieve this canonical form, relevant commutators etc are used, so
an expression written as a single product can turn into a sum of expressions.
The order is essentially normal ordering (creation before annihilation
operators, with œÉÀ£ ∏·∂ª in the middle), with some additional conventions to make
the normal form (hopefully) unique. In some contexts (e.g., interactive work),
it can be convenient to automatically transform all expressions to normal
form. This can be enabled by calling <code>QuantumAlgebra.auto_normal_form(true)</code>,
or alternatively by setting the environment variable
<code>QUANTUMALGEBRA_AUTO_NORMAL_FORM</code> to <code>"true"</code> (or any value that
<code>parse(Bool,value)</code> parses as <code>true</code>) before <code>using QuantumAlgebra</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; normal_form(a(:i)*adag(:j))
Œ¥(ij)  + a‚Ä†(j) a(i)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">normal_form</span>(<span class="pl-c1">a</span>(<span class="pl-c1">:i</span>)<span class="pl-k">*</span><span class="pl-c1">adag</span>(<span class="pl-c1">:j</span>))
<span class="pl-c1">Œ¥</span>(ij)  <span class="pl-k">+</span> a‚Ä†(j) <span class="pl-c1">a</span>(i)</pre></div>
</li>
<li>
<p dir="auto"><code>expval(A::QuExpr)</code> to represent an expectation value.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; expval(adag(:j)*a(:i))
‚ü®a‚Ä†(j) a(i)‚ü©"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">expval</span>(<span class="pl-c1">adag</span>(<span class="pl-c1">:j</span>)<span class="pl-k">*</span><span class="pl-c1">a</span>(<span class="pl-c1">:i</span>))
‚ü®a‚Ä†(j) <span class="pl-c1">a</span>(i)‚ü©</pre></div>
</li>
<li>
<p dir="auto"><code>expval_as_corrs(A::QuExpr)</code> to represent an expectation value through its
correlators, i.e., a cumulant expansion.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; expval_as_corrs(adag(:j)*a(:i))
‚ü®a‚Ä†(j)‚ü©c ‚ü®a(i)‚ü©c  + ‚ü®a‚Ä†(j) a(i)‚ü©c"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">expval_as_corrs</span>(<span class="pl-c1">adag</span>(<span class="pl-c1">:j</span>)<span class="pl-k">*</span><span class="pl-c1">a</span>(<span class="pl-c1">:i</span>))
‚ü®a‚Ä†(j)‚ü©c ‚ü®<span class="pl-c1">a</span>(i)‚ü©c  <span class="pl-k">+</span> ‚ü®a‚Ä†(j) <span class="pl-c1">a</span>(i)‚ü©c</pre></div>
</li>
<li>
<p dir="auto"><code>comm(A::QuExpr,B::QuExpr)</code> to calculate the commutator [<em>A,B</em>] = <em>AB - BA</em>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; comm(a(),adag())
-a‚Ä†() a() + a() a‚Ä†()

julia&gt; normal_form(comm(a(),adag()))
1"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">comm</span>(<span class="pl-c1">a</span>(),<span class="pl-c1">adag</span>())
<span class="pl-k">-</span>a‚Ä†() <span class="pl-c1">a</span>() <span class="pl-k">+</span> <span class="pl-c1">a</span>() a‚Ä†()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">normal_form</span>(<span class="pl-c1">comm</span>(<span class="pl-c1">a</span>(),<span class="pl-c1">adag</span>()))
<span class="pl-c1">1</span></pre></div>
</li>
<li>
<p dir="auto"><code>Avac(A)</code> and <code>vacA(A)</code> simplify operators by assuming they are applied to the
vacuum from the left or right, respectively. To be precise, <code>Avac(A)</code> returns
<em>A'</em> such that <em>A</em>|0‚ü© = <em>A'</em>|0‚ü©, while <code>vacA(A)</code> does the same for ‚ü®0|<em>A</em>.
These functions automatically apply <code>normal_form</code> to assure that the operators
are simplified as much as possible. Note that "vacuum" for two-level systems
is interpreted as the lower state, <code>œÉ·∂ª|0‚ü© = -|0‚ü©</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Avac(a())
0

julia&gt; Avac(a(:i)*adag(:j))
Œ¥(ij)

julia&gt; Avac(a()*adag()*adag())
2 a‚Ä†()

julia&gt; vacA(a()*adag()*adag())
0

julia&gt; Avac(œÉx())
œÉÀ£()

julia&gt; Avac(œÉz())
-1"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Avac</span>(<span class="pl-c1">a</span>())
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Avac</span>(<span class="pl-c1">a</span>(<span class="pl-c1">:i</span>)<span class="pl-k">*</span><span class="pl-c1">adag</span>(<span class="pl-c1">:j</span>))
<span class="pl-c1">Œ¥</span>(ij)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Avac</span>(<span class="pl-c1">a</span>()<span class="pl-k">*</span><span class="pl-c1">adag</span>()<span class="pl-k">*</span><span class="pl-c1">adag</span>())
<span class="pl-c1">2</span> a‚Ä†()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vacA</span>(<span class="pl-c1">a</span>()<span class="pl-k">*</span><span class="pl-c1">adag</span>()<span class="pl-k">*</span><span class="pl-c1">adag</span>())
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Avac</span>(<span class="pl-c1">œÉx</span>())
<span class="pl-c1">œÉÀ£</span>()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Avac</span>(<span class="pl-c1">œÉz</span>())
<span class="pl-k">-</span><span class="pl-c1">1</span></pre></div>
</li>
<li>
<p dir="auto"><code>vacExpVal(A,S=1)</code> calculates the vacuum expectation value
‚ü®0|<em>S<sup>‚Ä†</sup>AS</em>|0‚ü©, i.e., the expectation value ‚ü®œà|<em>A</em>|œà‚ü© for the state
defined by |œà‚ü©=<em>S</em>|0‚ü©. The result is guaranteed to not contain any operators.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; vacExpVal(adag()*a())
0

julia&gt; vacExpVal(adag()*a(), adag()^4/sqrt(factorial(4)))
4.000000000000001

julia&gt; vacExpVal(adag()*a(), adag()^4/sqrt(factorial(big(4))))
4

julia&gt; vacExpVal(œÉx())
0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">vacExpVal</span>(<span class="pl-c1">adag</span>()<span class="pl-k">*</span><span class="pl-c1">a</span>())
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vacExpVal</span>(<span class="pl-c1">adag</span>()<span class="pl-k">*</span><span class="pl-c1">a</span>(), <span class="pl-c1">adag</span>()<span class="pl-k">^</span><span class="pl-c1">4</span><span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">factorial</span>(<span class="pl-c1">4</span>)))
<span class="pl-c1">4.000000000000001</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vacExpVal</span>(<span class="pl-c1">adag</span>()<span class="pl-k">*</span><span class="pl-c1">a</span>(), <span class="pl-c1">adag</span>()<span class="pl-k">^</span><span class="pl-c1">4</span><span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">factorial</span>(<span class="pl-c1">big</span>(<span class="pl-c1">4</span>))))
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vacExpVal</span>(<span class="pl-c1">œÉx</span>())
<span class="pl-c1">0</span></pre></div>
</li>
<li>
<p dir="auto"><code>julia_expression(A)</code> to obtain a julia expression that can be used to
automatically build codes implementing equations derived with QuantumAlgebra.
Every expectation value or correlator is treated as a separate array. Daggers
are represented as <code>·¥¥</code>, which are valid identifiers that can appear in the
array names. Note that expectation values and correlators are not
distinguished, so it is best to have all expressions use the same kind.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; julia_expression(expval_as_corrs(adag(:j)*a(:i)))
:(a·¥¥[j] * a[i] + a·¥¥a[j, i])"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">julia_expression</span>(<span class="pl-c1">expval_as_corrs</span>(<span class="pl-c1">adag</span>(<span class="pl-c1">:j</span>)<span class="pl-k">*</span><span class="pl-c1">a</span>(<span class="pl-c1">:i</span>)))
:(a·¥¥[j] <span class="pl-k">*</span> a[i] <span class="pl-k">+</span> a·¥¥a[j, i])</pre></div>
<p dir="auto">Also note that expressions are always treated as arrays, even if they have no
indices (which gives zero-dimensional arrays). If you are working with scalar
quantities exclusively, it might be useful to clean up the resulting
expression (e.g., use <code>MacroTools</code> to remove the <code>[]</code>).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; julia_expression(expval(adag()*a()*œÉx()))
:(a·¥¥aœÉÀ£[])"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">julia_expression</span>(<span class="pl-c1">expval</span>(<span class="pl-c1">adag</span>()<span class="pl-k">*</span><span class="pl-c1">a</span>()<span class="pl-k">*</span><span class="pl-c1">œÉx</span>()))
:(a·¥¥aœÉÀ£[])</pre></div>
</li>
<li>
<p dir="auto">By default, two-level system operators are represented by the Pauli
matrices <code>œÉÀ£ ∏·∂ª</code>, and calling <code>œÉp()</code> and <code>œÉm()</code> will give results expressed through them:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; œÉp()
1//2 œÉÀ£() + 1//2i œÉ ∏()

julia&gt; œÉm()
1//2 œÉÀ£() - 1//2i œÉ ∏()"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">œÉp</span>()
<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span> <span class="pl-c1">œÉÀ£</span>() <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>i <span class="pl-c1">œÉ ∏</span>()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">œÉm</span>()
<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span> <span class="pl-c1">œÉÀ£</span>() <span class="pl-k">-</span> <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>i <span class="pl-c1">œÉ ∏</span>()</pre></div>
<p dir="auto">This can be changed by calling <code>QuantumAlgebra.use_œÉpm(true)</code>. In this mode,
<code>œÉ‚Å∫</code> and <code>œÉ‚Åª</code> are the "fundamental" operators, and all expressions are written in terms of them. Note that mixing conventions within the same expression is not supported, so it is suggested to set this flag once at the beginning of any calculation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; QuantumAlgebra.use_œÉpm(true)

julia&gt; œÉp()
œÉ‚Å∫()

julia&gt; œÉx()
œÉ‚Å∫() + œÉ‚Åª()

julia&gt; œÉz()
-1 + 2 œÉ‚Å∫() œÉ‚Åª()"><pre>julia<span class="pl-k">&gt;</span> QuantumAlgebra<span class="pl-k">.</span><span class="pl-c1">use_œÉpm</span>(<span class="pl-c1">true</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">œÉp</span>()
<span class="pl-c1">œÉ‚Å∫</span>()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">œÉx</span>()
<span class="pl-c1">œÉ‚Å∫</span>() <span class="pl-k">+</span> <span class="pl-c1">œÉ‚Åª</span>()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">œÉz</span>()
<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2</span> <span class="pl-c1">œÉ‚Å∫</span>() <span class="pl-c1">œÉ‚Åª</span>()</pre></div>
</li>
</ul>
<h2 dir="auto"><a id="user-content-citing" class="anchor" aria-hidden="true" href="#citing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citing</h2>
<p dir="auto">If you use QuantumAlgebra in academic work, we would appreciate a citation. See
<a href="CITATION.bib"><code>CITATION.bib</code></a> for the relevant references.</p>
</article></div>