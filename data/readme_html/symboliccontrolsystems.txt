<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-symboliccontrolsystems" class="anchor" aria-hidden="true" href="#symboliccontrolsystems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SymbolicControlSystems</h1>
<p dir="auto">Utilities for</p>
<ul dir="auto">
<li>Working with <a href="https://github.com/JuliaControl/ControlSystems.jl/">ControlSystems.jl</a> types with SymPy.jl and Symbolics.jl symbols as coefficients.</li>
<li>Generation of C-code for filtering with LTI systems.</li>
</ul>
<p dir="auto">This package exports the names <code>s,z</code> of type <code>SymPy.Sym</code> for the Laplace and Z-transform variables. These can be used to build symbolic transfer functions. To build symbolic transfer functions with Symbolics.jl symbols, create <code>s</code> or <code>z</code> using <code>using Symbolics; @variables s</code>.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Users typically want to install both ControlSystemsBase and SymbolicControlSystems. ControlSystemsBase contains the basic control-systems functionality, like system types etc., that is used when working with SymbolicControlSystems.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add([&quot;ControlSystemsBase&quot;, &quot;SymbolicControlSystems&quot;])"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>([<span class="pl-s"><span class="pl-pds">"</span>ControlSystemsBase<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>SymbolicControlSystems<span class="pl-pds">"</span></span>])</pre></div>
<h2 dir="auto"><a id="user-content-usage-examples" class="anchor" aria-hidden="true" href="#usage-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage examples</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using ControlSystemsBase, SymbolicControlSystems

julia&gt; @vars w T d # Define (SymPy) symbolic variables
(w, T, d)

julia&gt; h = 0.01; # Sample time

julia&gt; G = tf([w^2], [1, 2*d*w, w^2]) * tf(1, [T, 1])
TransferFunction{Continuous, SisoRational{Sym}}
                      w^2
-----------------------------------------------
T*s^3 + 2*T*d*w + 1*s^2 + T*w^2 + 2*d*w*s + w^2

Continuous-time transfer function model

julia&gt; Gd = tustin(G, h); # Discretize

julia&gt; Sym(G) # Convert a TransferFunction to symbolic expression
                        2                      
                       w                       
───────────────────────────────────────────────
   3    2                   ⎛   2        ⎞    2
T⋅s  + s ⋅(2⋅T⋅d⋅w + 1) + s⋅⎝T⋅w  + 2⋅d⋅w⎠ + w 

julia&gt; ex = w^2 / (s^2 + 2*d*w*s + w^2) # Define symbolic expression
         2       
        w        
─────────────────
           2    2
2⋅d⋅s⋅w + s  + w 

julia&gt; tf(ex) # Convert symbolic expression to TransferFunction
TransferFunction{Continuous, SisoRational{Sym}}
         w^2
---------------------
1*s^2 + 2*d*w*s + w^2

Continuous-time transfer function model

julia&gt; # Replace symbols with numbers
       T_, d_, w_ = 0.03, 0.2, 2.0 # Define system parameters
(0.03, 0.2, 2.0)

julia&gt; Gd_  = sym2num(Gd, h, Pair.((T, d, w), (T_, d_, w_))...)
TransferFunction{Discrete{Float64}, SisoRational{Float64}}
1.4227382019434605e-5*z^3 + 4.2682146058303814e-5*z^2 + 4.2682146058303814e-5*z + 1.4227382019434605e-5
-------------------------------------------------------------------------------------------------------
              1.0*z^3 - 2.705920013658287*z^2 + 2.414628594192383*z - 0.7085947614779404

Sample Time: 0.01 (seconds)
Discrete-time transfer function model"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> ControlSystemsBase, SymbolicControlSystems

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@vars</span> w T d <span class="pl-c"><span class="pl-c">#</span> Define (SymPy) symbolic variables</span>
(w, T, d)

julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">0.01</span>; <span class="pl-c"><span class="pl-c">#</span> Sample time</span>

julia<span class="pl-k">&gt;</span> G <span class="pl-k">=</span> <span class="pl-c1">tf</span>([w<span class="pl-k">^</span><span class="pl-c1">2</span>], [<span class="pl-c1">1</span>, <span class="pl-c1">2</span><span class="pl-k">*</span>d<span class="pl-k">*</span>w, w<span class="pl-k">^</span><span class="pl-c1">2</span>]) <span class="pl-k">*</span> <span class="pl-c1">tf</span>(<span class="pl-c1">1</span>, [T, <span class="pl-c1">1</span>])
TransferFunction{Continuous, SisoRational{Sym}}
                      w<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-k">-----------------------------------------------</span>
T<span class="pl-k">*</span>s<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>T<span class="pl-k">*</span>d<span class="pl-k">*</span>w <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-k">*</span>s<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> T<span class="pl-k">*</span>w<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>d<span class="pl-k">*</span>w<span class="pl-k">*</span>s <span class="pl-k">+</span> w<span class="pl-k">^</span><span class="pl-c1">2</span>

Continuous<span class="pl-k">-</span>time transfer <span class="pl-k">function</span> model

julia<span class="pl-k">&gt;</span> Gd <span class="pl-k">=</span> <span class="pl-c1">tustin</span>(G, h); <span class="pl-c"><span class="pl-c">#</span> Discretize</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Sym</span>(G) <span class="pl-c"><span class="pl-c">#</span> Convert a TransferFunction to symbolic expression</span>
                        <span class="pl-c1">2</span>                      
                       w                       
───────────────────────────────────────────────
   <span class="pl-c1">3</span>    <span class="pl-c1">2</span>                   ⎛   <span class="pl-c1">2</span>        ⎞    <span class="pl-c1">2</span>
T<span class="pl-k">⋅</span>s  <span class="pl-k">+</span> s <span class="pl-k">⋅</span>(<span class="pl-c1">2</span><span class="pl-k">⋅</span>T<span class="pl-k">⋅</span>d<span class="pl-k">⋅</span>w <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">+</span> s<span class="pl-k">⋅</span>⎝T<span class="pl-k">⋅</span>w  <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">⋅</span>d<span class="pl-k">⋅</span>w⎠ <span class="pl-k">+</span> w 

julia<span class="pl-k">&gt;</span> ex <span class="pl-k">=</span> w<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">/</span> (s<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>d<span class="pl-k">*</span>w<span class="pl-k">*</span>s <span class="pl-k">+</span> w<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> Define symbolic expression</span>
         <span class="pl-c1">2</span>       
        w        
─────────────────
           <span class="pl-c1">2</span>    <span class="pl-c1">2</span>
<span class="pl-c1">2</span><span class="pl-k">⋅</span>d<span class="pl-k">⋅</span>s<span class="pl-k">⋅</span>w <span class="pl-k">+</span> s  <span class="pl-k">+</span> w 

julia<span class="pl-k">&gt;</span> <span class="pl-c1">tf</span>(ex) <span class="pl-c"><span class="pl-c">#</span> Convert symbolic expression to TransferFunction</span>
TransferFunction{Continuous, SisoRational{Sym}}
         w<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-k">---------------------</span>
<span class="pl-c1">1</span><span class="pl-k">*</span>s<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>d<span class="pl-k">*</span>w<span class="pl-k">*</span>s <span class="pl-k">+</span> w<span class="pl-k">^</span><span class="pl-c1">2</span>

Continuous<span class="pl-k">-</span>time transfer <span class="pl-k">function</span> model

julia<span class="pl-k">&gt;</span> <span class="pl-c"><span class="pl-c">#</span> Replace symbols with numbers</span>
       T_, d_, w_ <span class="pl-k">=</span> <span class="pl-c1">0.03</span>, <span class="pl-c1">0.2</span>, <span class="pl-c1">2.0</span> <span class="pl-c"><span class="pl-c">#</span> Define system parameters</span>
(<span class="pl-c1">0.03</span>, <span class="pl-c1">0.2</span>, <span class="pl-c1">2.0</span>)

julia<span class="pl-k">&gt;</span> Gd_  <span class="pl-k">=</span> <span class="pl-c1">sym2num</span>(Gd, h, <span class="pl-c1">Pair</span>.((T, d, w), (T_, d_, w_))<span class="pl-k">...</span>)
TransferFunction{Discrete{Float64}, SisoRational{Float64}}
<span class="pl-c1">1.4227382019434605e-5</span><span class="pl-k">*</span>z<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">4.2682146058303814e-5</span><span class="pl-k">*</span>z<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">4.2682146058303814e-5</span><span class="pl-k">*</span>z <span class="pl-k">+</span> <span class="pl-c1">1.4227382019434605e-5</span>
<span class="pl-k">-------------------------------------------------------------------------------------------------------</span>
              <span class="pl-c1">1.0</span><span class="pl-k">*</span>z<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">2.705920013658287</span><span class="pl-k">*</span>z<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">2.414628594192383</span><span class="pl-k">*</span>z <span class="pl-k">-</span> <span class="pl-c1">0.7085947614779404</span>

Sample Time<span class="pl-k">:</span> <span class="pl-c1">0.01</span> (seconds)
Discrete<span class="pl-k">-</span>time transfer <span class="pl-k">function</span> model</pre></div>
<p dir="auto">Get a Latex-string</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; latextf(G)
&quot;\$\\dfrac{1.0w^2}{0.003s^3 + s^2(0.006dw + 1.0) + s(2.0dw + 0.003w^2) + 1.0w^2}\$&quot;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">latextf</span>(G)
<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\$\\</span>dfrac{1.0w^2}{0.003s^3 + s^2(0.006dw + 1.0) + s(2.0dw + 0.003w^2) + 1.0w^2}<span class="pl-cce">\$</span><span class="pl-pds">"</span></span></pre></div>
<h2 dir="auto"><a id="user-content-code-generation" class="anchor" aria-hidden="true" href="#code-generation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Code generation</h2>
<p dir="auto">The function <code>code = SymbolicControlSystems.ccode(G::LTISystem)</code> returns a string with C-code for filtering of a signal through the linear system <code>G</code>. All symbolic variables present in <code>G</code> will be expected as inputs to the generated function. The transfer-function state is handled by the C concept of <code>static</code> variables, i.e., a variable that remembers it's value since the last function invocation. The signature of the generated function <code>transfer_function</code> expects all input arguments in alphabetical order, except for the input <code>u</code> which always comes first.</p>
<p dir="auto">Code generation for systems with multiple inputs and outputs (MIMO) is only handled for statespace systems, call <code>ss(G)</code> to convert a transfer function to a statespace system.</p>
<p dir="auto">A usage example follows</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ControlSystemsBase, SymbolicControlSystems

@vars w T d      # Define symbolic variables
h        = 0.01  # Sample time
G        = tf([w^2], [1, 2*d*w, w^2]) * tf(1, [T, 1])
Gd       = tustin(G, h) # Discretize
code     = SymbolicControlSystems.ccode(Gd, cse=true)
path     = mktempdir()
filename = joinpath(path, &quot;code.c&quot;)
outname  = joinpath(path, &quot;test.so&quot;)
write(joinpath(path, filename), code)
run(`gcc $filename -lm -shared -o $outname`)

## Test that the C-code generates the same output as lsim in Julia

function c_lsim(u, T, d, w)
    Libc.Libdl.dlopen(outname) do lib
        fn = Libc.Libdl.dlsym(lib, :transfer_function)
        map(u) do u
            @ccall $(fn)(u::Float64, T::Float64, d::Float64, w::Float64)::Float64
        end
    end
end

u    = randn(1,100); # Random input signal 
T_, d_, w_ = 0.03, 0.2, 2.0 # Define system parameters
y    = c_lsim( u,  T_,  d_,  w_); # Filter u through the C-function filter
Gd_  = sym2num(Gd, h, Pair.((T, d, w), (T_, d_, w_))...) # Replace symbols with numeric constants
y_,_ = lsim(ss(Gd_), u); # Filter using Julia

using Plots, LinearAlgebra, Test
@test norm(y-y_)/norm(y_) &lt; 1e-10
plot(u', lab=&quot;u&quot;, layout=2)
plot!([y; y_]', lab=[&quot;y c-code&quot; &quot;y julia&quot;], sp=2, linestyle=[:solid :dash]) |&gt; display"><pre><span class="pl-k">using</span> ControlSystemsBase, SymbolicControlSystems

<span class="pl-c1">@vars</span> w T d      <span class="pl-c"><span class="pl-c">#</span> Define symbolic variables</span>
h        <span class="pl-k">=</span> <span class="pl-c1">0.01</span>  <span class="pl-c"><span class="pl-c">#</span> Sample time</span>
G        <span class="pl-k">=</span> <span class="pl-c1">tf</span>([w<span class="pl-k">^</span><span class="pl-c1">2</span>], [<span class="pl-c1">1</span>, <span class="pl-c1">2</span><span class="pl-k">*</span>d<span class="pl-k">*</span>w, w<span class="pl-k">^</span><span class="pl-c1">2</span>]) <span class="pl-k">*</span> <span class="pl-c1">tf</span>(<span class="pl-c1">1</span>, [T, <span class="pl-c1">1</span>])
Gd       <span class="pl-k">=</span> <span class="pl-c1">tustin</span>(G, h) <span class="pl-c"><span class="pl-c">#</span> Discretize</span>
code     <span class="pl-k">=</span> SymbolicControlSystems<span class="pl-k">.</span><span class="pl-c1">ccode</span>(Gd, cse<span class="pl-k">=</span><span class="pl-c1">true</span>)
path     <span class="pl-k">=</span> <span class="pl-c1">mktempdir</span>()
filename <span class="pl-k">=</span> <span class="pl-c1">joinpath</span>(path, <span class="pl-s"><span class="pl-pds">"</span>code.c<span class="pl-pds">"</span></span>)
outname  <span class="pl-k">=</span> <span class="pl-c1">joinpath</span>(path, <span class="pl-s"><span class="pl-pds">"</span>test.so<span class="pl-pds">"</span></span>)
<span class="pl-c1">write</span>(<span class="pl-c1">joinpath</span>(path, filename), code)
<span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>gcc $filename -lm -shared -o $outname<span class="pl-pds">`</span></span>)

<span class="pl-c"><span class="pl-c">#</span># Test that the C-code generates the same output as lsim in Julia</span>

<span class="pl-k">function</span> <span class="pl-en">c_lsim</span>(u, T, d, w)
    Libc<span class="pl-k">.</span>Libdl<span class="pl-k">.</span><span class="pl-c1">dlopen</span>(outname) <span class="pl-k">do</span> lib
        fn <span class="pl-k">=</span> Libc<span class="pl-k">.</span>Libdl<span class="pl-k">.</span><span class="pl-c1">dlsym</span>(lib, <span class="pl-c1">:transfer_function</span>)
        <span class="pl-c1">map</span>(u) <span class="pl-k">do</span> u
            <span class="pl-c1">@ccall</span> <span class="pl-k">$</span>(fn)(u<span class="pl-k">::</span><span class="pl-c1">Float64</span>, T<span class="pl-k">::</span><span class="pl-c1">Float64</span>, d<span class="pl-k">::</span><span class="pl-c1">Float64</span>, w<span class="pl-k">::</span><span class="pl-c1">Float64</span>)<span class="pl-k">::</span><span class="pl-c1">Float64</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

u    <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">1</span>,<span class="pl-c1">100</span>); <span class="pl-c"><span class="pl-c">#</span> Random input signal </span>
T_, d_, w_ <span class="pl-k">=</span> <span class="pl-c1">0.03</span>, <span class="pl-c1">0.2</span>, <span class="pl-c1">2.0</span> <span class="pl-c"><span class="pl-c">#</span> Define system parameters</span>
y    <span class="pl-k">=</span> <span class="pl-c1">c_lsim</span>( u,  T_,  d_,  w_); <span class="pl-c"><span class="pl-c">#</span> Filter u through the C-function filter</span>
Gd_  <span class="pl-k">=</span> <span class="pl-c1">sym2num</span>(Gd, h, <span class="pl-c1">Pair</span>.((T, d, w), (T_, d_, w_))<span class="pl-k">...</span>) <span class="pl-c"><span class="pl-c">#</span> Replace symbols with numeric constants</span>
y_,_ <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(<span class="pl-c1">ss</span>(Gd_), u); <span class="pl-c"><span class="pl-c">#</span> Filter using Julia</span>

<span class="pl-k">using</span> Plots, LinearAlgebra, Test
<span class="pl-c1">@test</span> <span class="pl-c1">norm</span>(y<span class="pl-k">-</span>y_)<span class="pl-k">/</span><span class="pl-c1">norm</span>(y_) <span class="pl-k">&lt;</span> <span class="pl-c1">1e-10</span>
<span class="pl-c1">plot</span>(u<span class="pl-k">'</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>u<span class="pl-pds">"</span></span>, layout<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-c1">plot!</span>([y; y_]<span class="pl-k">'</span>, lab<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>y c-code<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>y julia<span class="pl-pds">"</span></span>], sp<span class="pl-k">=</span><span class="pl-c1">2</span>, linestyle<span class="pl-k">=</span>[<span class="pl-c1">:solid</span> <span class="pl-c1">:dash</span>]) <span class="pl-k">|&gt;</span> display</pre></div>
<p dir="auto"><strong>NOTE:</strong> Numerical accuracy</p>
<blockquote>
<p dir="auto">The usual caveats for transfer-function filtering applies. High-order transfer functions might cause numerical problems. Consider either filtering through many smaller transfer function in series, or convert the system into a well-balanced statespace system and generate code for this instead. See <a href="http://www.control.lth.se/fileadmin/control/Education/EngineeringProgram/FRTN01/lectures/L11_slides6.pdf" rel="nofollow">lecture notes</a> slide 45 and onwards as well as the <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/man/numerical/#Performance-considerations" rel="nofollow">ControlSystems docs on numerical accuracy.</a>. The function <code>ControlSystems.ss</code> converts a transfer function to a statespace system and performs automatic balancing.</p>
</blockquote>
<h3 dir="auto"><a id="user-content-c-code-for-gain-scheduled-systems" class="anchor" aria-hidden="true" href="#c-code-for-gain-scheduled-systems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>C-code for gain scheduled systems</h3>
<p dir="auto">The following example writes C-code that interpolates between two linear systems.
The interpolation vector <code>t</code> defines the interpolation points.</p>
<p dir="auto">The system in the example is a double-mass-spring damper, where the inertia of the load is allowed to vary:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function double_mass_model(Jl) # Inertia load
    Jm = 1  # Inertia motor
    k = 100 # Spring constant
    c0 = 1  # Dampings
    c1 = 1
    c2 = 1
    A = [
        0.0 1 0 0
        -k/Jm -(c1 + c0)/Jm k/Jm c1/Jm
        0 0 0 1
        k/Jl c1/Jl -k/Jl -(c1 + c2)/Jl
    ]
    B = [0, 1/Jm, 0, 0]
    C = [1 0 0 0]
    ss(A,B,C,0)
end

t = [1, 5] # The different inertias in the interpolation
sys = [c2d(double_mass_model(inertia), 0.01) for inertia in t]
SymbolicControlSystems.print_c_array(stdout, sys, t, &quot;mass_spring_damper&quot;)"><pre><span class="pl-k">function</span> <span class="pl-en">double_mass_model</span>(Jl) <span class="pl-c"><span class="pl-c">#</span> Inertia load</span>
    Jm <span class="pl-k">=</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> Inertia motor</span>
    k <span class="pl-k">=</span> <span class="pl-c1">100</span> <span class="pl-c"><span class="pl-c">#</span> Spring constant</span>
    c0 <span class="pl-k">=</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> Dampings</span>
    c1 <span class="pl-k">=</span> <span class="pl-c1">1</span>
    c2 <span class="pl-k">=</span> <span class="pl-c1">1</span>
    A <span class="pl-k">=</span> [
        <span class="pl-c1">0.0</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>
        <span class="pl-k">-</span>k<span class="pl-k">/</span>Jm <span class="pl-k">-</span>(c1 <span class="pl-k">+</span> c0)<span class="pl-k">/</span>Jm k<span class="pl-k">/</span>Jm c1<span class="pl-k">/</span>Jm
        <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span>
        k<span class="pl-k">/</span>Jl c1<span class="pl-k">/</span>Jl <span class="pl-k">-</span>k<span class="pl-k">/</span>Jl <span class="pl-k">-</span>(c1 <span class="pl-k">+</span> c2)<span class="pl-k">/</span>Jl
    ]
    B <span class="pl-k">=</span> [<span class="pl-c1">0</span>, <span class="pl-c1">1</span><span class="pl-k">/</span>Jm, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>]
    C <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>]
    <span class="pl-c1">ss</span>(A,B,C,<span class="pl-c1">0</span>)
<span class="pl-k">end</span>

t <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">5</span>] <span class="pl-c"><span class="pl-c">#</span> The different inertias in the interpolation</span>
sys <span class="pl-k">=</span> [<span class="pl-c1">c2d</span>(<span class="pl-c1">double_mass_model</span>(inertia), <span class="pl-c1">0.01</span>) <span class="pl-k">for</span> inertia <span class="pl-k">in</span> t]
SymbolicControlSystems<span class="pl-k">.</span><span class="pl-c1">print_c_array</span>(<span class="pl-c1">stdout</span>, sys, t, <span class="pl-s"><span class="pl-pds">"</span>mass_spring_damper<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">This will print C-code functions for the interpolation of each of the system matrices. See the docstring for <code>print_c_array</code> for more customization options.</p>
</article></div>