<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p>This is alpha-quality software. It is under active development. Optimistically, I hope to have it and its dependencies reasonably well documented and tested, and all the libraries registered, by the end of the year. There is a roadmap issue <a href="https://github.com/chriselrod/ProbabilityModels.jl/issues/5">here</a>.</p>
<p>The primary goal of this library is to make it as easy as possible to specify models that run as quickly as possible $-$ providing both log densities and the associated gradients. This allows the library to be a front end to Hamiltonian Monte Carlo backends, such as <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a>. <a href="https://github.com/TuringLang/AdvancedHMC.jl">AdvancedHMC.jl</a>/<a href="https://github.com/TuringLang/Turing.jl">Turing's NUTS</a> is also probably worth looking into, as it <a href="https://discourse.julialang.org/t/mcmc-landscape/25654/11?u=elrod" rel="nofollow">reportedly converges the most reliably</a>, at least within DiffEqBayes.</p>
<p><em>A brief introduction.</em></p>
<p>First, you specify a model using a DSL:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> PaddedMatrices, StructuredMatrices, DistributionParameters, LoopVectorization
<span class="pl-k">using</span> InplaceDHMC, VectorizedRNG
<span class="pl-k">using</span> Random, SpecialFunctions, MCMCChainSummaries, LinearAlgebra
<span class="pl-k">using</span> ProbabilityModels, LoopVectorization, SLEEFPirates, SIMDPirates, ProbabilityDistributions, PaddedMatrices
<span class="pl-k">using</span> ProbabilityModels<span class="pl-k">:</span> HierarchicalCentering, ∂HierarchicalCentering, ITPExpectedValue, ∂ITPExpectedValue
<span class="pl-k">using</span> DistributionParameters<span class="pl-k">:</span> CovarianceMatrix, MissingDataVector<span class="pl-c"><span class="pl-c">#</span>, add</span>
<span class="pl-k">using</span> PaddedMatrices<span class="pl-k">:</span> vexp
BLAS<span class="pl-k">.</span><span class="pl-c1">set_num_threads</span>(<span class="pl-c1">1</span>)

<span class="pl-c1">@model</span> ITPModel <span class="pl-k">begin</span>
    <span class="pl-c"><span class="pl-c">#</span> Non-hierarchical Priors</span>
    ρ <span class="pl-k">~</span> <span class="pl-c1">Beta</span>(<span class="pl-c1">3</span>, <span class="pl-c1">1</span>)
    lκ <span class="pl-k">~</span> <span class="pl-c1">lsgg</span>(<span class="pl-c1">8.5</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">3.0</span>, <span class="pl-c1">1.5271796258079011</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 1, σ² = 10</span>
    σ <span class="pl-k">~</span> <span class="pl-c1">Gamma</span>(<span class="pl-c1">1.5</span>, <span class="pl-c1">0.25</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 6, σ² = 2.4</span>
    θ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>)
    L <span class="pl-k">~</span> <span class="pl-c1">LKJ</span>(<span class="pl-c1">2.0</span>)
    <span class="pl-c"><span class="pl-c">#</span> Hierarchical Priors.</span>
    <span class="pl-c"><span class="pl-c">#</span> h subscript, for highest in the hierarhcy.</span>
    μₕ₁ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    μₕ₂ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    σₕ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    <span class="pl-c"><span class="pl-c">#</span> Raw μs; non-cenetered parameterization</span>
    μᵣ₁ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>() <span class="pl-c"><span class="pl-c">#</span> μ = 0, σ = 1</span>
    μᵣ₂ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>() <span class="pl-c"><span class="pl-c">#</span> μ = 0, σ = 1</span>
    <span class="pl-c"><span class="pl-c">#</span> Center the μs</span>
    μᵦ₁ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(μᵣ₁, μₕ₁, σₕ)
    μᵦ₂ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(μᵣ₂, μₕ₂, σₕ)
    σᵦ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    <span class="pl-c"><span class="pl-c">#</span> Raw βs; non-cenetered parameterization</span>
    βᵣ₁ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>()
    βᵣ₂ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>()
    <span class="pl-c"><span class="pl-c">#</span> Center the βs.</span>
    β₁ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(βᵣ₁, μᵦ₁, σᵦ, domains)
    β₂ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(βᵣ₂, μᵦ₂, σᵦ, domains)
    <span class="pl-c"><span class="pl-c">#</span> Likelihood</span>
    κ <span class="pl-k">=</span> <span class="pl-c1">vexp</span>(lκ)
    μ₁ <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">ITPExpectedValue</span>(time, β₁, κ, θ))
    μ₂ <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">ITPExpectedValue</span>(time, β₂, κ, θ))
    Σ <span class="pl-k">=</span> <span class="pl-c1">CovarianceMatrix</span>(ρ, <span class="pl-c1">Diagonal</span>(σ) <span class="pl-k">*</span> L, time)
    <span class="pl-c"><span class="pl-c">#</span> Tuple (Y₁, Y₂)</span>
    (Y₁, Y₂) <span class="pl-k">~</span> <span class="pl-c1">Normal</span>((μ₁, μ₂)[AvailableData], Σ[AvailableData])
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> Defined model: ITPModel.</span>
<span class="pl-c"><span class="pl-c">#</span> Unknowns: Y₂, domains, μₕ₂, μᵣ₁, time, σ, AvailableData, σᵦ, θ, μᵣ₂, ρ, σₕ, lκ, μₕ₁, L, Y₁, βᵣ₂, βᵣ₁.</span></pre></div>
<p>The <code>@model</code> macro uses the following expression to define a struct and several functions.
The struct has one field for each unknown.</p>
<p>We can then define an instance of the struct, where we specify each of these unknowns either with an instance (e.g. assign a piece of data), or with a type.
Those specified with a type are unknown parameters (of that type); those specified with an instance treat that instance as known priors or data. For example,
(if we had the appropriate functions defined in scope), we could create an instance with:</p>
<div class="highlight highlight-source-julia"><pre>K <span class="pl-k">=</span> <span class="pl-c1">7</span>; D <span class="pl-k">=</span> <span class="pl-c1">3</span>
data <span class="pl-k">=</span> <span class="pl-c1">ITPModel</span>(
    domains <span class="pl-k">=</span> domains,
    AvailableData <span class="pl-k">=</span> missingness,
    Y₁ <span class="pl-k">=</span> Y₁,
    Y₂ <span class="pl-k">=</span> Y₂,
    time <span class="pl-k">=</span> time_vector,
    L <span class="pl-k">=</span> LKJCorrCholesky{K},
    ρ <span class="pl-k">=</span> RealVector{K,<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>)},
    lκ <span class="pl-k">=</span> RealVector{K},
    θ <span class="pl-k">=</span> RealVector{K},
    μₕ₁ <span class="pl-k">=</span> RealFloat,
    μₕ₂ <span class="pl-k">=</span> RealFloat,
    μᵣ₁ <span class="pl-k">=</span> RealVector{D},
    μᵣ₂ <span class="pl-k">=</span> RealVector{D},
    βᵣ₁ <span class="pl-k">=</span> RealVector{K},
    βᵣ₂ <span class="pl-k">=</span> RealVector{K},
    σᵦ <span class="pl-k">=</span> RealFloat{<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">Inf</span>)},
    σₕ <span class="pl-k">=</span> RealFloat{<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">Inf</span>)},
    σ <span class="pl-k">=</span> RealVector{K,<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">Inf</span>)}
)</pre></div>
<p>This would let <code>Y₁</code> equal the variable <code>Y₁</code>, while <code>ρ</code> is a vector (with length <code>K=7</code>) of unknown parameters bounded between 0 and 1. The default bounds are <code>(-Inf,Inf)</code>.</p>
<p>Before spewing boilerplate to generate random true values and fake data, a brief summary of the model:
We have longitudinal multivariate observations for some number of subjects. However, not all observations are measured at all times. That is, while subjects may be measured at multiple times (I use $T=36$ times below), only some measurements are taken at any given time, yielding missing data.
Therefore, we subset the full covariance matrix (produced from a vector of autocorrelations, and the Cholesky factor of a covariance matrix across measurements) to find the marginal.</p>
<p>The expected value is function of time (<code>ITPExpectedValue</code>). This function returns a matrix  (<code>time x measurement</code>), so we <code>vec</code> it and subset it.</p>
<p>We also expect some measurements to bare more in common than others, so we group them into "domains", and provide hierarchical priors. We use a non-cenetered parameterization, and the function <code>HierarchicalCentering</code> then centers our parameters for us. There are two methods we use above: one takes scalars, to transform a vector. The other accepts different domain means and standard deviations, and uses these to transform a vector, taking the indices from the <code>Domains</code> argument. That is, if the first element of <code>Domains</code> is 2, indicating that the first 2 measurements belong to the first domain, it will transform the first two elements of <code>βᵣ₁</code> with the first element of <code>μᵦ₁</code> and <code>σᵦ</code> (if either <code>μᵦ₁</code> or <code>σᵦ</code> are scalars, they will be broadcasted across each domain).</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">rinvscaledgamma</span>(<span class="pl-k">::</span><span class="pl-c1">Val{N}</span>,a<span class="pl-k">::</span><span class="pl-c1">T</span>,b<span class="pl-k">::</span><span class="pl-c1">T</span>,c<span class="pl-k">::</span><span class="pl-c1">T</span>) <span class="pl-k">where</span> {N,T}
    rg <span class="pl-k">=</span> <span class="pl-c1">MutableFixedSizeVector</span><span class="pl-c1">{N,T}</span>(undef)
    log100 <span class="pl-k">=</span> <span class="pl-c1">log</span>(<span class="pl-c1">100</span>)
    <span class="pl-c1">@inbounds</span> <span class="pl-k">for</span> n <span class="pl-k">∈</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        rg[n] <span class="pl-k">=</span> log100 <span class="pl-k">/</span> <span class="pl-c1">exp</span>(<span class="pl-c1">log</span>(VectorizedRNG<span class="pl-k">.</span><span class="pl-c1">randgamma</span>(a<span class="pl-k">/</span>c)) <span class="pl-k">/</span> c <span class="pl-k">+</span> b)
    <span class="pl-k">end</span>
    rg
<span class="pl-k">end</span>

<span class="pl-k">const</span> domains <span class="pl-k">=</span> ProbabilityModels<span class="pl-k">.</span><span class="pl-c1">Domains</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

<span class="pl-k">const</span> n_endpoints <span class="pl-k">=</span> <span class="pl-c1">sum</span>(domains)

<span class="pl-k">const</span> times <span class="pl-k">=</span> <span class="pl-c1">MutableFixedSizeVector</span><span class="pl-c1">{36,Float64,36}</span>(undef); times <span class="pl-k">.=</span> <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">35</span>;

structured_missing_pattern <span class="pl-k">=</span> <span class="pl-c1">push!</span>(<span class="pl-c1">vcat</span>(([<span class="pl-c1">1</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>] <span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">7</span>)<span class="pl-k">...</span>), <span class="pl-c1">1</span>);
missing_pattern <span class="pl-k">=</span> <span class="pl-c1">vcat</span>(
    structured_missing_pattern, <span class="pl-c1">fill</span>(<span class="pl-c1">1</span>, <span class="pl-c1">4</span><span class="pl-c1">length</span>(times)), structured_missing_pattern, structured_missing_pattern
);

<span class="pl-k">const</span> availabledata <span class="pl-k">=</span> <span class="pl-c1">MissingDataVector</span><span class="pl-c1">{Float64}</span>(missing_pattern);

<span class="pl-k">const</span> κ₀ <span class="pl-k">=</span> (<span class="pl-c1">8.5</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">3.0</span>)

<span class="pl-en">AR1</span>(ρ, t) <span class="pl-k">=</span> <span class="pl-c1">@.</span> ρ <span class="pl-k">^</span> <span class="pl-c1">abs</span>(t <span class="pl-k">-</span> t<span class="pl-k">'</span>)


<span class="pl-k">function</span> <span class="pl-en">generate_true_parameters</span>(domains, times, κ₀)
    K <span class="pl-k">=</span> <span class="pl-c1">sum</span>(domains)
    D <span class="pl-k">=</span> <span class="pl-c1">length</span>(domains)
    T <span class="pl-k">=</span> <span class="pl-c1">length</span>(times)
    μ <span class="pl-k">=</span> <span class="pl-c1">MutableFixedSizeVector</span><span class="pl-c1">{K,Float64}</span>(undef)
    offset <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> i <span class="pl-k">∈</span> domains
        domain_mean <span class="pl-k">=</span> <span class="pl-c1">5</span><span class="pl-c1">randn</span>()
        <span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">1</span><span class="pl-k">+</span>offset<span class="pl-k">:</span>i<span class="pl-k">+</span>offset
            μ[j] <span class="pl-k">=</span> domain_mean <span class="pl-k">+</span> <span class="pl-c1">5</span><span class="pl-c1">randn</span>()
        <span class="pl-k">end</span>
        offset <span class="pl-k">+=</span> i
    <span class="pl-k">end</span>
    σ <span class="pl-k">=</span> VectorizedRNG<span class="pl-k">.</span><span class="pl-c1">randgamma</span>( <span class="pl-c1">6.0</span>, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">6.0</span>)
    ρ <span class="pl-k">=</span> VectorizedRNG<span class="pl-k">.</span><span class="pl-c1">randbeta</span>(<span class="pl-c1">4.0</span>,<span class="pl-c1">4.0</span>)
    κ <span class="pl-k">=</span> <span class="pl-c1">rinvscaledgamma</span>(<span class="pl-c1">Val</span>(K), κ₀<span class="pl-k">...</span>)
    lt <span class="pl-k">=</span> <span class="pl-c1">last</span>(times)
    β <span class="pl-k">=</span> <span class="pl-c1">MutableFixedSizeVector</span><span class="pl-c1">{7,Float64,7}</span>(( <span class="pl-c1">0.0625</span>,  <span class="pl-c1">0.0575</span>,  <span class="pl-c1">0.0525</span>,  <span class="pl-c1">0.0475</span>,  <span class="pl-c1">0.0425</span>,  <span class="pl-c1">0.04</span>,  <span class="pl-c1">0.0375</span>))
    θ₁ <span class="pl-k">=</span> <span class="pl-c1">@.</span> μ<span class="pl-s"><span class="pl-pds">'</span> - β<span class="pl-pds">'</span></span> <span class="pl-k">*</span> ( <span class="pl-c1">1.0</span> <span class="pl-k">-</span> <span class="pl-c1">exp</span>( <span class="pl-k">-</span> κ<span class="pl-s"><span class="pl-pds">'</span> * times) ) / (1.0 - exp( - κ<span class="pl-pds">'</span></span> <span class="pl-k">*</span> lt) ) 
    θ₂ <span class="pl-k">=</span> <span class="pl-c1">@.</span> μ<span class="pl-s"><span class="pl-pds">'</span> + β<span class="pl-pds">'</span></span> <span class="pl-k">*</span> ( <span class="pl-c1">1.0</span> <span class="pl-k">-</span> <span class="pl-c1">exp</span>( <span class="pl-k">-</span> κ<span class="pl-s"><span class="pl-pds">'</span> * times) ) / (1.0 - exp( - κ<span class="pl-pds">'</span></span> <span class="pl-k">*</span> lt) ) 
    
    L_T, info <span class="pl-k">=</span> LAPACK<span class="pl-k">.</span><span class="pl-c1">potrf!</span>(<span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>, <span class="pl-c1">AR1</span>(ρ, times))
    <span class="pl-c1">@inbounds</span> <span class="pl-k">for</span> tc <span class="pl-k">∈</span> <span class="pl-c1">2</span><span class="pl-k">:</span>T, tr <span class="pl-k">∈</span> <span class="pl-c1">1</span><span class="pl-k">:</span>tc<span class="pl-k">-</span><span class="pl-c1">1</span>
        L_T[tr,tc] <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
    <span class="pl-k">end</span>
    X <span class="pl-k">=</span> PaddedMatrices<span class="pl-k">.</span><span class="pl-c1">MutableFixedSizeMatrix</span><span class="pl-c1">{K,K+3,Float64,K}</span>(undef); <span class="pl-c1">randn!</span>(X)
    U_K, info <span class="pl-k">=</span> LAPACK<span class="pl-k">.</span><span class="pl-c1">potrf!</span>(<span class="pl-s"><span class="pl-pds">'</span>U<span class="pl-pds">'</span></span>, BLAS<span class="pl-k">.</span><span class="pl-c1">syrk!</span>(<span class="pl-s"><span class="pl-pds">'</span>U<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>N<span class="pl-pds">'</span></span>, σ, X, <span class="pl-c1">0.0</span>, <span class="pl-c1">zero</span>(MutableFixedSizeMatrix{K,K,Float64,K})))
    (
        U_K <span class="pl-k">=</span> U_K, L_T <span class="pl-k">=</span> L_T, μ <span class="pl-k">=</span> μ, θ₁ <span class="pl-k">=</span> θ₁, θ₂ <span class="pl-k">=</span> θ₂, domains <span class="pl-k">=</span> domains, time <span class="pl-k">=</span> times
    )
<span class="pl-k">end</span>

<span class="pl-c1">@generated</span> <span class="pl-k">function</span> <span class="pl-en">randomize!</span>(
    sp<span class="pl-k">::</span><span class="pl-c1">PaddedMatrices.StackPointer</span>,
    A<span class="pl-k">::</span><span class="pl-c1">AbstractArray{T,P}</span>,
    B<span class="pl-k">::</span><span class="pl-c1">PaddedMatrices.AbstractMutableFixedSizeMatrix{M,M,T}</span>,
    C<span class="pl-k">::</span><span class="pl-c1">PaddedMatrices.AbstractMutableFixedSizeMatrix{N,N,T}</span>,
    D<span class="pl-k">::</span><span class="pl-c1">PaddedMatrices.AbstractMutableFixedSizeMatrix{M,N,T}</span>
) <span class="pl-k">where</span> {M,N,T,P}
    <span class="pl-k">quote</span>
        <span class="pl-c1">@boundscheck</span> <span class="pl-k">begin</span>
            d <span class="pl-k">=</span> <span class="pl-c1">size</span>(A,<span class="pl-c1">1</span>)
            <span class="pl-k">for</span> p <span class="pl-k">∈</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-k">$</span>(P<span class="pl-k">-</span><span class="pl-c1">1</span>)
                d <span class="pl-k">*=</span> <span class="pl-c1">size</span>(A,p)
            <span class="pl-k">end</span>
            d <span class="pl-k">==</span> M<span class="pl-k">*</span>N <span class="pl-k">||</span> PaddedMatrices<span class="pl-k">.</span><span class="pl-c1">ThrowBoundsError</span>(<span class="pl-s"><span class="pl-pds">"</span>Earlier dims size(A) == <span class="pl-v">$(<span class="pl-c1">size</span>(A))</span> does not match size(D) == (<span class="pl-v">$M</span>,<span class="pl-v">$N</span>)<span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        ptr <span class="pl-k">=</span> <span class="pl-c1">pointer</span>(sp, <span class="pl-k">$</span>T)
        E <span class="pl-k">=</span> <span class="pl-c1">PtrMatrix</span><span class="pl-c1">{$M,$N,$T,$M}</span>( ptr )
        F <span class="pl-k">=</span> <span class="pl-c1">PtrMatrix</span><span class="pl-c1">{$M,$N,$T,$M}</span>( ptr <span class="pl-k">+</span> <span class="pl-k">$</span>(<span class="pl-c1">sizeof</span>(T) <span class="pl-k">*</span> M <span class="pl-k">*</span> N) )
        ptr_A <span class="pl-k">=</span> <span class="pl-c1">pointer</span>(A)
        GC<span class="pl-k">.</span><span class="pl-c1">@preserve</span> A <span class="pl-k">begin</span>
            <span class="pl-k">for</span> n <span class="pl-k">∈</span> <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">size</span>(A,<span class="pl-k">$</span>P)<span class="pl-k">-</span><span class="pl-c1">1</span>
                Aₙ <span class="pl-k">=</span> <span class="pl-c1">PtrMatrix</span><span class="pl-c1">{$M,$N,$T,$M}</span>( ptr_A <span class="pl-k">+</span> n<span class="pl-k">*</span><span class="pl-k">$</span>(<span class="pl-c1">sizeof</span>(T)<span class="pl-k">*</span>M<span class="pl-k">*</span>N) )
                <span class="pl-c1">randn!</span>(ProbabilityModels<span class="pl-k">.</span>GLOBAL_PCGs[<span class="pl-c1">1</span>], E)
                <span class="pl-c1">mul!</span>(F, B, E)
                Aₙ <span class="pl-k">.=</span> D
                PaddedMatrices<span class="pl-k">.</span><span class="pl-c1">gemm!</span>(Aₙ, F, C)
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
        sp
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-en">sample_data</span>( N, truth, missingness, missingvals <span class="pl-k">=</span> (<span class="pl-en">Val</span><span class="pl-c1">{0}</span>(),<span class="pl-en">Val</span><span class="pl-c1">{0}</span>()) ) <span class="pl-k">=</span> <span class="pl-c1">sample_data</span>( N, truth, missingness, missingvals, truth<span class="pl-k">.</span>domains )
<span class="pl-c1">@generated</span> <span class="pl-k">function</span> <span class="pl-en">sample_data</span>(
    N<span class="pl-k">::</span><span class="pl-c1">Tuple{Int,Int}</span>,
	truth, missingness,
	<span class="pl-k">::</span><span class="pl-c1">Tuple{Val{M1},Val{M2}}</span>,
	<span class="pl-k">::</span><span class="pl-c1">ProbabilityModels.Domains{S}</span>
) <span class="pl-k">where</span> {S,M1,M2}
    K <span class="pl-k">=</span> <span class="pl-c1">sum</span>(S)
    D <span class="pl-k">=</span> <span class="pl-c1">length</span>(S)
    <span class="pl-k">quote</span>
        N₁, N₂ <span class="pl-k">=</span> N
        L_T <span class="pl-k">=</span> truth<span class="pl-k">.</span>L_T
        U_K <span class="pl-k">=</span> truth<span class="pl-k">.</span>U_K
        T <span class="pl-k">=</span> <span class="pl-c1">size</span>(L_T,<span class="pl-c1">1</span>)

        sp <span class="pl-k">=</span> ProbabilityModels<span class="pl-k">.</span>STACK_POINTER_REF[]
        (sp,Y₁) <span class="pl-k">=</span> PaddedMatrices<span class="pl-k">.</span><span class="pl-c1">DynamicPtrArray</span><span class="pl-c1">{Float64,3}</span>(sp, (T, <span class="pl-k">$</span>K, N₁), T)
        (sp,Y₂) <span class="pl-k">=</span> PaddedMatrices<span class="pl-k">.</span><span class="pl-c1">DynamicPtrArray</span><span class="pl-c1">{Float64,3}</span>(sp, (T, <span class="pl-k">$</span>K, N₂), T)
        <span class="pl-c1">randomize!</span>(sp, Y₁, L_T, U_K, truth<span class="pl-k">.</span>θ₁)
        <span class="pl-c1">randomize!</span>(sp, Y₂, L_T, U_K, truth<span class="pl-k">.</span>θ₂)
        
        c <span class="pl-k">=</span> <span class="pl-c1">length</span>(missingness<span class="pl-k">.</span>indices)
        inds <span class="pl-k">=</span> missingness<span class="pl-k">.</span>indices
        
        Y₁sub <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(Y₁, (T <span class="pl-k">*</span> <span class="pl-k">$</span>K, N₁))[inds, :]
        <span class="pl-k">$</span>(M1 <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> ? <span class="pl-k">quote</span>
            Y₁union <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{Union{Missing,Float64}}</span>(Y₁sub)
            perm <span class="pl-k">=</span> <span class="pl-c1">randperm</span>(<span class="pl-c1">length</span>(Y₁sub))
            <span class="pl-c1">@inbounds</span> <span class="pl-k">for</span> m <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-k">$</span>M1
                Y₁union[perm[m]] <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">missing</span>
	    	<span class="pl-k">end</span>
    		Y₁ <span class="pl-k">=</span> <span class="pl-c1">convert</span>(MissingDataArray{<span class="pl-k">$</span>M1,<span class="pl-c1">Bounds</span>(<span class="pl-k">-</span><span class="pl-c1">Inf</span>,<span class="pl-c1">Inf</span>)}, Y₁union)
		<span class="pl-k">end</span> : <span class="pl-k">quote</span>
			Y₁ <span class="pl-k">=</span> Y₁sub
		<span class="pl-k">end</span>)

        Y₂sub <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(Y₂, (T <span class="pl-k">*</span> <span class="pl-k">$</span>K, N₂))[inds, :]
		<span class="pl-k">$</span>(M2 <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> ? <span class="pl-k">quote</span>
            Y₂union <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{Union{Missing,Float64}}</span>(Y₂sub)
            perm <span class="pl-k">=</span> <span class="pl-c1">randperm</span>(<span class="pl-c1">length</span>(Y₂sub))
			<span class="pl-c1">@inbounds</span> <span class="pl-k">for</span> m <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-k">$</span>M2
                Y₂union[perm[m]] <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">missing</span>
            <span class="pl-k">end</span>
            Y₂ <span class="pl-k">=</span> <span class="pl-c1">convert</span>(MissingDataArray{<span class="pl-k">$</span>M2,<span class="pl-c1">Bounds</span>(<span class="pl-k">-</span><span class="pl-c1">Inf</span>,<span class="pl-c1">Inf</span>)},Y₂union)
		<span class="pl-k">end</span> : <span class="pl-k">quote</span>
		    Y₂ <span class="pl-k">=</span> Y₂sub
		<span class="pl-k">end</span>)
		
        <span class="pl-c1">ITPModel</span>(
            domains <span class="pl-k">=</span> truth<span class="pl-k">.</span>domains,
	        AvailableData <span class="pl-k">=</span> missingness,
            Y₁ <span class="pl-k">=</span> Y₁,
            Y₂ <span class="pl-k">=</span> Y₂,
            time <span class="pl-k">=</span> truth<span class="pl-k">.</span>time,
            L <span class="pl-k">=</span> LKJCorrCholesky{<span class="pl-k">$</span>K},
            ρ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>K,<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>)},
            lκ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>K},
            θ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>K},
            μₕ₁ <span class="pl-k">=</span> RealFloat,
            μₕ₂ <span class="pl-k">=</span> RealFloat,
            μᵣ₁ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>D},
            μᵣ₂ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>D},
            βᵣ₁ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>K},
            βᵣ₂ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>K},
            σᵦ <span class="pl-k">=</span> RealFloat{<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">Inf</span>)},
            σₕ <span class="pl-k">=</span> RealFloat{<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">Inf</span>)},
            σ <span class="pl-k">=</span> RealVector{<span class="pl-k">$</span>K,<span class="pl-c1">Bounds</span>(<span class="pl-c1">0</span>,<span class="pl-c1">Inf</span>)}
        )
    <span class="pl-k">end</span>
<span class="pl-k">end</span>
</pre></div>
<p>The library <a href="https://github.com/chriselrod/DistributionParameters.jl">DistributionParameters.jl</a> provides a variety of parameter types.
These types define constrianing transformations, to transform an unconstrained parameter vector and add the appropriate jacobians.</p>
<p>All parameters are typed by size. The library currently provides a DynamicHMC interface, defining <code>logdensity(::Value,::ITPModel)</code> and <code>logdensity(::ValueGradient,::ITPModel)</code> methods.</p>
<div class="highlight highlight-source-julia"><pre></pre></div>
<p>For comparison, a Stan implementation of this model takes about to 13ms to evaluate the gradient.</p>
<p>The <code>@model</code> macro also defines a helper function for <a href="https://mc-stan.org/docs/2_19/reference-manual/variable-transforms-chapter.html" rel="nofollow">constraining</a> unconstrained parameter vectors:</p>
<div class="highlight highlight-source-julia"><pre></pre></div>
<p>So you can use this to constrain the unconstrained parameter vectors <code>DynamicHMC</code> sampled and proceed with your convergence assessments and posterior analysis as normal.</p>
<p>Alternatively, it also supports <a href="https://github.com/chriselrod/MCMCChainSummaries.jl">MCMCChainSummaries.jl</a>, constraining the parameters for you and providing posterior summaries as well as plotting methods:</p>
<div class="highlight highlight-source-julia"><pre></pre></div>
<p>The difference in time between the slowest chain (748 s) and the overall time (775 s) roughly yields the compilation time. If we refit the model, the total time would roughly equal the length of time to sample from the slowest chain.</p>
<p>If you don't pass the sampler a tuner object, it'll create one by default with <code>M=5</code> and <code>term=50</code>. The section on <a href="https://mc-stan.org/docs/2_19/reference-manual/hmc-algorithm-parameters.html" rel="nofollow">Automatic Parameter Tuning</a> in the Stan reference manual explains what these mean. I added an extra slow adaptation step (with twice the length of the previous step) and doubled the length of the terminal adaptation window (a final window calculating step size), as this makes adaptation more consistent.
The idea is to try and decrease the probability of one or two chains being much slower than the others. We can look at NUTS statistics of the chains:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">NUTS_statistics</span>.(chains)
<span class="pl-c1">18</span><span class="pl-k">-</span>element Array{DynamicHMC<span class="pl-k">.</span>NUTS_Statistics{Float64,DataStructures<span class="pl-k">.</span>Accumulator{DynamicHMC<span class="pl-k">.</span>Termination,Int64},DataStructures<span class="pl-k">.</span>Accumulator{Int64,Int64}},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.94</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.94</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">6</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">93</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">13</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">87</span><span class="pl-k">%</span>
                         
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.96</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.96</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                                 
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.96</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.96</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                  
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.96</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.97</span> <span class="pl-c1">0.99</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                 
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.98</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">17</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">83</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">93</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">7</span><span class="pl-k">%</span> <span class="pl-c1">8</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                          
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.96</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.97</span> <span class="pl-c1">0.99</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                        
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.94</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.95</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">4</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">96</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">8</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">92</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                          
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.95</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.96</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                          
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.94</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.95</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">97</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">6</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">94</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
          
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.94</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.94</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">98</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">4</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">96</span><span class="pl-k">%</span> <span class="pl-c1">8</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                  
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.91</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.92</span> <span class="pl-c1">0.97</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">12</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">87</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">28</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">71</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
        
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.96</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.96</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">8</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
 
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.96</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.96</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">8</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                 
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.94</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.94</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">4</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">96</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">8</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">92</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                  
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.95</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.95</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">97</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
                  
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.96</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.96</span> <span class="pl-c1">0.98</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">99</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">8</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>
          
 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.91</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.92</span> <span class="pl-c1">0.97</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">16</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">83</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">39</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">60</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">8</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span>

 Hamiltonian Monte Carlo sample of length <span class="pl-c1">10000</span>
  acceptance rate mean<span class="pl-k">:</span> <span class="pl-c1">0.91</span>, min<span class="pl-k">/</span><span class="pl-c1">25</span><span class="pl-k">%/</span>median<span class="pl-k">/</span><span class="pl-c1">75</span><span class="pl-k">%/</span>max<span class="pl-k">:</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.92</span> <span class="pl-c1">0.97</span> <span class="pl-c1">0.99</span> <span class="pl-c1">1.0</span>
  termination<span class="pl-k">:</span> AdjacentDivergent <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span><span class="pl-k">%</span> AdjacentTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">9</span><span class="pl-k">%</span> DoubledTurn <span class="pl-k">=&gt;</span> <span class="pl-c1">89</span><span class="pl-k">%</span>
  depth<span class="pl-k">:</span> <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span><span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span> <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">20</span><span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">78</span><span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span><span class="pl-k">%</span></pre></div>
<p>and see that the fifth chain had an acceptance rate of 0.98, vs the target acceptance rate of <code>δ = 0.95</code>. 7% of samples hit a treedepth of 7, meaning this was probably the slowest chain (worker 15). Maybe increasing term further would help.</p>
<p><em>Overview of how the library works.</em></p>
<p>The <code>ITPModel</code> struct (or whatever you've named your model, with the first argument to the macro) is defined as a struct with a field for each unknown. Each field is parametrically typed.</p>
<p><code>logdensity</code> and <code>constrain</code> are defined as generated functions, so that they can compile appropriate code given these parameteric types. The <code>@model</code> macro does a little preprocessing of the expression; most of the code generation occurs within these generated functions.</p>
<p>The macro's preprocessing consists of simply translating the sampling statements into log probability increments (<code>target</code>, terminology taken from the <a href="https://mc-stan.org/users/documentation/" rel="nofollow">Stan</a> language), and lowering the expression.</p>
<p>We can manually perform these passes on the expression (note that variables with <code>#</code> in their names are NOT comments -- they're hygienic names, guaranteeing all the variables I add don't clash with any of the model's variables):</p>
<div class="highlight highlight-source-julia"><pre>itp_q <span class="pl-k">=</span> <span class="pl-k">quote</span>
    <span class="pl-c"><span class="pl-c">#</span> Non-hierarchical Priors</span>
    ρ <span class="pl-k">~</span> <span class="pl-c1">Beta</span>(<span class="pl-c1">3</span>, <span class="pl-c1">1</span>)
    κ <span class="pl-k">~</span> <span class="pl-c1">Gamma</span>(<span class="pl-c1">0.1</span>, <span class="pl-c1">0.1</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 1, σ² = 10</span>
    σ <span class="pl-k">~</span> <span class="pl-c1">Gamma</span>(<span class="pl-c1">1.5</span>, <span class="pl-c1">0.25</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 6, σ² = 2.4</span>
    θ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>)
    L <span class="pl-k">~</span> <span class="pl-c1">LKJ</span>(<span class="pl-c1">2.0</span>)

    <span class="pl-c"><span class="pl-c">#</span> Hierarchical Priors.</span>
    <span class="pl-c"><span class="pl-c">#</span> h subscript, for highest in the hierarhcy.</span>
    μₕ₁ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    μₕ₂ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    σₕ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    <span class="pl-c"><span class="pl-c">#</span> Raw μs; non-cenetered parameterization</span>
    μᵣ₁ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>() <span class="pl-c"><span class="pl-c">#</span> μ = 0, σ = 1</span>
    μᵣ₂ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>() <span class="pl-c"><span class="pl-c">#</span> μ = 0, σ = 1</span>
    <span class="pl-c"><span class="pl-c">#</span> Center the μs</span>
    μᵦ₁ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(μᵣ₁, μₕ₁, σₕ)
    μᵦ₂ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(μᵣ₂, μₕ₂, σₕ)
    σᵦ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> μ = 0</span>
    <span class="pl-c"><span class="pl-c">#</span> Raw βs; non-cenetered parameterization</span>
    βᵣ₁ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>()
    βᵣ₂ <span class="pl-k">~</span> <span class="pl-c1">Normal</span>()
    <span class="pl-c"><span class="pl-c">#</span> Center the βs.</span>
    β₁ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(βᵣ₁, μᵦ₁, σᵦ, domains)
    β₂ <span class="pl-k">=</span> <span class="pl-c1">HierarchicalCentering</span>(βᵣ₂, μᵦ₂, σᵦ, domains)

    <span class="pl-c"><span class="pl-c">#</span> Likelihood</span>
    μ₁ <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">ITPExpectedValue</span>(time, β₁, κ, θ))
    μ₂ <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">ITPExpectedValue</span>(time, β₂, κ, θ))
    Σ <span class="pl-k">=</span> <span class="pl-c1">CovarianceMatrix</span>(ρ, <span class="pl-c1">Diagonal</span>(σ) <span class="pl-k">*</span> L, time)

    (Y₁, Y₂) <span class="pl-k">~</span> <span class="pl-c1">Normal</span>((μ₁, μ₂)[AvailableData], Σ[AvailableData])

<span class="pl-k">end</span>

itp_preprocessed <span class="pl-k">=</span> itp_q <span class="pl-k">|&gt;</span> ProbabilityModels<span class="pl-k">.</span>translate_sampling_statements <span class="pl-k">|&gt;</span> ProbabilityModels<span class="pl-k">.</span>flatten_expression;

<span class="pl-k">using</span> MacroTools<span class="pl-k">:</span> striplines

<span class="pl-c1">striplines</span>(itp_preprocessed)</pre></div>
<p>This yields the following expression:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">quote</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##1## = Beta(ρ, 3, 1)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##2## = vadd(target, ##SSAValue##1##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##2##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##4## = Gamma(κ, 0.1, 0.1)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##5## = vadd(target, ##SSAValue##4##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##5##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##7## = Gamma(σ, 1.5, 0.25)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##8## = vadd(target, ##SSAValue##7##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##8##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##10## = Normal(θ, 10)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##11## = vadd(target, ##SSAValue##10##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##11##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##13## = LKJ(L, 2.0)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##14## = vadd(target, ##SSAValue##13##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##14##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##16## = Normal(μₕ₁, 10)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##17## = vadd(target, ##SSAValue##16##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##17##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##19## = Normal(μₕ₂, 10)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##20## = vadd(target, ##SSAValue##19##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##20##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##22## = Normal(σₕ, 10)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##23## = vadd(target, ##SSAValue##22##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##23##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##25## = Normal(μᵣ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##26## = vadd(target, ##SSAValue##25##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##26##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##28## = Normal(μᵣ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##29## = vadd(target, ##SSAValue##28##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##29##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##31## = HierarchicalCentering(μᵣ₁, μₕ₁, σₕ)</span>
    μᵦ₁ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##31##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##33## = HierarchicalCentering(μᵣ₂, μₕ₂, σₕ)</span>
    μᵦ₂ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##33##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##35## = Normal(σᵦ, 10)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##36## = vadd(target, ##SSAValue##35##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##36##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##38## = Normal(βᵣ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##39## = vadd(target, ##SSAValue##38##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##39##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##41## = Normal(βᵣ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##42## = vadd(target, ##SSAValue##41##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##42##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##44## = HierarchicalCentering(βᵣ₁, μᵦ₁, σᵦ, domains)</span>
    β₁ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##44##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##46## = HierarchicalCentering(βᵣ₂, μᵦ₂, σᵦ, domains)</span>
    β₂ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##46##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##48## = ITPExpectedValue(time, β₁, κ, θ)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##49## = vec(##SSAValue##48##)</span>
    μ₁ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##49##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##51## = ITPExpectedValue(time, β₂, κ, θ)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##52## = vec(##SSAValue##51##)</span>
    μ₂ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##52##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##54## = Diagonal(σ)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##55## = ##SSAValue##54## * L</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##56## = CovarianceMatrix(ρ, ##SSAValue##55##, time)</span>
    Σ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##56##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##58## = Core.tuple(Y₁, Y₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##59## = Core.tuple(μ₁, μ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##60## = Base.getindex(##SSAValue##59##, AvailableData)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##61## = Base.getindex(Σ, AvailableData)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##62## = Normal(##SSAValue##58##, ##SSAValue##60##, ##SSAValue##61##)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##63## = vadd(target, ##SSAValue##62##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##63##</span>
<span class="pl-k">end</span></pre></div>
<p>After translating the sampling statements into function calls, the code is transformed with <code>Meta.lower</code>. The resulting <code>Code.Info</code> is then transformed back into a Julia expression, as you see above. This has the advantage of flattening the expression, so that there is at most only a single function call per line.</p>
<p>The <code>logdensity</code> generated functions are defined with the above expressions assigned to a variable, so that they can apply additional transformations.</p>
<p>I'll focus on the <code>ValueGradient</code> method, as this one performs the more interesting transformations. Aside from loading and constraining all the parameters from an input vector, it performs a <code>reverse_diff!</code> pass on the expression.</p>
<div class="highlight highlight-source-julia"><pre>forward_pass <span class="pl-k">=</span> <span class="pl-k">quote</span> <span class="pl-k">end</span>
reverse_pass <span class="pl-k">=</span> <span class="pl-k">quote</span> <span class="pl-k">end</span>
tracked_vars <span class="pl-k">=</span> <span class="pl-c1">Set</span>([:ρ, :κ, :σ, :θ, <span class="pl-c1">:L</span>, :μₕ₁, :μₕ₂, :σₕ, :μᵣ₁, :μᵣ₂, :σᵦ, :βᵣ₁, :βᵣ₂, ]);
ProbabilityModels<span class="pl-k">.</span><span class="pl-c1">reverse_diff_pass!</span>(forward_pass, reverse_pass, itp_preprocessed, tracked_vars);
<span class="pl-c1">striplines</span>(forward_pass)</pre></div>
<p>It walks the expression, replacing each function with a function that also returns the adjoint; the forward pass becomes:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">quote</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##1##, ###adjoint###_##∂##SSAValue##1####∂ρ##) = ProbabilityDistributions.∂Beta(ρ, 3, 1, Val{(true, false, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##2## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##1##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##2##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##4##, ###adjoint###_##∂##SSAValue##4####∂κ##) = ProbabilityDistributions.∂Gamma(κ, 0.1, 0.1, Val{(true, false, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##5## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##4##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##5##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##7##, ###adjoint###_##∂##SSAValue##7####∂σ##) = ProbabilityDistributions.∂Gamma(σ, 1.5, 0.25, Val{(true, false, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##8## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##7##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##8##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##10##, ###adjoint###_##∂##SSAValue##10####∂θ##) = ProbabilityDistributions.∂Normal(θ, 10, Val{(true, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##11## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##10##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##11##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##13##, ###adjoint###_##∂##SSAValue##13####∂L##) = ProbabilityDistributions.∂LKJ(L, 2.0, Val{(true, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##14## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##13##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##14##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##16##, ###adjoint###_##∂##SSAValue##16####∂μₕ₁##) = ProbabilityDistributions.∂Normal(μₕ₁, 10, Val{(true, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##17## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##16##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##17##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##19##, ###adjoint###_##∂##SSAValue##19####∂μₕ₂##) = ProbabilityDistributions.∂Normal(μₕ₂, 10, Val{(true, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##20## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##19##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##20##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##22##, ###adjoint###_##∂##SSAValue##22####∂σₕ##) = ProbabilityDistributions.∂Normal(σₕ, 10, Val{(true, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##23## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##22##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##23##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##25##, ###adjoint###_##∂##SSAValue##25####∂μᵣ₁##) = ProbabilityDistributions.∂Normal(μᵣ₁, Val{(true,)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##26## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##25##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##26##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##28##, ###adjoint###_##∂##SSAValue##28####∂μᵣ₂##) = ProbabilityDistributions.∂Normal(μᵣ₂, Val{(true,)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##29## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##28##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##29##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##31##, ###adjoint###_##∂##SSAValue##31####∂μᵣ₁##, ###adjoint###_##∂##SSAValue##31####∂μₕ₁##, ###adjoint###_##∂##SSAValue##31####∂σₕ##) = ∂HierarchicalCentering(μᵣ₁, μₕ₁, σₕ, Val{(true, true, true)}())</span>
    μᵦ₁ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##31##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##33##, ###adjoint###_##∂##SSAValue##33####∂μᵣ₂##, ###adjoint###_##∂##SSAValue##33####∂μₕ₂##, ###adjoint###_##∂##SSAValue##33####∂σₕ##) = ∂HierarchicalCentering(μᵣ₂, μₕ₂, σₕ, Val{(true, true, true)}())</span>
    μᵦ₂ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##33##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##35##, ###adjoint###_##∂##SSAValue##35####∂σᵦ##) = ProbabilityDistributions.∂Normal(σᵦ, 10, Val{(true, false)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##36## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##35##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##36##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##38##, ###adjoint###_##∂##SSAValue##38####∂βᵣ₁##) = ProbabilityDistributions.∂Normal(βᵣ₁, Val{(true,)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##39## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##38##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##39##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##41##, ###adjoint###_##∂##SSAValue##41####∂βᵣ₂##) = ProbabilityDistributions.∂Normal(βᵣ₂, Val{(true,)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##42## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##41##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##42##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##44##, ###adjoint###_##∂##SSAValue##44####βᵣ₁##, ###adjoint###_##∂##SSAValue##44####∂μᵦ₁##, ###adjoint###_##∂##SSAValue##44####∂σᵦ##) = ∂HierarchicalCentering(βᵣ₁, μᵦ₁, σᵦ, domains, Val{(true, true, true)}())</span>
    β₁ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##44##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##46##, ###adjoint###_##∂##SSAValue##46####∂βᵣ₂##, ###adjoint###_##∂##SSAValue##46####∂μᵦ₂##, ###adjoint###_##∂##SSAValue##46####∂σᵦ##) = ∂HierarchicalCentering(βᵣ₂, μᵦ₂, σᵦ, domains, Val{(true, true, true)}())</span>
    β₂ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##46##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##48##, ###adjoint###_##∂##SSAValue##48####∂β₁##, ###adjoint###_##∂##SSAValue##48####∂κ##, ###adjoint###_##∂##SSAValue##48####∂θ##) = ProbabilityModels.∂ITPExpectedValue(time, β₁, κ, θ, Val{(true, true, true)}())</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##49##, ###adjoint###_##∂##SSAValue##49####∂##SSAValue##48####) = ProbabilityModels.∂vec(##SSAValue##48##)</span>
    μ₁ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##49##</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##51##, ###adjoint###_##∂##SSAValue##51####∂β₂##, ###adjoint###_##∂##SSAValue##51####∂κ##, ###adjoint###_##∂##SSAValue##51####∂θ##) = ProbabilityModels.∂ITPExpectedValue(time, β₂, κ, θ, Val{(true, true, true)}())</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##52##, ###adjoint###_##∂##SSAValue##52####∂##SSAValue##51####) = ProbabilityModels.∂vec(##SSAValue##51##)</span>
    μ₂ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##52##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##54## = LinearAlgebra.Diagonal(σ)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##55## = ##SSAValue##54## * L</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##56##, ###adjoint###_##∂##SSAValue##56####∂ρ##, ###adjoint###_##∂##SSAValue##56####∂##SSAValue##55####) = ProbabilityModels.DistributionParameters.∂CovarianceMatrix(ρ, ##SSAValue##55##, time, Val{(true, true)}())</span>
    Σ <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##56##</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##58## = Core.tuple(Y₁, Y₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##59## = Core.tuple(μ₁, μ₂)</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##60##, ###adjoint###_##∂##SSAValue##60####∂##SSAValue##59####) = PaddedMatrices.∂getindex(##SSAValue##59##, AvailableData)</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##61##, ###adjoint###_##∂##SSAValue##61####∂Σ##) = PaddedMatrices.∂getindex(Σ, AvailableData)</span>
    (<span class="pl-c"><span class="pl-c">#</span>#SSAValue##62##, ###adjoint###_##∂##SSAValue##62####∂##SSAValue##60####, ###adjoint###_##∂##SSAValue##62####∂##SSAValue##61####) = ProbabilityDistributions.∂Normal(##SSAValue##58##, ##SSAValue##60##, ##SSAValue##61##, Val{(false, true, true)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>#SSAValue##63## = ProbabilityModels.SIMDPirates.vadd(target, ##SSAValue##62##)</span>
    target <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>#SSAValue##63##</span>
<span class="pl-k">end</span></pre></div>
<p>It also prepends the corresponding operations to a second expression for the reverse diff pass:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">striplines</span>(reverse_pass)</pre></div>
<p>yielding:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">quote</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##63## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##63##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##62## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##63##, ###seed#####SSAValue##62##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##63##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##61## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##62##, ###adjoint###_##∂##SSAValue##62####∂##SSAValue##61####, ###seed#####SSAValue##61##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##60## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##62##, ###adjoint###_##∂##SSAValue##62####∂##SSAValue##60####, ###seed#####SSAValue##60##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###Σ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##61##, ###adjoint###_##∂##SSAValue##61####∂Σ##, ###seed###Σ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##59## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##60##, ###adjoint###_##∂##SSAValue##60####∂##SSAValue##59####, ###seed#####SSAValue##59##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##59##[2], ###seed###μ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##59##[1], ###seed###μ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##56## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###Σ, ###seed#####SSAValue##56##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##55## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##56##, ###adjoint###_##∂##SSAValue##56####∂##SSAValue##55####, ###seed#####SSAValue##55##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###ρ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##56##, ###adjoint###_##∂##SSAValue##56####∂ρ##, ###seed###ρ)</span>
    (<span class="pl-c"><span class="pl-c">#</span>##adjoint###_##∂##SSAValue##55####∂##SSAValue##54####, ###adjoint###_##∂##SSAValue##55####∂L##) = ProbabilityModels.∂mul(##SSAValue##54##, L, Val{(true, true)}())</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###L = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##55##, ###adjoint###_##∂##SSAValue##55####∂L##, ###seed###L)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##54## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##55##, ###adjoint###_##∂##SSAValue##55####∂##SSAValue##54####, ###seed#####SSAValue##54##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##54##, ###seed###σ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##52## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###μ₂, ###seed#####SSAValue##52##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##51## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##52##, ###adjoint###_##∂##SSAValue##52####∂##SSAValue##51####, ###seed#####SSAValue##51##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###θ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##51##, ###adjoint###_##∂##SSAValue##51####∂θ##, ###seed###θ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###κ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##51##, ###adjoint###_##∂##SSAValue##51####∂κ##, ###seed###κ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###β₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##51##, ###adjoint###_##∂##SSAValue##51####∂β₂##, ###seed###β₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##49## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###μ₁, ###seed#####SSAValue##49##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##48## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##49##, ###adjoint###_##∂##SSAValue##49####∂##SSAValue##48####, ###seed#####SSAValue##48##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###θ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##48##, ###adjoint###_##∂##SSAValue##48####∂θ##, ###seed###θ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###κ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##48##, ###adjoint###_##∂##SSAValue##48####∂κ##, ###seed###κ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###β₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##48##, ###adjoint###_##∂##SSAValue##48####∂β₁##, ###seed###β₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##46## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###β₂, ###seed#####SSAValue##46##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σᵦ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##46##, ###adjoint###_##∂##SSAValue##46####∂σᵦ##, ###seed###σᵦ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μᵦ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##46##, ###adjoint###_##∂##SSAValue##46####∂μᵦ₂##, ###seed###μᵦ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###βᵣ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##46##, ###adjoint###_##∂##SSAValue##46####∂βᵣ₂##, ###seed###βᵣ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##44## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###β₁, ###seed#####SSAValue##44##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σᵦ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##44##, ###adjoint###_##∂##SSAValue##44####∂σᵦ##, ###seed###σᵦ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μᵦ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##44##, ###adjoint###_##∂##SSAValue##44####∂μᵦ₁##, ###seed###μᵦ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###βᵣ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##44##, ###adjoint###_##∂##SSAValue##44####∂βᵣ₁##, ###seed###βᵣ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##42## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##42##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##41## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##42##, ###seed#####SSAValue##41##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##42##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###βᵣ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##41##, ###adjoint###_##∂##SSAValue##41####∂βᵣ₂##, ###seed###βᵣ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##39## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##39##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##38## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##39##, ###seed#####SSAValue##38##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##39##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###βᵣ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##38##, ###adjoint###_##∂##SSAValue##38####∂βᵣ₁##, ###seed###βᵣ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##36## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##36##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##35## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##36##, ###seed#####SSAValue##35##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##36##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σᵦ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##35##, ###adjoint###_##∂##SSAValue##35####∂σᵦ##, ###seed###σᵦ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##33## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###μᵦ₂, ###seed#####SSAValue##33##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σₕ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##33##, ###adjoint###_##∂##SSAValue##33####∂σₕ##, ###seed###σₕ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μₕ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##33##, ###adjoint###_##∂##SSAValue##33####∂μₕ₂##, ###seed###μₕ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μᵣ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##33##, ###adjoint###_##∂##SSAValue##33####∂μᵣ₂##, ###seed###μᵣ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##31## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###μᵦ₁, ###seed#####SSAValue##31##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σₕ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##31##, ###adjoint###_##∂##SSAValue##31####∂σₕ##, ###seed###σₕ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μₕ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##31##, ###adjoint###_##∂##SSAValue##31####∂μₕ₁##, ###seed###μₕ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μᵣ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##31##, ###adjoint###_##∂##SSAValue##31####∂μᵣ₁##, ###seed###μᵣ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##29## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##29##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##28## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##29##, ###seed#####SSAValue##28##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##29##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μᵣ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##28##, ###adjoint###_##∂##SSAValue##28####∂μᵣ₂##, ###seed###μᵣ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##26## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##26##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##25## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##26##, ###seed#####SSAValue##25##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##26##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μᵣ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##25##, ###adjoint###_##∂##SSAValue##25####∂μᵣ₁##, ###seed###μᵣ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##23## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##23##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##22## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##23##, ###seed#####SSAValue##22##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##23##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σₕ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##22##, ###adjoint###_##∂##SSAValue##22####∂σₕ##, ###seed###σₕ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##20## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##20##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##19## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##20##, ###seed#####SSAValue##19##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##20##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μₕ₂ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##19##, ###adjoint###_##∂##SSAValue##19####∂μₕ₂##, ###seed###μₕ₂)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##17## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##17##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##16## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##17##, ###seed#####SSAValue##16##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##17##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###μₕ₁ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##16##, ###adjoint###_##∂##SSAValue##16####∂μₕ₁##, ###seed###μₕ₁)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##14## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##14##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##13## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##14##, ###seed#####SSAValue##13##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##14##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###L = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##13##, ###adjoint###_##∂##SSAValue##13####∂L##, ###seed###L)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##11## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##11##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##10## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##11##, ###seed#####SSAValue##10##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##11##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###θ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##10##, ###adjoint###_##∂##SSAValue##10####∂θ##, ###seed###θ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##8## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##8##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##7## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##8##, ###seed#####SSAValue##7##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##8##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###σ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##7##, ###adjoint###_##∂##SSAValue##7####∂σ##, ###seed###σ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##5## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##5##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##4## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##5##, ###seed#####SSAValue##4##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###target = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##5##, ###seed###target)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###κ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##4##, ###adjoint###_##∂##SSAValue##4####∂κ##, ###seed###κ)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##2## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed###target, ###seed#####SSAValue##2##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed#####SSAValue##1## = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##2##, ###seed#####SSAValue##1##)</span>
    <span class="pl-c"><span class="pl-c">#</span>##seed###ρ = ProbabilityModels.PaddedMatrices.RESERVED_INCREMENT_SEED_RESERVED(###seed#####SSAValue##1##, ###adjoint###_##∂##SSAValue##1####∂ρ##, ###seed###ρ)</span>
<span class="pl-k">end</span></pre></div>
<p>The <code>RESERVED_INCREMENT_SEED_RESERVED</code> and <code>RESERVED_MULTIPLY_SEED_RESERVED</code> fall back to <code>mulladd</code> and <code>*</code> methods, respectively. They however allow for different overloads.</p>
<p>The keys to performance are that this source-to-source reverse mode differentation avoids unnecessary overhead, and does not interfere with vectorization, which typical dual-number based approaches, like Stan's var type or ForwardDiff's duals, do.
The reverse diff pass uses <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a> as well as custom derivatives defined for probability distributions and a few other special functions.</p>
<p>By defining high level derivatives for commonly used functions we can optimize them much further than if we relied on autodiff for them. Additionally, we abuse multiple dispatch here: whenevever there is some structure we can exploit in the adjoint, we return a type with <code>INCREMENT/MULTIPLY</code> methods defined to exploit it. Examples include <a href="https://github.com/chriselrod/StructuredMatrices.jl/blob/master/src/block_diagonal.jl#L4">BlockDiagonalColumnView</a>s or various <a href="https://github.com/chriselrod/ProbabilityModels.jl/blob/master/src/adjoints.jl#L55">Reducer</a> types.</p>
<p>Another optimization is that it performs a <a href="https://github.com/chriselrod/PaddedMatrices.jl/blob/master/src/stack_pointer.jl#L55">stack pointer pass</a>. Supported functions are passed a pointer to a preallocated block of memory. This memory reuse can both give us considerable savings, and allow the memory to stay hot in the cache. <a href="https://github.com/chriselrod/PaddedMatrices.jl">PaddedMatrices.jl</a>, aside from providing <a href="https://bayeswatch.org/2019/06/06/small-matrix-multiplication-performance-shootout/" rel="nofollow">optimized matrix operations</a> (contrary to the name, it's performance advantage over other libraries is actually greatest when none of them use padding), it also provides <code>PtrArray</code> (parameterized by size) and <code>DynamicPtrArray</code> (dynamically sized) types for taking advantage of this preallocated memory.</p>
</article></div>