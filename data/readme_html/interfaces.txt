<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-interfaces" class="anchor" aria-hidden="true" href="#interfaces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interfaces</h1>
<p dir="auto"><a href="https://rafaqz.github.io/Interfaces.jl/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://rafaqz.github.io/Interfaces.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/rafaqz/Interfaces.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/rafaqz/Interfaces.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/rafaqz/Interfaces.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/94554ad7f759d5216b8e8c3c9ac752437f70f432956e7d37dfe4b1f107a16064/68747470733a2f2f636f6465636f762e696f2f67682f72616661717a2f496e74657266616365732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/rafaqz/Interfaces.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Macros for defining the required behaviours of Julia interfaces,
and stating that an object implements them.</p>
<p dir="auto">The goal is to get as much as possible out of defining an interface,
specifically:</p>
<ul dir="auto">
<li>Traits: All <code>@implements</code> declarations produce compile-time traits that can be
checked by other packages - for the whole interface and all of it's optional
components.</li>
<li>Tests: <code>@implements</code> declarations should be tested in package tests.</li>
<li>Docs: interface documentation can be inserted into trait documentation.</li>
</ul>
<p dir="auto"><strong>Note: the syntax here is likely to change over 2022 as we work out the best ways to define interfaces</strong></p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<p dir="auto">See the <code>IterationInterface</code> in BaseInterfaces.jl (a subpackage of this package)
for examples of <code>@interface</code> and <code>@implements</code>.</p>
<p dir="auto">But heres an examples using Animals, and the implementation of a Duck.</p>
<p dir="auto">First we define the interface methods, and a list of mandatory and
optional properties of the interface, with conditions, using the <code>@interface</code>
macro.</p>
<p dir="auto">The <code>@interface</code> macro takes two argumens</p>
<ol dir="auto">
<li>The name of the interface, which should usully end with "Interface"</li>
<li>The <code>mandatory</code> and <code>optional</code> components of the interface written as a <code>NamedTuple</code>,
with functions or tuple of functions that test them.</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module Animals

using Interfaces

# Define the methods the interface uses
function age end
function walk end
function talk end
function dig end

# Define the interface conditions
@interface AnimalInterface (
    mandatory = (;
        age = (
            x -&gt; age(x) isa Real,
            x -&gt; age(x) &gt;= 0,
        )
    ),
    optional = (;
        walk = x -&gt; walk(x) isa String,
        talk = x -&gt; talk(x) isa Symbol,
        dig = x -&gt; dig(x) isa String,
    ),
)

end"><pre><span class="pl-k">module</span> Animals

<span class="pl-k">using</span> Interfaces

<span class="pl-c"><span class="pl-c">#</span> Define the methods the interface uses</span>
<span class="pl-k">function</span> age <span class="pl-k">end</span>
<span class="pl-k">function</span> walk <span class="pl-k">end</span>
<span class="pl-k">function</span> talk <span class="pl-k">end</span>
<span class="pl-k">function</span> dig <span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Define the interface conditions</span>
<span class="pl-c1">@interface</span> AnimalInterface (
    mandatory <span class="pl-k">=</span> (;
        age <span class="pl-k">=</span> (
            x <span class="pl-k">-&gt;</span> <span class="pl-c1">age</span>(x) <span class="pl-k">isa</span> Real,
            x <span class="pl-k">-&gt;</span> <span class="pl-c1">age</span>(x) <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>,
        )
    ),
    optional <span class="pl-k">=</span> (;
        walk <span class="pl-k">=</span> x <span class="pl-k">-&gt;</span> <span class="pl-c1">walk</span>(x) <span class="pl-k">isa</span> String,
        talk <span class="pl-k">=</span> x <span class="pl-k">-&gt;</span> <span class="pl-c1">talk</span>(x) <span class="pl-k">isa</span> Symbol,
        dig <span class="pl-k">=</span> x <span class="pl-k">-&gt;</span> <span class="pl-c1">dig</span>(x) <span class="pl-k">isa</span> String,
    ),
)

<span class="pl-k">end</span></pre></div>
<p dir="auto">Now we can implement the AnimalInterface, for a Duck.</p>
<p dir="auto">The <code>@implements</code> macro takes three arguments.</p>
<ol dir="auto">
<li>The interface type, with a tuple of optional components in
its first type parameter.</li>
<li>The the type of the object implementing the interface</li>
<li>Some code that defines an instance of that type that can be used in tests.</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Interfaces

# Define our Duck object
struct Duck
    age::Int
end

# And extend Animals methods for it
Animals.age(duck::Duck) = duck.age
Animals.walk(::Duck) = &quot;waddle&quot;
Animals.talk(::Duck) = :quack

# And define the interface
@implements Animals.AnimalInterface{(:walk, :talk)} Duck [Duck(1), Duck(2)]"><pre><span class="pl-k">using</span> Interfaces

<span class="pl-c"><span class="pl-c">#</span> Define our Duck object</span>
<span class="pl-k">struct</span> Duck
    age<span class="pl-k">::</span><span class="pl-c1">Int</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> And extend Animals methods for it</span>
Animals<span class="pl-k">.</span><span class="pl-en">age</span>(duck<span class="pl-k">::</span><span class="pl-c1">Duck</span>) <span class="pl-k">=</span> duck<span class="pl-k">.</span>age
Animals<span class="pl-k">.</span><span class="pl-en">walk</span>(<span class="pl-k">::</span><span class="pl-c1">Duck</span>) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>waddle<span class="pl-pds">"</span></span>
Animals<span class="pl-k">.</span><span class="pl-en">talk</span>(<span class="pl-k">::</span><span class="pl-c1">Duck</span>) <span class="pl-k">=</span> <span class="pl-c1">:quack</span>

<span class="pl-c"><span class="pl-c">#</span> And define the interface</span>
<span class="pl-c1">@implements</span> Animals<span class="pl-k">.</span>AnimalInterface{(<span class="pl-c1">:walk</span>, <span class="pl-c1">:talk</span>)} Duck [<span class="pl-c1">Duck</span>(<span class="pl-c1">1</span>), <span class="pl-c1">Duck</span>(<span class="pl-c1">2</span>)]</pre></div>
<p dir="auto">Now we have some methods we can use as traits, and test the interface with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Interfaces.implements(Animals.AnimalInterface{:walk}, Duck)
true

julia&gt; Interfaces.implements(Animals.AnimalInterface{:dig}, Duck)
false

# We can test the interface
julia&gt; Interfaces.test(Animals.AnimalInterface, Duck)
true

# Or components of it:
julia&gt; Interfaces.test(Animals.AnimalInterface{(:walk,:talk)}, Duck)
true

# Test another object
struct Chicken end

julia&gt; Interfaces.implements(Animals.AnimalInterface, Chicken()) 
false"><pre>julia<span class="pl-k">&gt;</span> Interfaces<span class="pl-k">.</span><span class="pl-c1">implements</span>(Animals<span class="pl-k">.</span>AnimalInterface{<span class="pl-c1">:walk</span>}, Duck)
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> Interfaces<span class="pl-k">.</span><span class="pl-c1">implements</span>(Animals<span class="pl-k">.</span>AnimalInterface{<span class="pl-c1">:dig</span>}, Duck)
<span class="pl-c1">false</span>

<span class="pl-c"><span class="pl-c">#</span> We can test the interface</span>
julia<span class="pl-k">&gt;</span> Interfaces<span class="pl-k">.</span><span class="pl-c1">test</span>(Animals<span class="pl-k">.</span>AnimalInterface, Duck)
<span class="pl-c1">true</span>

<span class="pl-c"><span class="pl-c">#</span> Or components of it:</span>
julia<span class="pl-k">&gt;</span> Interfaces<span class="pl-k">.</span><span class="pl-c1">test</span>(Animals<span class="pl-k">.</span>AnimalInterface{(<span class="pl-c1">:walk</span>,<span class="pl-c1">:talk</span>)}, Duck)
<span class="pl-c1">true</span>

<span class="pl-c"><span class="pl-c">#</span> Test another object</span>
<span class="pl-k">struct</span> Chicken <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> Interfaces<span class="pl-k">.</span><span class="pl-c1">implements</span>(Animals<span class="pl-k">.</span>AnimalInterface, <span class="pl-c1">Chicken</span>()) 
<span class="pl-c1">false</span></pre></div>
<p dir="auto">If you think it should behave differently or there is better syntax,
please make an issue.</p>
</article></div>