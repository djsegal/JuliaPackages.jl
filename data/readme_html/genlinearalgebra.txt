<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a id="user-content-linear-algebra-on-any-field/ring"></a></p>
<p dir="auto"><a id="user-content-linear-algebra-on-any-field/ring-1"></a></p>
<h1 dir="auto"><a id="user-content-linear-algebra-on-any-fieldring" class="anchor" aria-hidden="true" href="#linear-algebra-on-any-fieldring"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Linear algebra on any field/ring</h1>
<ul dir="auto">
<li><a href="index.md#Linear-algebra-on-any-field/ring">Linear algebra on any field/ring</a></li>
</ul>
<p dir="auto"><a id="user-content-genlinearalgebra" href="#GenLinearAlgebra">#</a>
<strong><code>GenLinearAlgebra</code></strong> — <em>Module</em>.</p>
<p dir="auto">GenLinearAlgebra: linear algebra over arbitrary fields and rings</p>
<p dir="auto">The  linear  algebra  package  in  Julia  is  not  suitable  for  a general mathematics  package: it assumes  the field is  the Real or Complex numbers and  uses floating  point to  do approximate  computations. For example the invertible  rational matrix <code>[1//(n+m) for  n in 1:11, m  in 1:11]</code> has for <code>LinearAlgebra</code> a <code>rank</code> of 10 and a <code>Float64</code> nullspace of dimension 1.</p>
<p dir="auto">Here we are interested in functions which work over any field (or sometimes any ring) and assume exact computations.</p>
<p dir="auto">For more information, look at the helpstrings of <code>echelon!, rowspace, independent_rows, in_rowspace, intersect_rowspace,  lnullspace, GenLinearAlgebra.nullspace, GenLinearAlgebra.rank, solutionmat,   charpoly, comatrix, permanent, symmetric_power, exterior_power, ratio,   diagconj_elt, transporter, bigcell_decomposition, traces_words_mats</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L1-L18">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.echelon!" href="#GenLinearAlgebra.echelon!">#</a>
<strong><code>GenLinearAlgebra.echelon!</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>echelon!(m::AbstractMatrix)</code></p>
<p dir="auto">puts  <code>m</code> in echelon  form in-place and  returns:</p>
<p dir="auto">(<code>m</code>, indices of linearly independent  rows of original <code>m</code>)</p>
<p dir="auto">The  echelon form transforms the  rows of m into  a particular basis of the rowspace. The first non-zero element of each line is 1, and such an element is also the only non-zero in its column. This function works in any field.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[0 0 0 1; 1 1 0 1; 0 1 0 1; 1 0 0 0]//1
4×4 Matrix{Rational{Int64}}:
 0//1  0//1  0//1  1//1
 1//1  1//1  0//1  1//1
 0//1  1//1  0//1  1//1
 1//1  0//1  0//1  0//1

julia&gt; echelon!(m)
(Rational{Int64}[1//1 0//1 0//1 0//1; 0//1 1//1 0//1 0//1; 0//1 0//1 0//1 1//1; 0//1 0//1 0//1 0//1], [2, 3, 1])"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[0 0 0 1; 1 1 0 1; 0 1 0 1; 1 0 0 0]//1
4×4 Matrix{Rational{Int64}}:
 0//1  0//1  0//1  1//1
 1//1  1//1  0//1  1//1
 0//1  1//1  0//1  1//1
 1//1  0//1  0//1  0//1

julia&gt; echelon!(m)
(Rational{Int64}[1//1 0//1 0//1 0//1; 0//1 1//1 0//1 0//1; 0//1 0//1 0//1 1//1; 0//1 0//1 0//1 0//1], [2, 3, 1])
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L27-L48">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.rowspace" href="#GenLinearAlgebra.rowspace">#</a>
<strong><code>GenLinearAlgebra.rowspace</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>rowspace(m::AbstractMatrix)</code></p>
<p dir="auto">returns a canonical form of the rowspace of <code>m</code> (the vector space generated by  the rows of <code>m</code>),  the echelon form. This  is a particular basis of the rowspace  of <code>m</code>: the first non-zero element of each line is 1, and such an element  is also the only non-zero  element in its column. Integer matrices are converted to <code>Rational</code> before applying this function.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[1 2;2 4;5 6]
3×2 Matrix{Int64}:
 1  2
 2  4
 5  6

julia&gt; rowspace(m)
2×2 view(::Matrix{Rational{Int64}}, 1:2, :) with eltype Rational{Int64}:
 1//1  0//1
 0//1  1//1"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[1 2;2 4;5 6]
3×2 Matrix{Int64}:
 1  2
 2  4
 5  6

julia&gt; rowspace(m)
2×2 view(::Matrix{Rational{Int64}}, 1:2, :) with eltype Rational{Int64}:
 1//1  0//1
 0//1  1//1
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L73-L94">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.rank" href="#GenLinearAlgebra.rank">#</a>
<strong><code>GenLinearAlgebra.rank</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>GenLinearAlgebra.rank(m::AbstractMatrix)</code></p>
<p dir="auto">computes  exactly  the  rank  of  <code>m</code>.  Not  exported  to not conflict with <code>LinearAlgebra</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; hilbert(r)=[1//(n+m) for n in 1:r, m in 1:r];

julia&gt; LinearAlgebra.rank(hilbert(11))
10

julia&gt; GenLinearAlgebra.rank(hilbert(11)) # correct value
11"><pre lang="julia-rep1" class="notranslate"><code>julia&gt; hilbert(r)=[1//(n+m) for n in 1:r, m in 1:r];

julia&gt; LinearAlgebra.rank(hilbert(11))
10

julia&gt; GenLinearAlgebra.rank(hilbert(11)) # correct value
11
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L128-L143">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.independent_rows" href="#GenLinearAlgebra.independent_rows">#</a>
<strong><code>GenLinearAlgebra.independent_rows</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>independent_rows(m::AbstractMatrix)</code></p>
<p dir="auto">returns  a vector of the  indices of a set  of independent rows of <code>m</code> (the lexicographically first such set).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[1 2;2 4;5 6]
3×2 Matrix{Int64}:
 1  2
 2  4
 5  6

julia&gt; independent_rows(m)
2-element Vector{Int64}:
 1
 3"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[1 2;2 4;5 6]
3×2 Matrix{Int64}:
 1  2
 2  4
 5  6

julia&gt; independent_rows(m)
2-element Vector{Int64}:
 1
 3
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L102-L120">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.in_rowspace" href="#GenLinearAlgebra.in_rowspace">#</a>
<strong><code>GenLinearAlgebra.in_rowspace</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>in_rowspace(v::AbstractVector,m::AbstractMatrix)</code></p>
<p dir="auto">whether <code>v</code> is in the rowspace <code>m</code>. The matrix <code>m</code> should be an echelonized matrix like what is returned by function <code>rowspace</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L196-L201">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.intersect_rowspace" href="#GenLinearAlgebra.intersect_rowspace">#</a>
<strong><code>GenLinearAlgebra.intersect_rowspace</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>intersect_rowspace(m::AbstractMatrix,n::AbstractMatrix)</code></p>
<p dir="auto">The intersection of the rowspaces of <code>m</code> and <code>n</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L184-L188">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.lnullspace" href="#GenLinearAlgebra.lnullspace">#</a>
<strong><code>GenLinearAlgebra.lnullspace</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>lnullspace(m::AbstractMatrix)</code></p>
<p dir="auto">The left nullspace of <code>m</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L177-L181">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.nullspace" href="#GenLinearAlgebra.nullspace">#</a>
<strong><code>GenLinearAlgebra.nullspace</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>GenLinearAlgebra.nullspace(m::AbstractMatrix)</code></p>
<p dir="auto">computes the right nullspace of <code>m</code> in a type-preserving way. Not exported to avoid conflict with LinearAlgebra</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L146-L151">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.solutionmat" href="#GenLinearAlgebra.solutionmat">#</a>
<strong><code>GenLinearAlgebra.solutionmat</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>solutionmat(mat,v)</code></p>
<p dir="auto">returns  one solution of the  equation <code>transpose(mat)*x=v</code> or <code>nothing</code> if no  such  solution  exists.  Similar  to  <code>transpose(mat)\v</code> when <code>mat</code> is invertible.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[2 -4 1;0 0 -4;1 -2 -1]
3×3 Matrix{Int64}:
 2  -4   1
 0   0  -4
 1  -2  -1

julia&gt; x=solutionmat(m,[10,-20, -10])
3-element Vector{Rational{Int64}}:
  5//1
 15//4
  0//1

julia&gt; m'*x
3-element Vector{Rational{Int64}}:
  10//1
 -20//1
 -10//1

julia&gt; solutionmat(m,[10, 20, -10])"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[2 -4 1;0 0 -4;1 -2 -1]
3×3 Matrix{Int64}:
 2  -4   1
 0   0  -4
 1  -2  -1

julia&gt; x=solutionmat(m,[10,-20, -10])
3-element Vector{Rational{Int64}}:
  5//1
 15//4
  0//1

julia&gt; m'*x
3-element Vector{Rational{Int64}}:
  10//1
 -20//1
 -10//1

julia&gt; solutionmat(m,[10, 20, -10])
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L466-L494">source</a><br></p>
<p dir="auto"><code>solutionmat(m,n::AbstractMatrix)</code></p>
<p dir="auto">return a matrix <code>x</code> such that <code>x*m==n</code>. This is interesting when <code>m</code>  is not invertible.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L542-L547">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.charpoly" href="#GenLinearAlgebra.charpoly">#</a>
<strong><code>GenLinearAlgebra.charpoly</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>charpoly(M::Matrix)</code></p>
<p dir="auto">The characteristic polynomial of <code>M</code> (as a <code>Vector</code> of coefficients). This function works over any ring.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L227-L232">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.comatrix" href="#GenLinearAlgebra.comatrix">#</a>
<strong><code>GenLinearAlgebra.comatrix</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>comatrix(M::Matrix)</code></p>
<p dir="auto">is defined by <code>comatrix(M)*M=det(M)*one(M)</code>. This function works over any ring.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L235-L240">source</a><br></p>
<p dir="auto"><a id="user-content-genlinearalgebra.permanent" href="#GenLinearAlgebra.permanent">#</a>
<strong><code>GenLinearAlgebra.permanent</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>permanent(m)</code></p>
<p dir="auto">returns the <em>permanent</em> of the square matrix <code>m</code>, which is defined by  <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="0ee197c5b176ba90117cde379d4aa558">$\sum_{p\in\frak S_n}\prod_{i=1}^n m[i,p(i)]$</math-renderer>.</p>
<p dir="auto">Note the similarity of the definition of  the permanent to the definition of the determinant.  In  fact the only  difference is the missing sign of the permutation.  However the  permanent is quite unlike the determinant, for example   it is  not  multilinear or  alternating.  It   has  however important combinatorical properties.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; permanent([0 1 1 1;1 0 1 1;1 1 0 1;1 1 1 0])
9 # inefficient way to compute the number of derangements of 1:4

julia&gt; permanent([1 1 0 1 0 0 0; 0 1 1 0 1 0 0;0 0 1 1 0 1 0; 0 0 0 1 1 0 1;1 0 0 0 1 1 0;0 1 0 0 0 1 1;1 0 1 0 0 0 1])
24 # 24 permutations fit the projective plane of order 2 "><pre lang="julia-repl" class="notranslate"><code>julia&gt; permanent([0 1 1 1;1 0 1 1;1 1 0 1;1 1 1 0])
9 # inefficient way to compute the number of derangements of 1:4

julia&gt; permanent([1 1 0 1 0 0 0; 0 1 1 0 1 0 0;0 0 1 1 0 1 0; 0 0 0 1 1 0 1;1 0 0 0 1 1 0;0 1 0 0 0 1 1;1 0 1 0 0 0 1])
24 # 24 permutations fit the projective plane of order 2 
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L372-L391">source</a><br></p>
<p dir="auto"><a id="user-content-GenLinearAlgebra.symmetric_power" href="#GenLinearAlgebra.symmetric_power">#</a>
<strong><code>GenLinearAlgebra.symmetric_power</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>symmetric_power(m,n)</code></p>
<p dir="auto">returns the <code>n</code>-th symmetric power of the square matrix <code>m</code>, in the basis  naturally indexed by the <code>multisets</code> of <code>1:n</code>, where <code>n=size(m,1)</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[1 2;3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; Int.(symmetric_power(m,2))
3×3 Matrix{Int64}:
 1   2   4
 6  10  16
 9  12  16"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[1 2;3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; Int.(symmetric_power(m,2))
3×3 Matrix{Int64}:
 1   2   4
 6  10  16
 9  12  16
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L402-L420">source</a><br></p>
<p dir="auto"><a id="user-content-GenLinearAlgebra.exterior_power" href="#GenLinearAlgebra.exterior_power">#</a>
<strong><code>GenLinearAlgebra.exterior_power</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>exterior_power(mat,n)</code></p>
<p dir="auto"><code>mat</code>  should be a square matrix.  The function returns the <code>n</code>-th exterior power  of  <code>mat</code>,  in  the  basis naturally indexed by<code>combinations(1:r,n)</code> where<code>r=size(mat,1)</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; M=[1 2 3 4;2 3 4 1;3 4 1 2;4 1 2 3]
4×4 Matrix{Int64}:
 1  2  3  4
 2  3  4  1
 3  4  1  2
 4  1  2  3

julia&gt; exterior_power(M,2)
6×6 Matrix{Int64}:
  -1   -2   -7   -1  -10  -13
  -2   -8  -10  -10  -12    2
  -7  -10  -13    1    2    1
  -1  -10    1  -13    2    7
 -10  -12    2    2    8   10
 -13    2    1    7   10   -1"><pre lang="julia-repl" class="notranslate"><code>julia&gt; M=[1 2 3 4;2 3 4 1;3 4 1 2;4 1 2 3]
4×4 Matrix{Int64}:
 1  2  3  4
 2  3  4  1
 3  4  1  2
 4  1  2  3

julia&gt; exterior_power(M,2)
6×6 Matrix{Int64}:
  -1   -2   -7   -1  -10  -13
  -2   -8  -10  -10  -12    2
  -7  -10  -13    1    2    1
  -1  -10    1  -13    2    7
 -10  -12    2    2    8   10
 -13    2    1    7   10   -1
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L342-L366">source</a><br></p>
<p dir="auto"><a id="user-content-GenLinearAlgebra.ratio" href="#GenLinearAlgebra.ratio">#</a>
<strong><code>GenLinearAlgebra.ratio</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>ratio(v::abstractVector,w::abstractVector)</code></p>
<p dir="auto">ratio <code>v/w</code>, <code>nothing</code> if <code>v</code> is not a multiple of <code>w</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L454-L458">source</a><br></p>
<p dir="auto"><a id="user-content-GenLinearAlgebra.diagconj_elt" href="#GenLinearAlgebra.diagconj_elt">#</a>
<strong><code>GenLinearAlgebra.diagconj_elt</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>diagconj_elt(M,N)</code></p>
<p dir="auto"><code>M</code> and <code>N</code> must be square matrices of the same size. This function returns a  list <code>d</code>  such that  <code>N==inv(Diagonal(d))*M*Diagonal(d)</code> if  such a list exists, and <code>nothing</code> otherwise.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; M=[1 2;2 1];N=[1 4;1 1]
2×2 Matrix{Int64}:
 1  4
 1  1

julia&gt; diagconj_elt(M,N)
2-element Vector{Rational{Int64}}:
 1//1
 2//1"><pre lang="julia_repl" class="notranslate"><code>julia&gt; M=[1 2;2 1];N=[1 4;1 1]
2×2 Matrix{Int64}:
 1  4
 1  1

julia&gt; diagconj_elt(M,N)
2-element Vector{Rational{Int64}}:
 1//1
 2//1
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L550-L568">source</a><br></p>
<p dir="auto"><a id="user-content-GenLinearAlgebra.transporter" href="#GenLinearAlgebra.transporter">#</a>
<strong><code>GenLinearAlgebra.transporter</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>transporter(l1, l2 )</code></p>
<p dir="auto"><code>l1</code>  and <code>l2</code> should be vectors of  the same length of square matrices all of the same size. The result is a basis of the vector space of matrices <code>A</code> such  that for any <code>i</code> we have  <code>A*l1[i]=l2[i]*A</code> –- the basis is returned as  a vector of matrices, empty if the vector space is 0. This is useful to find whether two representations are isomorphic.</p>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L427-L435">source</a><br></p>
<p dir="auto"><a id="user-content-GenLinearAlgebra.bigcell_decomposition" href="#GenLinearAlgebra.bigcell_decomposition">#</a>
<strong><code>GenLinearAlgebra.bigcell_decomposition</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>bigcell_decomposition(M [, b])</code></p>
<p dir="auto"><code>M</code>  should be a square  matrix, and <code>b</code> specifies  a block structure for a matrix  of  same  size  as  <code>M</code>  (it  is  a  <code>Vector</code>  of  <code>Vector</code>s  whose concatenation  is <code>1:size(M,1)</code>).  If <code>b</code>  is not  given, the trivial block structure <code>[[i] for i in axes(M,1)]</code> is assumed.</p>
<p dir="auto">The  function  decomposes  <code>M</code>  as  a  product  <code>P₁ L P</code> where <code>P</code> is upper block-unitriangular   (with  identity  diagonal   blocks),  <code>P₁</code>  is  lower block-unitriangular  and <code>L</code> is block-diagonal for the block structure <code>b</code>. If  <code>M</code> is symmetric then  <code>P₁</code> is the transposed  of <code>P</code> and the result is the  pair  <code>[P,L]</code>;  else  the  result  is  the triple <code>[P₁,L,P]</code>. The only condition  for  this  decomposition  of  <code>M</code>  to  be  possible  is that the principal  minors  according  to  the  block  structure be invertible. This routine  is used  in the  Lusztig-Shoji algorithm  for computing  the Green functions  and the example  below is extracted  from the computation of the Green functions for <code>G₂</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; using LaurentPolynomials

julia&gt; @Pol q
Pol{Int64}: q

julia&gt; M=[q^6 q^0 q^3 q^3 q^5+q q^4+q^2; q^0 q^6 q^3 q^3 q^5+q q^4+q^2; q^3 q^3 q^6 q^0 q^4+q^2 q^5+q; q^3 q^3 q^0 q^6 q^4+q^2 q^5+q; q^5+q q^5+q q^4+q^2 q^4+q^2 q^6+q^4+q^2+1 q^5+2*q^3+q; q^4+q^2 q^4+q^2 q^5+q q^5+q q^5+2*q^3+q q^6+q^4+q^2+1]
6×6 Matrix{Pol{Int64}}:
 q⁶     1      q³     q³     q⁵+q        q⁴+q²
 1      q⁶     q³     q³     q⁵+q        q⁴+q²
 q³     q³     q⁶     1      q⁴+q²       q⁵+q
 q³     q³     1      q⁶     q⁴+q²       q⁵+q
 q⁵+q   q⁵+q   q⁴+q²  q⁴+q²  q⁶+q⁴+q²+1  q⁵+2q³+q
 q⁴+q²  q⁴+q²  q⁵+q   q⁵+q   q⁵+2q³+q    q⁶+q⁴+q²+1

julia&gt; bb=[[2],[4],[6],[3,5],[1]];

julia&gt; (P,L)=bigcell_decomposition(M,bb);

julia&gt; P
6×6 Matrix{Pol{Int64}}:
 1    0  0    0    0        0
 q⁻⁶  1  q⁻³  q⁻³  q⁻¹+q⁻⁵  q⁻²+q⁻⁴
 0    0  1    0    0        0
 q⁻³  0  0    1    q⁻²      q⁻¹
 q⁻¹  0  0    0    1        0
 q⁻²  0  q⁻¹  0    q⁻¹      1

julia&gt; L
6×6 Matrix{Pol{Int64}}:
 q⁶-q⁴-1+q⁻²  0   0            0     0            0
 0            q⁶  0            0     0            0
 0            0   q⁶-q⁴-1+q⁻²  0     0            0
 0            0   0            q⁶-1  0            0
 0            0   0            0     q⁶-q⁴-1+q⁻²  0
 0            0   0            0     0            q⁶-1

julia&gt; M==transpose(P)*L*P
true"><pre lang="julia-repl" class="notranslate"><code>julia&gt; using LaurentPolynomials

julia&gt; @Pol q
Pol{Int64}: q

julia&gt; M=[q^6 q^0 q^3 q^3 q^5+q q^4+q^2; q^0 q^6 q^3 q^3 q^5+q q^4+q^2; q^3 q^3 q^6 q^0 q^4+q^2 q^5+q; q^3 q^3 q^0 q^6 q^4+q^2 q^5+q; q^5+q q^5+q q^4+q^2 q^4+q^2 q^6+q^4+q^2+1 q^5+2*q^3+q; q^4+q^2 q^4+q^2 q^5+q q^5+q q^5+2*q^3+q q^6+q^4+q^2+1]
6×6 Matrix{Pol{Int64}}:
 q⁶     1      q³     q³     q⁵+q        q⁴+q²
 1      q⁶     q³     q³     q⁵+q        q⁴+q²
 q³     q³     q⁶     1      q⁴+q²       q⁵+q
 q³     q³     1      q⁶     q⁴+q²       q⁵+q
 q⁵+q   q⁵+q   q⁴+q²  q⁴+q²  q⁶+q⁴+q²+1  q⁵+2q³+q
 q⁴+q²  q⁴+q²  q⁵+q   q⁵+q   q⁵+2q³+q    q⁶+q⁴+q²+1

julia&gt; bb=[[2],[4],[6],[3,5],[1]];

julia&gt; (P,L)=bigcell_decomposition(M,bb);

julia&gt; P
6×6 Matrix{Pol{Int64}}:
 1    0  0    0    0        0
 q⁻⁶  1  q⁻³  q⁻³  q⁻¹+q⁻⁵  q⁻²+q⁻⁴
 0    0  1    0    0        0
 q⁻³  0  0    1    q⁻²      q⁻¹
 q⁻¹  0  0    0    1        0
 q⁻²  0  q⁻¹  0    q⁻¹      1

julia&gt; L
6×6 Matrix{Pol{Int64}}:
 q⁶-q⁴-1+q⁻²  0   0            0     0            0
 0            q⁶  0            0     0            0
 0            0   q⁶-q⁴-1+q⁻²  0     0            0
 0            0   0            q⁶-1  0            0
 0            0   0            0     q⁶-q⁴-1+q⁻²  0
 0            0   0            0     0            q⁶-1

julia&gt; M==transpose(P)*L*P
true
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L243-L302">source</a><br></p>
<p dir="auto"><a id="user-content-GenLinearAlgebra.traces_words_mats" href="#GenLinearAlgebra.traces_words_mats">#</a>
<strong><code>GenLinearAlgebra.traces_words_mats</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>traces_words_mats(mats,words)</code></p>
<p dir="auto">given  a list <code>mats</code>  of matrices and  a list <code>words</code>  of words returns the list  of traces of the corresponding products of the matrices. Each subword is evaluated only once.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; R=[[-1 -1 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1], [1 0 0 0; -1 -1 -1 0; 0 0 1 0; 0 0 0 1], [1 0 0 0; 0 1 0 0; 0 -2 -1 -1; 0 0 0 1], [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 -1 -1]]; # 17th representation of F4

julia&gt;words=[[], [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4], [2,3,2,3], [2,1], [1,2,3,4,2,3,2,3,4,3], [1,2,3,4,1,2,3,4,1,2,3,4], [4,3], [1,2,1,3,2,3,1,2,3,4], [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4], [1,2,3,4,1,2,3,4], [1,2,3,4], [1], [2,3,2,3,4,3,2,3,4], [1,4,3], [4,3,2], [2,3,2,1,3], [3], [1,2,1,3,2,1,3,2,3], [2,1,4], [3,2,1], [2,4,3,2,3], [1,3], [3,2], [1,2,3,4,1,2,3,4,1,2,3,4,2,3], [1,2,3,4,2,3]];

julia&gt; [traces_words_mats(R,words)] # 17th character of F4
1-element Vector{Vector{Int64}}:
 [4, 0, 0, 1, -1, 0, 1, -1, -2, 2  …  0, 2, -2, -1, 1, 0, 0, 2, -2, 0]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; R=[[-1 -1 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1], [1 0 0 0; -1 -1 -1 0; 0 0 1 0; 0 0 0 1], [1 0 0 0; 0 1 0 0; 0 -2 -1 -1; 0 0 0 1], [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 -1 -1]]; # 17th representation of F4

julia&gt;words=[[], [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4], [2,3,2,3], [2,1], [1,2,3,4,2,3,2,3,4,3], [1,2,3,4,1,2,3,4,1,2,3,4], [4,3], [1,2,1,3,2,3,1,2,3,4], [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4], [1,2,3,4,1,2,3,4], [1,2,3,4], [1], [2,3,2,3,4,3,2,3,4], [1,4,3], [4,3,2], [2,3,2,1,3], [3], [1,2,1,3,2,1,3,2,3], [2,1,4], [3,2,1], [2,4,3,2,3], [1,3], [3,2], [1,2,3,4,1,2,3,4,1,2,3,4,2,3], [1,2,3,4,2,3]];

julia&gt; [traces_words_mats(R,words)] # 17th character of F4
1-element Vector{Vector{Int64}}:
 [4, 0, 0, 1, -1, 0, 1, -1, -2, 2  …  0, 2, -2, -1, 1, 0, 0, 2, -2, 0]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/GenLinearAlgebra.jl/blob/e64cc5b173023de766717d80547ab74ebcb21cef/src/GenLinearAlgebra.jl#L589-L605">source</a><br></p>
</article></div>