<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-zerosjl" class="anchor" aria-hidden="true" href="#zerosjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Zeros.jl</h1>
<p><a href="https://travis-ci.org/perrutquist/Zeros.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ba4ab6980ce1e40dd2bfd2d76e7356042c10a068dcdd0bda5ea8f32758b2775b/68747470733a2f2f7472617669732d63692e6f72672f70657272757471756973742f5a65726f732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/perrutquist/Zeros.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="http://codecov.io/github/perrutquist/Zeros.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/5f5ee505598b030f45619deb6976f81f956bacd437d18ce5a175ebe77e6426f5/687474703a2f2f636f6465636f762e696f2f6769746875622f70657272757471756973742f5a65726f732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/perrutquist/Zeros.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>This module provides singular datatypes named Zero and One. All instances of each datatype are identical, and represent the values zero and one, respectively. This is a light-weight alternative to <a href="https://github.com/perrutquist/StaticNumbers.jl">StaticNumbers.jl</a> when only these two values are needed.</p>
<p><code>Zero</code> and <code>One</code> are subtypes of <code>Integer</code>. The most common operations, such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;</code>, <code>&gt;</code>, etc. are defined. Operations like <code>*</code> propagate the <code>Zero</code> or <code>One</code> type to their return values in a way that is correct for numbers, but not for IEEE 754 <code>Inf</code> and <code>NaN</code>. For example, <code>Zero()*x</code> reduces to <code>Zero()</code> at compile-time which has the effect that <code>Zero()*Inf</code> becomes <code>Zero()</code> rather than <code>NaN</code>. A value with this behaviour is sometimes referred to as a "strong zero".</p>
<p>Since the value of a <code>Zero</code> or <code>One</code> is known at compile-time, the complier might be able to make optimisations that might not be possible otherwise.</p>
<p>Trying to convert a nonzero value to <code>Zero</code> will throw an <code>InexactError</code>.</p>
<p>Attempting to divide by <code>Zero()</code> will throw a <code>DivideError</code> rather than returning <code>Inf</code> or <code>NaN</code>.
(A compile-time zero in the denominator is usually a sign that a piece of code needs to be re-written to work optimally.)</p>
<p>The <code>testzero</code> function can be used to change the type when a variable is equal to zero. For example <code>foo(testzero(a), b)</code> will call <code>foo(a,b)</code> if <code>a</code> is nonzero. But if <code>a</code> is zero, then it will call <code>foo(Zero(),b)</code> instead. The function <code>foo</code> will then be complied specifically for input of the type <code>Zero</code> and this might result in speed-ups that outweigh the cost of branching.</p>
<p>The command</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="Zeros.@pirate Base
"><pre><code>Zeros.@pirate Base
</code></pre></div>
<p>can be used to enable a few more method definitions, such as <code>+()</code> (the sum of zero terms)
and <code>*()</code> (the product of zero factors).</p>
</article></div>