<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-zerosjl" class="anchor" aria-hidden="true" href="#zerosjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Zeros.jl</h1>
<p dir="auto"><a href="https://travis-ci.com/perrutquist/Zeros.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/135a5de19a56060a8cb338f87e84c4a855491f3aefef76ee812b1c55f557b983/68747470733a2f2f7472617669732d63692e636f6d2f70657272757471756973742f5a65726f732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/perrutquist/Zeros.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/perrutquist/Zeros.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/5f5ee505598b030f45619deb6976f81f956bacd437d18ce5a175ebe77e6426f5/687474703a2f2f636f6465636f762e696f2f6769746875622f70657272757471756973742f5a65726f732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/perrutquist/Zeros.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">This module provides singular datatypes named Zero and One. All instances of each datatype are identical, and represent the values zero and one, respectively. This is a light-weight alternative to <a href="https://github.com/perrutquist/StaticNumbers.jl">StaticNumbers.jl</a> when only these two values are needed.</p>
<p dir="auto"><code>Zero</code> and <code>One</code> are subtypes of <code>Integer</code>. The most common operations, such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;</code>, <code>&gt;</code>, etc. are defined. Operations like <code>*</code> propagate the <code>Zero</code> or <code>One</code> type to their return values in a way that is correct for numbers, but not for IEEE 754 <code>Inf</code> and <code>NaN</code>. For example, <code>Zero()*x</code> reduces to <code>Zero()</code> at compile-time which has the effect that <code>Zero()*Inf</code> becomes <code>Zero()</code> rather than <code>NaN</code>. A value with this behaviour is sometimes referred to as a "strong zero".</p>
<p dir="auto">Since the value of a <code>Zero</code> or <code>One</code> is known at compile-time, the complier might be able to make optimisations that might not be possible otherwise.</p>
<p dir="auto">With Julia v1.3 and later, the Unicode symbols <code>ùüé</code> and <code>ùüè</code> can be used as aliases for <code>Zero()</code> and <code>One()</code>. These can be entered from the keyboard as <code>\bfzero</code> or <code>\bfone</code> followed by a tab. (User beware: Depending on the font used, it might be hard to tell the difference between these symbols and the numbers <code>0</code> and <code>1</code>.)</p>
<p dir="auto">Trying to convert a nonzero value to <code>Zero</code> will throw an <code>InexactError</code>.</p>
<p dir="auto">Attempting to divide by <code>Zero()</code> will throw a <code>DivideError</code> rather than returning <code>Inf</code> or <code>NaN</code>.
(A compile-time zero in the denominator is usually a sign that a piece of code needs to be re-written to work optimally.)</p>
<p dir="auto">The <code>testzero</code> function can be used to change the type when a variable is equal to zero. For example <code>foo(testzero(a), b)</code> will call <code>foo(a,b)</code> if <code>a</code> is nonzero. But if <code>a</code> is zero, then it will call <code>foo(Zero(),b)</code> instead. The function <code>foo</code> will then be complied specifically for input of the type <code>Zero</code> and this might result in speed-ups that outweigh the cost of branching.</p>
<p dir="auto">The command</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Zeros.@pirate Base"><pre class="notranslate"><code>Zeros.@pirate Base
</code></pre></div>
<p dir="auto">can be used to enable a few more (rarely needed) method definitions, such as <code>+()</code> (the sum of zero terms)
and <code>*()</code> (the product of zero factors).</p>
</article></div>