<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a id="user-content-cyclotomicnumbers"></a></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers-1"></a></p>
<h1 dir="auto"><a id="user-content-cyclotomicnumbers" class="anchor" aria-hidden="true" href="#cyclotomicnumbers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>CyclotomicNumbers</h1>
<ul dir="auto">
<li><a href="index.md#CyclotomicNumbers">CyclotomicNumbers</a></li>
</ul>
<p dir="auto"><a id="user-content-cyclotomicnumbers" href="#CyclotomicNumbers">#</a>
<strong><code>CyclotomicNumbers</code></strong> — <em>Module</em>.</p>
<p dir="auto">This  package deals with cyclotomic numbers,  the complex numbers which are linear  combinations  of  roots  of  unity,  usually  with with rational or integer  coefficients; but it is possible to use any coefficients <code>&lt;:Real</code>. Cyclotomic numbers can be converted to <code>Complex</code> numbers.</p>
<p dir="auto">The  cyclotomic  numbers  with  rational  coefficients  form  a  field, the cyclotomic  field. It  is the  maximal extension  of the  rationals with an abelian  Galois group. Its ring of  integers is the cyclotomic numbers with integer coefficients (called cyclotomic integers).</p>
<p dir="auto">Cyclotomic  numbers are very  important for finite  groups, since character values of finite groups are cyclotomic integers.</p>
<p dir="auto">This package depends only on the packages <code>ModuleElt</code> and <code>Primes</code>. It is a port  of the  GAP implementation  of cyclotomics,  which uses a normal form given  by writing them in the Zumbroich basis. This form allows to find the smallest  Cyclotomic field  which contains  a given  number, and  decide in particular  if a cyclotomic is zero. Let ζₙ=exp(2iπ/n). The Zumbroich basis is a particular subset of size φ(n) of 1,ζₙ,ζₙ²,…,ζₙⁿ⁻¹ which forms a basis of ℚ (ζₙ). The reference is</p>
<p dir="auto">T. Breuer, Integral bases for subfields of cyclotomic fields AAECC 8 (1997)</p>
<p dir="auto">I  started  this  file  by  porting  Christian  Stump's Sage code, which is simpler  to understand than GAP's C  code.</p>
<p dir="auto">As GAP does, I lower automatically numbers after each computation, that is, reduce  them to the smallest cyclotomic  field where they belong. Currently the  code is somewhat  slower (depending on  the operation it  has the same speed or is slower up to 50%) than the C code in GAP but there are probably opportunities to optimize that I missed.</p>
<p dir="auto">What GAP does which I do not do is convert automatically a Cyclotomic which is  rational  to  a  <code>Rational</code>,  a  <code>Rational</code>  which  is  integral  to an <code>Integer</code>,  a  <code>BigInt</code>  which  is  small  to  an  <code>Int</code>,  etc…  This  is a tremendously  important optimization but because of type stability in Julia it  needs  a  new  type  of  number  to  be  added to Julia, which I am not competent enough to try.</p>
<p dir="auto">This package is similar (and mostly compatible) with Marek Kaluba's package <code>Cyclotomics</code>,  whose existence I discovered after writing this package. We discussed merging them but concluded it would be a lot of work for benefits which are not clear currently. Some differences are:</p>
<ul dir="auto">
<li>I define two types in this  package: <code>Root1</code> represents a root of unity, and  <code>Cyc</code> a cyclotomic number. The advantage of having a separate type for  roots of  unity is  that computations  are very  fast for them, of which  I take advantage  in the package  <code>CycPol</code> for polynomials whose zeros are roots of unity.</li>
<li>In Kaluba's package  numbers are not  systematically lowered but only on demand  (like  for  printing).  this  speeds  up some computations by a factor  approaching 2, but it also makes some computations I have to do infeasible,  like the following one, which if not lowering involves too large fields; the answer is <code>-36ζ₃²</code>:</li>
</ul>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; prod(x-&gt;1-x,[E(3),E(3,2),E(6),E(6,5),E(8),E(8),E(8,5),E(8,7),E(9,2),
E(9,5),E(9,8),E(12,7),E(12,11),E(16),E(16,3),E(16,5),E(16,9),E(16,11),E(16,13),
E(18,5),E(18,5),E(18,11),E(18,11),E(18,17),E(18,17),E(21,2),E(21,5),E(21,8),
E(21,11),E(21,17),E(21,20),
E(27,2),E(27,5),E(27,8),E(27,11),E(27,14),E(27,17),E(27,20),E(27,23),E(27,26),
E(32,7),E(32,15),E(32,23),E(32,31),E(39),E(39,4),E(39,7),E(39,10),E(39,16),
E(39,19),E(39,22),E(39,25),E(39,28),E(39,31),E(39,34),E(39,37),E(42),E(42,13),
E(42,19),E(42,25),E(42,31),E(42,37),E(48,11),E(48,19),E(48,35),E(48,43),E(60,7),
E(60,19),E(60,31),E(60,43),E(78,5),E(78,11),E(78,17),E(78,23),E(78,29),E(78,35),
E(78,41),E(78,47),E(78,53),E(78,59),E(78,71),E(78,77),E(80,7),E(80,23),E(80,31),
E(80,39),E(80,47),E(80,63),E(80,71),E(80,79),E(88,3),E(88,19),E(88,27),E(88,35),
E(88,43),E(88,51),E(88,59),E(88,67),E(88,75),E(88,83),E(90),E(90,7),E(90,13),
E(90,19),E(90,31),E(90,37),E(90,43),E(90,49),E(90,61),E(90,67),E(90,73),
E(90,79),E(96,5),E(96,13),E(96,29),E(96,37),E(96,53),E(96,61),E(96,77),E(96,85),
E(104),E(104,9),E(104,17),E(104,25),E(104,33),E(104,41),E(104,49),E(104,57),
E(104,73),E(104,81),E(104,89),E(104,97),E(144),E(144,17),E(144,25),E(144,41),
E(144,49),E(144,65),E(144,73),E(144,89),E(144,97),E(144,113),E(144,121),
E(144,137),E(152,5),E(152,13),E(152,21),E(152,29),E(152,37),E(152,45),
E(152,53),E(152,61),E(152,69),E(152,77),E(152,85),E(152,93),E(152,101),
E(152,109),E(152,117),E(152,125),E(152,141),E(152,149),E(204,11),E(204,23),
E(204,35),E(204,47),E(204,59),E(204,71),E(204,83),E(204,95),E(204,107),
E(204,131),E(204,143),E(204,155),E(204,167),E(204,179),E(204,191),E(204,203)])"><pre lang="julia-rep1" class="notranslate"><code>julia&gt; prod(x-&gt;1-x,[E(3),E(3,2),E(6),E(6,5),E(8),E(8),E(8,5),E(8,7),E(9,2),
E(9,5),E(9,8),E(12,7),E(12,11),E(16),E(16,3),E(16,5),E(16,9),E(16,11),E(16,13),
E(18,5),E(18,5),E(18,11),E(18,11),E(18,17),E(18,17),E(21,2),E(21,5),E(21,8),
E(21,11),E(21,17),E(21,20),
E(27,2),E(27,5),E(27,8),E(27,11),E(27,14),E(27,17),E(27,20),E(27,23),E(27,26),
E(32,7),E(32,15),E(32,23),E(32,31),E(39),E(39,4),E(39,7),E(39,10),E(39,16),
E(39,19),E(39,22),E(39,25),E(39,28),E(39,31),E(39,34),E(39,37),E(42),E(42,13),
E(42,19),E(42,25),E(42,31),E(42,37),E(48,11),E(48,19),E(48,35),E(48,43),E(60,7),
E(60,19),E(60,31),E(60,43),E(78,5),E(78,11),E(78,17),E(78,23),E(78,29),E(78,35),
E(78,41),E(78,47),E(78,53),E(78,59),E(78,71),E(78,77),E(80,7),E(80,23),E(80,31),
E(80,39),E(80,47),E(80,63),E(80,71),E(80,79),E(88,3),E(88,19),E(88,27),E(88,35),
E(88,43),E(88,51),E(88,59),E(88,67),E(88,75),E(88,83),E(90),E(90,7),E(90,13),
E(90,19),E(90,31),E(90,37),E(90,43),E(90,49),E(90,61),E(90,67),E(90,73),
E(90,79),E(96,5),E(96,13),E(96,29),E(96,37),E(96,53),E(96,61),E(96,77),E(96,85),
E(104),E(104,9),E(104,17),E(104,25),E(104,33),E(104,41),E(104,49),E(104,57),
E(104,73),E(104,81),E(104,89),E(104,97),E(144),E(144,17),E(144,25),E(144,41),
E(144,49),E(144,65),E(144,73),E(144,89),E(144,97),E(144,113),E(144,121),
E(144,137),E(152,5),E(152,13),E(152,21),E(152,29),E(152,37),E(152,45),
E(152,53),E(152,61),E(152,69),E(152,77),E(152,85),E(152,93),E(152,101),
E(152,109),E(152,117),E(152,125),E(152,141),E(152,149),E(204,11),E(204,23),
E(204,35),E(204,47),E(204,59),E(204,71),E(204,83),E(204,95),E(204,107),
E(204,131),E(204,143),E(204,155),E(204,167),E(204,179),E(204,191),E(204,203)])
</code></pre></div>
<p dir="auto">If you <code>develop</code> my package it is easy to use the strategy of lowering only on  demand or to use alternate implementations like dense vectors or sparse vectors (like <code>Cyclotomics</code>) –- I prepared boolean flags to choose various implementations  in the  code. I  have currently  chosen the implementation with <code>ModuleElts</code> and systematic lowering as giving the best results.</p>
<p dir="auto">The main way to build a Cyclotomic number is to use the function <code>E(n,k=1)</code> which   constructs  the  <code>Root1</code>  equal  to   <code>ζₙᵏ</code>,  and  to  make  linear combinations of such numbers.</p>
<p dir="auto"><strong>Examples</strong></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; E(3,2) # a root of unity
Root1: ζ₃²

julia&gt; E(3)+E(4) # nice display at the repl
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹"><pre lang="julia-repl" class="notranslate"><code>julia&gt; E(3,2) # a root of unity
Root1: ζ₃²

julia&gt; E(3)+E(4) # nice display at the repl
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹
</code></pre></div>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; print(E(3)+E(4)) # otherwise give output which can be parsed back
E(12,4)-E(12,7)-E(12,11)"><pre lang="julia-rep1" class="notranslate"><code>julia&gt; print(E(3)+E(4)) # otherwise give output which can be parsed back
E(12,4)-E(12,7)-E(12,11)
</code></pre></div>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; E(12,11)-E(12,7) # square roots of integers are recognized on output
Cyc{Int64}: √3

# but you can prevent that recognition
julia&gt; repr(E(12,11)-E(12,7),context=(:limit=&gt;true,:quadratic=&gt;false))
&quot;-ζ₁₂⁷+ζ₁₂¹¹&quot;

julia&gt; a=E(3)+E(3,2)
Cyc{Int64}: -1

julia&gt; conductor(a) # a has been lowered to ℚ (ζ₁)=ℚ 
1

julia&gt; typeof(Int(a))
Int64"><pre lang="julia-repl" class="notranslate"><code>julia&gt; E(12,11)-E(12,7) # square roots of integers are recognized on output
Cyc{Int64}: √3

# but you can prevent that recognition
julia&gt; repr(E(12,11)-E(12,7),context=(:limit=&gt;true,:quadratic=&gt;false))
"-ζ₁₂⁷+ζ₁₂¹¹"

julia&gt; a=E(3)+E(3,2)
Cyc{Int64}: -1

julia&gt; conductor(a) # a has been lowered to ℚ (ζ₁)=ℚ 
1

julia&gt; typeof(Int(a))
Int64
</code></pre></div>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; Int(E(4))
ERROR: InexactError: convert(Int64, E(4))"><pre lang="julia-rep1" class="notranslate"><code>julia&gt; Int(E(4))
ERROR: InexactError: convert(Int64, E(4))
</code></pre></div>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; inv(1+E(4)) # like for Integers inverse involves floats
Cyc{Float64}: 0.5-0.5ζ₄

julia&gt; 1//(1+E(4))  # but not written this way
Cyc{Rational{Int64}}: (1-ζ₄)/2

julia&gt; Cyc(1//2+im) # we can convert Gaussian rationals to cyclotomics
Cyc{Rational{Int64}}: (1+2ζ₄)/2

julia&gt; conj(1+E(4)) # complex conjugate
Cyc{Int64}: 1-ζ₄

julia&gt; real(E(3))  # real part
Cyc{Rational{Int64}}: -1//2

julia&gt; Rational{Int}(real(E(3)))
-1//2

julia&gt; imag(E(3))  # imaginary part
Cyc{Rational{Int64}}: √3/2

julia&gt; c=Cyc(E(9))   # the normal form in the Zumbroich basis has two terms
Cyc{Int64}: -ζ₉⁴-ζ₉⁷

julia&gt; Root1(c) #  but you can convert back to Root1 if possible
Root1: ζ₉

julia&gt; Root1(1+E(4)) # the constructor Root1 returns nothing for a non-root"><pre lang="julia-repl" class="notranslate"><code>julia&gt; inv(1+E(4)) # like for Integers inverse involves floats
Cyc{Float64}: 0.5-0.5ζ₄

julia&gt; 1//(1+E(4))  # but not written this way
Cyc{Rational{Int64}}: (1-ζ₄)/2

julia&gt; Cyc(1//2+im) # we can convert Gaussian rationals to cyclotomics
Cyc{Rational{Int64}}: (1+2ζ₄)/2

julia&gt; conj(1+E(4)) # complex conjugate
Cyc{Int64}: 1-ζ₄

julia&gt; real(E(3))  # real part
Cyc{Rational{Int64}}: -1//2

julia&gt; Rational{Int}(real(E(3)))
-1//2

julia&gt; imag(E(3))  # imaginary part
Cyc{Rational{Int64}}: √3/2

julia&gt; c=Cyc(E(9))   # the normal form in the Zumbroich basis has two terms
Cyc{Int64}: -ζ₉⁴-ζ₉⁷

julia&gt; Root1(c) #  but you can convert back to Root1 if possible
Root1: ζ₉

julia&gt; Root1(1+E(4)) # the constructor Root1 returns nothing for a non-root
</code></pre></div>
<p dir="auto">The  group of  roots of  unity is  isomorphic to  ℚ /ℤ  , thus  <code>Root1</code> are represented internally by a rational number in <code>[0,1[</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; Root1(;r=1//4) # this constructor ensures the fraction is in [0,1[
Root1: ζ₄

julia&gt; c=E(4)*E(3) # fast computation if staying inside roots of unity
Root1: ζ₁₂⁷"><pre lang="julia-repl" class="notranslate"><code>julia&gt; Root1(;r=1//4) # this constructor ensures the fraction is in [0,1[
Root1: ζ₄

julia&gt; c=E(4)*E(3) # fast computation if staying inside roots of unity
Root1: ζ₁₂⁷
</code></pre></div>
<p dir="auto"><code>Root1</code> have the same operations as <code>Cyc</code>, but are first converted to <code>Cyc</code> for  any  operation  other  than  <code>one,  isone,  *, ^, inv, conj, /, //</code>. A <code>Root1</code>  can be  raised to  a <code>Rational</code>  power, which  extracts a  root if needed.  A <code>Root1</code> can be  taken apart using <code>order</code>  and <code>exponent</code> –- if <code>a</code>  and <code>b</code> are prime to each other,  <code>a</code> is the order of <code>E(a,b)</code> and <code>b</code> (taken  mod <code>a</code>) is the exponent. Note  that the order is not the conductor since <code>E(6)==-E(3)</code> has order 6 and conductor 3.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; c=Complex{Float64}(E(3))  # convert to Complex{float} is sometimes useful
-0.4999999999999999 + 0.8660254037844387im"><pre lang="julia-repl" class="notranslate"><code>julia&gt; c=Complex{Float64}(E(3))  # convert to Complex{float} is sometimes useful
-0.4999999999999999 + 0.8660254037844387im
</code></pre></div>
<p dir="auto">In  presence  of  a  <code>Cyc</code>  a  number  <code>&lt;:Real</code>  or  <code>&lt;:Complex{&lt;:Real}</code> is converted to a <code>Cyc</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; 0.0+E(3)
Cyc{Float64}: 1.0ζ₃

julia&gt; E(3)+1//2
Cyc{Rational{Int64}}: √-3/2

julia&gt; E(3)+im
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹"><pre lang="julia-repl" class="notranslate"><code>julia&gt; 0.0+E(3)
Cyc{Float64}: 1.0ζ₃

julia&gt; E(3)+1//2
Cyc{Rational{Int64}}: √-3/2

julia&gt; E(3)+im
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹
</code></pre></div>
<p dir="auto">The  function  <code>complex</code>  converts  a  <code>Cyc{T}</code>  to  a  <code>Complex{T}</code> if the conductor is 1 or 4, to a <code>Complex{float(T)}</code> otherwise.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; complex(E(4))
0 + 1im

julia&gt; complex(E(3))
-0.4999999999999999 + 0.8660254037844387im"><pre lang="julia-repl" class="notranslate"><code>julia&gt; complex(E(4))
0 + 1im

julia&gt; complex(E(3))
-0.4999999999999999 + 0.8660254037844387im
</code></pre></div>
<p dir="auto"><code>Cyc</code>s have methods <code>copy, hash, ==, cmp, isless</code> (total order) so they can be  keys in hashes, elements of sets,  and can be sorted. Cyclotomics which are  integers  or  rationals  compare  correctly  to <code>Real</code>s (this does not extend to irrational real <code>Cyc</code>s):</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; -1&lt;Cyc(0)&lt;1
true"><pre lang="julia-repl" class="notranslate"><code>julia&gt; -1&lt;Cyc(0)&lt;1
true
</code></pre></div>
<p dir="auto"><code>Cyc</code>s have the operations <code>+, -, *, /, //, inv, ^, conj, abs2, abs, image, real, reim, isinteger, isreal, one, isone, zero, iszero, complex, adjoint</code>. Cyclotomics   with  rational  or  integer  coefficients  have  the  methods <code>numerator</code>  and  <code>denominator</code>:  a  <code>Cyc</code>  <code>x</code>  is a Cyclotomic integer if <code>denominator(x)==1</code>   and  then  <code>numerator(x)</code>   gives  the  corresponding <code>Cyc{&lt;:Integer}</code>.</p>
<p dir="auto">You  can pick apart a cyclotomic in various ways. The fastest is to use the iterator  <code>pairs</code> which, for a cyclotomic  <code>a</code> of conductor <code>e</code> iterates on the  pairs <code>(i,c)</code> such that  <code>a</code> has a non-zero  coefficient <code>c</code> on <code>ζₑⁱ</code>. You  can also get  the coefficient of  <code>ζₑⁱ</code> as <code>a[i]</code>  but it is slower to iterate  on coefficients  this way.  Finally you  can get (efficiently) the vector of all coefficients by <code>coefficients</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; a=E(3)+E(4)
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹

julia&gt; collect(pairs(a))
3-element Vector{Pair{Int64, Int64}}:
  4 =&gt; 1
  7 =&gt; -1
 11 =&gt; -1

julia&gt; a[6],a[7]
(0, -1)

julia&gt; coefficients(a)
12-element Vector{Int64}:
  0
  0
  0
  0
  1
  0
  0
 -1
  0
  0
  0
 -1

julia&gt; valtype(a) # the type of the coefficients of a
Int64"><pre lang="julia-repl" class="notranslate"><code>julia&gt; a=E(3)+E(4)
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹

julia&gt; collect(pairs(a))
3-element Vector{Pair{Int64, Int64}}:
  4 =&gt; 1
  7 =&gt; -1
 11 =&gt; -1

julia&gt; a[6],a[7]
(0, -1)

julia&gt; coefficients(a)
12-element Vector{Int64}:
  0
  0
  0
  0
  1
  0
  0
 -1
  0
  0
  0
 -1

julia&gt; valtype(a) # the type of the coefficients of a
Int64
</code></pre></div>
<p dir="auto">For more information see the docstring for the methods Quadratic,  galois, root, conjugates.</p>
<p dir="auto">Finally, a benchmark:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; function testmat(p) 
         ss=[[i,j] for i in 0:p-1 for j in i+1:p-1]
         [(E(p,i'*reverse(j))-E(p,i'*j))//p for i in ss,j in ss]
       end
testmat (generic function with 1 method)

julia&gt; @btime CyclotomicNumbers.testmat(12)^2;  # on Julia 1.7.2
  287.781 ms (3774785 allocations: 279.66 MiB)"><pre lang="benchmark" class="notranslate"><code>julia&gt; function testmat(p) 
         ss=[[i,j] for i in 0:p-1 for j in i+1:p-1]
         [(E(p,i'*reverse(j))-E(p,i'*j))//p for i in ss,j in ss]
       end
testmat (generic function with 1 method)

julia&gt; @btime CyclotomicNumbers.testmat(12)^2;  # on Julia 1.7.2
  287.781 ms (3774785 allocations: 279.66 MiB)
</code></pre></div>
<p dir="auto">The equivalent in GAP:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="testmat:=function(p)local ss;ss:=Combinations([0..p-1],2);
  return List(ss,i-&gt;List(ss,j-&gt;(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));
end; "><pre class="notranslate"><code>testmat:=function(p)local ss;ss:=Combinations([0..p-1],2);
  return List(ss,i-&gt;List(ss,j-&gt;(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));
end; 
</code></pre></div>
<p dir="auto">testmat(12)^2 takes 0.31s in GAP3, 0.22s in GAP4</p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L1-L280">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.e" href="#CyclotomicNumbers.E">#</a>
<strong><code>CyclotomicNumbers.E</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>E(n,p=1)</code> returns the <code>Root1</code> equal to <code>ζₙᵖ</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L354">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.root1" href="#CyclotomicNumbers.Root1">#</a>
<strong><code>CyclotomicNumbers.Root1</code></strong> — <em>Type</em>.</p>
<p dir="auto"><code>Root1(c)</code></p>
<p dir="auto"><code>c</code>  should be a cyclotomic number (a  <code>Cyc</code>), or a <code>Real</code>. <code>Root1</code> returns <code>E(n,e)</code> if <code>c==E(n,e)</code>, and <code>nothing</code> if <code>c</code> is not a root of unity.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; r=Root1(-E(9,2)-E(9,5))
Root1: ζ₉⁸

julia&gt; order(r)
9

julia&gt; exponent(r)
8

julia&gt; Cyc(r) # the Zumbroich normal form is a sum of 2 roots of unity
Cyc{Int64}: -ζ₉²-ζ₉⁵

julia&gt; Root1(-E(9,4)-E(9,5)) # nothing"><pre lang="julia-repl" class="notranslate"><code>julia&gt; r=Root1(-E(9,2)-E(9,5))
Root1: ζ₉⁸

julia&gt; order(r)
9

julia&gt; exponent(r)
8

julia&gt; Cyc(r) # the Zumbroich normal form is a sum of 2 roots of unity
Cyc{Int64}: -ζ₉²-ζ₉⁵

julia&gt; Root1(-E(9,4)-E(9,5)) # nothing
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L1147-L1168">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.conductor" href="#CyclotomicNumbers.conductor">#</a>
<strong><code>CyclotomicNumbers.conductor</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>conductor(c::Cyc)</code></p>
<p dir="auto">returns the smallest positive integer  n such that <code>c∈ ℚ (ζₙ)</code></p>
<p dir="auto"><code>conductor(a::AbstractArray)</code></p>
<p dir="auto">smallest positive integer  n such that all elements of <code>a</code> are in <code>ℚ (ζₙ)</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; conductor(E(6))
3

julia&gt; conductor([E(3),1//2,E(4)])
12"><pre lang="julia-repl" class="notranslate"><code>julia&gt; conductor(E(6))
3

julia&gt; conductor([E(3),1//2,E(4)])
12
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L472-L488">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.coefficients" href="#CyclotomicNumbers.coefficients">#</a>
<strong><code>CyclotomicNumbers.coefficients</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>coefficients(c::Cyc)</code></p>
<p dir="auto">for  a cyclotomic <code>c</code> of conductor <code>n</code>,  returns a vector <code>v</code> of length <code>n</code> such that <code>c==∑ᵢ vᵢ₊₁ ζⁱ</code> for <code>i∈ 0:n-1</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; coefficients(Cyc(E(9)))
9-element Vector{Int64}:
  0
  0
  0
  0
 -1
  0
  0
 -1
  0"><pre lang="julia-repl" class="notranslate"><code>julia&gt; coefficients(Cyc(E(9)))
9-element Vector{Int64}:
  0
  0
  0
  0
 -1
  0
  0
 -1
  0
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L509-L528">source</a><br></p>
<p dir="auto"><a id="user-content-base.denominator" href="#Base.denominator">#</a>
<strong><code>Base.denominator</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>denominator(c::Cyc{Rational})</code></p>
<p dir="auto">returns   the   smallest   integer   <code>d</code>   such  that  <code>d*c</code>  has  integral <code>coefficients</code> (thus is an algebraic integer).</p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L539-L544">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.galois" href="#CyclotomicNumbers.galois">#</a>
<strong><code>CyclotomicNumbers.galois</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>galois(c::Cyc,n::Int)</code>  applies  to  <code>c</code>  the  galois  automorphism  of <code>ℚ (ζ_conductor(c))</code>  raising  all  roots  of  unity  to the <code>n</code>-th power. <code>n</code> should be prime to <code>conductor(c)</code>.</p>
<p dir="auto"><strong>Examples</strong></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; galois(1+E(4),-1) # galois(c,-1) is the same as conj(c)
Cyc{Int64}: 1-ζ₄

julia&gt; galois(root(5),2)==-root(5)
true"><pre lang="julia-repl" class="notranslate"><code>julia&gt; galois(1+E(4),-1) # galois(c,-1) is the same as conj(c)
Cyc{Int64}: 1-ζ₄

julia&gt; galois(root(5),2)==-root(5)
true
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L1079-L1091">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.conjugates" href="#CyclotomicNumbers.conjugates">#</a>
<strong><code>CyclotomicNumbers.conjugates</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>conjugates(c)</code></p>
<p dir="auto">returns the list of distinct galois conjugates of <code>c</code> (over the Rationals), starting with <code>c</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; conjugates(1+root(5))
2-element Vector{Cyc{Int64}}:
 1+√5
 1-√5"><pre lang="julia-repl" class="notranslate"><code>julia&gt; conjugates(1+root(5))
2-element Vector{Cyc{Int64}}:
 1+√5
 1-√5
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L1108-L1120">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.quadratic" href="#CyclotomicNumbers.Quadratic">#</a>
<strong><code>CyclotomicNumbers.Quadratic</code></strong> — <em>Type</em>.</p>
<p dir="auto"><code>Quadratic(c::Cyc)</code></p>
<p dir="auto">determines  if  <code>c</code>  lives  in  a  quadratic  extension  of  <code>ℚ</code>. The call <code>q=Quadratic(c)</code>  returns a  struct <code>Quadratic</code>  with fields  <code>q.a</code>, <code>q.b</code>, <code>q.root</code>,  <code>q.den</code> representing <code>c</code> as <code>(q.a + q.b root(q.root))//q.den</code> if such a representation is possible or returns <code>q===nothing</code> otherwise.</p>
<p dir="auto"><strong>Examples</strong></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; Quadratic(E(3,2)-2E(3))
(1-3√-3)/2

julia&gt; Quadratic(1+E(5))
"><pre lang="julia-repl" class="notranslate"><code>julia&gt; Quadratic(E(3,2)-2E(3))
(1-3√-3)/2

julia&gt; Quadratic(1+E(5))

</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L1201-L1217">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.root" href="#CyclotomicNumbers.root">#</a>
<strong><code>CyclotomicNumbers.root</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>root(x,n=2)</code></p>
<p dir="auto">computes  an <code>n</code>-th root of <code>x</code>  when we know how to  do it. We know how to compute  <code>n</code>-th roots  of roots  of unity,  and <code>n</code>-th  or <code>2n</code>-th roots of perfect <code>n</code>-th powers of integers or rationals.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; root(-1)
Cyc{Int64}: ζ₄

julia&gt; root(E(4))
Root1: ζ₈

julia&gt; root(27//8,6)
Cyc{Rational{Int64}}: √6/2"><pre lang="julia-repl" class="notranslate"><code>julia&gt; root(-1)
Cyc{Int64}: ζ₄

julia&gt; root(E(4))
Root1: ζ₈

julia&gt; root(27//8,6)
Cyc{Rational{Int64}}: √6/2
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L1295-L1312">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.elist" href="#CyclotomicNumbers.Elist">#</a>
<strong><code>CyclotomicNumbers.Elist</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>CyclotomicNumbers.Elist(n,i)</code></p>
<p dir="auto">expresses  <code>ζₙⁱ</code> in  <code>zumbroich_basis(n)</code>: it  is a  sum of some <code>ζₙʲ</code> with coefficients  all 1  or all  -1. The  result is  a <code>Pair</code> <code>sgn=&gt;inds</code> where <code>sgn</code> is <code>true</code> if coefficients are all 1 and <code>false</code> otherwise, and <code>inds</code> is  the  list  of  <code>i</code>  in  <code>0:n-1</code>  such that <code>ζₙⁱ</code> occurs with a non-zero coefficient.</p>
<p dir="auto">Should only be called with <code>i∈ 0:n-1</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L679-L689">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.zumbroich_basis" href="#CyclotomicNumbers.zumbroich_basis">#</a>
<strong><code>CyclotomicNumbers.zumbroich_basis</code></strong> — <em>Function</em>.</p>
<p dir="auto">CyclotomicNumbers.zumbroich_basis(n::Int)</p>
<p dir="auto">returns  the Zumbroich basis of ℚ (ζₙ) as the sorted vector of i in 0:n-1   such that <code>ζₙⁱ</code> is in the basis.</p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L493-L498">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.prime_residues" href="#CyclotomicNumbers.prime_residues">#</a>
<strong><code>CyclotomicNumbers.prime_residues</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>CyclotomicNumbers.prime_residues(n)</code> the numbers less than <code>n</code> and prime to <code>n</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L331">source</a><br></p>
<p dir="auto"><a id="user-content-cyclotomicnumbers.modz" href="#CyclotomicNumbers.modZ">#</a>
<strong><code>CyclotomicNumbers.modZ</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>modZ(x::Rational{&lt;:Integer})</code> returns <code>x mod ℤ</code> as a rational in <code>[0,1[</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L350">source</a><br></p>
<p dir="auto"><a id="user-content-base.numerator-union{tuple{cyc{&lt;:union{rational{t}, t}}}, tuple{t}} where t&lt;:integer">#</a>
<strong><code>Base.numerator</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>numerator(c::Cyc{Rational})</code></p>
<p dir="auto">returns <code>denominator(c)*c</code> as a cyclotomic over the integers.</p>
<p dir="auto"><a href="https://github.com/jmichel7/CyclotomicNumbers.jl/blob/793551e86a1cabf8c3727e141f575275341079fc/src/CyclotomicNumbers.jl#L547-L551">source</a><br></p>
</article></div>