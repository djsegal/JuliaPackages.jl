<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto">Wrapper Library designed to wrap function objects to ensure the correct signature. Very similar to using typedef in C++.</p>
<p dir="auto">To Install:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#To Use
Pkg.add(&quot;FunWrap&quot;)

using FunWrap"><pre><span class="pl-c"><span class="pl-c">#</span>To Use</span>
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>FunWrap<span class="pl-pds">"</span></span>)

<span class="pl-k">using</span> FunWrap</pre></div>
<p dir="auto">Usage:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="     
#Create the wrapper you want
@Fun(MyFuncName{T}, return_arg::T, arg1::Int, arg2::Int)

#Void version and no var names
@VFun(MyFuncName2, Int, Int)

#The function can be called like a struct now
test(func::MyFuncName{Int})
       return func(1, 2)
end

#Wrap the anonymous function
test(MyFuncName{Int}((x1, x2) -&gt; x1 * x2)

#Have it guess the types (careful with this though, better to manually type)
test(MyFuncName((x1, x2) -&gt; Int(x1 * x2))

#string(MyFuncName{Int}) will return &quot;.MyFuncName{Int}(arg1::Int, arg2::int):(return_arg::Int)&quot;
#Docs will also display this aswell"><pre>     
<span class="pl-c"><span class="pl-c">#</span>Create the wrapper you want</span>
<span class="pl-c1">@Fun</span>(MyFuncName{T}, return_arg<span class="pl-k">::</span><span class="pl-c1">T</span>, arg1<span class="pl-k">::</span><span class="pl-c1">Int</span>, arg2<span class="pl-k">::</span><span class="pl-c1">Int</span>)

<span class="pl-c"><span class="pl-c">#</span>Void version and no var names</span>
<span class="pl-c1">@VFun</span>(MyFuncName2, Int, Int)

<span class="pl-c"><span class="pl-c">#</span>The function can be called like a struct now</span>
<span class="pl-c1">test</span>(func<span class="pl-k">::</span><span class="pl-c1">MyFuncName{Int}</span>)
       <span class="pl-k">return</span> <span class="pl-c1">func</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span>Wrap the anonymous function</span>
<span class="pl-c1">test</span>(<span class="pl-c1">MyFuncName</span><span class="pl-c1">{Int}</span>((x1, x2) <span class="pl-k">-&gt;</span> x1 <span class="pl-k">*</span> x2)

<span class="pl-c"><span class="pl-c">#</span>Have it guess the types (careful with this though, better to manually type)</span>
<span class="pl-c1">test</span>(<span class="pl-c1">MyFuncName</span>((x1, x2) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span>(x1 <span class="pl-k">*</span> x2))

<span class="pl-c"><span class="pl-c">#</span>string(MyFuncName{Int}) will return ".MyFuncName{Int}(arg1::Int, arg2::int):(return_arg::Int)"</span>
<span class="pl-c"><span class="pl-c">#</span>Docs will also display this aswell</span></pre></div>
</article></div>