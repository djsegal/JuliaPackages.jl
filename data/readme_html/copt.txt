<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-using-julia-interface-for-copt-cardinal-optimizer" class="anchor" aria-hidden="true" href="#using-julia-interface-for-copt-cardinal-optimizer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using Julia interface for COPT (Cardinal Optimizer)</h1>
<p dir="auto">COPT (Cardinal Optimizer) is a mathematical optimization solver for large-scale optimization problems.
It includes high-performance solvers for LP, MIP, SOCP, convex QP/QCP and SDP.</p>
<h2 dir="auto"><a id="user-content-prerequisite" class="anchor" aria-hidden="true" href="#prerequisite"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Prerequisite</h2>
<p dir="auto">COPT.jl requires Julia version 1.6 or above. Please apply for a free personal COPT license from <a href="https://www.shanshu.ai/copt" rel="nofollow">COPT application page</a>.</p>
<p dir="auto"><strong>Notes</strong><br>
When COPT is upgraded to a newer version, you may see an error message such as <code>ERROR: COPT error 4: Unable to create COPT environment</code>,
which indicates that you will need to reapply and upgrade your COPT license files as well.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Please install JuMP and COPT Julia interface from Julia with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import Pkg
Pkg.add(&quot;JuMP&quot;)
Pkg.add(&quot;COPT&quot;)"><pre><span class="pl-k">import</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>JuMP<span class="pl-pds">"</span></span>)
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>COPT<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">When there is no COPT installed,
installing the COPT Julia interface will automatically download the necessary solver binaries.
Without a license, you can solve small models for non-commercial purpose.
We strongly recommend that you apply for a license by following the link above.</p>
<p dir="auto"><strong>Notes</strong><br>
<strong>MacOS Apple M1/ARM:</strong> on MacOS with Apple M1 chips, Intel based programs can run via <em>Rosetta</em>. When you installed the COPT binaries manually, then please make sure that the <em>COPT build</em> matches the <em>Julia build</em>. We recommend the Intel based COPT and Julia build, as the Apple M1/ARM build of Julia is experimental.</p>
<h2 dir="auto"><a id="user-content-quick-check" class="anchor" aria-hidden="true" href="#quick-check"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick check</h2>
<p dir="auto">When the installation is done, you should be able to build and solve an LP problem with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP
using COPT
model = Model(COPT.Optimizer)
@variable(model, x &gt;= 0)
@variable(model, 0 &lt;= y &lt;= 3)
@objective(model, Min, 12x + 20y)
@constraint(model, c1, 6x + 8y &gt;= 100)
@constraint(model, c2, 7x + 12y &gt;= 120)
print(model)
optimize!(model)
@show termination_status(model)
@show primal_status(model)
@show dual_status(model)
@show objective_value(model)
@show value(x)
@show value(y)
@show shadow_price(c1)
@show shadow_price(c2)"><pre><span class="pl-k">using</span> JuMP
<span class="pl-k">using</span> COPT
model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(COPT<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">@variable</span>(model, x <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>)
<span class="pl-c1">@variable</span>(model, <span class="pl-c1">0</span> <span class="pl-k">&lt;=</span> y <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>)
<span class="pl-c1">@objective</span>(model, Min, <span class="pl-c1">12</span>x <span class="pl-k">+</span> <span class="pl-c1">20</span>y)
<span class="pl-c1">@constraint</span>(model, c1, <span class="pl-c1">6</span>x <span class="pl-k">+</span> <span class="pl-c1">8</span>y <span class="pl-k">&gt;=</span> <span class="pl-c1">100</span>)
<span class="pl-c1">@constraint</span>(model, c2, <span class="pl-c1">7</span>x <span class="pl-k">+</span> <span class="pl-c1">12</span>y <span class="pl-k">&gt;=</span> <span class="pl-c1">120</span>)
<span class="pl-c1">print</span>(model)
<span class="pl-c1">optimize!</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">termination_status</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">primal_status</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">dual_status</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">objective_value</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">value</span>(x)
<span class="pl-c1">@show</span> <span class="pl-c1">value</span>(y)
<span class="pl-c1">@show</span> <span class="pl-c1">shadow_price</span>(c1)
<span class="pl-c1">@show</span> <span class="pl-c1">shadow_price</span>(c2)</pre></div>
<p dir="auto">For solving SDP problems, you need to use <code>COPT.ConeOptimizer</code> in place of
<code>COPT.Optimizer</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP
using COPT
model = Model(COPT.ConeOptimizer)
C = [1.0 -1.0; -1.0 2.0]
@variable(model, X[1:2, 1:2], PSD)
@variable(model, z[1:2] &gt;= 0)
@objective(model, Min, C ⋅ X)
@constraint(model, c1, X[1, 1] - z[1] == 1)
@constraint(model, c2, X[2, 2] - z[2] == 1)
optimize!(model)
@show termination_status(model)
@show primal_status(model)
@show dual_status(model)
@show objective_value(model)
@show value.(X)
@show value.(z)
@show shadow_price(c1)
@show shadow_price(c2)"><pre><span class="pl-k">using</span> JuMP
<span class="pl-k">using</span> COPT
model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(COPT<span class="pl-k">.</span>ConeOptimizer)
C <span class="pl-k">=</span> [<span class="pl-c1">1.0</span> <span class="pl-k">-</span><span class="pl-c1">1.0</span>; <span class="pl-k">-</span><span class="pl-c1">1.0</span> <span class="pl-c1">2.0</span>]
<span class="pl-c1">@variable</span>(model, X[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>], PSD)
<span class="pl-c1">@variable</span>(model, z[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>] <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>)
<span class="pl-c1">@objective</span>(model, Min, C <span class="pl-k">⋅</span> X)
<span class="pl-c1">@constraint</span>(model, c1, X[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">-</span> z[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">1</span>)
<span class="pl-c1">@constraint</span>(model, c2, X[<span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">-</span> z[<span class="pl-c1">2</span>] <span class="pl-k">==</span> <span class="pl-c1">1</span>)
<span class="pl-c1">optimize!</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">termination_status</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">primal_status</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">dual_status</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">objective_value</span>(model)
<span class="pl-c1">@show</span> <span class="pl-c1">value</span>.(X)
<span class="pl-c1">@show</span> <span class="pl-c1">value</span>.(z)
<span class="pl-c1">@show</span> <span class="pl-c1">shadow_price</span>(c1)
<span class="pl-c1">@show</span> <span class="pl-c1">shadow_price</span>(c2)</pre></div>
<p dir="auto">Please refer to <a href="https://jump.dev/JuMP.jl/stable/tutorials/getting_started/getting_started_with_JuMP/" rel="nofollow">Getting started with JuMP</a>
for a quick introduction to writing and solving optimization models with JuMP.
The model above is adapted from the introduction page.</p>
</article></div>