<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-nonlinearsystemsjl" class="anchor" aria-hidden="true" href="#nonlinearsystemsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NonlinearSystems.jl</h1>
<p dir="auto"><em>Solve nonlinear systems of equations and nonlinear least squares in Julia</em></p>
<p dir="auto"><a href="https://github.com/junyuan-chen/NonlinearSystems.jl/actions?query=workflow%3ACI-stable"><img src="https://github.com/junyuan-chen/NonlinearSystems.jl/workflows/CI-stable/badge.svg" alt="CI-stable" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/junyuan-chen/NonlinearSystems.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/6733c7e407b797a50769fd778a5e237603a0591525faaf25cb7be50e587ee102/68747470733a2f2f636f6465636f762e696f2f67682f6a756e7975616e2d6368656e2f4e6f6e6c696e65617253797374656d732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/junyuan-chen/NonlinearSystems.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/N/NonlinearSystems.html" rel="nofollow"><img src="https://camo.githubusercontent.com/347f778c8ad1685a4e8914e60f79e7b69262047fd215ac627d1c616deecec691/68747470733a2f2f6a756c696163692e6769746875622e696f2f4e616e6f736f6c646965725265706f7274732f706b676576616c5f6261646765732f4e2f4e6f6e6c696e65617253797374656d732e737667" alt="PkgEval" data-canonical-src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/N/NonlinearSystems.svg" style="max-width: 100%;"></a>
<a href="https://junyuan-chen.github.io/NonlinearSystems.jl/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="docs-stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://junyuan-chen.github.io/NonlinearSystems.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="docs-dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/junyuan-chen/NonlinearSystems.jl">NonlinearSystems.jl</a>
is a Julia package for solving nonlinear systems of equations and nonlinear least squares.
It renovates well-trusted solution algorithms with
highly performant and extensible implementation in native Julia language.</p>
<p dir="auto">NonlinearSystems.jl places special emphasis on</p>
<ul dir="auto">
<li>Low number of evaluations needed for updating the Jacobian matrix</li>
<li>Flexibility of swapping the underlying linear solver based on array type and hardware</li>
<li>Zero memory allocation incurred in iteration steps</li>
</ul>
<p dir="auto">At this moment, the only solution algorithm implemented
is a modified version of Powell's hybrid method
(a trust region method with dogleg).
Relations to existing packages are further discussed towards the end.</p>
<h2 dir="auto"><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick Start</h2>
<p dir="auto">NonlinearSystems.jl adopts the
<a href="https://github.com/SciML/CommonSolve.jl">CommonSolve.jl</a> interface
and wraps a residual function as <code>OnceDifferentiable</code> defined in
<a href="https://github.com/JuliaNLSolvers/NLSolversBase.jl">NLSolversBase.jl</a>
with an optionally user-provided Jacobian function.
The same interface is shared for
solving a root-finding problems and solving a least-squares problems.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using NonlinearSystems

# Residual function
function f!(F, x)
    F[1] = (x[1] + 3) * (x[2]^3 - 7) + 18
    F[2] = sin(x[2] * exp(x[1]) - 1)
    return F
end

# Jacobian function (optional)
function j!(J, x)
    J[1,1] = x[2]^3 - 7
    J[1,2] = 3 * x[2]^2 * (x[1] + 3)
    u = exp(x[1]) * cos(x[2] * exp(x[1]) - 1)
    J[2,1] = x[2] * u
    J[2,2] = u
    return J
end

# Initial value
x0 = [0.1, 1.2]

# Evaluate Jacobians via finite differencing methods from FiniteDiff.jl
solve(Hybrid{RootFinding}, f!, x0)

# Use user-specified Jacobian function and separate out the initialization step
s = init(Hybrid{LeastSquares}, f!, j!, x0)
solve!(s)"><pre><span class="pl-k">using</span> NonlinearSystems

<span class="pl-c"><span class="pl-c">#</span> Residual function</span>
<span class="pl-k">function</span> <span class="pl-en">f!</span>(F, x)
    F[<span class="pl-c1">1</span>] <span class="pl-k">=</span> (x[<span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">3</span>) <span class="pl-k">*</span> (x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">7</span>) <span class="pl-k">+</span> <span class="pl-c1">18</span>
    F[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">sin</span>(x[<span class="pl-c1">2</span>] <span class="pl-k">*</span> <span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">1</span>)
    <span class="pl-k">return</span> F
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Jacobian function (optional)</span>
<span class="pl-k">function</span> <span class="pl-en">j!</span>(J, x)
    J[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">7</span>
    J[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">3</span> <span class="pl-k">*</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">*</span> (x[<span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">3</span>)
    u <span class="pl-k">=</span> <span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>]) <span class="pl-k">*</span> <span class="pl-c1">cos</span>(x[<span class="pl-c1">2</span>] <span class="pl-k">*</span> <span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">1</span>)
    J[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>] <span class="pl-k">*</span> u
    J[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> u
    <span class="pl-k">return</span> J
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Initial value</span>
x0 <span class="pl-k">=</span> [<span class="pl-c1">0.1</span>, <span class="pl-c1">1.2</span>]

<span class="pl-c"><span class="pl-c">#</span> Evaluate Jacobians via finite differencing methods from FiniteDiff.jl</span>
<span class="pl-c1">solve</span>(Hybrid{RootFinding}, f!, x0)

<span class="pl-c"><span class="pl-c">#</span> Use user-specified Jacobian function and separate out the initialization step</span>
s <span class="pl-k">=</span> <span class="pl-c1">init</span>(Hybrid{LeastSquares}, f!, j!, x0)
<span class="pl-c1">solve!</span>(s)</pre></div>
<p dir="auto">For more details, please see the <a href="https://junyuan-chen.github.io/NonlinearSystems.jl/stable/" rel="nofollow">documentation</a>.</p>
<h2 dir="auto"><a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related Packages</h2>
<p dir="auto">NonlinearSystems.jl addresses the following limitations that the related packages do not:</p>
<ul dir="auto">
<li><a href="https://github.com/sglyon/MINPACK.jl">MINPACK.jl</a> and <a href="https://github.com/JuliaMath/GSL.jl">GSL.jl</a>
<ul dir="auto">
<li>No option for swapping the linear solver</li>
<li>Use of rank-1 update of the Jacobian matrix and factorization cannot be adjusted</li>
<li>Wrappers of C interface; no native Julia implementation</li>
<li>MINPACK.jl does not work on Apple Silicon</li>
</ul>
</li>
<li><a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a>
<ul dir="auto">
<li>No option for swapping the linear solver</li>
<li>No rank-1 update of the Jacobian matrix and factorization</li>
<li>Iteration steps are not non-allocating</li>
<li>No support for nonlinear least squares</li>
</ul>
</li>
<li><a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve.jl</a>
<ul dir="auto">
<li>Trust region solver (<code>TrustRegion</code>) does not provide correct answers on test problems (as of version 1.6)</li>
<li>No rank-1 update of the Jacobian matrix and factorization</li>
<li>Iteration steps are not non-allocating</li>
<li>No support for nonlinear least squares</li>
</ul>
</li>
<li><a href="https://github.com/matthieugomez/LeastSquaresOptim.jl">LeastSquaresOptim.jl</a>
<ul dir="auto">
<li>Only solves nonlinear least squares</li>
<li>No rank-1 update of the Jacobian matrix and factorization</li>
</ul>
</li>
<li><a href="https://github.com/JuliaNLSolvers/LsqFit.jl">LsqFit.jl</a>
<ul dir="auto">
<li>Only solves nonlinear least squares</li>
<li>Performance seems to be dominated by LeastSquaresOptim.jl</li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-roadmap" class="anchor" aria-hidden="true" href="#roadmap"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Roadmap</h2>
<p dir="auto">The development of NonlinearSystems.jl is still in an early stage.
At this moment, only trust-region methods are considered and
the linear problem involved in each iteration is only solved by dense matrix factorization.</p>
<p dir="auto">The following features will be added in future:</p>
<ul dir="auto">
<li>Support for sparse Jacobian matrices</li>
<li>Support for conducting linear algebra on GPUs</li>
</ul>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto"><strong>Moré, Jorge J., Danny C. Sorenson, Burton S. Garbow, and Kenneth E. Hillstrom.</strong> 1984.
"The MINPACK Project."
In <em>Sources and Development of Mathematical Software</em>,
ed. Wayne R. Cowell, 88-111. New Jersey: Prentice-Hall.</p>
<p dir="auto"><strong>Nocedal, Jorge, and Stephen J. Wright.</strong> 2006.
<em>Numerical Optimization.</em> 2nd ed. New York: Springer.</p>
<p dir="auto"><strong>Powell, Michael J. D.</strong> 1970.
"A Hybrid Method for Nonlinear Equations."
In <em>Numerical Methods for Nonlinear Algebraic Equations</em>,
ed. Philip Rabinowitz, 87-114. London: Gordon and Breach.</p>
</article></div>