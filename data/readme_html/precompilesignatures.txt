<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-precompilesignaturesjl" class="anchor" aria-hidden="true" href="#precompilesignaturesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PrecompileSignatures.jl</h1>
<p dir="auto">This package reads all method signatures in a package and generates precompile directives for any concrete signature that it can find.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">Add this package to your package <code>Foo</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; activate Foo

(Foo) pkg&gt; add PrecompileSignatures"><pre>pkg<span class="pl-k">&gt;</span> activate Foo

(Foo) pkg<span class="pl-k">&gt;</span> add PrecompileSignatures</pre></div>
<p dir="auto">Next, add <code>@precompile_signatures(Foo)</code> somewhere after your module's logic.
For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module Foo

using PrecompileSignatures: @precompile_signatures

[...]

# Generate and run `precompile` directives.
@precompile_signatures(Foo)

end # module"><pre><span class="pl-k">module</span> Foo

<span class="pl-k">using</span> PrecompileSignatures<span class="pl-k">:</span> <span class="pl-c1">@precompile_signatures</span>

[<span class="pl-k">...</span>]

<span class="pl-c"><span class="pl-c">#</span> Generate and run `precompile` directives.</span>
<span class="pl-c1">@precompile_signatures</span>(Foo)

<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> module</span></pre></div>
<h2 dir="auto"><a id="user-content-how-does-this-package-work" class="anchor" aria-hidden="true" href="#how-does-this-package-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How does this package work?</h2>
<p dir="auto">This package finds precompile directives by searching for concrete types in method signatures.
For example, for the function</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function f(x::Int, y::Float64)
    return x
end"><pre><span class="pl-k">function</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">Int</span>, y<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
    <span class="pl-k">return</span> x
<span class="pl-k">end</span></pre></div>
<p dir="auto">this package will generate</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="precompile(Tuple{typeof(f), Int, Float64})"><pre><span class="pl-c1">precompile</span>(Tuple{<span class="pl-c1">typeof</span>(f), Int, Float64})</pre></div>
<p dir="auto">Also, this package will create <code>precompile</code> directives for <code>(Int, Float64)</code> and <code>(Float32, Float64)</code> from the following method definitions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function f(x, y)
    return x
end
f(x::Union{Int,Float32}, y::Float64}) = f(x)"><pre><span class="pl-k">function</span> <span class="pl-en">f</span>(x, y)
    <span class="pl-k">return</span> x
<span class="pl-k">end</span>
<span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">Union{Int,Float32}</span>, y<span class="pl-k">::</span><span class="pl-c1">Float64</span>}) <span class="pl-k">=</span> <span class="pl-c1">f</span>(x)</pre></div>
<p dir="auto">This splitting of union types can be disabled by setting <code>split_union=false</code>.</p>
<p dir="auto"><strong>Note</strong></p>
<p dir="auto">Unfortunately, writing</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function f(x::Union{Float64,Float32,Any}, y::Float64})
    return x
end"><pre><span class="pl-k">function</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">Union{Float64,Float32,Any}</span>, y<span class="pl-k">::</span><span class="pl-c1">Float64</span>})
    <span class="pl-k">return</span> x
<span class="pl-k">end</span></pre></div>
<p dir="auto">doesn't generate <code>precompile</code> directives for <code>Float64</code> and <code>Float32</code> on <code>x</code> because the signature is simplified to <code>Any</code> by Julia's internals:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; z(x::Union{Int,Any}) = x;

julia&gt; only(methods(z)).sig
Tuple{typeof(z), Any}"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">z</span>(x<span class="pl-k">::</span><span class="pl-c1">Union{Int,Any}</span>) <span class="pl-k">=</span> x;

julia<span class="pl-k">&gt;</span> <span class="pl-c1">only</span>(<span class="pl-c1">methods</span>(z))<span class="pl-k">.</span>sig
Tuple{<span class="pl-c1">typeof</span>(z), Any}</pre></div>
<p dir="auto">In other words, this package cannot easily extract all types mentioned in the union in this case.</p>
<h2 dir="auto"><a id="user-content-by-how-much-does-this-package-reduce-the-time-to-first-x" class="anchor" aria-hidden="true" href="#by-how-much-does-this-package-reduce-the-time-to-first-x"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>By how much does this package reduce the time to first X?</h2>
<p dir="auto">Depends on the package.
The more signatures a package has with concretely typed arguments, the more <code>precompile</code> directives can be added.
Next, the better the types inside the methods can be inferred, the more performance can be gained from adding the directives.
As an indication, in this package the time for the first <code>@time @eval precompilables(PrecompileSignatures)</code> is reduced by 0.3 seconds (-15%) and 134 MiB allocations (-19%).
In <a href="https://github.com/fonsp/Pluto.jl"><code>Pluto.jl</code></a>, the compile time benchmark is 3 seconds faster (-3%) and 1.6 GiB allocations less (-47%), see <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1212674176" data-permission-text="Title is private" data-url="https://github.com/fonsp/Pluto.jl/issues/2054" data-hovercard-type="pull_request" data-hovercard-url="/fonsp/Pluto.jl/pull/2054/hovercard" href="https://github.com/fonsp/Pluto.jl/pull/2054">fonsp/Pluto.jl#2054</a> for details.
Both these numbers are obtained with Julia 1.8-beta3.</p>
<h2 dir="auto"><a id="user-content-how-does-this-package-compare-to-running-code-during-the-precompilation-phase" class="anchor" aria-hidden="true" href="#how-does-this-package-compare-to-running-code-during-the-precompilation-phase"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How does this package compare to running code during the precompilation phase?</h2>
<p dir="auto">Some packages nowadays run code during the precompilation phase.
For example, at the time of writing, <a href="https://github.com/JuliaPlots/Makie.jl"><code>Makie.jl</code></a> runs</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="## src/precompiles.jl
function _precompile_()
    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing
    f, ax1, pl = scatter(1:4)
    f, ax2, pl = lines(1:4)
    f = Figure()
    Axis(f[1,1])
    return
end

## src/Makie.jl
if Base.VERSION &gt;= v&quot;1.4.2&quot;
    include(&quot;precompiles.jl&quot;)
    _precompile_()
end"><pre><span class="pl-c"><span class="pl-c">#</span># src/precompiles.jl</span>
<span class="pl-k">function</span> <span class="pl-en">_precompile_</span>()
    <span class="pl-c1">ccall</span>(<span class="pl-c1">:jl_generating_output</span>, Cint, ()) <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
    f, ax1, pl <span class="pl-k">=</span> <span class="pl-c1">scatter</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>)
    f, ax2, pl <span class="pl-k">=</span> <span class="pl-c1">lines</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>)
    f <span class="pl-k">=</span> <span class="pl-c1">Figure</span>()
    <span class="pl-c1">Axis</span>(f[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])
    <span class="pl-k">return</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span># src/Makie.jl</span>
<span class="pl-k">if</span> Base<span class="pl-k">.</span><span class="pl-c1">VERSION</span> <span class="pl-k">&gt;=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">v</span>"</span>1.4.2<span class="pl-pds">"</span></span>
    <span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>precompiles.jl<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_precompile_</span>()
<span class="pl-k">end</span></pre></div>
<p dir="auto">What happens here is that the code such as <code>lines(1:4)</code> is executed during the precompilation phase.
While running the code, Julia will compile all methods that it needs to run the code.</p>
<p dir="auto">In contrast, <code>PrecompileSignatures.jl</code> would call precompile directives such as <code>precompile(lines, (UnitRange{Int},))</code>.
The benefit is that this will not actually run the code.
However because of that, it will also not be able to precompile everything since some types cannot be infered when going through methods recursively.
That's why the TTFX performance of this package lies somewhere in between actually calling the code and not calling the code nor calling <code>precompile</code>.</p>
<p dir="auto">So firstly, the strength of this package is mostly to automatically decide what to precompile.
You don't need to manually figure out what code to run.
Secondly, the strength of this package lies in codebases where the code cannot easily be called during the precompilation phase.
For example, for code with side-effects such as disk or network operations.</p>
<h2 dir="auto"><a id="user-content-how-does-this-package-compare-to-snoopcompile" class="anchor" aria-hidden="true" href="#how-does-this-package-compare-to-snoopcompile"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How does this package compare to SnoopCompile?</h2>
<p dir="auto">Like this package, <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile.jl</a> can also generate precompile directives.
Where this package does it by reading code and signatures, SnoopCompile runs code to find directives.
Because SnoopCompile runs the code, it can find much more directives.
However, the problem with running code is that it takes long.
For example, to generate a lot of precompile directives in <a href="https://github.com/fonsp/Pluto.jl">Pluto.jl</a>, we could run all tests.
This takes about 20 minutes.
Conversely, this package takes about 6 seconds to generate directives for all modules in Pluto.
In practise, this means that this package can re-generate the directives with each start of the package whereas SnoopCompile's directives have to be cached, that is, stored in the repository.</p>
<h2 dir="auto"><a id="user-content-how-can-i-see-what-signatures-this-package-creates" class="anchor" aria-hidden="true" href="#how-can-i-see-what-signatures-this-package-creates"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How can I see what signatures this package creates?</h2>
<p dir="auto">Use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="PrecompileSignatures.precompilables(Foo)"><pre>PrecompileSignatures<span class="pl-k">.</span><span class="pl-c1">precompilables</span>(Foo)</pre></div>
<p dir="auto">where <code>Foo</code> is the name of your package.</p>
<h2 dir="auto"><a id="user-content-how-can-i-see-whether-the-created-signatures-are-valid" class="anchor" aria-hidden="true" href="#how-can-i-see-whether-the-created-signatures-are-valid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How can I see whether the created signatures are valid?</h2>
<p dir="auto">By default, this package doesn't verify the <code>precompile</code> directives to avoid breaking precompilation in worst-case scenarios.
To verify the directives for debugging purposes, use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="types = PrecompileSignatures.precompilables(Foo)
@assert all(precompile.(types))"><pre>types <span class="pl-k">=</span> PrecompileSignatures<span class="pl-k">.</span><span class="pl-c1">precompilables</span>(Foo)
<span class="pl-c1">@assert</span> <span class="pl-c1">all</span>(<span class="pl-c1">precompile</span>.(types))</pre></div>
<p dir="auto">where <code>Foo</code> is the name of your package.</p>
<h2 dir="auto"><a id="user-content-further-notes" class="anchor" aria-hidden="true" href="#further-notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Further notes</h2>
<p dir="auto">Unfortunately, in many cases, inference will run all over again even after some method has been "precompiled".
For more information about this, see <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="771682908" data-permission-text="Title is private" data-url="https://github.com/JuliaLang/julia/issues/38951" data-hovercard-type="issue" data-hovercard-url="/JuliaLang/julia/issues/38951/hovercard?comment_id=749153888&amp;comment_type=issue_comment" href="https://github.com/JuliaLang/julia/issues/38951#issuecomment-749153888">JuliaLang/julia#38951 (comment)</a> and the related discussions.
This aspect is a work-in-progress.
For example, a recent PR that got merged related to this is "Cache external CodeInstances" (<a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1118691210" data-permission-text="Title is private" data-url="https://github.com/JuliaLang/julia/issues/43990" data-hovercard-type="pull_request" data-hovercard-url="/JuliaLang/julia/pull/43990/hovercard" href="https://github.com/JuliaLang/julia/pull/43990">JuliaLang/julia#43990</a>).
With the great work that is done at the Julia-side, this package is expected to make a bigger difference over time.</p>
</article></div>