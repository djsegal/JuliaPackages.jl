<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-approximate-bayesian-computation" class="anchor" aria-hidden="true" href="#approximate-bayesian-computation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Approximate Bayesian Computation</h1>
<p dir="auto"><a href="https://travis-ci.org/marcjwilliams1/ApproxBayes.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/13708d94da55452f9dcedb27bf837eac0fadebd41394e79d51f275b43c5bce09/68747470733a2f2f7472617669732d63692e6f72672f6d6172636a77696c6c69616d73312f417070726f7842617965732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/marcjwilliams1/ApproxBayes.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/marcjwilliams1/approxbayes-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/84d5664de98647d26b0d6095f4f5e6fb23f5df74a1b9e3d4533afb228dc37fb9/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f6d6172636a77696c6c69616d73312f417070726f7842617965732e6a6c3f6272616e63683d6d6173746572267376673d74727565" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/marcjwilliams1/ApproxBayes.jl?branch=master&amp;svg=true" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/marcjwilliams1/ApproxBayes.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/5844f189185264f803cf7d3ae97ef147a17a9431756ef74aa8aa88e693eee570/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6d6172636a77696c6c69616d73312f417070726f7842617965732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/marcjwilliams1/ApproxBayes.jl/badge.svg?branch=master" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/marcjwilliams1/ApproxBayes.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/9fd8459949ef6f612aeba6f862e32fa4f3e7a1a3c8462a2b90d6ad372b64b92f/687474703a2f2f636f6465636f762e696f2f6769746875622f6d6172636a77696c6c69616d73312f417070726f7842617965732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/marcjwilliams1/ApproxBayes.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">Package to implement Approximate Bayesian computation algorithms in the <a href="https://julialang.org/" rel="nofollow">Julia</a> programming language. Package implements basic ABC rejection sampler and sequential monte carlo algorithm (ABC SMC) as in Toni. et al 2009 as well as model selection versions of both (Toni. et al 2010).</p>
<h2 dir="auto"><a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting Started</h2>
<p dir="auto">To download the package, once you're in a Julia session type the following command:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Pkg.add(&quot;ApproxBayes&quot;)"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>ApproxBayes<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">Below is a simple example using the package to infer the mean of a normal distribution. The first step is to create an ABC type which stores the information required to run an analysis. The first input is the simulation function which returns a distance between the simulated and target data sets, the second input is the number of parameters and the the third is the desired tolerance. The final required input is the prior distributions for the parameters, this specified as by creating an a <code>Prior</code> type which is an array of distribution types from <a href="https://github.com/JuliaStats/Distributions.jl/">Distributions.jl</a> of the same length as the number of parameters. There are some more optional parameters that are specific the the different algorithms.</p>
<p dir="auto">First we'll load <code>ApproxBayes</code> and <code>Distributions</code> packages.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ApproxBayes
using Distributions"><pre><span class="pl-k">using</span> ApproxBayes
<span class="pl-k">using</span> Distributions</pre></div>
<p dir="auto">Now we'll set up the simulation function, we'll use the Kolmogorov Distance as our distance measure. The simulation needs to return 2 values the first being the distance, the second value is useful if additional information from the simulation needs to be stored, here this is not the case so we'll simply return 1, for example sometimes we might want to keep the raw data generated from each simulation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function normaldist(params, constants, targetdata)
  simdata = rand(Normal(params...), 1000)
  ApproxBayes.ksdist(simdata, targetdata), 1
end"><pre><span class="pl-k">function</span> <span class="pl-en">normaldist</span>(params, constants, targetdata)
  simdata <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">Normal</span>(params<span class="pl-k">...</span>), <span class="pl-c1">1000</span>)
  ApproxBayes<span class="pl-k">.</span><span class="pl-c1">ksdist</span>(simdata, targetdata), <span class="pl-c1">1</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Now we can generate some target data, we'll take 100 samples from a normal distirbution with mean = 2.0 and variance = 0.4.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Random
Random.seed!(1)
p1 = 2.0
p2 = 0.4
targetdata = rand(Normal(p1, p2), 1000)"><pre><span class="pl-k">using</span> Random
Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1</span>)
p1 <span class="pl-k">=</span> <span class="pl-c1">2.0</span>
p2 <span class="pl-k">=</span> <span class="pl-c1">0.4</span>
targetdata <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">Normal</span>(p1, p2), <span class="pl-c1">1000</span>)</pre></div>
<p dir="auto">Now we can setup an ABCrejection type and run the inference.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="setup = ABCRejection(normaldist, #simulation function
  2, # number of parameters
  0.1, #target ϵ
  Prior([Uniform(0.0, 20.0), Uniform(0.0, 2.0)]); # Prior for each of the parameters
  maxiterations = 10^6, #Maximum number of iterations before the algorithm terminates
  )

# run ABC inference
rejection = runabc(setup, targetdata)"><pre>setup <span class="pl-k">=</span> <span class="pl-c1">ABCRejection</span>(normaldist, <span class="pl-c"><span class="pl-c">#</span>simulation function</span>
  <span class="pl-c1">2</span>, <span class="pl-c"><span class="pl-c">#</span> number of parameters</span>
  <span class="pl-c1">0.1</span>, <span class="pl-c"><span class="pl-c">#</span>target ϵ</span>
  <span class="pl-c1">Prior</span>([<span class="pl-c1">Uniform</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">20.0</span>), <span class="pl-c1">Uniform</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">2.0</span>)]); <span class="pl-c"><span class="pl-c">#</span> Prior for each of the parameters</span>
  maxiterations <span class="pl-k">=</span> <span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">6</span>, <span class="pl-c"><span class="pl-c">#</span>Maximum number of iterations before the algorithm terminates</span>
  )

<span class="pl-c"><span class="pl-c">#</span> run ABC inference</span>
rejection <span class="pl-k">=</span> <span class="pl-c1">runabc</span>(setup, targetdata)</pre></div>
<p dir="auto">We can do the same with ABC SMC algorithm.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="setup = ABCSMC(normaldist, #simulation function
  2, # number of parameters
  0.1, #target ϵ
  Prior([Uniform(0.0, 20.0), Uniform(0.0, 2.0)]), #Prior for each of the parameters
  )

smc = runabc(setup, targetdata, verbose = true, progress = true)"><pre>setup <span class="pl-k">=</span> <span class="pl-c1">ABCSMC</span>(normaldist, <span class="pl-c"><span class="pl-c">#</span>simulation function</span>
  <span class="pl-c1">2</span>, <span class="pl-c"><span class="pl-c">#</span> number of parameters</span>
  <span class="pl-c1">0.1</span>, <span class="pl-c"><span class="pl-c">#</span>target ϵ</span>
  <span class="pl-c1">Prior</span>([<span class="pl-c1">Uniform</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">20.0</span>), <span class="pl-c1">Uniform</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">2.0</span>)]), <span class="pl-c"><span class="pl-c">#</span>Prior for each of the parameters</span>
  )

smc <span class="pl-k">=</span> <span class="pl-c1">runabc</span>(setup, targetdata, verbose <span class="pl-k">=</span> <span class="pl-c1">true</span>, progress <span class="pl-k">=</span> <span class="pl-c1">true</span>)</pre></div>
<h3 dir="auto"><a id="user-content-parallelism" class="anchor" aria-hidden="true" href="#parallelism"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Parallelism</h3>
<p dir="auto">Parallelism is provided via multithreading. To use multithreading you'll need to set the JULIA_NUM_THREADS environmental variable before running julia (one way of doing this exporting the variable in the terminal eg <code>export JULIA_NUM_THREADS=1</code>). Then when running an ABCRejection or ABCSMC inference in parallel set the <code>parallel</code> keyword to true. For example the normal distribution example above would be run in parallel as follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="setup = ABCSMC(normaldist, #simulation function
  2, # number of parameters
  0.1, #target ϵ
  Prior([Uniform(0.0, 20.0), Uniform(0.0, 2.0)]), #Prior for each of the parameters
  )

smc = runabc(setup, targetdata, verbose = true, progress = true, parallel = true)"><pre>setup <span class="pl-k">=</span> <span class="pl-c1">ABCSMC</span>(normaldist, <span class="pl-c"><span class="pl-c">#</span>simulation function</span>
  <span class="pl-c1">2</span>, <span class="pl-c"><span class="pl-c">#</span> number of parameters</span>
  <span class="pl-c1">0.1</span>, <span class="pl-c"><span class="pl-c">#</span>target ϵ</span>
  <span class="pl-c1">Prior</span>([<span class="pl-c1">Uniform</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">20.0</span>), <span class="pl-c1">Uniform</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">2.0</span>)]), <span class="pl-c"><span class="pl-c">#</span>Prior for each of the parameters</span>
  )

smc <span class="pl-k">=</span> <span class="pl-c1">runabc</span>(setup, targetdata, verbose <span class="pl-k">=</span> <span class="pl-c1">true</span>, progress <span class="pl-k">=</span> <span class="pl-c1">true</span>, parallel <span class="pl-k">=</span> <span class="pl-c1">true</span>)</pre></div>
<h3 dir="auto"><a id="user-content-optional-arguments" class="anchor" aria-hidden="true" href="#optional-arguments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Optional arguments</h3>
<p dir="auto">There are more optional arguments for each of the algorithms, to see these simply use <code>?ABCSMC</code> in a Julia session. If verbose and progress are set to true then a progress meter will be displayed and at the end of each population a summary will be printed.</p>
<p dir="auto">There are more examples provided in the examples directory and used as tests in the test directory. ApproxBayes.jl is also available as an option to perform Bayesian inference with differential equations in <a href="https://github.com/JuliaDiffEq/DiffEqBayes.jl">DiffEqBayes.jl</a>.</p>
<h3 dir="auto"><a id="user-content-perturbation-kernels" class="anchor" aria-hidden="true" href="#perturbation-kernels"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Perturbation kernels</h3>
<p dir="auto">One requirement for the ABC SMC is to have a perturbation kernel. This kernel takes a sampled particle and perturbs the parameter vector in some way to explore the parameter space. Two default kernels are supplied by ApproxBayes.jl, a uniform kernel and a gaussian kernel. Both are adaptive in that the parameters specific to the kernel change as the distance decreases. For example, in the gaussian kernel the variance is calculated from the variance of the previous population. If you want to write your own kernel, take a look at <code>src/kernels.jl</code> for examples.</p>
<h3 dir="auto"><a id="user-content-convenience-functions" class="anchor" aria-hidden="true" href="#convenience-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Convenience functions</h3>
<p dir="auto">Also provided are some convenience functions for plotting and saving the output.</p>
<ul dir="auto">
<li><code>writeoutput(abcresults)</code>: This will write the output to a text file should you wish to some additional analysis or plotting using some other tools or languages.</li>
<li><code>plot</code>: Plotting recipes for use with <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> are provided. Just use <code>plot</code> on any ABC return type. This will plot histograms of the posterior distributions. For the model selection algorithm <code>plot(result::ABCSMCmodelresults)</code> will plot the model posterior probabilities, a second argument indexing a particular model will plot the parameter posterior distributions for that model, ie <code>plot(result::ABCSMCmodelresults, 1)</code> will plot the posterior distribution of parameters for model 1. You'll need to add the <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> packages yourself as it is not bundled in with <code>ApproxBayes.jl</code>.</li>
</ul>
<h2 dir="auto"><a id="user-content-other-abc-packages-in-julia" class="anchor" aria-hidden="true" href="#other-abc-packages-in-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Other ABC packages in julia</h2>
<p dir="auto">Here are some other packages that perform ABSC in julia that I am aware of. If this package does not have all your requirements then you might want to take a look at these. <a href="https://github.com/tanhevg/GpABC.jl">gpABC.jl</a> in particular has more features.</p>
<ul dir="auto">
<li><a href="https://github.com/tanhevg/GpABC.jl">gpABC.jl</a></li>
<li><a href="https://github.com/eford/ABC.jl">ABC.jl</a></li>
</ul>
<h2 dir="auto"><a id="user-content-acknowledgments" class="anchor" aria-hidden="true" href="#acknowledgments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgments</h2>
<p dir="auto">Some of the code was inspired by <a href="http://www.theosysbio.bio.ic.ac.uk/resources/abc-sysbio/" rel="nofollow">ABC-SysBio</a>.</p>
</article></div>