<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-versatile-binary-heaps-and-priority-queues-for-julia" class="anchor" aria-hidden="true" href="#versatile-binary-heaps-and-priority-queues-for-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Versatile binary heaps and priority queues for Julia</h1>
<p dir="auto"><a href="https://emmt.github.io/QuickHeaps.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Doc. Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://emmt.github.io/QuickHeaps.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Doc. Devel" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="./LICENSE.md"><img src="https://camo.githubusercontent.com/bbf49a2eb96e6f718803f2493bd7aa3baae61abb09b7f8fc185a94e08c504dc6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d627269676874677265656e2e7376673f7374796c653d666c6174" alt="License" data-canonical-src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" style="max-width: 100%;"></a>
<a href="https://github.com/emmt/QuickHeaps.jl/actions/workflows/CI.yml?query=branch%3Amaster"><img src="https://github.com/emmt/QuickHeaps.jl/actions/workflows/CI.yml/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/emmt/QuickHeaps-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/ef6ffd65bc0278a47f07ea6c7495845343b99eaac1576c28c30b4245211cfadc/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f656d6d742f517569636b48656170732e6a6c3f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/emmt/QuickHeaps.jl?branch=master" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/emmt/QuickHeaps.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/97e8d3eda262d67c3b9f6421b292b53bf317d2a9f93c1b59457e2cf0b1d3018b/687474703a2f2f636f6465636f762e696f2f6769746875622f656d6d742f517569636b48656170732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="Coverage" data-canonical-src="http://codecov.io/github/emmt/QuickHeaps.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto"><code>QuickHeaps</code> is a small <a href="https://julialang.org/" rel="nofollow">Julia</a> package providing versatile <a href="https://en.wikipedia.org/wiki/Binary_heap" rel="nofollow">binary
heaps</a> and <a href="https://en.wikipedia.org/wiki/Priority_queue" rel="nofollow">priority
queues</a>. These data structures
are more flexible and may be quite significantly faster than those provided by
<a href="https://github.com/JuliaCollections/DataStructures.jl"><code>DataStructures</code></a>.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">The easiest way to install <code>QuickHeaps</code> is to use <a href="https://pkgdocs.julialang.org/" rel="nofollow">Julia's package
manager</a>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
pkg&quot;add QuickHeaps&quot;"><pre><span class="pl-k">using</span> Pkg
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">pkg</span>"</span>add QuickHeaps<span class="pl-pds">"</span></span></pre></div>
<h2 dir="auto"><a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Documentation</h2>
<p dir="auto">Documentation is available for different versions of <code>QuickHeaps</code>:</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://emmt.github.io/QuickHeaps.jl/stable" rel="nofollow">last release</a>;</p>
</li>
<li>
<p dir="auto"><a href="https://emmt.github.io/QuickHeaps.jl/stable" rel="nofollow">development version</a>.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-speed-up-and-strengthen-sorting-algorithms" class="anchor" aria-hidden="true" href="#speed-up-and-strengthen-sorting-algorithms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Speed up and strengthen sorting algorithms</h2>
<p dir="auto">The sorting algorithms in Julia are very powerful but have some issues (for
me):</p>
<ol dir="auto">
<li>
<p dir="auto">Sorting algorithms involve lots of comparisons and could be much faster if
we know that there are no NaN's in the arrays to sort or if we assume (at
our own risk) that they can be ignored.</p>
</li>
<li>
<p dir="auto">Some non-exported methods may be very useful if they can be safely
called.</p>
</li>
</ol>
<p dir="auto">This short note is bout dealing with these two points.</p>
<h3 dir="auto"><a id="user-content-speed-up-sorting" class="anchor" aria-hidden="true" href="#speed-up-sorting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Speed up sorting</h3>
<p dir="auto">Sorting algorithms in Julia rely on <code>Base.Order.lt(o,x,y)</code> to check whether <code>x</code>
is <em>before</em> <code>y</code> according to the ordering specified in <code>o</code> (the letters <code>lt</code>
stands for <em>less than</em>).  Most (all?) Julia sorting methods have an <code>order</code>
keyword to specify the ordering.  By default, ordering is <code>Base.Order.Forward</code>
which is the singleton of type <code>Base.Order.ForwardOrdering</code>.  Another usual
choice is to take <code>Base.Order.Reverse</code>.  In short, when sorting, you are using
the following definitions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const Forward = ForwardOrdering()
const Reverse = ReverseOrdering()
lt(o::ForwardOrdering, a, b) = isless(a,b)
lt(o::ReverseOrdering, a, b) = lt(o.fwd,b,a)"><pre><span class="pl-k">const</span> Forward <span class="pl-k">=</span> <span class="pl-c1">ForwardOrdering</span>()
<span class="pl-k">const</span> Reverse <span class="pl-k">=</span> <span class="pl-c1">ReverseOrdering</span>()
<span class="pl-en">lt</span>(o<span class="pl-k">::</span><span class="pl-c1">ForwardOrdering</span>, a, b) <span class="pl-k">=</span> <span class="pl-c1">isless</span>(a,b)
<span class="pl-en">lt</span>(o<span class="pl-k">::</span><span class="pl-c1">ReverseOrdering</span>, a, b) <span class="pl-k">=</span> <span class="pl-c1">lt</span>(o<span class="pl-k">.</span>fwd,b,a)</pre></div>
<p dir="auto">So it turns out that, <code>isless</code> is eventually called, not the operator <code>&lt;</code>.  For
integers <code>isless(x,y)</code> and <code>x &lt; y</code> are the same (at least as far as execution
time is concerned) but for floating-point values, <code>isless</code> takes care of NaN's
which involves overheads and this may strongly impact the execution time of
sorting algorithms.</p>
<p dir="auto">Simple means to ignore NaN's in sorting consists in defining your own ordering
types and extend the <code>Base.Order.lt</code> method, this is pretty simple:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Base: Ordering, ReverseOrdering
struct FastForwardOrdering &lt;: Ordering end
const FastForward = FastForwardOrdering()
const FastReverse = ReverseOrdering(FastForward)

import Base: lt
lt(::FastForwardOrdering, a, b) = a &lt; b"><pre><span class="pl-k">using</span> Base<span class="pl-k">:</span> Ordering, ReverseOrdering
<span class="pl-k">struct</span> FastForwardOrdering <span class="pl-k">&lt;:</span> <span class="pl-c1">Ordering</span> <span class="pl-k">end</span>
<span class="pl-k">const</span> FastForward <span class="pl-k">=</span> <span class="pl-c1">FastForwardOrdering</span>()
<span class="pl-k">const</span> FastReverse <span class="pl-k">=</span> <span class="pl-c1">ReverseOrdering</span>(FastForward)

<span class="pl-k">import</span> Base<span class="pl-k">:</span> lt
<span class="pl-en">lt</span>(<span class="pl-k">::</span><span class="pl-c1">FastForwardOrdering</span>, a, b) <span class="pl-k">=</span> a <span class="pl-k">&lt;</span> b</pre></div>
<p dir="auto">Then just use keyword <code>order=FastForward</code> or <code>order=FastReverse</code> in calls to
sort methods to benefit from a speed-up factor between 2 or 3.  Almost for free!
The very same trick has been implemented in the
<a href="https://github.com/JuliaCollections/DataStructures.jl"><code>DataStructures</code></a>
package with <code>DataStructures.FasterForward()</code> and
<code>DataStructures.FasterReverse()</code>.</p>
<p dir="auto">Checking that an array has NaN's can be checked in linear time, that is <code>O(n)</code>,
for arrays of <code>n</code> floating-point values by the following method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function has_nans(A::AbstractArray{&lt;:AbstractFloat})
    flag = false
    @inbounds @simd for i in eachindex(A)
        flag |= isnan(A[i])
    end
    return flag
end"><pre><span class="pl-k">function</span> <span class="pl-en">has_nans</span>(A<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:AbstractFloat}</span>)
    flag <span class="pl-k">=</span> <span class="pl-c1">false</span>
    <span class="pl-c1">@inbounds</span> <span class="pl-c1">@simd</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(A)
        flag <span class="pl-k">|=</span> <span class="pl-c1">isnan</span>(A[i])
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> flag
<span class="pl-k">end</span></pre></div>
<p dir="auto">where short-circuit has been purposely avoided to exploit SIMD optimization.
The rationale is that if you are mostly interested in arrays with no NaN's, you
expect that the entire array be checked.  A simple benchmark follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using BenchmarkTools
x = rand(1000);
@btime has_nans($x) # ----&gt; 119.054 ns (0 allocations: 0 bytes)"><pre><span class="pl-k">using</span> BenchmarkTools
x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1000</span>);
<span class="pl-c1">@btime</span> <span class="pl-c1">has_nans</span>(<span class="pl-k">$</span>x) <span class="pl-c"><span class="pl-c">#</span> ----&gt; 119.054 ns (0 allocations: 0 bytes)</span></pre></div>
<p dir="auto">which is much shorter than the time it takes to heapify the array.  This test
could be applied to arrays of floating-point values to choose between fast/slow
ordering.  This would not change the behavior of the sorting methods but would
significantly reduce the execution time most of the time.</p>
<p dir="auto">For integer-valued arrays, it takes <code>O(1)</code> time to check for NaN's:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="has_nans(A::AbstractArray{&lt;:Integer}) = false"><pre><span class="pl-en">has_nans</span>(A<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Integer}</span>) <span class="pl-k">=</span> <span class="pl-c1">false</span></pre></div>
<p dir="auto">An additional speed-up by a factor between 1.5 and 2 is achievable by proper use
of <code>@inline</code>, <code>@inbounds</code> and <code>@propagate_inbounds</code> macros in the code
implementing the sorting algorithms.  This however requires to modify existing
code.  This is what is done in
<a href="https://github.com/emmt/QuickHeaps.jl"><code>QuickHeaps</code></a>.</p>
<h3 dir="auto"><a id="user-content-application-to-binary-heaps" class="anchor" aria-hidden="true" href="#application-to-binary-heaps"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Application to binary heaps</h3>
<p dir="auto">As an illustration of the above discussion, below is the output of a small
benchmark ran by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia --project test/benchmarks.jl"><pre>julia <span class="pl-k">--</span>project test<span class="pl-k">/</span>benchmarks<span class="pl-k">.</span>jl</pre></div>
<p dir="auto">with Julia 1.6.3 on an AMD Ryzen Threadripper 2950X 16-Core Processor:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Timings for &quot;DataStructures&quot; methods (T=Float64, n=1000):
 - DataStructures.heapify!(..., Base.Forward) ---------------------&gt; 7.478 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., Base.Reverse) ---------------------&gt; 7.268 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., DataStructures.FasterForward()) ---&gt; 3.444 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., DataStructures.FasterReverse()) ---&gt; 3.428 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., QuickHeaps.FastMin) ---------------&gt; 3.413 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., QuickHeaps.FastMax) ---------------&gt; 3.428 μs (0 allocations: 0 bytes)

Timings for &quot;QuickHeaps&quot; methods (T=Float64, n=1000):
 - QuickHeaps.heapify!(..., Base.Forward) -------------------------&gt; 4.852 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., Base.Reverse) -------------------------&gt; 4.506 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., DataStructures.FasterForward()) -------&gt; 1.655 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., DataStructures.FasterReverse()) -------&gt; 1.658 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., QuickHeaps.FastMin) -------------------&gt; 1.637 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., QuickHeaps.FastMax) -------------------&gt; 1.658 μs (0 allocations: 0 bytes)

Timings for &quot;DataStructures&quot; methods (T=Float64, n=1000):
 - DataStructures.isheap(..., Base.Forward) -----------------------&gt; 1.910 μs (0 allocations: 0 bytes)
 - DataStructures.isheap(..., Base.Reverse) -----------------------&gt; 1.932 μs (0 allocations: 0 bytes)
 - DataStructures.isheap(..., DataStructures.FasterForward()) -----&gt; 563.027 ns (0 allocations: 0 bytes)
 - DataStructures.isheap(..., DataStructures.FasterReverse()) -----&gt; 575.110 ns (0 allocations: 0 bytes)
 - DataStructures.isheap(..., QuickHeaps.FastMin) -----------------&gt; 575.087 ns (0 allocations: 0 bytes)
 - DataStructures.isheap(..., QuickHeaps.FastMax) -----------------&gt; 573.750 ns (0 allocations: 0 bytes)

Timings for &quot;QuickHeaps&quot; methods (T=Float64, n=1000):
 - QuickHeaps.isheap(..., Base.Forward) ---------------------------&gt; 1.820 μs (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., Base.Reverse) ---------------------------&gt; 1.821 μs (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., DataStructures.FasterForward()) ---------&gt; 381.527 ns (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., DataStructures.FasterReverse()) ---------&gt; 383.847 ns (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., QuickHeaps.FastMin) ---------------------&gt; 378.627 ns (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., QuickHeaps.FastMax) ---------------------&gt; 384.631 ns (0 allocations: 0 bytes)"><pre class="notranslate"><code>Timings for "DataStructures" methods (T=Float64, n=1000):
 - DataStructures.heapify!(..., Base.Forward) ---------------------&gt; 7.478 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., Base.Reverse) ---------------------&gt; 7.268 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., DataStructures.FasterForward()) ---&gt; 3.444 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., DataStructures.FasterReverse()) ---&gt; 3.428 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., QuickHeaps.FastMin) ---------------&gt; 3.413 μs (0 allocations: 0 bytes)
 - DataStructures.heapify!(..., QuickHeaps.FastMax) ---------------&gt; 3.428 μs (0 allocations: 0 bytes)

Timings for "QuickHeaps" methods (T=Float64, n=1000):
 - QuickHeaps.heapify!(..., Base.Forward) -------------------------&gt; 4.852 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., Base.Reverse) -------------------------&gt; 4.506 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., DataStructures.FasterForward()) -------&gt; 1.655 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., DataStructures.FasterReverse()) -------&gt; 1.658 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., QuickHeaps.FastMin) -------------------&gt; 1.637 μs (0 allocations: 0 bytes)
 - QuickHeaps.heapify!(..., QuickHeaps.FastMax) -------------------&gt; 1.658 μs (0 allocations: 0 bytes)

Timings for "DataStructures" methods (T=Float64, n=1000):
 - DataStructures.isheap(..., Base.Forward) -----------------------&gt; 1.910 μs (0 allocations: 0 bytes)
 - DataStructures.isheap(..., Base.Reverse) -----------------------&gt; 1.932 μs (0 allocations: 0 bytes)
 - DataStructures.isheap(..., DataStructures.FasterForward()) -----&gt; 563.027 ns (0 allocations: 0 bytes)
 - DataStructures.isheap(..., DataStructures.FasterReverse()) -----&gt; 575.110 ns (0 allocations: 0 bytes)
 - DataStructures.isheap(..., QuickHeaps.FastMin) -----------------&gt; 575.087 ns (0 allocations: 0 bytes)
 - DataStructures.isheap(..., QuickHeaps.FastMax) -----------------&gt; 573.750 ns (0 allocations: 0 bytes)

Timings for "QuickHeaps" methods (T=Float64, n=1000):
 - QuickHeaps.isheap(..., Base.Forward) ---------------------------&gt; 1.820 μs (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., Base.Reverse) ---------------------------&gt; 1.821 μs (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., DataStructures.FasterForward()) ---------&gt; 381.527 ns (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., DataStructures.FasterReverse()) ---------&gt; 383.847 ns (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., QuickHeaps.FastMin) ---------------------&gt; 378.627 ns (0 allocations: 0 bytes)
 - QuickHeaps.isheap(..., QuickHeaps.FastMax) ---------------------&gt; 384.631 ns (0 allocations: 0 bytes)
</code></pre></div>
<p dir="auto">These timings show the gain in speed for <code>heapify!</code> by using <code>&lt;</code> instead of
<code>isless</code> by a factor of 2.3 for the binary heap implemented by <code>DataStructures</code>
and by a factor of 3.2 for the binary heap implemented by <code>QuickHeaps</code>.</p>
<p dir="auto">These timings also show that <code>heapify!</code> in <code>QuickHeaps</code> is faster than in
<code>DataStructures</code> by a factor greater than 1.5 with standard orderings and by a
factor better than 2 with faster orderings.</p>
</article></div>