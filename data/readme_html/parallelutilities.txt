<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-parallelutilitiesjl" class="anchor" aria-hidden="true" href="#parallelutilitiesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ParallelUtilities.jl</h1>
<p><a href="https://travis-ci.com/jishnub/ParallelUtilities.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/0d858c33e635384d862336ab734278807164bd04/68747470733a2f2f7472617669732d63692e636f6d2f6a6973686e75622f506172616c6c656c5574696c69746965732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jishnub/ParallelUtilities.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/jishnub/ParallelUtilities.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/8d663f1fc1c8967d89b365cbf0ccdd874c2e2268/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6a6973686e75622f506172616c6c656c5574696c69746965732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/jishnub/ParallelUtilities.jl/badge.svg?branch=master" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/jishnub/ParallelUtilities.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f2c47c70ad87ef4d9e593e3f54650d4d74d2dd9d/68747470733a2f2f636f6465636f762e696f2f67682f6a6973686e75622f506172616c6c656c5574696c69746965732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/jishnub/ParallelUtilities.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>Parallel mapreduce and other helpful functions for HPC, meant primarily for embarassingly parallel operations that often require one to split up a list of tasks into subsections that can be processed on individual cores.</p>
<h1><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h1>
<p>Install the package using</p>
<div class="highlight highlight-source-julia"><pre>pkg<span class="pl-k">&gt;</span> add ParallelUtilities
julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> ParallelUtilities </pre></div>
<h1><a id="user-content-exported-functions" class="anchor" aria-hidden="true" href="#exported-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Exported functions</h1>
<ul>
<li><code>pmap</code>-related functions
<ul>
<li><code>pmapreduce</code></li>
<li><code>pmapreduce_commutative</code></li>
<li><code>pmapsum</code></li>
<li><code>pmapreduce_elementwise</code></li>
<li><code>pmapsum_elementwise</code></li>
</ul>
</li>
<li>Functions to evenly split a Tuple of ranges
<ul>
<li><code>ProductSplit</code></li>
<li><code>ntasks</code></li>
<li><code>whichproc</code></li>
<li><code>procrange_recast</code></li>
<li><code>localindex</code></li>
<li><code>whichproc_localindex</code></li>
<li><code>extremadims</code></li>
<li><code>extrema_commonlastdim</code></li>
</ul>
</li>
<li>Utility functions to query the cluster
<ul>
<li><code>gethostnames</code></li>
<li><code>nodenames</code></li>
<li><code>nprocs_node</code></li>
</ul>
</li>
</ul>
<h1><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Quick start</h1>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">addprocs</span>(<span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2</span>
 <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@everywhere</span> <span class="pl-k">using</span> ParallelUtilities

julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapreduce</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),x<span class="pl-k">-&gt;</span><span class="pl-c1">hcat</span>(x<span class="pl-k">...</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Float64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2.0</span>  <span class="pl-c1">3.0</span>
 <span class="pl-c1">2.0</span>  <span class="pl-c1">3.0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapreduce_commutative</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),sum,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">5.0</span>
 <span class="pl-c1">5.0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapsum</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">5.0</span>
 <span class="pl-c1">5.0</span></pre></div>
<h1><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h1>
<p>The package splits up a collection of ranges into subparts of roughly equal length, so that all the cores are approximately equally loaded. This is best understood using an example: let's say that we have a function <code>f</code> that is defined as</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@everywhere</span> <span class="pl-k">begin</span> 
       <span class="pl-en">f</span>(x,y,z) <span class="pl-k">=</span> x<span class="pl-k">+</span>y<span class="pl-k">+</span>z
       <span class="pl-k">end</span></pre></div>
<p>where each parameter takes up values in a range, and we would like to sample the entire parameter space. As an example, we choose the ranges to be</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> xrange,yrange,zrange <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>,<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">4</span>,<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span> ranges should be strictly increasing</span></pre></div>
<p>There are a total of 36 possible <code>(x,y,z)</code> combinations possible given these ranges. Let's say that we would like to split the evaluation of the function over 10 processors. We describe the simple way to evaluate this and then explain how this is achieved.</p>
<p>The set of parameters may be split up using the function <code>ProductSplit</code>. In this example each of the 10 processors receive a chunk as listed below</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> [<span class="pl-c1">collect</span>(<span class="pl-c1">ProductSplit</span>((xrange,yrange,zrange),<span class="pl-c1">10</span>,i)) <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>]
<span class="pl-c1">10</span><span class="pl-k">-</span>element Array{Array{Tuple{Int64,Int64,Int64},<span class="pl-c1">1</span>},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 [(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>)]
 [(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">4</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">3</span>)]
 [(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>)]
 [(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>)]
 [(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">5</span>)]
 [(<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>)]
 [(<span class="pl-c1">1</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>)]           
 [(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">6</span>)]           
 [(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">6</span>)]           
 [(<span class="pl-c1">1</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>)] </pre></div>
<p>The first six processors receive 4 tuples of parameters each and the final four receive 3 each. This is the splitting used by the various functions described next.</p>
<h2><a id="user-content-pmap-related-functions" class="anchor" aria-hidden="true" href="#pmap-related-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>pmap-related functions</h2>
<p>The package provides versions of <code>pmap</code> with an optional reduction. These differ from the one provided by <code>Distributed</code> in a few key aspects: firstly, the iterator product of the argument is what is passed to the function and not the arguments by elementwise, so the i-th task will be <code>Iterators.product(args...)[i]</code> and not <code>[x[i] for x in args]</code>. Specifically the second set of parameters in the example above will be <code>(2,2,3)</code> and not <code>(2,3,4)</code>.</p>
<p>Secondly, the iterator is passed to the function in batches and not elementwise, and it is left to the function to iterate over the collection. Thirdly, the tasks are passed on to processors sorted by rank, so the first task is passed to the first processor and the last to the last active worker. The tasks are also approximately evenly distributed across processors. The function <code>pmapbatch_elementwise</code> is also exported that passes the elements to the function one-by-one as unwrapped tuples. This produces the same result as <code>pmap</code> where each worker is assigned batches of approximately equal sizes taken from the iterator product.</p>
<h3><a id="user-content-pmapbatch-and-pmapbatch_elementwise" class="anchor" aria-hidden="true" href="#pmapbatch-and-pmapbatch_elementwise"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>pmapbatch and pmapbatch_elementwise</h3>
<p>As an example we demonstrate how to evaluate the function <code>f</code> for the ranges of parameters listed above:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> p <span class="pl-k">=</span> <span class="pl-c1">pmapbatch_elementwise</span>(f,(xrange,yrange,zrange));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Tuple</span>(p)
(<span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">13</span>)

<span class="pl-c"><span class="pl-c">#</span> Check for correctness</span>
julia<span class="pl-k">&gt;</span> p <span class="pl-k">==</span> <span class="pl-c1">map</span>(f,<span class="pl-c1">vec</span>(<span class="pl-c1">collect</span>(Iterators<span class="pl-k">.</span><span class="pl-c1">product</span>(xrange,yrange,zrange))))
<span class="pl-c1">true</span>

<span class="pl-c"><span class="pl-c">#</span> pmapbatch_elementwise produces the same result as pmap, although the internals are different</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapbatch_elementwise</span>(x<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>
 <span class="pl-c1">4</span>
 <span class="pl-c1">9</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmap</span>(x<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>
 <span class="pl-c1">4</span>
 <span class="pl-c1">9</span></pre></div>
<p>There is also a function <code>pmapbatch</code> that deals with batches of parameters that are passed to each processor, and <code>pmap_elementwise</code> calls this function under the hood to process the parameters one by one. We may use this directly as well if we need the entire batch for some reason (eg. reading values off a disk, which needs to be done once for the entire set and not for every parameter). As an example we demonstrate how to obtain the same result as above using <code>pmapbatch</code>:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> p <span class="pl-k">=</span> <span class="pl-c1">pmapbatch</span>(x<span class="pl-k">-&gt;</span>[<span class="pl-c1">f</span>(i<span class="pl-k">...</span>) <span class="pl-k">for</span> i <span class="pl-k">in</span> x],(xrange,yrange,zrange));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Tuple</span>(p)
(<span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">13</span>)</pre></div>
<h3><a id="user-content-pmapsum-and-pmapreduce" class="anchor" aria-hidden="true" href="#pmapsum-and-pmapreduce"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>pmapsum and pmapreduce</h3>
<p>Often a parallel execution is followed by a reduction (eg. a sum over the results). A reduction may be commutative (in which case the order of results do not matter), or non-commutative (in which the order does matter). There are two functions that are exported that carry out these tasks: <code>pmapreduce_commutative</code> and <code>pmapreduce</code>, where the former does not preserve ordering and the latter does. For convenience, the package also provides the function <code>pmapsum</code> that chooses <code>sum</code> as the reduction operator. The map-reduce operation is similar in many ways to the distributed <code>for</code> loop provided by julia, but the main difference is that the reduction operation is not binary for the functions in this package (eg. we need <code>sum</code> and not <code>(+)</code>to add the results). There is also the difference as above that the function gets the parameters in batches, with functions having the suffix <code>_elementwise</code> taking on parameters individually as unwrapped tuples as above. The function <code>pmapreduce</code> does not take on parameters elementwise at this point, although this might be implemented in the future.</p>
<p>As an example, to sum up a list of numbers in parallel we may call</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapsum_elementwise</span>(identity,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1000</span>)
<span class="pl-c1">500500</span></pre></div>
<p>Here the mapped function is taken to by <code>identity</code> which just returns its argument. To sum the squares of the numbers in a list we may use</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapsum_elementwise</span>(x<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1000</span>)
<span class="pl-c1">333833500</span></pre></div>
<p>We may choose an arbitrary reduction operator in the function <code>pmapreduce</code> and <code>pmapreduce_commutative</code>, and the elementwise function <code>pmapreduce_commutative_elementwise</code>. The reductions are carried out as a binary tree across all workers.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Compute 1^2 * 2^2 * 3^2 in parallel</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapreduce_commutative_elementwise</span>(x<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>,prod,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)
<span class="pl-c1">36</span></pre></div>
<p>The function <code>pmapreduce</code> sorts the results obtained from each processor, so it is useful for concatenations.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">workers</span>()
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2</span>
 <span class="pl-c1">3</span>

<span class="pl-c"><span class="pl-c">#</span> The signature is pmapreduce(fmap,freduce,iterable)</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapreduce</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),x<span class="pl-k">-&gt;</span><span class="pl-c1">hcat</span>(x<span class="pl-k">...</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Float64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2.0</span>  <span class="pl-c1">3.0</span>
 <span class="pl-c1">2.0</span>  <span class="pl-c1">3.0</span></pre></div>
<p>The functions <code>pmapreduce</code> produces the same result as <code>pmapreduce_commutative</code> if the reduction operator is commutative (ie. the order of results received from the children workers does not matter).</p>
<p>The function <code>pmapsum</code> sets the reduction operator to be a sum.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(<span class="pl-c1">workers</span>())
<span class="pl-c1">5</span>

<span class="pl-c"><span class="pl-c">#</span> We compute ones(2).*sum(workers()) in parallel</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapsum</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">5.0</span>
 <span class="pl-c1">5.0</span></pre></div>
<p>It is possible to specify the return types of the map and reduce operations in these functions. To specify the return types use the following variants:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Signature is pmapreduce(fmap,Tmap,freduce,Treduce,iterators)</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapreduce</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),Vector{Float64},x<span class="pl-k">-&gt;</span><span class="pl-c1">hcat</span>(x<span class="pl-k">...</span>),Matrix{Float64},<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Float64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2.0</span>  <span class="pl-c1">3.0</span>
 <span class="pl-c1">2.0</span>  <span class="pl-c1">3.0</span>

<span class="pl-c"><span class="pl-c">#</span> Signature is pmapsum(fmap,Tmap,iterators)</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapsum</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),Vector{Float64},<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">5.0</span>
 <span class="pl-c1">5.0</span></pre></div>
<p>Specifying the types would lead to a type coercion if possible, or an error if a conversion is not possible. This might help in asserting the correctness of the result obtained. For example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> The result is converted from Vector{Float64} to Vector{Int}. </span>
<span class="pl-c"><span class="pl-c">#</span> Conversion works as the numbers are integers</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapsum</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">ones</span>(<span class="pl-c1">2</span>)<span class="pl-k">.*</span><span class="pl-c1">myid</span>(),Vector{Int},<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">5</span>
 <span class="pl-c1">5</span>

<span class="pl-c"><span class="pl-c">#</span> Conversion fails here as the numbers aren't integers</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapsum</span>(x<span class="pl-k">-&gt;</span><span class="pl-c1">rand</span>(<span class="pl-c1">2</span>),Vector{Int},<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>())
ERROR<span class="pl-k">:</span> On worker <span class="pl-c1">2</span><span class="pl-k">:</span>
InexactError<span class="pl-k">:</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">0.7742577217010362</span>)</pre></div>
<h3><a id="user-content-progress-bar" class="anchor" aria-hidden="true" href="#progress-bar"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Progress bar</h3>
<p>The progress of the map-reduce operation might be tracked by setting the keyword argument <code>showprogress</code> to true. This might be useful in case certain workers have a heavier load than others.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Running on 8 workers, artificially induce load using sleep</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapreduce</span>(x<span class="pl-k">-&gt;</span>(<span class="pl-c1">sleep</span>(<span class="pl-c1">myid</span>());<span class="pl-c1">myid</span>()),x<span class="pl-k">-&gt;</span><span class="pl-c1">hcat</span>(x<span class="pl-k">...</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>(),showprogress<span class="pl-k">=</span><span class="pl-c1">true</span>)
Progress <span class="pl-k">in</span> pmapreduce : <span class="pl-c1">100</span><span class="pl-k">%</span><span class="pl-k">|</span>██████████████████████████████████████████████████<span class="pl-k">|</span> Time<span class="pl-k">:</span> <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">00</span><span class="pl-k">:</span><span class="pl-c1">09</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">8</span> Array{Int64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">3</span>  <span class="pl-c1">4</span>  <span class="pl-c1">5</span>  <span class="pl-c1">6</span>  <span class="pl-c1">7</span>  <span class="pl-c1">8</span>  <span class="pl-c1">9</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">pmapreduce</span>(x<span class="pl-k">-&gt;</span>(<span class="pl-c1">sleep</span>(<span class="pl-c1">myid</span>());<span class="pl-c1">myid</span>()),x<span class="pl-k">-&gt;</span><span class="pl-c1">hcat</span>(x<span class="pl-k">...</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">nworkers</span>(),showprogress<span class="pl-k">=</span><span class="pl-c1">true</span>,progressdesc<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Progress : <span class="pl-pds">"</span></span>)
Progress : <span class="pl-c1">100</span><span class="pl-k">%</span><span class="pl-k">|</span>████████████████████████████████████████████████████████████████<span class="pl-k">|</span> Time<span class="pl-k">:</span> <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">00</span><span class="pl-k">:</span><span class="pl-c1">09</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">8</span> Array{Int64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">3</span>  <span class="pl-c1">4</span>  <span class="pl-c1">5</span>  <span class="pl-c1">6</span>  <span class="pl-c1">7</span>  <span class="pl-c1">8</span>  <span class="pl-c1">9</span></pre></div>
<p>Note that this does not track the progress of the individual maps, it merely tracks how many are completed. The progress of the individual maps may be tracked by explicitly passing a <code>RemoteChannel</code> to the mapping function and pushing the progress status to it from the workers.</p>
<h3><a id="user-content-why-two-mapreduce-functions" class="anchor" aria-hidden="true" href="#why-two-mapreduce-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why two mapreduce functions?</h3>
<p>The two separate functions <code>pmapreduce</code> and <code>pmapreduce_commutative</code> exist for historical reasons. They use different binary tree structures for reduction. The commutative one might be removed in the future in favour of <code>pmapreduce</code>.</p>
<h2><a id="user-content-productsplit" class="anchor" aria-hidden="true" href="#productsplit"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ProductSplit</h2>
<p>In the above examples we have talked about the tasks being distributed approximately equally among the workers without going into details about the distribution, which is what we describe here. The package provides an iterator <code>ProductSplit</code> that lists that ranges of parameters that would be passed on to each core. This may equivalently be achieved using an</p>
<p><code>Iterators.Take{Iterators.Drop{Iterators.ProductIterator}}</code></p>
<p>with appropriately chosen parameters, and in many ways a <code>ProductSplit</code> behaves similarly. However a <code>ProductSplit</code> supports several extra features such as <code>O(1)</code> indexing, which eliminates the need to actually iterate over it in many scenarios.</p>
<p>The signature of the constructor is</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">ProductSplit</span>(tuple_of_ranges,number_of_processors,processor_rank)</pre></div>
<p>where <code>processor_rank</code> takes up values in <code>1:number_of_processors</code>. Note that this is different from MPI where the rank starts from 0. For example, we check the tasks that are passed on to the processor number 4:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> ps <span class="pl-k">=</span> <span class="pl-c1">ProductSplit</span>((xrange,yrange,zrange),<span class="pl-c1">10</span>,<span class="pl-c1">4</span>)
<span class="pl-c1">ProductSplit</span><span class="pl-c1">{Tuple{Int64,Int64,Int64},3,UnitRange{Int64}}</span>((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>, <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">4</span>, <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">5</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">9</span>), <span class="pl-c1">10</span>, <span class="pl-c1">4</span>, <span class="pl-c1">10</span>, <span class="pl-c1">12</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(ps)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Array{Tuple{Int64,Int64,Int64},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 (<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)
 (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)
 (<span class="pl-c1">1</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>)</pre></div>
<p>where the object loops over values of <code>(x,y,z)</code>, and the values are sorted in reverse lexicographic order (the last index increases the slowest while the first index increases the fastest). The ranges roll over as expected. The tasks are evenly distributed with the remainders being split among the first few processors. In this example the first six processors receive 4 tasks each and the last four receive 3 each. We can see this by evaluating the length of the <code>ProductSplit</code> operator on each processor</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Tuple</span>(<span class="pl-c1">length</span>(<span class="pl-c1">ProductSplit</span>((xrange,yrange,zrange),<span class="pl-c1">10</span>,i)) <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>)
(<span class="pl-c1">4</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>)</pre></div>
<h3><a id="user-content-indexing" class="anchor" aria-hidden="true" href="#indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Indexing</h3>
<p>The iterator supports fast indexing</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> ps[<span class="pl-c1">3</span>]
(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>ps[<span class="pl-c1">3</span>]
  <span class="pl-c1">9.493</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)</pre></div>
<p>This is useful if we have a large number of parameters to analyze on each processor.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> xrange_long,yrange_long,zrange_long <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>
(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>)

julia<span class="pl-k">&gt;</span> params_long <span class="pl-k">=</span> (xrange_long,yrange_long,zrange_long);

julia<span class="pl-k">&gt;</span> ps_long <span class="pl-k">=</span> <span class="pl-c1">ProductSplit</span>(params_long,<span class="pl-c1">10</span>,<span class="pl-c1">4</span>)
<span class="pl-c1">ProductSplit</span><span class="pl-c1">{Tuple{Int64,Int64,Int64},3,UnitRange{Int64}}</span>((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3000</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">3000</span>, <span class="pl-c1">9000000</span>), <span class="pl-c1">10</span>, <span class="pl-c1">4</span>, <span class="pl-c1">8100000001</span>, <span class="pl-c1">10800000000</span>)

<span class="pl-c"><span class="pl-c">#</span> Evaluate length using random ranges to avoid compiler optimizations</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">length</span>(p) setup<span class="pl-k">=</span>(n<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3000</span><span class="pl-k">:</span><span class="pl-c1">4000</span>);p<span class="pl-k">=</span><span class="pl-c1">ProductSplit</span>((<span class="pl-c1">1</span><span class="pl-k">:</span>n,<span class="pl-c1">1</span><span class="pl-k">:</span>n,<span class="pl-c1">1</span><span class="pl-k">:</span>n),<span class="pl-c1">200</span>,<span class="pl-c1">2</span>));
  <span class="pl-c1">2.674</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>ps_long[<span class="pl-c1">1000000</span>] <span class="pl-c"><span class="pl-c">#</span> also fast, does not iterate</span>
  <span class="pl-c1">32.530</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">1000</span>, <span class="pl-c1">334</span>, <span class="pl-c1">901</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">first</span>(<span class="pl-k">$</span>ps_long)
  <span class="pl-c1">31.854</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">901</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">last</span>(<span class="pl-k">$</span>ps_long)
  <span class="pl-c1">31.603</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">3000</span>, <span class="pl-c1">3000</span>, <span class="pl-c1">1200</span>)</pre></div>
<p>We may evaluate whether or not a value exists in the list and its index in <code>O(1)</code> time.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> val <span class="pl-k">=</span> (<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>)
(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)

julia<span class="pl-k">&gt;</span> val <span class="pl-k">in</span> ps
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">localindex</span>(ps,val)
<span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> val<span class="pl-k">=</span>(<span class="pl-c1">10</span>,<span class="pl-c1">2</span>,<span class="pl-c1">901</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>val <span class="pl-k">in</span> <span class="pl-k">$</span>ps_long
  <span class="pl-c1">50.183</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">localindex</span>(<span class="pl-k">$</span>ps_long, <span class="pl-k">$</span>val)
  <span class="pl-c1">104.513</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">3010</span></pre></div>
<p>Another useful function is <code>whichproc</code> that returns the rank of the processor a specific set of parameters will be on, given the total number of processors. This is also computed using a binary search.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">whichproc</span>(params_long,val,<span class="pl-c1">10</span>)
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">whichproc</span>(<span class="pl-k">$</span>params_long,<span class="pl-k">$</span>val,<span class="pl-c1">10</span>)
  <span class="pl-c1">1.264</span> μs (<span class="pl-c1">14</span> allocations<span class="pl-k">:</span> <span class="pl-c1">448</span> bytes)
<span class="pl-c1">4</span></pre></div>
<h3><a id="user-content-extrema" class="anchor" aria-hidden="true" href="#extrema"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Extrema</h3>
<p>We can compute the ranges of each variable on any processor in <code>O(1)</code> time.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">extrema</span>(ps,dim<span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> extrema of the second parameter on this processor</span>
(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Tuple</span>(<span class="pl-c1">extrema</span>(ps,dim<span class="pl-k">=</span>i) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)
((<span class="pl-c1">1</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">4</span>))

<span class="pl-c"><span class="pl-c">#</span> Minimum and maximum work similarly</span>

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">minimum</span>(ps,dim<span class="pl-k">=</span><span class="pl-c1">2</span>),<span class="pl-c1">maximum</span>(ps,dim<span class="pl-k">=</span><span class="pl-c1">2</span>))
(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">extrema</span>(<span class="pl-k">$</span>ps_long,dim<span class="pl-k">=</span><span class="pl-c1">2</span>)
  <span class="pl-c1">52.813</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">1</span>, <span class="pl-c1">3000</span>)</pre></div>
</article></div>