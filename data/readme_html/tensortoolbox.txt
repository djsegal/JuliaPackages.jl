<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-tensortoolboxjl" class="anchor" aria-hidden="true" href="#tensortoolboxjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TensorToolbox.jl</h1>
<p><a href="https://travis-ci.org/lanaperisa/TensorToolbox.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ed15a1beac341d470e0c992464863bdaf92fd26fe274a212f6d859d8bb08c134/68747470733a2f2f7472617669732d63692e6f72672f6c616e617065726973612f54656e736f72546f6f6c626f782e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/lanaperisa/TensorToolbox.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p><a href="https://zenodo.org/badge/latestdoi/92327488" rel="nofollow"><img src="https://camo.githubusercontent.com/224ad287c57b7bfc2977c8c100c909444fd2561b8167c42dadb236d5dafa0830/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f39323332373438382e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/92327488.svg" style="max-width:100%;"></a></p>
<p>Julia package for tensors. Includes functionality for</p>
<ul>
<li>dense tensors,</li>
<li>tensors in Tucker format,</li>
<li>tensors in Kruskal (CP) format,</li>
<li>tensors in Hierarchical Tucker format,</li>
<li>tensors in Tensor Train format (work in progress).</li>
</ul>
<p>Follows the functionality of MATLAB <a href="http://www.sandia.gov/~tgkolda/TensorToolbox/index-2.6.html" rel="nofollow">Tensor toolbox</a> and <a href="https://anchp.epfl.ch/htucker" rel="nofollow">Hierarchical Tucker Toolbox</a>.</p>
<p>Additionally, it contains algorithms from the paper <a href="http://sma.epfl.ch/~anchpcommon/publications/ttensors_pp.pdf" rel="nofollow">Recompression of Hadamard Products
of Tensors in Tucker Format</a> by D. Kressner and L. Peri≈°a.</p>
<h2><a id="user-content-basics" class="anchor" aria-hidden="true" href="#basics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basics</h2>
<p>Start with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using TensorToolbox
"><pre><span class="pl-k">using</span> TensorToolbox</pre></div>
<p>Define tensor as multidimensional array and calculate its norm:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(4,3,2)
norm(X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)
<span class="pl-c1">norm</span>(X)</pre></div>
<p>Create identity and diagonal tensor:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Id=neye(2,2,2)
D=diagt([1,2,3,4])
"><pre>Id<span class="pl-k">=</span><span class="pl-c1">neye</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)
D<span class="pl-k">=</span><span class="pl-c1">diagt</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>])</pre></div>
<p>For two tensors of same size calculate their inner product:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(3,3,3,3);Y=rand(3,3,3,3);
innerprod(X,Y)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>);Y<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>);
<span class="pl-c1">innerprod</span>(X,Y)</pre></div>
<p><em>Matricization</em> of a tensor:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(4,3,2);n=1; 
A=tenmat(X,n) #by mode n
B=tenmat(X,row=[2,1],col=3) #by row modes [2,1] and column mode 3
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>);n<span class="pl-k">=</span><span class="pl-c1">1</span>; 
A<span class="pl-k">=</span><span class="pl-c1">tenmat</span>(X,n) <span class="pl-c"><span class="pl-c">#</span>by mode n</span>
B<span class="pl-k">=</span><span class="pl-c1">tenmat</span>(X,row<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>],col<span class="pl-k">=</span><span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span>by row modes [2,1] and column mode 3</span></pre></div>
<p>Fold matrix back to tensor:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=matten(A,n,[4,3,2]) # by mode n
X=matten(B,[2,1],[3],[4,3,2]) # by row modes [2,1] and column mode 3
"><pre>X<span class="pl-k">=</span><span class="pl-c1">matten</span>(A,n,[<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span> by mode n</span>
X<span class="pl-k">=</span><span class="pl-c1">matten</span>(B,[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>],[<span class="pl-c1">3</span>],[<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span> by row modes [2,1] and column mode 3</span></pre></div>
<p><em>n-mode product</em> of a tensor and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(5,4,3);
A=[rand(2,5),rand(2,4),rand(2,3)];
ttm(X,A[1],1)  #X times A[1] by mode 1
ttm(X,[A[1],A[2]],[1,2]) #X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)
ttm(X,A) #X times matrices from A by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(5,4,3);
V=[rand(5),rand(4),rand(3)];
ttv(X,V[1],1)  #X times V[1] by mode 1
ttv(X,[V[1],V[2]],[1,2]) #X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)
ttv(X,V) #X times vectors from V by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p><em>Outer product</em> of two tensors:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content=" X=rand(5,4,3,2);Y=rand(2,3,4);
 ttt(X,Y)
"><pre> X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>);Y<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>);
 <span class="pl-c1">ttt</span>(X,Y)</pre></div>
<p>Kronecker product of two tensors (straightforward generalization of Kronecker product of matrices):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(5,4,3);Y=rand(2,2,2);
tkron(X,Y)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);Y<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>);
<span class="pl-c1">tkron</span>(X,Y)</pre></div>
<p>The <em>n-rank</em> and the <em>mutlilinear rank</em> of a tensor:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(5,4,3);
n=2;
nrank(X,n)
mrank(X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
n<span class="pl-k">=</span><span class="pl-c1">2</span>;
<span class="pl-c1">nrank</span>(X,n)
<span class="pl-c1">mrank</span>(X)</pre></div>
<p>The HOSVD:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(5,4,3);
hosvd(X) #same as hosvd(X,eps_abs=1e-8)
hosvd(X,eps_abs=1e-6) #discard singular values lower than 1e-5
hosvd(X,eps_rel=1e-3) #discard singular values lower than 1e-3*sigma_{max}
hosvd(X,reqrank=[2,2,2])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
<span class="pl-c1">hosvd</span>(X) <span class="pl-c"><span class="pl-c">#</span>same as hosvd(X,eps_abs=1e-8)</span>
<span class="pl-c1">hosvd</span>(X,eps_abs<span class="pl-k">=</span><span class="pl-c1">1e-6</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-5</span>
<span class="pl-c1">hosvd</span>(X,eps_rel<span class="pl-k">=</span><span class="pl-c1">1e-3</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-3*sigma_{max}</span>
<span class="pl-c1">hosvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>The CP decomposition:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(5,4,3);
R=3; #number of components
cp_als(X,R)  #same as cp_als(X,R,init=&quot;rand&quot;,dimorder=1:ndims(X))
cp_als(X,R,init=[rand(5,3),rand(4,3),rand(3,3)]) #initialize factor matrices 
cp_als(X,R,init=&quot;nvecs&quot;,dimorder=[2,1,3])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
R<span class="pl-k">=</span><span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span>number of components</span>
<span class="pl-c1">cp_als</span>(X,R)  <span class="pl-c"><span class="pl-c">#</span>same as cp_als(X,R,init="rand",dimorder=1:ndims(X))</span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)]) <span class="pl-c"><span class="pl-c">#</span>initialize factor matrices </span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>nvecs<span class="pl-pds">"</span></span>,dimorder<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>])</pre></div>
<h2><a id="user-content-tensors-in-tucker-format" class="anchor" aria-hidden="true" href="#tensors-in-tucker-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Tucker format</h2>
<p>Define tensor in Tucker format by its core tensor and factor matrices:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="F=rand(5,4,3);
A=[rand(6,5),rand(6,4),rand(6,3)];
ttensor(F,A)
"><pre>F<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttensor</span>(F,A)</pre></div>
<p>Get Tucker format of a tensor by using HOSVD:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(8,9,7);
hosvd(X) 
hosvd(X,reqrank=[3,3,3]) #HOSVD with predefined multilinear rank
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">7</span>);
<span class="pl-c1">hosvd</span>(X) 
<span class="pl-c1">hosvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>]) <span class="pl-c"><span class="pl-c">#</span>HOSVD with predefined multilinear rank</span></pre></div>
<p>Create random tensor in Tucker format of size 5x4x3 and mulilinear rank (2,2,2):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randttensor([5,4,3],[2,2,2])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>Basic functions:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="size(X) 
coresize(X)
ndims(X)
norm(X)
full(X)  #Creates full tensor out of Tucker format
reorth(X) #Orthogonalize factor matrices
permutedims(X,[2,1,3]) 
"><pre><span class="pl-c1">size</span>(X) 
<span class="pl-c1">coresize</span>(X)
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Tucker format</span>
<span class="pl-c1">reorth</span>(X) <span class="pl-c"><span class="pl-c">#</span>Orthogonalize factor matrices</span>
<span class="pl-c1">permutedims</span>(X,[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>]) </pre></div>
<p><em>n-mode matricization</em> of a tensor in Tucker format:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n=1;
tenmat(X,n)
"><pre>n<span class="pl-k">=</span><span class="pl-c1">1</span>;
<span class="pl-c1">tenmat</span>(X,n)</pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randttensor([5,4,3],[2,2,2]);Y=randttensor([5,4,3],[3,2,1]);
innerprod(X,Y)
X+Y
X-Y
X==Y #same as isequal(X,Y)
3*X #same as mtimes(3,X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]);Y<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">3</span>,<span class="pl-c1">2</span>,<span class="pl-c1">1</span>]);
<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
X<span class="pl-k">==</span>Y <span class="pl-c"><span class="pl-c">#</span>same as isequal(X,Y)</span>
<span class="pl-c1">3</span><span class="pl-k">*</span>X <span class="pl-c"><span class="pl-c">#</span>same as mtimes(3,X)</span></pre></div>
<p><em>n-mode product</em> of a tensor in Tucker format and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randttensor([5,4,3],[2,2,2]);
A=[rand(2,5),rand(2,4),rand(2,3)];
ttm(X,A[1],1)  #X times A[1] by mode 1
ttm(X,[A[1],A[2]],[1,2]) #X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)
ttm(X,A) #X times matrices from A by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor in Tucker format and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randttensor([5,4,3],[2,2,2]);
V=[rand(5),rand(4),rand(3)];
ttv(X,V[1],1)  #X times V[1] by mode 1
ttv(X,[V[1],V[2]],[1,2]) #X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)
ttv(X,V) #X times vectors from V by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p>The <em>n-rank</em> and the <em>mutlilinear rank</em> of a tensor in Tucker format:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randttensor([9,8,7],[5,4,3]);
n=2;
nrank(X,n)
mrank(X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">9</span>,<span class="pl-c1">8</span>,<span class="pl-c1">7</span>],[<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
n<span class="pl-k">=</span><span class="pl-c1">2</span>;
<span class="pl-c1">nrank</span>(X,n)
<span class="pl-c1">mrank</span>(X)</pre></div>
<p>HOSVD of a tensor in Tucker format:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randttensor([6,7,5],[4,4,4]);
hosvd(X)  #same as hosvd(X,eps_abs=1e-8)
hosvd(X,eps_abs=1e-6) #discard singular values lower than 1e-5
hosvd(X,eps_rel=1e-3) #discard singular values lower than 1e-3*sigma_{max}
hosvd(X,reqrank=[3,3,3]) #HOSVD with predefined multilinear rank
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">5</span>],[<span class="pl-c1">4</span>,<span class="pl-c1">4</span>,<span class="pl-c1">4</span>]);
<span class="pl-c1">hosvd</span>(X)  <span class="pl-c"><span class="pl-c">#</span>same as hosvd(X,eps_abs=1e-8)</span>
<span class="pl-c1">hosvd</span>(X,eps_abs<span class="pl-k">=</span><span class="pl-c1">1e-6</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-5</span>
<span class="pl-c1">hosvd</span>(X,eps_rel<span class="pl-k">=</span><span class="pl-c1">1e-3</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-3*sigma_{max}</span>
<span class="pl-c1">hosvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>]) <span class="pl-c"><span class="pl-c">#</span>HOSVD with predefined multilinear rank</span></pre></div>
<p>The CP decomposition:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randttensor([6,7,5],[4,4,4]);
R=3; #number of components
cp_als(X,R)  #same as cp_als(X,R,init=&quot;rand&quot;,dimorder=1:ndims(X))
cp_als(X,R,init=[rand(6,3),rand(7,3),rand(5,3)]) #initialize factor matrices 
cp_als(X,R,init=&quot;nvecs&quot;,dimorder=[2,1,3])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">5</span>],[<span class="pl-c1">4</span>,<span class="pl-c1">4</span>,<span class="pl-c1">4</span>]);
R<span class="pl-k">=</span><span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span>number of components</span>
<span class="pl-c1">cp_als</span>(X,R)  <span class="pl-c"><span class="pl-c">#</span>same as cp_als(X,R,init="rand",dimorder=1:ndims(X))</span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">7</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>)]) <span class="pl-c"><span class="pl-c">#</span>initialize factor matrices </span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>nvecs<span class="pl-pds">"</span></span>,dimorder<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>])</pre></div>
<h2><a id="user-content-tensors-in-kruskal-format" class="anchor" aria-hidden="true" href="#tensors-in-kruskal-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Kruskal format</h2>
<p>Define tensor in Kruskal format by its factor matrices (and vector of weights):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="lambda=rand(3)
A=[rand(5,3),rand(4,3),rand(3,3)];
ktensor(A)
ktensor(lambda,A)
"><pre>lambda<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ktensor</span>(A)
<span class="pl-c1">ktensor</span>(lambda,A)</pre></div>
<p>Create random tensor in Kruskal format of size 5x4x3 and with 2 components:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([5,4,3],2)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>)</pre></div>
<p>Basic functions:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="size(X) 
ndims(X)
norm(X)
full(X)  #Creates full tensor out of Kruskal format
permutedims(X,[2,1,3]) 
ncomponents(X) #Number of components
"><pre><span class="pl-c1">size</span>(X) 
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Kruskal format</span>
<span class="pl-c1">permutedims</span>(X,[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>]) 
<span class="pl-c1">ncomponents</span>(X) <span class="pl-c"><span class="pl-c">#</span>Number of components</span></pre></div>
<p><em>n-mode matricization</em> of a tensor in Kruskal format:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n=1;
tenmat(X,n)
"><pre>n<span class="pl-k">=</span><span class="pl-c1">1</span>;
<span class="pl-c1">tenmat</span>(X,n)</pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([5,4,3],2);Y=randktensor([5,4,3],3);
innerprod(X,Y)
X+Y
X-Y
X==Y #same as isequal(X,Y)
3*X #same as mtimes(3,X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>);Y<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">3</span>);
<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
X<span class="pl-k">==</span>Y <span class="pl-c"><span class="pl-c">#</span>same as isequal(X,Y)</span>
<span class="pl-c1">3</span><span class="pl-k">*</span>X <span class="pl-c"><span class="pl-c">#</span>same as mtimes(3,X)</span></pre></div>
<p><em>n-mode product</em> of a tensor in Kruskal format and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([5,4,3],2);
A=[rand(2,5),rand(2,4),rand(2,3)];
ttm(X,A[1],1)  #X times A[1] by mode 1
ttm(X,[A[1],A[2]],[1,2]) #X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)
ttm(X,A) #X times matrices from A by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor in Kruskal format and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([5,4,3],2);
V=[rand(5),rand(4),rand(3)];
ttv(X,V[1],1)  #X times V[1] by mode 1
ttv(X,[V[1],V[2]],[1,2]) #X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)
ttv(X,V) #X times vectors from V by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p>Arrange the rank-1 components of a tensor in Kruskal format:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([6,5,4,3],3);
arrange(X)
arrange!(X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">3</span>);
<span class="pl-c1">arrange</span>(X)
<span class="pl-c1">arrange!</span>(X)</pre></div>
<p>Fix sign ambiguity of a tensor in Kruskal format:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([6,5,4,3,4],3);
fixsigns(X)
fixsigns!(X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>],<span class="pl-c1">3</span>);
<span class="pl-c1">fixsigns</span>(X)
<span class="pl-c1">fixsigns!</span>(X)</pre></div>
<p>Distribute weights a tensor in Kruskal format to a specific mode:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([3,3,3],3);
n=2;
redistribute(X,n)
redistribute!(X,n)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>],<span class="pl-c1">3</span>);
n<span class="pl-k">=</span><span class="pl-c1">2</span>;
<span class="pl-c1">redistribute</span>(X,n)
<span class="pl-c1">redistribute!</span>(X,n)</pre></div>
<p>The CP decomposition:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randktensor([6,7,5],4);
R=3; #number of components
cp_als(X,R)  #same as cp_als(X,R,init=&quot;rand&quot;,dimorder=1:ndims(X))
cp_als(X,R,init=[rand(6,3),rand(7,3),rand(5,3)]) #initialize factor matrices 
cp_als(X,R,init=&quot;nvecs&quot;,dimorder=[2,1,3])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">5</span>],<span class="pl-c1">4</span>);
R<span class="pl-k">=</span><span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span>number of components</span>
<span class="pl-c1">cp_als</span>(X,R)  <span class="pl-c"><span class="pl-c">#</span>same as cp_als(X,R,init="rand",dimorder=1:ndims(X))</span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">7</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>)]) <span class="pl-c"><span class="pl-c">#</span>initialize factor matrices </span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>nvecs<span class="pl-pds">"</span></span>,dimorder<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>])</pre></div>
<h2><a id="user-content-tensors-in-hierarchical-tucker-format" class="anchor" aria-hidden="true" href="#tensors-in-hierarchical-tucker-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Hierarchical Tucker format</h2>
<p>Define tensor in Hierarchical Tucker format by dimensional tree T, its transfer tensors and factor matrices:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="T=dimtree(3)
B=[rand(2,3,1),rand(4,3,2)]
A=[rand(5,4),rand(4,3),rand(3,3)]
htensor(T,B,A)
"><pre>T<span class="pl-k">=</span><span class="pl-c1">dimtree</span>(<span class="pl-c1">3</span>)
B<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">1</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)]
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)]
<span class="pl-c1">htensor</span>(T,B,A)</pre></div>
<p>Define tensor in Hierarchical Tucker format by dimensional tree T, its transfer tensors and factor matrices:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="T=dimtree(3)
B=[rand(2,3,1),rand(4,3,2)]
A=[rand(5,4),rand(4,3),rand(3,3)]
htensor(T,B,A)
"><pre>T<span class="pl-k">=</span><span class="pl-c1">dimtree</span>(<span class="pl-c1">3</span>)
B<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">1</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)]
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)]
<span class="pl-c1">htensor</span>(T,B,A)</pre></div>
<p>Get Tucker format of a tensor by using htrunc:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(8,9,7);
htrunc(X)
htrunc(X,maxrank=3) #hrunc with defined maximal rank
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">7</span>);
<span class="pl-c1">htrunc</span>(X)
<span class="pl-c1">htrunc</span>(X,maxrank<span class="pl-k">=</span><span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span>hrunc with defined maximal rank</span></pre></div>
<p>Create random tensor in Hierarchical Tucker format of size 5x4x3:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randhtensor([5,4,3])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>])</pre></div>
<p>Basic functions:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="size(X)
ndims(X)
norm(X)
full(X)  #Creates full tensor out of Hierarchial Tucker format
reorth(X) #Orthogonalize factor matrices
"><pre><span class="pl-c1">size</span>(X)
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Hierarchial Tucker format</span>
<span class="pl-c1">reorth</span>(X) <span class="pl-c"><span class="pl-c">#</span>Orthogonalize factor matrices</span></pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randhtensor([5,4,3]);Y=randhtensor([5,4,3]);
innerprod(X,Y)
X+Y
X-Y
X==Y #same as isequal(X,Y)
3*X #same as mtimes(3,X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);Y<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
X<span class="pl-k">==</span>Y <span class="pl-c"><span class="pl-c">#</span>same as isequal(X,Y)</span>
<span class="pl-c1">3</span><span class="pl-k">*</span>X <span class="pl-c"><span class="pl-c">#</span>same as mtimes(3,X)</span></pre></div>
<p><em>n-mode product</em> of a tensor in Hierarchical Tucker format and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randhtensor([5,4,3]);
A=[rand(2,5),rand(2,4),rand(2,3)];
ttm(X,A[1],1)  #X times A[1] by mode 1
ttm(X,[A[1],A[2]],[1,2]) #X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)
ttm(X,A) #X times matrices from A by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor in Hierarchical Tucker format and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randhtensor([5,4,3]);
V=[rand(5),rand(4),rand(3)];
ttv(X,V[1],1)  #X times V[1] by mode 1
ttv(X,[V[1],V[2]],[1,2]) #X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)
ttv(X,V) #X times vectors from V by each mode
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p>The <em>h-rank</em> of a tensor in Hierarchical Tucker format:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=htrunc(rand(9,8,7),maxrank=2)
hrank(X)
"><pre>X<span class="pl-k">=</span><span class="pl-c1">htrunc</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">9</span>,<span class="pl-c1">8</span>,<span class="pl-c1">7</span>),maxrank<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-c1">hrank</span>(X)</pre></div>
<h2><a id="user-content-tensors-in-tensor-train-format" class="anchor" aria-hidden="true" href="#tensors-in-tensor-train-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Tensor Train format</h2>
<p>Define tensor in TT format by its core tensors:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="G=CoreCell(undef,3)
G[1]=rand(1,4,3)
G[2]=rand(3,6,4)
G[3]=rand(4,3,1)
X=TTtensor(G)
"><pre>G<span class="pl-k">=</span><span class="pl-c1">CoreCell</span>(undef,<span class="pl-c1">3</span>)
G[<span class="pl-c1">1</span>]<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">1</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>)
G[<span class="pl-c1">2</span>]<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">6</span>,<span class="pl-c1">4</span>)
G[<span class="pl-c1">3</span>]<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">1</span>)
X<span class="pl-k">=</span><span class="pl-c1">TTtensor</span>(G)</pre></div>
<p>Get TT format of a tensor by using TTsvd:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=rand(5,4,3,2)
TTsvd(X)
TTsvd(X,reqrank=[2,2,2])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)
<span class="pl-c1">TTsvd</span>(X)
<span class="pl-c1">TTsvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>Create random TT tensor of size 5x4x3 and TT-rank (2,2):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randTTtensor([5,4,3],[2,2])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>Basic functions::</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="size(X)
TTrank(X)
ndims(X)
norm(X)
full(X)  #Creates full tensor out of Tucker format
reorth(X)
"><pre><span class="pl-c1">size</span>(X)
<span class="pl-c1">TTrank</span>(X)
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Tucker format</span>
<span class="pl-c1">reorth</span>(X)</pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randTTtensor([5,4,3],[2,2])
Y=randTTtensor([5,4,3],[3,3])

innerprod(X,Y)
X+Y
X-Y
3*X
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])
Y<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>])

<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
<span class="pl-c1">3</span><span class="pl-k">*</span>X</pre></div>
<p>TTsvd of a TT tensor:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="X=randTTtensor([7,6,5],[5,4])
TTsvd(X,reqrank=[3,3])
"><pre>X<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">7</span>,<span class="pl-c1">6</span>,<span class="pl-c1">5</span>],[<span class="pl-c1">5</span>,<span class="pl-c1">4</span>])
<span class="pl-c1">TTsvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>])</pre></div>
</article></div>