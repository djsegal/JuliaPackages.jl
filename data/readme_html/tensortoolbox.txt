<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-tensortoolboxjl" class="anchor" aria-hidden="true" href="#tensortoolboxjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TensorToolbox.jl</h1>
<p><a href="https://travis-ci.org/lanaperisa/TensorToolbox.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f3a14f8b5bfba58286cc9421b993c5a35c7c2aca/68747470733a2f2f7472617669732d63692e6f72672f6c616e617065726973612f54656e736f72546f6f6c626f782e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/lanaperisa/TensorToolbox.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p><a href="https://zenodo.org/badge/latestdoi/92327488" rel="nofollow"><img src="https://camo.githubusercontent.com/c0cbaa38a4822ba8e6d62b0a31fef3183e107b1b/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f39323332373438382e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/92327488.svg" style="max-width:100%;"></a></p>
<p>Julia package for tensors. Includes functionality for</p>
<ul>
<li>dense tensors,</li>
<li>tensors in Tucker format,</li>
<li>tensors in Kruskal (CP) format,</li>
<li>tensors in Hierarchical Tucker format,</li>
<li>tensors in Tensor Train format (work in progress).</li>
</ul>
<p>Follows the functionality of MATLAB <a href="http://www.sandia.gov/~tgkolda/TensorToolbox/index-2.6.html" rel="nofollow">Tensor toolbox</a> and <a href="https://anchp.epfl.ch/htucker" rel="nofollow">Hierarchical Tucker Toolbox</a>.</p>
<p>Additionally, it contains algorithms from the paper <a href="http://sma.epfl.ch/~anchpcommon/publications/ttensors_pp.pdf" rel="nofollow">Recompression of Hadamard Products
of Tensors in Tucker Format</a> by D. Kressner and L. Peri≈°a.</p>
<h2><a id="user-content-basics" class="anchor" aria-hidden="true" href="#basics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basics</h2>
<p>Start with</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> TensorToolbox</pre></div>
<p>Define tensor as multidimensional array and calculate its norm:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)
<span class="pl-c1">norm</span>(X)</pre></div>
<p>Create identity and diagonal tensor:</p>
<div class="highlight highlight-source-julia"><pre>Id<span class="pl-k">=</span><span class="pl-c1">neye</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)
D<span class="pl-k">=</span><span class="pl-c1">diagt</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>])</pre></div>
<p>For two tensors of same size calculate their inner product:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>);Y<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>);
<span class="pl-c1">innerprod</span>(X,Y)</pre></div>
<p><em>Matricization</em> of a tensor:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>);n<span class="pl-k">=</span><span class="pl-c1">1</span>; 
A<span class="pl-k">=</span><span class="pl-c1">tenmat</span>(X,n) <span class="pl-c"><span class="pl-c">#</span>by mode n</span>
B<span class="pl-k">=</span><span class="pl-c1">tenmat</span>(X,row<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>],col<span class="pl-k">=</span><span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span>by row modes [2,1] and column mode 3</span></pre></div>
<p>Fold matrix back to tensor:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">matten</span>(A,n,[<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span> by mode n</span>
X<span class="pl-k">=</span><span class="pl-c1">matten</span>(B,[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>],[<span class="pl-c1">3</span>],[<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span> by row modes [2,1] and column mode 3</span></pre></div>
<p><em>n-mode product</em> of a tensor and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p><em>Outer product</em> of two tensors:</p>
<div class="highlight highlight-source-julia"><pre> X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>);Y<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>);
 <span class="pl-c1">ttt</span>(X,Y)</pre></div>
<p>Kronecker product of two tensors (straightforward generalization of Kronecker product of matrices):</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);Y<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>);
<span class="pl-c1">tkron</span>(X,Y)</pre></div>
<p>The <em>n-rank</em> and the <em>mutlilinear rank</em> of a tensor:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
n<span class="pl-k">=</span><span class="pl-c1">2</span>;
<span class="pl-c1">nrank</span>(X,n)
<span class="pl-c1">mrank</span>(X)</pre></div>
<p>The HOSVD:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
<span class="pl-c1">hosvd</span>(X) <span class="pl-c"><span class="pl-c">#</span>same as hosvd(X,eps_abs=1e-8)</span>
<span class="pl-c1">hosvd</span>(X,eps_abs<span class="pl-k">=</span><span class="pl-c1">1e-6</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-5</span>
<span class="pl-c1">hosvd</span>(X,eps_rel<span class="pl-k">=</span><span class="pl-c1">1e-3</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-3*sigma_{max}</span>
<span class="pl-c1">hosvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>The CP decomposition:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
R<span class="pl-k">=</span><span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span>number of components</span>
<span class="pl-c1">cp_als</span>(X,R)  <span class="pl-c"><span class="pl-c">#</span>same as cp_als(X,R,init="rand",dimorder=1:ndims(X))</span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)]) <span class="pl-c"><span class="pl-c">#</span>initialize factor matrices </span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>nvecs<span class="pl-pds">"</span></span>,dimorder<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>])</pre></div>
<h2><a id="user-content-tensors-in-tucker-format" class="anchor" aria-hidden="true" href="#tensors-in-tucker-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Tucker format</h2>
<p>Define tensor in Tucker format by its core tensor and factor matrices:</p>
<div class="highlight highlight-source-julia"><pre>F<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttensor</span>(F,A)</pre></div>
<p>Get Tucker format of a tensor by using HOSVD:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">7</span>);
<span class="pl-c1">hosvd</span>(X) 
<span class="pl-c1">hosvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>]) <span class="pl-c"><span class="pl-c">#</span>HOSVD with predefined multilinear rank</span></pre></div>
<p>Create random tensor in Tucker format of size 5x4x3 and mulilinear rank (2,2,2):</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>Basic functions:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">size</span>(X) 
<span class="pl-c1">coresize</span>(X)
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Tucker format</span>
<span class="pl-c1">reorth</span>(X) <span class="pl-c"><span class="pl-c">#</span>Orthogonalize factor matrices</span>
<span class="pl-c1">permutedims</span>(X,[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>]) </pre></div>
<p><em>n-mode matricization</em> of a tensor in Tucker format:</p>
<div class="highlight highlight-source-julia"><pre>n<span class="pl-k">=</span><span class="pl-c1">1</span>;
<span class="pl-c1">tenmat</span>(X,n)</pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]);Y<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">3</span>,<span class="pl-c1">2</span>,<span class="pl-c1">1</span>]);
<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
X<span class="pl-k">==</span>Y <span class="pl-c"><span class="pl-c">#</span>same as isequal(X,Y)</span>
<span class="pl-c1">3</span><span class="pl-k">*</span>X <span class="pl-c"><span class="pl-c">#</span>same as mtimes(3,X)</span></pre></div>
<p><em>n-mode product</em> of a tensor in Tucker format and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor in Tucker format and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p>The <em>n-rank</em> and the <em>mutlilinear rank</em> of a tensor in Tucker format:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">9</span>,<span class="pl-c1">8</span>,<span class="pl-c1">7</span>],[<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
n<span class="pl-k">=</span><span class="pl-c1">2</span>;
<span class="pl-c1">nrank</span>(X,n)
<span class="pl-c1">mrank</span>(X)</pre></div>
<p>HOSVD of a tensor in Tucker format:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">5</span>],[<span class="pl-c1">4</span>,<span class="pl-c1">4</span>,<span class="pl-c1">4</span>]);
<span class="pl-c1">hosvd</span>(X)  <span class="pl-c"><span class="pl-c">#</span>same as hosvd(X,eps_abs=1e-8)</span>
<span class="pl-c1">hosvd</span>(X,eps_abs<span class="pl-k">=</span><span class="pl-c1">1e-6</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-5</span>
<span class="pl-c1">hosvd</span>(X,eps_rel<span class="pl-k">=</span><span class="pl-c1">1e-3</span>) <span class="pl-c"><span class="pl-c">#</span>discard singular values lower than 1e-3*sigma_{max}</span>
<span class="pl-c1">hosvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>]) <span class="pl-c"><span class="pl-c">#</span>HOSVD with predefined multilinear rank</span></pre></div>
<p>The CP decomposition:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randttensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">5</span>],[<span class="pl-c1">4</span>,<span class="pl-c1">4</span>,<span class="pl-c1">4</span>]);
R<span class="pl-k">=</span><span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span>number of components</span>
<span class="pl-c1">cp_als</span>(X,R)  <span class="pl-c"><span class="pl-c">#</span>same as cp_als(X,R,init="rand",dimorder=1:ndims(X))</span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">7</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>)]) <span class="pl-c"><span class="pl-c">#</span>initialize factor matrices </span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>nvecs<span class="pl-pds">"</span></span>,dimorder<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>])</pre></div>
<h2><a id="user-content-tensors-in-kruskal-format" class="anchor" aria-hidden="true" href="#tensors-in-kruskal-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Kruskal format</h2>
<p>Define tensor in Kruskal format by its factor matrices (and vector of weights):</p>
<div class="highlight highlight-source-julia"><pre>lambda<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ktensor</span>(A)
<span class="pl-c1">ktensor</span>(lambda,A)</pre></div>
<p>Create random tensor in Kruskal format of size 5x4x3 and with 2 components:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>)</pre></div>
<p>Basic functions:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">size</span>(X) 
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Kruskal format</span>
<span class="pl-c1">permutedims</span>(X,[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>]) 
<span class="pl-c1">ncomponents</span>(X) <span class="pl-c"><span class="pl-c">#</span>Number of components</span></pre></div>
<p><em>n-mode matricization</em> of a tensor in Kruskal format:</p>
<div class="highlight highlight-source-julia"><pre>n<span class="pl-k">=</span><span class="pl-c1">1</span>;
<span class="pl-c1">tenmat</span>(X,n)</pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>);Y<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">3</span>);
<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
X<span class="pl-k">==</span>Y <span class="pl-c"><span class="pl-c">#</span>same as isequal(X,Y)</span>
<span class="pl-c1">3</span><span class="pl-k">*</span>X <span class="pl-c"><span class="pl-c">#</span>same as mtimes(3,X)</span></pre></div>
<p><em>n-mode product</em> of a tensor in Kruskal format and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor in Kruskal format and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">2</span>);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p>Arrange the rank-1 components of a tensor in Kruskal format:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],<span class="pl-c1">3</span>);
<span class="pl-c1">arrange</span>(X)
<span class="pl-c1">arrange!</span>(X)</pre></div>
<p>Fix sign ambiguity of a tensor in Kruskal format:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>],<span class="pl-c1">3</span>);
<span class="pl-c1">fixsigns</span>(X)
<span class="pl-c1">fixsigns!</span>(X)</pre></div>
<p>Distribute weights a tensor in Kruskal format to a specific mode:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">3</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>],<span class="pl-c1">3</span>);
n<span class="pl-k">=</span><span class="pl-c1">2</span>;
<span class="pl-c1">redistribute</span>(X,n)
<span class="pl-c1">redistribute!</span>(X,n)</pre></div>
<p>The CP decomposition:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randktensor</span>([<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">5</span>],<span class="pl-c1">4</span>);
R<span class="pl-k">=</span><span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span>number of components</span>
<span class="pl-c1">cp_als</span>(X,R)  <span class="pl-c"><span class="pl-c">#</span>same as cp_als(X,R,init="rand",dimorder=1:ndims(X))</span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">6</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">7</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">3</span>)]) <span class="pl-c"><span class="pl-c">#</span>initialize factor matrices </span>
<span class="pl-c1">cp_als</span>(X,R,init<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>nvecs<span class="pl-pds">"</span></span>,dimorder<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>])</pre></div>
<h2><a id="user-content-tensors-in-hierarchical-tucker-format" class="anchor" aria-hidden="true" href="#tensors-in-hierarchical-tucker-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Hierarchical Tucker format</h2>
<p>Define tensor in Hierarchical Tucker format by dimensional tree T, its transfer tensors and factor matrices:</p>
<div class="highlight highlight-source-julia"><pre>T<span class="pl-k">=</span><span class="pl-c1">dimtree</span>(<span class="pl-c1">3</span>)
B<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">1</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)]
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)]
<span class="pl-c1">htensor</span>(T,B,A)</pre></div>
<p>Define tensor in Hierarchical Tucker format by dimensional tree T, its transfer tensors and factor matrices:</p>
<div class="highlight highlight-source-julia"><pre>T<span class="pl-k">=</span><span class="pl-c1">dimtree</span>(<span class="pl-c1">3</span>)
B<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">1</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)]
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)]
<span class="pl-c1">htensor</span>(T,B,A)</pre></div>
<p>Get Tucker format of a tensor by using htrunc:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">7</span>);
<span class="pl-c1">htrunc</span>(X)
<span class="pl-c1">htrunc</span>(X,maxrank<span class="pl-k">=</span><span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span>hrunc with defined maximal rank</span></pre></div>
<p>Create random tensor in Hierarchical Tucker format of size 5x4x3:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>])</pre></div>
<p>Basic functions:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">size</span>(X)
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Hierarchial Tucker format</span>
<span class="pl-c1">reorth</span>(X) <span class="pl-c"><span class="pl-c">#</span>Orthogonalize factor matrices</span></pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);Y<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
X<span class="pl-k">==</span>Y <span class="pl-c"><span class="pl-c">#</span>same as isequal(X,Y)</span>
<span class="pl-c1">3</span><span class="pl-k">*</span>X <span class="pl-c"><span class="pl-c">#</span>same as mtimes(3,X)</span></pre></div>
<p><em>n-mode product</em> of a tensor in Hierarchical Tucker format and a matrix or an array of matrices:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
A<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)];
<span class="pl-c1">ttm</span>(X,A[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1</span>
<span class="pl-c1">ttm</span>(X,[A[<span class="pl-c1">1</span>],A[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times A[1] by mode 1 and times A[2] by mode 2; same as ttm(X,A,-3)</span>
<span class="pl-c1">ttm</span>(X,A) <span class="pl-c"><span class="pl-c">#</span>X times matrices from A by each mode</span></pre></div>
<p><em>n-mode (vector) product</em> of a tensor in Hierarchical Tucker format and a vector or an array of vectors:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randhtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>]);
V<span class="pl-k">=</span>[<span class="pl-c1">rand</span>(<span class="pl-c1">5</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">4</span>),<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)];
<span class="pl-c1">ttv</span>(X,V[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1</span>
<span class="pl-c1">ttv</span>(X,[V[<span class="pl-c1">1</span>],V[<span class="pl-c1">2</span>]],[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span>X times V[1] by mode 1 and times V[2] by mode 2; same as ttm(X,V,-3)</span>
<span class="pl-c1">ttv</span>(X,V) <span class="pl-c"><span class="pl-c">#</span>X times vectors from V by each mode</span></pre></div>
<p>The <em>h-rank</em> of a tensor in Hierarchical Tucker format:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">htrunc</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">9</span>,<span class="pl-c1">8</span>,<span class="pl-c1">7</span>),maxrank<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-c1">hrank</span>(X)</pre></div>
<h2><a id="user-content-tensors-in-tensor-train-format" class="anchor" aria-hidden="true" href="#tensors-in-tensor-train-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tensors in Tensor Train format</h2>
<p>Define tensor in TT format by its core tensors:</p>
<div class="highlight highlight-source-julia"><pre>G<span class="pl-k">=</span><span class="pl-c1">CoreCell</span>(undef,<span class="pl-c1">3</span>)
G[<span class="pl-c1">1</span>]<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">1</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>)
G[<span class="pl-c1">2</span>]<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">6</span>,<span class="pl-c1">4</span>)
G[<span class="pl-c1">3</span>]<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">1</span>)
X<span class="pl-k">=</span><span class="pl-c1">TTtensor</span>(G)</pre></div>
<p>Get TT format of a tensor by using TTsvd:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)
<span class="pl-c1">TTsvd</span>(X)
<span class="pl-c1">TTsvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>Create random TT tensor of size 5x4x3 and TT-rank (2,2):</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])</pre></div>
<p>Basic functions::</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">size</span>(X)
<span class="pl-c1">TTrank</span>(X)
<span class="pl-c1">ndims</span>(X)
<span class="pl-c1">norm</span>(X)
<span class="pl-c1">full</span>(X)  <span class="pl-c"><span class="pl-c">#</span>Creates full tensor out of Tucker format</span>
<span class="pl-c1">reorth</span>(X)</pre></div>
<p>Basic operations:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>])
Y<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>],[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>])

<span class="pl-c1">innerprod</span>(X,Y)
X<span class="pl-k">+</span>Y
X<span class="pl-k">-</span>Y
<span class="pl-c1">3</span><span class="pl-k">*</span>X</pre></div>
<p>TTsvd of a TT tensor:</p>
<div class="highlight highlight-source-julia"><pre>X<span class="pl-k">=</span><span class="pl-c1">randTTtensor</span>([<span class="pl-c1">7</span>,<span class="pl-c1">6</span>,<span class="pl-c1">5</span>],[<span class="pl-c1">5</span>,<span class="pl-c1">4</span>])
<span class="pl-c1">TTsvd</span>(X,reqrank<span class="pl-k">=</span>[<span class="pl-c1">3</span>,<span class="pl-c1">3</span>])</pre></div>
</article></div>