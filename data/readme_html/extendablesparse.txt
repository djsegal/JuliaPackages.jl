<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-extendablesparsejl" class="anchor" aria-hidden="true" href="#extendablesparsejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ExtendableSparse.jl</h1>
<p dir="auto"><a href="https://github.com/j-fu/ExtendableSparse.jl/actions"><img src="https://github.com/j-fu/ExtendableSparse.jl/workflows/linux-macos-windows/badge.svg" alt="Build status" style="max-width: 100%;"></a>
<a href="https://j-fu.github.io/ExtendableSparse.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://j-fu.github.io/ExtendableSparse.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://doi.org/10.5281/zenodo.3530554" rel="nofollow"><img src="https://camo.githubusercontent.com/7b842acdc347d02bbe41bad49f1b3651e6965d7cb7d00f6491aa9a6444d537e8/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f444f492f31302e353238312f7a656e6f646f2e333533303535342e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/DOI/10.5281/zenodo.3530554.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Sparse matrix class with efficient successive insertion of entries and entry update, supporting general number types.</p>
<h2 dir="auto"><a id="user-content-summary" class="anchor" aria-hidden="true" href="#summary"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Summary</h2>
<p dir="auto">The package allows for efficient assembly of a sparse matrix without
the need to handle intermediate arrays:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using ExtendableSparse
A=ExtendableSparseMatrix(10,10)
A[1,1]=1
for i = 1:9
   A[i + 1, i] += -1
   A[i, i + 1] += -1
   A[i, i] += 1
   A[i + 1, i + 1] += 1
end
b=ones(10)
x=A\b"><pre class="notranslate"><code>using ExtendableSparse
A=ExtendableSparseMatrix(10,10)
A[1,1]=1
for i = 1:9
   A[i + 1, i] += -1
   A[i, i + 1] += -1
   A[i, i] += 1
   A[i + 1, i + 1] += 1
end
b=ones(10)
x=A\b
</code></pre></div>
<p dir="auto">While one could replace here  <code>ExtendableSparseMatrix(10,10)</code> by <code>spzeros(10,10)</code>, the later is inefficient for large problems. Without this package, the general advise is  to <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/#Sparse-Vector-and-Matrix-Constructors" rel="nofollow">construct a sparse matrix via the COO format</a>.</p>
<p dir="auto">Instead of <code>\</code>, the methods from <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> can be used:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using LinearSolve
p=LinearProblem(A,b)
LinearSolve.solve(p)"><pre class="notranslate"><code>using LinearSolve
p=LinearProblem(A,b)
LinearSolve.solve(p)
</code></pre></div>
<p dir="auto">With the help of <a href="https://github.com/PetrKryslUCSD/Sparspak.jl">Sparspak.jl</a>, these examples work for general number types.</p>
<p dir="auto"><code>sparse(A)</code> creates a standard <code>SparseMatrixCSC</code> from a filled <code>ExtendableSparseMatrix</code> which can be used e.g. to create preconditioners. So one can instead perform e.g.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="LinearSolve.solve(p, KrylovJL_CG(); Pl = ILUZero.ilu0(sparse(A)))"><pre class="notranslate"><code>LinearSolve.solve(p, KrylovJL_CG(); Pl = ILUZero.ilu0(sparse(A)))
</code></pre></div>
<h2 dir="auto"><a id="user-content-rationale" class="anchor" aria-hidden="true" href="#rationale"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Rationale</h2>
<p dir="auto">Without an intermediate data structure, efficient successive insertion/update of possibly duplicate entries in random order into a standard compressed column storage structure appears to be not possible. The package introduces <code>ExtendableSparseMatrix</code>, a delegating wrapper containing a Julia standard <code>SparseMatrixCSC</code> struct for performing linear algebra operations and a <code>SparseMatrixLNK</code> struct realising a linked list based (but realised in vectors) format collecting new entries.</p>
<p dir="auto">The later is modeled after the linked list sparse matrix format described in the <a href="https://www-users.cs.umn.edu/%7Esaad/software/SPARSKIT/paper.ps" rel="nofollow">whitepaper</a> by Y. Saad. See also exercise P.3-16  in his <a href="https://www-users.cs.umn.edu/%7Esaad/IterMethBook_2ndEd.pdf" rel="nofollow">book</a>.</p>
<p dir="auto">Any linear algebra method on <code>ExtendableSparseMatrix</code> starts with a <code>flush!</code> method which adds the LNK entries and the existing CSC entries into a new CSC struct and resets the LNK struct.</p>
<p dir="auto"><code>ExtendableSparseMatrix</code> is aimed to work as a drop-in replacement to <code>SparseMatrixCSC</code> in finite element and finite volume codes especially in those cases where the sparsity structure is hard to detect a priori and where working with an intermediadte COO representation appears to be not convenient.</p>
<p dir="auto">The package  provides a <code>\</code> method for <code>ExtendableSparseMatrix</code> which dispatches to Julia's standard <code>\</code> method for <code>SparseMatrixCSC</code> where possible.
It relies on  <a href="https://github.com/PetrKryslUCSD/Sparspak.jl">Sparspak.jl</a>, P.Krysl's Julia MIT licensed re-implementation of Sparspak by George &amp; Liu for
number types  not supported by Julia's standard implementation. Notably, this  includes <code>ForwardDiff.Dual</code> numbers, thus supporting for automatic differentiation. When used with a non-GPL version of the system image, <code>\</code> is dispatched to Sparsepak.jl in all cases.</p>
<h2 dir="auto"><a id="user-content-caveat" class="anchor" aria-hidden="true" href="#caveat"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Caveat</h2>
<p dir="auto">This package assumes that a  <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dd994005f0ee4cda8d7f6a9ffa77bcd3">$m \times n$</math-renderer>  matrix is sparse if <em>each</em> row and <em>each</em> column have less than <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dd994005f0ee4cda8d7f6a9ffa77bcd3">$C$</math-renderer> entries with
<math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dd994005f0ee4cda8d7f6a9ffa77bcd3">$C &amp;lt;&amp;lt; n$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dd994005f0ee4cda8d7f6a9ffa77bcd3">$C &amp;lt;&amp;lt; m$</math-renderer> . Adding a full matrix row will be a performance hit.</p>
<h2 dir="auto">
<a id="user-content-working-with-forwarddiff" class="anchor" aria-hidden="true" href="#working-with-forwarddiff"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Working with ForwardDiff</h2>
<p dir="auto">In particular, it cooperates with <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> when it comes to the assembly of a sparse jacobian. For a function 'f!(y,x)' returning it's result in a vector <code>y</code>, one can use e.g.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="x=...
y=zeros(n)
dresult=DiffResults.DiffResult(zeros(n),ExtendableSparseMatrix(n,n))
x=ForwardDiff.jacobian!(dresult,f!,y,x)
jac=DiffResults.jacobian(dresult)
h=jac\x"><pre class="notranslate"><code>x=...
y=zeros(n)
dresult=DiffResults.DiffResult(zeros(n),ExtendableSparseMatrix(n,n))
x=ForwardDiff.jacobian!(dresult,f!,y,x)
jac=DiffResults.jacobian(dresult)
h=jac\x
</code></pre></div>
<p dir="auto">However, without a priori information on sparsity, ForwardDiff calls element insertion for the full range of n^2 indices,
leading to a O(n^2) scaling behavior due to the nevertheless necessary search operations, see  this <a href="https://discourse.julialang.org/t/non-sorted-sparsematrixcsc/37133" rel="nofollow">discourse thread</a>.</p>
<h2 dir="auto">
<a id="user-content-updateindex" class="anchor" aria-hidden="true" href="#updateindex"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>updateindex!</h2>
<p dir="auto">In addition, the package provides a method <code>updateindex!(A,op,v,i,j)</code> for both <code>SparseMatrixCSC</code> and for <code>ExtendableSparse</code> which allows to update a matrix element with one index search instead of two. It allows to replace e.g. <code>A[i,j]+=v</code> by <code>updateindex!(A,+,v,i,j)</code>. The former operation is lowered to</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="%1 = Base.getindex(A, 1, 2)
%2 = %1 + 3
Base.setindex!(A, %2, 1, 2)"><pre class="notranslate"><code>%1 = Base.getindex(A, 1, 2)
%2 = %1 + 3
Base.setindex!(A, %2, 1, 2)
</code></pre></div>
<p dir="auto">triggering two index searches, one for <code>getindex!</code> and another one for <code>setindex!</code>.</p>
<p dir="auto">See <a href="https://github.com/JuliaLang/julia/issues/15630" data-hovercard-type="issue" data-hovercard-url="/JuliaLang/julia/issues/15630/hovercard">Julia issue #15630</a> for a discussion on this.</p>
<h2 dir="auto">
<a id="user-content-factorizations-and-preconditioners" class="anchor" aria-hidden="true" href="#factorizations-and-preconditioners"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Factorizations and Preconditioners</h2>
<p dir="auto">The package provides a common API for factorizations and preconditioners supporting
series of solutions of similar problem as they occur during nonlinear and transient solves.
For details, see the <a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/" rel="nofollow">corresponding documentation</a>.</p>
<p dir="auto">With the advent of LinearSolve.jl, this functionality probably will be reduced to some core cases.</p>
<h3 dir="auto">
<a id="user-content-interfaces-to-other-packages" class="anchor" aria-hidden="true" href="#interfaces-to-other-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interfaces to other packages</h3>
<p dir="auto">The package directly provides interfaces to other sparse matrix solvers and preconditioners. Dependencies on these
packages are handeled via <a href="https://github.com/JuliaPackaging/Requires.jl">Requires.jl</a>.
Currently, support includes:</p>
<ul dir="auto">
<li>
<a href="https://github.com/JuliaSparse/Pardiso.jl">Pardiso.jl</a> (both <a href="https://pardiso-project.org" rel="nofollow">"project Pardiso"</a>
and <a href="https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/sparse-solver-routines/onemkl-pardiso-parallel-direct-sparse-solver-interface.html" rel="nofollow">MKL Pardiso</a>)</li>
<li><a href="https://github.com/haampie/IncompleteLU.jl">IncompleteLU.jl</a></li>
<li>
<a href="https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl">AlgebraicMultigrid.jl</a> (Ruge-Stüben AMG)</li>
</ul>
<p dir="auto">For a similar approach, see <a href="https://github.com/mohamed82008/Preconditioners.jl">Preconditioners.jl</a></p>
<h2 dir="auto">
<a id="user-content-alternatives" class="anchor" aria-hidden="true" href="#alternatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Alternatives</h2>
<p dir="auto">You may also evaluate alternatives to this package:</p>
<ul dir="auto">
<li><a href="https://github.com/atoptima/DynamicSparseArrays.jl">DynamicSparseArrays.jl</a></li>
</ul>
</article></div>