<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-auralightingjl" class="anchor" aria-hidden="true" href="#auralightingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>AuraLighting.jl</h1>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/wherrera10/AuraLighting.jl/blob/master/docs/src/aur.png"><img src="https://github.com/wherrera10/AuraLighting.jl/raw/master/docs/src/aur.png" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-julia-aura-lighting-interface-for-pc-hardware-using-the-asus-aura-sdk" class="anchor" aria-hidden="true" href="#julia-aura-lighting-interface-for-pc-hardware-using-the-asus-aura-sdk"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Julia Aura Lighting interface for PC hardware using the ASUS AURA SDK.</h2>
<h2 dir="auto"><a id="user-content-usage-notes" class="anchor" aria-hidden="true" href="#usage-notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage Notes</h2>
<h2 dir="auto"><a id="user-content-server-mode-or-direct-hardware-interaction-mode" class="anchor" aria-hidden="true" href="#server-mode-or-direct-hardware-interaction-mode"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Server mode or direct hardware interaction mode.</h2>
<p dir="auto">You need to run the main process (for directly interacting with the Aura lighting hardware):</p>
<ol dir="auto">
<li>
<p dir="auto">As a 32-bit process under Windows: see Julia Windows 32-bit download at <a href="https://julialang.org/downloads/" rel="nofollow">Download-Win32</a></p>
</li>
<li>
<p dir="auto">In adminstrator privilege mode under Windows ("Run as administrator")</p>
</li>
</ol>
<p dir="auto">This is because the Aura SDK itself, as provided by ASUStek, is a 32-bit DLL.</p>
<h2 dir="auto"><a id="user-content-client-mode-using-the-zmqjl-functions" class="anchor" aria-hidden="true" href="#client-mode-using-the-zmqjl-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Client mode using the ZMQ.jl functions.</h2>
<p dir="auto">Client interaction with the 32-bit Aura hardware server can be run with any Julia process, 32 or 64 bit.</p>
<p dir="auto">The OS may be any Julia capable of running ZMQ, and need not be on the same machine.</p>
<p dir="auto">Note that the AURA_SDK dll is a bit glitchy, especially when the hardware is slow to respond. Turning off
garbage collection seems to allow Julia to mostly ignore some AURA_SDK.dll based memory errors. YMMV.
<br><br></p>
<h3 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example:</h3>
<h3 dir="auto"><a id="user-content-32-bit-server" class="anchor" aria-hidden="true" href="#32-bit-server"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>32-bit server:</h3>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="GC.enable(false)  # DLL glitch workaround

aur = AuraMbControl(1, 5555)
startservice(aur)

while true sleep(0.5); end  # only use if not running in REPL"><pre class="notranslate"><code>GC.enable(false)  # DLL glitch workaround

aur = AuraMbControl(1, 5555)
startservice(aur)

while true sleep(0.5); end  # only use if not running in REPL
</code></pre></div>
<p dir="auto"><br><br></p>
<h3 dir="auto"><a id="user-content-64-bit-client" class="anchor" aria-hidden="true" href="#64-bit-client"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>64-bit client:</h3>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="client = AuraControlClient(5555, &quot;localhost&quot;, 1)

println(&quot;Client request yellow&quot;)
setcolor(client, 0xff00ff)
sleep(0.5)

r, b, g = getcolor(client)
println(&quot;Color is now RBG red = $r, blue = $b, green = $g&quot;)"><pre class="notranslate"><code>client = AuraControlClient(5555, "localhost", 1)

println("Client request yellow")
setcolor(client, 0xff00ff)
sleep(0.5)

r, b, g = getcolor(client)
println("Color is now RBG red = $r, blue = $b, green = $g")
</code></pre></div>
<p dir="auto"><br><br><br></p>
<h2 dir="auto"><a id="user-content-functions" class="anchor" aria-hidden="true" href="#functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Functions</h2>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="EnumerateControls()"><pre class="notranslate"><code>EnumerateControls()
</code></pre></div>
<p dir="auto">Find any accessible Aura lighting AuraControl objects and return a set of such,
or an empty vector if none are found. Note will also return empty if the
Windows 32-bit DLL AURA_SDK.dll is not found (in current directory or in a directory
previously set as a valid DLL directory) or if it is not loadable (eg, not 32-bit Windows Julia).
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="itorbg(i) "><pre class="notranslate"><code>itorbg(i) 
</code></pre></div>
<p dir="auto">Change rgb integer to a vector length 3 of UInt8 (red, green, blue)
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="rbgtoi(r, g, b)"><pre class="notranslate"><code>rbgtoi(r, g, b)
</code></pre></div>
<p dir="auto">Convert array of UInt8 of length 3 (r, g, b) to rgb integer.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="struct AuraMbControl &lt;: AuraControl
    controllernumber::Int
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraMbControl(c, n, h, p) = new(c, n, h, zeros(UInt, n * 3), n * 3, p)
end"><pre class="notranslate"><code>struct AuraMbControl &lt;: AuraControl
    controllernumber::Int
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraMbControl(c, n, h, p) = new(c, n, h, zeros(UInt, n * 3), n * 3, p)
end
</code></pre></div>
<p dir="auto">Represents an Aura enabled motherboard hardware item for color control usage.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function AuraMbControl(cont=1; asservice=false, port=5555)"><pre class="notranslate"><code>function AuraMbControl(cont=1; asservice=false, port=5555)
</code></pre></div>
<p dir="auto">Constructor for an AuraMBControl.
cont: controller number, defaults to 1 (first or only controller found)
port: port number of ZMQ service, defaults to 5555
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="struct AuraGPUControl &lt;: AuraControl
    controllernumber::Int
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraGPUControl(c, n, h, p) = new(c, n, h, zeros(UInt, n * 3), n * 3, p)
end"><pre class="notranslate"><code>struct AuraGPUControl &lt;: AuraControl
    controllernumber::Int
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraGPUControl(c, n, h, p) = new(c, n, h, zeros(UInt, n * 3), n * 3, p)
end
</code></pre></div>
<p dir="auto">Represents an Aura enabled GPU hardware item for color control usage.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function AuraGPUControl(cont=1, port=5556)"><pre class="notranslate"><code>function AuraGPUControl(cont=1, port=5556)
</code></pre></div>
<p dir="auto">Constructor for an AuraGPUControl.
cont: controller number, defaults to 1 (first or only controller found)
port: port number of ZMQ service, defaults to 5556
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="struct AuraKeyboardControl &lt;: AuraControl
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraKeyboardControl(n, h, p) = new(n, h, zeros(UInt, n * 3), n * 3, p)
end"><pre class="notranslate"><code>struct AuraKeyboardControl &lt;: AuraControl
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraKeyboardControl(n, h, p) = new(n, h, zeros(UInt, n * 3), n * 3, p)
end
</code></pre></div>
<p dir="auto">Represents an Aura enabled keyboard hardware item for color control usage.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function AuraKeyboardControl(cont=1; asservice=false, port=5557)"><pre class="notranslate"><code>function AuraKeyboardControl(cont=1; asservice=false, port=5557)
</code></pre></div>
<p dir="auto">Constructor for an AuraKeyboardControl.
port: port number of ZMQ service, defaults to 5557
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="struct AuraMouseControl &lt;: AuraControl
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraMouseControl(n, h, p) = new(n, h, zeros(UInt, n * 3), n * 3, p)
end"><pre class="notranslate"><code>struct AuraMouseControl &lt;: AuraControl
    LEDcount::Int
    handle::Handle
    colorbuf::Vector{UInt8}
    buflen::Int
    port::Int
    AuraMouseControl(n, h, p) = new(n, h, zeros(UInt, n * 3), n * 3, p)
end
</code></pre></div>
<p dir="auto">Represents an Aura enabled mouse hardware item for color control usage.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function AuraMouseControl(cont=1; asservice=false, port=5558)"><pre class="notranslate"><code>function AuraMouseControl(cont=1; asservice=false, port=5558)
</code></pre></div>
<p dir="auto">Constructor for an AuraMouseControl.
port: port number of ZMQ service, defaults to 5558
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function startserver(au::AuraControl)"><pre class="notranslate"><code>function startserver(au::AuraControl)
</code></pre></div>
<p dir="auto">Start AuraControl service on previously specified AuraControl object's port.<br>
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="controllernumber(au::AuraMbControl)"><pre class="notranslate"><code>controllernumber(au::AuraMbControl)
</code></pre></div>
<p dir="auto">Get the number of the hardware control for when there is mre than one Aura
controller on the hardware. Usually only motherboard and GPU have such a setup.
For other hardware this is always 1.
<br><br></p>
<p dir="auto">function setmode(au::AuraMbControl, setting::Integer=0)</p>
<p dir="auto">Set mode of motherboard Aura controller from software control to an auto mode
A setting of 0 will change to the auto mode. A setting of 1 is software control.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function setmode(au::AuraGPUControl, setting::Integer)"><pre class="notranslate"><code>function setmode(au::AuraGPUControl, setting::Integer)
</code></pre></div>
<p dir="auto">Set mode of GPU Aura controller from software control to an auto mode
A setting of 0 will change to the auto mode. A setting of 1 is software control.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function setmode(au::AuraKeyboardControl, setting::Integer)"><pre class="notranslate"><code>function setmode(au::AuraKeyboardControl, setting::Integer)
</code></pre></div>
<p dir="auto">Set mode of keyboard Aura controller from software control to an auto mode
A setting of 0 will change to the auto mode. A setting of 1 is software control.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function setmode(au::AuraMouseControl, setting::Integer)"><pre class="notranslate"><code>function setmode(au::AuraMouseControl, setting::Integer)
</code></pre></div>
<p dir="auto">Set mode of mouse Aura controller from software control to an auto mode
A setting of 0 will change to the auto mode. A setting of 1 is software control.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function getcolor(auramb::AuraMbControl)"><pre class="notranslate"><code>function getcolor(auramb::AuraMbControl)
</code></pre></div>
<p dir="auto">Get RGB color as a tuple of red, green, and blue values (0 to 255 each).
As of 2021 """ only motherboards can get color, though all types can set color
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function setcolor(au::AuraControl, red, green, blue)"><pre class="notranslate"><code>function setcolor(au::AuraControl, red, green, blue)
</code></pre></div>
<p dir="auto">Set RGB color via setting color with separate red, green, and blue values
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function setcolor(au::AuraControl, rgb)"><pre class="notranslate"><code>function setcolor(au::AuraControl, rgb)
</code></pre></div>
<p dir="auto">Set RGB color as a 64-bit integer with color as 0x00rrggbb (highest 8 bits ignored).
See e.g. <a href="https://www.rapidtables.com/web/color/RGB_Color.html" rel="nofollow">https://www.rapidtables.com/web/color/RGB_Color.html</a>
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function ZMQservice(au::AuraControl)"><pre class="notranslate"><code>function ZMQservice(au::AuraControl)
</code></pre></div>
<p dir="auto">Serve requests via ZMQ to control the Aura lighting controller.
This must be run in 32-bit Windows mode with admin privileges.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="struct AuraControlClient
    sock::Socket
    controllernumber::Int
    function AuraControlClient(port=5555, server=&quot;localhost&quot;, cont=1)
        sock = Socket(REQ)
        connect(sock, &quot;tcp://$server:$port&quot;)
        new(sock, cont)
    end
end"><pre class="notranslate"><code>struct AuraControlClient
    sock::Socket
    controllernumber::Int
    function AuraControlClient(port=5555, server="localhost", cont=1)
        sock = Socket(REQ)
        connect(sock, "tcp://$server:$port")
        new(sock, cont)
    end
end
</code></pre></div>
<p dir="auto">Client for a service to change Aura lighting via the 32-bit Win32 Aura lighting SDK.
This client can be any application and can be 64-bit even though the server must be
32-bit because ASUStek only provided a 32-bit DLL for Windows in its AuraSDK library.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function iscorrectcontroller(client::AuraControlClient)"><pre class="notranslate"><code>function iscorrectcontroller(client::AuraControlClient)
</code></pre></div>
<p dir="auto">Check if the client's controller number matches the server's controller number.
It is not actually necessary these two match, but checking this may help avoid
sending commands to the wrong controller.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function getcolor(client::AuraMBControlClient)"><pre class="notranslate"><code>function getcolor(client::AuraMBControlClient)
</code></pre></div>
<p dir="auto">Get Aura lighting color as a tuple of red, green, and blue.
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function setcolor(client::AuraControlClient, color::Integer)"><pre class="notranslate"><code>function setcolor(client::AuraControlClient, color::Integer)
</code></pre></div>
<p dir="auto">Set Aura lighting color to an RGB integer of form 0xrrggbb.
Return: true on success, false on failure
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function setcolor(client::AuraControlClient, r, g, b)"><pre class="notranslate"><code>function setcolor(client::AuraControlClient, r, g, b)
</code></pre></div>
<p dir="auto">Set Aura lighting color to RGB color with components r red, g green, b blue.
Return: true on success, false on failure
<br><br></p>
<p dir="auto">function setmode(client::AuraControlClient, mode::Integer)</p>
<p dir="auto">Set the mode of the controller to 0 for auto mode, 1 for software controlled.
Return true on success
<br><br></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="function sendexit(client::AuraControlClient)"><pre class="notranslate"><code>function sendexit(client::AuraControlClient)
</code></pre></div>
<p dir="auto">Close down the server and exit the server thread.
<br><br></p>
</article></div>