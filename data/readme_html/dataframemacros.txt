<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-dataframemacrosjl" class="anchor" aria-hidden="true" href="#dataframemacrosjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DataFrameMacros.jl</h1>
<p dir="auto"><a href="https://jkrumbiegel.github.io/DataFrameMacros.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://jkrumbiegel.github.io/DataFrameMacros.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/0050fab42206a08a390fefc18b4c773f70fcc230e9162ea74085500fb0484de2/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d6c69676874677261792e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-lightgray.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/jkrumbiegel/DataFrameMacros.jl/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/jkrumbiegel/DataFrameMacros.jl/workflows/CI/badge.svg" alt="CI Testing" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-intro" class="anchor" aria-hidden="true" href="#intro"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Intro</h2>
<p dir="auto">DataFrames.jl has a special mini-language for data transformations, which is powerful but often verbose.
Here's an example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="transform(df, :A =&gt; ByRow(x -&gt; x + 1) =&gt; :B)"><pre><span class="pl-c1">transform</span>(df, <span class="pl-c1">:A</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">ByRow</span>(x <span class="pl-k">-&gt;</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">:B</span>)</pre></div>
<p dir="auto">With DataFrameMacros.jl, you don't have to separately specify the input columns, the transformation function, and the output columns.
You can just write it as a normal expression which is transformed to the mini-language for you:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@transform(df, :B = :A + 1)"><pre><span class="pl-c1">@transform</span>(df, <span class="pl-c1">:B</span> <span class="pl-k">=</span> <span class="pl-c1">:A</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>)</pre></div>
<p dir="auto">DataFrameMacros.jl also helps you when you have to transform many columns in a similar way.
Every expression in DataFrameMacros.jl is automatically executed once for every column in a multi-column specifier, such as <code>All</code>, <code>Between</code>, <code>Not</code> or regular expressions like <code>r"cat|dog"</code>.</p>
<p dir="auto">Here's how you could divide all columns of a DataFrame that start with <code>"a"</code> by 10 and add the suffix <code>_div_10</code> to each new name:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@select(df, &quot;{}_div_10&quot; = {r&quot;^a&quot;} / 10)"><pre><span class="pl-c1">@select</span>(df, <span class="pl-s"><span class="pl-pds">"</span>{}_div_10<span class="pl-pds">"</span></span> <span class="pl-k">=</span> {<span class="pl-sr"><span class="pl-pds">r"</span>^a<span class="pl-pds">"</span></span>} <span class="pl-k">/</span> <span class="pl-c1">10</span>)</pre></div>
<p dir="auto">To execute more complex name transformations on the left-hand side, you can use <code>{n}</code> expressions.
For example, to concatenate each first column name with only the last split off part of each second column name in a multi-column transformation, you could write:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@select(df, {1} * split({2})[end] = {first_set_of_cols} + {second_set_of_cols})"><pre><span class="pl-c1">@select</span>(df, {<span class="pl-c1">1</span>} <span class="pl-k">*</span> <span class="pl-c1">split</span>({<span class="pl-c1">2</span>})[<span class="pl-c1">end</span>] <span class="pl-k">=</span> {first_set_of_cols} <span class="pl-k">+</span> {second_set_of_cols})</pre></div>
<p dir="auto">You can also use multiple columns together as a Tuple with the double brace syntax, which is useful when you need to run an aggregation over those columns in an expression. In this example we keep all rows where the value in the <code>:January</code> column is larger than the median from <code>:February</code> to <code>:December</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@subset(df, :January &gt; median({{ Between(:February, :December) }}))"><pre><span class="pl-c1">@subset</span>(df, <span class="pl-c1">:January</span> <span class="pl-k">&gt;</span> <span class="pl-c1">median</span>({{ <span class="pl-c1">Between</span>(<span class="pl-c1">:February</span>, <span class="pl-c1">:December</span>) }}))</pre></div>
<h2 dir="auto"><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>API</h2>
<p dir="auto">DataFrameMacros.jl exports these macros:</p>
<ul dir="auto">
<li><code>@transform</code> and <code>@transform!</code></li>
<li><code>@select</code> and <code>@select!</code></li>
<li><code>@groupby</code></li>
<li><code>@combine</code></li>
<li><code>@subset</code> and <code>@subset!</code></li>
<li><code>@sort</code> and <code>@sort!</code></li>
<li><code>@unique</code></li>
</ul>
<h2 dir="auto"><a id="user-content-dataframemacrosjl-compared-to-dataframesmetajl" class="anchor" aria-hidden="true" href="#dataframemacrosjl-compared-to-dataframesmetajl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DataFrameMacros.jl compared to DataFramesMeta.jl</h2>
<p dir="auto"><a href="https://github.com/JuliaData/DataFramesMeta.jl">DataFramesMeta.jl</a> is another package that provides macros for DataFrames.jl.
The syntax looks similar in many cases, but here are some noteworthy differences:</p>
<ul dir="auto">
<li>Except <code>@combine</code>, all macros work row-wise by default in DataFrameMacros.jl
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@transform(df, :y = :x + 1)
@combine(df, :sum = sum(:x))"><pre><span class="pl-c1">@transform</span>(df, <span class="pl-c1">:y</span> <span class="pl-k">=</span> <span class="pl-c1">:x</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>)
<span class="pl-c1">@combine</span>(df, <span class="pl-c1">:sum</span> <span class="pl-k">=</span> <span class="pl-c1">sum</span>(<span class="pl-c1">:x</span>))</pre></div>
</li>
<li>In DataFrameMacros.jl, you can apply the same expression to several columns in <code>{}</code> braces at once and even broadcast across multiple sets of columns. You can also use a shortcut syntax to derive new column names from old ones.</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@transform(df, &quot;{}_plus_one&quot; = {r&quot;^col&quot;} + 1) # for all columns starting with &quot;col&quot;"><pre><span class="pl-c1">@transform</span>(df, <span class="pl-s"><span class="pl-pds">"</span>{}_plus_one<span class="pl-pds">"</span></span> <span class="pl-k">=</span> {<span class="pl-sr"><span class="pl-pds">r"</span>^col<span class="pl-pds">"</span></span>} <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> for all columns starting with "col"</span></pre></div>
<ul dir="auto">
<li>In DataFrameMacros.jl, you can use special <code>{{ }}</code> multi-column expressions where you can operate on a tuple of all values at once which makes it easier to do aggregates across columns.
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@select(df, :july_larger_than_rest = :july &gt; maximum({{Not(:july)}}))"><pre><span class="pl-c1">@select</span>(df, <span class="pl-c1">:july_larger_than_rest</span> <span class="pl-k">=</span> <span class="pl-c1">:july</span> <span class="pl-k">&gt;</span> <span class="pl-c1">maximum</span>({{<span class="pl-c1">Not</span>(<span class="pl-c1">:july</span>)}}))</pre></div>
</li>
<li>DataFrameMacros.jl uses <code>{}</code> to signal column expressions instead of <code>$()</code>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@select(df, :y = {&quot;x&quot;} + 1)
col = :x
@transform(df, :z = {col} * 5)"><pre><span class="pl-c1">@select</span>(df, <span class="pl-c1">:y</span> <span class="pl-k">=</span> {<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>} <span class="pl-k">+</span> <span class="pl-c1">1</span>)
col <span class="pl-k">=</span> <span class="pl-c1">:x</span>
<span class="pl-c1">@transform</span>(df, <span class="pl-c1">:z</span> <span class="pl-k">=</span> {col} <span class="pl-k">*</span> <span class="pl-c1">5</span>)</pre></div>
</li>
<li>DataFrameMacros.jl has a special syntax to make use of <code>transform!</code> on a view returned from <code>subset</code>.
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@transform!(df, @subset(:x &gt; 5), :x = :y + 10) # update x in all rows where x &gt; 5"><pre><span class="pl-c1">@transform!</span>(df, <span class="pl-c1">@subset</span>(<span class="pl-c1">:x</span> <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>), <span class="pl-c1">:x</span> <span class="pl-k">=</span> <span class="pl-c1">:y</span> <span class="pl-k">+</span> <span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> update x in all rows where x &gt; 5</span></pre></div>
</li>
<li>DataFrameMacros.jl has a <code>@groupby</code> macro, which is a shortcut to execute <code>transform</code> and then <code>groupby</code> on a DataFrame.jl. This is nice when you want to group on a column that you have to create first. Instead of
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="df2 = @transform(df, :Y = :X + 1)
groupby(df2, :Y)"><pre>df2 <span class="pl-k">=</span> <span class="pl-c1">@transform</span>(df, <span class="pl-c1">:Y</span> <span class="pl-k">=</span> <span class="pl-c1">:X</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>)
<span class="pl-c1">groupby</span>(df2, <span class="pl-c1">:Y</span>)</pre></div>
You can write:
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@groupby(df, :Y = :X + 1)"><pre><span class="pl-c1">@groupby</span>(df, <span class="pl-c1">:Y</span> <span class="pl-k">=</span> <span class="pl-c1">:X</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>)</pre></div>
</li>
</ul>
<p dir="auto">If any of these points have changed, please open an issue.</p>
<h2 dir="auto"><a id="user-content-tip" class="anchor" aria-hidden="true" href="#tip"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tip</h2>
<p dir="auto">You can use the separate package <a href="https://github.com/jkrumbiegel/Chain.jl">Chain.jl</a> for writing chains of transformations, this way you don't have to repeat the DataFrame argument every time. This is similar to the tidyverse piping syntax that you might know from R:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@chain df begin
    @subset(:A &gt; 50)
    @transform(:B = :A + :C)
    @groupby(iseven(:B), :D)
    @combine(:mean_E = mean(:E))
    @sort(abs(:F))
end"><pre><span class="pl-c1">@chain</span> df <span class="pl-k">begin</span>
    <span class="pl-c1">@subset</span>(<span class="pl-c1">:A</span> <span class="pl-k">&gt;</span> <span class="pl-c1">50</span>)
    <span class="pl-c1">@transform</span>(<span class="pl-c1">:B</span> <span class="pl-k">=</span> <span class="pl-c1">:A</span> <span class="pl-k">+</span> <span class="pl-c1">:C</span>)
    <span class="pl-c1">@groupby</span>(<span class="pl-c1">iseven</span>(<span class="pl-c1">:B</span>), <span class="pl-c1">:D</span>)
    <span class="pl-c1">@combine</span>(<span class="pl-c1">:mean_E</span> <span class="pl-k">=</span> <span class="pl-c1">mean</span>(<span class="pl-c1">:E</span>))
    <span class="pl-c1">@sort</span>(<span class="pl-c1">abs</span>(<span class="pl-c1">:F</span>))
<span class="pl-k">end</span></pre></div>
</article></div>