<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-cbindingjl" class="anchor" aria-hidden="true" href="#cbindingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CBinding.jl</h1>
<p><a href="https://travis-ci.com/analytech-solutions/CBinding.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/19525fc898dd31c1b9ed1951bf5c56a20d3ac3a8/68747470733a2f2f6170692e7472617669732d63692e636f6d2f616e616c79746563682d736f6c7574696f6e732f4342696e64696e672e6a6c2e7376673f6272616e63683d6d6173746572" alt="Linux" data-canonical-src="https://api.travis-ci.com/analytech-solutions/CBinding.jl.svg?branch=master" style="max-width:100%;"></a> <a href="https://ci.appveyor.com/project/krrutkow/cbinding-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/0a1296d46e701c9bb41bc8dc2d77afe205f0b7c4/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f3465637864796a35316c666e6b3464662f6272616e63682f6d61737465723f7376673d74727565" alt="Windows" data-canonical-src="https://ci.appveyor.com/api/projects/status/4ecxdyj51lfnk4df/branch/master?svg=true" style="max-width:100%;"></a></p>
<p>This package provides improvements for specifying and using C bindings in Julia.
CBinding.jl has the goal of making it easier to correctly connect Julia to your C API and libraries.
We have highlighted in our blog post many of the issues encountered when <a href="https://analytech-solutions.com/analytech-solutions/blog/cbinding.html" rel="nofollow">using C libraries from Julia</a>, and those issues have fueled us to develop this package.</p>
<h1><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h1>
<p>CBinding.jl provides some missing functionality and more precise specification capabilities than those provided by the builtin Julia facilities for interfacing C.
All of the functionality and correctness of the CBinding.jl package has been compared to the behavior of GCC on x86_64 and AArch64 Linux distributions.
Since many aspects of C are platform or compiler defined, the behavior of API's built for other platforms or compilers may not be matched by this package.
Any help to test and develop against other setups is very much welcome!</p>
<h2><a id="user-content-c-aggregate-and-array-types" class="anchor" aria-hidden="true" href="#c-aggregate-and-array-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Aggregate and Array Types</h2>
<p>CBinding.jl provides a statically-sized C array similar to the static array constructs found in some other Julia packages.
An array definition is obtained by using the<code>@carray ElementType[SIZE]</code> syntax, which is provided to ease in the transcribing of C to Julia.
When used within the context of a <code>@cunion</code>, <code>@cstruct</code>, or <code>@ctypedef</code> macro, <code>ElementType[SIZE]</code> can be used directly to define arrays.</p>
<p>The <code>union</code> and <code>struct</code> aggregate types in C are described in very similar ways using CBinding.jl.
Both require the bit range of each aggregate field to be specified in order to support the different field packing approaches used in C.
Aggregate fields can be nested and anonymous aggregate fields can be used as well - two significant improvements over the usual Julian approach.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> CBinding

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> MyFirstCStruct {    <span class="pl-c"><span class="pl-c">#</span> struct MyFirstCStruct {</span>
           i<span class="pl-k">::</span><span class="pl-c1">Cint</span>                  <span class="pl-c"><span class="pl-c">#</span>     int i;</span>
       }                            <span class="pl-c"><span class="pl-c">#</span> };</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@ctypedef</span> MySecondType <span class="pl-c1">@cstruct</span> MySecondCStruct {    <span class="pl-c"><span class="pl-c">#</span> typedef struct MySecondCStruct {</span>
           i<span class="pl-k">::</span><span class="pl-c1">Cint</span>                                          <span class="pl-c"><span class="pl-c">#</span>     int i;</span>
           j<span class="pl-k">::</span><span class="pl-c1">Cint</span>                                          <span class="pl-c"><span class="pl-c">#</span>     int j;</span>
           <span class="pl-c1">@cunion</span> {                                        <span class="pl-c"><span class="pl-c">#</span>     union {</span>
               w<span class="pl-k">::</span><span class="pl-c1">Cuchar</span>[<span class="pl-c1">sizeof</span>(Cint)<span class="pl-k">÷</span><span class="pl-c1">sizeof</span>(Cuchar)]       <span class="pl-c"><span class="pl-c">#</span>         unsigned char w[sizeof(int)/sizeof(unsigned char)];</span>
               x<span class="pl-k">::</span><span class="pl-c1">Cint</span>                                      <span class="pl-c"><span class="pl-c">#</span>         int x;</span>
               (y<span class="pl-k">::</span><span class="pl-c1">_</span>[<span class="pl-c1">4</span>])<span class="pl-k">:</span>:<span class="pl-c1">@cstruct</span> {                        <span class="pl-c"><span class="pl-c">#</span>         struct {</span>
                   c<span class="pl-k">::</span><span class="pl-c1">Cuchar</span>                                <span class="pl-c"><span class="pl-c">#</span>             unsigned char c;</span>
               }                                            <span class="pl-c"><span class="pl-c">#</span>         } y[4];</span>
               z<span class="pl-k">::</span><span class="pl-c1">MyFirstCStruct</span>[<span class="pl-c1">1</span>]                         <span class="pl-c"><span class="pl-c">#</span>         struct MyFirstCStruct z[1];</span>
           }                                                <span class="pl-c"><span class="pl-c">#</span>     };</span>
           m<span class="pl-k">::</span><span class="pl-c1">MyFirstCStruct</span>                                <span class="pl-c"><span class="pl-c">#</span>     struct MyFirstCStruct m;</span>
       }                                                    <span class="pl-c"><span class="pl-c">#</span> } MySecondType;</span></pre></div>
<p>As you can see, type definition syntax closely mimics that of C, which you should find helpful when transcribing more complicated types or API's with numerous types.
There are a few syntax differences to note though:</p>
<ul>
<li>a <code>@ctypedef</code> is specified with the type name before the definition rather than after (as is done in C)</li>
<li>likewise, an aggregate field is specified in the Julia <code>fieldName::FieldType</code> syntax rather than the C style of <code>FieldType fieldName</code></li>
<li>in C a single line can specified multiple types (like <code>SomeType a, *b, c[4]</code>), but with our syntax these are expressed as a tuple (<code>(a, b::Ptr{_}, c::_[4])::SomeType</code>) with the use of an underscore <code>_</code> to mean "plug in type here"</li>
<li>Julia does not support forward declarations, so CBinding.jl uses some very dubious methods to simulate the capability which may cause grief and confusion for users when types don't appear as they should</li>
</ul>
<p>The generic constructor provided by CBinding.jl allows you to create an aggregate with uninitialized values, zero-initialized values, or from existing an existing aggregate object.
It is also possible to use keyword arguments to specify values for particular fields within the aggregate as well.
Pass the <code>zero</code> function to the constructor to create a zero-initialized object (an alternative is to pass the aggregate type to the <code>zero</code> function).
The "undef" constructor is also defined and does nothing to initialize the memory region of the allocated object, so it is optimal to use in situations where an object will be fully initialized with particular values provided as keyword arguments.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> garbage <span class="pl-k">=</span> <span class="pl-c1">MySecondCStruct</span>(undef)    <span class="pl-c"><span class="pl-c">#</span> struct MySecondCStruct garbage;</span>
<span class="pl-c1">MySecondCStruct</span>(i<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">340722048</span>, j<span class="pl-k">=</span><span class="pl-c1">32586</span>, w<span class="pl-k">=</span>UInt8[<span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>], x<span class="pl-k">=</span><span class="pl-c1">0</span>, y<span class="pl-k">=</span><span class="pl-k">&lt;</span>anonymous<span class="pl-k">-</span><span class="pl-k">struct</span><span class="pl-k">&gt;</span>[(c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>)], z<span class="pl-k">=</span>MyFirstCStruct[(i<span class="pl-k">=</span><span class="pl-c1">0</span>)], m<span class="pl-k">=</span><span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>))

julia<span class="pl-k">&gt;</span> zeroed <span class="pl-k">=</span> <span class="pl-c1">MySecondCStruct</span>(zero)    <span class="pl-c"><span class="pl-c">#</span> struct MySecondCStruct zeroed; memset(&amp;zeroed, 0, sizeof(zeroed));</span>
<span class="pl-c1">MySecondCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>, j<span class="pl-k">=</span><span class="pl-c1">0</span>, w<span class="pl-k">=</span>UInt8[<span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>], x<span class="pl-k">=</span><span class="pl-c1">0</span>, y<span class="pl-k">=</span><span class="pl-k">&lt;</span>anonymous<span class="pl-k">-</span><span class="pl-k">struct</span><span class="pl-k">&gt;</span>[(c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>)], z<span class="pl-k">=</span>MyFirstCStruct[(i<span class="pl-k">=</span><span class="pl-c1">0</span>)], m<span class="pl-k">=</span><span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>))</pre></div>
<p>Accessing the data fields within a C aggregate type works the way you would expect with one noteworthy detail.
Notice that when modifying fields within a union (e.g. <code>zeroed.y[3].c = 0xff</code>) the change is also observed in the other fields in the union (<code>zeroed.w</code>, <code>zeroed.x</code>, and <code>zeroed.y</code>).</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> zeroed<span class="pl-k">.</span>i <span class="pl-k">=</span> <span class="pl-c1">100</span>
<span class="pl-c1">100</span>

julia<span class="pl-k">&gt;</span> zeroed
<span class="pl-c1">MySecondCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">100</span>, j<span class="pl-k">=</span><span class="pl-c1">0</span>, w<span class="pl-k">=</span>UInt8[<span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>], x<span class="pl-k">=</span><span class="pl-c1">0</span>, y<span class="pl-k">=</span><span class="pl-k">&lt;</span>anonymous<span class="pl-k">-</span><span class="pl-k">struct</span><span class="pl-k">&gt;</span>[(c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>)], z<span class="pl-k">=</span>MyFirstCStruct[(i<span class="pl-k">=</span><span class="pl-c1">0</span>)], m<span class="pl-k">=</span><span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>))

julia<span class="pl-k">&gt;</span> zeroed<span class="pl-k">.</span>y[<span class="pl-c1">3</span>]<span class="pl-k">.</span>c <span class="pl-k">=</span> <span class="pl-c1">0xff</span>
<span class="pl-c1">0xff</span>

julia<span class="pl-k">&gt;</span> zeroed
<span class="pl-c1">MySecondCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">100</span>, j<span class="pl-k">=</span><span class="pl-c1">0</span>, w<span class="pl-k">=</span>UInt8[<span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0xff</span>, <span class="pl-c1">0x00</span>], x<span class="pl-k">=</span><span class="pl-c1">16711680</span>, y<span class="pl-k">=</span><span class="pl-k">&lt;</span>anonymous<span class="pl-k">-</span><span class="pl-k">struct</span><span class="pl-k">&gt;</span>[(c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>), (c<span class="pl-k">=</span><span class="pl-c1">0xff</span>), (c<span class="pl-k">=</span><span class="pl-c1">0x00</span>)], z<span class="pl-k">=</span>MyFirstCStruct[(i<span class="pl-k">=</span><span class="pl-c1">16711680</span>)], m<span class="pl-k">=</span><span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>))</pre></div>
<p>When accessing a nested aggregate (or array) type, a <code>Caccessor</code> object is used to maintain a reference to the enclosing object.
To get the aggregate itself that a <code>Caccessor</code> is referring to you must use <code>[]</code> similar to Julia <code>Ref</code> usage.
This will lead to some surprising results/behavior if you forget this detail.
The implemented <code>Base.show</code> function will also cause the <code>Caccessor</code> to appear as if you are working with the aggregate, so trust <code>typeof</code>.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(zeroed<span class="pl-k">.</span>m)
Caccessor{MyFirstCStruct,MySecondCStruct,Val{<span class="pl-c1">12</span>}}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(zeroed<span class="pl-k">.</span>m[])
MyFirstCStruct

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(zeroed<span class="pl-k">.</span>m)
<span class="pl-c1">8</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(zeroed<span class="pl-k">.</span>m[])
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> zeroed<span class="pl-k">.</span>m
<span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>)

julia<span class="pl-k">&gt;</span> zeroed<span class="pl-k">.</span>m <span class="pl-k">=</span> <span class="pl-c1">MyFirstCStruct</span>(zero, i <span class="pl-k">=</span> <span class="pl-c1">42</span>)
<span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">42</span>)

julia<span class="pl-k">&gt;</span> zeroed<span class="pl-k">.</span>m
<span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">42</span>)

julia<span class="pl-k">&gt;</span> zeroed<span class="pl-k">.</span>m[] <span class="pl-k">=</span> <span class="pl-c1">MyFirstCStruct</span>(zero, i <span class="pl-k">=</span> <span class="pl-c1">0</span>)
<span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>)

julia<span class="pl-k">&gt;</span> zeroed<span class="pl-k">.</span>m
<span class="pl-c1">MyFirstCStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>)</pre></div>
<h2><a id="user-content-c-field-alignment" class="anchor" aria-hidden="true" href="#c-field-alignment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Field Alignment</h2>
<p>By default, the fields in aggregates use native alignment to match the default alignment in C, but it is possible to denote packed aggregates using <code>__packed__</code>, similar to using a <code>__attribute__((packed))</code> attribute in C.
CBinding.jl also features the <code>@calign</code> macro to describe additional alignment requirements when defining aggregate types.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> MyUnalignedCStruct {    <span class="pl-c"><span class="pl-c">#</span> struct MyUnalignedCStruct {</span>
           c<span class="pl-k">::</span><span class="pl-c1">Cchar</span>                     <span class="pl-c"><span class="pl-c">#</span>     char c;</span>
           i<span class="pl-k">::</span><span class="pl-c1">Cint</span>                      <span class="pl-c"><span class="pl-c">#</span>     int i;</span>
           <span class="pl-c1">@cunion</span> {                    <span class="pl-c"><span class="pl-c">#</span>     union {</span>
               f<span class="pl-k">::</span><span class="pl-c1">Cfloat</span>                <span class="pl-c"><span class="pl-c">#</span>         float f;</span>
               d<span class="pl-k">::</span><span class="pl-c1">Cdouble</span>               <span class="pl-c"><span class="pl-c">#</span>         double d;</span>
           }                            <span class="pl-c"><span class="pl-c">#</span>     };</span>
       } __packed__                     <span class="pl-c"><span class="pl-c">#</span> } __attribute__((packed));</span>
MyUnalignedCStruct

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(MyUnalignedCStruct)
<span class="pl-c1">13</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> MyAlignedCStruct {    <span class="pl-c"><span class="pl-c">#</span> struct MyAlignedCStruct {</span>
           c<span class="pl-k">::</span><span class="pl-c1">Cchar</span>                   <span class="pl-c"><span class="pl-c">#</span>     char c;</span>
           i<span class="pl-k">::</span><span class="pl-c1">Cint</span>                    <span class="pl-c"><span class="pl-c">#</span>     int i;</span>
           <span class="pl-c1">@cunion</span> {                  <span class="pl-c"><span class="pl-c">#</span>     union {</span>
               f<span class="pl-k">::</span><span class="pl-c1">Cfloat</span>              <span class="pl-c"><span class="pl-c">#</span>         float f;</span>
               d<span class="pl-k">::</span><span class="pl-c1">Cdouble</span>             <span class="pl-c"><span class="pl-c">#</span>         double d;</span>
           }                          <span class="pl-c"><span class="pl-c">#</span>     };</span>
       }                              <span class="pl-c"><span class="pl-c">#</span> };</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(MyAlignedCStruct)
<span class="pl-c1">16</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> MyStrictlyAlignedCStruct {                           <span class="pl-c"><span class="pl-c">#</span> struct MyStrictlyAlignedCStruct {</span>
           <span class="pl-c1">@calign</span> <span class="pl-c1">1</span>   <span class="pl-c"><span class="pl-c">#</span> align next field at 1 byte                  #     alignas(1) char c;</span>
           c<span class="pl-k">::</span><span class="pl-c1">Cchar</span>                                                  <span class="pl-c"><span class="pl-c">#</span>     alignas(int) int i;</span>
           <span class="pl-c1">@calign</span> <span class="pl-c1">sizeof</span>(Cint)   <span class="pl-c"><span class="pl-c">#</span> align next field at 4 bytes      #     alignas(double) union {</span>
           i<span class="pl-k">::</span><span class="pl-c1">Cint</span>                                                   <span class="pl-c"><span class="pl-c">#</span>         alignas(float) float f;</span>
           <span class="pl-c1">@calign</span> <span class="pl-c1">sizeof</span>(Cdouble)   <span class="pl-c"><span class="pl-c">#</span> align largest nested field    #         alignas(double) double d;</span>
           <span class="pl-c1">@cunion</span> {                                                 <span class="pl-c"><span class="pl-c">#</span>     };</span>
               <span class="pl-c1">@calign</span> <span class="pl-c1">sizeof</span>(Cfloat)                                <span class="pl-c"><span class="pl-c">#</span> };</span>
               f<span class="pl-k">::</span><span class="pl-c1">Cfloat</span>
               <span class="pl-c1">@calign</span> <span class="pl-c1">sizeof</span>(Cdouble)
               d<span class="pl-k">::</span><span class="pl-c1">Cdouble</span>
           }
       }
MyStrictlyAlignedCStruct

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(MyStrictlyAlignedCStruct)
<span class="pl-c1">16</span></pre></div>
<h2><a id="user-content-c-const-ness" class="anchor" aria-hidden="true" href="#c-const-ness"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Const-ness</h2>
<p>One feature of C that doesn't necessarily port well into Julia is the <code>const</code> modifier on types.
The aggregate types provided by CBinding.jl are mutable by default, but the <code>Cconst</code> type can be used to create an immutable <code>struct</code> form of the type.
This mechanism can be used in a way that is <em>similar</em> to the <code>const</code> modifier in C.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> ConstStruct {    <span class="pl-c"><span class="pl-c">#</span> struct ConstStruct {</span>
           i<span class="pl-k">::</span><span class="pl-c1">Cint</span>               <span class="pl-c"><span class="pl-c">#</span>     int i;</span>
           j<span class="pl-k">::</span><span class="pl-c1">Cconst{Cint}</span>       <span class="pl-c"><span class="pl-c">#</span>     int const j;</span>
       }                         <span class="pl-c"><span class="pl-c">#</span> };</span>
ConstStruct

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">ConstStruct</span>(zero, i <span class="pl-k">=</span> <span class="pl-c1">1</span>, j <span class="pl-k">=</span> <span class="pl-c1">2</span>)
<span class="pl-c1">ConstStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> s<span class="pl-k">.</span>i <span class="pl-k">=</span> <span class="pl-c1">3</span>
<span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> s
<span class="pl-c1">ConstStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">3</span>, j<span class="pl-k">=</span><span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> s<span class="pl-k">.</span>j <span class="pl-k">=</span> <span class="pl-c1">4</span>
ERROR<span class="pl-k">:</span> Unable to change the value of a Cconst field
Stacktrace<span class="pl-k">:</span>
 [<span class="pl-c1">1</span>] <span class="pl-c1">error</span>(<span class="pl-k">::</span><span class="pl-c1">String</span>) at <span class="pl-k">./</span>error<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">33</span>
  ⁝

julia<span class="pl-k">&gt;</span> c <span class="pl-k">=</span> <span class="pl-c1">Cconst</span>(s)
<span class="pl-c1">Cconst</span>(<span class="pl-c1">ConstStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">3</span>, j<span class="pl-k">=</span><span class="pl-c1">2</span>))

julia<span class="pl-k">&gt;</span> c<span class="pl-k">.</span>i <span class="pl-k">=</span> <span class="pl-c1">5</span>
ERROR<span class="pl-k">:</span> Unable to change the value of a Cconst field
Stacktrace<span class="pl-k">:</span>
 [<span class="pl-c1">1</span>] <span class="pl-c1">error</span>(<span class="pl-k">::</span><span class="pl-c1">String</span>) at <span class="pl-k">./</span>error<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">33</span>
  ⁝

julia<span class="pl-k">&gt;</span> s<span class="pl-k">.</span>i <span class="pl-k">=</span> <span class="pl-c1">5</span>
<span class="pl-c1">5</span>

julia<span class="pl-k">&gt;</span> s
<span class="pl-c1">ConstStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">5</span>, j<span class="pl-k">=</span><span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> c  <span class="pl-c"><span class="pl-c">#</span> notice that `i` is not changed, `c` is a constant _copy_ of `s`</span>
<span class="pl-c1">Cconst</span>(<span class="pl-c1">ConstStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">3</span>, j<span class="pl-k">=</span><span class="pl-c1">2</span>))</pre></div>
<p>Run time and memory usage can be improved by using <code>Cconst</code> wrapped types as well.
If you do not wish to modify any fields in an aggregate, then it is recommended that you use the <code>Cconst</code> form of the object.</p>
<h2><a id="user-content-c-enumerations" class="anchor" aria-hidden="true" href="#c-enumerations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Enumerations</h2>
<p>We also provide an implementation of C-style enumeration with a syntax very similar to that of C.
Enumerations may be defined by using the <code>@cenum</code> macro in typedef or aggregate type macros and may be specified as either anonymous or named types.
The values of an enumeration must evaluate to integers, and can reference values defined earlier.
Usage of enumerations and values is generally promoted to integer arithmetic.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cenum</span> MyNamedEnum {    <span class="pl-c"><span class="pl-c">#</span> enum MyNamedEnum {</span>
           VALUE_1,            <span class="pl-c"><span class="pl-c">#</span>     VALUE_1,</span>
           VALUE_2,            <span class="pl-c"><span class="pl-c">#</span>     VALUE_2,</span>
           VALUE_3,            <span class="pl-c"><span class="pl-c">#</span>     VALUE_3</span>
       }                       <span class="pl-c"><span class="pl-c">#</span> };</span>
MyNamedEnum

julia<span class="pl-k">&gt;</span> e <span class="pl-k">=</span> <span class="pl-c1">MyNamedEnum</span>(VALUE_3)
<span class="pl-c1">MyNamedEnum</span>(<span class="pl-k">&lt;</span>VALUE_3<span class="pl-k">&gt;</span>(<span class="pl-c1">0x00000002</span>))

julia<span class="pl-k">&gt;</span> e <span class="pl-k">=</span> <span class="pl-c1">MyNamedEnum</span>(VALUE_1)
<span class="pl-c1">MyNamedEnum</span>(<span class="pl-k">&lt;</span>VALUE_1<span class="pl-k">&gt;</span>(<span class="pl-c1">0x00000000</span>))

julia<span class="pl-k">&gt;</span> e <span class="pl-k">|</span> VALUE_3
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> EnumStruct {    <span class="pl-c"><span class="pl-c">#</span> struct EnumStruct {</span>
           e<span class="pl-k">:</span>:<span class="pl-c1">@cenum</span> {          <span class="pl-c"><span class="pl-c">#</span>     enum {</span>
               X <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">&lt;&lt;</span><span class="pl-c1">0</span>,        <span class="pl-c"><span class="pl-c">#</span>         X = 1&lt;&lt;0,</span>
               Y <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">&lt;&lt;</span><span class="pl-c1">1</span>,        <span class="pl-c"><span class="pl-c">#</span>         Y = 1&lt;&lt;1,</span>
               Z <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">&lt;&lt;</span><span class="pl-c1">2</span>,        <span class="pl-c"><span class="pl-c">#</span>         Z = 1&lt;&lt;2</span>
           }                    <span class="pl-c"><span class="pl-c">#</span>     } e;</span>
       }                        <span class="pl-c"><span class="pl-c">#</span> };</span>
EnumStruct

julia<span class="pl-k">&gt;</span> e <span class="pl-k">=</span> <span class="pl-c1">EnumStruct</span>(zero)
<span class="pl-c1">EnumStruct</span>(e<span class="pl-k">=</span><span class="pl-k">&lt;</span>anonymous<span class="pl-k">-</span>enum<span class="pl-k">&gt;</span>(<span class="pl-c1">0x00000000</span>))

julia<span class="pl-k">&gt;</span> e<span class="pl-k">.</span>e <span class="pl-k">=</span> X<span class="pl-k">|</span>Y<span class="pl-k">|</span>Z
<span class="pl-c1">7</span>

julia<span class="pl-k">&gt;</span> e
<span class="pl-c1">EnumStruct</span>(e<span class="pl-k">=</span><span class="pl-k">&lt;</span>anonymous<span class="pl-k">-</span>enum<span class="pl-k">&gt;</span>(<span class="pl-c1">0x00000007</span>))</pre></div>
<p>CBinding.jl also allows you to apply an alignment strategy, such as <code>__packed__</code>, to an enumeration definition.
An alignment strategy can be applied to both standalone enumeration types and enumerations nested within unions or structures.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cenum</span> MyPackedNamedEnum {    <span class="pl-c"><span class="pl-c">#</span> enum MyPackedNamedEnum {</span>
           PACKED_VALUE_1,           <span class="pl-c"><span class="pl-c">#</span>     PACKED_VALUE_1,</span>
           PACKED_VALUE_2,           <span class="pl-c"><span class="pl-c">#</span>     PACKED_VALUE_2,</span>
           PACKED_VALUE_3,           <span class="pl-c"><span class="pl-c">#</span>     PACKED_VALUE_3</span>
       } __packed__                  <span class="pl-c"><span class="pl-c">#</span> } __attribute__((packed));</span>
MyPackedNamedEnum

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(MyNamedEnum)
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(MyPackedNamedEnum)
<span class="pl-c1">1</span></pre></div>
<h2><a id="user-content-c-bit-fields" class="anchor" aria-hidden="true" href="#c-bit-fields"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Bit Fields</h2>
<p>Specifying C bit fields is another feature provided by CBinding.jl.
Bit fields can be defined with <code>(fieldName:FIELD_BITS)::FieldType</code> where <code>FIELD_BITS</code> is an Integer number of bits and <code>FieldType</code> is either <code>Cint</code> or <code>Cuint</code>.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> BitfieldStruct {    <span class="pl-c"><span class="pl-c">#</span> struct BitfieldStruct {</span>
           (i<span class="pl-k">:</span><span class="pl-c1">2</span>)<span class="pl-k">::</span><span class="pl-c1">Cint</span>              <span class="pl-c"><span class="pl-c">#</span>     int i:2;</span>
           (j<span class="pl-k">:</span><span class="pl-c1">2</span>)<span class="pl-k">::</span><span class="pl-c1">Cuint</span>             <span class="pl-c"><span class="pl-c">#</span>     unsigned int j:2;</span>
       }                            <span class="pl-c"><span class="pl-c">#</span> };</span>
BitfieldStruct

julia<span class="pl-k">&gt;</span> bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(zero)
<span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000000</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(bf)
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>
           bf<span class="pl-k">.</span>i <span class="pl-k">=</span> i ; <span class="pl-c1">@show</span> bf
       <span class="pl-k">end</span>
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000000</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">2</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000000</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000000</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">0</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000000</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000000</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>
           bf<span class="pl-k">.</span>j <span class="pl-k">=</span> i ; <span class="pl-c1">@show</span> bf
       <span class="pl-k">end</span>
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000001</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000002</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000003</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000000</span>)
bf <span class="pl-k">=</span> <span class="pl-c1">BitfieldStruct</span>(i<span class="pl-k">=</span><span class="pl-c1">1</span>, j<span class="pl-k">=</span><span class="pl-c1">0x00000001</span>)</pre></div>
<h2><a id="user-content-c-libraries" class="anchor" aria-hidden="true" href="#c-libraries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Libraries</h2>
<p>Interfacing C libraries is done through a <code>Clibrary</code> object.
Once the library object is available, it can be used for obtaining global variables or functions directly.
This approach allows for multiple libraries to be loaded without causing symbol conflicts.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> lib <span class="pl-k">=</span> <span class="pl-c1">Clibrary</span>()  <span class="pl-c"><span class="pl-c">#</span> dlopens the Julia process    # void *lib = dlopen(NULL, RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL); </span>
<span class="pl-c1">Clibrary</span>(Ptr{Nothing} @<span class="pl-c1">0x000061eefd6a1000</span>)

julia<span class="pl-k">&gt;</span> lib2 <span class="pl-k">=</span> <span class="pl-c1">Clibrary</span>(<span class="pl-s"><span class="pl-pds">"</span>/path/to/library.so<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> dlopens the library    # void *lib2 = dlopen("/path/to/library.so", RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL);</span>
<span class="pl-c1">Clibrary</span>(Ptr{Nothing} @<span class="pl-c1">0x00006c1ce98c5000</span>)</pre></div>
<h2><a id="user-content-c-global-variables" class="anchor" aria-hidden="true" href="#c-global-variables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Global Variables</h2>
<p>A simple wrapper type, <code>Cglobal</code>, is provided to obtain global variables from a library.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> val <span class="pl-k">=</span> <span class="pl-c1">Cglobal</span><span class="pl-c1">{Ptr{Cvoid}}</span>(lib, <span class="pl-c1">:jl_nothing</span>)    <span class="pl-c"><span class="pl-c">#</span> const void **val = dlsym(lib, "jl_nothing");</span>
<span class="pl-c1">Cglobal</span><span class="pl-c1">{Ptr{Nothing}}</span>(Ptr{Ptr{Nothing}} @<span class="pl-c1">0x00007fc384893bb8</span>)

julia<span class="pl-k">&gt;</span> val[]   <span class="pl-c"><span class="pl-c">#</span> dereference val</span>
Ptr{Nothing} @<span class="pl-c1">0x00007fc3735ce008</span></pre></div>
<p>The new <code>@cextern</code> macro is the recommended method of binding global variables.
It is a more concise Julian representation that closely mirrors the C syntax.
This macro also includes the ability to use anonymous types in the definition of global variables.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cextern</span> jl_base_module<span class="pl-k">::</span><span class="pl-c1">Ptr{@cstruct jl_module_t}</span>    <span class="pl-c"><span class="pl-c">#</span> extern struct _jl_module_t *jl_base_module;</span>
<span class="pl-c1">Cglobal</span><span class="pl-c1">{Ptr{jl_module_t}}</span>(Ptr{Ptr{jl_module_t}} @<span class="pl-c1">0x00007f84ce375230</span>)</pre></div>
<h2><a id="user-content-c-functions" class="anchor" aria-hidden="true" href="#c-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Functions</h2>
<p>This package adds the ability to specify function pointers in a type-safe way to Julia, similar to how you would in C.
You may specify a <code>Cfunction</code> pointer directly, or use the constructor to load a symbol from a bound library.
The parametric types to <code>Cfunction</code> are used to specify the return type and the tuple of argument types for the function referenced.
The additional type-safety will help you avoid many mishaps when calling C functions.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> CFuncType <span class="pl-k">=</span> Cfunction{Clong, Tuple{Ptr{Clong}}}    <span class="pl-c"><span class="pl-c">#</span> type of the function `long func(long *);`</span>
Cfunction{Int64,Tuple{Ptr{Int64}},ConvT} <span class="pl-k">where</span> ConvT<span class="pl-k">&lt;:</span><span class="pl-c1">Cconvention</span>

julia<span class="pl-k">&gt;</span> CFuncPtrType <span class="pl-k">=</span> Ptr{CFuncType}    <span class="pl-c"><span class="pl-c">#</span> long (*func)(long *);</span>
Ptr{Cfunction{Int64,Tuple{Ptr{Int64}},ConvT} <span class="pl-k">where</span> ConvT<span class="pl-k">&lt;:</span><span class="pl-c1">Cconvention</span>}

julia<span class="pl-k">&gt;</span> func <span class="pl-k">=</span> <span class="pl-en">CFuncType</span>(lib, <span class="pl-c1">:time</span>)    <span class="pl-c"><span class="pl-c">#</span> long (*func)(long *) = dlsym(lib, "time");</span>
Ptr{Cfunction{Int64,Tuple{Ptr{Int64}},ConvT} <span class="pl-k">where</span> ConvT<span class="pl-k">&lt;:</span><span class="pl-c1">Cconvention</span>} @<span class="pl-c1">0x00007fff95de08c0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cstruct</span> tm {
           sec<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           min<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           hour<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           mday<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           mon<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           year<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           wday<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           yday<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           isdst<span class="pl-k">::</span><span class="pl-c1">Cint</span>
       }
tm

julia<span class="pl-k">&gt;</span> localtime <span class="pl-k">=</span> <span class="pl-en">Cfunction</span><span class="pl-c1">{Ptr{tm}, Tuple{Ptr{Clong}}}</span>(lib, <span class="pl-c1">:localtime</span>)    <span class="pl-c"><span class="pl-c">#</span> struct tm *(*localtime)(long *) = dlsym(lib, "localtime");</span>
Ptr{Cfunction{Ptr{tm},Tuple{Ptr{Int64}},ConvT} <span class="pl-k">where</span> ConvT<span class="pl-k">&lt;:</span><span class="pl-c1">Cconvention</span>} @<span class="pl-c1">0x0000652bdb253fd0</span></pre></div>
<p>CBinding.jl also makes a function pointer (<code>Ptr{&lt;:Cfunction}</code>) callable.
So, just as you would in C, you can simply call the function pointer to invoke it.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">func</span>(C_NULL)
<span class="pl-c1">1560708358</span>

julia<span class="pl-k">&gt;</span> t <span class="pl-k">=</span> <span class="pl-c1">Ref</span>(<span class="pl-c1">Clong</span>(<span class="pl-c1">0</span>))
Base<span class="pl-k">.</span><span class="pl-c1">RefValue</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">0</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">func</span>(t)
<span class="pl-c1">1560708359</span>

julia<span class="pl-k">&gt;</span> t[]   <span class="pl-c"><span class="pl-c">#</span> dereference t</span>
<span class="pl-c1">1560708359</span>

julia<span class="pl-k">&gt;</span> p <span class="pl-k">=</span> <span class="pl-c1">localtime</span>(t)
Ptr{tm} @<span class="pl-c1">0x00007f4afa08b300</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">unsafe_load</span>(p)   <span class="pl-c"><span class="pl-c">#</span> dereference p</span>
<span class="pl-c1">tm</span>(sec<span class="pl-k">=</span><span class="pl-c1">59</span>, min<span class="pl-k">=</span><span class="pl-c1">5</span>, hour<span class="pl-k">=</span><span class="pl-c1">14</span>, mday<span class="pl-k">=</span><span class="pl-c1">16</span>, mon<span class="pl-k">=</span><span class="pl-c1">5</span>, year<span class="pl-k">=</span><span class="pl-c1">119</span>, wday<span class="pl-k">=</span><span class="pl-c1">0</span>, yday<span class="pl-k">=</span><span class="pl-c1">166</span>, isdst<span class="pl-k">=</span><span class="pl-c1">1</span>)</pre></div>
<p>It is also possible to create type-safe function pointers to Julia functions for use in C code.
A closure is automatically created for the wrapped function and returned along with the C function pointer, so a reference to the closure (<code>Base.CFunction</code>) must be kept to keep the function pointer valid.
One important thing to note is that the Julia function used is not (yet) guarded, so the argument and return types of the Julia function must match that of the Cfunction signature.
The new <code>@ccallback</code> macro is now the recommended method of creating function pointers from Julia functions.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> (Cadd, add) <span class="pl-k">=</span> <span class="pl-c1">Cfunction</span><span class="pl-c1">{Cint, Tuple{Cint, Cint}}</span>() <span class="pl-k">do</span> x<span class="pl-k">::</span><span class="pl-c1">Cint</span>, y<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           <span class="pl-k">return</span> <span class="pl-c1">Cint</span>(x <span class="pl-k">+</span> y)
       <span class="pl-k">end</span>
(Ptr{Cfunction{Int32,Tuple{Int32,Int32},Cconvention{<span class="pl-c1">:cdecl</span>}}} @<span class="pl-c1">0x00007fc34e4dfa40</span>, Base<span class="pl-k">.</span><span class="pl-c1">CFunction</span>(Ptr{Nothing} @<span class="pl-c1">0x00007fc34e4dfa40</span>, <span class="pl-c1">getfield</span>(Main, <span class="pl-c1">Symbol</span>(<span class="pl-s"><span class="pl-pds">"</span>##5#6<span class="pl-pds">"</span></span>))(), Ptr{Nothing} @<span class="pl-c1">0x0000000000000000</span>, Ptr{Nothing} @<span class="pl-c1">0x0000000000000000</span>))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Cadd</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> ccall the C function pointer, arguments are Base.cconvert-ed automatically</span>
<span class="pl-c1">5</span>

julia<span class="pl-k">&gt;</span> add<span class="pl-k">.</span><span class="pl-c1">f</span>(<span class="pl-c1">Cint</span>(<span class="pl-c1">2</span>), <span class="pl-c1">Cint</span>(<span class="pl-c1">3</span>))  <span class="pl-c"><span class="pl-c">#</span> directly call the Julia function</span>
<span class="pl-c1">5</span>

julia<span class="pl-k">&gt;</span> Cadd <span class="pl-k">=</span> <span class="pl-c1">@ccallback</span> <span class="pl-k">function</span> <span class="pl-en">add</span>(x<span class="pl-k">::</span><span class="pl-c1">Cint</span>, y<span class="pl-k">::</span><span class="pl-c1">Cint</span>)<span class="pl-k">::</span><span class="pl-c1">Cint</span>
           <span class="pl-k">return</span> x <span class="pl-k">+</span> y
       <span class="pl-k">end</span></pre></div>
<h2><a id="user-content-c-variadic-functions" class="anchor" aria-hidden="true" href="#c-variadic-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C Variadic Functions</h2>
<p>Declaring a variadic function pointer can be done using a <code>Vararg</code> argument type (which must be the last argument).
The variadic function calling capability provided with CBinding.jl is not limited in the ways that native Julia ccall usage is.
This enables Julia the ability to perform real-world variadic function usage as demonstrated with an example of binding to <code>printf</code> and then calling it below.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> func <span class="pl-k">=</span> <span class="pl-en">Cfunction</span><span class="pl-c1">{Cint, Tuple{Cstring, Vararg}}</span>(lib, <span class="pl-c1">:printf</span>)    <span class="pl-c"><span class="pl-c">#</span> int (*func)(char *, ...) = dlsym(lib, "printf");</span>
Ptr{Cfunction{Int32,Tuple{Cstring,Vararg{Any,N} <span class="pl-k">where</span> N},ConvT} <span class="pl-k">where</span> ConvT<span class="pl-k">&lt;:</span><span class="pl-c1">Cconvention</span>} @<span class="pl-c1">0x000061eefc388930</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">func</span>(<span class="pl-s"><span class="pl-pds">"</span>%s i%c %ld great demo of CBinding.jl v%3.1lf%c<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>this<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-c1">1</span>, <span class="pl-c1">0.1</span>, <span class="pl-s"><span class="pl-pds">'</span>!<span class="pl-pds">'</span></span>)
this is <span class="pl-c1">1</span> great demo of CBinding<span class="pl-k">.</span>jl v0<span class="pl-c1">.1</span>!
<span class="pl-c1">42</span></pre></div>
<h2><a id="user-content-binding-julia-with-a-c-library" class="anchor" aria-hidden="true" href="#binding-julia-with-a-c-library"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Binding Julia with a C library</h2>
<p>The new <code>@cbindings</code> and <code>@cextern</code> macros provide the recommended method of binding C functions with Julia.
Its intended use is for creating optimized function bindings rather than loading function pointers.
It provides a more concise Julian representation that closely mirrors the C syntax.
The <code>@cextern</code> macro also includes the ability to use anonymous types in the definition of function.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cextern</span> <span class="pl-c1">time</span>(ptr<span class="pl-k">::</span><span class="pl-c1">Ptr{Clong}</span>)<span class="pl-k">::</span><span class="pl-c1">Clong</span>
time (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cextern</span> <span class="pl-c1">localtime</span>(ptr<span class="pl-k">::</span><span class="pl-c1">Ptr{Clong}</span>)<span class="pl-k">::</span><span class="pl-c1">Ptr{tm}</span>
localtime (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cextern</span> <span class="pl-c1">printf</span>(format<span class="pl-k">::</span><span class="pl-c1">Cstring</span>, vals<span class="pl-k">...</span>)<span class="pl-k">::</span><span class="pl-c1">Cint</span>
printf (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">time</span>(t)
<span class="pl-c1">1560708359</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">unsafe_load</span>(<span class="pl-c1">localtime</span>(t))
<span class="pl-c1">tm</span>(sec<span class="pl-k">=</span><span class="pl-c1">59</span>, min<span class="pl-k">=</span><span class="pl-c1">5</span>, hour<span class="pl-k">=</span><span class="pl-c1">14</span>, mday<span class="pl-k">=</span><span class="pl-c1">16</span>, mon<span class="pl-k">=</span><span class="pl-c1">5</span>, year<span class="pl-k">=</span><span class="pl-c1">119</span>, wday<span class="pl-k">=</span><span class="pl-c1">0</span>, yday<span class="pl-k">=</span><span class="pl-c1">166</span>, isdst<span class="pl-k">=</span><span class="pl-c1">1</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>%s i%c %ld great demo of CBinding.jl v%3.1lf%c<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>this<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-c1">1</span>, <span class="pl-c1">0.1</span>, <span class="pl-s"><span class="pl-pds">'</span>!<span class="pl-pds">'</span></span>)
this is <span class="pl-c1">1</span> great demo of CBinding<span class="pl-k">.</span>jl v0<span class="pl-c1">.1</span>!
<span class="pl-c1">42</span></pre></div>
<p>The <code>@cbindings</code> macro can be used to cleanly group and target bindings to a particular library.
Any <code>@ctypedef</code>, <code>@cstruct</code>, <code>@cextern</code>, etc. macro usage can be placed within a <code>@cbindings</code> macro as well.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">module</span> CJulia
  <span class="pl-k">using</span> CBinding
  
  <span class="pl-c1">@cbindings</span> <span class="pl-s"><span class="pl-pds">"</span>./path/to/libjulia.so<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
    <span class="pl-c1">@ctypedef</span> jl_nullable_float64_t <span class="pl-c1">@cstruct</span> {
      hasvalue<span class="pl-k">::</span><span class="pl-c1">UInt8</span>
      value<span class="pl-k">::</span><span class="pl-c1">Cdouble</span>
    }
    
    <span class="pl-c1">@ctypedef</span> jl_value_t <span class="pl-c1">@cstruct</span> _jl_value_t
    
    <span class="pl-c1">@cextern</span> <span class="pl-c1">jl_gc_enable</span>(on<span class="pl-k">::</span><span class="pl-c1">Cint</span>)<span class="pl-k">::</span><span class="pl-c1">Cint</span>
    <span class="pl-c1">@cextern</span> <span class="pl-c1">jl_gc_is_enabled</span>()<span class="pl-k">::</span><span class="pl-c1">Cint</span>
    
    <span class="pl-c1">@cextern</span> <span class="pl-c1">jl_gc_alloc_0w</span>()<span class="pl-k">::</span><span class="pl-c1">Ptr{jl_value_t}</span>
    <span class="pl-c1">@cextern</span> <span class="pl-c1">jl_gc_alloc_1w</span>()<span class="pl-k">::</span><span class="pl-c1">Ptr{jl_value_t}</span>
    <span class="pl-c1">@cextern</span> <span class="pl-c1">jl_gc_alloc_2w</span>()<span class="pl-k">::</span><span class="pl-c1">Ptr{jl_value_t}</span>
    <span class="pl-c1">@cextern</span> <span class="pl-c1">jl_gc_alloc_3w</span>()<span class="pl-k">::</span><span class="pl-c1">Ptr{jl_value_t}</span>
    <span class="pl-c1">@cextern</span> <span class="pl-c1">jl_gc_allocobj</span>(sz<span class="pl-k">::</span><span class="pl-c1">Csize_t</span>)<span class="pl-k">::</span><span class="pl-c1">Ptr{jl_value_t}</span>
    
    <span class="pl-c1">@cextern</span> jl_base_module<span class="pl-k">::</span><span class="pl-c1">Ptr{@cstruct jl_module_t}</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
</article></div>