<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-cbindingjl" class="anchor" aria-hidden="true" href="#cbindingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>CBinding.jl</h1>
<p dir="auto"><a href="https://github.com/analytech-solutions/CBinding.jl/actions"><img src="https://github.com/analytech-solutions/CBinding.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto">Use CBinding.jl to automatically create C library bindings with Julia at runtime!</p>
<p dir="auto">Package supports these C features:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> fully supports C's <code>struct</code>, <code>union</code>, and <code>enum</code> types</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> alignment strategies</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> bit fields</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> nested types</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> anonymous types</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> type qualifiers</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> variadic functions</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> unknown-length arrays</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> inline functions (experimental opt-in)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> typed function pointers</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> function calling conventions</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> automatic callback function pointers</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> documentation generation</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> preprocessor macros (partially supported)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> fully supports insane C (i.e. <code>extern struct { int i; } g[2], func();</code>)</li>
</ul>
<p dir="auto">Read on to learn how to automatically create C library bindings, or <a href="#using-cbindingjl-generated-bindings">learn how to use the generated bindings</a>.</p>
<h1 dir="auto"><a id="user-content-create-bindings-with-cbindingjl" class="anchor" aria-hidden="true" href="#create-bindings-with-cbindingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Create bindings with <code>CBinding.jl</code></h1>
<p dir="auto">First, set up a compiler context to collect C expressions (at the module scope, or at the REPL).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using CBinding

julia&gt; c``"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> CBinding

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span><span class="pl-pds">`</span></span></pre></div>
<p dir="auto">Notice that <code>c`...`</code> is a command macro (with the backticks) and is the means of specifying command line arguments to the Clang parser.
Each time such a command macro is used, a new compiler context is started for the module creating it.
A more real-life example might look like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; libpath = find_libpath();

julia&gt; c`-std=c99 -Wall -DGO_FAST=1 -Imylib/include -L$(libpath) -lmylib`"><pre>julia<span class="pl-k">&gt;</span> libpath <span class="pl-k">=</span> <span class="pl-c1">find_libpath</span>();

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span>-std=c99 -Wall -DGO_FAST=1 -Imylib/include -L$(libpath) -lmylib<span class="pl-pds">`</span></span></pre></div>
<p dir="auto">The compiler context also finds the paths of all specified libraries so it can use them in any bindings that are created.</p>
<p dir="auto">Next the <code>c"..."</code> string macro can be used to input C code and automatically create the equivalent Julia types, global variable bindings, and function bindings.
It is often the case that the C code will span multiple lines, so the triple-quoted variant (<code>c"""..."""</code>) is most effective for this usage.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; c&quot;&quot;&quot;
         struct S;
         struct T {
           int i;
           struct S *s;
           struct T *t;
         };
         
         extern void func(struct S *s, struct T t);
       &quot;&quot;&quot;;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct S;</span>
<span class="pl-s">         struct T {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">           struct S *s;</span>
<span class="pl-s">           struct T *t;</span>
<span class="pl-s">         };</span>
<span class="pl-s">         </span>
<span class="pl-s">         extern void func(struct S *s, struct T t);</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;</pre></div>
<p dir="auto">That's it...
That's all that is needed to create a couple C types and a function binding in Julia, but actually, it gets even easier!</p>
<p dir="auto">C API's usually come with header files, so let's just use those to create the Julia bindings and save some effort.
By default, bindings are generated from the code directly written in C string macros and header files explicitly included in them, but not headers included by those headers.
<a href="#options-for-c">See the <code>i</code> string macro option</a> to allow parsing certain implicitly included headers as well.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; c&quot;&quot;&quot;
         #include &lt;mylib/header.h&gt;
       &quot;&quot;&quot;;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         #include &lt;mylib/header.h&gt;</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;</pre></div>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> all C types are defined in Julia</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> C function and global variable bindings defined</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> the C API is documented and exported by the enclosing module</li>
</ul>
<p dir="auto">All done in just a few lines of code!
<a href="#a-complete-example">Take a look at the complete example below</a> or continue reading to learn about some more details.</p>
<h2 dir="auto"><a id="user-content-some-gory-details" class="anchor" aria-hidden="true" href="#some-gory-details"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Some gory details</h2>
<p dir="auto">The C expressions are parsed and immediately converted to Julia code.
In fact, the generated Julia code can be inspected using <code>@macroexpand</code>, like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @macroexpand c&quot;&quot;&quot;
         struct S;
         struct T {
           int i;
           struct S *s;
           struct T *t;
         };
         
         extern void func(struct S *s, struct T t);
       &quot;&quot;&quot;
  ⋮
YIKES!
  ⋮"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@macroexpand</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct S;</span>
<span class="pl-s">         struct T {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">           struct S *s;</span>
<span class="pl-s">           struct T *t;</span>
<span class="pl-s">         };</span>
<span class="pl-s">         </span>
<span class="pl-s">         extern void func(struct S *s, struct T t);</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>
  ⋮
YIKES!
  ⋮</pre></div>
<p dir="auto">In order to support the fully automatic conversion and avoid name collisions, the names of C types or functions are mangled a bit to work in Julia.
Therefore everything generated by CBinding.jl can be accessed with the <code>c"..."</code> string macro (<a href="#using-cbindingjl-generated-bindings">more about this below</a>) to indicate that it lives in C-land.
As an example, the function <code>func</code> above is available in Julia as <code>c"func"</code>.
It is possible to store the generated bindings to more user-friendly names (this can sometimes be automated, <a href="#options-for-c">see the <code>j</code> option</a>).
Placing each C declaration in its own macro helps when doing this manually, like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; const S = c&quot;&quot;&quot;
         struct S;
       &quot;&quot;&quot;;

julia&gt; const T = c&quot;&quot;&quot;
         struct T {
           int i;
           struct S *s;
           struct T *t;
         };
       &quot;&quot;&quot;;

julia&gt; c&quot;&quot;&quot;
         extern void func(struct S *s, struct T t);
       &quot;&quot;&quot;j;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> S <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct S;</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;

julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> T <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct T {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">           struct S *s;</span>
<span class="pl-s">           struct T *t;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         extern void func(struct S *s, struct T t);</span>
<span class="pl-s">       <span class="pl-pds">"""</span><span class="pl-c1">j</span></span>;</pre></div>
<p dir="auto">Constructs from the standard C library headers are currently not being emitted by CBinding.jl, but other packages may be developed to provide a unified source for them.
For now, dependencies on C library or other libraries should be placed before any C code blocks referencing them.
Most often it is only a few <code>using</code> and <code>const</code> statements.</p>
<h2 dir="auto"><a id="user-content-a-complete-example" class="anchor" aria-hidden="true" href="#a-complete-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A complete example</h2>
<p dir="auto">Finally, a set of examples can be found at <a href="https://github.com/analytech-solutions/ExamplesUsingCBinding.jl">https://github.com/analytech-solutions/ExamplesUsingCBinding.jl</a>, but here is a generalized example of what a package using CBinding.jl might look like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module LibFoo
  module libfoo
    import Foo_jll
    using CBinding
    
    # libfoo has libbar as a dep, and LibBar has bindings for it
    using LibBar: libbar
    
    # set up the parser
    let
      incdir = joinpath(Foo_jll.artifact_dir, &quot;include&quot;)
      libdir = dirname(Foo_jll.libfoo_path)
      
      c`-std=c99 -fparse-all-comments -I$(incdir) -L$(libdir) -lfoo`
    end
    
    # libfoo refers to some std C sized types (eventually made available with something like `using C99`)
    const c&quot;int32_t&quot;  = Int32
    const c&quot;int64_t&quot;  = Int64
    const c&quot;uint32_t&quot; = UInt32
    const c&quot;uint64_t&quot; = UInt64
    
    # generate bindings for libfoo
    c&quot;&quot;&quot;
      #include &lt;libfoo/header-1.h&gt;
      #include &lt;libfoo/header-2.h&gt;
    &quot;&quot;&quot;
    
    # any other bindings not in headers
    c&quot;&quot;&quot;
      struct FooStruct {
        struct BarStruct bs;
      };
      
      extern struct FooStruct *foo_like_its_the_80s(int i);
    &quot;&quot;&quot;
  end
  
  
  # high-level Julian interface to libfoo
  using CBinding
  using .libfoo
  
  function foo(i)
    ptr = c&quot;foo_like_its_the_80s&quot;(Cint(i-1))
    try
      return JulianFoo(ptr[])
    finally
      Libc.free(ptr)
    end
  end
end"><pre><span class="pl-k">module</span> LibFoo
  <span class="pl-k">module</span> libfoo
    <span class="pl-k">import</span> Foo_jll
    <span class="pl-k">using</span> CBinding
    
    <span class="pl-c"><span class="pl-c">#</span> libfoo has libbar as a dep, and LibBar has bindings for it</span>
    <span class="pl-k">using</span> LibBar<span class="pl-k">:</span> libbar
    
    <span class="pl-c"><span class="pl-c">#</span> set up the parser</span>
    <span class="pl-k">let</span>
      incdir <span class="pl-k">=</span> <span class="pl-c1">joinpath</span>(Foo_jll<span class="pl-k">.</span>artifact_dir, <span class="pl-s"><span class="pl-pds">"</span>include<span class="pl-pds">"</span></span>)
      libdir <span class="pl-k">=</span> <span class="pl-c1">dirname</span>(Foo_jll<span class="pl-k">.</span>libfoo_path)
      
      <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span>-std=c99 -fparse-all-comments -I$(incdir) -L$(libdir) -lfoo<span class="pl-pds">`</span></span>
    <span class="pl-k">end</span>
    
    <span class="pl-c"><span class="pl-c">#</span> libfoo refers to some std C sized types (eventually made available with something like `using C99`)</span>
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>int32_t<span class="pl-pds">"</span></span>  <span class="pl-k">=</span> Int32
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>int64_t<span class="pl-pds">"</span></span>  <span class="pl-k">=</span> Int64
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>uint32_t<span class="pl-pds">"</span></span> <span class="pl-k">=</span> UInt32
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>uint64_t<span class="pl-pds">"</span></span> <span class="pl-k">=</span> UInt64
    
    <span class="pl-c"><span class="pl-c">#</span> generate bindings for libfoo</span>
    <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">      #include &lt;libfoo/header-1.h&gt;</span>
<span class="pl-s">      #include &lt;libfoo/header-2.h&gt;</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    
    <span class="pl-c"><span class="pl-c">#</span> any other bindings not in headers</span>
    <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">      struct FooStruct {</span>
<span class="pl-s">        struct BarStruct bs;</span>
<span class="pl-s">      };</span>
<span class="pl-s">      </span>
<span class="pl-s">      extern struct FooStruct *foo_like_its_the_80s(int i);</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
  <span class="pl-k">end</span>
  
  
  <span class="pl-c"><span class="pl-c">#</span> high-level Julian interface to libfoo</span>
  <span class="pl-k">using</span> CBinding
  <span class="pl-k">using</span> <span class="pl-k">.</span>libfoo
  
  <span class="pl-k">function</span> <span class="pl-en">foo</span>(i)
    ptr <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>foo_like_its_the_80s<span class="pl-pds">"</span></span>(<span class="pl-c1">Cint</span>(i<span class="pl-k">-</span><span class="pl-c1">1</span>))
    <span class="pl-k">try</span>
      <span class="pl-k">return</span> <span class="pl-c1">JulianFoo</span>(ptr[])
    <span class="pl-k">finally</span>
      Libc<span class="pl-k">.</span><span class="pl-c1">free</span>(ptr)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-options-for-c" class="anchor" aria-hidden="true" href="#options-for-c"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Options for <code>c"..."</code></h2>
<p dir="auto">The string macro has some options to handle more complex use cases.
Occasionally it is necessary to include or define C code that is just a dependency and should not be exported or perhaps excluded from the generated bindings altogether.
These kinds of situations can be handled with combinations of the following string macro suffixes.</p>
<ul dir="auto">
<li><code>d</code> - defer conversion of the C code block; successive blocks marked with <code>d</code> will keep deferring until a block without it (its options will be used for processing the deferred blocks)</li>
<li><code>f</code> - don't create bindings for <code>extern</code> functions</li>
<li><code>i</code> - also parse implicitly included headers that are related (in the same directory or subdirectories) to explicitly included headers</li>
<li><code>j</code> - provide additional bindings using Julian names (name collisions likely)</li>
<li><code>J</code> - provide additional bindings using Julian names with annotated user-defined types (using <code>struct_</code>, <code>union_</code>, or <code>enum_</code> prefixes)</li>
<li><code>m</code> - skip conversion of C macros</li>
<li><code>n</code> - show warnings for macros or inline functions that are skipped (and other conversion issues)</li>
<li><code>p</code> - mark the C code as "private" content that will not be exported</li>
<li><code>q</code> - quietly parse the block of C code, suppressing any compiler/linker messages</li>
<li><code>r</code> - the C code is only a reference to something in C-land and bindings are not to be generated</li>
<li><code>s</code> - skip processing of this block of C code</li>
<li><code>t</code> - skip conversion of C types</li>
<li><code>u</code> - leave this block of C code undocumented</li>
<li><code>v</code> - don't create bindings for <code>extern</code> variables</li>
<li><code>w</code> - create bindings for inline functions by using wrapper libraries (somewhat experimental)</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; c&quot;&quot;&quot;
         #include &lt;stdio.h&gt;  // provides FILE type, but skip emitting bindings for this block
       &quot;&quot;&quot;s;

julia&gt; c&quot;&quot;&quot;
         struct File {  // do not include this type in module exports, and suppress compiler messages
           FILE *f;
         };
       &quot;&quot;&quot;pq;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         #include &lt;stdio.h&gt;  // provides FILE type, but skip emitting bindings for this block</span>
<span class="pl-s">       <span class="pl-pds">"""</span><span class="pl-c1">s</span></span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct File {  // do not include this type in module exports, and suppress compiler messages</span>
<span class="pl-s">           FILE *f;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""</span><span class="pl-c1">pq</span></span>;</pre></div>
<h1 dir="auto"><a id="user-content-using-cbindingjl-generated-bindings" class="anchor" aria-hidden="true" href="#using-cbindingjl-generated-bindings"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using <code>CBinding.jl</code>-generated bindings</h1>
<p dir="auto">The <code>c"..."</code> string macro can be used to refer to any of the types, global variables, or functions generated by CBinding.jl.
When simply referencing the C content, setting up a compiler context (i.e. using <code>c`...`</code>) is not necessary.</p>
<p dir="auto">The <code>c"..."</code> string macro can take on two meanings depending on the content placed in it.
So to guarantee it is interpreted as a reference to something in C, rather than a block of C code to create bindings with, include an <code>r</code> in the string macro options.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; module MyLib  # generally some C bindings are defined elsewhere
         using CBinding
         
         c`-std=c99 -Wall -Imy/include`
         
         c&quot;&quot;&quot;
           struct S;
           struct T {
             int i;
             struct S *s;
             struct T *t;
           };
           
           extern void func(struct S *s, struct T t);
         &quot;&quot;&quot;
       end

julia&gt; using CBinding, .MyLib

julia&gt; c&quot;struct T&quot; &lt;: Cstruct
true

julia&gt; c&quot;struct T&quot;r &lt;: Cstruct  # use 'r' option to guarantee it is treated as a reference
true

julia&gt; t = c&quot;struct T&quot;(i = 123);

julia&gt; t.i
123"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">module</span> MyLib  <span class="pl-c"><span class="pl-c">#</span> generally some C bindings are defined elsewhere</span>
         <span class="pl-k">using</span> CBinding
         
         <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span>-std=c99 -Wall -Imy/include<span class="pl-pds">`</span></span>
         
         <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">           struct S;</span>
<span class="pl-s">           struct T {</span>
<span class="pl-s">             int i;</span>
<span class="pl-s">             struct S *s;</span>
<span class="pl-s">             struct T *t;</span>
<span class="pl-s">           };</span>
<span class="pl-s">           </span>
<span class="pl-s">           extern void func(struct S *s, struct T t);</span>
<span class="pl-s">         <span class="pl-pds">"""</span></span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> CBinding, <span class="pl-k">.</span>MyLib

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct T<span class="pl-pds">"</span></span> <span class="pl-k">&lt;:</span> <span class="pl-c1">Cstruct</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct T<span class="pl-pds">"</span><span class="pl-c1">r</span></span> <span class="pl-k">&lt;:</span> <span class="pl-c1">Cstruct</span>  <span class="pl-c"><span class="pl-c">#</span> use 'r' option to guarantee it is treated as a reference</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> t <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct T<span class="pl-pds">"</span></span>(i <span class="pl-k">=</span> <span class="pl-c1">123</span>);

julia<span class="pl-k">&gt;</span> t<span class="pl-k">.</span>i
<span class="pl-c1">123</span></pre></div>
<p dir="auto">The user-defined types (<code>enum</code>, <code>struct</code>, and <code>union</code>) are referenced just as they are in C (e.g. <code>c"enum E"</code>, <code>c"struct S"</code>, and <code>c"union U"</code>).
All other types, pointers, arrays, global variables, enumeration constants, functions, etc. are also referenced just as they are in C.
Here is a quick reference for C string macro usage:</p>
<ul dir="auto">
<li><code>c"int"</code> - the <code>Cint</code> type</li>
<li><code>c"int[2]"</code> - a length-2 static array of <code>Cint</code>'s</li>
<li><code>c"int[2][4]"</code> - a length-2 static array of length-4 static arrays of <code>Cint</code>'s</li>
<li><code>c"int *"</code> - pointer to a <code>Cint</code></li>
<li><code>c"int **"</code> - pointer to a pointer to a <code>Cint</code></li>
<li><code>c"int const **"</code> - pointer to a pointer to a read-only <code>Cint</code></li>
<li><code>c"enum MyUnion"</code> - a user-defined C <code>enum</code> type</li>
<li><code>c"union MyUnion"</code> - a user-defined C <code>union</code> type</li>
<li><code>c"struct MyStruct"</code> - a user-defined C <code>struct</code> type</li>
<li><code>c"struct MyStruct *"</code> - a pointer to a user-defined C <code>struct</code> type</li>
<li><code>c"struct MyStruct[2]"</code> - a length-2 static array of user-defined C <code>struct</code> type</li>
<li><code>c"MyStruct"</code> - a user-defined <code>typedef</code>-ed type</li>
<li><code>c"MyStruct *"</code> - a pointer to a user-defined <code>typedef</code>-ed type</li>
<li><code>c"printf"</code> - a C function (specifically the <code>printf</code> function)</li>
<li><code>c"int (*)(int, int)"</code> - a function pointer</li>
<li><code>c"int (*)(char const *, ...)"</code> - a variadic function pointer</li>
</ul>
<p dir="auto">The following examples demonstrate how to refer to C-land content that resides in other modules and is not exported/imported:</p>
<ul dir="auto">
<li><code>c"SomeModule.SubModule.enum MyUnion"</code></li>
<li><code>c"SomeModule.SubModule.struct MyStruct *"</code></li>
<li><code>c"SomeModule.SubModule.printf"</code></li>
<li><code>c"int (*)(Some.Other.Module.struct MyStruct *, ...)"</code></li>
</ul>
<p dir="auto">The C string macro can also be used to expose Julia content to C-land.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; const c&quot;IntPtr&quot; = Cptr{Cint};

julia&gt; c&quot;void (*)(IntPtr, IntPtr *, IntPtr[2])&quot; &lt;: Cptr{&lt;:Cfunction}
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>IntPtr<span class="pl-pds">"</span></span> <span class="pl-k">=</span> Cptr{Cint};

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>void (*)(IntPtr, IntPtr *, IntPtr[2])<span class="pl-pds">"</span></span> <span class="pl-k">&lt;:</span> <span class="pl-c1">Cptr{&lt;:Cfunction}</span>
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Type qualifiers are carried over from the C code.
As an example, <code>int const *</code> is a pointer to a read-only integer in is represented by CBinding.jl as the type <code>Cptr{Cconst{Cint}}</code>.
The <code>unqualifiedtype(T)</code> can be used to strip away the type qualifiers to get to the core type, so <code>unqualifiedtype(Cconst{Cint}) === Cint</code>.</p>
<p dir="auto"><a href="#any-gotchas">As detailed below</a>, the <code>bitstype(T)</code> function can be used to acquire the concrete bits type of user-defined C types as well.</p>
<h2 dir="auto"><a id="user-content-working-with-aggregate-types-and-sized-arrays" class="anchor" aria-hidden="true" href="#working-with-aggregate-types-and-sized-arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Working with aggregate types and sized arrays</h2>
<p dir="auto">User-defined aggregate types (<code>struct</code> and <code>union</code>) have several ways to be constructed:</p>
<ul dir="auto">
<li><code>t = c"struct T"()</code> - zero-ed immutable object</li>
<li><code>t = c"struct T"(i = 123)</code> - zero-ed immutable object with field <code>i</code> initialized to 123</li>
<li><code>t = c"struct T"(t, i = 321)</code> - copy of <code>t</code> with field <code>i</code> initialized to 321</li>
</ul>
<p dir="auto">These objects are immutable and changing fields will have no effect, so a copy must be constructed with the desired field overrides or <a href="#working-with-pointers">pointers must be used</a>.
Nested field access is transparent, and performance should match that of accessing fields within standard Julia immutable structs.</p>
<p dir="auto">Statically-sized arrays (i.e. <code>c"typedef int IntArray[4];"</code>) can be constructed:</p>
<ul dir="auto">
<li><code>t = c"IntArray"()</code> - zero-ed immutable array</li>
<li><code>t = c"IntArray"(1, 2)</code> - zero-ed immutable array with first 2 elements initialized to 1 and 2</li>
<li><code>t = c"IntArray"(t, 3)</code> - copy of <code>t</code> with first element initialized to 3</li>
<li><code>t = c"IntArray"(t, 4 =&gt; 123)</code> - copy of <code>t</code> with 4th element initialized to 123</li>
</ul>
<p dir="auto">Constructors for both aggregates and arrays can also accept nested <code>Tuple</code> and <code>NamedTuple</code> arguments which get splatted appropriately into the respective field's constructor.
A comprehensive example of constructing a complex C type and accessing fields/elements is shown below:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; c`` ; c&quot;&quot;&quot;
         struct A {
           struct {
             int i;
           };
           struct {
             struct {
               int i;
             } c[2];
           } b;
         };
       &quot;&quot;&quot;;

julia&gt; a = c&quot;struct A&quot;();

julia&gt; a.i
0

julia&gt; a.b.c[2].i
0

julia&gt; a = c&quot;struct A&quot;(i = 123, b = (c = ((i = 321,), (i = 654,)),));

julia&gt; a.i
123

julia&gt; a.b.c[2].i
654
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span><span class="pl-pds">`</span></span> ; <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct A {</span>
<span class="pl-s">           struct {</span>
<span class="pl-s">             int i;</span>
<span class="pl-s">           };</span>
<span class="pl-s">           struct {</span>
<span class="pl-s">             struct {</span>
<span class="pl-s">               int i;</span>
<span class="pl-s">             } c[2];</span>
<span class="pl-s">           } b;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct A<span class="pl-pds">"</span></span>();

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>i
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>b<span class="pl-k">.</span>c[<span class="pl-c1">2</span>]<span class="pl-k">.</span>i
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct A<span class="pl-pds">"</span></span>(i <span class="pl-k">=</span> <span class="pl-c1">123</span>, b <span class="pl-k">=</span> (c <span class="pl-k">=</span> ((i <span class="pl-k">=</span> <span class="pl-c1">321</span>,), (i <span class="pl-k">=</span> <span class="pl-c1">654</span>,)),));

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>i
<span class="pl-c1">123</span>

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>b<span class="pl-k">.</span>c[<span class="pl-c1">2</span>]<span class="pl-k">.</span>i
<span class="pl-c1">654</span>
</pre></div>
<h2 dir="auto"><a id="user-content-working-with-pointers" class="anchor" aria-hidden="true" href="#working-with-pointers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Working with pointers</h2>
<p dir="auto">CBinding.jl also works elegantly with pointers to aggregate types.
Pointers are followed through fields and array elements as they are accessed, and they can be dereferenced with <code>ptr[]</code> or written to with <code>ptr[] = val</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ptr = Libc.malloc(a);  # allocate a `struct A` as a copy of `a`

julia&gt; ptr.i
Cptr{Int32}(0x0000000003458810)

julia&gt; ptr.i[]
123

julia&gt; ptr.b.c[2].i
Cptr{Int32}(0x0000000003458814)

julia&gt; ptr.b.c[2].i[]
654

julia&gt; ptr.b.c[2].i[] = 42
42

julia&gt; Libc.free(ptr)  # deallocate it"><pre>julia<span class="pl-k">&gt;</span> ptr <span class="pl-k">=</span> Libc<span class="pl-k">.</span><span class="pl-c1">malloc</span>(a);  <span class="pl-c"><span class="pl-c">#</span> allocate a `struct A` as a copy of `a`</span>

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>i
<span class="pl-c1">Cptr</span><span class="pl-c1">{Int32}</span>(<span class="pl-c1">0x0000000003458810</span>)

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>i[]
<span class="pl-c1">123</span>

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>b<span class="pl-k">.</span>c[<span class="pl-c1">2</span>]<span class="pl-k">.</span>i
<span class="pl-c1">Cptr</span><span class="pl-c1">{Int32}</span>(<span class="pl-c1">0x0000000003458814</span>)

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>b<span class="pl-k">.</span>c[<span class="pl-c1">2</span>]<span class="pl-k">.</span>i[]
<span class="pl-c1">654</span>

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>b<span class="pl-k">.</span>c[<span class="pl-c1">2</span>]<span class="pl-k">.</span>i[] <span class="pl-k">=</span> <span class="pl-c1">42</span>
<span class="pl-c1">42</span>

julia<span class="pl-k">&gt;</span> Libc<span class="pl-k">.</span><span class="pl-c1">free</span>(ptr)  <span class="pl-c"><span class="pl-c">#</span> deallocate it</span></pre></div>
<p dir="auto">An exception to the rule is bitfields.
It is not possible to refer to bitfields with a pointer, so access to bitfields is automatically dereferenced.</p>
<h2 dir="auto"><a id="user-content-using-global-variable-and-function-bindings" class="anchor" aria-hidden="true" href="#using-global-variable-and-function-bindings"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using global variable and function bindings</h2>
<p dir="auto">Bindings to global variables also behave as if they are pointers, and must be dereferenced to be read or written.
Fields and elements can be followed through the same as with pointers.
Bindings to functions can be called directly, and getting the pointer to a one can be done with the "dereferencing" (<code>func[]</code>) syntax in case a bound function must be used as a callback function.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; c&quot;func&quot;(Cint(1), Cint(2));  # call the C function directly

julia&gt; funcptr = c&quot;func&quot;[]
Cptr{Cfunction{Int32, Tuple{Int32, Int32}, :cdecl}}(0x00007f8f50722b10)

julia&gt; funcptr(Cint(1), Cint(2));  # call the C function pointer"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>func<span class="pl-pds">"</span></span>(<span class="pl-c1">Cint</span>(<span class="pl-c1">1</span>), <span class="pl-c1">Cint</span>(<span class="pl-c1">2</span>));  <span class="pl-c"><span class="pl-c">#</span> call the C function directly</span>

julia<span class="pl-k">&gt;</span> funcptr <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>func<span class="pl-pds">"</span></span>[]
<span class="pl-c1">Cptr</span><span class="pl-c1">{Cfunction{Int32, Tuple{Int32, Int32}, :cdecl}}</span>(<span class="pl-c1">0x00007f8f50722b10</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">funcptr</span>(<span class="pl-c1">Cint</span>(<span class="pl-c1">1</span>), <span class="pl-c1">Cint</span>(<span class="pl-c1">2</span>));  <span class="pl-c"><span class="pl-c">#</span> call the C function pointer</span></pre></div>
<h2 dir="auto"><a id="user-content-using-julia-functions-in-c" class="anchor" aria-hidden="true" href="#using-julia-functions-in-c"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using Julia functions in C</h2>
<p dir="auto">Providing a Julia method to C as a callback function has never been easier!
Just pass it as an argument to the CBinding.jl function binding or function pointer.
Assuming a binding to a C function, like <code>void set_callback(int (*cb)(int, int))</code> exists:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; function myadd(a, b)  # a callback function to give to C
         return a+b
       end;

julia&gt; c&quot;set_callback&quot;(myadd)  # that's it!

julia&gt; function saferadd(a::Cint, b::Cint)::Cint  # a safer callback function might require type paranoia
         return a+b
       end;

julia&gt; c&quot;set_callback&quot;(saferadd)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">myadd</span>(a, b)  <span class="pl-c"><span class="pl-c">#</span> a callback function to give to C</span>
         <span class="pl-k">return</span> a<span class="pl-k">+</span>b
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>set_callback<span class="pl-pds">"</span></span>(myadd)  <span class="pl-c"><span class="pl-c">#</span> that's it!</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">saferadd</span>(a<span class="pl-k">::</span><span class="pl-c1">Cint</span>, b<span class="pl-k">::</span><span class="pl-c1">Cint</span>)<span class="pl-k">::</span><span class="pl-c1">Cint</span>  <span class="pl-c"><span class="pl-c">#</span> a safer callback function might require type paranoia</span>
         <span class="pl-k">return</span> a<span class="pl-k">+</span>b
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>set_callback<span class="pl-pds">"</span></span>(saferadd)</pre></div>
<h2 dir="auto"><a id="user-content-getting-help" class="anchor" aria-hidden="true" href="#getting-help"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting help</h2>
<p dir="auto">Unless explicitly disabled, the generated bindings include doc-strings.
An attempt is made at converting any structured comments from the C blocks into somewhat equivalent doc-strings, as this example illustrates:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="help?&gt; libsdl2.SDL_CreateRGBSurface
  extern SDL_Surface *SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)

  Defined at SDL_surface.h:130 (file:///usr/include/SDL2/SDL_surface.h)

   Allocate and free an RGB surface.

  Details
  =========

   If the depth is 4 or 8 bits, an empty palette is allocated for the surface. If the depth is greater than 8 bits, the pixel format is set
  using the flags '[RGB]mask'.

   If the function runs out of memory, it will return NULL.

  Parameters
  ============

    •    flags: The flags are obsolete and should be set to 0. 

    •    width: The width in pixels of the surface to create. 

    •    height: The height in pixels of the surface to create. 

    •    depth: The depth in bits of the surface to create. 

    •    Rmask: The red mask of the surface to create. 

    •    Gmask: The green mask of the surface to create. 

    •    Bmask: The blue mask of the surface to create. 

    •    Amask: The alpha mask of the surface to create.
"><pre>help?<span class="pl-k">&gt;</span> libsdl2<span class="pl-k">.</span>SDL_CreateRGBSurface
  extern SDL_Surface <span class="pl-k">*</span><span class="pl-c1">SDL_CreateRGBSurface</span>(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)

  Defined at SDL_surface<span class="pl-k">.</span>h<span class="pl-k">:</span><span class="pl-c1">130</span> (file<span class="pl-k">:</span><span class="pl-k">///</span>usr<span class="pl-k">/</span>include<span class="pl-k">/</span>SDL2<span class="pl-k">/</span>SDL_surface<span class="pl-k">.</span>h)

   Allocate and free an RGB surface.

  Details
  <span class="pl-k">=========</span>

   If the depth is <span class="pl-c1">4</span> or <span class="pl-c1">8</span> bits, an empty palette is allocated <span class="pl-k">for</span> the surface. If the depth is greater than <span class="pl-c1">8</span> bits, the pixel format is set
  <span class="pl-k">using</span> the flags <span class="pl-s"><span class="pl-pds">'</span>[RGB]mask<span class="pl-pds">'</span></span>.

   If the <span class="pl-k">function</span> runs out of memory, it will <span class="pl-k">return</span> NULL.

  Parameters
  <span class="pl-k">============</span>

    •    flags<span class="pl-k">:</span> The flags are obsolete and should be set to <span class="pl-c1">0.</span> 

    •    width<span class="pl-k">:</span> The width <span class="pl-k">in</span> pixels of the surface to create. 

    •    height<span class="pl-k">:</span> The height <span class="pl-k">in</span> pixels of the surface to create. 

    •    depth<span class="pl-k">:</span> The depth <span class="pl-k">in</span> bits of the surface to create. 

    •    Rmask<span class="pl-k">:</span> The red mask of the surface to create. 

    •    Gmask<span class="pl-k">:</span> The green mask of the surface to create. 

    •    Bmask<span class="pl-k">:</span> The blue mask of the surface to create. 

    •    Amask<span class="pl-k">:</span> The alpha mask of the surface to create.
</pre></div>
<p dir="auto">However, if such exquisite documentation cannot be generated, the doc-string simply conveys the item's original C definition:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="help?&gt; libclang.clang_visitChildren
  unsigned int clang_visitChildren(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data)

  Defined at Index.h:4189 (file:///usr/include/clang-c/Index.h)

help?&gt; libclang.CXCursor
  struct {
      enum CXCursorKind kind;
      int xdata;
      const void *data[3];
  }

  Defined at Index.h:2664 (file:///usr/include/clang-c/Index.h)"><pre>help?<span class="pl-k">&gt;</span> libclang<span class="pl-k">.</span>clang_visitChildren
  unsigned int <span class="pl-c1">clang_visitChildren</span>(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data)

  Defined at Index<span class="pl-k">.</span>h<span class="pl-k">:</span><span class="pl-c1">4189</span> (file<span class="pl-k">:</span><span class="pl-k">///</span>usr<span class="pl-k">/</span>include<span class="pl-k">/</span>clang<span class="pl-k">-</span>c<span class="pl-k">/</span>Index<span class="pl-k">.</span>h)

help?<span class="pl-k">&gt;</span> libclang<span class="pl-k">.</span>CXCursor
  <span class="pl-k">struct</span> {
      enum CXCursorKind kind;
      int xdata;
      <span class="pl-k">const</span> void <span class="pl-k">*</span>data[<span class="pl-c1">3</span>];
  }

  Defined at Index<span class="pl-k">.</span>h<span class="pl-k">:</span><span class="pl-c1">2664</span> (file<span class="pl-k">:</span><span class="pl-k">///</span>usr<span class="pl-k">/</span>include<span class="pl-k">/</span>clang<span class="pl-k">-</span>c<span class="pl-k">/</span>Index<span class="pl-k">.</span>h)</pre></div>
<p dir="auto">Check for comments near the referenced definition location for C documentation that libclang failed to associate with the binding.</p>
<h1 dir="auto"><a id="user-content-any-gotchas" class="anchor" aria-hidden="true" href="#any-gotchas"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Any gotchas?</h1>
<p dir="auto">Since Julia does not yet provide <code>incomplete type</code> (please voice your support of the feature here: <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="2410256" data-permission-text="Title is private" data-url="https://github.com/JuliaLang/julia/issues/269" data-hovercard-type="issue" data-hovercard-url="/JuliaLang/julia/issues/269/hovercard" href="https://github.com/JuliaLang/julia/issues/269">JuliaLang/julia#269</a>), abstract types are used to allow forward declarations in C.
Therefore, referencing C types usually refers to the abstract type which can have significant implications when creating Julia arrays, using <code>ccall</code>, etc.
The following example illustrates this kind of unexpected behavior:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; struct X
         i::Cint
       end

julia&gt; const Y = c&quot;&quot;&quot;
         struct Y {
           int i;
         };
       &quot;&quot;&quot;

julia&gt; [X(123)] isa Vector{X}
true

julia&gt; [Y(i=123)] isa Vector{Y}
false

julia&gt; [Y(i=123)] isa Vector{bitstype(Y)}
true
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> X
         i<span class="pl-k">::</span><span class="pl-c1">Cint</span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> Y <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct Y {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>

julia<span class="pl-k">&gt;</span> [<span class="pl-c1">X</span>(<span class="pl-c1">123</span>)] <span class="pl-k">isa</span> Vector{X}
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> [<span class="pl-c1">Y</span>(i<span class="pl-k">=</span><span class="pl-c1">123</span>)] <span class="pl-k">isa</span> Vector{Y}
<span class="pl-c1">false</span>

julia<span class="pl-k">&gt;</span> [<span class="pl-c1">Y</span>(i<span class="pl-k">=</span><span class="pl-c1">123</span>)] <span class="pl-k">isa</span> Vector{<span class="pl-c1">bitstype</span>(Y)}
<span class="pl-c1">true</span>
</pre></div>
<p dir="auto">The <code>bitstype(T)</code> function can be used to acquire the concrete bits type of any C type when the distinction matters.</p>
<p dir="auto">Another implementation detail worth noting is that function bindings are brought into Julia as singleton constants, not as actual functions.
This approach allows a user to obtain function pointers from C functions in case one must be used as a callback function.
Therefore, attaching other methods to a bound C function is not possible.</p>
<p dir="auto">It is also sometimes necessary to use the <code>c"..."</code> mangled names directly in Julia (for instance in the REPL help mode).
Until consistent, universal support for the string macro is available, the mangled names can be used directly as <code>var"c\"...\""</code>, like <code>help?&gt; var"c\"struct Y\""</code>.</p>
<p dir="auto">When a C function has a statically-sized array as an argument in its signature, the semantics of C is to treat the argument as a pointer instead.
Therefore, the statically-sized array in the binding signature will be lowered to a pointer for the underlying <code>ccall</code>.
A user can then pass any argument (array, pointer, etc.) that is compatible with a pointer argument type (not the anticipated statically-sized array type).</p>
<h1 dir="auto"><a id="user-content-some-helpful-tips" class="anchor" aria-hidden="true" href="#some-helpful-tips"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Some helpful tips</h1>
<p dir="auto">Thorough tutorials and examples should be developed illustrating the countless scenarios that could be encountered when interfacing C from Julia in an automated manner.
However, until such a body of a work is available, the following list of hopefully helpful comments will have to suffice:</p>
<ul dir="auto">
<li>Documentation comments are not converted?
Try adding <code>-fparse-all-comments</code> to your compiler context command.</li>
<li>Encounter syntax/types that are not yet supported errors?
Try disabling compiler extensions (e.g. <code>-fno-blocks</code>) or specifying a language standard (such as <code>-std=c99</code>).</li>
<li>Are some functions or macros missing from the generated bindings?
See warnings if CBinding.jl skips anything by using the 'n' string macro option (like <code>c"..."n</code>).</li>
<li>Are there undefined references to C library items (such as <code>uint8_t</code>, <code>FILE</code>, or <code>va_list</code>)?
Until C library modules are published, define these symbols using existing Julia types:
<code>const c"uint8_t" = UInt8</code>, <code>const c"FILE" = Cvoid</code>, <code>const c"va_list" = Cvoid</code>, etc.</li>
</ul>
</article></div>