<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-magmathermokinematicsjl" class="anchor" aria-hidden="true" href="#magmathermokinematicsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MagmaThermoKinematics.jl</h1>
<p dir="auto"><a href="https://github.com/boriskaus/MagmaThermoKinematics.jl/actions"><img src="https://github.com/boriskaus/MagmaThermoKinematics.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto">Understanding how magmatic systems work is of interest to a wide range of Earth Scientists.</p>
<p dir="auto">This easy to use and versatile package simulates the thermal evolution of magmatic systems following the intrusion of dikes and sills. It can take 2D, 2D axisymmetric and 3D geometries into account, and works on both parallel CPU's and GPU's. A finite difference discretization is employed for the energy equation, combined with semi-Lagrangian advection and tracers to track the thermal evolution of emplaced magma. Dikes are emplaced kinematically and the host rock is shifted to accommodate space for the intruding dikes/sills, in a number of ways including by using analytical models for penny-shaped cracks in elastic media. Cooling, crystallizing and latent heat effects are taken into account, and the thermal evolution of tracers can be used to simulate zircon age distributions.</p>
<p dir="auto">Below we give a number of example scripts that show how it can be used to simulate a number of scenarios.</p>
<h2 dir="auto"><a id="user-content-contents" class="anchor" aria-hidden="true" href="#contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contents</h2>
<ul dir="auto">
<li><a href="#100-lines-2d-example">100-lines 2D example</a></li>
<li><a href="#100-lines-3d-example">100-lines 3D example</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#installation">Installation</a></li>
</ul>
<h2 dir="auto"><a id="user-content-100-lines-2d-example" class="anchor" aria-hidden="true" href="#100-lines-2d-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>100-lines 2D example</h2>
<p dir="auto">A simple example that simulates the emplacement of dikes within the crust over a period of 10'000 years is shown below.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="examples/movies/Example2D.gif"><img src="examples/movies/Example2D.gif" alt="2-D dike intrusion" data-animated-image="" style="max-width: 100%;"></a></p>
<p dir="auto">The code to simulate this, including visualization, is only 100 lines and the key parts of it are shown below</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MagmaThermoKinematics
const USE_GPU=false;
if USE_GPU  environment!(:gpu, Float64, 2)      # initialize parallel stencil in 2D
else        environment!(:cpu, Float64, 2)      # initialize parallel stencil in 2D
end
using MagmaThermoKinematics.Diffusion2D # to load AFTER calling environment!()
using Plots                                     

#------------------------------------------------------------------------------------------
@views function MainCode_2D();

Nx,Nz                   =   500,500
Grid                    =   CreateGrid(size=(Nx,Nz), extent=(30e3, 30e3)) # grid points &amp; domain size
Num                     =   Numeric_params(verbose=false)                   # Nonlinear solver options

# Set material parameters                                       
MatParam                =   (
        SetMaterialParams(Name=&quot;Rock&quot;, Phase=1, 
             Density    = ConstantDensity(ρ=2800kg/m^3),               
           HeatCapacity = ConstantHeatCapacity(cp=1050J/kg/K),
           Conductivity = ConstantConductivity(k=1.5Watt/K/m),       
             LatentHeat = ConstantLatentHeat(Q_L=350e3J/kg),
                Melting = MeltingParam_Caricchi()),
                            )      

GeoT                    =   20.0/1e3;                   # Geothermal gradient [K/km]
W_in, H_in              =   5e3,    0.2e3;              # Width and thickness of dike
T_in                    =   900;                        # Intrusion temperature
InjectionInterval       =   0.1kyr;                     # Inject a new dike every X kyrs
maxTime                 =   25kyr;                      # Maximum simulation time in kyrs
H_ran, W_ran            =   Grid.L.*[0.3; 0.4];         # Size of domain in which we randomly place dikes and range of angles   
DikeType                =   &quot;ElasticDike&quot;               # Type to be injected (&quot;ElasticDike&quot;,&quot;SquareDike&quot;)
κ                       =   1.2/(2800*1050);            # thermal diffusivity   
dt                      =   minimum(Grid.Δ.^2)/κ/10;    # stable timestep (required for explicit FD)
nt                      =   floor(Int64,maxTime/dt);    # number of required timesteps
nTr_dike                =   300;                        # number of tracers inserted per dike

# Array initializations
Arrays = CreateArrays(Dict( (Nx,  Nz)=&gt;(T=0,T_K=0, T_it_old=0, K=1.5, Rho=2800, Cp=1050, Tnew=0,  Hr=0, Hl=0, Kc=1, P=0, X=0, Z=0, ϕₒ=0, ϕ=0, dϕdT=0),
                            (Nx-1,Nz)=&gt;(qx=0,Kx=0), (Nx, Nz-1)=&gt;(qz=0,Kz=0 ) ))
# CPU buffers 
Tnew_cpu                =   Matrix{Float64}(undef, Grid.N...)
Phi_melt_cpu            =   similar(Tnew_cpu)
if USE_GPU; Phases      =   CUDA.ones(Int64,Grid.N...)
else        Phases      =   ones(Int64,Grid.N...)   end
@parallel (1:Nx, 1:Nz) GridArray!(Arrays.X,  Arrays.Z, Grid.coord1D[1], Grid.coord1D[2])   
Tracers                 =   StructArray{Tracer}(undef, 1)                           # Initialize tracers   
dike                    =   Dike(W=W_in,H=H_in,Type=DikeType,T=T_in);               # &quot;Reference&quot; dike with given thickness,radius and T
Arrays.T               .=   -Arrays.Z.*GeoT;                                        # Initial (linear) temperature profile

# Preparation of visualisation
ENV[&quot;GKSwstype&quot;]=&quot;nul&quot;; if isdir(&quot;viz2D_out&quot;)==false mkdir(&quot;viz2D_out&quot;) end; loadpath = &quot;./viz2D_out/&quot;; anim = Animation(loadpath,String[])

time, dike_inj, InjectVol, Time_vec,Melt_Time = 0.0, 0.0, 0.0,zeros(nt,1),zeros(nt,1);
for it = 1:nt   # Time loop

    if floor(time/InjectionInterval)&gt; dike_inj       # Add new dike every X years
        dike_inj  =     floor(time/InjectionInterval)                                               # Keeps track on what was injected already
        cen       =     (Grid.max .+ Grid.min)./2 .+ rand(-0.5:1e-3:0.5, 2).*[W_ran;H_ran];         # Randomly vary center of dike 
        if cen[end]&lt;-12e3;  Angle_rand = rand( 80.0:0.1:100.0)                                      # Orientation: near-vertical @ depth             
        else                Angle_rand = rand(-10.0:0.1:10.0); end                                  # Orientation: near-vertical @ shallower depth     
        dike      =     Dike(dike, Center=cen[:],Angle=[Angle_rand]);                               # Specify dike with random location/angle but fixed size/T 
        Tnew_cpu .=     Array(Arrays.T)
        Tracers, Tnew_cpu, Vol   =   InjectDike(Tracers, Tnew_cpu, Grid.coord1D, dike, nTr_dike);   # Add dike, move hostrocks
        Arrays.T .=     Data.Array(Tnew_cpu)
        InjectVol +=    Vol                                                                 # Keep track of injected volume
        println(&quot;Added new dike; total injected magma volume = $(round(InjectVol/km³,digits=2)) km³; rate Q=$(round(InjectVol/(time),digits=2)) m³/s&quot;)
    end
    
    Nonlinear_Diffusion_step_2D!(Arrays, MatParam, Phases, Grid, dt, Num)   # Perform a nonlinear diffusion step
    
    copy_arrays_GPU2CPU!(Tnew_cpu, Phi_melt_cpu, Arrays.Tnew, Arrays.ϕ)     # Copy arrays to CPU to update properties
    UpdateTracers_T_ϕ!(Tracers, Grid.coord1D, Tnew_cpu, Phi_melt_cpu);      # Update info on tracers 
    
    @parallel assign!(Arrays.T, Arrays.Tnew)
    @parallel assign!(Arrays.Tnew, Arrays.T)                                # Update temperature
    time                =   time + dt;                                      # Keep track of evolved time
    Melt_Time[it]       =   sum(Arrays.ϕ)/prod(Grid.N)                      # Melt fraction in crust    
    Time_vec[it]        =   time;                                           # Vector with time
    println(&quot; Timestep $it = $(round(time/kyr*100)/100) kyrs&quot;)
    
    if mod(it,20)==0  # Visualisation
        x,z         =   Grid.coord1D[1], Grid.coord1D[2]
        p1          =   heatmap(x/1e3, z/1e3, Array(Arrays.T)',  aspect_ratio=1, xlims=(x[1]/1e3,x[end]/1e3), ylims=(z[1]/1e3,z[end]/1e3),   c=:lajolla, clims=(0.,900.), xlabel=&quot;Width [km]&quot;,ylabel=&quot;Depth [km]&quot;, title=&quot;$(round(time/kyr, digits=2)) kyrs&quot;, dpi=200, fontsize=6, colorbar_title=&quot;Temperature&quot;)
        p2          =   heatmap(x/1e3,z/1e3, Array(Arrays.ϕ)',  aspect_ratio=1, xlims=(x[1]/1e3,x[end]/1e3), ylims=(z[1]/1e3,z[end]/1e3),   c=:nuuk,    clims=(0., 1. ), xlabel=&quot;Width [km]&quot;,             dpi=200, fontsize=6, colorbar_title=&quot;Melt Fraction&quot;)
        plot(p1, p2, layout=(1,2)); frame(anim)
    end
end
gif(anim, &quot;Example2D.gif&quot;, fps = 15)   # create gif animation
return Time_vec, Melt_Time;
end# end of main function

Time_vec,Melt_Time = MainCode_2D(); # start the main code
plot(Time_vec/kyr, Melt_Time, xlabel=&quot;Time [kyrs]&quot;, ylabel=&quot;Fraction of crust that is molten&quot;, label=:none); png(&quot;Time_vs_Melt_Example2D&quot;) # Create plot"><pre><span class="pl-k">using</span> MagmaThermoKinematics
<span class="pl-k">const</span> USE_GPU<span class="pl-k">=</span><span class="pl-c1">false</span>;
<span class="pl-k">if</span> USE_GPU  <span class="pl-c1">environment!</span>(<span class="pl-c1">:gpu</span>, Float64, <span class="pl-c1">2</span>)      <span class="pl-c"><span class="pl-c">#</span> initialize parallel stencil in 2D</span>
<span class="pl-k">else</span>        <span class="pl-c1">environment!</span>(<span class="pl-c1">:cpu</span>, Float64, <span class="pl-c1">2</span>)      <span class="pl-c"><span class="pl-c">#</span> initialize parallel stencil in 2D</span>
<span class="pl-k">end</span>
<span class="pl-k">using</span> MagmaThermoKinematics<span class="pl-k">.</span>Diffusion2D <span class="pl-c"><span class="pl-c">#</span> to load AFTER calling environment!()</span>
<span class="pl-k">using</span> Plots                                     

<span class="pl-c"><span class="pl-c">#</span>------------------------------------------------------------------------------------------</span>
<span class="pl-c1">@views</span> <span class="pl-k">function</span> <span class="pl-en">MainCode_2D</span>();

Nx,Nz                   <span class="pl-k">=</span>   <span class="pl-c1">500</span>,<span class="pl-c1">500</span>
Grid                    <span class="pl-k">=</span>   <span class="pl-c1">CreateGrid</span>(size<span class="pl-k">=</span>(Nx,Nz), extent<span class="pl-k">=</span>(<span class="pl-c1">30e3</span>, <span class="pl-c1">30e3</span>)) <span class="pl-c"><span class="pl-c">#</span> grid points &amp; domain size</span>
Num                     <span class="pl-k">=</span>   <span class="pl-c1">Numeric_params</span>(verbose<span class="pl-k">=</span><span class="pl-c1">false</span>)                   <span class="pl-c"><span class="pl-c">#</span> Nonlinear solver options</span>

<span class="pl-c"><span class="pl-c">#</span> Set material parameters                                       </span>
MatParam                <span class="pl-k">=</span>   (
        <span class="pl-c1">SetMaterialParams</span>(Name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Rock<span class="pl-pds">"</span></span>, Phase<span class="pl-k">=</span><span class="pl-c1">1</span>, 
             Density    <span class="pl-k">=</span> <span class="pl-c1">ConstantDensity</span>(ρ<span class="pl-k">=</span><span class="pl-c1">2800</span>kg<span class="pl-k">/</span>m<span class="pl-k">^</span><span class="pl-c1">3</span>),               
           HeatCapacity <span class="pl-k">=</span> <span class="pl-c1">ConstantHeatCapacity</span>(cp<span class="pl-k">=</span><span class="pl-c1">1050</span>J<span class="pl-k">/</span>kg<span class="pl-k">/</span>K),
           Conductivity <span class="pl-k">=</span> <span class="pl-c1">ConstantConductivity</span>(k<span class="pl-k">=</span><span class="pl-c1">1.5</span>Watt<span class="pl-k">/</span>K<span class="pl-k">/</span>m),       
             LatentHeat <span class="pl-k">=</span> <span class="pl-c1">ConstantLatentHeat</span>(Q_L<span class="pl-k">=</span><span class="pl-c1">350e3</span>J<span class="pl-k">/</span>kg),
                Melting <span class="pl-k">=</span> <span class="pl-c1">MeltingParam_Caricchi</span>()),
                            )      

GeoT                    <span class="pl-k">=</span>   <span class="pl-c1">20.0</span><span class="pl-k">/</span><span class="pl-c1">1e3</span>;                   <span class="pl-c"><span class="pl-c">#</span> Geothermal gradient [K/km]</span>
W_in, H_in              <span class="pl-k">=</span>   <span class="pl-c1">5e3</span>,    <span class="pl-c1">0.2e3</span>;              <span class="pl-c"><span class="pl-c">#</span> Width and thickness of dike</span>
T_in                    <span class="pl-k">=</span>   <span class="pl-c1">900</span>;                        <span class="pl-c"><span class="pl-c">#</span> Intrusion temperature</span>
InjectionInterval       <span class="pl-k">=</span>   <span class="pl-c1">0.1</span>kyr;                     <span class="pl-c"><span class="pl-c">#</span> Inject a new dike every X kyrs</span>
maxTime                 <span class="pl-k">=</span>   <span class="pl-c1">25</span>kyr;                      <span class="pl-c"><span class="pl-c">#</span> Maximum simulation time in kyrs</span>
H_ran, W_ran            <span class="pl-k">=</span>   Grid<span class="pl-k">.</span>L<span class="pl-k">.*</span>[<span class="pl-c1">0.3</span>; <span class="pl-c1">0.4</span>];         <span class="pl-c"><span class="pl-c">#</span> Size of domain in which we randomly place dikes and range of angles   </span>
DikeType                <span class="pl-k">=</span>   <span class="pl-s"><span class="pl-pds">"</span>ElasticDike<span class="pl-pds">"</span></span>               <span class="pl-c"><span class="pl-c">#</span> Type to be injected ("ElasticDike","SquareDike")</span>
κ                       <span class="pl-k">=</span>   <span class="pl-c1">1.2</span><span class="pl-k">/</span>(<span class="pl-c1">2800</span><span class="pl-k">*</span><span class="pl-c1">1050</span>);            <span class="pl-c"><span class="pl-c">#</span> thermal diffusivity   </span>
dt                      <span class="pl-k">=</span>   <span class="pl-c1">minimum</span>(Grid<span class="pl-k">.</span>Δ<span class="pl-k">.^</span><span class="pl-c1">2</span>)<span class="pl-k">/</span>κ<span class="pl-k">/</span><span class="pl-c1">10</span>;    <span class="pl-c"><span class="pl-c">#</span> stable timestep (required for explicit FD)</span>
nt                      <span class="pl-k">=</span>   <span class="pl-c1">floor</span>(Int64,maxTime<span class="pl-k">/</span>dt);    <span class="pl-c"><span class="pl-c">#</span> number of required timesteps</span>
nTr_dike                <span class="pl-k">=</span>   <span class="pl-c1">300</span>;                        <span class="pl-c"><span class="pl-c">#</span> number of tracers inserted per dike</span>

<span class="pl-c"><span class="pl-c">#</span> Array initializations</span>
Arrays <span class="pl-k">=</span> <span class="pl-c1">CreateArrays</span>(<span class="pl-c1">Dict</span>( (Nx,  Nz)<span class="pl-k">=&gt;</span>(T<span class="pl-k">=</span><span class="pl-c1">0</span>,T_K<span class="pl-k">=</span><span class="pl-c1">0</span>, T_it_old<span class="pl-k">=</span><span class="pl-c1">0</span>, K<span class="pl-k">=</span><span class="pl-c1">1.5</span>, Rho<span class="pl-k">=</span><span class="pl-c1">2800</span>, Cp<span class="pl-k">=</span><span class="pl-c1">1050</span>, Tnew<span class="pl-k">=</span><span class="pl-c1">0</span>,  Hr<span class="pl-k">=</span><span class="pl-c1">0</span>, Hl<span class="pl-k">=</span><span class="pl-c1">0</span>, Kc<span class="pl-k">=</span><span class="pl-c1">1</span>, P<span class="pl-k">=</span><span class="pl-c1">0</span>, X<span class="pl-k">=</span><span class="pl-c1">0</span>, Z<span class="pl-k">=</span><span class="pl-c1">0</span>, ϕₒ<span class="pl-k">=</span><span class="pl-c1">0</span>, ϕ<span class="pl-k">=</span><span class="pl-c1">0</span>, dϕdT<span class="pl-k">=</span><span class="pl-c1">0</span>),
                            (Nx<span class="pl-k">-</span><span class="pl-c1">1</span>,Nz)<span class="pl-k">=&gt;</span>(qx<span class="pl-k">=</span><span class="pl-c1">0</span>,Kx<span class="pl-k">=</span><span class="pl-c1">0</span>), (Nx, Nz<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">=&gt;</span>(qz<span class="pl-k">=</span><span class="pl-c1">0</span>,Kz<span class="pl-k">=</span><span class="pl-c1">0</span> ) ))
<span class="pl-c"><span class="pl-c">#</span> CPU buffers </span>
Tnew_cpu                <span class="pl-k">=</span>   <span class="pl-c1">Matrix</span><span class="pl-c1">{Float64}</span>(undef, Grid<span class="pl-k">.</span>N<span class="pl-k">...</span>)
Phi_melt_cpu            <span class="pl-k">=</span>   <span class="pl-c1">similar</span>(Tnew_cpu)
<span class="pl-k">if</span> USE_GPU; Phases      <span class="pl-k">=</span>   CUDA<span class="pl-k">.</span><span class="pl-c1">ones</span>(Int64,Grid<span class="pl-k">.</span>N<span class="pl-k">...</span>)
<span class="pl-k">else</span>        Phases      <span class="pl-k">=</span>   <span class="pl-c1">ones</span>(Int64,Grid<span class="pl-k">.</span>N<span class="pl-k">...</span>)   <span class="pl-k">end</span>
<span class="pl-c1">@parallel</span> (<span class="pl-c1">1</span><span class="pl-k">:</span>Nx, <span class="pl-c1">1</span><span class="pl-k">:</span>Nz) <span class="pl-c1">GridArray!</span>(Arrays<span class="pl-k">.</span>X,  Arrays<span class="pl-k">.</span>Z, Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">1</span>], Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">2</span>])   
Tracers                 <span class="pl-k">=</span>   <span class="pl-c1">StructArray</span><span class="pl-c1">{Tracer}</span>(undef, <span class="pl-c1">1</span>)                           <span class="pl-c"><span class="pl-c">#</span> Initialize tracers   </span>
dike                    <span class="pl-k">=</span>   <span class="pl-c1">Dike</span>(W<span class="pl-k">=</span>W_in,H<span class="pl-k">=</span>H_in,Type<span class="pl-k">=</span>DikeType,T<span class="pl-k">=</span>T_in);               <span class="pl-c"><span class="pl-c">#</span> "Reference" dike with given thickness,radius and T</span>
Arrays<span class="pl-k">.</span>T               <span class="pl-k">.=</span>   <span class="pl-k">-</span>Arrays<span class="pl-k">.</span>Z<span class="pl-k">.*</span>GeoT;                                        <span class="pl-c"><span class="pl-c">#</span> Initial (linear) temperature profile</span>

<span class="pl-c"><span class="pl-c">#</span> Preparation of visualisation</span>
<span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>GKSwstype<span class="pl-pds">"</span></span>]<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>nul<span class="pl-pds">"</span></span>; <span class="pl-k">if</span> <span class="pl-c1">isdir</span>(<span class="pl-s"><span class="pl-pds">"</span>viz2D_out<span class="pl-pds">"</span></span>)<span class="pl-k">==</span><span class="pl-c1">false</span> <span class="pl-c1">mkdir</span>(<span class="pl-s"><span class="pl-pds">"</span>viz2D_out<span class="pl-pds">"</span></span>) <span class="pl-k">end</span>; loadpath <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>./viz2D_out/<span class="pl-pds">"</span></span>; anim <span class="pl-k">=</span> <span class="pl-c1">Animation</span>(loadpath,String[])

time, dike_inj, InjectVol, Time_vec,Melt_Time <span class="pl-k">=</span> <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>,<span class="pl-c1">zeros</span>(nt,<span class="pl-c1">1</span>),<span class="pl-c1">zeros</span>(nt,<span class="pl-c1">1</span>);
<span class="pl-k">for</span> it <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>nt   <span class="pl-c"><span class="pl-c">#</span> Time loop</span>

    <span class="pl-k">if</span> <span class="pl-c1">floor</span>(time<span class="pl-k">/</span>InjectionInterval)<span class="pl-k">&gt;</span> dike_inj       <span class="pl-c"><span class="pl-c">#</span> Add new dike every X years</span>
        dike_inj  <span class="pl-k">=</span>     <span class="pl-c1">floor</span>(time<span class="pl-k">/</span>InjectionInterval)                                               <span class="pl-c"><span class="pl-c">#</span> Keeps track on what was injected already</span>
        cen       <span class="pl-k">=</span>     (Grid<span class="pl-k">.</span>max <span class="pl-k">.+</span> Grid<span class="pl-k">.</span>min)<span class="pl-k">.</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">.+</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">0.5</span><span class="pl-k">:</span><span class="pl-c1">1e-3</span><span class="pl-k">:</span><span class="pl-c1">0.5</span>, <span class="pl-c1">2</span>)<span class="pl-k">.*</span>[W_ran;H_ran];         <span class="pl-c"><span class="pl-c">#</span> Randomly vary center of dike </span>
        <span class="pl-k">if</span> cen[<span class="pl-c1">end</span>]<span class="pl-k">&lt;-</span><span class="pl-c1">12e3</span>;  Angle_rand <span class="pl-k">=</span> <span class="pl-c1">rand</span>( <span class="pl-c1">80.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">100.0</span>)                                      <span class="pl-c"><span class="pl-c">#</span> Orientation: near-vertical @ depth             </span>
        <span class="pl-k">else</span>                Angle_rand <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">10.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>); <span class="pl-k">end</span>                                  <span class="pl-c"><span class="pl-c">#</span> Orientation: near-vertical @ shallower depth     </span>
        dike      <span class="pl-k">=</span>     <span class="pl-c1">Dike</span>(dike, Center<span class="pl-k">=</span>cen[:],Angle<span class="pl-k">=</span>[Angle_rand]);                               <span class="pl-c"><span class="pl-c">#</span> Specify dike with random location/angle but fixed size/T </span>
        Tnew_cpu <span class="pl-k">.=</span>     <span class="pl-c1">Array</span>(Arrays<span class="pl-k">.</span>T)
        Tracers, Tnew_cpu, Vol   <span class="pl-k">=</span>   <span class="pl-c1">InjectDike</span>(Tracers, Tnew_cpu, Grid<span class="pl-k">.</span>coord1D, dike, nTr_dike);   <span class="pl-c"><span class="pl-c">#</span> Add dike, move hostrocks</span>
        Arrays<span class="pl-k">.</span>T <span class="pl-k">.=</span>     Data<span class="pl-k">.</span><span class="pl-c1">Array</span>(Tnew_cpu)
        InjectVol <span class="pl-k">+=</span>    Vol                                                                 <span class="pl-c"><span class="pl-c">#</span> Keep track of injected volume</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Added new dike; total injected magma volume = <span class="pl-v">$(<span class="pl-c1">round</span>(InjectVol<span class="pl-k">/</span>km³,digits<span class="pl-k">=</span><span class="pl-c1">2</span>))</span> km³; rate Q=<span class="pl-v">$(<span class="pl-c1">round</span>(InjectVol<span class="pl-k">/</span>(time),digits<span class="pl-k">=</span><span class="pl-c1">2</span>))</span> m³/s<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
    
    <span class="pl-c1">Nonlinear_Diffusion_step_2D!</span>(Arrays, MatParam, Phases, Grid, dt, Num)   <span class="pl-c"><span class="pl-c">#</span> Perform a nonlinear diffusion step</span>
    
    <span class="pl-c1">copy_arrays_GPU2CPU!</span>(Tnew_cpu, Phi_melt_cpu, Arrays<span class="pl-k">.</span>Tnew, Arrays<span class="pl-k">.</span>ϕ)     <span class="pl-c"><span class="pl-c">#</span> Copy arrays to CPU to update properties</span>
    <span class="pl-c1">UpdateTracers_T_ϕ!</span>(Tracers, Grid<span class="pl-k">.</span>coord1D, Tnew_cpu, Phi_melt_cpu);      <span class="pl-c"><span class="pl-c">#</span> Update info on tracers </span>
    
    <span class="pl-c1">@parallel</span> <span class="pl-c1">assign!</span>(Arrays<span class="pl-k">.</span>T, Arrays<span class="pl-k">.</span>Tnew)
    <span class="pl-c1">@parallel</span> <span class="pl-c1">assign!</span>(Arrays<span class="pl-k">.</span>Tnew, Arrays<span class="pl-k">.</span>T)                                <span class="pl-c"><span class="pl-c">#</span> Update temperature</span>
    time                <span class="pl-k">=</span>   time <span class="pl-k">+</span> dt;                                      <span class="pl-c"><span class="pl-c">#</span> Keep track of evolved time</span>
    Melt_Time[it]       <span class="pl-k">=</span>   <span class="pl-c1">sum</span>(Arrays<span class="pl-k">.</span>ϕ)<span class="pl-k">/</span><span class="pl-c1">prod</span>(Grid<span class="pl-k">.</span>N)                      <span class="pl-c"><span class="pl-c">#</span> Melt fraction in crust    </span>
    Time_vec[it]        <span class="pl-k">=</span>   time;                                           <span class="pl-c"><span class="pl-c">#</span> Vector with time</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span> Timestep <span class="pl-v">$it</span> = <span class="pl-v">$(<span class="pl-c1">round</span>(time<span class="pl-k">/</span>kyr<span class="pl-k">*</span><span class="pl-c1">100</span>)<span class="pl-k">/</span><span class="pl-c1">100</span>)</span> kyrs<span class="pl-pds">"</span></span>)
    
    <span class="pl-k">if</span> <span class="pl-c1">mod</span>(it,<span class="pl-c1">20</span>)<span class="pl-k">==</span><span class="pl-c1">0</span>  <span class="pl-c"><span class="pl-c">#</span> Visualisation</span>
        x,z         <span class="pl-k">=</span>   Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">1</span>], Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">2</span>]
        p1          <span class="pl-k">=</span>   <span class="pl-c1">heatmap</span>(x<span class="pl-k">/</span><span class="pl-c1">1e3</span>, z<span class="pl-k">/</span><span class="pl-c1">1e3</span>, <span class="pl-c1">Array</span>(Arrays<span class="pl-k">.</span>T)<span class="pl-k">'</span>,  aspect_ratio<span class="pl-k">=</span><span class="pl-c1">1</span>, xlims<span class="pl-k">=</span>(x[<span class="pl-c1">1</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>,x[<span class="pl-c1">end</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>), ylims<span class="pl-k">=</span>(z[<span class="pl-c1">1</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>,z[<span class="pl-c1">end</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>),   c<span class="pl-k">=</span><span class="pl-c1">:lajolla</span>, clims<span class="pl-k">=</span>(<span class="pl-c1">0.</span>,<span class="pl-c1">900.</span>), xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Width [km]<span class="pl-pds">"</span></span>,ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Depth [km]<span class="pl-pds">"</span></span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$(<span class="pl-c1">round</span>(time<span class="pl-k">/</span>kyr, digits<span class="pl-k">=</span><span class="pl-c1">2</span>))</span> kyrs<span class="pl-pds">"</span></span>, dpi<span class="pl-k">=</span><span class="pl-c1">200</span>, fontsize<span class="pl-k">=</span><span class="pl-c1">6</span>, colorbar_title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Temperature<span class="pl-pds">"</span></span>)
        p2          <span class="pl-k">=</span>   <span class="pl-c1">heatmap</span>(x<span class="pl-k">/</span><span class="pl-c1">1e3</span>,z<span class="pl-k">/</span><span class="pl-c1">1e3</span>, <span class="pl-c1">Array</span>(Arrays<span class="pl-k">.</span>ϕ)<span class="pl-k">'</span>,  aspect_ratio<span class="pl-k">=</span><span class="pl-c1">1</span>, xlims<span class="pl-k">=</span>(x[<span class="pl-c1">1</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>,x[<span class="pl-c1">end</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>), ylims<span class="pl-k">=</span>(z[<span class="pl-c1">1</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>,z[<span class="pl-c1">end</span>]<span class="pl-k">/</span><span class="pl-c1">1e3</span>),   c<span class="pl-k">=</span><span class="pl-c1">:nuuk</span>,    clims<span class="pl-k">=</span>(<span class="pl-c1">0.</span>, <span class="pl-c1">1.</span> ), xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Width [km]<span class="pl-pds">"</span></span>,             dpi<span class="pl-k">=</span><span class="pl-c1">200</span>, fontsize<span class="pl-k">=</span><span class="pl-c1">6</span>, colorbar_title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Melt Fraction<span class="pl-pds">"</span></span>)
        <span class="pl-c1">plot</span>(p1, p2, layout<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)); <span class="pl-c1">frame</span>(anim)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>
<span class="pl-c1">gif</span>(anim, <span class="pl-s"><span class="pl-pds">"</span>Example2D.gif<span class="pl-pds">"</span></span>, fps <span class="pl-k">=</span> <span class="pl-c1">15</span>)   <span class="pl-c"><span class="pl-c">#</span> create gif animation</span>
<span class="pl-k">return</span> Time_vec, Melt_Time;
<span class="pl-k">end</span><span class="pl-c"><span class="pl-c">#</span> end of main function</span>

Time_vec,Melt_Time <span class="pl-k">=</span> <span class="pl-c1">MainCode_2D</span>(); <span class="pl-c"><span class="pl-c">#</span> start the main code</span>
<span class="pl-c1">plot</span>(Time_vec<span class="pl-k">/</span>kyr, Melt_Time, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Time [kyrs]<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Fraction of crust that is molten<span class="pl-pds">"</span></span>, label<span class="pl-k">=</span><span class="pl-c1">:none</span>); <span class="pl-c1">png</span>(<span class="pl-s"><span class="pl-pds">"</span>Time_vs_Melt_Example2D<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span> Create plot</span></pre></div>
<p dir="auto">The main routines are thus <code>InjectDike(..)</code>, which inserts a new dike (of given dimensions and orientation) into the domain, and <code>Nonlinear_Diffusion_step_2D!(...)</code>, which computes thermal diffusion. Variable thermal conductivity, and latent heat are all taken into account.</p>
<p dir="auto">If you have a multicore processor (chances are very high that you do), the code can also take advantage of that. The only thing that you have to do is start julia with multiple threads, which on linux or macOS is done with:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$julia --threads=8"><pre class="notranslate"><code>$julia --threads=8
</code></pre></div>
<p dir="auto">You can check how many threads you are using by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Threads.nthreads()
8"><pre>julia<span class="pl-k">&gt;</span> Threads<span class="pl-k">.</span><span class="pl-c1">nthreads</span>()
<span class="pl-c1">8</span></pre></div>
<p dir="auto">You start the simulation with</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; include(&quot;Example2D.jl&quot;)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>Example2D.jl<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">provided that you are in the same directory as the file (check that with <code>pwd()</code>).</p>
<p dir="auto">If you happen to have a machine with an NVIDIA graphics card build in, the code will run (substantially) faster by changing this flag:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const USE_GPU=true;"><pre><span class="pl-k">const</span> USE_GPU<span class="pl-k">=</span><span class="pl-c1">true</span>;</pre></div>
<p dir="auto">The full code example can be downloaded <a href="./examples/Example2D.jl">here</a></p>
<h2 dir="auto"><a id="user-content-100-lines-3d-example" class="anchor" aria-hidden="true" href="#100-lines-3d-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>100-lines 3D example</h2>
<p dir="auto">To go from 2D to 3D, only a few minor changes to the code above are required. A movie of our example, which was computed on a laptop, is:
<a target="_blank" rel="noopener noreferrer" href="examples/movies/Example3D.gif"><img src="examples/movies/Example3D.gif" alt="3-D dike intrusion" data-animated-image="" style="max-width: 100%;"></a></p>
<p dir="auto">Here the full 3D code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MagmaThermoKinematics
const USE_GPU=false;
if USE_GPU  environment!(:gpu, Float64, 3)      # initialize parallel stencil in 2D
else        environment!(:cpu, Float64, 3)      # initialize parallel stencil in 2D
end
using MagmaThermoKinematics.Diffusion3D 
using Plots                                     
using WriteVTK    

#------------------------------------------------------------------------------------------
@views function MainCode_3D();
    Nx,Ny,Nz                =   250,250,250
    Grid                    =   CreateGrid(size=(Nx,Ny,Nz), extent=(30e3, 30e3, 30e3)) # grid points &amp; domain size
    Num                     =   Numeric_params(verbose=false)                   # Nonlinear solver options

    # Set material parameters                                       
    MatParam                =   (
            SetMaterialParams(Name=&quot;Rock&quot;, Phase=1, 
                 Density    = ConstantDensity(ρ=2800kg/m^3),               
               HeatCapacity = ConstantHeatCapacity(cp=1050J/kg/K),
               Conductivity = ConstantConductivity(k=1.5Watt/K/m),       
                 LatentHeat = ConstantLatentHeat(Q_L=350e3J/kg),
                    Melting = MeltingParam_Caricchi()),
                                )      

    GeoT                    =   20.0/1e3;                   # Geothermal gradient [K/km]
    W_in, H_in              =   5e3,    0.5e3;              # Width and thickness of dike
    T_in                    =   900;                        # Intrusion temperature
    InjectionInterval       =   0.1kyr;                     # Inject a new dike every X kyrs
    maxTime                 =   15kyr;                      # Maximum simulation time in kyrs
    H_ran, W_ran            =   Grid.L[1]*0.3,Grid.L[3]*0.4;# Size of domain in which we randomly place dikes and range of angles   
    DikeType                =   &quot;ElasticDike&quot;               # Type to be injected (&quot;ElasticDike&quot;,&quot;SquareDike&quot;)
    κ                       =   1.2/(2800*1050);            # thermal diffusivity   
    dt                      =   minimum(Grid.Δ.^2)/κ/10;    # stable timestep (required for explicit FD)
    nt                      =   floor(Int64,maxTime/dt);    # number of required timesteps
    nTr_dike                =   300;                        # number of tracers inserted per dike

    # Array initializations
    Arrays = CreateArrays(Dict( (Nx,  Ny, Nz)=&gt;(T=0,T_K=0, T_it_old=0, K=1.5, Rho=2800, Cp=1050, Tnew=0,  Hr=0, Hl=0, Kc=1, P=0, X=0, Y=0, Z=0, ϕₒ=0, ϕ=0, dϕdT=0),
                                (Nx-1,Ny,Nz)=&gt;(qx=0,Kx=0), (Nx, Ny-1, Nz)=&gt;(qy=0,Ky=0 ) , (Nx, Ny, Nz-1)=&gt;(qz=0,Kz=0 ) ))
    # CPU buffers 
    Tnew_cpu                =   zeros(Float64, Grid.N...)
    Phi_melt_cpu            =   similar(Tnew_cpu)
    if USE_GPU; Phases      =   CUDA.ones(Int64,Grid.N...)
    else        Phases      =   ones(Int64,Grid.N...)   end

    @parallel (1:Nx,1:Ny,1:Nz) GridArray!(Arrays.X,Arrays.Y,Arrays.Z, Grid.coord1D[1], Grid.coord1D[2], Grid.coord1D[3])   
    Tracers                 =   StructArray{Tracer}(undef, 1)                           # Initialize tracers   
    dike                    =   Dike(W=W_in,H=H_in,Type=DikeType,T=T_in);               # &quot;Reference&quot; dike with given thickness,radius and T
    Arrays.T               .=   -Arrays.Z.*GeoT;                                        # Initial (linear) temperature profile

    # Preparation of VTK/Paraview output 
    if isdir(&quot;viz3D_out&quot;)==false mkdir(&quot;viz3D_out&quot;) end; loadpath = &quot;./viz3D_out/&quot;; pvd = paraview_collection(&quot;Example3D&quot;);

    time, dike_inj, InjectVol, Time_vec,Melt_Time = 0.0, 0.0, 0.0,zeros(nt,1),zeros(nt,1);
    for it = 1:nt   # Time loop

        if floor(time/InjectionInterval)&gt; dike_inj       # Add new dike every X years
            dike_inj  =     floor(time/InjectionInterval)                                               # Keeps track on what was injected already
            cen       =     (Grid.max .+ Grid.min)./2 .+ rand(-0.5:1e-3:0.5, 3).*[W_ran;W_ran;H_ran];   # Randomly vary center of dike 
            if cen[end]&lt;-12e3;  Angle_rand = [rand(80.0:0.1:100.0); rand(0:360)]                        # Dikes at depth             
            else                Angle_rand = [rand(-10.0:0.1:10.0); rand(0:360)] end                    # Sills at shallower depth
            dike      =     Dike(dike, Center=cen[:],Angle=Angle_rand);                                 # Specify dike with random location/angle but fixed size/T 
            Tnew_cpu .=     Array(Arrays.T)
            Tracers, Tnew_cpu, Vol   =   InjectDike(Tracers, Tnew_cpu, Grid.coord1D, dike, nTr_dike);   # Add dike, move hostrocks
            Arrays.T .=     Data.Array(Tnew_cpu)
            InjectVol +=    Vol                                                                 # Keep track of injected volume
            println(&quot;Added new dike; total injected magma volume = $(round(InjectVol/km³,digits=2)) km³; rate Q=$(round(InjectVol/(time),digits=2)) m³/s&quot;)
        end

        Nonlinear_Diffusion_step_3D!(Arrays, MatParam, Phases, Grid, dt, Num)   # Perform a nonlinear diffusion step

        copy_arrays_GPU2CPU!(Tnew_cpu, Phi_melt_cpu, Arrays.Tnew, Arrays.ϕ)     # Copy arrays to CPU to update properties
        UpdateTracers_T_ϕ!(Tracers, Grid.coord1D, Tnew_cpu, Phi_melt_cpu);      # Update info on tracers 

        @parallel assign!(Arrays.T, Arrays.Tnew)
        @parallel assign!(Arrays.Tnew, Arrays.T)                                # Update temperature
        time                =   time + dt;                                      # Keep track of evolved time
        Melt_Time[it]       =   sum(Arrays.ϕ)/prod(Grid.N)                      # Melt fraction in crust    
        Time_vec[it]        =   time;                                           # Vector with time
        println(&quot; Timestep $it = $(round(time/kyr*100)/100) kyrs&quot;)

        if mod(it,20)==0  # Visualisation
            x,y,z         =   Grid.coord1D[1], Grid.coord1D[2], Grid.coord1D[3]
            vtkfile = vtk_grid(&quot;./viz3D_out/ex3D_$(Int32(it+1e4))&quot;, Vector(x/1e3), Vector(y/1e3), Vector(z/1e3)) # 3-D VTK file
            vtkfile[&quot;Temperature&quot;] = Array(Arrays.T); vtkfile[&quot;MeltFraction&quot;] = Array(Arrays.ϕ);                 # Store fields in file
            outfiles = vtk_save(vtkfile); pvd[time/kyr] = vtkfile                                   # Save file &amp; update pvd file
        end
    end
    vtk_save(pvd) 
    return Time_vec, Melt_Time, Tracers, Grid, Arrays;
end # end of main function

Time_vec, Melt_Time, Tracers, Grid, Arrays = MainCode_3D(); # start the main code
"><pre><span class="pl-k">using</span> MagmaThermoKinematics
<span class="pl-k">const</span> USE_GPU<span class="pl-k">=</span><span class="pl-c1">false</span>;
<span class="pl-k">if</span> USE_GPU  <span class="pl-c1">environment!</span>(<span class="pl-c1">:gpu</span>, Float64, <span class="pl-c1">3</span>)      <span class="pl-c"><span class="pl-c">#</span> initialize parallel stencil in 2D</span>
<span class="pl-k">else</span>        <span class="pl-c1">environment!</span>(<span class="pl-c1">:cpu</span>, Float64, <span class="pl-c1">3</span>)      <span class="pl-c"><span class="pl-c">#</span> initialize parallel stencil in 2D</span>
<span class="pl-k">end</span>
<span class="pl-k">using</span> MagmaThermoKinematics<span class="pl-k">.</span>Diffusion3D 
<span class="pl-k">using</span> Plots                                     
<span class="pl-k">using</span> WriteVTK    

<span class="pl-c"><span class="pl-c">#</span>------------------------------------------------------------------------------------------</span>
<span class="pl-c1">@views</span> <span class="pl-k">function</span> <span class="pl-en">MainCode_3D</span>();
    Nx,Ny,Nz                <span class="pl-k">=</span>   <span class="pl-c1">250</span>,<span class="pl-c1">250</span>,<span class="pl-c1">250</span>
    Grid                    <span class="pl-k">=</span>   <span class="pl-c1">CreateGrid</span>(size<span class="pl-k">=</span>(Nx,Ny,Nz), extent<span class="pl-k">=</span>(<span class="pl-c1">30e3</span>, <span class="pl-c1">30e3</span>, <span class="pl-c1">30e3</span>)) <span class="pl-c"><span class="pl-c">#</span> grid points &amp; domain size</span>
    Num                     <span class="pl-k">=</span>   <span class="pl-c1">Numeric_params</span>(verbose<span class="pl-k">=</span><span class="pl-c1">false</span>)                   <span class="pl-c"><span class="pl-c">#</span> Nonlinear solver options</span>

    <span class="pl-c"><span class="pl-c">#</span> Set material parameters                                       </span>
    MatParam                <span class="pl-k">=</span>   (
            <span class="pl-c1">SetMaterialParams</span>(Name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Rock<span class="pl-pds">"</span></span>, Phase<span class="pl-k">=</span><span class="pl-c1">1</span>, 
                 Density    <span class="pl-k">=</span> <span class="pl-c1">ConstantDensity</span>(ρ<span class="pl-k">=</span><span class="pl-c1">2800</span>kg<span class="pl-k">/</span>m<span class="pl-k">^</span><span class="pl-c1">3</span>),               
               HeatCapacity <span class="pl-k">=</span> <span class="pl-c1">ConstantHeatCapacity</span>(cp<span class="pl-k">=</span><span class="pl-c1">1050</span>J<span class="pl-k">/</span>kg<span class="pl-k">/</span>K),
               Conductivity <span class="pl-k">=</span> <span class="pl-c1">ConstantConductivity</span>(k<span class="pl-k">=</span><span class="pl-c1">1.5</span>Watt<span class="pl-k">/</span>K<span class="pl-k">/</span>m),       
                 LatentHeat <span class="pl-k">=</span> <span class="pl-c1">ConstantLatentHeat</span>(Q_L<span class="pl-k">=</span><span class="pl-c1">350e3</span>J<span class="pl-k">/</span>kg),
                    Melting <span class="pl-k">=</span> <span class="pl-c1">MeltingParam_Caricchi</span>()),
                                )      

    GeoT                    <span class="pl-k">=</span>   <span class="pl-c1">20.0</span><span class="pl-k">/</span><span class="pl-c1">1e3</span>;                   <span class="pl-c"><span class="pl-c">#</span> Geothermal gradient [K/km]</span>
    W_in, H_in              <span class="pl-k">=</span>   <span class="pl-c1">5e3</span>,    <span class="pl-c1">0.5e3</span>;              <span class="pl-c"><span class="pl-c">#</span> Width and thickness of dike</span>
    T_in                    <span class="pl-k">=</span>   <span class="pl-c1">900</span>;                        <span class="pl-c"><span class="pl-c">#</span> Intrusion temperature</span>
    InjectionInterval       <span class="pl-k">=</span>   <span class="pl-c1">0.1</span>kyr;                     <span class="pl-c"><span class="pl-c">#</span> Inject a new dike every X kyrs</span>
    maxTime                 <span class="pl-k">=</span>   <span class="pl-c1">15</span>kyr;                      <span class="pl-c"><span class="pl-c">#</span> Maximum simulation time in kyrs</span>
    H_ran, W_ran            <span class="pl-k">=</span>   Grid<span class="pl-k">.</span>L[<span class="pl-c1">1</span>]<span class="pl-k">*</span><span class="pl-c1">0.3</span>,Grid<span class="pl-k">.</span>L[<span class="pl-c1">3</span>]<span class="pl-k">*</span><span class="pl-c1">0.4</span>;<span class="pl-c"><span class="pl-c">#</span> Size of domain in which we randomly place dikes and range of angles   </span>
    DikeType                <span class="pl-k">=</span>   <span class="pl-s"><span class="pl-pds">"</span>ElasticDike<span class="pl-pds">"</span></span>               <span class="pl-c"><span class="pl-c">#</span> Type to be injected ("ElasticDike","SquareDike")</span>
    κ                       <span class="pl-k">=</span>   <span class="pl-c1">1.2</span><span class="pl-k">/</span>(<span class="pl-c1">2800</span><span class="pl-k">*</span><span class="pl-c1">1050</span>);            <span class="pl-c"><span class="pl-c">#</span> thermal diffusivity   </span>
    dt                      <span class="pl-k">=</span>   <span class="pl-c1">minimum</span>(Grid<span class="pl-k">.</span>Δ<span class="pl-k">.^</span><span class="pl-c1">2</span>)<span class="pl-k">/</span>κ<span class="pl-k">/</span><span class="pl-c1">10</span>;    <span class="pl-c"><span class="pl-c">#</span> stable timestep (required for explicit FD)</span>
    nt                      <span class="pl-k">=</span>   <span class="pl-c1">floor</span>(Int64,maxTime<span class="pl-k">/</span>dt);    <span class="pl-c"><span class="pl-c">#</span> number of required timesteps</span>
    nTr_dike                <span class="pl-k">=</span>   <span class="pl-c1">300</span>;                        <span class="pl-c"><span class="pl-c">#</span> number of tracers inserted per dike</span>

    <span class="pl-c"><span class="pl-c">#</span> Array initializations</span>
    Arrays <span class="pl-k">=</span> <span class="pl-c1">CreateArrays</span>(<span class="pl-c1">Dict</span>( (Nx,  Ny, Nz)<span class="pl-k">=&gt;</span>(T<span class="pl-k">=</span><span class="pl-c1">0</span>,T_K<span class="pl-k">=</span><span class="pl-c1">0</span>, T_it_old<span class="pl-k">=</span><span class="pl-c1">0</span>, K<span class="pl-k">=</span><span class="pl-c1">1.5</span>, Rho<span class="pl-k">=</span><span class="pl-c1">2800</span>, Cp<span class="pl-k">=</span><span class="pl-c1">1050</span>, Tnew<span class="pl-k">=</span><span class="pl-c1">0</span>,  Hr<span class="pl-k">=</span><span class="pl-c1">0</span>, Hl<span class="pl-k">=</span><span class="pl-c1">0</span>, Kc<span class="pl-k">=</span><span class="pl-c1">1</span>, P<span class="pl-k">=</span><span class="pl-c1">0</span>, X<span class="pl-k">=</span><span class="pl-c1">0</span>, Y<span class="pl-k">=</span><span class="pl-c1">0</span>, Z<span class="pl-k">=</span><span class="pl-c1">0</span>, ϕₒ<span class="pl-k">=</span><span class="pl-c1">0</span>, ϕ<span class="pl-k">=</span><span class="pl-c1">0</span>, dϕdT<span class="pl-k">=</span><span class="pl-c1">0</span>),
                                (Nx<span class="pl-k">-</span><span class="pl-c1">1</span>,Ny,Nz)<span class="pl-k">=&gt;</span>(qx<span class="pl-k">=</span><span class="pl-c1">0</span>,Kx<span class="pl-k">=</span><span class="pl-c1">0</span>), (Nx, Ny<span class="pl-k">-</span><span class="pl-c1">1</span>, Nz)<span class="pl-k">=&gt;</span>(qy<span class="pl-k">=</span><span class="pl-c1">0</span>,Ky<span class="pl-k">=</span><span class="pl-c1">0</span> ) , (Nx, Ny, Nz<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">=&gt;</span>(qz<span class="pl-k">=</span><span class="pl-c1">0</span>,Kz<span class="pl-k">=</span><span class="pl-c1">0</span> ) ))
    <span class="pl-c"><span class="pl-c">#</span> CPU buffers </span>
    Tnew_cpu                <span class="pl-k">=</span>   <span class="pl-c1">zeros</span>(Float64, Grid<span class="pl-k">.</span>N<span class="pl-k">...</span>)
    Phi_melt_cpu            <span class="pl-k">=</span>   <span class="pl-c1">similar</span>(Tnew_cpu)
    <span class="pl-k">if</span> USE_GPU; Phases      <span class="pl-k">=</span>   CUDA<span class="pl-k">.</span><span class="pl-c1">ones</span>(Int64,Grid<span class="pl-k">.</span>N<span class="pl-k">...</span>)
    <span class="pl-k">else</span>        Phases      <span class="pl-k">=</span>   <span class="pl-c1">ones</span>(Int64,Grid<span class="pl-k">.</span>N<span class="pl-k">...</span>)   <span class="pl-k">end</span>

    <span class="pl-c1">@parallel</span> (<span class="pl-c1">1</span><span class="pl-k">:</span>Nx,<span class="pl-c1">1</span><span class="pl-k">:</span>Ny,<span class="pl-c1">1</span><span class="pl-k">:</span>Nz) <span class="pl-c1">GridArray!</span>(Arrays<span class="pl-k">.</span>X,Arrays<span class="pl-k">.</span>Y,Arrays<span class="pl-k">.</span>Z, Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">1</span>], Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">2</span>], Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">3</span>])   
    Tracers                 <span class="pl-k">=</span>   <span class="pl-c1">StructArray</span><span class="pl-c1">{Tracer}</span>(undef, <span class="pl-c1">1</span>)                           <span class="pl-c"><span class="pl-c">#</span> Initialize tracers   </span>
    dike                    <span class="pl-k">=</span>   <span class="pl-c1">Dike</span>(W<span class="pl-k">=</span>W_in,H<span class="pl-k">=</span>H_in,Type<span class="pl-k">=</span>DikeType,T<span class="pl-k">=</span>T_in);               <span class="pl-c"><span class="pl-c">#</span> "Reference" dike with given thickness,radius and T</span>
    Arrays<span class="pl-k">.</span>T               <span class="pl-k">.=</span>   <span class="pl-k">-</span>Arrays<span class="pl-k">.</span>Z<span class="pl-k">.*</span>GeoT;                                        <span class="pl-c"><span class="pl-c">#</span> Initial (linear) temperature profile</span>

    <span class="pl-c"><span class="pl-c">#</span> Preparation of VTK/Paraview output </span>
    <span class="pl-k">if</span> <span class="pl-c1">isdir</span>(<span class="pl-s"><span class="pl-pds">"</span>viz3D_out<span class="pl-pds">"</span></span>)<span class="pl-k">==</span><span class="pl-c1">false</span> <span class="pl-c1">mkdir</span>(<span class="pl-s"><span class="pl-pds">"</span>viz3D_out<span class="pl-pds">"</span></span>) <span class="pl-k">end</span>; loadpath <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>./viz3D_out/<span class="pl-pds">"</span></span>; pvd <span class="pl-k">=</span> <span class="pl-c1">paraview_collection</span>(<span class="pl-s"><span class="pl-pds">"</span>Example3D<span class="pl-pds">"</span></span>);

    time, dike_inj, InjectVol, Time_vec,Melt_Time <span class="pl-k">=</span> <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>,<span class="pl-c1">zeros</span>(nt,<span class="pl-c1">1</span>),<span class="pl-c1">zeros</span>(nt,<span class="pl-c1">1</span>);
    <span class="pl-k">for</span> it <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>nt   <span class="pl-c"><span class="pl-c">#</span> Time loop</span>

        <span class="pl-k">if</span> <span class="pl-c1">floor</span>(time<span class="pl-k">/</span>InjectionInterval)<span class="pl-k">&gt;</span> dike_inj       <span class="pl-c"><span class="pl-c">#</span> Add new dike every X years</span>
            dike_inj  <span class="pl-k">=</span>     <span class="pl-c1">floor</span>(time<span class="pl-k">/</span>InjectionInterval)                                               <span class="pl-c"><span class="pl-c">#</span> Keeps track on what was injected already</span>
            cen       <span class="pl-k">=</span>     (Grid<span class="pl-k">.</span>max <span class="pl-k">.+</span> Grid<span class="pl-k">.</span>min)<span class="pl-k">.</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">.+</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">0.5</span><span class="pl-k">:</span><span class="pl-c1">1e-3</span><span class="pl-k">:</span><span class="pl-c1">0.5</span>, <span class="pl-c1">3</span>)<span class="pl-k">.*</span>[W_ran;W_ran;H_ran];   <span class="pl-c"><span class="pl-c">#</span> Randomly vary center of dike </span>
            <span class="pl-k">if</span> cen[<span class="pl-c1">end</span>]<span class="pl-k">&lt;-</span><span class="pl-c1">12e3</span>;  Angle_rand <span class="pl-k">=</span> [<span class="pl-c1">rand</span>(<span class="pl-c1">80.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">100.0</span>); <span class="pl-c1">rand</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">360</span>)]                        <span class="pl-c"><span class="pl-c">#</span> Dikes at depth             </span>
            <span class="pl-k">else</span>                Angle_rand <span class="pl-k">=</span> [<span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">10.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>); <span class="pl-c1">rand</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">360</span>)] <span class="pl-k">end</span>                    <span class="pl-c"><span class="pl-c">#</span> Sills at shallower depth</span>
            dike      <span class="pl-k">=</span>     <span class="pl-c1">Dike</span>(dike, Center<span class="pl-k">=</span>cen[:],Angle<span class="pl-k">=</span>Angle_rand);                                 <span class="pl-c"><span class="pl-c">#</span> Specify dike with random location/angle but fixed size/T </span>
            Tnew_cpu <span class="pl-k">.=</span>     <span class="pl-c1">Array</span>(Arrays<span class="pl-k">.</span>T)
            Tracers, Tnew_cpu, Vol   <span class="pl-k">=</span>   <span class="pl-c1">InjectDike</span>(Tracers, Tnew_cpu, Grid<span class="pl-k">.</span>coord1D, dike, nTr_dike);   <span class="pl-c"><span class="pl-c">#</span> Add dike, move hostrocks</span>
            Arrays<span class="pl-k">.</span>T <span class="pl-k">.=</span>     Data<span class="pl-k">.</span><span class="pl-c1">Array</span>(Tnew_cpu)
            InjectVol <span class="pl-k">+=</span>    Vol                                                                 <span class="pl-c"><span class="pl-c">#</span> Keep track of injected volume</span>
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Added new dike; total injected magma volume = <span class="pl-v">$(<span class="pl-c1">round</span>(InjectVol<span class="pl-k">/</span>km³,digits<span class="pl-k">=</span><span class="pl-c1">2</span>))</span> km³; rate Q=<span class="pl-v">$(<span class="pl-c1">round</span>(InjectVol<span class="pl-k">/</span>(time),digits<span class="pl-k">=</span><span class="pl-c1">2</span>))</span> m³/s<span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>

        <span class="pl-c1">Nonlinear_Diffusion_step_3D!</span>(Arrays, MatParam, Phases, Grid, dt, Num)   <span class="pl-c"><span class="pl-c">#</span> Perform a nonlinear diffusion step</span>

        <span class="pl-c1">copy_arrays_GPU2CPU!</span>(Tnew_cpu, Phi_melt_cpu, Arrays<span class="pl-k">.</span>Tnew, Arrays<span class="pl-k">.</span>ϕ)     <span class="pl-c"><span class="pl-c">#</span> Copy arrays to CPU to update properties</span>
        <span class="pl-c1">UpdateTracers_T_ϕ!</span>(Tracers, Grid<span class="pl-k">.</span>coord1D, Tnew_cpu, Phi_melt_cpu);      <span class="pl-c"><span class="pl-c">#</span> Update info on tracers </span>

        <span class="pl-c1">@parallel</span> <span class="pl-c1">assign!</span>(Arrays<span class="pl-k">.</span>T, Arrays<span class="pl-k">.</span>Tnew)
        <span class="pl-c1">@parallel</span> <span class="pl-c1">assign!</span>(Arrays<span class="pl-k">.</span>Tnew, Arrays<span class="pl-k">.</span>T)                                <span class="pl-c"><span class="pl-c">#</span> Update temperature</span>
        time                <span class="pl-k">=</span>   time <span class="pl-k">+</span> dt;                                      <span class="pl-c"><span class="pl-c">#</span> Keep track of evolved time</span>
        Melt_Time[it]       <span class="pl-k">=</span>   <span class="pl-c1">sum</span>(Arrays<span class="pl-k">.</span>ϕ)<span class="pl-k">/</span><span class="pl-c1">prod</span>(Grid<span class="pl-k">.</span>N)                      <span class="pl-c"><span class="pl-c">#</span> Melt fraction in crust    </span>
        Time_vec[it]        <span class="pl-k">=</span>   time;                                           <span class="pl-c"><span class="pl-c">#</span> Vector with time</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span> Timestep <span class="pl-v">$it</span> = <span class="pl-v">$(<span class="pl-c1">round</span>(time<span class="pl-k">/</span>kyr<span class="pl-k">*</span><span class="pl-c1">100</span>)<span class="pl-k">/</span><span class="pl-c1">100</span>)</span> kyrs<span class="pl-pds">"</span></span>)

        <span class="pl-k">if</span> <span class="pl-c1">mod</span>(it,<span class="pl-c1">20</span>)<span class="pl-k">==</span><span class="pl-c1">0</span>  <span class="pl-c"><span class="pl-c">#</span> Visualisation</span>
            x,y,z         <span class="pl-k">=</span>   Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">1</span>], Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">2</span>], Grid<span class="pl-k">.</span>coord1D[<span class="pl-c1">3</span>]
            vtkfile <span class="pl-k">=</span> <span class="pl-c1">vtk_grid</span>(<span class="pl-s"><span class="pl-pds">"</span>./viz3D_out/ex3D_<span class="pl-v">$(<span class="pl-c1">Int32</span>(it<span class="pl-k">+</span><span class="pl-c1">1e4</span>))</span><span class="pl-pds">"</span></span>, <span class="pl-c1">Vector</span>(x<span class="pl-k">/</span><span class="pl-c1">1e3</span>), <span class="pl-c1">Vector</span>(y<span class="pl-k">/</span><span class="pl-c1">1e3</span>), <span class="pl-c1">Vector</span>(z<span class="pl-k">/</span><span class="pl-c1">1e3</span>)) <span class="pl-c"><span class="pl-c">#</span> 3-D VTK file</span>
            vtkfile[<span class="pl-s"><span class="pl-pds">"</span>Temperature<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Array</span>(Arrays<span class="pl-k">.</span>T); vtkfile[<span class="pl-s"><span class="pl-pds">"</span>MeltFraction<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Array</span>(Arrays<span class="pl-k">.</span>ϕ);                 <span class="pl-c"><span class="pl-c">#</span> Store fields in file</span>
            outfiles <span class="pl-k">=</span> <span class="pl-c1">vtk_save</span>(vtkfile); pvd[time<span class="pl-k">/</span>kyr] <span class="pl-k">=</span> vtkfile                                   <span class="pl-c"><span class="pl-c">#</span> Save file &amp; update pvd file</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-c1">vtk_save</span>(pvd) 
    <span class="pl-k">return</span> Time_vec, Melt_Time, Tracers, Grid, Arrays;
<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> end of main function</span>

Time_vec, Melt_Time, Tracers, Grid, Arrays <span class="pl-k">=</span> <span class="pl-c1">MainCode_3D</span>(); <span class="pl-c"><span class="pl-c">#</span> start the main code</span>
</pre></div>
<p dir="auto">The result of the script are a range of VTK files, which can be visualized with the 3D software <a href="https://www.paraview.org" rel="nofollow">Paraview</a>. The full code example can be downloaded <a href="./examples/Example3D.jl">here</a>, and the paraview statefile (to reproduce the movie) is available <a href="./examples/movies/Example3D_Paraview.pvsm">here</a>.</p>
<h2 dir="auto"><a id="user-content-dependencies" class="anchor" aria-hidden="true" href="#dependencies"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Dependencies</h2>
<p dir="auto">We rely on <a href="https://github.com/omlins/ParallelStencil.jl">ParallelStencil.jl</a> for the energy solver, <a href="https://github.com/JuliaGeodynamics/GeoParams.jl">GeoParams.jl</a> to define material properties (such as nonlinear conductivity, melting, etc.), <a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a> to generate an aray of tracer structures, <a href="https://docs.julialang.org/en/v1/stdlib/Random/" rel="nofollow">Random.jl</a> for random number generation, <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a> to simplify setting parameters (such as specifying dike properties), <a href="https://github.com/JuliaMath/Interpolations.jl">Interpolations.jl</a> to interpolate properties such as temperature from a fixed grid to tracers, and <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> for speed. All these dependencies should be installed automatically if you install <code>MagmaThermoKinematics.jl</code>.</p>
<p dir="auto"><a href="http://docs.juliaplots.org/latest/" rel="nofollow">Plots.jl</a> is employed for plotting, and <a href="https://github.com/jipolanco/WriteVTK.jl">WriteVTK.jl</a> is used in the 3D example to generate <code>*.vtr/*.pvd</code> files that can be visualized with <a href="https://www.paraview.org" rel="nofollow">Paraview</a>. You have to add both packages yourself; they are however anyways useful to have.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">After installing julia in the usual manner, you can add (and test) the package with</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt;]
  pkg&gt; add MagmaThermoKinematics
  pkg&gt; test MagmaThermoKinematics"><pre class="notranslate"><code>julia&gt;]
  pkg&gt; add MagmaThermoKinematics
  pkg&gt; test MagmaThermoKinematics
</code></pre></div>
<p dir="auto">Dependecies such as <code>ParallelStencil.jl</code> are installed automatically.
The testing suite run above performs a large number of tests and, among others, compares the results with analytical solutions for advection/diffusion. Let us know if you encounter problems.</p>
<p dir="auto">If you want to run the examples and create plots, you may also want to install these packages:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt;]
  pkg&gt; add Plots
  pkg&gt; add Makie
  pkg&gt; add WriteVTK"><pre class="notranslate"><code>julia&gt;]
  pkg&gt; add Plots
  pkg&gt; add Makie
  pkg&gt; add WriteVTK
</code></pre></div>
<p dir="auto">Next, you can download one of the codes above, put it in your current directory, and start it with</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; include(&quot;Example2D.jl&quot;)"><pre class="notranslate"><code>julia&gt; include("Example2D.jl")
</code></pre></div>
<p dir="auto">And finally, if you have installed this package previously on your system, but want to update it to the latest version:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt;]
  pkg&gt; update MagmaThermoKinematics"><pre class="notranslate"><code>julia&gt;]
  pkg&gt; update MagmaThermoKinematics
</code></pre></div>
<p dir="auto">If you are interested in running benchmark scenarios, comparing <code>MagmaThermoKinematics.jl</code>, versus codes previously used by the <code>Geneva</code> (Gregor Weber, Luca Caricchi) and <code>UCLA</code> (Oscar Lovera) research group, run this:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; include(&quot;examples/Example2D_ZASSy.jl&quot;)"><pre class="notranslate"><code>julia&gt; include("examples/Example2D_ZASSy.jl")
</code></pre></div>
<h2 dir="auto"><a id="user-content-ongoing-development" class="anchor" aria-hidden="true" href="#ongoing-development"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Ongoing development</h2>
<p dir="auto">We are working on a more general magmatic systems software as part of the <a href="https://magma.uni-mainz.de" rel="nofollow">MAGMA</a> project funded by the European Research Council. That will not only include thermal diffusion solvers and kinematically emplaced dikes (as done here), but also mechanical multiphysics solvers (to compute stress and deformation rate in the system, for example). For that we follow a modular and reusable software approach, where various software componentys are are defined in external package and re-usable packages, will which ultimately make it easier to write new software and apply that to natural cases. An example is the <a href="https://github.com/JuliaGeodynamics/GeoParams.jl">GeoParams.jl</a> package where material properties (e.g., density, heat capacity, thermal conductivity) are defined, that can be used by other packages (such as MagmaThermoKinematics.jl). The advantage of this approach is that such material properties only have to be defined once, and can subsequently be used in a whole range of software packages.<br>
If you are interested in this, have a look at <a href="https://github.com/JuliaGeodynamics/">https://github.com/JuliaGeodynamics/</a>.</p>
<p dir="auto">MagmaThermoKinematics is currently being used as an example case to test this software infrastructure. As a result, the functionality and the internals of the code is expected to change on a regular basis.</p>
<h2 dir="auto"><a id="user-content-related-work" class="anchor" aria-hidden="true" href="#related-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related work</h2>
<p dir="auto">Thermal-kinematic codes such as the ones presented here have been around for some time with various degrees of sophistication (e.g., [1],[2],[3],[4],[5]). A recent effort in Julia, similar to what we do here, is described in [6].</p>
<p dir="auto">Yet, as far as we are aware, the source code of these other packages is currently not openly available (at least not in a non-binary format), which makes it often non-straightforward to understand what is actually done inside the codes. No existing code works in 3D or can take advantage of GPUs.</p>
<p dir="auto">[1] Dufek, J., &amp; Bergantz, G. W. (2005). Lower crustal magma genesis and preservation: A stochastic framework for the evaluation of basalt–crust interaction. <em>Journal of Petrology</em>, 46(11), 2167–2195. <a href="https://doi.org/10.1093/petrology/egi049" rel="nofollow">https://doi.org/10.1093/petrology/egi049</a></p>
<p dir="auto">[2] Annen, C., Blundy, J. D., &amp; Sparks, R. S. J. (2006). The genesis of intermediate and silicic magmas in deep crustal hot zones. <em>Journal of Petrology</em>. 47(3), 505–539. <a href="https://doi.org/10.1093/petrology/egi084" rel="nofollow">https://doi.org/10.1093/petrology/egi084</a></p>
<p dir="auto">[4] Caricchi, L., Annen, C., Blundy, J., Simpson, G., &amp; Pinel, V. (2014). Frequency and magnitude of volcanic eruptions controlled by magma injection and buoyancy. <em>Nature Geoscience</em>, 7, 126–130. <a href="https://doi.org/10.1038/NGEO2041" rel="nofollow">https://doi.org/10.1038/NGEO2041</a></p>
<p dir="auto">[5] Tierney, C. R., Schmitt, A. K., Lovera, O. M., &amp; de Silva, S. L. (2016). Voluminous plutonism during a period of volcanic quiescence revealed by thermochemical modeling of zircon. <em>Geology</em>, 44, 683–686. <a href="https://doi.org/10.1130/G37968.1" rel="nofollow">https://doi.org/10.1130/G37968.1</a></p>
<p dir="auto">[6] Melnik, O.E., Utkin, I.S., Bindeman, I.N., 2021. Magma Chamber Formation by Dike Accretion and Crustal Melting: 2D Thermo‐Compositional Model With Emphasis on Eruptions and Implication for Zircon Records. <em>J Geophys Res Solid Earth</em> 126. <a href="https://doi.org/10.1029/2021JB023008" rel="nofollow">https://doi.org/10.1029/2021JB023008</a>. A preprint of their work is available <a href="https://www.essoar.org/doi/10.1002/essoar.10505594.1" rel="nofollow">here</a>.</p>
</article></div>