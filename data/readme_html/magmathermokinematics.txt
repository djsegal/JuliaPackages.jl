<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-magmathermokinematicsjl" class="anchor" aria-hidden="true" href="#magmathermokinematicsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MagmaThermoKinematics.jl</h1>
<p>Understanding how magmatic systems evolve and how the rock record can be interpreted is of interest to a wide range of Earth Scientists.</p>
<p>This easy to use and versatile package simulates the thermal evolution of magmatic systems, consisting of (kinematically) emplaced dikes. It can take 2D, 2D axisymmetric and 3D geometries into account, and works in parallel on both CPU (and GPU's). A finite difference discretization is employed for the energy equation, combined with semi-Lagrangian advection and tracers to track the thermal evolution of emplaced magma. Dikes are emplaced kinematically and the host rock is shifted to accommodate space for the intruding dikes/sills, using analytical models for penny-shaped cracks in elastic media. Cooling, crystallizing and latent heat effects are taken into account, and the thermal evolution of tracers can be used to simulate zircon age distributions.</p>
<p>Below we give a number of example scripts that show how it can be used to simulate a number of scenarios.</p>
<h2><a id="user-content-contents" class="anchor" aria-hidden="true" href="#contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contents</h2>
<ul>
<li><a href="#100-lines-2d-example">100-lines 2D example</a></li>
<li><a href="#100-lines-3d-example">100-lines 3D example</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#installation">Installation</a></li>
</ul>
<h2><a id="user-content-100-lines-2d-example" class="anchor" aria-hidden="true" href="#100-lines-2d-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>100-lines 2D example</h2>
<p>A simple example that simulates the emplacement of dikes within the crust over a period of 10'000 years is shown below.</p>
<p><a target="_blank" rel="noopener noreferrer" href="examples/movies/Example2D.gif"><img src="examples/movies/Example2D.gif" alt="2-D dike intrusion" style="max-width:100%;"></a></p>
<p>The code to simulate this, including visualization, is only 100 lines and the key parts of it are shown below</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Load required packages
#(...) 

#------------------------------------------------------------------------------------------
@views function MainCode_2D();

# Model parameters
W,H                     =   30km, 30km;             # Width, Height
ρ                       =   2800;                   # Density 
cp                      =   1050;                   # Heat capacity
k_rock, k_magma         =   1.5, 1.2;               # Thermal conductivity of host rock &amp; magma
La                      =   350e3;                  # Latent heat J/kg/K
GeoT                    =   20.0/km;                # Geothermal gradient [K/km]
x_in,z_in               =   20km,   -15km;          # Center of dike [x,z]
W_in, H_in              =   5km,    0.2km;          # Width and thickness of dike
T_in                    =   900;                    # Intrusion temperature
InjectionInterval       =   0.1kyr;                 # Inject a new dike every X kyrs
maxTime                 =   25kyr;                  # Maximum simulation time in kyrs
H_ran, W_ran            =   H*0.4, W*0.3;           # Size of domain in which we randomly place dikes and range of angles   
DikeType                =   &quot;ElasticDike&quot;           # Type to be injected (&quot;ElasticDike&quot;,&quot;SquareDike&quot;)

Nx, Nz                  =   500, 500;               # resolution (grid cells in x,z direction)
dx,dz                   =   W/(Nx-1), H/(Nz-1);     # grid size
κ                       =   k_rock./(ρ*cp);         # thermal diffusivity   
dt                      =   min(dx^2, dz^2)./κ/10;  # stable timestep (required for explicit FD)
nt::Int64               =   floor(maxTime/dt);      # number of required timesteps
nTr_dike                =   300;                    # number of tracers inserted per dike


#(...) 
# Initialize numerical parameters and arrays
#(...) 

# Set up model geometry &amp; initial T structure
# (...)
dike                    =   Dike(W=W_in,H=H_in,Type=DikeType,T=T_in); # &quot;Reference&quot; dike with given thickness,radius and T
T                       .=   -Z.*GeoT;                                # Initial (linear) temperature profile
Phi, dPhi_dt            =   SolidFraction(T, Phi_o, dt);              # Compute solid fractio
# Preparation of visualisation
#(...)

time, dike_inj, InjectVol, Time_vec,Melt_Time = 0.0, 0.0, 0.0,zeros(nt,1),zeros(nt,1);
for it = 1:nt   # Time loop

    if floor(time/InjectionInterval)&gt; dike_inj                                      # Add new dike every X years
        dike_inj  =   floor(time/InjectionInterval)                                 # Keeps track on what was injected already
        cen       =   [W/2.; -H/2.] + rand(-0.5:1e-3:0.5, 2).*[W_ran;H_ran];        # Randomly vary center of dike 
        if cen[end]&lt;-12km;  Angle_rand = rand( 80.0:0.1:100.0)                      # Orientation: near-vertical @ depth             
        else                Angle_rand = rand(-10.0:0.1:10.0); end                  # Orientation: near-vertical @ shallower depth     
        dike      =   Dike(dike, Center=cen[:],Angle=[Angle_rand]);                 # Specify dike with random location/angle but fixed size/T 
        Tracers, T, Vol     =   InjectDike(Tracers, T, Grid, dike, nTr_dike);       # Add dike, move hostrocks
        InjectVol           +=  Vol                                                 # Keep track of injected volume
        println(&quot;Added new dike; total injected magma volume = $(round(InjectVol/km³,digits=2)) km³; rate Q=$(round(InjectVol/(time),digits=2)) m³/s&quot;)
    end
    
    Phi, dPhi_dt     =  SolidFraction(T, Phi_o, dt);                                # Compute solid fraction
    K               .=  Phi.*k_rock .+ (1 .- Phi).*k_magma;                         # Thermal conductivity

    # Perform a diffusion step
    @parallel diffusion2D_step!(Tnew, T, qx, qz, K, Kx, Kz, Rho, Cp, dt, dx, dz, La, dPhi_dt);  
    @parallel (1:size(T,2)) bc2D_x!(Tnew);                                                      # set lateral boundary conditions (flux-free)
    Tnew[:,1] .= GeoT*H; Tnew[:,end] .= 0.0;                                                    # bottom &amp; top temperature (constant)
    
    Tracers             =   UpdateTracers(Tracers, Grid, Tnew, Phi);                            # Update info on tracers 
    T, Tnew             =   Tnew, T;                                                            # Update temperature
    time                =   time + dt;                                                          # Keep track of evolved time
    Melt_Time[it]       =   sum( 1.0 .- Phi)/(Nx*Nz)                                            # Melt fraction in crust    
    Time_vec[it]        =   time;                                                               # Vector with time
    println(&quot; Timestep $it = $(round(time/kyr*100)/100) kyrs&quot;)

    if mod(it,20)==0  # Visualisation
        Phi_melt    =   1.0 .- Phi;     
        p1          =   heatmap(x/km, z/km, T',         aspect_ratio=1, xlims=(x[1]/km,x[end]/km), ylims=(z[1]/km,z[end]/km),   c=:lajolla, clims=(0.,900.), xlabel=&quot;Width [km]&quot;,ylabel=&quot;Depth [km]&quot;, title=&quot;$(round(time/kyr, digits=2)) kyrs&quot;, dpi=200, fontsize=6, colorbar_title=&quot;Temperature&quot;)
        p2          =   heatmap(x/km, z/km, Phi_melt',  aspect_ratio=1, xlims=(x[1]/km,x[end]/km), ylims=(z[1]/km,z[end]/km),   c=:nuuk,    clims=(0., 1. ), xlabel=&quot;Width [km]&quot;,             dpi=200, fontsize=6, colorbar_title=&quot;Melt Fraction&quot;)
        plot(p1, p2, layout=(1,2)); frame(anim)
    end
end
gif(anim, &quot;Example2D.gif&quot;, fps = 15)   # create gif animation
return Time_vec, Melt_Time;
end # end of main function

Time_vec,Melt_Time = MainCode_2D(); # start the main code
plot(Time_vec/kyr, Melt_Time, xlabel=&quot;Time [kyrs]&quot;, ylabel=&quot;Fraction of crust that is molten&quot;, label=:none); png(&quot;Time_vs_Melt_Example2D&quot;) #Create plot
"><pre><span class="pl-c"><span class="pl-c">#</span> Load required packages</span>
<span class="pl-c"><span class="pl-c">#</span>(...) </span>

<span class="pl-c"><span class="pl-c">#</span>------------------------------------------------------------------------------------------</span>
<span class="pl-c1">@views</span> <span class="pl-k">function</span> <span class="pl-en">MainCode_2D</span>();

<span class="pl-c"><span class="pl-c">#</span> Model parameters</span>
W,H                     <span class="pl-k">=</span>   <span class="pl-c1">30</span>km, <span class="pl-c1">30</span>km;             <span class="pl-c"><span class="pl-c">#</span> Width, Height</span>
ρ                       <span class="pl-k">=</span>   <span class="pl-c1">2800</span>;                   <span class="pl-c"><span class="pl-c">#</span> Density </span>
cp                      <span class="pl-k">=</span>   <span class="pl-c1">1050</span>;                   <span class="pl-c"><span class="pl-c">#</span> Heat capacity</span>
k_rock, k_magma         <span class="pl-k">=</span>   <span class="pl-c1">1.5</span>, <span class="pl-c1">1.2</span>;               <span class="pl-c"><span class="pl-c">#</span> Thermal conductivity of host rock &amp; magma</span>
La                      <span class="pl-k">=</span>   <span class="pl-c1">350e3</span>;                  <span class="pl-c"><span class="pl-c">#</span> Latent heat J/kg/K</span>
GeoT                    <span class="pl-k">=</span>   <span class="pl-c1">20.0</span><span class="pl-k">/</span>km;                <span class="pl-c"><span class="pl-c">#</span> Geothermal gradient [K/km]</span>
x_in,z_in               <span class="pl-k">=</span>   <span class="pl-c1">20</span>km,   <span class="pl-k">-</span><span class="pl-c1">15</span>km;          <span class="pl-c"><span class="pl-c">#</span> Center of dike [x,z]</span>
W_in, H_in              <span class="pl-k">=</span>   <span class="pl-c1">5</span>km,    <span class="pl-c1">0.2</span>km;          <span class="pl-c"><span class="pl-c">#</span> Width and thickness of dike</span>
T_in                    <span class="pl-k">=</span>   <span class="pl-c1">900</span>;                    <span class="pl-c"><span class="pl-c">#</span> Intrusion temperature</span>
InjectionInterval       <span class="pl-k">=</span>   <span class="pl-c1">0.1</span>kyr;                 <span class="pl-c"><span class="pl-c">#</span> Inject a new dike every X kyrs</span>
maxTime                 <span class="pl-k">=</span>   <span class="pl-c1">25</span>kyr;                  <span class="pl-c"><span class="pl-c">#</span> Maximum simulation time in kyrs</span>
H_ran, W_ran            <span class="pl-k">=</span>   H<span class="pl-k">*</span><span class="pl-c1">0.4</span>, W<span class="pl-k">*</span><span class="pl-c1">0.3</span>;           <span class="pl-c"><span class="pl-c">#</span> Size of domain in which we randomly place dikes and range of angles   </span>
DikeType                <span class="pl-k">=</span>   <span class="pl-s"><span class="pl-pds">"</span>ElasticDike<span class="pl-pds">"</span></span>           <span class="pl-c"><span class="pl-c">#</span> Type to be injected ("ElasticDike","SquareDike")</span>

Nx, Nz                  <span class="pl-k">=</span>   <span class="pl-c1">500</span>, <span class="pl-c1">500</span>;               <span class="pl-c"><span class="pl-c">#</span> resolution (grid cells in x,z direction)</span>
dx,dz                   <span class="pl-k">=</span>   W<span class="pl-k">/</span>(Nx<span class="pl-k">-</span><span class="pl-c1">1</span>), H<span class="pl-k">/</span>(Nz<span class="pl-k">-</span><span class="pl-c1">1</span>);     <span class="pl-c"><span class="pl-c">#</span> grid size</span>
κ                       <span class="pl-k">=</span>   k_rock<span class="pl-k">./</span>(ρ<span class="pl-k">*</span>cp);         <span class="pl-c"><span class="pl-c">#</span> thermal diffusivity   </span>
dt                      <span class="pl-k">=</span>   <span class="pl-c1">min</span>(dx<span class="pl-k">^</span><span class="pl-c1">2</span>, dz<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">./</span>κ<span class="pl-k">/</span><span class="pl-c1">10</span>;  <span class="pl-c"><span class="pl-c">#</span> stable timestep (required for explicit FD)</span>
nt<span class="pl-k">::</span><span class="pl-c1">Int64</span>               <span class="pl-k">=</span>   <span class="pl-c1">floor</span>(maxTime<span class="pl-k">/</span>dt);      <span class="pl-c"><span class="pl-c">#</span> number of required timesteps</span>
nTr_dike                <span class="pl-k">=</span>   <span class="pl-c1">300</span>;                    <span class="pl-c"><span class="pl-c">#</span> number of tracers inserted per dike</span>


<span class="pl-c"><span class="pl-c">#</span>(...) </span>
<span class="pl-c"><span class="pl-c">#</span> Initialize numerical parameters and arrays</span>
<span class="pl-c"><span class="pl-c">#</span>(...) </span>

<span class="pl-c"><span class="pl-c">#</span> Set up model geometry &amp; initial T structure</span>
<span class="pl-c"><span class="pl-c">#</span> (...)</span>
dike                    <span class="pl-k">=</span>   <span class="pl-c1">Dike</span>(W<span class="pl-k">=</span>W_in,H<span class="pl-k">=</span>H_in,Type<span class="pl-k">=</span>DikeType,T<span class="pl-k">=</span>T_in); <span class="pl-c"><span class="pl-c">#</span> "Reference" dike with given thickness,radius and T</span>
T                       <span class="pl-k">.=</span>   <span class="pl-k">-</span>Z<span class="pl-k">.*</span>GeoT;                                <span class="pl-c"><span class="pl-c">#</span> Initial (linear) temperature profile</span>
Phi, dPhi_dt            <span class="pl-k">=</span>   <span class="pl-c1">SolidFraction</span>(T, Phi_o, dt);              <span class="pl-c"><span class="pl-c">#</span> Compute solid fractio</span>
<span class="pl-c"><span class="pl-c">#</span> Preparation of visualisation</span>
<span class="pl-c"><span class="pl-c">#</span>(...)</span>

time, dike_inj, InjectVol, Time_vec,Melt_Time <span class="pl-k">=</span> <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>,<span class="pl-c1">zeros</span>(nt,<span class="pl-c1">1</span>),<span class="pl-c1">zeros</span>(nt,<span class="pl-c1">1</span>);
<span class="pl-k">for</span> it <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>nt   <span class="pl-c"><span class="pl-c">#</span> Time loop</span>

    <span class="pl-k">if</span> <span class="pl-c1">floor</span>(time<span class="pl-k">/</span>InjectionInterval)<span class="pl-k">&gt;</span> dike_inj                                      <span class="pl-c"><span class="pl-c">#</span> Add new dike every X years</span>
        dike_inj  <span class="pl-k">=</span>   <span class="pl-c1">floor</span>(time<span class="pl-k">/</span>InjectionInterval)                                 <span class="pl-c"><span class="pl-c">#</span> Keeps track on what was injected already</span>
        cen       <span class="pl-k">=</span>   [W<span class="pl-k">/</span><span class="pl-c1">2.</span>; <span class="pl-k">-</span>H<span class="pl-k">/</span><span class="pl-c1">2.</span>] <span class="pl-k">+</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">0.5</span><span class="pl-k">:</span><span class="pl-c1">1e-3</span><span class="pl-k">:</span><span class="pl-c1">0.5</span>, <span class="pl-c1">2</span>)<span class="pl-k">.*</span>[W_ran;H_ran];        <span class="pl-c"><span class="pl-c">#</span> Randomly vary center of dike </span>
        <span class="pl-k">if</span> cen[<span class="pl-c1">end</span>]<span class="pl-k">&lt;-</span><span class="pl-c1">12</span>km;  Angle_rand <span class="pl-k">=</span> <span class="pl-c1">rand</span>( <span class="pl-c1">80.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">100.0</span>)                      <span class="pl-c"><span class="pl-c">#</span> Orientation: near-vertical @ depth             </span>
        <span class="pl-k">else</span>                Angle_rand <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">10.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>); <span class="pl-k">end</span>                  <span class="pl-c"><span class="pl-c">#</span> Orientation: near-vertical @ shallower depth     </span>
        dike      <span class="pl-k">=</span>   <span class="pl-c1">Dike</span>(dike, Center<span class="pl-k">=</span>cen[:],Angle<span class="pl-k">=</span>[Angle_rand]);                 <span class="pl-c"><span class="pl-c">#</span> Specify dike with random location/angle but fixed size/T </span>
        Tracers, T, Vol     <span class="pl-k">=</span>   <span class="pl-c1">InjectDike</span>(Tracers, T, Grid, dike, nTr_dike);       <span class="pl-c"><span class="pl-c">#</span> Add dike, move hostrocks</span>
        InjectVol           <span class="pl-k">+=</span>  Vol                                                 <span class="pl-c"><span class="pl-c">#</span> Keep track of injected volume</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Added new dike; total injected magma volume = <span class="pl-v">$(<span class="pl-c1">round</span>(InjectVol<span class="pl-k">/</span>km³,digits<span class="pl-k">=</span><span class="pl-c1">2</span>))</span> km³; rate Q=<span class="pl-v">$(<span class="pl-c1">round</span>(InjectVol<span class="pl-k">/</span>(time),digits<span class="pl-k">=</span><span class="pl-c1">2</span>)</span>) m³/s<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
    
    Phi, dPhi_dt     <span class="pl-k">=</span>  <span class="pl-c1">SolidFraction</span>(T, Phi_o, dt);                                <span class="pl-c"><span class="pl-c">#</span> Compute solid fraction</span>
    K               <span class="pl-k">.=</span>  Phi<span class="pl-k">.*</span>k_rock <span class="pl-k">.+</span> (<span class="pl-c1">1</span> <span class="pl-k">.-</span> Phi)<span class="pl-k">.*</span>k_magma;                         <span class="pl-c"><span class="pl-c">#</span> Thermal conductivity</span>

    <span class="pl-c"><span class="pl-c">#</span> Perform a diffusion step</span>
    <span class="pl-c1">@parallel</span> <span class="pl-c1">diffusion2D_step!</span>(Tnew, T, qx, qz, K, Kx, Kz, Rho, Cp, dt, dx, dz, La, dPhi_dt);  
    <span class="pl-c1">@parallel</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(T,<span class="pl-c1">2</span>)) <span class="pl-c1">bc2D_x!</span>(Tnew);                                                      <span class="pl-c"><span class="pl-c">#</span> set lateral boundary conditions (flux-free)</span>
    Tnew[:,<span class="pl-c1">1</span>] <span class="pl-k">.=</span> GeoT<span class="pl-k">*</span>H; Tnew[:,<span class="pl-c1">end</span>] <span class="pl-k">.=</span> <span class="pl-c1">0.0</span>;                                                    <span class="pl-c"><span class="pl-c">#</span> bottom &amp; top temperature (constant)</span>
    
    Tracers             <span class="pl-k">=</span>   <span class="pl-c1">UpdateTracers</span>(Tracers, Grid, Tnew, Phi);                            <span class="pl-c"><span class="pl-c">#</span> Update info on tracers </span>
    T, Tnew             <span class="pl-k">=</span>   Tnew, T;                                                            <span class="pl-c"><span class="pl-c">#</span> Update temperature</span>
    time                <span class="pl-k">=</span>   time <span class="pl-k">+</span> dt;                                                          <span class="pl-c"><span class="pl-c">#</span> Keep track of evolved time</span>
    Melt_Time[it]       <span class="pl-k">=</span>   <span class="pl-c1">sum</span>( <span class="pl-c1">1.0</span> <span class="pl-k">.-</span> Phi)<span class="pl-k">/</span>(Nx<span class="pl-k">*</span>Nz)                                            <span class="pl-c"><span class="pl-c">#</span> Melt fraction in crust    </span>
    Time_vec[it]        <span class="pl-k">=</span>   time;                                                               <span class="pl-c"><span class="pl-c">#</span> Vector with time</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span> Timestep <span class="pl-v">$it</span> = <span class="pl-v">$(<span class="pl-c1">round</span>(time<span class="pl-k">/</span>kyr<span class="pl-k">*</span><span class="pl-c1">100</span>)<span class="pl-k">/</span><span class="pl-c1">100</span>)</span> kyrs<span class="pl-pds">"</span></span>)

    <span class="pl-k">if</span> <span class="pl-c1">mod</span>(it,<span class="pl-c1">20</span>)<span class="pl-k">==</span><span class="pl-c1">0</span>  <span class="pl-c"><span class="pl-c">#</span> Visualisation</span>
        Phi_melt    <span class="pl-k">=</span>   <span class="pl-c1">1.0</span> <span class="pl-k">.-</span> Phi;     
        p1          <span class="pl-k">=</span>   <span class="pl-c1">heatmap</span>(x<span class="pl-k">/</span>km, z<span class="pl-k">/</span>km, T<span class="pl-k">'</span>,         aspect_ratio<span class="pl-k">=</span><span class="pl-c1">1</span>, xlims<span class="pl-k">=</span>(x[<span class="pl-c1">1</span>]<span class="pl-k">/</span>km,x[<span class="pl-c1">end</span>]<span class="pl-k">/</span>km), ylims<span class="pl-k">=</span>(z[<span class="pl-c1">1</span>]<span class="pl-k">/</span>km,z[<span class="pl-c1">end</span>]<span class="pl-k">/</span>km),   c<span class="pl-k">=</span><span class="pl-c1">:lajolla</span>, clims<span class="pl-k">=</span>(<span class="pl-c1">0.</span>,<span class="pl-c1">900.</span>), xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Width [km]<span class="pl-pds">"</span></span>,ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Depth [km]<span class="pl-pds">"</span></span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$(<span class="pl-c1">round</span>(time<span class="pl-k">/</span>kyr, digits<span class="pl-k">=</span><span class="pl-c1">2</span>))</span> kyrs<span class="pl-pds">"</span></span>, dpi<span class="pl-k">=</span><span class="pl-c1">200</span>, fontsize<span class="pl-k">=</span><span class="pl-c1">6</span>, colorbar_title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Temperature<span class="pl-pds">"</span></span>)
        p2          <span class="pl-k">=</span>   <span class="pl-c1">heatmap</span>(x<span class="pl-k">/</span>km, z<span class="pl-k">/</span>km, Phi_melt<span class="pl-k">'</span>,  aspect_ratio<span class="pl-k">=</span><span class="pl-c1">1</span>, xlims<span class="pl-k">=</span>(x[<span class="pl-c1">1</span>]<span class="pl-k">/</span>km,x[<span class="pl-c1">end</span>]<span class="pl-k">/</span>km), ylims<span class="pl-k">=</span>(z[<span class="pl-c1">1</span>]<span class="pl-k">/</span>km,z[<span class="pl-c1">end</span>]<span class="pl-k">/</span>km),   c<span class="pl-k">=</span><span class="pl-c1">:nuuk</span>,    clims<span class="pl-k">=</span>(<span class="pl-c1">0.</span>, <span class="pl-c1">1.</span> ), xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Width [km]<span class="pl-pds">"</span></span>,             dpi<span class="pl-k">=</span><span class="pl-c1">200</span>, fontsize<span class="pl-k">=</span><span class="pl-c1">6</span>, colorbar_title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Melt Fraction<span class="pl-pds">"</span></span>)
        <span class="pl-c1">plot</span>(p1, p2, layout<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)); <span class="pl-c1">frame</span>(anim)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>
<span class="pl-c1">gif</span>(anim, <span class="pl-s"><span class="pl-pds">"</span>Example2D.gif<span class="pl-pds">"</span></span>, fps <span class="pl-k">=</span> <span class="pl-c1">15</span>)   <span class="pl-c"><span class="pl-c">#</span> create gif animation</span>
<span class="pl-k">return</span> Time_vec, Melt_Time;
<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> end of main function</span>

Time_vec,Melt_Time <span class="pl-k">=</span> <span class="pl-c1">MainCode_2D</span>(); <span class="pl-c"><span class="pl-c">#</span> start the main code</span>
<span class="pl-c1">plot</span>(Time_vec<span class="pl-k">/</span>kyr, Melt_Time, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Time [kyrs]<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Fraction of crust that is molten<span class="pl-pds">"</span></span>, label<span class="pl-k">=</span><span class="pl-c1">:none</span>); <span class="pl-c1">png</span>(<span class="pl-s"><span class="pl-pds">"</span>Time_vs_Melt_Example2D<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span>Create plot</span></pre></div>
<p>The main routines are thus <code>InjectDike(..)</code>, which inserts a new dike (of given dimensions and orientation) into the domain, and <code>diffusion2D_step!(...)</code>, which computes thermal diffusion. Variable thermal conductivity, and latent heat are all taken into account.</p>
<p>The full code example can be downloaded <a href="./examples/Example2D.jl">here</a></p>
<h2><a id="user-content-100-lines-3d-example" class="anchor" aria-hidden="true" href="#100-lines-3d-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>100-lines 3D example</h2>
<p>To go from 2D to 3D, only a few minor changes to the code above are required. A movie of our example, which was computed on a laptop, is:
<a target="_blank" rel="noopener noreferrer" href="examples/movies/Example3D.gif"><img src="examples/movies/Example3D.gif" alt="3-D dike intrusion" style="max-width:100%;"></a></p>
<p>The main changes, compared to the 2D example, are:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="#(...)
using MagmaThermoKinematics.Diffusion3D
#(...)
using ParallelStencil.FiniteDifferences3D
using WriteVTK                                   

# Initialize 
@init_parallel_stencil(Threads, Float64, 3);    # initialize parallel stencil in 2D

#------------------------------------------------------------------------------------------
@views function MainCode_3D();

# Model parameters
W,L,H                   =   30km,30km,30km;         # Width, Length, Height
#(...)
x_in,y_in,z_in          =   20km,20km,-15km;        # Center of dike [x,y,z coordinates]
W_in, H_in              =   5km,  0.5km;            # Width and thickness of dike [m]
#(..)
Nx, Ny, Nz              =   250, 250, 250;                    # Resolution
dx,dy,dz                =   W/(Nx-1), L/(Nx-1), H/(Nz-1);     # Grid size [m]
#(...)

# Array initializations
#(...)

# Set up model geometry &amp; initial T structure
x,y,z                   =   (0:Nx-1)*dx, (0:Ny-1)*dy, (-(Nz-1):0)*dz;       # 1D coordinate arrays
crd                     =   collect(Iterators.product(x,y,z))               # Generate coordinates from 1D coordinate vectors   
X,Y,Z                   =   (x-&gt;x[1]).(crd),(x-&gt;x[2]).(crd),(x-&gt;x[3]).(crd);# Transfer coords to 3D arrays
Grid                    =   (x,y,z);                                        # Grid 
#(...)

# Preparation of VTK/Paraview output 
if isdir(&quot;viz3D_out&quot;)==false mkdir(&quot;viz3D_out&quot;) end; loadpath = &quot;./viz3D_out/&quot;; pvd = paraview_collection(&quot;Example3D&quot;);

#(...)
for it = 1:nt   # Time loop

    if floor(time/InjectionInterval)&gt; dike_inj        # Add new dike every X years
        #(...)       
        cen             =   [W/2.;L/2.;-H/2.] + rand(-0.5:1e-3:0.5, 3).*[W_ran;W_ran;H_ran];    # Randomly vary center of dike 
        if cen[end]&lt;-12km;  Angle_rand = [rand(80.0:0.1:100.0); rand(0:360)]                    # Dikes at depth             
        else                Angle_rand = [rand(-10.0:0.1:10.0); rand(0:360)] end                # Sills at shallower depth
        dike            =   Dike(dike,Center=cen[:],Angle=Angle_rand);                          # Specify dike with random location/angle but fixed size 
        #(...)       
    end

    #(...)       
  
    # Perform a diffusion step
    @parallel diffusion3D_step_varK!(Tnew, T, qx, qy, qz, K, Kx, Ky, Kz, Rho, Cp, dt, dx, dy, dz,  La, dPhi_dt);  
    @parallel (1:size(T,2), 1:size(T,3)) bc3D_x!(Tnew);                                         # set lateral boundary conditions (flux-free)
    @parallel (1:size(T,1), 1:size(T,3)) bc3D_y!(Tnew);                                         # set lateral boundary conditions (flux-free)
    Tnew[:,:,1] .= GeoT*H; Tnew[:,:,end] .= 0.0;                                                # bottom &amp; top temperature (constant)
    
    #(...)

    if mod(it,10)==0  # Visualisation
        Phi_melt        =   1.0 .- Phi;             
        vtkfile = vtk_grid(&quot;./viz3D_out/ex3D_$(Int32(it+1e4))&quot;, Vector(x/km), Vector(y/km), Vector(z/km)) # 3-D
        vtkfile[&quot;Temperature&quot;] = T; vtkfile[&quot;MeltFraction&quot;] = Phi_melt;
        outfiles = vtk_save(vtkfile); pvd[time_kyrs] = vtkfile 
    end

end
vtk_save(pvd)


return nothing; #Tracers, T, Grid;
end # end of main function

MainCode_3D(); # start the main code
"><pre><span class="pl-c"><span class="pl-c">#</span>(...)</span>
<span class="pl-k">using</span> MagmaThermoKinematics<span class="pl-k">.</span>Diffusion3D
<span class="pl-c"><span class="pl-c">#</span>(...)</span>
<span class="pl-k">using</span> ParallelStencil<span class="pl-k">.</span>FiniteDifferences3D
<span class="pl-k">using</span> WriteVTK                                   

<span class="pl-c"><span class="pl-c">#</span> Initialize </span>
<span class="pl-c1">@init_parallel_stencil</span>(Threads, Float64, <span class="pl-c1">3</span>);    <span class="pl-c"><span class="pl-c">#</span> initialize parallel stencil in 2D</span>

<span class="pl-c"><span class="pl-c">#</span>------------------------------------------------------------------------------------------</span>
<span class="pl-c1">@views</span> <span class="pl-k">function</span> <span class="pl-en">MainCode_3D</span>();

<span class="pl-c"><span class="pl-c">#</span> Model parameters</span>
W,L,H                   <span class="pl-k">=</span>   <span class="pl-c1">30</span>km,<span class="pl-c1">30</span>km,<span class="pl-c1">30</span>km;         <span class="pl-c"><span class="pl-c">#</span> Width, Length, Height</span>
<span class="pl-c"><span class="pl-c">#</span>(...)</span>
x_in,y_in,z_in          <span class="pl-k">=</span>   <span class="pl-c1">20</span>km,<span class="pl-c1">20</span>km,<span class="pl-k">-</span><span class="pl-c1">15</span>km;        <span class="pl-c"><span class="pl-c">#</span> Center of dike [x,y,z coordinates]</span>
W_in, H_in              <span class="pl-k">=</span>   <span class="pl-c1">5</span>km,  <span class="pl-c1">0.5</span>km;            <span class="pl-c"><span class="pl-c">#</span> Width and thickness of dike [m]</span>
<span class="pl-c"><span class="pl-c">#</span>(..)</span>
Nx, Ny, Nz              <span class="pl-k">=</span>   <span class="pl-c1">250</span>, <span class="pl-c1">250</span>, <span class="pl-c1">250</span>;                    <span class="pl-c"><span class="pl-c">#</span> Resolution</span>
dx,dy,dz                <span class="pl-k">=</span>   W<span class="pl-k">/</span>(Nx<span class="pl-k">-</span><span class="pl-c1">1</span>), L<span class="pl-k">/</span>(Nx<span class="pl-k">-</span><span class="pl-c1">1</span>), H<span class="pl-k">/</span>(Nz<span class="pl-k">-</span><span class="pl-c1">1</span>);     <span class="pl-c"><span class="pl-c">#</span> Grid size [m]</span>
<span class="pl-c"><span class="pl-c">#</span>(...)</span>

<span class="pl-c"><span class="pl-c">#</span> Array initializations</span>
<span class="pl-c"><span class="pl-c">#</span>(...)</span>

<span class="pl-c"><span class="pl-c">#</span> Set up model geometry &amp; initial T structure</span>
x,y,z                   <span class="pl-k">=</span>   (<span class="pl-c1">0</span><span class="pl-k">:</span>Nx<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>dx, (<span class="pl-c1">0</span><span class="pl-k">:</span>Ny<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>dy, (<span class="pl-k">-</span>(Nz<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">:</span><span class="pl-c1">0</span>)<span class="pl-k">*</span>dz;       <span class="pl-c"><span class="pl-c">#</span> 1D coordinate arrays</span>
crd                     <span class="pl-k">=</span>   <span class="pl-c1">collect</span>(Iterators<span class="pl-k">.</span><span class="pl-c1">product</span>(x,y,z))               <span class="pl-c"><span class="pl-c">#</span> Generate coordinates from 1D coordinate vectors   </span>
X,Y,Z                   <span class="pl-k">=</span>   (x<span class="pl-k">-&gt;</span>x[<span class="pl-c1">1</span>]).(crd),(x<span class="pl-k">-&gt;</span>x[<span class="pl-c1">2</span>]).(crd),(x<span class="pl-k">-&gt;</span>x[<span class="pl-c1">3</span>]).(crd);<span class="pl-c"><span class="pl-c">#</span> Transfer coords to 3D arrays</span>
Grid                    <span class="pl-k">=</span>   (x,y,z);                                        <span class="pl-c"><span class="pl-c">#</span> Grid </span>
<span class="pl-c"><span class="pl-c">#</span>(...)</span>

<span class="pl-c"><span class="pl-c">#</span> Preparation of VTK/Paraview output </span>
<span class="pl-k">if</span> <span class="pl-c1">isdir</span>(<span class="pl-s"><span class="pl-pds">"</span>viz3D_out<span class="pl-pds">"</span></span>)<span class="pl-k">==</span><span class="pl-c1">false</span> <span class="pl-c1">mkdir</span>(<span class="pl-s"><span class="pl-pds">"</span>viz3D_out<span class="pl-pds">"</span></span>) <span class="pl-k">end</span>; loadpath <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>./viz3D_out/<span class="pl-pds">"</span></span>; pvd <span class="pl-k">=</span> <span class="pl-c1">paraview_collection</span>(<span class="pl-s"><span class="pl-pds">"</span>Example3D<span class="pl-pds">"</span></span>);

<span class="pl-c"><span class="pl-c">#</span>(...)</span>
<span class="pl-k">for</span> it <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>nt   <span class="pl-c"><span class="pl-c">#</span> Time loop</span>

    <span class="pl-k">if</span> <span class="pl-c1">floor</span>(time<span class="pl-k">/</span>InjectionInterval)<span class="pl-k">&gt;</span> dike_inj        <span class="pl-c"><span class="pl-c">#</span> Add new dike every X years</span>
        <span class="pl-c"><span class="pl-c">#</span>(...)       </span>
        cen             <span class="pl-k">=</span>   [W<span class="pl-k">/</span><span class="pl-c1">2.</span>;L<span class="pl-k">/</span><span class="pl-c1">2.</span>;<span class="pl-k">-</span>H<span class="pl-k">/</span><span class="pl-c1">2.</span>] <span class="pl-k">+</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">0.5</span><span class="pl-k">:</span><span class="pl-c1">1e-3</span><span class="pl-k">:</span><span class="pl-c1">0.5</span>, <span class="pl-c1">3</span>)<span class="pl-k">.*</span>[W_ran;W_ran;H_ran];    <span class="pl-c"><span class="pl-c">#</span> Randomly vary center of dike </span>
        <span class="pl-k">if</span> cen[<span class="pl-c1">end</span>]<span class="pl-k">&lt;-</span><span class="pl-c1">12</span>km;  Angle_rand <span class="pl-k">=</span> [<span class="pl-c1">rand</span>(<span class="pl-c1">80.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">100.0</span>); <span class="pl-c1">rand</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">360</span>)]                    <span class="pl-c"><span class="pl-c">#</span> Dikes at depth             </span>
        <span class="pl-k">else</span>                Angle_rand <span class="pl-k">=</span> [<span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">10.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>); <span class="pl-c1">rand</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">360</span>)] <span class="pl-k">end</span>                <span class="pl-c"><span class="pl-c">#</span> Sills at shallower depth</span>
        dike            <span class="pl-k">=</span>   <span class="pl-c1">Dike</span>(dike,Center<span class="pl-k">=</span>cen[:],Angle<span class="pl-k">=</span>Angle_rand);                          <span class="pl-c"><span class="pl-c">#</span> Specify dike with random location/angle but fixed size </span>
        <span class="pl-c"><span class="pl-c">#</span>(...)       </span>
    <span class="pl-k">end</span>

    <span class="pl-c"><span class="pl-c">#</span>(...)       </span>
  
    <span class="pl-c"><span class="pl-c">#</span> Perform a diffusion step</span>
    <span class="pl-c1">@parallel</span> <span class="pl-c1">diffusion3D_step_varK!</span>(Tnew, T, qx, qy, qz, K, Kx, Ky, Kz, Rho, Cp, dt, dx, dy, dz,  La, dPhi_dt);  
    <span class="pl-c1">@parallel</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(T,<span class="pl-c1">2</span>), <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(T,<span class="pl-c1">3</span>)) <span class="pl-c1">bc3D_x!</span>(Tnew);                                         <span class="pl-c"><span class="pl-c">#</span> set lateral boundary conditions (flux-free)</span>
    <span class="pl-c1">@parallel</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(T,<span class="pl-c1">1</span>), <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(T,<span class="pl-c1">3</span>)) <span class="pl-c1">bc3D_y!</span>(Tnew);                                         <span class="pl-c"><span class="pl-c">#</span> set lateral boundary conditions (flux-free)</span>
    Tnew[:,:,<span class="pl-c1">1</span>] <span class="pl-k">.=</span> GeoT<span class="pl-k">*</span>H; Tnew[:,:,<span class="pl-c1">end</span>] <span class="pl-k">.=</span> <span class="pl-c1">0.0</span>;                                                <span class="pl-c"><span class="pl-c">#</span> bottom &amp; top temperature (constant)</span>
    
    <span class="pl-c"><span class="pl-c">#</span>(...)</span>

    <span class="pl-k">if</span> <span class="pl-c1">mod</span>(it,<span class="pl-c1">10</span>)<span class="pl-k">==</span><span class="pl-c1">0</span>  <span class="pl-c"><span class="pl-c">#</span> Visualisation</span>
        Phi_melt        <span class="pl-k">=</span>   <span class="pl-c1">1.0</span> <span class="pl-k">.-</span> Phi;             
        vtkfile <span class="pl-k">=</span> <span class="pl-c1">vtk_grid</span>(<span class="pl-s"><span class="pl-pds">"</span>./viz3D_out/ex3D_<span class="pl-v">$(<span class="pl-c1">Int32</span>(it<span class="pl-k">+</span><span class="pl-c1">1e4</span>))</span><span class="pl-pds">"</span></span>, <span class="pl-c1">Vector</span>(x<span class="pl-k">/</span>km), <span class="pl-c1">Vector</span>(y<span class="pl-k">/</span>km), <span class="pl-c1">Vector</span>(z<span class="pl-k">/</span>km)) <span class="pl-c"><span class="pl-c">#</span> 3-D</span>
        vtkfile[<span class="pl-s"><span class="pl-pds">"</span>Temperature<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> T; vtkfile[<span class="pl-s"><span class="pl-pds">"</span>MeltFraction<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> Phi_melt;
        outfiles <span class="pl-k">=</span> <span class="pl-c1">vtk_save</span>(vtkfile); pvd[time_kyrs] <span class="pl-k">=</span> vtkfile 
    <span class="pl-k">end</span>

<span class="pl-k">end</span>
<span class="pl-c1">vtk_save</span>(pvd)


<span class="pl-k">return</span> <span class="pl-c1">nothing</span>; <span class="pl-c"><span class="pl-c">#</span>Tracers, T, Grid;</span>
<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> end of main function</span>

<span class="pl-c1">MainCode_3D</span>(); <span class="pl-c"><span class="pl-c">#</span> start the main code</span></pre></div>
<p>The result of the script are a range of VTK files, which can be visualized with the 3D software <a href="https://www.paraview.org" rel="nofollow">Paraview</a>. The full code example can be downloaded <a href="./examples/Example3D.jl">here</a>, and the paraview statefile (to reproduce the movie) is available <a href="./examples/movies/Example3D_Paraview.pvsm">here</a>.</p>
<h2><a id="user-content-dependencies" class="anchor" aria-hidden="true" href="#dependencies"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dependencies</h2>
<p>We rely on <a href="https://github.com/omlins/ParallelStencil.jl">ParallelStencil.jl</a> to for the energy solver, <a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a> to generate an aray of tracer structures, <a href="https://docs.julialang.org/en/v1/stdlib/Random/" rel="nofollow">Random.jl</a> for random number generation, <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a> to simplify setting parameters (such as specifying dike properties), <a href="https://github.com/JuliaMath/Interpolations.jl">Interpolations.jl</a> to interpolate properties such as temperature from a fixed grid to tracers, and <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> for speed. All these dependencies should be installed automatically if you install <code>MagmaThermoKinematics.jl</code>.</p>
<p><a href="http://docs.juliaplots.org/latest/" rel="nofollow">Plots.jl</a> is employed for plotting, and <a href="https://github.com/jipolanco/WriteVTK.jl">WriteVTK.jl</a> is used in the 3D example to generate <code>*.vtr/*.pvd</code> files that can be visualized with <a href="https://www.paraview.org" rel="nofollow">Paraview</a>. You have to add both packages yourself; they are however anyways useful to have.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>After installing julia in the usual manner, you can add (and test) the package with</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt;]
  pkg&gt; add https://github.com/omlins/ParallelStencil.jl
  pkg&gt; add https://github.com/boriskaus/MagmaThermoKinematics.jl
  pkg&gt; test MagmaThermoKinematics
"><pre><code>julia&gt;]
  pkg&gt; add https://github.com/omlins/ParallelStencil.jl
  pkg&gt; add https://github.com/boriskaus/MagmaThermoKinematics.jl
  pkg&gt; test MagmaThermoKinematics
</code></pre></div>
<p>We use ParallelStencil.jl, which is not (yet) a registed julia package, which is why you have to install that first.
The testing suite run above performs a large number of tests and, among others, compares the results with analytical solutions for advection/diffusion. Let us know if you encounter problems.</p>
<p>If you want to run the examples and create plots, you may also want to install these two packages:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt;]
  pkg&gt; add Plots
  pkg&gt; add WriteVTK
"><pre><code>julia&gt;]
  pkg&gt; add Plots
  pkg&gt; add WriteVTK
</code></pre></div>
<p>Next, you can download one of the codes above, put it in your current directory, and start it with</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; include(&quot;Example2D.jl&quot;)
"><pre><code>julia&gt; include("Example2D.jl")
</code></pre></div>
<p>And finally, if you have installed this package previously on your system, but want to update it to the latest version:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt;]
  pkg&gt; update MagmaThermoKinematics
"><pre><code>julia&gt;]
  pkg&gt; update MagmaThermoKinematics
</code></pre></div>
<h2><a id="user-content-dependencies-1" class="anchor" aria-hidden="true" href="#dependencies-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dependencies</h2>
</article></div>