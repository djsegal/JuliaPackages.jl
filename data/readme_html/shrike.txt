<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-shrikejl" class="anchor" aria-hidden="true" href="#shrikejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Shrike.jl</h1>
<p dir="auto"><a href="https://github.com/djpasseyjr/Shrike.jl/actions/workflows/ci.yml/badge.svg"><img src="https://github.com/djpasseyjr/Shrike.jl/actions/workflows/ci.yml/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/djpasseyjr/Shrike.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/55a5dff21e9b538d6e7634468db0893c5a29a3b6d0a6302896d6485f537d39e7/68747470733a2f2f636f6465636f762e696f2f67682f646a7061737365796a722f536872696b652e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d5337504e58514f4c514b" alt="codecov" data-canonical-src="https://codecov.io/gh/djpasseyjr/Shrike.jl/branch/main/graph/badge.svg?token=S7PNXQOLQK" style="max-width: 100%;"></a>
<a href="https://djpasseyjr.github.io/Shrike.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/rppartition.png"><img src="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/rppartition.png" alt="Random Projection Splits" style="max-width: 100%;"></a></p>
<p dir="auto"><code>Shrike</code> is a 100% pure Julia package for building ensembles of random projection trees. Random projection trees are a generalization of KD-Trees and are used to quickly approximate nearest neighbors or build k-nearest-neighbor graphs. They <a href="https://cseweb.ucsd.edu/~dasgupta/papers/rptree-stoc.pdf" rel="nofollow">conform to low dimensionality</a> that is often present in high dimensional data.</p>
<p dir="auto">The implementation here is based on the <a href="https://helda.helsinki.fi//bitstream/handle/10138/301147/Hyvonen_Pitkanen_2016_Fast_Nearest.pdf?sequence=1" rel="nofollow">MRPT algorithm</a>. This package also includes optimizations for knn-graph creation and has built-in support for multithreading.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">To install just type</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="] add Shrike"><pre>] add Shrike</pre></div>
<p dir="auto">in the REPL or</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(&quot;Shrike&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>Shrike<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-build-an-index" class="anchor" aria-hidden="true" href="#build-an-index"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Build an Index</h2>
<p dir="auto">To build an ensemble of random projection trees use the <code>ShrikeIndex</code> type.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Shrike
maxk = 100
X = rand(100, 10000)
shi = ShrikeIndex(X, maxk; depth=8, ntrees=10)"><pre><span class="pl-k">using</span> Shrike
maxk <span class="pl-k">=</span> <span class="pl-c1">100</span>
X <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">10000</span>)
shi <span class="pl-k">=</span> <span class="pl-c1">ShrikeIndex</span>(X, maxk; depth<span class="pl-k">=</span><span class="pl-c1">8</span>, ntrees<span class="pl-k">=</span><span class="pl-c1">10</span>)</pre></div>
<p dir="auto">The type accepts a matrix of data, <code>X</code> where each column represents a datapoint.</p>
<ol dir="auto">
<li><code>maxk</code> represents the maximum number of nearest neighbors you will be able to find with this index.
<code>maxk</code> is used to set a safe <code>depth</code> for the tree. You can also construct an index without this parameter if you need to.</li>
<li><code>depth</code> describes the number of times each random projection tree will split the data. Leaf nodes in the tree contain about <code>npoints / 2^depth</code> data points. Increasing <code>depth</code> increases speed but decreases accuracy. By default, the index sets depth as large as possible.</li>
<li><code>ntrees</code> controls the number of trees in the ensemble. More trees means more accuracy but more memory.</li>
</ol>
<p dir="auto">In this case, since we need an index that can find the 100 nearest neighbors, setting <code>depth</code> equal to 8 will result in
some leaf nodes with less than 100 points. The index will infer this using <code>maxk</code> and set the <code>depth</code> to be as large as
possible given <code>maxk</code>. In this case, <code>depth =  6</code>.</p>
<p dir="auto">To query the index for approximate 10 nearest neighbors use:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="k = 10
q = X[:, 1]
approx_nn = ann(shi, q, k; vote_cutoff=2)"><pre>k <span class="pl-k">=</span> <span class="pl-c1">10</span>
q <span class="pl-k">=</span> X[:, <span class="pl-c1">1</span>]
approx_nn <span class="pl-k">=</span> <span class="pl-c1">ann</span>(shi, q, k; vote_cutoff<span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>
<ol dir="auto">
<li>The <code>vote_cutoff</code> parameter signifies how many "votes" a point needs in order to be included in a linear search. Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy. Each tree "votes" for all points in relevant leaf nodes. If there aren't many points in the leaves, and there aren't many trees, the odds of a point receiving more than one vote is low. Thus, when <code>depth</code> is large and <code>ntrees</code> is less than 5, it is reccomended to set <code>vote_cutoff = 1</code>.</li>
</ol>
<h2 dir="auto"><a id="user-content-knn-graphs" class="anchor" aria-hidden="true" href="#knn-graphs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>KNN-Graphs</h2>
<p dir="auto">This package includes fast algorithms to generate k-nearest-neighbor graphs and has specialized functions for this purpose. It uses neighbor of neighbor exploration (outlined <a href="https://arxiv.org/pdf/1602.00370.pdf" rel="nofollow">here</a>) to efficiently improve the accuracy of a knn-graph.</p>
<p dir="auto">Nearest neighbor graphs are used to give a sparse topology to large datasets. Their structure can be used to <a href="https://arxiv.org/pdf/1602.00370.pdf" rel="nofollow">project the data</a> onto a lower dimensional manifold, to cluster datapoints with community detection algorithms or to preform other analyses.</p>
<p dir="auto">To generate nearest neighbor graphs:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Shrike
X = rand(100, 10000)
shi = ShrikeIndex(X; depth=6, ntrees=5)
k = 10
g = knngraph(shi, k; vote_cutoff=1, ne_iters=1, gtype=SimpleDiGraph)"><pre><span class="pl-k">using</span> Shrike
X <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">10000</span>)
shi <span class="pl-k">=</span> <span class="pl-c1">ShrikeIndex</span>(X; depth<span class="pl-k">=</span><span class="pl-c1">6</span>, ntrees<span class="pl-k">=</span><span class="pl-c1">5</span>)
k <span class="pl-k">=</span> <span class="pl-c1">10</span>
g <span class="pl-k">=</span> <span class="pl-c1">knngraph</span>(shi, k; vote_cutoff<span class="pl-k">=</span><span class="pl-c1">1</span>, ne_iters<span class="pl-k">=</span><span class="pl-c1">1</span>, gtype<span class="pl-k">=</span>SimpleDiGraph)</pre></div>
<ol dir="auto">
<li>The <code>vote_cutoff</code> parameter signifies how many "votes" a point needs in order to be included in a linear search.</li>
<li><code>ne_iters</code> controlls how many iterations of neighbor exploration the algorithm will undergo. Successive iterations are increasingly fast. It is reccomened to use more iterations of neighbor exploration when the number of trees is small and less when many trees are used.</li>
<li>The <code>gtype</code> parameter allows the user to specify a <code>LightGraphs.jl</code> graph type to return. <code>gtype=identity</code> returns a sparse adjacency matrix.</li>
</ol>
<p dir="auto">If an array of nearest neighbor indices is preferred,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="nn = allknn(shi, k; vote_cutoff=1, ne_iters=0)"><pre>nn <span class="pl-k">=</span> <span class="pl-c1">allknn</span>(shi, k; vote_cutoff<span class="pl-k">=</span><span class="pl-c1">1</span>, ne_iters<span class="pl-k">=</span><span class="pl-c1">0</span>)</pre></div>
<p dir="auto">can be used to generate an <code>shi.npoints</code>x<code>k</code> array of integer indexes where <code>nn[i, :]</code> corresponds to the nearest neighbors of <code>X[:, i]</code>. The keyword arguments work in the same way as in <code>knngraph</code> (outlined above).</p>
<h2 dir="auto"><a id="user-content-threading" class="anchor" aria-hidden="true" href="#threading"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Threading</h2>
<p dir="auto"><code>Shrike</code> has built in support for multithreading. To allocate multiple threads, start <code>julia</code> with the <code>--threads</code> flag:</p>
<div class="highlight highlight-text-shell-session notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="user@sys:~$ julia --threads 4"><pre><span class="pl-e">user@sys:~</span>$ <span class="pl-s1">julia --threads 4</span></pre></div>
<p dir="auto">To see this at work, consider a small scale example:</p>
<div class="highlight highlight-text-shell-session notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="user@sys:~$ cmd=&quot;using Shrike; shi=ShrikeIndex(rand(100, 10000)); @time knngraph(shi, 10, ne_iters=1)&quot;
user@sys:~$ julia -e &quot;$cmd&quot;
  12.373127 seconds (8.66 M allocations: 4.510 GiB, 6.85% gc time, 18.88% compilation time)
user@sys:~$ julia  --threads 4 -e &quot;$cmd&quot;
  6.306410 seconds (8.67 M allocations: 4.498 GiB, 13.12% gc time, 31.64% compilation time)"><pre><span class="pl-e">user@sys:~</span>$ <span class="pl-s1">cmd=<span class="pl-s"><span class="pl-pds">"</span>using Shrike; shi=ShrikeIndex(rand(100, 10000)); @time knngraph(shi, 10, ne_iters=1)<span class="pl-pds">"</span></span></span>
<span class="pl-e">user@sys:~</span>$ <span class="pl-s1">julia -e <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$cmd</span><span class="pl-pds">"</span></span></span>
<span class="pl-c1">  12.373127 seconds (8.66 M allocations: 4.510 GiB, 6.85% gc time, 18.88% compilation time)</span>
<span class="pl-e">user@sys:~</span>$ <span class="pl-s1">julia  --threads 4 -e <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$cmd</span><span class="pl-pds">"</span></span></span>
<span class="pl-c1">  6.306410 seconds (8.67 M allocations: 4.498 GiB, 13.12% gc time, 31.64% compilation time)</span></pre></div>
<p dir="auto">(This assumes that <code>Shrike</code> is installed.)</p>
<h2 dir="auto"><a id="user-content-benchmark" class="anchor" aria-hidden="true" href="#benchmark"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Benchmark</h2>
<p dir="auto">This package was compared to the original <a href="https://github.com/vioshyvo/mrpt"><code>mrpt</code></a> C++ implementation (on which this algorithm was based), <a href="https://github.com/spotify/annoy"><code>annoy</code></a>, a popular package for approximate nearest neighbors, and <a href="https://github.com/KristofferC/NearestNeighbors.jl"><code>NearestNeighbors.jl</code></a>, a Julia package for nearest neighbor search. The benchmarks were written in the spirit of <a href="https://github.com/erikbern/ann-benchmarks"><code>ann-benchmarks</code></a>, a repository for comparing different approximate nearest neighbor algorithms. The datasets used for the benchmark were taken directly from <code>ann-benchmarks</code>. The following are links to the HDF5 files in question: <a href="http://ann-benchmarks.com/fashion-mnist-784-euclidean.hdf5" rel="nofollow">FashionMNIST</a>, <a href="http://ann-benchmarks.com/sift-128-euclidean.hdf5" rel="nofollow">SIFT</a>, <a href="http://ann-benchmarks.com/mnist-784-euclidean.hdf5" rel="nofollow">MNIST</a> and <a href="http://ann-benchmarks.com/gist-960-euclidean.hdf5" rel="nofollow">GIST</a>. The benchmarks below were run on a compute cluster, restricting all algorithms to a single thread.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/fashionmnist_bm.png"><img src="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/fashionmnist_bm.png" alt="FashionMNIST Speed Comparison" style="max-width: 100%;"></a></p>
<p dir="auto">In this plot, up and to the right is better. (Faster queries, better recall). Each point represents a parameter combination. For a full documentation of parameters run and timing methods consult the original scripts located in the <code>benchmark/</code> directory.</p>
<p dir="auto">This plot illustrates how for this dataset, on most parameter combinations, <code>Shrike</code> has better preformance. Compared to SIFT, below, where some parameter combinations are not as strong. We speculate that this has to do with the high dimensionality of points in FashionMNIST (d=784), compared to the lower dimensionality of SIFT (d=128).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/sift_bm.png"><img src="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/sift_bm.png" alt="SIFT Speed Comparison" style="max-width: 100%;"></a></p>
<p dir="auto">It is important to note that <code>NearestNeighbors.jl</code> was designed to return the <em>exact</em> k-nearest-neighbors as quickly as possible, and does not approximate, hence the high accuracy and lower speed.</p>
<p dir="auto">The takeaway here is that <code>Shrike</code> is fast! It is possibly a little faster than the original C++ implementation. Go Julia! We should note, that <code>Shrike</code> was <em>not</em> benchmarked against state of the art algorithms for approximate nearest neighbor search. These algorithms are faster than <code>annoy</code> and <code>mrpt</code>, but unfortunately, the developers of <code>Shrike</code> aren't familiar with these algorithms.</p>
</article></div>