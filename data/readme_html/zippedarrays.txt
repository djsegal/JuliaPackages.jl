<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-zipping-julia-arrays-together" class="anchor" aria-hidden="true" href="#zipping-julia-arrays-together"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Zipping Julia arrays together</h1>
<p dir="auto"><a href="./LICENSE.md"><img src="https://camo.githubusercontent.com/bbf49a2eb96e6f718803f2493bd7aa3baae61abb09b7f8fc185a94e08c504dc6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d627269676874677265656e2e7376673f7374796c653d666c6174" alt="License" data-canonical-src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" style="max-width: 100%;"></a>
<a href="https://github.com/emmt/ZippedArrays.jl/actions/workflows/CI.yml?query=branch%3Amaster"><img src="https://github.com/emmt/ZippedArrays.jl/actions/workflows/CI.yml/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/emmt/ZippedArrays-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/bef381ff6c2fa561c748d650b567de48fff3096d2980d7cce5db54a1032770b2/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f656d6d742f5a69707065644172726179732e6a6c3f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/emmt/ZippedArrays.jl?branch=master" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/emmt/ZippedArrays.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/840d90c008071395a646da3363c66233fbdc54aac31663f8dfc86d324ca13834/687474703a2f2f636f6465636f762e696f2f6769746875622f656d6d742f5a69707065644172726179732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="Coverage" data-canonical-src="http://codecov.io/github/emmt/ZippedArrays.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto"><code>ZippedArrays</code> is a <a href="https://julialang.org/" rel="nofollow">Julia</a> package to zip several (abstract) arrays
together for accessing their elements simultaneously.  For instance, assuming
that <code>A</code>, <code>B</code> and <code>C</code> are 3 Julia arrays, then:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ZippedArrays
Z = ZippedArray(A,B,C)"><pre><span class="pl-k">using</span> ZippedArrays
Z <span class="pl-k">=</span> <span class="pl-c1">ZippedArray</span>(A,B,C)</pre></div>
<p dir="auto">builds a zipped array instance <code>Z</code> such that the syntax <code>Z[i]</code> yields the
3-tuple <code>(A[i],B[i],C[i])</code> while the syntax <code>Z[i] = (a,b,c)</code> is equivalent to
<code>(A[i],B[i],C[i]) = (a,b,c)</code>.</p>
<p dir="auto">Any number of arrays can be zipped together, they must however have the same
indices (as returned by the <code>axes</code> method).</p>
<p dir="auto">To build an uninitialized zipped array of size <code>dims</code> whose elements are tuples
of items of types <code>T1</code>, <code>T2</code>, etc., call:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Z = ZippedArray{Tuple{T1,T2,...}}(undef, dims)"><pre>Z <span class="pl-k">=</span> <span class="pl-c1">ZippedArray</span><span class="pl-c1">{Tuple{T1,T2,...}}</span>(undef, dims)</pre></div>
<p dir="auto">For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Z = ZippedArray{Tuple{Int,Float64}}(undef, 2, 3, 4)"><pre>Z <span class="pl-k">=</span> <span class="pl-c1">ZippedArray</span><span class="pl-c1">{Tuple{Int,Float64}}</span>(undef, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)</pre></div>
<p dir="auto">builds a 3-dimensional array of size <code>(2,3,4)</code> and whose elements are 2-tuples
of type <code>Tuple{Int,Float64}</code>.</p>
<p dir="auto">Compared to the <code>zip</code> function which only provides means to iterate through its
arguments, a zipped array can be accessed in random order and for reading and
writing.  This makes zipped arrays useful for multi-key sorting.  For instance:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sort!(ZippedArray(A,B);
      lt = (x,y) -&gt; ifelse(x[1] == y[1], x[2] &lt; y[2], x[1] &lt; y[1]))"><pre><span class="pl-c1">sort!</span>(<span class="pl-c1">ZippedArray</span>(A,B);
      lt <span class="pl-k">=</span> (x,y) <span class="pl-k">-&gt;</span> <span class="pl-c1">ifelse</span>(x[<span class="pl-c1">1</span>] <span class="pl-k">==</span> y[<span class="pl-c1">1</span>], x[<span class="pl-c1">2</span>] <span class="pl-k">&lt;</span> y[<span class="pl-c1">2</span>], x[<span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> y[<span class="pl-c1">1</span>]))</pre></div>
<p dir="auto">will sort in-place vectors <code>A</code> and <code>B</code> such that the values in <code>A</code> are in
increasing order and, in case of equality, the values in <code>B</code> are in increasing
order.</p>
<p dir="auto">A zipped array is a simple immutable structure wrapped around the arguments of
<code>ZippedArray</code> so zipped arrays are almost costless to build.  Below is an
example of how to build an array <code>C</code> whose elements are pairs of values from
<code>A</code> and <code>B</code> and a zipped array <code>Z</code> also built from <code>A</code> and <code>B</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ZippedArrays
n = 10_000
A = rand(Float64, n)
B = rand(Int64, n)
C = [(A[i],B[i]) for i in 1:n]
Z = ZippedArray(A,B)
C == Z # yields true"><pre><span class="pl-k">using</span> ZippedArrays
n <span class="pl-k">=</span> <span class="pl-c1">10_000</span>
A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(Float64, n)
B <span class="pl-k">=</span> <span class="pl-c1">rand</span>(Int64, n)
C <span class="pl-k">=</span> [(A[i],B[i]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n]
Z <span class="pl-k">=</span> <span class="pl-c1">ZippedArray</span>(A,B)
C <span class="pl-k">==</span> Z <span class="pl-c"><span class="pl-c">#</span> yields true</span></pre></div>
<p dir="auto">The comparison <code>C == Z</code> shows that the two arrays are virtually the same
(although not the same object, that is <code>C !== Z</code>).  Building <code>Z</code> however
requires no copy of array elements and hardly requires additional memory, the
sizes of <code>Z</code> and <code>C</code> are indeed quite different:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; sizeof(Z)
16

julia&gt; sizeof(C)
160000"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(Z)
<span class="pl-c1">16</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(C)
<span class="pl-c1">160000</span></pre></div>
<p dir="auto">These numbers may depend on the architecture (here a 64-bit processor).</p>
<p dir="auto">Thanks to the in-lining of functions and optimizations, a zipped array may also
be faster.  For instance, with the arrays <code>C</code> and <code>Z</code> defined above:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using BenchmarkTools
function sum_first(A::AbstractArray{&lt;:Tuple})
    s = 0.0
    @inbounds @simd for i in eachindex(A)
        s += first(A[i])
    end
    return s
end
@btime sum_first($C) # 1.615 μs (0 allocations: 0 bytes)
@btime sum_first($Z) # 643.983 ns (0 allocations: 0 bytes)"><pre><span class="pl-k">using</span> BenchmarkTools
<span class="pl-k">function</span> <span class="pl-en">sum_first</span>(A<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Tuple}</span>)
    s <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
    <span class="pl-c1">@inbounds</span> <span class="pl-c1">@simd</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(A)
        s <span class="pl-k">+=</span> <span class="pl-c1">first</span>(A[i])
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> s
<span class="pl-k">end</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">sum_first</span>(<span class="pl-k">$</span>C) <span class="pl-c"><span class="pl-c">#</span> 1.615 μs (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">sum_first</span>(<span class="pl-k">$</span>Z) <span class="pl-c"><span class="pl-c">#</span> 643.983 ns (0 allocations: 0 bytes)</span></pre></div>
</article></div>