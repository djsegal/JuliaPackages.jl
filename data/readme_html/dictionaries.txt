<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-dictionariesjl" class="anchor" aria-hidden="true" href="#dictionariesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dictionaries.jl</h1>
<p><em>An alternative interface for dictionaries in Julia, for improved productivity and performance</em></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/andyferris/Dictionaries.jl/workflows/Test/badge.svg"><img src="https://github.com/andyferris/Dictionaries.jl/workflows/Test/badge.svg" alt="Test Status" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/andyferris/Dictionaries.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/fbd5b37648c2d4181597c9924986b60aef34868ee8bbc1431e0b5a31306f346b/68747470733a2f2f636f6465636f762e696f2f67682f616e64796665727269732f44696374696f6e61726965732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/andyferris/Dictionaries.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>This package is somewhat young - new features are being added and some (low-level) interfaces may be tweaked in the future, but things should be stable enough for general usage. Contributions welcome - please submit an issue or PR!</p>
<h2><a id="user-content-motivation" class="anchor" aria-hidden="true" href="#motivation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Motivation</h2>
<p>The high-level goal of this package is to define a new interface for dictionary and set structures which is convenient and efficient for functional data manipulation - including operations such as non-scalar indexing, broadcasting, mapping, filtering, reducing, grouping, and so-on. While Julia comes with built-in <code>AbstractDict</code> and <code>AbstractSet</code> supertypes, the interfaces for these are not as well established or generic as for <code>AbstractArray</code>, the built-in dictionaries implement less of the common data manipulation operations compared to arrays, and it is difficult to work with them in a performant manner.</p>
<p>In this package we aim to devise a cohesive interface for abstract dictionaries (or associative maps), having the common supertype <code>AbstractDictionary</code>. A large part of this is working with indices (of arbitrary type) as well as convenient and efficient iteration of the containers. A second goal is to make dictionary manipulation more closely resemble array manipulation, to make it easier for users. Simultaneously, we are pushing the performance of working with dictionaries to be closer to that of working with arrays.</p>
<h2><a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Getting started</h2>
<p>Dictionaries share the common supertype <code>AbstractDictionary</code>, and the go-to container in this package is <code>Dictionary</code> - which is a new hash-based implementation that serves as a replacement of Julia's inbuilt <code>Dict</code> type (using <code>hash</code> and <code>isequal</code> for key lookup and comparison). The three main difference to <code>Dict</code> are that it preserves the order of elements, it iterates much faster, and it iterates values rather than key-value pairs.</p>
<h3><a id="user-content-constructing-dictionaries" class="anchor" aria-hidden="true" href="#constructing-dictionaries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Constructing dictionaries</h3>
<p>You can construct one from a list of indices (or keys) and a list of values.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; dict = Dictionary([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [1, 2, 3])
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 1
 &quot;b&quot; │ 2
 &quot;c&quot; │ 3

julia&gt; dict[&quot;a&quot;]
1
"><pre>julia<span class="pl-k">&gt;</span> dict <span class="pl-k">=</span> <span class="pl-c1">Dictionary</span>([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>], [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>])
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> dict[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]
<span class="pl-c1">1</span></pre></div>
<p>The constructor also accepts any indexable container, preserving the keys and values.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; Dictionary(Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3))
3-element Dictionary{String,Int64}
 &quot;c&quot; │ 3
 &quot;b&quot; │ 2
 &quot;a&quot; │ 1
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Dictionary</span>(<span class="pl-c1">Dict</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">3</span>))
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span></pre></div>
<p>If you prefer, you can use the <code>dictionary</code> function to create a dictionary from something
that iterates key-value pairs (either as a <code>Pair</code> or a two-tuple, etc), somewhat like a
<code>Dict</code> constructor.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; dictionary([&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3])
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 1
 &quot;b&quot; │ 2
 &quot;c&quot; │ 3
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">dictionary</span>([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span>])
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span></pre></div>
<p>One final way to construct a dictionary is using the <code>index</code> function, which accepts a
function that constructs a "key" for each element in the collection.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; index(first, [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;])
3-element Dictionary{Char,String}
 'A' │ &quot;Alice&quot;
 'B' │ &quot;Bob&quot;
 'C' │ &quot;Charlie&quot;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">index</span>(first, [<span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span>])
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{Char,String}
 <span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">'</span>B<span class="pl-pds">'</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span></pre></div>
<h3><a id="user-content-accessing-dictionaries" class="anchor" aria-hidden="true" href="#accessing-dictionaries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Accessing dictionaries</h3>
<p>The values of <code>Dictionary</code> are mutable, or "settable", and can be modified via <code>setindex!</code>.
However, just like for <code>Array</code>s, new indices (keys) are <em>never</em> created or rearranged this way.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; dict[&quot;a&quot;] = 10
10

julia&gt; dict
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 10
 &quot;b&quot; │ 2
 &quot;c&quot; │ 3

julia&gt; dict[&quot;d&quot;] = 42
ERROR: IndexError(&quot;Dictionary does not contain index: d&quot;)
Stacktrace:
 [1] setindex!(::Dictionary{String,Int64}, ::Int64, ::String) at /home/ferris/.julia/dev/Dictionaries/src/AbstractDictionary.jl:347
 [2] top-level scope at REPL[7]:1
"><pre>julia<span class="pl-k">&gt;</span> dict[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>
<span class="pl-c1">10</span>

julia<span class="pl-k">&gt;</span> dict
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">10</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> dict[<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">42</span>
ERROR<span class="pl-k">:</span> <span class="pl-c1">IndexError</span>(<span class="pl-s"><span class="pl-pds">"</span>Dictionary does not contain index: d<span class="pl-pds">"</span></span>)
Stacktrace<span class="pl-k">:</span>
 [<span class="pl-c1">1</span>] <span class="pl-c1">setindex!</span>(<span class="pl-k">::</span><span class="pl-c1">Dictionary{String,Int64}</span>, <span class="pl-k">::</span><span class="pl-c1">Int64</span>, <span class="pl-k">::</span><span class="pl-c1">String</span>) at <span class="pl-k">/</span>home<span class="pl-k">/</span>ferris<span class="pl-k">/</span><span class="pl-k">.</span>julia<span class="pl-k">/</span>dev<span class="pl-k">/</span>Dictionaries<span class="pl-k">/</span>src<span class="pl-k">/</span>AbstractDictionary<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">347</span>
 [<span class="pl-c1">2</span>] top<span class="pl-k">-</span>level scope at REPL[<span class="pl-c1">7</span>]<span class="pl-k">:</span><span class="pl-c1">1</span></pre></div>
<p>The indices of <code>Dictionary</code> are said to be "insertable" - indices can be added or removed with the <code>insert!</code> and <code>delete!</code> functions.</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; insert!(dict, &quot;d&quot;, 42)
4-element Dictionary{String,Int64}
 &quot;a&quot; │ 10
 &quot;b&quot; │ 2
 &quot;c&quot; │ 3
 &quot;d&quot; │ 42

julia&gt; delete!(dict, &quot;d&quot;)
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 10
 &quot;b&quot; │ 2
 &quot;c&quot; │ 3
"><pre><code>julia&gt; insert!(dict, "d", 42)
4-element Dictionary{String,Int64}
 "a" │ 10
 "b" │ 2
 "c" │ 3
 "d" │ 42

julia&gt; delete!(dict, "d")
3-element Dictionary{String,Int64}
 "a" │ 10
 "b" │ 2
 "c" │ 3
</code></pre></div>
<p>Note that <code>insert!</code> and <code>delete!</code> are precise in the sense that <code>insert!</code> will error if the index already exists, and <code>delete!</code> will error if the index does not. The <code>set!</code> function provides "upsert" functionality ("update or insert") and <code>unset!</code> is useful for removing an index that may or may not exist.</p>
<h3><a id="user-content-working-with-dictionaries" class="anchor" aria-hidden="true" href="#working-with-dictionaries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Working with dictionaries</h3>
<p>Dictionaries can be manipulated and transformed using a similar interface to Julia's built-in arrays. The first thing to note is that dictionaries iterate values, so it easy to perform simple analytics on the dictionary values.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; dict = Dictionary([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [1, 2, 3])
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 1
 &quot;b&quot; │ 2
 &quot;c&quot; │ 3

julia&gt; sum(dict)
6

julia&gt; using Statistics; mean(dict)
2.0
"><pre>julia<span class="pl-k">&gt;</span> dict <span class="pl-k">=</span> <span class="pl-c1">Dictionary</span>([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>], [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>])
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(dict)
<span class="pl-c1">6</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Statistics; <span class="pl-c1">mean</span>(dict)
<span class="pl-c1">2.0</span></pre></div>
<p>Mapping and broadcasting also function as-per arrays, preserving the indices and transforming the corresponding values.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; map(iseven, dict)
3-element Dictionary{String,Bool}
 &quot;a&quot; │ false
 &quot;b&quot; │ true
 &quot;c&quot; │ false

julia&gt; map(*, dict, dict)
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 1
 &quot;b&quot; │ 4
 &quot;c&quot; │ 9

julia&gt; dict .+ 1
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 2
 &quot;b&quot; │ 3
 &quot;c&quot; │ 4
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(iseven, dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Bool}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">false</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">true</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">false</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(<span class="pl-k">*</span>, dict, dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">4</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">9</span>

julia<span class="pl-k">&gt;</span> dict <span class="pl-k">.+</span> <span class="pl-c1">1</span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">4</span></pre></div>
<p>There is a <code>mapview</code> function exported by <a href="https://github.com/JuliaData/SplitApplyCombine.jl">SplitApplyCombine.jl</a>, which is the lazy version of the above.</p>
<p>Filtering a dictionary also preserves the keys, dropping the remainder.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; filter(isodd, dict)
2-element Dictionary{String,Bool}
 &quot;a&quot; │ 1
 &quot;c&quot; │ 3
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">filter</span>(isodd, dict)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Dictionary{String,Bool}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span></pre></div>
<p>The <code>filterview</code> function is provided to lazily filter a dictionary, which may occassionally
be more performant when working with larger containers.</p>
<p>The <code>pairs</code> function allows access to both the index (key) and value when iterating.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; pairs(dict)
3-element Dictionaries.PairDictionary{String,Int64,Dictionary{String,Int64}}
 &quot;a&quot; │ &quot;a&quot; =&gt; 1
 &quot;b&quot; │ &quot;b&quot; =&gt; 2
 &quot;c&quot; │ &quot;c&quot; =&gt; 3

julia&gt; map(((k,v),) -&gt; k^v, pairs(dict))
3-element Dictionary{String,String}
 &quot;a&quot; │ &quot;a&quot;
 &quot;b&quot; │ &quot;bb&quot;
 &quot;c&quot; │ &quot;ccc&quot;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">pairs</span>(dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionaries<span class="pl-k">.</span>PairDictionary{String,Int64,Dictionary{String,Int64}}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(((k,v),) <span class="pl-k">-&gt;</span> k<span class="pl-k">^</span>v, <span class="pl-c1">pairs</span>(dict))
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>bb<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>ccc<span class="pl-pds">"</span></span></pre></div>
<h3><a id="user-content-indices" class="anchor" aria-hidden="true" href="#indices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Indices</h3>
<p>The indices of a dictionary are unique, and form a set (in the mathematical sense). You can get the indices for any dictionary with the <code>keys</code> function.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; keys(dict)
3-element Indices{String}
 &quot;a&quot;
 &quot;b&quot;
 &quot;c&quot;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">keys</span>(dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Indices{String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span></pre></div>
<p>Whenever you call <code>keys(::AbstractDictionary)</code>, you always receive an <code>AbstractIndices</code> in return.
<code>Indices</code> shares a similar implementation to <code>Base.Set</code> and can be used to perform set operations including <code>union</code>, <code>intersect</code>, <code>setdiff</code>, <code>symdiff</code>, and mutating counterparts. You can construct one from any iterable of unique elements.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; inds = Indices([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
3-element Indices{String}
 &quot;a&quot;
 &quot;b&quot;
 &quot;c&quot;
"><pre>julia<span class="pl-k">&gt;</span> inds <span class="pl-k">=</span> <span class="pl-c1">Indices</span>([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>])
<span class="pl-c1">3</span><span class="pl-k">-</span>element Indices{String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span></pre></div>
<p>You can also use the <code>distinct</code> function, which is similar to <code>unique</code> from <code>Base</code>, to construct indices where the input may not be unique.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; distinct([1,2,3,3])
3-element Indices{Int64}
 1
 2
 3
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">distinct</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>])
<span class="pl-c1">3</span><span class="pl-k">-</span>element Indices{Int64}
 <span class="pl-c1">1</span>
 <span class="pl-c1">2</span>
 <span class="pl-c1">3</span></pre></div>
<p>The <code>distinct</code> function may be considered as useful replacement of <code>unique</code> in many cases, as the <code>unique</code> function internally constructs a hashmap (<code>Set</code>) anyway before returning a <code>Vector</code>. However, a <code>Indices</code> iterates as fast as <code>Vector</code> and in many cases it can be useful to be able to <code>map</code> it into a dictionary.</p>
<p><code>Indices</code> are insertable, so you can use <code>insert!</code> and <code>delete!</code> (or <code>set!</code> and <code>unset!</code>) to add and remove elements.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; insert!(inds, &quot;d&quot;)
4-element Indices{String}
 &quot;a&quot;
 &quot;b&quot;
 &quot;c&quot;
 &quot;d&quot;

julia&gt; delete!(inds, &quot;d&quot;)
3-element Indices{String}
 &quot;a&quot;
 &quot;b&quot;
 &quot;c&quot;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">insert!</span>(inds, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Indices{String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">delete!</span>(inds, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Indices{String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span></pre></div>
<p>One crucial property of <code>AbstractIndices</code> is that they are a subtype of <code>AbstractDictionary</code> (similar to how the <code>keys</code> of an <code>AbstractArray</code> are always <code>AbstractArray</code>s). But how can a set, or indices, be a dictionary? Under <code>getindex</code>, they form a map from each element to itself.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; inds[&quot;b&quot;]
&quot;b&quot;
"><pre>julia<span class="pl-k">&gt;</span> inds[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]
<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span></pre></div>
<p>Thus, if you iterate an <code>AbstractIndices</code> you are guaranteed never to get the same value twice, and the collection is a set. All the usual set operations like <code>union</code>, <code>intersect</code>, <code>setdiff</code> and <code>symdiff</code> are defined, as well as a newly exported predicate function <code>disjoint(set1, set2)</code> which returns <code>true</code> if <code>set1</code> and <code>set2</code> do not intersect/overlap according to an elementwise <code>isequal</code> check, and <code>false</code> otherwise (note that <code>Dictionaries.disjoint</code> is deprecated in favour of <code>Base.isdisjoint</code> in Julia 1.5 onwards).</p>
<p>Since all dictionaries have <code>keys</code>, even indices must have <code>keys</code> - and in this case <code>keys(inds::AbstractIndices) === inds</code>.</p>
<h3><a id="user-content-working-with-indices" class="anchor" aria-hidden="true" href="#working-with-indices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Working with indices</h3>
<p>While the above properties for <code>AbstractIndices</code> may seem a little unnecessary at first, they lead to a variety of useful behavior.</p>
<p>If you wish to perform an operation on each element of a set, you can simply <code>map</code> or <code>broadcast</code> some indices, and return a dictionary. These operations cannot return an <code>AbstractIndices</code> since the mapping may or may not be one-to-one, so the results may not be distinct, while <code>map</code>/<code>broadcast</code> must preserve the number of elements and the <code>keys</code>.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; map(uppercase, inds)
3-element Dictionary{String,String}
 &quot;a&quot; │ &quot;A&quot;
 &quot;b&quot; │ &quot;B&quot;
 &quot;c&quot; │ &quot;C&quot;

julia&gt; inds .* &quot;at&quot;
3-element Dictionary{String,String}
 &quot;a&quot; │ &quot;aat&quot;
 &quot;b&quot; │ &quot;bat&quot;
 &quot;c&quot; │ &quot;cat&quot;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(uppercase, inds)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> inds <span class="pl-k">.*</span> <span class="pl-s"><span class="pl-pds">"</span>at<span class="pl-pds">"</span></span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>aat<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>bat<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span></pre></div>
<p>You can filter indices.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; filter(in([&quot;a&quot;, &quot;b&quot;]), inds)
2-element Indices{String}
 &quot;a&quot;
 &quot;b&quot;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">filter</span>(<span class="pl-c1">in</span>([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]), inds)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Indices{String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span></pre></div>
<p>To find the subset of dictionary indices/keys that satisfy some constraint on the values, use the <code>findall</code> function.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; dict
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 1
 &quot;b&quot; │ 2
 &quot;c&quot; │ 3

julia&gt; inds2 = findall(isodd, dict)
2-element Indices{String}
 &quot;a&quot;
 &quot;c&quot;
"><pre>julia<span class="pl-k">&gt;</span> dict
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">2</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> inds2 <span class="pl-k">=</span> <span class="pl-c1">findall</span>(isodd, dict)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Indices{String}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span></pre></div>
<p>And, finally, one useful thing you can do with indices is, well, <em>indexing</em>. Non-scalar indexing of dictionaries is a little more complicated than that of arrays, since there is an ambiguity on whether the indexer is a <em>single</em> index or a collection of indices (for arrays, the scalar indices are integers (or <code>CartesianIndex</code>es) so this ambiguity is less of a problem). The <a href="https://github.com/andyferris/Indexing.jl">Indexing.jl</a> provides the <code>getindices</code> function to return a container with the same indices as the indexer, and this is re-exported here.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; getindices(dict, inds2)
2-element Dictionary{String,Int64}
 &quot;a&quot; │ 1
 &quot;c&quot; │ 3
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">getindices</span>(dict, inds2)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span></pre></div>
<p>It has <a href="https://github.com/JuliaLang/julia/issues/30845">been suggested</a> to make the syntax <code>dict.[inds2]</code> available in Julia in the future for unambiguous non-scalar indexing.</p>
<p>Lazy non-scalar indexing may be achieved, as usual, with the <code>view</code> function.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; view(dict, inds2)
2-element DictionaryView{String,Int64,Indices{String},Dictionary{String,Int64}}
 &quot;a&quot; │ 1
 &quot;c&quot; │ 3
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">view</span>(dict, inds2)
<span class="pl-c1">2</span><span class="pl-k">-</span>element DictionaryView{String,Int64,Indices{String},Dictionary{String,Int64}}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span></pre></div>
<p>Boolean or "logical" indexing is also ambiguous with scalar and non-scalar indexing. Luckily, the <code>findall</code> function is a convenient way to convert a Boolean-valued dictionary into indices, which we can use with <code>getindices</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; isodd.(dict)
3-element Dictionary{String,Bool}
 &quot;a&quot; │ true
 &quot;b&quot; │ false
 &quot;c&quot; │ true

julia&gt; getindices(dict, findall(isodd.(dict)))
2-element Dictionary{String,Int64}
 &quot;a&quot; │ 1
 &quot;c&quot; │ 3
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">isodd</span>.(dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Bool}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">true</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">false</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getindices</span>(dict, <span class="pl-c1">findall</span>(<span class="pl-c1">isodd</span>.(dict)))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">1</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">3</span></pre></div>
<p>(Who knows - maybe we need syntax for this, too?)</p>
<h3><a id="user-content-other-dictionary-types" class="anchor" aria-hidden="true" href="#other-dictionary-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Other dictionary types</h3>
<p>The <code>ArrayDictionary</code> container is a simple, iteration-based dictionary that may be faster for smaller collections. It's <code>keys</code> are the corresponding <code>ArrayIndices</code> type. By default these contain <code>Vector</code>s which support mutation, insertion and tokenization, but they can contain other arrays such as <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>SVector</code></a>s (which make for good statically-sized dictionaries, with similarities with <code>Base.ImmutableDict</code>).</p>
<p>There is a <code>FillDictionary</code> container which lazily maps every key to the same value (only keeping a single copy of the value).</p>
<p>Indices that are based on sort ordering instead of hashing (both in a dense sorted form and as a B-tree or similar) are also planned.</p>
<h3><a id="user-content-factories-for-dictionary-creation" class="anchor" aria-hidden="true" href="#factories-for-dictionary-creation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Factories for dictionary creation</h3>
<h4><a id="user-content-dictionaries-with-the-same-indices" class="anchor" aria-hidden="true" href="#dictionaries-with-the-same-indices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dictionaries with the same indices</h4>
<p>The <code>similar</code> function is used to create a dictionary with defined indices, but undefined values that can be set/mutated after the fact. <code>similar(dict, T)</code> creates a container with the same indices as <code>dict</code> and, optionally, a new element type.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; similar(dict, Vector{Int})
3-element Dictionary{String,Array{Int64,1}}
 &quot;a&quot; │ #undef
 &quot;b&quot; │ #undef
 &quot;c&quot; │ #undef
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">similar</span>(dict, Vector{Int})
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Array{Int64,<span class="pl-c1">1</span>}}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c"><span class="pl-c">#</span>undef</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c"><span class="pl-c">#</span>undef</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c"><span class="pl-c">#</span>undef</span></pre></div>
<p>The behaviour is the same if <code>dict</code> is an <code>AbstractIndices</code> - you always get a dictionary with settable/mutable elements. Preserving the indices using <code>similar</code> and setting the values provides a huge performance advantage compared to iteratively constructing a new dictionary via insertion (see the bottom of this README).</p>
<p>On the other hand, values can be initialized with the <code>fill(value, dict)</code> function.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; fill(42, dict)
3-element Dictionary{String,Int64}
 &quot;a&quot; │ 42
 &quot;b&quot; │ 42
 &quot;c&quot; │ 42
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">fill</span>(<span class="pl-c1">42</span>, dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Int64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">42</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">42</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">42</span></pre></div>
<p>The <code>fill</code> function can optionally define a wider type than the value, helpful for if you want to assign a default value like <code>missing</code> but allow this to be updated later.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; fill(missing, dict, Union{Missing, Int64})
3-element Dictionary{String,Union{Missing, Int64}}
 &quot;a&quot; │ missing
 &quot;b&quot; │ missing
 &quot;c&quot; │ missing
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">fill</span>(<span class="pl-c1">missing</span>, dict, Union{Missing, Int64})
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Union{Missing, Int64}}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">missing</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">missing</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">missing</span></pre></div>
<p>Functions <code>zeros</code>, <code>ones</code>, <code>falses</code> and <code>trues</code> are defined as a handy alternative to the above in common cases, as are <code>rand</code> and <code>randn</code>.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; zeros(dict)
3-element Dictionary{String,Float64}
 &quot;a&quot; │ 0.0
 &quot;b&quot; │ 0.0
 &quot;c&quot; │ 0.0

julia&gt; zeros(UInt8, dict)
3-element Dictionary{String,UInt8}
 &quot;a&quot; │ 0x00
 &quot;b&quot; │ 0x00
 &quot;c&quot; │ 0x00
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">zeros</span>(dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,Float64}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">0.0</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">0.0</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">0.0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">zeros</span>(UInt8, dict)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Dictionary{String,UInt8}
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> │ <span class="pl-c1">0x00</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> │ <span class="pl-c1">0x00</span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> │ <span class="pl-c1">0x00</span></pre></div>
<p>Note that the <em>indices</em> of the output are not guaranteed to be mutable/insertable - in fact, in the current implementation inserting or deleting indices to the output of the above can corrupt the input container (Julia suffers similar restrictions with <code>AbstractArray</code>s with mutable indices, for example changing the size of the indices of a <code>SubArray</code> can lead to corruption and segfaults). This also holds true for the output of <code>map</code>, <code>broadcast</code>, <code>getindices</code>, <code>similar</code>, <code>zeros</code>, <code>ones</code>, <code>falses</code> and <code>trues</code>. If you want a new container with indices you can insert, by sure to <code>copy</code> the indices furst, or use <code>empty</code> instead.</p>
<h4><a id="user-content-empty-insertable-dictionaries-indices" class="anchor" aria-hidden="true" href="#empty-insertable-dictionaries-indices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Empty, insertable dictionaries indices</h4>
<p>The <code>empty</code> function will create an insertable container which is "similar" to the input, with zero elements and the specified type for the indices and values.</p>
<ul>
<li><code>empty(x, I)</code> constructs an empty indices (whether <code>x</code> is a dictionary or indices).</li>
<li><code>empty(x, I, T)</code> constructs an empty dictionary (whether <code>x</code> is a dictionary or indices).</li>
<li><code>empty(x)</code> constructs an empty container - indices if <code>x</code> are indices, and a dictionary if <code>x</code> is a dictionary.</li>
</ul>
<h2><a id="user-content-types-interfaces-and-traits" class="anchor" aria-hidden="true" href="#types-interfaces-and-traits"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Types, interfaces and traits</h2>
<p>This section will be of primary interest to developers who wish to understand the internals to <em>Dictionaries.jl</em> or create their own custom dictionary types.</p>
<h3><a id="user-content-abstractdictionary" class="anchor" aria-hidden="true" href="#abstractdictionary"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>AbstractDictionary</code></h3>
<p>The common supertype to this package is <code>AbstractDictionary{I, T}</code>, which models an indexable container. To implement a simple <code>AbstractDictionary</code> all you need to implement is:</p>
<ul>
<li><code>getindex(::AbstractDictionary{I, T}, ::I) --&gt; T</code></li>
<li><code>keys(::AbstractDictionary{I, T}) --&gt; AbstractIndices{I}</code></li>
<li><code>isassigned(::AbstractDictionary{I, T}, ::I) --&gt; Bool</code></li>
</ul>
<h3><a id="user-content-abstractindices" class="anchor" aria-hidden="true" href="#abstractindices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>AbstractIndices</code></h3>
<p>Indexable containers in Julia have <code>keys</code>, which form a "set" in the mathematic sense of a collection of distinct elements. The <code>keys</code> of an <code>AbstractDictionary{I, T}</code> must have type <code>AbstractIndices{I}</code>. These form a set because no two elements in an <code>AbstractIndices</code> can be <code>isequal</code>. To implement a simple index type, you need to provide:</p>
<ul>
<li>The <code>iterate</code> protocol, returning unique values of type <code>I</code>.</li>
<li><code>in</code>, such that <code>in(i, indices)</code> implies there is an element of <code>indices</code> which <code>isequal</code> to <code>i</code>.</li>
<li>Either <code>length</code>, or override <code>IteratorSize</code> to <code>SizeUnknown</code>.</li>
</ul>
<p>Indices themselves are also dictionaries (much like the indices of <code>AbstractArray</code>s are also <code>AbstractArray</code>s), and we have the subtyping relationship <code>AbstractIndices{I} &lt;: AbstractDictionary{I, I}</code>. Indexing an <code>AbstractIndices</code> is always an identity operation, such that <code>indices[i] === i</code>. The <code>keys</code> function is also an identity operation on indices (<code>keys(indices::AbstractIndices) === indices</code>) and therefore idempotent on dictionaries (<code>keys(keys(dict::AbstractDictionary)) === keys(dict)</code>).</p>
<h3><a id="user-content-non-scalar-indexing" class="anchor" aria-hidden="true" href="#non-scalar-indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Non-scalar indexing</h3>
<p>Indexing an <code>AbstractDictionary</code> follows the interface provided by the <em>Indexing.jl</em> package. Since the indices of a dictionary may be of arbitrary type (including being a container such as an array or a dictionary), a function distinct to <code>getindex</code> is required to indicate non-scalar indexing.</p>
<p>The expression <code>dict3 = getindices(dict1, dict2)</code> follows the following simple rules:</p>
<ul>
<li>The output indices match the indexer, such that <code>issetequal(keys(dict3), keys(dict2))</code>.</li>
<li>The values of <code>dict3</code> come directly from <code>dict1</code>, such that <code>dict3[i] === dict1[dict2[i]]</code> for all <code>i in keys(dict2)</code>.</li>
</ul>
<p>Non-scalar indexing is simplified such that it is essentially <code>getindices(dict1, dict2) = map(i -&gt; dict1[i], dict2)</code>. Note also that <code>getindices(dict, keys(dict))</code> has the same keys and values as <code>dict</code>, and is synonymous with <code>getindices(dict, :)</code>.</p>
<p>These rules match those for <code>AbstractArray</code>, including offset arrays. The <code>view</code> function will work similarly, and the <code>setindices!</code> function from <em>Indexing.jl</em> is already implemented (see mutation, below).</p>
<h3><a id="user-content-settingmutating-values" class="anchor" aria-hidden="true" href="#settingmutating-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Setting/mutating values</h3>
<p>Many dictionary types support setting or mutating the the <em>values</em> of the elements. To support mutation, an <code>AbstractDictionary</code> should implement:</p>
<ul>
<li><code>issettable(::AbstractDictionary)</code> (returning <code>true</code>)</li>
<li><code>setindex!(dict::AbstractDictionary{I, T}, ::T, ::I}</code> (returning <code>dict</code>)</li>
</ul>
<p>The <code>issettable</code> function is a trait function that indicate whether an <code>AbstractDictionary</code> supports <code>setindex!</code>.</p>
<p>Because the idempotency property of <code>AbstractIndices</code>, indices always have immutable values - but indices can be inserted or deleted (see below).</p>
<h3><a id="user-content-insertion-and-deletion" class="anchor" aria-hidden="true" href="#insertion-and-deletion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Insertion and deletion</h3>
<p>If arbitrary indices can be added to or removed from an <code>AbstractDictionary</code>, one needs to implement:</p>
<ul>
<li><code>isinsertable(::AbstractDictionary)</code> (returning <code>true</code>)</li>
<li><code>insert!(dict::AbstractDictionary{I, T}, ::I, ::T}</code> (returning <code>dict</code>)</li>
<li><code>delete!(dict::AbstractDictionary{I, T}, ::I}</code> (returning <code>dict</code>)</li>
</ul>
<p>The <code>insert!</code> and <code>delete!</code> always create or remove indices. Calling <code>insert!</code> when an index already exists will throw an error, as will attempting to <code>delete!</code> an index that does not exist. The function <code>set!</code> is provided as an "upsert" (update or insert) operation. Similarly, <code>unset!</code> function can be used to ensure a given index does not exist. The <code>get!</code> function works as in <code>Base</code>.</p>
<p><strong>NOTE</strong>: <code>setindex!</code> can <em>never</em> create new indices, unlike with Julia's <code>AbstractDict</code> (and many other programming languages!). Always use <code>set!</code> to perform an "upsert" operation. This change may seem inconvenient at first, but it is similar to <code>AbstractArray</code> and how Julia differs from MATLAB in requiring one to explicitly <code>push!</code> to the end of a vector (a much less bug-prone pattern).</p>
<p><code>AbstractIndices</code> may also be insertable, by implementing:</p>
<ul>
<li><code>isinsertable(indices)</code> (returning <code>true</code>)</li>
<li><code>insert!(indices, i)</code> - add new index <code>i</code> to <code>indices</code> (will error if index exists)</li>
<li><code>delete!(indices, i)</code> - remove an existing index <code>i</code> from <code>indices</code> (will error if index does not exist).</li>
</ul>
<p>The <code>set!</code> and <code>unset!</code> functions behave as expected, as do <code>union!</code>, <code>intersect!</code>, <code>setdiff!</code> and <code>symdiff!</code>. Since indices iterate values, the <code>filter!</code> function can programmatically trim back a set of indices.</p>
<h3><a id="user-content-tokens" class="anchor" aria-hidden="true" href="#tokens"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tokens</h3>
<p>To make operations on dictionaries fast, we need to avoid unnecessary lookups into the dictionary and operations like recomputations of hashes. The token interface makes many things more efficient, especially co-iteration of <code>similar</code> containers containing identical <code>keys</code>.</p>
<h4><a id="user-content-implementing-the-token-interface-for-abstractindices" class="anchor" aria-hidden="true" href="#implementing-the-token-interface-for-abstractindices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implementing the token interface for <code>AbstractIndices</code></h4>
<p>A token is a more efficient way of refering to an element of <code>indices</code>. Using tokens may
help avoid multiple index lookups for a single operation.</p>
<p>A tokenizable indices must implement:</p>
<ul>
<li><code>istokenizable(indices)</code> (returning <code>true</code>)</li>
<li><code>tokentype(indices) --&gt; T::Type</code></li>
<li><code>iteratetoken(indices, s...)</code> iterates the tokens of <code>indices</code>, like <code>iterate</code></li>
<li><code>gettoken(indices, i) --&gt; (hasindex::Bool, token)</code></li>
<li><code>gettokenvalue(indices, token)</code> returning the value of the index at <code>token</code></li>
</ul>
<p>An <code>isinsertable</code> tokenizable indices must implement</p>
<ul>
<li><code>gettoken!(indices, i) --&gt; (hadtoken::Bool, token)</code></li>
<li><code>deletetoken!(indices, token) --&gt; indices</code></li>
</ul>
<h4><a id="user-content-implementing-the-token-interface-for-abstractdictionary" class="anchor" aria-hidden="true" href="#implementing-the-token-interface-for-abstractdictionary"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implementing the token interface for <code>AbstractDictionary</code></h4>
<p>An tokenizable dictionary must implement:</p>
<ul>
<li><code>istokenizable(dict)</code> (returning <code>true</code>)</li>
<li><code>keys(dict)</code> must be <code>istokenizable</code> and share tokens with <code>dict</code></li>
<li><code>gettokenvalue(dict, token)</code> returning the dictionary value at <code>token</code></li>
<li><code>istokenassigned(dict, token) --&gt; Bool</code></li>
</ul>
<p>An <code>issettable</code> tokenizable dictionary must implement:</p>
<ul>
<li><code>settokenvalue!(dict, token)</code></li>
</ul>
<p>An <code>isinsertable</code> tokenizable dictionary must implement:</p>
<ul>
<li><code>gettoken!(dict, i) --&gt; (hadtoken::Bool, token)</code></li>
<li><code>deletetoken!(dict, token) --&gt; dict</code></li>
</ul>
<h3><a id="user-content-co-iteration-implementation-notes" class="anchor" aria-hidden="true" href="#co-iteration-implementation-notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Co-iteration implementation notes</h3>
<p>When two-or-more dictionaries share the same tokens, co-iterating through their matching
elements becomes much more efficient. By default, the <code>similar</code> function on <code>Indices</code>
and <code>ArrayIndices</code> does not make a copy of the indices. When performing an operation such as
<code>map!(f, d_out, d_in)</code>, a check of <code>keys(d_out) === keys(d_in)</code> lets us know that the
tokens are equivalent with a constant-time operation. When this is the case, the <code>map!</code>
operation can skip lookup entirely, performing zero calls to <code>hash</code> and dealing with hash
collisions.</p>
<p>A quick benchmark verifies the result.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; using Dictionaries, BenchmarkTools

julia&gt; d1 = Dictionary(1:10_000_000, 10_000_000:-1:1);

julia&gt; d2 = d1 .+ 1;

julia&gt; @btime map(+, d1, d2);
  25.712 ms (20 allocations: 76.29 MiB)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Dictionaries, BenchmarkTools

julia<span class="pl-k">&gt;</span> d1 <span class="pl-k">=</span> <span class="pl-c1">Dictionary</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10_000_000</span>, <span class="pl-c1">10_000_000</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> d2 <span class="pl-k">=</span> d1 <span class="pl-k">.+</span> <span class="pl-c1">1</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">map</span>(<span class="pl-k">+</span>, d1, d2);
  <span class="pl-c1">25.712</span> ms (<span class="pl-c1">20</span> allocations<span class="pl-k">:</span> <span class="pl-c1">76.29</span> MiB)</pre></div>
<p>The <code>copy</code> below makes <code>keys(d1) !== keys(d2)</code>, disabling token co-iteration. It still uses
an iterative approach rather than using mulitple hash-table lookups per element, so it's
relatively snappy.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; @btime map(+, d1, $(Dictionary(copy(keys(d2)), d2)));
  61.615 ms (20 allocations: 76.29 MiB)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">map</span>(<span class="pl-k">+</span>, d1, <span class="pl-k">$</span>(<span class="pl-c1">Dictionary</span>(<span class="pl-c1">copy</span>(<span class="pl-c1">keys</span>(d2)), d2)));
  <span class="pl-c1">61.615</span> ms (<span class="pl-c1">20</span> allocations<span class="pl-k">:</span> <span class="pl-c1">76.29</span> MiB)</pre></div>
<p>For a comparitive baseline benchmark, we can try the same with dense vectors.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; v1 = collect(10_000_000:-1:1);

julia&gt; v2 = v1 .+ 1;

julia&gt; @btime map(+, v1, v2);
  27.587 ms (5 allocations: 76.29 MiB)
"><pre>julia<span class="pl-k">&gt;</span> v1 <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">10_000_000</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> v2 <span class="pl-k">=</span> v1 <span class="pl-k">.+</span> <span class="pl-c1">1</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">map</span>(<span class="pl-k">+</span>, v1, v2);
  <span class="pl-c1">27.587</span> ms (<span class="pl-c1">5</span> allocations<span class="pl-k">:</span> <span class="pl-c1">76.29</span> MiB)</pre></div>
<p>Here, the vector results are in line with the dictionary co-iteration!</p>
<p>Using insertion, instead of preserving the existing indices, is comparitively slow.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; function f(d1, d2)
           out = Dictionary{Int64, Int64}()
           for i in keys(d1)
               insert!(out, i, d1[i] + d2[i])
           end
           return out
       end
f (generic function with 1 method)

julia&gt; @btime f(d1, d2);
  2.819 s (10000091 allocations: 668.42 MiB)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">f</span>(d1, d2)
           out <span class="pl-k">=</span> <span class="pl-c1">Dictionary</span><span class="pl-c1">{Int64, Int64}</span>()
           <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">keys</span>(d1)
               <span class="pl-c1">insert!</span>(out, i, d1[i] <span class="pl-k">+</span> d2[i])
           <span class="pl-k">end</span>
           <span class="pl-k">return</span> out
       <span class="pl-k">end</span>
f (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">f</span>(d1, d2);
  <span class="pl-c1">2.819</span> s (<span class="pl-c1">10000091</span> allocations<span class="pl-k">:</span> <span class="pl-c1">668.42</span> MiB)</pre></div>
<p>Unfortunately, insertion appears to be the idiomatic way of doing things with <code>Base.Dict</code>.
Compare the above to:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; dict1 = Dict(pairs(d1)); dict2 = Dict(pairs(d2));

julia&gt; function g(d1, d2)
           out = Dict{Int64, Int64}()
           for i in keys(d1)
               out[i] = d1[i] + d2[i]
           end
           return out
       end
g (generic function with 1 method)

julia&gt; @btime g(dict1, dict2);
  9.507 s (72 allocations: 541.17 MiB)
"><pre>julia<span class="pl-k">&gt;</span> dict1 <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">pairs</span>(d1)); dict2 <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">pairs</span>(d2));

julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">g</span>(d1, d2)
           out <span class="pl-k">=</span> <span class="pl-c1">Dict</span><span class="pl-c1">{Int64, Int64}</span>()
           <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">keys</span>(d1)
               out[i] <span class="pl-k">=</span> d1[i] <span class="pl-k">+</span> d2[i]
           <span class="pl-k">end</span>
           <span class="pl-k">return</span> out
       <span class="pl-k">end</span>
g (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">g</span>(dict1, dict2);
  <span class="pl-c1">9.507</span> s (<span class="pl-c1">72</span> allocations<span class="pl-k">:</span> <span class="pl-c1">541.17</span> MiB)</pre></div>
<p>The result is similar with generators, which is possibly the easiest way of dealing with
<code>Base.Dict</code>.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; @btime Dict(i =&gt; dict1[i] + dict2[i] for i in keys(dict1));
  13.046 s (89996503 allocations: 2.02 GiB)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">Dict</span>(i <span class="pl-k">=&gt;</span> dict1[i] <span class="pl-k">+</span> dict2[i] <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">keys</span>(dict1));
  <span class="pl-c1">13.046</span> s (<span class="pl-c1">89996503</span> allocations<span class="pl-k">:</span> <span class="pl-c1">2.02</span> GiB)</pre></div>
<p>This represents a 500x speedup between the first example with <code>Dictionary</code> to this last
example with <code>Base.Dict</code>.</p>
</article></div>