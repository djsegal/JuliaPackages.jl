<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-ffta-fastest-fourier-transform-in-my-apartment" class="anchor" aria-hidden="true" href="#ffta-fastest-fourier-transform-in-my-apartment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FFTA: Fastest Fourier Transform in my Apartment</h1>
<h2 dir="auto"><a id="user-content-a-library-by-danny-sharp" class="anchor" aria-hidden="true" href="#a-library-by-danny-sharp"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A library by Danny Sharp</h2>
<p dir="auto"><a href="https://github.com/dannys4/FFTA.jl/actions"><img src="https://github.com/dannys4/FFTA.jl/workflows/CI/badge.svg" alt="Github Action CI" style="max-width: 100%;"></a>
<a href="https://dannys4.github.io/FFTA.jl/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/dannys4/FFTA.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/49e712b034de443fce33763c4a2b082ad8e1fd3516bb2bf1a0bccaf47ed8fb72/68747470733a2f2f636f6465636f762e696f2f67682f64616e6e7973342f464654412e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/dannys4/FFTA.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This is a <em>pure Julia</em> implementation of FFTs, with the goal that this could supplant other FFTs for applications that require odd Julia objects. Currently this supports <code>AbstractArray{T,N}</code> where <code>N</code> in <code>{1,2}</code> (i.e. <code>AbstractVector</code> and <code>AbstractMatrix</code>). If you're looking for more performance, checkout <code>FFTW.jl</code>. Regardless of <code>T</code>, <code>one(::Type{T})</code> must be defined. Additionally, if <code>T&lt;:Real</code>, then <code>convert(::Type{T}, Float64)</code> has to be defined. Otherwise, <code>convert(::Type{T},ComplexF64)</code> must be defined.</p>
<p dir="auto">Some ideas outside the feature requests in Issues:</p>
<ul dir="auto">
<li>Make the code more readable</li>
<li>Use <code>StaticArrays</code> for the workspace in small cases</li>
<li>Strictly generate code for certain cases</li>
<li>Create a SIMD type for Complex numbers</li>
<li>E-Graphs for the call-graph</li>
<li>Other performance left on the table....</li>
</ul>
<p dir="auto">Interface:</p>
<ul dir="auto">
<li><code>fft(x::AbstractVector)</code>-- Forward FFT</li>
<li><code>fft(x::AbstractMatrix})</code>-- Forward FFT</li>
<li><code>bfft(x::AbstractVector})</code>-- Backward FFT (unscaled inverse FFT)</li>
<li><code>bfft(x::AbstractMatrix})</code>-- Backward FFT (unscaled inverse FFT)</li>
</ul>
<p dir="auto">NOTE: Currently, my C++ code is actually faster than this, so "Fastest Fourier Transform in my Apartment" is a bit of a misnomer.</p>
<h2 dir="auto"><a id="user-content-why-use-this" class="anchor" aria-hidden="true" href="#why-use-this"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Why use this?</h2>
<p dir="auto">There's a lot of FFT packages out there, no doubt. Many are great. Some, like mine, are "good enough". Many aren't so great. As far as I know, though, very few are as generic as FFTA. Does that matter? Yes. One of the main draws of Julia is the fact that a lot of functions "just work" with types from other packages. FFTA aims to abide by this philosophy. For example, have you ever wanted to generate what an FFT looks like symbolically? Well, now you can.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FFTA, Symbolics
N = 16
@variables x_a[1:N]::Complex
x = collect(x_a)
y = simplify.(fft(x))"><pre><span class="pl-k">using</span> FFTA, Symbolics
N <span class="pl-k">=</span> <span class="pl-c1">16</span>
<span class="pl-c1">@variables</span> x_a[<span class="pl-c1">1</span><span class="pl-k">:</span>N]<span class="pl-k">::</span><span class="pl-c1">Complex</span>
x <span class="pl-k">=</span> <span class="pl-c1">collect</span>(x_a)
y <span class="pl-k">=</span> <span class="pl-c1">simplify</span>.(<span class="pl-c1">fft</span>(x))</pre></div>
<p dir="auto">Now, if you have a signal afterward that you want to substitute in, you can call <code>map(y_el -&gt; substitute(y_el, Dict(x .=&gt; signal)), y)</code>. Make no mistake-- it's almost certainly more efficient to just plug your type into <code>FFTA.fft</code> than using substitution. But this is an example of how <code>FFTA</code> integrates wonderfully and gracefully with the Julia ecosystem. If you want high precision FFTs, use <code>Complex{BigFloat}</code>. If you want to use an <code>SVector</code> from <code>StaticArrays</code> because your data is small, then use that! If you want to use <code>SizedArray{Complex{BigFloat}}</code>, be my guest. These are opportunities that won't be provided to you in almost any other package out there.</p>
<p dir="auto">As of this commit, you can do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; import FFTA, FFTW

julia&gt; N = 64

julia&gt; @btime FFTA.fft(x) setup=(x = @SVector rand(N));
  698.611 ns (8 allocations: 2.11 KiB)

julia&gt; @btime FFTW.fft(x) setup=(x = @SVector rand(N));
  5.433 μs (34 allocations: 4.70 KiB)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">import</span> FFTA, FFTW

julia<span class="pl-k">&gt;</span> N <span class="pl-k">=</span> <span class="pl-c1">64</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> FFTA<span class="pl-k">.</span><span class="pl-c1">fft</span>(x) setup<span class="pl-k">=</span>(x <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">rand</span>(N));
  <span class="pl-c1">698.611</span> ns (<span class="pl-c1">8</span> allocations<span class="pl-k">:</span> <span class="pl-c1">2.11</span> KiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> FFTW<span class="pl-k">.</span><span class="pl-c1">fft</span>(x) setup<span class="pl-k">=</span>(x <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">rand</span>(N));
  <span class="pl-c1">5.433</span> μs (<span class="pl-c1">34</span> allocations<span class="pl-k">:</span> <span class="pl-c1">4.70</span> KiB)</pre></div>
<p dir="auto">It's painfully obvious that this example is cherry-picked. Nonetheless, the user can finally take the speedups so much of the Julia community has worked so hard on and propogate them into the FFT.</p>
</article></div>