<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-halfintegerarrays" class="anchor" aria-hidden="true" href="#halfintegerarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>HalfIntegerArrays</h1>
<p dir="auto"><a href="https://jishnub.github.io/HalfIntegerArrays.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://jishnub.github.io/HalfIntegerArrays.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://travis-ci.com/jishnub/HalfIntegerArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/4a0f2364c8e45d95216d624642e028d02bca911f45d6c511f52b91bbb5dc0f31/68747470733a2f2f7472617669732d63692e636f6d2f6a6973686e75622f48616c66496e74656765724172726179732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jishnub/HalfIntegerArrays.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/jishnub/HalfIntegerArrays-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a2e8be01baa223afedf969b13bb7a64e361022c60c1022ad6afa7deb15219786/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f6a6973686e75622f48616c66496e74656765724172726179732e6a6c3f7376673d74727565" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/jishnub/HalfIntegerArrays.jl?svg=true" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jishnub/HalfIntegerArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/0409392c92e44e63a24e9a38ad988b2c750e955673936595b17050cc7a5c2c60/68747470733a2f2f636f6465636f762e696f2f67682f6a6973686e75622f48616c66496e74656765724172726179732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/jishnub/HalfIntegerArrays.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/jishnub/HalfIntegerArrays.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/87ad909f5053d7abfa6f3741e5f2f3f0fdb315e0daf6cd2bfb8e7f4cfbc48044/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6a6973686e75622f48616c66496e74656765724172726179732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage" data-canonical-src="https://coveralls.io/repos/github/jishnub/HalfIntegerArrays.jl/badge.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">Arrays that may have half-integer indices, commonly encountered while working with rotations and spin.</p>
<p dir="auto">This package is very much a WIP, and bugs are expected. Please open an issue if you encounter a bug.</p>
<h1 dir="auto"><a id="user-content-prerequisites" class="anchor" aria-hidden="true" href="#prerequisites"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Prerequisites</h1>
<p dir="auto">The package is to be used alongside <a href="https://github.com/sostock/HalfIntegers.jl">HalfIntegers.jl</a>. This is installed automatically with this package, and may be imported as shown below.</p>
<h1 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h1>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ]
pkg&gt; add https://github.com/jishnub/HalfIntegerArrays.jl

julia&gt; using HalfIntegerArrays
julia&gt; using HalfIntegerArrays.HalfIntegers"><pre>julia<span class="pl-k">&gt;</span> ]
pkg<span class="pl-k">&gt;</span> add https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>jishnub<span class="pl-k">/</span>HalfIntegerArrays<span class="pl-k">.</span>jl

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> HalfIntegerArrays
julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> HalfIntegerArrays<span class="pl-k">.</span>HalfIntegers</pre></div>
<h1 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h1>
<p dir="auto">There are two types exported: <code>HalfIntArray</code> and <code>SpinMatrix</code>. The former represents an arbitrary array with possibly half-integral axes, whereas the latter represents a square matrix corresponding to an angular momentum <code>j</code>. In the second case the array is guaranteed to have a size of <code>(2j+1, 2j+1)</code>, and axes <code>(-j:j, -j:j)</code>.</p>
<p dir="auto"><code>HalfIntArray</code>s are wrappers around <code>AbstractArray</code>s, and may be constructed in two ways: firstly by providing the axes for the parent array, eg:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; h = HalfIntArray(ones(Int,3,3), -1:1, -1:1)
3×3 HalfIntArray(::Array{Int64,2}, -1:1, -1:1) with eltype Int64 with indices -1:1×-1:1:
 1  1  1
 1  1  1
 1  1  1

# We may wrap structured arrays
julia&gt; import LinearAlgebra: Diagonal

julia&gt; h = HalfIntArray(Diagonal([1,2]), -1//2:1//2, -1//2:1//2)
2×2 HalfIntArray(::Diagonal{Int64,Array{Int64,1}}, -1/2:1/2, -1/2:1/2) with eltype Int64 with indices -1/2:1/2×-1/2:1/2:
 1  ⋅
 ⋅  2"><pre>julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">ones</span>(Int,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,2}</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">1</span>  <span class="pl-c1">1</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">1</span>  <span class="pl-c1">1</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">1</span>  <span class="pl-c1">1</span>

<span class="pl-c"><span class="pl-c">#</span> We may wrap structured arrays</span>
julia<span class="pl-k">&gt;</span> <span class="pl-k">import</span> LinearAlgebra<span class="pl-k">:</span> Diagonal

julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">Diagonal</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-k">::</span><span class="pl-c1">Diagonal{Int64,Array{Int64,1}}</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-k">⋅</span>
 <span class="pl-k">⋅</span>  <span class="pl-c1">2</span></pre></div>
<p dir="auto">and secondly by using the typed constructor</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; h = HalfIntArray{Float64}(undef,-1//2:1//2, -1//2:1//2)
2×2 HalfIntArray(::Array{Float64,2}, -1/2:1/2, -1/2:1/2) with eltype Float64 with indices -1/2:1/2×-1/2:1/2:
 0.0           0.0
 6.89924e-310  0.0

julia&gt; h = HalfIntArray{Union{Float64,Missing}}(missing,-1:1, -1:1)
3×3 HalfIntArray(::Array{Union{Missing, Float64},2}, -1:1, -1:1) with eltype Union{Missing, Float64} with indices -1:1×-1:1:
 missing  missing  missing
 missing  missing  missing
 missing  missing  missing"><pre>julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">HalfIntArray</span><span class="pl-c1">{Float64}</span>(undef,<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Float64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>           <span class="pl-c1">0.0</span>
 <span class="pl-c1">6.89924e-310</span>  <span class="pl-c1">0.0</span>

julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">HalfIntArray</span><span class="pl-c1">{Union{Float64,Missing}}</span>(<span class="pl-c1">missing</span>,<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Union{Missing, Float64},2}</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>) with eltype Union{Missing, Float64} with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">missing</span>  <span class="pl-c1">missing</span>  <span class="pl-c1">missing</span>
 <span class="pl-c1">missing</span>  <span class="pl-c1">missing</span>  <span class="pl-c1">missing</span>
 <span class="pl-c1">missing</span>  <span class="pl-c1">missing</span>  <span class="pl-c1">missing</span></pre></div>
<p dir="auto">In the second case an underlying array of an appropriate size is initialized that has the specified element type.</p>
<p dir="auto">A <code>SpinMatrix</code> may be constructed as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; s = SpinMatrix(zeros(3,3)) # the angular momentum is inferred
3×3 SpinMatrix(::Array{Float64,2}, 1) with eltype Float64 with indices -1:1×-1:1:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

# Specifying the angular momentum will allocate an appropriate array
julia&gt; s = SpinMatrix{ComplexF64}(undef, 1//2)
2×2 SpinMatrix(::Array{Complex{Float64},2}, 1/2) with eltype Complex{Float64} with indices -1/2:1/2×-1/2:1/2:
 6.91635e-310+6.91635e-310im  6.91637e-310+6.91637e-310im
 6.91635e-310+6.91637e-310im  6.91637e-310+6.91637e-310im"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>)) <span class="pl-c"><span class="pl-c">#</span> the angular momentum is inferred</span>
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-c1">1</span>) with eltype Float64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

<span class="pl-c"><span class="pl-c">#</span> Specifying the angular momentum will allocate an appropriate array</span>
julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">SpinMatrix</span><span class="pl-c1">{ComplexF64}</span>(undef, <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Complex{Float64},2}</span>, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Complex{Float64} with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">6.91635e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91635e-310im</span>  <span class="pl-c1">6.91637e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91637e-310im</span>
 <span class="pl-c1">6.91635e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91637e-310im</span>  <span class="pl-c1">6.91637e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91637e-310im</span></pre></div>
<p dir="auto">A <code>SpinMatrix</code> requires the parent matrix to have <code>1</code>-based indexing and have a size of <code>(2j+1, 2j+1)</code>.</p>
<h2 dir="auto"><a id="user-content-indexing" class="anchor" aria-hidden="true" href="#indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Indexing</h2>
<p dir="auto">The arrays may be indexed with integral or half-integral values. For optimal performance it's preferable to use integral, floating-point or <code>HalfInt</code> types as indices. A <code>HalfInt</code> may be constructed using the function <code>half</code>, such that <code>half(n) == n/2</code>. Alternately they may also be constructed as <code>HalfInt(n)</code> which is numerically equivalent to <code>n</code>. Rational numbers may be used as well, but these might not be as performant.</p>
<p dir="auto">An example with a half-integral spin:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; s = SpinMatrix(reshape(1:4,2,2), 1//2)
2×2 SpinMatrix(reshape(::UnitRange{Int64}, 2, 2), 1/2) with eltype Int64 with indices -1/2:1/2×-1/2:1/2:
 1  3
 2  4

julia&gt; s[1//2,1//2]
4

julia&gt; import HalfIntegerArrays: half

julia&gt; s[-half(1),half(1)]
3"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-c1">reshape</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">3</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> s[<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>]
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">import</span> HalfIntegerArrays<span class="pl-k">:</span> half

julia<span class="pl-k">&gt;</span> s[<span class="pl-k">-</span><span class="pl-c1">half</span>(<span class="pl-c1">1</span>),<span class="pl-c1">half</span>(<span class="pl-c1">1</span>)]
<span class="pl-c1">3</span></pre></div>
<p dir="auto">An example with integral spin:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; s = SpinMatrix(reshape(1:9,3,3))
3×3 SpinMatrix(reshape(::UnitRange{Int64}, 3, 3), 1) with eltype Int64 with indices -1:1×-1:1:
 1  4  7
 2  5  8
 3  6  9

julia&gt; s[1,1]
9"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-c1">reshape</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">9</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>))
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>), <span class="pl-c1">1</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">4</span>  <span class="pl-c1">7</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">5</span>  <span class="pl-c1">8</span>
 <span class="pl-c1">3</span>  <span class="pl-c1">6</span>  <span class="pl-c1">9</span>

julia<span class="pl-k">&gt;</span> s[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]
<span class="pl-c1">9</span></pre></div>
<h3 dir="auto"><a id="user-content-linear-and-cartesian-indexing" class="anchor" aria-hidden="true" href="#linear-and-cartesian-indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Linear and Cartesian Indexing</h3>
<p dir="auto">Julia's default <code>CartesianIndex</code>, <code>CartesianIndices</code> and <code>LinearIndices</code> types require integer indices, therefore these are not compatible with <code>HalfIntArray</code>s. This package exports the equivalent types <code>CartesianIndexHalfInt</code>, <code>CartesianIndicesHalfInt</code> and <code>LinearIndicesHalfInt</code> that support both integer and half-integer indices. These are therefore the safe choices for indexing into <code>HalfIntArray</code>s.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; h = HalfIntArray(reshape(1:4,2,2), 0:1, 0:1)
2×2 HalfIntArray(reshape(::UnitRange{Int64}, 2, 2), 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:
 1  3
 2  4

julia&gt; cinds = eachindex(IndexCartesian(), h)
2×2 CartesianIndicesHalfInt{2,Tuple{Base.OneTo{Int64},Base.OneTo{Int64}}} with indices 0:1×0:1:
 CartesianIndexHalfInt(0, 0)  CartesianIndexHalfInt(0, 1)
 CartesianIndexHalfInt(1, 0)  CartesianIndexHalfInt(1, 1)

julia&gt; h[cinds[1,0]]
2"><pre>julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>) with eltype Int64 with indices <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">3</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> cinds <span class="pl-k">=</span> <span class="pl-c1">eachindex</span>(<span class="pl-c1">IndexCartesian</span>(), h)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> CartesianIndicesHalfInt{<span class="pl-c1">2</span>,Tuple{Base<span class="pl-k">.</span>OneTo{Int64},Base<span class="pl-k">.</span>OneTo{Int64}}} with indices <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">CartesianIndexHalfInt</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>)  <span class="pl-c1">CartesianIndexHalfInt</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>)
 <span class="pl-c1">CartesianIndexHalfInt</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>)  <span class="pl-c1">CartesianIndexHalfInt</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>)

julia<span class="pl-k">&gt;</span> h[cinds[<span class="pl-c1">1</span>,<span class="pl-c1">0</span>]]
<span class="pl-c1">2</span></pre></div>
<p dir="auto">Indexing with <code>CartesianIndices</code> works as well for arrays with integer indices.</p>
<h2 dir="auto"><a id="user-content-broadcasting" class="anchor" aria-hidden="true" href="#broadcasting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Broadcasting</h2>
<p dir="auto">Broadcasting works, but is a bit slow at the moment. For optimal performance it's better to broadcast on the parent array.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; h = HalfIntArray(reshape(1:4,2,2), -1//2:1//2, -1//2:1//2)
2×2 HalfIntArray(reshape(::UnitRange{Int64}, 2, 2), -1/2:1/2, -1/2:1/2) with eltype Int64 with indices -1/2:1/2×-1/2:1/2:
 1  3
 2  4

julia&gt; h .+ h
2×2 HalfIntArray(::Array{Int64,2}, -1/2:1/2, -1/2:1/2) with eltype Int64 with indices -1/2:1/2×-1/2:1/2:
 2  6
 4  8

julia&gt; @btime $h .+ $h;
  193.130 ns (2 allocations: 192 bytes)

julia&gt; @btime parent($h) .+ parent($h);
  94.443 ns (1 allocation: 160 bytes)"><pre>julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">3</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> h <span class="pl-k">.+</span> h
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,2}</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">6</span>
 <span class="pl-c1">4</span>  <span class="pl-c1">8</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>h <span class="pl-k">.+</span> <span class="pl-k">$</span>h;
  <span class="pl-c1">193.130</span> ns (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">192</span> bytes)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">parent</span>(<span class="pl-k">$</span>h) <span class="pl-k">.+</span> <span class="pl-c1">parent</span>(<span class="pl-k">$</span>h);
  <span class="pl-c1">94.443</span> ns (<span class="pl-c1">1</span> allocation<span class="pl-k">:</span> <span class="pl-c1">160</span> bytes)</pre></div>
<p dir="auto">Upon broadcasting with <code>SpinMatrix</code> types, the result will be a <code>HalfIntArray</code>. This behaviour might change in the future.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; s = SpinMatrix(reshape(1:4,2,2), half(1))
2×2 SpinMatrix(reshape(::UnitRange{Int64}, 2, 2), 1/2) with eltype Int64 with indices -1/2:1/2×-1/2:1/2:
 1  3
 2  4

julia&gt; s .+ s
2×2 HalfIntArray(::Array{Int64,2}, -1/2:1/2, -1/2:1/2) with eltype Int64 with indices -1/2:1/2×-1/2:1/2:
 2  6
 4  8

# It's possible to recreate the wrapper
julia&gt; s .+ s |&gt; SpinMatrix
2×2 SpinMatrix(::Array{Int64,2}, 1/2) with eltype Int64 with indices -1/2:1/2×-1/2:1/2:
 2  6
 4  8"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-c1">reshape</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-c1">half</span>(<span class="pl-c1">1</span>))
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">3</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">.+</span> s
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,2}</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">6</span>
 <span class="pl-c1">4</span>  <span class="pl-c1">8</span>

<span class="pl-c"><span class="pl-c">#</span> It's possible to recreate the wrapper</span>
julia<span class="pl-k">&gt;</span> s <span class="pl-k">.+</span> s <span class="pl-k">|&gt;</span> SpinMatrix
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SpinMatrix</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,2}</span>, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">6</span>
 <span class="pl-c1">4</span>  <span class="pl-c1">8</span></pre></div>
<h1 dir="auto"><a id="user-content-comparison-with-offsetarrays" class="anchor" aria-hidden="true" href="#comparison-with-offsetarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Comparison with <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a></h1>
<p dir="auto">A <code>HalfIntArray</code> with integer axes is equivalent to an <code>OffsetArray</code>, except that a <code>HalfIntArray</code> is somewhat less performant when it comes to indexing.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using OffsetArrays

julia&gt; oa = OffsetArray(reshape(1:9,3,3), -1:1, -1:1)
3×3 OffsetArray(reshape(::UnitRange{Int64}, 3, 3), -1:1, -1:1) with eltype Int64 with indices -1:1×-1:1:
 1  4  7
 2  5  8
 3  6  9

julia&gt; h = HalfIntArray(parent(oa), axes(oa)...)
3×3 HalfIntArray(reshape(::UnitRange{Int64}, 3, 3), -1:1, -1:1) with eltype Int64 with indices -1:1×-1:1:
 1  4  7
 2  5  8
 3  6  9

julia&gt; h == oa
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> OffsetArrays

julia<span class="pl-k">&gt;</span> oa <span class="pl-k">=</span> <span class="pl-c1">OffsetArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">9</span>,<span class="pl-c1">3</span>,<span class="pl-c1">3</span>), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">OffsetArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">4</span>  <span class="pl-c1">7</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">5</span>  <span class="pl-c1">8</span>
 <span class="pl-c1">3</span>  <span class="pl-c1">6</span>  <span class="pl-c1">9</span>

julia<span class="pl-k">&gt;</span> h <span class="pl-k">=</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">parent</span>(oa), <span class="pl-c1">axes</span>(oa)<span class="pl-k">...</span>)
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">HalfIntArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">4</span>  <span class="pl-c1">7</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">5</span>  <span class="pl-c1">8</span>
 <span class="pl-c1">3</span>  <span class="pl-c1">6</span>  <span class="pl-c1">9</span>

julia<span class="pl-k">&gt;</span> h <span class="pl-k">==</span> oa
<span class="pl-c1">true</span></pre></div>
</article></div>