<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-dagger" class="anchor" aria-hidden="true" href="#dagger"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dagger</h1>
<p><strong>A framework for out-of-core and parallel computing</strong>.</p>
<p><a href="https://travis-ci.org/JuliaParallel/Dagger.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c69e058caf3df2da40c415c9462c6b9b80363292/68747470733a2f2f7472617669732d63692e6f72672f4a756c6961506172616c6c656c2f4461676765722e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaParallel/Dagger.jl.svg?branch=master" style="max-width:100%;"></a> <a href="https://coveralls.io/github/JuliaParallel/Dagger.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/517ecf550b61c100e16a3e4de03551f9d2e6d137/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f4a756c6961506172616c6c656c2f4461676765722e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/JuliaParallel/Dagger.jl/badge.svg?branch=master" style="max-width:100%;"></a></p>
<p>At the core of Dagger.jl is a scheduler heavily inspired by <a href="https://docs.dask.org/en/latest/" rel="nofollow">Dask</a>. It can run computations represented as <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="nofollow">directed-acyclic-graphs</a> (DAGs) efficiently on many Julia worker processes.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>You can install Dagger by typing</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> ] add Dagger</pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>Once installed, the <code>Dagger</code> package can by used by typing</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Dagger</pre></div>
<p>The main function for using Dagger is <code>delayed</code></p>
<p><code>delayed(f; options...)</code></p>
<p>It returns a function which when called creates a <code>Thunk</code> object representing a call to function <code>f</code> with the given arguments. If it is called with other thunks as input, then they form a graph with input nodes directed at the output. The function <code>f</code> gets the result of the input Thunks.
Thunks don't pass keyword argument to the function <code>f</code>. Options kwargs... to <code>delayed</code> are passed to the scheduler to control its behavior:</p>
<ul>
<li><code>get_result::Bool</code> -- return the actual result to the scheduler instead of <code>Chunk</code> objects. Used when <code>f</code> explicitly constructs a Chunk or when return value is small (e.g. in case of reduce)</li>
<li><code>meta::Bool</code> -- pass the input “Chunk” objects themselves to <code>f</code> and not the value contained in them - this is always run on the master process</li>
<li><code>persist::Bool</code> -- the result of this Thunk should not be released after it becomes unused in the DAG</li>
<li><code>cache::Bool</code> -- cache the result of this Thunk such that if the thunk is evaluated again, one can just reuse the cached value. If it’s been removed from cache, recompute the value.</li>
</ul>
<h1><a id="user-content-dag-creation-interface" class="anchor" aria-hidden="true" href="#dag-creation-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DAG creation interface</h1>
<p>Here is a very simple example DAG:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Dagger

<span class="pl-en">add1</span>(value) <span class="pl-k">=</span> value <span class="pl-k">+</span> <span class="pl-c1">1</span>
<span class="pl-en">add2</span>(value) <span class="pl-k">=</span> value <span class="pl-k">+</span> <span class="pl-c1">2</span>
<span class="pl-en">combine</span>(a<span class="pl-k">...</span>) <span class="pl-k">=</span> <span class="pl-c1">sum</span>(a)

p <span class="pl-k">=</span> <span class="pl-c1">delayed</span>(add1)(<span class="pl-c1">4</span>)
q <span class="pl-k">=</span> <span class="pl-c1">delayed</span>(add2)(p)
r <span class="pl-k">=</span> <span class="pl-c1">delayed</span>(add1)(<span class="pl-c1">3</span>)
s <span class="pl-k">=</span> <span class="pl-c1">delayed</span>(combine)(p, q, r)

<span class="pl-c1">@assert</span> <span class="pl-c1">collect</span>(s) <span class="pl-k">==</span> <span class="pl-c1">16</span></pre></div>
<p>The connections between nodes <code>p</code>, <code>q</code>, <code>r</code> and <code>s</code> is represented by this dependency graph:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/25916/26920104-7b9b5fa4-4c55-11e7-97fb-fe5b9e73cae6.png"><img src="https://user-images.githubusercontent.com/25916/26920104-7b9b5fa4-4c55-11e7-97fb-fe5b9e73cae6.png" alt="graph" style="max-width:100%;"></a></p>
<p>The final result is the obvious consequence of the operation</p>
<p><code>add1(4)</code> + <code>add2(add1(4))</code> + <code>add1(3)</code></p>
<p><code>(4 + 1)</code> + <code>((4 + 1) + 2)</code> + <code>(3 + 1)</code> = 16</p>
<p>To compute and fetch the result of a thunk (say <code>s</code>), you can call <code>collect(s)</code>. <code>collect</code> will fetch the result of the computation to the master process. Alternatively, if you want to compute but not fetch the result you can call <code>compute</code> on the thunk. This will return a <code>Chunk</code> object which references the result. If you pass in a <code>Chunk</code> objects as an input to a delayed function, then the function will get executed with the value of the <code>Chunk</code> -- this evaluation will likely happen where the input chunks are, to reduce communication.</p>
<p>The key point is that, for each argument to a node, if the argument is a <code>Thunk</code>, it'll be executed before this node and its result will be passed into the function <code>f</code> provided.
If the argument is <em>not</em> a <code>Thunk</code> (just some regular Julia object), it'll be passed as-is to the function <code>f</code>.</p>
<h3><a id="user-content-polytree" class="anchor" aria-hidden="true" href="#polytree"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Polytree</h3>
<p><a href="https://en.wikipedia.org/wiki/Polytree" title="Polytrees" rel="nofollow">Polytrees</a> are easily supported by Dagger. To make this work, pass all the head nodes <code>Thunk</code>s into a call to <code>delayed</code> as arguments, which will act as the top node for the graph.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">group</span>(x<span class="pl-k">...</span>) <span class="pl-k">=</span> [x<span class="pl-k">...</span>]
top_node <span class="pl-k">=</span> <span class="pl-c1">delayed</span>(group)(head_nodes<span class="pl-k">...</span>)
<span class="pl-c1">compute</span>(top_node)</pre></div>
<h2><a id="user-content-rough-high-level-description-of-scheduling" class="anchor" aria-hidden="true" href="#rough-high-level-description-of-scheduling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rough high level description of scheduling</h2>
<ul>
<li>First picks the leaf Thunks and distributes them to available workers. Each worker is given at most 1 task at a time. If input to the node is a <code>Chunk</code>, then workers which already have the chunk are preferred.</li>
<li>When a worker finishes a thunk it will return a <code>Chunk</code> object to the scheduler.</li>
<li>Once the worker has returned a <code>Chunk</code>, the scheduler picks the next task for the worker -- this is usually the task the worker immediately made available (if possible). In the small example above, if worker 2 finished <code>p</code> it will be given <code>q</code> since it will already have the result of <code>p</code> which is input to <code>q</code>.</li>
<li>The scheduler also issues "release" Commands to chunks that are no longer required by nodes in the DAG: for example, when <code>s</code> is computed all of <code>p</code>, <code>q</code>, <code>r</code> are released to free up memory. This can be prevented by passing <code>persist</code> or <code>cache</code> options to <code>delayed</code>.</li>
</ul>
<h3><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Acknowledgements</h3>
<p>We thank DARPA, Intel, and the NIH for supporting this work at MIT.</p>
</article></div>