<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a href="https://numericaleft.github.io/CompositeGrids.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="img" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/numericaleft/CompositeGrids.jl/actions"><img src="https://github.com/numericaleft/CompositeGrids.jl/workflows/CI/badge.svg" alt="img" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/numericaleft/CompositeGrids.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/bd92ba4c679a92060d95192828231c24e819b6a59f0a3cb2e328a866b77fd4e2/68747470733a2f2f636f6465636f762e696f2f67682f6e756d65726963616c4546542f436f6d706f7369746547726964732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d574e36484f3158415359" alt="img" data-canonical-src="https://codecov.io/gh/numericalEFT/CompositeGrids.jl/branch/main/graph/badge.svg?token=WN6HO1XASY" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h1>
<p dir="auto">CompositeGrids gives a unified interface to generate various common 1D grids
and also the composite grids that is a combination of basic grids,
together with the floor function, interpolation function and also integration function
that is optimized for some of the grids.</p>
<h1 dir="auto"><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick Start</h1>
<p dir="auto">In the following example we show how to generate a τ grid from 0 to β, log-densed at 0 and β,
and optimized for integration. The description is attached in the comments in the code.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="    using CompositeGrids
    β = 10
    
    # Generating a log densed composite grid with LogDensedGrid()
    tgrid = CompositeGrid.LogDensedGrid(
        :gauss,# The top layer grid is :gauss, optimized for integration. For interpolation use :cheb
        [0.0, β],# The grid is defined on [0.0, β]
        [0.0, β],# and is densed at 0.0 and β, as given by 2nd and 3rd parameter.
        5,# N of log grid
        0.005, # minimum interval length of log grid
        5 # N of bottom layer
    )
    # The grid has 3 layers.
    # The top layer is defined by the boundary and densed points. In this case its:
    println(&quot;Top layer:&quot;,tgrid.panel.grid)
    # The middle layer is a log grid with 4 points and minimum interval length 0.001:
    println(&quot;First subgrid of middle layer:&quot;,tgrid.subgrids[1].panel.grid)
    # The bottom layer is a Gauss-Legendre grid with 5 points:
    println(&quot;First subgrid of bottom layer:&quot;,tgrid.subgrids[1].subgrids[1].grid)
    
    # function to be integrated:
    f(t) = exp(t)+exp(β-t)
    # numerical value on grid points:
    data = [f(t) for (ti, t) in enumerate(tgrid.grid)]
    
    # integrate with integrate1D():
    int_result = Interp.integrate1D(data, tgrid)
    
    println(&quot;result=&quot;,int_result)
    println(&quot;comparing to:&quot;,2*(exp(β)-1))"><pre>    <span class="pl-k">using</span> CompositeGrids
    β <span class="pl-k">=</span> <span class="pl-c1">10</span>
    
    <span class="pl-c"><span class="pl-c">#</span> Generating a log densed composite grid with LogDensedGrid()</span>
    tgrid <span class="pl-k">=</span> CompositeGrid<span class="pl-k">.</span><span class="pl-c1">LogDensedGrid</span>(
        <span class="pl-c1">:gauss</span>,<span class="pl-c"><span class="pl-c">#</span> The top layer grid is :gauss, optimized for integration. For interpolation use :cheb</span>
        [<span class="pl-c1">0.0</span>, β],<span class="pl-c"><span class="pl-c">#</span> The grid is defined on [0.0, β]</span>
        [<span class="pl-c1">0.0</span>, β],<span class="pl-c"><span class="pl-c">#</span> and is densed at 0.0 and β, as given by 2nd and 3rd parameter.</span>
        <span class="pl-c1">5</span>,<span class="pl-c"><span class="pl-c">#</span> N of log grid</span>
        <span class="pl-c1">0.005</span>, <span class="pl-c"><span class="pl-c">#</span> minimum interval length of log grid</span>
        <span class="pl-c1">5</span> <span class="pl-c"><span class="pl-c">#</span> N of bottom layer</span>
    )
    <span class="pl-c"><span class="pl-c">#</span> The grid has 3 layers.</span>
    <span class="pl-c"><span class="pl-c">#</span> The top layer is defined by the boundary and densed points. In this case its:</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Top layer:<span class="pl-pds">"</span></span>,tgrid<span class="pl-k">.</span>panel<span class="pl-k">.</span>grid)
    <span class="pl-c"><span class="pl-c">#</span> The middle layer is a log grid with 4 points and minimum interval length 0.001:</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>First subgrid of middle layer:<span class="pl-pds">"</span></span>,tgrid<span class="pl-k">.</span>subgrids[<span class="pl-c1">1</span>]<span class="pl-k">.</span>panel<span class="pl-k">.</span>grid)
    <span class="pl-c"><span class="pl-c">#</span> The bottom layer is a Gauss-Legendre grid with 5 points:</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>First subgrid of bottom layer:<span class="pl-pds">"</span></span>,tgrid<span class="pl-k">.</span>subgrids[<span class="pl-c1">1</span>]<span class="pl-k">.</span>subgrids[<span class="pl-c1">1</span>]<span class="pl-k">.</span>grid)
    
    <span class="pl-c"><span class="pl-c">#</span> function to be integrated:</span>
    <span class="pl-en">f</span>(t) <span class="pl-k">=</span> <span class="pl-c1">exp</span>(t)<span class="pl-k">+</span><span class="pl-c1">exp</span>(β<span class="pl-k">-</span>t)
    <span class="pl-c"><span class="pl-c">#</span> numerical value on grid points:</span>
    data <span class="pl-k">=</span> [<span class="pl-c1">f</span>(t) <span class="pl-k">for</span> (ti, t) <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(tgrid<span class="pl-k">.</span>grid)]
    
    <span class="pl-c"><span class="pl-c">#</span> integrate with integrate1D():</span>
    int_result <span class="pl-k">=</span> Interp<span class="pl-k">.</span><span class="pl-c1">integrate1D</span>(data, tgrid)
    
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>result=<span class="pl-pds">"</span></span>,int_result)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>comparing to:<span class="pl-pds">"</span></span>,<span class="pl-c1">2</span><span class="pl-k">*</span>(<span class="pl-c1">exp</span>(β)<span class="pl-k">-</span><span class="pl-c1">1</span>))</pre></div>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="    Top layer:[0.0, 5.0, 10.0]
    First subgrid of middle layer:[0.0, 0.005000000000000001, 0.05000000000000001, 0.5, 5.0]
    First subgrid of bottom layer:[0.00023455038515334025, 0.0011538267247357924, 0.0025000000000000005, 0.0038461732752642086, 0.004765449614846661]
    result=44050.91248775534
    comparing to:44050.931589613436"><pre class="notranslate"><code>    Top layer:[0.0, 5.0, 10.0]
    First subgrid of middle layer:[0.0, 0.005000000000000001, 0.05000000000000001, 0.5, 5.0]
    First subgrid of bottom layer:[0.00023455038515334025, 0.0011538267247357924, 0.0025000000000000005, 0.0038461732752642086, 0.004765449614846661]
    result=44050.91248775534
    comparing to:44050.931589613436
</code></pre></div>
<h1 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h1>
<p dir="auto">Static version could be installed via standard package manager with Pkg.add("CompositeGrids").</p>
<p dir="auto">For developing version, git clone this repo and add with Pkg.develop("directory/of/the/repo").</p>
<h1 dir="auto"><a id="user-content-manual" class="anchor" aria-hidden="true" href="#manual"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Manual</h1>
<h2 dir="auto"><a id="user-content-basics" class="anchor" aria-hidden="true" href="#basics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basics</h2>
<p dir="auto">The grids are provided in two modules, SimpleGrid and CompositeGrid. SimpleGrid consists of several
common 1D grids that is defined straightforward and has simple structure. CompositeGrid defines a
general type of grids composed by a panel grid and a set of subgrids. The common interface of grids
are the following:</p>
<ul dir="auto">
<li>g.bound gives the boundary of the interval of the grid.</li>
<li>g.size gives the total number of grid points.</li>
<li>g.grid gives the array of grid points.</li>
<li>g[i] returns the i-th grid point, same as g.grid[i].</li>
<li>floor(g, x) returns the largest index of grid point where g[i]&lt;x. Return 1 for x&lt;g[1] and (grid.size-1) for x&gt;g[end], so that both floor() and (floor()+1) are valid grid indices.</li>
</ul>
<p dir="auto">Interpolation and integration are also provided, with different implemented functions for different grids.</p>
<h2 dir="auto"><a id="user-content-simple-grids" class="anchor" aria-hidden="true" href="#simple-grids"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simple Grids</h2>
<p dir="auto">Various basic grids are designed for use and also as components of composite grids, including:
Arbitrary, Uniform, Log, BaryCheb, and GaussLegendre.</p>
<p dir="auto">Arbitrary grid is the most general basic grid, which takes an array and turn it into a grid.
An O(ln(N)) floor function based on searchsortedfirst() is provided.</p>
<p dir="auto">Uniform grid is defined by the boundary and number of grid points.
An O(1) floor function is provided.</p>
<p dir="auto">Log grid is defined by the boundary, number of grid points, minimum interval, and also the direction.
A log densed grid is generated according to the parameters provided.
For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="    using CompositeGrids
    loggrid = SimpleGrid.Log{Float64}([0.0,1.0], 6, 0.0001, true)
    println(loggrid.grid)"><pre>    <span class="pl-k">using</span> CompositeGrids
    loggrid <span class="pl-k">=</span> SimpleGrid<span class="pl-k">.</span><span class="pl-c1">Log</span><span class="pl-c1">{Float64}</span>([<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>], <span class="pl-c1">6</span>, <span class="pl-c1">0.0001</span>, <span class="pl-c1">true</span>)
    <span class="pl-c1">println</span>(loggrid<span class="pl-k">.</span>grid)</pre></div>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="    [0.0, 0.00010000000000000005, 0.0010000000000000002, 0.010000000000000002, 0.1, 1.0]"><pre class="notranslate"><code>    [0.0, 0.00010000000000000005, 0.0010000000000000002, 0.010000000000000002, 0.1, 1.0]
</code></pre></div>
<p dir="auto">An O(1) floor function is provided.</p>
<p dir="auto">BaryCheb grid is designed for interpolation. It's defined by the boundary and number of grid points,
but the grid points are not distributed uniformly. The floor function is not optimized
so the O(ln(N)) function will be used, but the interpolation is based on an optimized algorithm.</p>
<p dir="auto">GaussLegendre grid is designed for integration. It's defined by the boundary and number of grid points,
but the grid points are not distributed uniformly. The floor function is not optimized
so the O(ln(N)) function will be used. The 1D integration is optimized.</p>
<p dir="auto">Also notice that there's open grids and closed grids. Closed grids means that the boundary points are
also grid points, while open grids means the opposite. Only BaryCheb and GaussLegendre are open.</p>
<p dir="auto">A detailed manual can be found <a href="https://numericaleft.github.io/CompositeGrids.jl/dev/lib/simple/" rel="nofollow">here</a>.</p>
<h2 dir="auto"><a id="user-content-composite-grids" class="anchor" aria-hidden="true" href="#composite-grids"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Composite Grids</h2>
<p dir="auto">Composite grid is a general type of grids where the whole interval is first divided by a panel grid,
then each interval of a panel grid is divided by a smaller grid in subgrids. Subgrid could also be
composite grid.</p>
<p dir="auto">LogDensedGrid is a useful generator of CompositeGrid which gives a general solution when an 1D grid on an
interval is needed to be log-densed around several points. For example, τ grids need to be densed around
0 and β, and momentum grids need to be densed around Fermi momentum.
The grid is defined as a three-layer composite grid with the top layer being an Arbitrary grid defined by
the boundary and densed points, the middle layer a Log grid which is densed at the points required, and the
bottom layer a grid of three options. Three types are :cheb, :gauss, and :uniform, which corresponds to
BaryCheb grid for interpolation, GaussLegendre grid for integration, and Uniform grid for general use.
The floor function is defined recursively, i.e. the floor function of the panel grid is called to find the
corresponding subgrid, and then the floor function of the subgrid is called to find the result. Since the
subgrids could also be CompositeGrid, this process continues until the lowest level of the subgrids is reached.</p>
<p dir="auto">A detailed manual can be found <a href="https://numericaleft.github.io/CompositeGrids.jl/dev/lib/composite/" rel="nofollow">here</a>.</p>
<h2 dir="auto"><a id="user-content-interpolation-and-integration" class="anchor" aria-hidden="true" href="#interpolation-and-integration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interpolation and Integration</h2>
<p dir="auto">Interpolation gives an estimate of the function value at x with given grid and function value on the grid.
For most of the simple grids the interpolation is given by linear interpolation with the floor function to find
the corresponding grid points. BaryCheb uses an optimized algorithm for interpolation which makes use of the information
of all grid points, and thus gives a more precise interpolation with the same number of grid points, given the condition that
the function itself is smooth enough. For composite grids, the interpolation is done recursively, so that the final result
depends on the type of lowest level grid. Interpolation for higher dimension where the data is defined on a list of grids is also
given, but only linear interpolation is implemented, even when some of the grids are BaryCheb.</p>
<p dir="auto">Integration over 1D grid is also provided. For most of simple grids it's given by linear integral, while for GaussLegendre grid it's
optimized. For composite grids it's again recursively done so that the method depends on the type of lowest level grids.</p>
<p dir="auto">A detailed manual can be found <a href="https://numericaleft.github.io/CompositeGrids.jl/dev/lib/interpolate/" rel="nofollow">here</a>.</p>
</article></div>