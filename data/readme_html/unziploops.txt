<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-unziploops" class="anchor" aria-hidden="true" href="#unziploops"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>UnzipLoops</h1>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9f233ae10b14a71de2e02072b7d650bdd49593b440d4be0ccc9ab07b697d49ff/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6a756c69612d253345253344253230312e372d626c7565"><img src="https://camo.githubusercontent.com/9f233ae10b14a71de2e02072b7d650bdd49593b440d4be0ccc9ab07b697d49ff/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6a756c69612d253345253344253230312e372d626c7565" alt="Julia version" data-canonical-src="https://img.shields.io/badge/julia-%3E%3D%201.7-blue" style="max-width: 100%;"></a></p>
<p dir="auto">For function <code>f</code> that returns a Tuple object, this package provides one optimized function
<code>broadcast_unzip(f, As...)</code> that works similar to <code>broadcast(f, As...)</code> (aka <code>f.(As...)</code>) but
outputs different data layout.</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<p dir="auto">Broadcasting is very useful in Julia. When you use broadcasting, you'll definitely meet cases like
this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f(x, y) = x^y, x/y

X, Y = [1, 2, 3, 4], [4 3 2 1]
out = f.(X, Y)"><pre><span class="pl-en">f</span>(x, y) <span class="pl-k">=</span> x<span class="pl-k">^</span>y, x<span class="pl-k">/</span>y

X, Y <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], [<span class="pl-c1">4</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>]
out <span class="pl-k">=</span> <span class="pl-c1">f</span>.(X, Y)</pre></div>
<p dir="auto">This <code>out</code> is of type <code>Matrix{Tuple{Int,Float64}}</code>. It's often the case that we'll need to unzip it
to <code>Tuple{Matrix{Int}, Matrix{Float64}}</code>. For most of the case, we can trivially split it apart:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function g(X, Y)
    out = f.(X, Y)
    return map(x-&gt;x[1], out), map(x-&gt;x[2], out)
end"><pre><span class="pl-k">function</span> <span class="pl-en">g</span>(X, Y)
    out <span class="pl-k">=</span> <span class="pl-c1">f</span>.(X, Y)
    <span class="pl-k">return</span> <span class="pl-c1">map</span>(x<span class="pl-k">-&gt;</span>x[<span class="pl-c1">1</span>], out), <span class="pl-c1">map</span>(x<span class="pl-k">-&gt;</span>x[<span class="pl-c1">2</span>], out)
<span class="pl-k">end</span></pre></div>
<p dir="auto">In this case, since this requires two more broadcasting, it introduces some unnecessary overhead:</p>
<ul dir="auto">
<li><code>f.(X, Y)</code> allocates one extra memory to store the intermediate result, and</li>
<li>the entire function requires two more loops to do the work and thus hurts the cache locality --
locality matters for low-level performance optimization.</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X, Y = rand(1:5, 1024), collect(rand(1:5, 1024)')
@btime f.($X, $Y) # 4.720 ms (2 allocations: 16.00 MiB)
@btime g($X, $Y) # 7.566 ms (6 allocations: 32.00 MiB)"><pre>X, Y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1024</span>), <span class="pl-c1">collect</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1024</span>)<span class="pl-k">'</span>)
<span class="pl-c1">@btime</span> <span class="pl-c1">f</span>.(<span class="pl-k">$</span>X, <span class="pl-k">$</span>Y) <span class="pl-c"><span class="pl-c">#</span> 4.720 ms (2 allocations: 16.00 MiB)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">g</span>(<span class="pl-k">$</span>X, <span class="pl-k">$</span>Y) <span class="pl-c"><span class="pl-c">#</span> 7.566 ms (6 allocations: 32.00 MiB)</span></pre></div>
<p dir="auto">We can observe 2.8ms overhead here.</p>
<p dir="auto">A more optimized version for this specific <code>f</code> is to pre-allocate the output result, and do
everything in one single loop. For this simple case, we can create something similar to below:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function g(X, Y)
    T = promote_type(Float64, eltype(X), eltype(Y))
    bc = broadcast(f, X, Y)
    Z1 = similar(bc, T)
    Z2 = similar(bc, T)
    @inbounds @simd for i in eachindex(bc)
        v = bc[i]
        Z1[i] = v[1]
        Z2[i] = v[2]
    end
    return Z1, Z2
end"><pre><span class="pl-k">function</span> <span class="pl-en">g</span>(X, Y)
    T <span class="pl-k">=</span> <span class="pl-c1">promote_type</span>(Float64, <span class="pl-c1">eltype</span>(X), <span class="pl-c1">eltype</span>(Y))
    bc <span class="pl-k">=</span> <span class="pl-c1">broadcast</span>(f, X, Y)
    Z1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(bc, T)
    Z2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(bc, T)
    <span class="pl-c1">@inbounds</span> <span class="pl-c1">@simd</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(bc)
        v <span class="pl-k">=</span> bc[i]
        Z1[i] <span class="pl-k">=</span> v[<span class="pl-c1">1</span>]
        Z2[i] <span class="pl-k">=</span> v[<span class="pl-c1">2</span>]
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> Z1, Z2
<span class="pl-k">end</span></pre></div>
<p dir="auto">We usually call this <code>g</code> the SoA (struct of array) layout. Comparing to the AoS (array of struct)
layout that has only one contiguous array involved, this SoA layout introduces two contiguous
arrays. Thus you'll still notice some overhead here compared to the plain <code>f.(X, Y)</code> kernel:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime g($X, $Y) # 6.878 ms (6 allocations: 32.00 MiB)"><pre><span class="pl-c1">@btime</span> <span class="pl-c1">g</span>(<span class="pl-k">$</span>X, <span class="pl-k">$</span>Y) <span class="pl-c"><span class="pl-c">#</span> 6.878 ms (6 allocations: 32.00 MiB)</span></pre></div>
<p dir="auto">but the overhead is relatively small here -- we eliminate the extra loops and allocations. From case
to case, Julia compiler can optimze this difference away.</p>
<h2 dir="auto"><a id="user-content-broadcast_unzip" class="anchor" aria-hidden="true" href="#broadcast_unzip"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>broadcast_unzip</code></h2>
<p dir="auto">Obviously, rewriting the trivial <code>getindex</code> solution into the verbose manual loop introduces many
work and hurts the readability. This also requires the users to understand the very low-level
mechanisim of how broadcasting works, which is not always an easy thing. This is why
<code>broadcast_unzip</code> is introduced -- it's a combination of <code>broadcast</code> and <code>unzip</code>. Most importantly,
this is simple to use and yet fast:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g(X, Y) == broadcast_unzip(f, X, Y) # true
@btime broadcast_unzip(f, $X, $Y) # 5.042 ms (4 allocations: 16.00 MiB)
@btime broadcast(f, $X, $Y) # 4.647 ms (2 allocations: 16.00 MiB)"><pre><span class="pl-c1">g</span>(X, Y) <span class="pl-k">==</span> <span class="pl-c1">broadcast_unzip</span>(f, X, Y) <span class="pl-c"><span class="pl-c">#</span> true</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast_unzip</span>(f, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y) <span class="pl-c"><span class="pl-c">#</span> 5.042 ms (4 allocations: 16.00 MiB)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast</span>(f, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y) <span class="pl-c"><span class="pl-c">#</span> 4.647 ms (2 allocations: 16.00 MiB)</span></pre></div>
<p dir="auto">The overhead is almost minimized here.</p>
<p dir="auto">Additionally, <code>broadcast_unzip</code> accepts more inputs (just like <code>broadcast</code>) as long as <code>f</code> outputs a
<code>Tuple</code> of a scalar-like object.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X, Y, Z = rand(1:5, 1024), rand(1:5, 1024), rand(1:5, 1024)
f(x, y, z) = x ^ y ^ z, x / y / z, x * y * z, x / (y*z)
out = broadcast_unzip(f, X, Y, Z)
@assert out[1] == getindex.(f.(X, Y, Z), 1)

@btime broadcast(f, $X, $Y, $Z) # 15.692 μs (2 allocations: 32.05 KiB)
@btime broadcast_unzip(f, $X, $Y, $Z) # 16.072 μs (4 allocations: 32.50 KiB)"><pre>X, Y, Z <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1024</span>), <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1024</span>), <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1024</span>)
<span class="pl-en">f</span>(x, y, z) <span class="pl-k">=</span> x <span class="pl-k">^</span> y <span class="pl-k">^</span> z, x <span class="pl-k">/</span> y <span class="pl-k">/</span> z, x <span class="pl-k">*</span> y <span class="pl-k">*</span> z, x <span class="pl-k">/</span> (y<span class="pl-k">*</span>z)
out <span class="pl-k">=</span> <span class="pl-c1">broadcast_unzip</span>(f, X, Y, Z)
<span class="pl-c1">@assert</span> out[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">getindex</span>.(<span class="pl-c1">f</span>.(X, Y, Z), <span class="pl-c1">1</span>)

<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast</span>(f, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y, <span class="pl-k">$</span>Z) <span class="pl-c"><span class="pl-c">#</span> 15.692 μs (2 allocations: 32.05 KiB)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast_unzip</span>(f, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y, <span class="pl-k">$</span>Z) <span class="pl-c"><span class="pl-c">#</span> 16.072 μs (4 allocations: 32.50 KiB)</span></pre></div>
<h2 dir="auto"><a id="user-content-performance-caveat----type-stability" class="anchor" aria-hidden="true" href="#performance-caveat----type-stability"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance caveat -- type stability</h2>
<p dir="auto">Just like the function <code>map</code>/<code>broadcast</code>, the input function <code>f</code> has to be type-inferrable to work
performantly:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X, Y = rand(1:5, 1024), rand(1:5, 1024)
f_unstable(x, y) = x &gt; 3 ? (x * y, x / y) : (x + y, x - y) # &lt;-- many people make mistakes here
f_stable(x, y) = x &gt; 3 ? (Float64(x * y), Float64(x / y)) : (Float64(x + y), Float64(x - y))

# unstable
@btime broadcast(f_unstable, $X, $Y); # 11.292 μs (1026 allocations: 56.25 KiB)
@btime broadcast_unzip(f_unstable, $X, $Y); # 8.812 μs (403 allocations: 22.52 KiB)

# stable
@btime broadcast(f_stable, $X, $Y); # 1.740 μs (1 allocation: 16.12 KiB)
@btime broadcast_unzip(f_stable, $X, $Y); # 3.018 μs (2 allocations: 16.25 KiB)"><pre>X, Y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1024</span>), <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1024</span>)
<span class="pl-en">f_unstable</span>(x, y) <span class="pl-k">=</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">3</span> <span class="pl-k">?</span> (x <span class="pl-k">*</span> y, x <span class="pl-k">/</span> y) <span class="pl-k">:</span> (x <span class="pl-k">+</span> y, x <span class="pl-k">-</span> y) <span class="pl-c"><span class="pl-c">#</span> &lt;-- many people make mistakes here</span>
<span class="pl-en">f_stable</span>(x, y) <span class="pl-k">=</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">3</span> <span class="pl-k">?</span> (<span class="pl-c1">Float64</span>(x <span class="pl-k">*</span> y), <span class="pl-c1">Float64</span>(x <span class="pl-k">/</span> y)) <span class="pl-k">:</span> (<span class="pl-c1">Float64</span>(x <span class="pl-k">+</span> y), <span class="pl-c1">Float64</span>(x <span class="pl-k">-</span> y))

<span class="pl-c"><span class="pl-c">#</span> unstable</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast</span>(f_unstable, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y); <span class="pl-c"><span class="pl-c">#</span> 11.292 μs (1026 allocations: 56.25 KiB)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast_unzip</span>(f_unstable, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y); <span class="pl-c"><span class="pl-c">#</span> 8.812 μs (403 allocations: 22.52 KiB)</span>

<span class="pl-c"><span class="pl-c">#</span> stable</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast</span>(f_stable, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y); <span class="pl-c"><span class="pl-c">#</span> 1.740 μs (1 allocation: 16.12 KiB)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">broadcast_unzip</span>(f_stable, <span class="pl-k">$</span>X, <span class="pl-k">$</span>Y); <span class="pl-c"><span class="pl-c">#</span> 3.018 μs (2 allocations: 16.25 KiB)</span></pre></div>
<h2 dir="auto"><a id="user-content-scalar-output-function-not-supported" class="anchor" aria-hidden="true" href="#scalar-output-function-not-supported"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Scalar output function not supported</h2>
<p dir="auto">Currently, function <code>f</code> that outputs a scalar is delibrately disallowed because there are two
possible result that both makes sense:</p>
<ul dir="auto">
<li><code>Array</code>: degenerates to <code>broadcast(f, args...)</code></li>
<li><code>Tuple{Array}</code>: degenerated from the generic <code>broadcast_unzip((f, ), args...)</code> form (not supported, though)</li>
</ul>
<p dir="auto">Thus you'll get an error message here:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; broadcast_unzip(+, [1, 2], [3, 4])
ERROR: function + must return a tuple, instead it returns Int64
Stacktrace:
..."><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">broadcast_unzip</span>(<span class="pl-k">+</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], [<span class="pl-c1">3</span>, <span class="pl-c1">4</span>])
ERROR<span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-k">+</span> must <span class="pl-k">return</span> a tuple, instead it returns Int64
Stacktrace<span class="pl-k">:</span>
<span class="pl-k">...</span></pre></div>
<h2 dir="auto"><a id="user-content-comparison-with-other-solutions" class="anchor" aria-hidden="true" href="#comparison-with-other-solutions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Comparison with other solutions</h2>
<p dir="auto">This package might never exists if I had known the <a href="https://github.com/JuliaArrays/MappedArrays.jl">MappedArrays</a> + <a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays</a> solutions
provided in the <a href="https://discourse.julialang.org/t/ann-unziploops-broadcasting-and-unzip-the-output-without-overhead/89190" rel="nofollow">ANN post</a>. But it turns out this package is (a little bit) superior to those
alternatives speaking of the performance, see benchmark results in <a href="benchmarks/mydot.jl">mydot benchmarks</a>.</p>
</article></div>