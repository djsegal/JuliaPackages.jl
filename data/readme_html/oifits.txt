<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-support-for-oi-fits-data-in-julia" class="anchor" aria-hidden="true" href="#support-for-oi-fits-data-in-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Support for OI-FITS data in Julia</h1>
<p dir="auto"><a href="./LICENSE.md"><img src="https://camo.githubusercontent.com/bbf49a2eb96e6f718803f2493bd7aa3baae61abb09b7f8fc185a94e08c504dc6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d627269676874677265656e2e7376673f7374796c653d666c6174" alt="License" data-canonical-src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" style="max-width: 100%;"></a>
<a href="https://github.com/emmt/OIFITS.jl/actions/workflows/CI.yml?query=branch%3Amaster"><img src="https://github.com/emmt/OIFITS.jl/actions/workflows/CI.yml/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/emmt/OIFITS-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/340ce37cc865f54460b2fd2a3bdde35fb5c1be3fa9a0d8e7ccdaa66058da28ea/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f656d6d742f4f49464954532e6a6c3f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/emmt/OIFITS.jl?branch=master" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/emmt/OIFITS.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/f27de208c5280bb132619e64847e4e786bacc98ba2e3c204fe4272df9385c6bc/687474703a2f2f636f6465636f762e696f2f6769746875622f656d6d742f4f49464954532e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="Coverage" data-canonical-src="http://codecov.io/github/emmt/OIFITS.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">The <code>OIFITS.jl</code> package provides support for OI-FITS data in Julia language.</p>
<h2 dir="auto"><a id="user-content-oi-fits-types" class="anchor" aria-hidden="true" href="#oi-fits-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>OI-FITS types</h2>
<p dir="auto">OI-FITS is a standard to store optical interferometry data as a collection of
data-blocks. In the second revision of the standard (see <a href="#references">Ref. 1</a>
and <a href="#references">Ref. 2</a>), an OI-FITS file may contain the following
data-blocks:</p>
<ul dir="auto">
<li>an <code>OI_TARGET</code> data-block stores a list of observed targets;</li>
<li>each <code>OI_ARRAY</code> data-block describes a given array of telescope stations;</li>
<li>each <code>OI_WAVELENGTH</code> data-block describes a given instrument notably the
effective wavelengths and bandwidths of its spectral channels;</li>
<li><code>OI_CORR</code> data-blocks store correlation data;</li>
<li><code>OI_VIS</code> data-blocks store complex visibility data;</li>
<li><code>OI_VIS2</code> data-blocks store squared visibility (powerspectrum) data;</li>
<li><code>OI_T3</code> data-blocks store triple product (bispectrum) data;</li>
<li><code>OI_FLUX</code> data-blocks store spectral flux data;</li>
<li><code>OI_INSPOL</code> data-blocks store instrumental polarization data.</li>
</ul>
<p dir="auto">These data-blocks are stored as binary tables in a FITS data file. The support
for FITS files is provided by the
<a href="https://github.com/JuliaAstro/FITSIO.jl"><code>FITSIO.jl</code></a> package.</p>
<p dir="auto">The Julia type of an OI-FITS data-block is named as the corresponding OI-FITS
extension. In addition to these types for individual OI-FITS data-blocks, the
<code>OIFITS.jl</code> package provides data-sets (of type <code>OIDataSet</code>) that contain
several OI-FITS data-blocks. Each data-set is an efficient representation of
the contents of a compliant OI-FITS file.</p>
<h2 dir="auto"><a id="user-content-reading-and-writing-oi-fits-files" class="anchor" aria-hidden="true" href="#reading-and-writing-oi-fits-files"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reading and writing OI-FITS files</h2>
<h3 dir="auto"><a id="user-content-reading-and-writing-oi-fits-data-sets" class="anchor" aria-hidden="true" href="#reading-and-writing-oi-fits-data-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reading and writing OI-FITS data-sets</h3>
<p dir="auto">Reading an OI-FITS data file in Julia yields a data-set and is done by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using OIFITS
ds = read(OIDataSet, input)"><pre><span class="pl-k">using</span> OIFITS
ds <span class="pl-k">=</span> <span class="pl-c1">read</span>(OIDataSet, input)</pre></div>
<p dir="auto">where <code>input</code> it the name of the OI-FITS file or an instance of <code>FITSIO.FITS</code>
which represents an open FITS file. The above <code>read</code> call is equivalent to the
shortcut:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds = OIDataSet(input)"><pre>ds <span class="pl-k">=</span> <span class="pl-c1">OIDataSet</span>(input)</pre></div>
<p dir="auto">It is possible to merge the contents of several OI-FITS file, say <code>inp1</code>,
<code>inp2</code>, etc., by one of:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds = read(OIDataSet, inp1, inp2, ...)
ds = OIDataSet(inp1, inp2, ...)"><pre>ds <span class="pl-k">=</span> <span class="pl-c1">read</span>(OIDataSet, inp1, inp2, <span class="pl-k">...</span>)
ds <span class="pl-k">=</span> <span class="pl-c1">OIDataSet</span>(inp1, inp2, <span class="pl-k">...</span>)</pre></div>
<p dir="auto">or to merge them into an existing data-set <code>ds</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="read!(ds, inp1, inp2, ...)"><pre><span class="pl-c1">read!</span>(ds, inp1, inp2, <span class="pl-k">...</span>)</pre></div>
<p dir="auto">Creating an OI-FITS file is as simple as writing the data-set <code>ds</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="write(filename, ds)"><pre><span class="pl-c1">write</span>(filename, ds)</pre></div>
<p dir="auto">Overwriting is forbidden by default, but the keyword <code>overwrite=true</code> may be
specified to allow for silently overwriting an existing file.</p>
<h3 dir="auto"><a id="user-content-reading-individual-oi-fits-data-blocks" class="anchor" aria-hidden="true" href="#reading-individual-oi-fits-data-blocks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reading individual OI-FITS data-blocks</h3>
<p dir="auto">It may be useful to read individual OI-FITS data-blocks, to debug or to fix the
contents of a non-compliant OI-FITS file. To that end, you must open the FITS
file and can then read a given HDU as an OI-FITS data-block:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FITSIO, OIFITS
f = FITS(filename, &quot;r&quot;)     # open FITS file for reading
tgt = OI_TARGET(f[i])       # read OI_TARGET extension in i-th HDU
tgt = read(OI_TARGET, f[i]) # idem
db = OI_VIS2(f[j])          # read OI_VIS2 extension in j-th HDU
db = read(OI_VIS2, f[j])    # idem
..."><pre><span class="pl-k">using</span> FITSIO, OIFITS
f <span class="pl-k">=</span> <span class="pl-c1">FITS</span>(filename, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>)     <span class="pl-c"><span class="pl-c">#</span> open FITS file for reading</span>
tgt <span class="pl-k">=</span> <span class="pl-c1">OI_TARGET</span>(f[i])       <span class="pl-c"><span class="pl-c">#</span> read OI_TARGET extension in i-th HDU</span>
tgt <span class="pl-k">=</span> <span class="pl-c1">read</span>(OI_TARGET, f[i]) <span class="pl-c"><span class="pl-c">#</span> idem</span>
db <span class="pl-k">=</span> <span class="pl-c1">OI_VIS2</span>(f[j])          <span class="pl-c"><span class="pl-c">#</span> read OI_VIS2 extension in j-th HDU</span>
db <span class="pl-k">=</span> <span class="pl-c1">read</span>(OI_VIS2, f[j])    <span class="pl-c"><span class="pl-c">#</span> idem</span>
<span class="pl-k">...</span></pre></div>
<p dir="auto">any OI-FITS data-block type can be used in that way.  If the type of the <code>i</code>-th
extension is not known, <code>OIDataBlock</code> can be used instead but the result is not
type-stable:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="db = OIDataBlock(f[i])       # read OI-FITS extension extension in i-th HDU
db = read(OIDataBlock, f[i]) # idem"><pre>db <span class="pl-k">=</span> <span class="pl-c1">OIDataBlock</span>(f[i])       <span class="pl-c"><span class="pl-c">#</span> read OI-FITS extension extension in i-th HDU</span>
db <span class="pl-k">=</span> <span class="pl-c1">read</span>(OIDataBlock, f[i]) <span class="pl-c"><span class="pl-c">#</span> idem</span></pre></div>
<p dir="auto">Writing individual OI-FITS data-blocks is also possible:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FITSIO, OIFITS
f = FITS(filename, &quot;w&quot;) # open FITS file for writing
write(f, db)            # write db in the next HDU of f"><pre><span class="pl-k">using</span> FITSIO, OIFITS
f <span class="pl-k">=</span> <span class="pl-c1">FITS</span>(filename, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span> open FITS file for writing</span>
<span class="pl-c1">write</span>(f, db)            <span class="pl-c"><span class="pl-c">#</span> write db in the next HDU of f</span></pre></div>
<p dir="auto">To fix a non-compliant OI-FITS file (usually duplicate target or instrument
names), you can read all the data-blocks, fix those which are wrong and push
them in <strong>order</strong> in an <code>OIDataSet</code> to have a consistent data-set which you can
then directly use or write in an OI-FITS file for later. Thanks to the
automatic rewriting of target identifiers and of the fact that targets (and
other dependencies) are identified by their name and consistently merged, it is
possible to push an <code>OI_TARGET</code> with multiply defined identical targets (apart
maybe their identifiers).</p>
<h2 dir="auto"><a id="user-content-accessing-the-contents-of-data-blocks-and-data-sets" class="anchor" aria-hidden="true" href="#accessing-the-contents-of-data-blocks-and-data-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Accessing the contents of data-blocks and data-sets</h2>
<p dir="auto">The contents of OI-FITS data-blocks and data-sets may be accessed by the dot
notation but also by indexation.</p>
<h3 dir="auto"><a id="user-content-contents-of-data-sets" class="anchor" aria-hidden="true" href="#contents-of-data-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contents of data-sets</h3>
<p dir="auto">The dot notation can be used on a <em>data-set</em> object, say <code>ds</code>, storing a
consistent set of OI-FITS data-blocks.  The following properties are available:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>ds.target</code> is the <code>OI_TARGET</code> data-block of the OI-FITS structure.</p>
</li>
<li>
<p dir="auto"><code>ds.instr</code> is a list of <code>OI_WAVELENGTH</code> data-blocks indexed by a regular
integer index or by the instrument name:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds.instr[i]       # yields the i-th OI_WAVELENGTH data-block
ds.instr[insname] # yields the OI_WAVELENGTH data-block whose name matches insname"><pre>ds<span class="pl-k">.</span>instr[i]       <span class="pl-c"><span class="pl-c">#</span> yields the i-th OI_WAVELENGTH data-block</span>
ds<span class="pl-k">.</span>instr[insname] <span class="pl-c"><span class="pl-c">#</span> yields the OI_WAVELENGTH data-block whose name matches insname</span></pre></div>
<p dir="auto">Matching of names follows FITS conventions that case of letters and trailing
spaces are ignored. An exception is thrown if the index (integer or name) is
not valid. The <code>get</code> method can be used to provide a default value, for
example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="get(ds.instr, insname, nothing)"><pre><span class="pl-c1">get</span>(ds<span class="pl-k">.</span>instr, insname, <span class="pl-c1">nothing</span>)</pre></div>
<p dir="auto">would yield <code>nothing</code> if <code>insname</code> is not found in <code>ds.instr</code> instead of
throwing an exception.</p>
</li>
<li>
<p dir="auto"><code>ds.array</code> is a list of <code>OI_ARRAY</code> data-blocks indexed like <code>ds.instr</code> except
that interferometric array names are assumed.</p>
</li>
<li>
<p dir="auto"><code>ds.correl</code> is a list of <code>OI_CORR</code> data-blocks indexed like <code>ds.instr</code> except
that correlation data array names are assumed.</p>
</li>
<li>
<p dir="auto"><code>ds.vis</code> is a vector of <code>OI_VIS</code> data-blocks.</p>
</li>
<li>
<p dir="auto"><code>ds.vis2</code> is a vector of <code>OI_VIS2</code> data-blocks.</p>
</li>
<li>
<p dir="auto"><code>ds.t3</code> is a vector of <code>OI_T3</code> data-blocks.</p>
</li>
<li>
<p dir="auto"><code>ds.flux</code> is a vector of <code>OI_FLUX</code> data-blocks.</p>
</li>
<li>
<p dir="auto"><code>ds.inspol</code> is a vector of <code>OI_INSPOL</code> data-blocks.</p>
</li>
</ul>
<p dir="auto">Other fields of data-sets shall be considered as <strong>private</strong> and not accessed
directly.</p>
<p dir="auto">Using the dot notation, it is easy to access the different data-blocks
containing measurements. For instance:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for db in ds.vis2
    ...
end"><pre><span class="pl-k">for</span> db <span class="pl-k">in</span> ds<span class="pl-k">.</span>vis2
    <span class="pl-k">...</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">is convenient to loop across all <code>OI_VIS2</code> instances stored by <code>ds</code>.</p>
<h3 dir="auto"><a id="user-content-contents-of-data-blocks" class="anchor" aria-hidden="true" href="#contents-of-data-blocks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contents of data-blocks</h3>
<p dir="auto">The contents of a data-block, say <code>db</code>, may also be accessed by the dot
notation.  As a general rule, <code>db.key</code> or <code>db.col</code> yield the value of the
keyword <code>key</code> or the contents of the column <code>col</code> of the OI-FITS table
corresponding to the data-block <code>db</code>.  In order to follow Julia conventions and
to accommodate for a number of restrictions, <code>key</code> or <code>col</code> are the FITS
keyword or column name converted to lower case letters and with
non-alphanumeric letters replaced by underscores.  For instance <code>db.date_obs</code>
yields the value of the keyword <code>DATE-OBS</code>, that is the UTC start date of
observations.  The revision number corresponding to the keyword <code>OI_REVN</code> is
however accessed as <code>db.revn</code>, this is the only exception.  Other properties
are also accessible via this syntax:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>db.extname</code> yields the OI-FITS name of the extension corresponding to the
data-block <code>db</code> (for all data-block types);</p>
</li>
<li>
<p dir="auto"><code>db.array</code> yields the <code>OI_ARRAY</code> data-block associated with data-block <code>db</code>
(only for <code>OI_VIS</code>, <code>OI_VIS2</code>, <code>OI_T3</code>, <code>OI_FLUX</code>, and <code>OI_INSPOL</code>
data-block).  Beware that the association with an <code>OI_ARRAY</code> is optional, so
<code>db.array</code> may be actually undefined; this can be checked by
<code>isdefined(db,:array)</code>.</p>
</li>
<li>
<p dir="auto"><code>db.instr</code> yields the <code>OI_WAVELENGTH</code> data-block associated with data-block
<code>db</code> (only for <code>OI_VIS</code>, <code>OI_VIS2</code>, <code>OI_T3</code>, and <code>OI_FLUX</code> data-block).</p>
</li>
<li>
<p dir="auto"><code>db.correl</code> yields the <code>OI_CORR</code> data-block associated with data-block <code>db</code>
(only for <code>OI_VIS</code>, <code>OI_VIS2</code>, <code>OI_T3</code>, and <code>OI_FLUX</code> data-block).</p>
</li>
<li>
<p dir="auto"><code>db.name</code> is an alias for <code>db.arrname</code> for <code>OI_ARRAY</code> instances, for
<code>db.insname</code> for <code>OI_WAVELENGTH</code> instances, and for <code>db.corrname</code> for
<code>OI_CORR</code> instances.</p>
</li>
</ul>
<p dir="auto">Of course, getting a given property must make sense.  For example,
<code>db.sta_name</code> is only possible for an <code>OI_ARRAY</code> data-block but not for an
<code>OI_WAVELENGTH</code> data-block.  The dot notation can be however be chained and:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="db.instr.eff_wave"><pre>db<span class="pl-k">.</span>instr<span class="pl-k">.</span>eff_wave</pre></div>
<p dir="auto">can be used to access the effective wavelengths of the measurements in <code>db</code> via
the instrument associated to <code>db</code>.  Shortcuts are provided:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="λ  = db.eff_wave # get effective wavelength
Δλ = db.eff_band # get effective bandwidth"><pre>λ  <span class="pl-k">=</span> db<span class="pl-k">.</span>eff_wave <span class="pl-c"><span class="pl-c">#</span> get effective wavelength</span>
Δλ <span class="pl-k">=</span> db<span class="pl-k">.</span>eff_band <span class="pl-c"><span class="pl-c">#</span> get effective bandwidth</span></pre></div>
<p dir="auto">for <code>OI_WAVELENGTH</code> data-blocks but also for <code>OI_VIS</code>, <code>OI_VIS2</code>, <code>OI_T3</code>, and
<code>OI_FLUX</code> data-blocks.</p>
<p dir="auto">Some fields of a data-block <code>db</code> may however be undefined because:</p>
<ul dir="auto">
<li>
<p dir="auto">the field is not yet defined (the data-block is being constructed);</p>
</li>
<li>
<p dir="auto">the field is optional in the revision <code>db.revn</code> of the data-block;</p>
</li>
<li>
<p dir="auto">the field (for example <code>db.instr</code> for an <code>OI_VIS</code> data-block) involves links
with other data-blocks (the <em>dependencies)</em> and these links are only defined
when a data-block is part of a data-set (see <a href="#building-of-data-sets">Building of
data-sets</a> below).</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-oi_target-data-blocks" class="anchor" aria-hidden="true" href="#oi_target-data-blocks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>OI_TARGET</code> data-blocks</h3>
<p dir="auto">For efficiency, instances of <code>OI_TARGET</code> data-blocks do not follow the same
rules as other types of OI-FITS data-blocks whose properties are the columns of
the corresponding OI-FITS table: in an <code>OI_TARGET</code> instance, all parameters
describing a target are repesented by an <code>OITargetEntry</code> structure and all
targets are stored as a vector of <code>OITargetEntry</code>.  An <code>OI_TARGET</code> instance,
say <code>db</code>, has the 3 following properties:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="db.extname # yields &quot;OI_TARGET&quot;
db.list    # yields a vector of OITargetEntry instances
db.revn    # yields the revision number"><pre>db<span class="pl-k">.</span>extname <span class="pl-c"><span class="pl-c">#</span> yields "OI_TARGET"</span>
db<span class="pl-k">.</span>list    <span class="pl-c"><span class="pl-c">#</span> yields a vector of OITargetEntry instances</span>
db<span class="pl-k">.</span>revn    <span class="pl-c"><span class="pl-c">#</span> yields the revision number</span></pre></div>
<p dir="auto">The list of targets <code>db.list</code> can be indexed by an integer (as any Julia
vector) or by the target name (case of letters and trailing spaces are
irrelevant).</p>
<p dir="auto">As an <code>OI_TARGET</code> data-blocks is essentially a vector of target entries, it can
be used as an iterable and it can indexed by an integer index or by a target
name:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="length(db) # the number of targets, shortcut for `length(db.list)`
db[i]      # the i-th target, shortcut for `db.list[i]`
db[key]    # the target whose name matches string `key`, shortcut for `db.list[key]`"><pre><span class="pl-c1">length</span>(db) <span class="pl-c"><span class="pl-c">#</span> the number of targets, shortcut for `length(db.list)`</span>
db[i]      <span class="pl-c"><span class="pl-c">#</span> the i-th target, shortcut for `db.list[i]`</span>
db[key]    <span class="pl-c"><span class="pl-c">#</span> the target whose name matches string `key`, shortcut for `db.list[key]`</span></pre></div>
<p dir="auto">Standard methods <code>get</code> and <code>haskey</code>, applied to <code>db.list</code> or directly to <code>db</code>,
work as expected and according to the type (integer or string) of the key.  For
the <code>keys</code> method, the default is to return an iterator over the target names,
but the type of the expected keys can be specified:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="get(db,key,def)   # yields `db[key]` or `def` if `key` not found
keys(db)          # iterator over target names
keys(String, db)  # idem
keys(Integer, db) # iterator over target indices
keys(Int, db)     # idem"><pre><span class="pl-c1">get</span>(db,key,def)   <span class="pl-c"><span class="pl-c">#</span> yields `db[key]` or `def` if `key` not found</span>
<span class="pl-c1">keys</span>(db)          <span class="pl-c"><span class="pl-c">#</span> iterator over target names</span>
<span class="pl-c1">keys</span>(String, db)  <span class="pl-c"><span class="pl-c">#</span> idem</span>
<span class="pl-c1">keys</span>(Integer, db) <span class="pl-c"><span class="pl-c">#</span> iterator over target indices</span>
<span class="pl-c1">keys</span>(Int, db)     <span class="pl-c"><span class="pl-c">#</span> idem</span></pre></div>
<p dir="auto">The method <code>OIFITS.get_column</code> is a helper to recover a single target field as
a vector:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="OIFITS.get_column([T,] db, col)"><pre>OIFITS<span class="pl-k">.</span><span class="pl-c1">get_column</span>([T,] db, col)</pre></div>
<p dir="auto">yields the column <code>col</code> of an OI-FITS data-block <code>db</code>.  Column is identified by
<code>col</code> which is either <code>sym</code> or <code>Val(sym)</code> where <code>sym</code> is the symbolic name of
the corresponding field in <code>OITargetEntry</code>.  Optional argument <code>T</code> is to
specify the element type of the returned array.</p>
<p dir="auto">To build an <code>OI_TARGET</code> instance, you may provide the list of targets and the
revision number:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="OI_TARGET(lst=OITargetEntry[]; revn=0)"><pre><span class="pl-c1">OI_TARGET</span>(lst<span class="pl-k">=</span>OITargetEntry[]; revn<span class="pl-k">=</span><span class="pl-c1">0</span>)</pre></div>
<p dir="auto">yields an <code>OI_TARGET</code> data-block.  Optional argument <code>lst</code> is a vector of
<code>OITargetEntry</code> specifying the targets (none by default).  Keyword <code>revn</code>
specifies the revision number.</p>
<p dir="auto">A target entry may be constructed by specifying all its fields (there are many)
by keywords, all of which but <code>category</code> are mandatory:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = OITargetEntry(;
        target_id ::Integer,
        target    ::AbstractString,
        raep0     ::AbstractFloat,
        decep0    ::AbstractFloat,
        equinox   ::AbstractFloat,
        ra_err    ::AbstractFloat,
        dec_err   ::AbstractFloat,
        sysvel    ::AbstractFloat,
        veltyp    ::AbstractString,
        veldef    ::AbstractString,
        pmra      ::AbstractFloat,
        pmdec     ::AbstractFloat,
        pmra_err  ::AbstractFloat,
        pmdec_err ::AbstractFloat,
        parallax  ::AbstractFloat,
        para_err  ::AbstractFloat,
        spectyp   ::AbstractString,
        category  ::AbstractString = &quot;&quot;)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">OITargetEntry</span>(;
        target_id <span class="pl-k">::</span><span class="pl-c1">Integer</span>,
        target    <span class="pl-k">::</span><span class="pl-c1">AbstractString</span>,
        raep0     <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        decep0    <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        equinox   <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        ra_err    <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        dec_err   <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        sysvel    <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        veltyp    <span class="pl-k">::</span><span class="pl-c1">AbstractString</span>,
        veldef    <span class="pl-k">::</span><span class="pl-c1">AbstractString</span>,
        pmra      <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        pmdec     <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        pmra_err  <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        pmdec_err <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        parallax  <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        para_err  <span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>,
        spectyp   <span class="pl-k">::</span><span class="pl-c1">AbstractString</span>,
        category  <span class="pl-k">::</span><span class="pl-c1">AbstractString</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">It is also possible to specify another target entry, say <code>ref</code>, which is used
as a template: any unspecified keyword is assume to have the same value as in
<code>ref</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = OITargetEntry(ref;
        target_id = ref.target_id,
        target    = ref.target,
        ...)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">OITargetEntry</span>(ref;
        target_id <span class="pl-k">=</span> ref<span class="pl-k">.</span>target_id,
        target    <span class="pl-k">=</span> ref<span class="pl-k">.</span>target,
        <span class="pl-k">...</span>)</pre></div>
<p dir="auto">Note that, when an <code>OI_TARGET</code> instance is pushed in a data-set, target
identifiers (field <code>target_id</code>) are automatically rewritten to be identical to
the index in the list of targets of the data-set.</p>
<h2 dir="auto"><a id="user-content-building-of-data-sets" class="anchor" aria-hidden="true" href="#building-of-data-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Building of data-sets</h2>
<h3 dir="auto"><a id="user-content-pushing-data-blocks-to-data-sets" class="anchor" aria-hidden="true" href="#pushing-data-blocks-to-data-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Pushing data-blocks to data-sets</h3>
<p dir="auto">Reading an OI-FITS file is the easiest way to define a data-set but a new
OI-FITS data-set may be built by creating an empty data-set with <code>OIDataSet()</code>,
and then pushing OI-FITS data-blocks <strong>in order</strong> with <code>push!(...)</code>. Indeed, in
order to ensure the consistency of a data-set, it is required to push the
dependencies (<code>OI_TARGET</code>, <code>OI_ARRAY</code>, <code>OI_WAVELENGTH</code>, and <code>OI_CORR</code>
data-blocks) <strong>before</strong> the data-blocks containing measurements (<code>OI_VIS</code>,
<code>OI_VIS2</code>, <code>OI_T3</code>, <code>OI_FLUX</code>, and <code>OI_INSPOL</code>) that may refer to them.</p>
<p dir="auto">For example, building a new data-set, say <code>ds</code>, looks like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds = OIDataSet() # create empty data-set
push!(ds, arr)   # push OI_ARRAY data-block(s)
push!(ds, ins)   # push OI_WAVELENGTH data-block(s)
push!(ds, cor)   # push OI_CORR data-block(s)
push!(ds, tgt)   # push OI_TARGET data-block
push!(ds, db1)   # push data
push!(ds, db2)   # push more data
push!(ds, db3)   # push even more data
..."><pre>ds <span class="pl-k">=</span> <span class="pl-c1">OIDataSet</span>() <span class="pl-c"><span class="pl-c">#</span> create empty data-set</span>
<span class="pl-c1">push!</span>(ds, arr)   <span class="pl-c"><span class="pl-c">#</span> push OI_ARRAY data-block(s)</span>
<span class="pl-c1">push!</span>(ds, ins)   <span class="pl-c"><span class="pl-c">#</span> push OI_WAVELENGTH data-block(s)</span>
<span class="pl-c1">push!</span>(ds, cor)   <span class="pl-c"><span class="pl-c">#</span> push OI_CORR data-block(s)</span>
<span class="pl-c1">push!</span>(ds, tgt)   <span class="pl-c"><span class="pl-c">#</span> push OI_TARGET data-block</span>
<span class="pl-c1">push!</span>(ds, db1)   <span class="pl-c"><span class="pl-c">#</span> push data</span>
<span class="pl-c1">push!</span>(ds, db2)   <span class="pl-c"><span class="pl-c">#</span> push more data</span>
<span class="pl-c1">push!</span>(ds, db3)   <span class="pl-c"><span class="pl-c">#</span> push even more data</span>
<span class="pl-k">...</span></pre></div>
<p dir="auto">with the dependencies:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>arr</code> an <code>OI_ARRAY</code> instance defining the interferometric array (zero or any
number of such instances may be pushed),</p>
</li>
<li>
<p dir="auto"><code>ins</code> an <code>OI_WAVELENGTH</code> instance defining the instrument (several such
instances can be pushed),</p>
</li>
<li>
<p dir="auto"><code>cor</code> an <code>OI_COORREL</code> instance defining the correlations (zero or any number
of such instances can be pushed),</p>
</li>
<li>
<p dir="auto"><code>tgt</code> an <code>OI_TARGET</code> instance defining the list of observed targets (at least
one such instance is required, if more such instances are pushed in the same
data-set, they are merged in a single one);</p>
</li>
</ul>
<p dir="auto">and where <code>db1</code>, <code>db2</code>, <code>db3</code>, etc., are instances of <code>OI_VIS</code>, <code>OI_VIS2</code>,
<code>OI_T3</code>, <code>OI_FLUX</code>, or <code>OI_INSPOL</code> that provide measurements.</p>
<p dir="auto">You may push all data-blocks in a single <code>push!</code> call:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds = push!(OIDataSet(), arr, ins, cor, tgt, d1, db2, ...)"><pre>ds <span class="pl-k">=</span> <span class="pl-c1">push!</span>(<span class="pl-c1">OIDataSet</span>(), arr, ins, cor, tgt, d1, db2, <span class="pl-k">...</span>)</pre></div>
<p dir="auto">and the following shortcut is implemented:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds = OIDataSet(arr, ins, cor, tgt, d1, db2, ...)"><pre>ds <span class="pl-k">=</span> <span class="pl-c1">OIDataSet</span>(arr, ins, cor, tgt, d1, db2, <span class="pl-k">...</span>)</pre></div>
<p dir="auto">These two are equivalent to the multi-line example above, but remember that
pushing data-blocks in order (i.e., dependencies before they may be referenced)
is required to have a consistent data-set. Apart from this constraint,
dependencies may be pushed in any order <strong>before</strong> the data-blocks with
measurements and data-blocks with measurements can be pushed in any order
<strong>after</strong> dependencies.</p>
<p dir="auto">As a benefit of the constraint of pushing data-blocks in order, data-blocks
with dependencies are automatically linked to these dependencies when pushed on
the data-set (which implies that the dependencies already exist in the
data-set). This allows for syntactic sugar like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds.vis2[i].eff_wave # the wavelengths of the i-th OI_VIS2 data-block in ds
ds.t3[i].array      # the interferometric array for the i-th OI_T3 data-block in ds
ds.vis[i].instr     # the instrument used for the i-th OI_VIS data-block in ds"><pre>ds<span class="pl-k">.</span>vis2[i]<span class="pl-k">.</span>eff_wave <span class="pl-c"><span class="pl-c">#</span> the wavelengths of the i-th OI_VIS2 data-block in ds</span>
ds<span class="pl-k">.</span>t3[i]<span class="pl-k">.</span>array      <span class="pl-c"><span class="pl-c">#</span> the interferometric array for the i-th OI_T3 data-block in ds</span>
ds<span class="pl-k">.</span>vis[i]<span class="pl-k">.</span>instr     <span class="pl-c"><span class="pl-c">#</span> the instrument used for the i-th OI_VIS data-block in ds</span></pre></div>
<p dir="auto">Without linked dependencies, the first above example would require to (1) find
in the data-set <code>ds</code> the <code>OI_WAVELENGTH</code> instance, say <code>instr</code>, whose name is
matching <code>ds.vi2[i].insname</code> and (2) extract the field <code>eff_wave</code> of <code>instr</code>.
The latter step is as simple as <code>instr.eff_wave</code> but the former one has some
overheads and scales as <code>O(n)</code> with <code>n</code> the number of <code>OI_WAVELENGTH</code> instances
in the data-set.</p>
<p dir="auto">Since an OI-FITS data-set has a single list of targets (an <code>OI_TARGET</code> instance
accessible via <code>ds.target</code>), a mean to merge list of targets had to be defined.
The adopted rule is pretty simple:</p>
<blockquote>
<p dir="auto">The <code>target_id</code> field of any data-block that is part of a data-set
corresponds to the index of the target entry in the list of targets stored by
the data-set.</p>
</blockquote>
<p dir="auto">As a consequence, whenever a data-block is pushed into a data-set, the target
identifiers of the data-block have to be rewritten according to this rule. Of
course, this does not apply for data-blocks with no <code>target_id</code> field such as
<code>OI_ARRAY</code>, <code>OI_WAVELENGTH</code>, and <code>OI_CORR</code>.</p>
<p dir="auto">To summarize, here is what happens under the hood when a data-block <code>db</code> is
pushed into a data-set <code>ds</code>:</p>
<ul dir="auto">
<li>
<p dir="auto">When an <code>OI_ARRAY</code>, <code>OI_WAVELENGTH</code>, or <code>OI_CORR</code> instance <code>db</code> is pushed in
a data-set <code>ds</code>, it is appended to the corresponding list (<code>ds.array</code>,
<code>ds.instr</code>, or <code>ds.correl</code>) unless this list already has an entry with a name
matching <code>db.name</code>. In this latter case, nothing is done unless that an
assertion exception is thrown if the two data-blocks whose names are matching
do not have the same contents (to prevent building inconsistent data-sets).</p>
</li>
<li>
<p dir="auto">When an <code>OI_TARGET</code> instance is pushed in a data-set, the new targets
(according to their names) are appended to the list of targets in the
data-set and their identifiers set to their index in this list. This also
re-initializes an internal dictionary used to perform the conversion from all
the target identifiers of the <code>OI_TARGET</code> instance that has been pushed to
the target identifiers in the data-set. Until it is reinitialized (by pushing
another <code>OI_TARGET</code> instance), this mapping is used to rewrite the target
identifiers of subsequent data-blocks pushed in the data-set.</p>
</li>
<li>
<p dir="auto">When an <code>OI_VIS</code>, <code>OI_VIS2</code>, <code>OI_T3</code>, <code>OI_FLUX</code>, or <code>OI_INSPOL</code> instance <code>db</code>
is pushed in a data-set <code>ds</code>, it is appended to the corresponding list
(<code>ds.vis</code>, <code>ds.vis2</code>, <code>db.t3</code>, <code>db.flux</code>, or <code>ds.inspol</code>), after it has been
linked to its dependencies (<code>OI_ARRAY</code>, <code>OI_WAVELENGTH</code>, etc., which must
already exist in the data-set), and its target identifiers have been
rewritten according to the mapping defined by the last <code>OI_TARGET</code> instance
previously pushed to the data-set. Rewriting of the target identifiers may be
avoided by using the keyword <code>rewrite_target_id=false</code>, this assumes that the
target identifiers in the pushed data-block are already set according to the
index in the list of targets <code>ds.target</code>.</p>
</li>
</ul>
<p dir="auto">Pushing a data-block in a data-set does check the consistency of the
data-block. This is to allow for building the data-blocks step by step so that
they not need to be consistent at all times (just when pushed into a data-set).</p>
<p dir="auto">Pushing a data-block in a data-set lefts the data-block unchanged. A swallow
copy of it is added to the data-blocks stored by the data-set. Most members of
the pushed data-blocks are shared by the one stored by the data-set with the
notable exception of the target identifiers which are rewritten and the links
to the dependencies which are updated.</p>
<p dir="auto">While it sounds complicated, the default rule of rewriting the target
identifiers just amounts to assuming that the target identifiers of <code>OI_VIS</code>,
<code>OI_VIS2</code>, <code>OI_T3</code>, <code>OI_FLUX</code>, or <code>OI_INSPOL</code> instances pushed in a data-set
refer to the last <code>OI_TARGET</code> instance previously pushed on the same data-set.</p>
<p dir="auto">Pushing several groups of data-blocks, each group making a consistent data-set,
in the same data-set is easy. Typically:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# First push dependencies for group 1.
push!(ds, group1_arr) # push OI_ARRAY
push!(ds, group1_ins) # push OI_INS
push!(ds, group1_cor) # push OI_CORR
push!(ds, group1_tgt) # push OI_TARGET (reinitializing target_id mapping)
# Then push data for group 1 (using current target_id mapping).
push!(ds, group1_db1)
push!(ds, group1_db2)
...
# First push dependencies for group 2.
push!(ds, group2_arr) # push OI_ARRAY
push!(ds, group2_ins) # push OI_INS
push!(ds, group2_cor) # push OI_CORR
push!(ds, group2_tgt) # push OI_TARGET (reinitializing target_id mapping)
# Then push data for group 2 (using current target_id mapping).
push!(ds, group2_db1)
push!(ds, group2_db2)
..."><pre><span class="pl-c"><span class="pl-c">#</span> First push dependencies for group 1.</span>
<span class="pl-c1">push!</span>(ds, group1_arr) <span class="pl-c"><span class="pl-c">#</span> push OI_ARRAY</span>
<span class="pl-c1">push!</span>(ds, group1_ins) <span class="pl-c"><span class="pl-c">#</span> push OI_INS</span>
<span class="pl-c1">push!</span>(ds, group1_cor) <span class="pl-c"><span class="pl-c">#</span> push OI_CORR</span>
<span class="pl-c1">push!</span>(ds, group1_tgt) <span class="pl-c"><span class="pl-c">#</span> push OI_TARGET (reinitializing target_id mapping)</span>
<span class="pl-c"><span class="pl-c">#</span> Then push data for group 1 (using current target_id mapping).</span>
<span class="pl-c1">push!</span>(ds, group1_db1)
<span class="pl-c1">push!</span>(ds, group1_db2)
<span class="pl-k">...</span>
<span class="pl-c"><span class="pl-c">#</span> First push dependencies for group 2.</span>
<span class="pl-c1">push!</span>(ds, group2_arr) <span class="pl-c"><span class="pl-c">#</span> push OI_ARRAY</span>
<span class="pl-c1">push!</span>(ds, group2_ins) <span class="pl-c"><span class="pl-c">#</span> push OI_INS</span>
<span class="pl-c1">push!</span>(ds, group2_cor) <span class="pl-c"><span class="pl-c">#</span> push OI_CORR</span>
<span class="pl-c1">push!</span>(ds, group2_tgt) <span class="pl-c"><span class="pl-c">#</span> push OI_TARGET (reinitializing target_id mapping)</span>
<span class="pl-c"><span class="pl-c">#</span> Then push data for group 2 (using current target_id mapping).</span>
<span class="pl-c1">push!</span>(ds, group2_db1)
<span class="pl-c1">push!</span>(ds, group2_db2)
<span class="pl-k">...</span></pre></div>
<p dir="auto">Since they are referenced by their names, it is not necessary to push
<code>OI_ARRAY</code>, <code>OI_WAVELENGTH</code>, and <code>OI_COORREL</code> dependencies if they already
exist in the data-set (according to their name), but it doesn't hurt. It is
however mandatory to push an <code>OI_TARGET</code> instance with all targets and their
identifiers as assumed by the subsequent data-blocks.</p>
<h2 dir="auto"><a id="user-content-merging-data-sets" class="anchor" aria-hidden="true" href="#merging-data-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Merging data-sets</h2>
<p dir="auto">Two OI-FITS data-sets (or more), say <code>A</code> and <code>B</code>, can be consistently merged
together by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="C = merge(A, B)"><pre>C <span class="pl-k">=</span> <span class="pl-c1">merge</span>(A, B)</pre></div>
<p dir="auto">As much as possible, the resulting data-set <code>C</code> will share its contents with
<code>A</code> and/or <code>B</code> but without affecting <code>A</code> and <code>B</code> which are guaranteed to remain
unchanged. As for pushing data-blocks, the target identifiers (the <code>target_id</code>
field) may be rewritten in the result.</p>
<p dir="auto">Merging of data-sets assumes that the two merged data-sets are <em>consistent</em> and
<em>compatible</em>. Here <em>compatible</em> means that targets and dependencies with
matching names must have the same contents. This is checked during the merge
operation.</p>
<p dir="auto">It is also allowed to merge several data-sets and/or merge data-sets
<em>in-place</em>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ds = merge(ds1, ds2, ds3, ...) # merge ds1, ds2, ... in new data-set ds
merge!(ds, ds1, ds2, ds3, ...) # merge ds1, ds2, ... in existing data-set ds"><pre>ds <span class="pl-k">=</span> <span class="pl-c1">merge</span>(ds1, ds2, ds3, <span class="pl-k">...</span>) <span class="pl-c"><span class="pl-c">#</span> merge ds1, ds2, ... in new data-set ds</span>
<span class="pl-c1">merge!</span>(ds, ds1, ds2, ds3, <span class="pl-k">...</span>) <span class="pl-c"><span class="pl-c">#</span> merge ds1, ds2, ... in existing data-set ds</span></pre></div>
<p dir="auto">Note that <code>merge!(ds,...)</code> yields the destination <code>ds</code>.</p>
<p dir="auto">Also note that, after merging, the internal dictionary used for rewriting
target identifiers is left with the mapping built from the targets of the last
merged data-set.</p>
<h2 dir="auto"><a id="user-content-credits" class="anchor" aria-hidden="true" href="#credits"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Credits</h2>
<p dir="auto">The development of this package has received funding from the European
Community's Seventh Framework Programme (FP7/2013-2016) under Grant Agreement
312430 (OPTICON) and is currently supported by the <a href="http://www.jmmc.fr/" rel="nofollow">Jean-Marie Mariotti Center
(JMMC)</a>.</p>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<ol dir="auto">
<li>
<p dir="auto">Pauls, T. A., Young, J. S., Cotton, W. D., &amp; Monnier, J. D. "A data exchange
standard for optical (visible/IR) interferometry." Publications of the
Astronomical Society of the Pacific, vol. 117, no 837, p. 1255 (2005).
<a href="http://arxiv.org/pdf/astro-ph/0508185" rel="nofollow">[pdf]</a></p>
</li>
<li>
<p dir="auto">Duvert, G., Young, J., &amp; Hummel, C. "OIFITS 2: the 2nd version of the Data
Exchange Standard for Optical (Visible/IR) Interferometry." arXiv preprint
<a href="http://arxiv.org/abs/1510.04556v2" rel="nofollow">[arXiv:1510.04556v2.04556]</a>.</p>
</li>
</ol>
</article></div>