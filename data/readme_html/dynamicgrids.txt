<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p><a target="_blank" rel="noopener noreferrer" href="https://repository-images.githubusercontent.com/136250713/956b0c00-5cc7-11eb-9814-eed48441d013"><img src="https://repository-images.githubusercontent.com/136250713/956b0c00-5cc7-11eb-9814-eed48441d013" alt="DynamicGrids" style="max-width:100%;"></a></p>
<p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a>
<a href="https://cesaraustralia.github.io/DynamicGrids.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a>
<a href="https://travis-ci.com/cesaraustralia/DynamicGrids.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f4cc5a5d29fb8832bdd9762daa992115f97d23e78b8432d9822525864d682eca/68747470733a2f2f7472617669732d63692e636f6d2f63657361726175737472616c69612f44796e616d696347726964732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/cesaraustralia/DynamicGrids.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="http://codecov.io/github/cesaraustralia/DynamicGrids.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/77883acddb917cf4a327337dcbfa89e621f3abb4715fc8f70a4eda03de59b5d1/687474703a2f2f636f6465636f762e696f2f6769746875622f63657361726175737472616c69612f44796e616d696347726964732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/cesaraustralia/DynamicGrids.jl/coverage.svg?branch=master" style="max-width:100%;"></a>
<a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://camo.githubusercontent.com/e349577932398a6ba8f7510d8148fb8ad415850b7ad01697c4b57da4cd508bf3/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f417175612e6a6c2d2546302539462538432541322d617175612e737667" alt="Aqua.jl Quality Assurance" data-canonical-src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" style="max-width:100%;"></a></p>
<p>DynamicGrids is a generalised framework for building high-performance grid-based
spatial simulations, including cellular automata, but also allowing a wider
range of behaviours like random jumps and interactions between multiple grids.
It is extended by <a href="https://github.com/cesaraustralia/Dispersal.jl">Dispersal.jl</a>
for modelling organism dispersal processes.</p>
<p><a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> provides a simple live
interface, while <a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a>
also has live control over model parameters while the simulation runs: real-time visual feedback for
manual parametrisation and model exploration.</p>
<p>DynamicGrids can run rules on single CPUs, threaded CPUs, and on CUDA GPUs.
Simulation run-time is usually measured in fractions of a second.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/dispersal_quarantine.gif"><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/dispersal_quarantine.gif" alt="Dispersal quarantine" style="max-width:100%;"></a></p>
<p><em>A dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the
GtkOuput from <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk</a>.
Note that this is indicative of the real-time frame-rate on a laptop.</em></p>
<p>A DynamicGrids.jl simulation is run with a script like this one
running the included game of life model <code>Life()</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using DynamicGrids, Crayons

init = rand(Bool, 150, 200)
output = REPLOutput(init; tspan=1:200, fps=30, color=Crayon(foreground=:red, background=:black, bold=true))
sim!(output, Life())

# Or define it from scratch (yes this is actually the whole implementation!)
const sum_states = (false, false, true, false, false, false, false, false, false), 
                   (false, false, true, true,  false, false, false, false, false)
life = Neighbors(Moore(1)) do hood, state
    sum_states[state + 1][sum(hood) + 1]
end
sim!(output, life)
"><pre><span class="pl-k">using</span> DynamicGrids, Crayons

init <span class="pl-k">=</span> <span class="pl-c1">rand</span>(Bool, <span class="pl-c1">150</span>, <span class="pl-c1">200</span>)
output <span class="pl-k">=</span> <span class="pl-c1">REPLOutput</span>(init; tspan<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">200</span>, fps<span class="pl-k">=</span><span class="pl-c1">30</span>, color<span class="pl-k">=</span><span class="pl-c1">Crayon</span>(foreground<span class="pl-k">=</span><span class="pl-c1">:red</span>, background<span class="pl-k">=</span><span class="pl-c1">:black</span>, bold<span class="pl-k">=</span><span class="pl-c1">true</span>))
<span class="pl-c1">sim!</span>(output, <span class="pl-c1">Life</span>())

<span class="pl-c"><span class="pl-c">#</span> Or define it from scratch (yes this is actually the whole implementation!)</span>
<span class="pl-k">const</span> sum_states <span class="pl-k">=</span> (<span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">true</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>), 
                   (<span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">true</span>, <span class="pl-c1">true</span>,  <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>, <span class="pl-c1">false</span>)
life <span class="pl-k">=</span> <span class="pl-c1">Neighbors</span>(<span class="pl-c1">Moore</span>(<span class="pl-c1">1</span>)) <span class="pl-k">do</span> hood, state
    sum_states[state <span class="pl-k">+</span> <span class="pl-c1">1</span>][<span class="pl-c1">sum</span>(hood) <span class="pl-k">+</span> <span class="pl-c1">1</span>]
<span class="pl-k">end</span>
<span class="pl-c1">sim!</span>(output, life)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/media/life.gif?raw=true"><img src="https://github.com/cesaraustralia/DynamicGrids.jl/raw/media/life.gif?raw=true" alt="REPL life" style="max-width:100%;"></a></p>
<p><em>A game of life simulation being displayed directly in a terminal.</em></p>
<h1><a id="user-content-concepts" class="anchor" aria-hidden="true" href="#concepts"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Concepts</h1>
<p>The framework is highly customisable, but there are some central ideas that define
how a simulation works: <em>grids</em>, <em>rules</em>, and <em>outputs</em>.</p>
<h2><a id="user-content-grids" class="anchor" aria-hidden="true" href="#grids"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Grids</h2>
<p>Simulations run over one or many grids, derived from <code>init</code> of a single
<code>AbstractArray</code> or a <code>NamedTuple</code> of multiple <code>AbstractArray</code>. Grids (<code>GridData</code>
types) are, however not a single array but both source and destination arrays,
to maintain independence between cell reads and writes where required. These may
be padded or otherwise altered for specific performance optimisations. However,
broadcasted <code>getindex</code> operations are guaranteed to work on them as if the grid
is a regular array. This may be useful running simulations manually with
<code>step!</code>.</p>
<p>Usually grids contain values of <code>Number</code>, but other types are possible, such as
<code>SArray</code>, <code>FieldVector</code> or other custom structs. Grids are updated by <code>Rule</code>s
that are run for every cell, at every timestep.</p>
<p>The <code>init</code> grid/s contain whatever initialisation data is required to start
a simulation: the array type, size and element type, as well as providing the
initial conditions:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="init = rand(Float32, 100, 100)
"><pre lang="juli"><code>init = rand(Float32, 100, 100)
</code></pre></div>
<p>An <code>init</code> grid can be attached to an <code>Output</code>:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="output = ArrayOutput(init; tspan=1:100)
"><pre><code>output = ArrayOutput(init; tspan=1:100)
</code></pre></div>
<p>or passed in to <code>sim!</code>, where it will take preference over the <code>init</code>
attached to the <code>Output</code>, but must be the same type and size:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="sim!(output, ruleset; init=init)
"><pre><code>sim!(output, ruleset; init=init)
</code></pre></div>
<p>For multiple grids, <code>init</code> is a <code>NamedTuple</code> of equal-sized arrays
matching the names used in each <code>Ruleset</code> :</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="init = (predator=rand(100, 100), prey=(rand(100, 100))
"><pre>init <span class="pl-k">=</span> (predator<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>), prey<span class="pl-k">=</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>))</pre></div>
<p>Handling and passing of the correct grids to a <code>Rule</code> is automated by
DynamicGrids.jl, as a no-cost abstraction. <code>Rule</code>s specify which grids they
require in what order using the first two (<code>R</code> and <code>W</code>) type parameters.</p>
<p>Dimensional or spatial <code>init</code> grids from
<a href="https://github.com/rafaqz/DimensionalData.jl">DimensionalData.jl</a> or
<a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a> will propagate through the
model to return output with explicit dimensions. This will plot correctly as a
map using <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>, to which shape
files and observation points can be easily added.</p>
<h3><a id="user-content-non-number-grids" class="anchor" aria-hidden="true" href="#non-number-grids"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Non-Number Grids</h3>
<p>Grids containing custom and non-<code>Number</code> types are possible, with some caveats.
They must define <code>Base.zero</code> for their element type, and should be a bitstype for performance.
Tuple does not define <code>zero</code>. <code>Array</code> is not a bitstype, and does not define <code>zero</code>.
<code>SArray</code> from StaticArrays.jl is both, and can be used as the contents of a grid.
Custom structs that defne <code>zero</code> should also work.</p>
<p>However, for any multi-values grid element type, you will need to define a method of
<code>DynamicGrids.to_rgb</code> that returns an <code>ARGB32</code> for them to work in <code>ImageOutput</code>s, and
<code>isless</code> for the <code>REPLoutput</code> to work. A definition for multiplication by a scalar <code>Real</code>
and addition are required to use <code>Convolution</code> kernels.</p>
<h2><a id="user-content-rules" class="anchor" aria-hidden="true" href="#rules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Rules</h2>
<p>Rules hold the parameters for running a simulation, and are applied in
<code>applyrule</code> method that is called for each of the active cells in the grid.
Rules come in a number of flavours (outlined in the
<a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Rules-1" rel="nofollow">docs</a>), which
allow assumptions to be made about running them that can greatly improve
performance. Rules can be collected in a <code>Ruleset</code>, with some additional
arguments to control the simulation:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="ruleset = Ruleset(Life(2, 3); opt=SparseOpt(), proc=CuGPU())
"><pre><code>ruleset = Ruleset(Life(2, 3); opt=SparseOpt(), proc=CuGPU())
</code></pre></div>
<p>Multiple rules can be combined in a <code>Ruleset</code> or simply passed to <code>sim!</code>. Each rule
will be run for the whole grid, in sequence, using appropriate optimisations depending
on the parent types of each rule:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ruleset = Ruleset(rule1, rule2; timestep=Day(1), opt=SparseOpt(), proc=ThreadedCPU())
"><pre>ruleset <span class="pl-k">=</span> <span class="pl-c1">Ruleset</span>(rule1, rule2; timestep<span class="pl-k">=</span><span class="pl-c1">Day</span>(<span class="pl-c1">1</span>), opt<span class="pl-k">=</span><span class="pl-c1">SparseOpt</span>(), proc<span class="pl-k">=</span><span class="pl-c1">ThreadedCPU</span>())</pre></div>
<h2><a id="user-content-output" class="anchor" aria-hidden="true" href="#output"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Output</h2>
<p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Output-1" rel="nofollow">Outputs</a>
are ways of storing or viewing a simulation. They can be used
interchangeably depending on your needs: <code>ArrayOutput</code> is a simple storage
structure for high performance-simulations. As with most outputs, it is
initialised with the <code>init</code> array, but in this case it also requires the number
of simulation frames to preallocate before the simulation runs.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="output = ArrayOutput(init; tspan=1:10)
"><pre>output <span class="pl-k">=</span> <span class="pl-c1">ArrayOutput</span>(init; tspan<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>)</pre></div>
<p>The <code>REPLOutput</code> shown above is a <code>GraphicOutput</code> that can be useful for checking a
simulation when working in a terminal or over ssh:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="output = REPLOutput(init; tspan=1:100)
"><pre>output <span class="pl-k">=</span> <span class="pl-c1">REPLOutput</span>(init; tspan<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>)</pre></div>
<p><code>ImageOutput</code> is the most complex class of outputs, allowing full color visual
simulations using ColorSchemes.jl. It can also display multiple grids using color
composites or layouts, as shown above in the quarantine simulation.</p>
<p><a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a>
provides simulation interfaces for use in Juno, Jupyter, web pages or electron
apps, with live interactive control over parameters, using
<a href="https://github.com/rafaqz/ModelParameters.jl">ModelParameters.jl</a>.
<a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> is a
simple graphical output for Gtk. These packages are kept separate to avoid
dependencies when being used in non-graphical simulations.</p>
<p>Outputs are also easy to write, and high performance applications may benefit
from writing a custom output to reduce memory use, or using <code>TransformedOuput</code>.
Performance of DynamicGrids.jl is dominated by cache interactions, so reducing
memory use has positive effects.</p>
<h2><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example</h2>
<p>This example implements the classic stochastic forest fire model in a few
different ways, and benchmarks them.</p>
<p>First we will define a Forest Fire algorithm that sets the current cell to
burning, if a neighbor is burning. Dead cells can come back to life, and living
cells can spontaneously catch fire:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using DynamicGrids, ColorSchemes, Colors, BenchmarkTools

const DEAD, ALIVE, BURNING = 1, 2, 3

neighbors_rule = let prob_combustion=0.0001, prob_regrowth=0.01
    Neighbors(Moore(1)) do neighborhood, cell
        if cell == ALIVE
            if BURNING in neighborhood
                BURNING
            else
                rand() &lt;= prob_combustion ? BURNING : ALIVE
            end
        elseif cell == BURNING
            DEAD
        else
            rand() &lt;= prob_regrowth ? ALIVE : DEAD
        end
    end
end

# Set up the init array and output (using a Gtk window)
init = fill(ALIVE, 400, 400)
output = GifOutput(init; 
    filename=&quot;forestfire.gif&quot;, tspan=1:200, fps=25, 
    minval=DEAD, maxval=BURNING, 
    imagegen=Image(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))
)

# Run the simulation, which will save a gif when it completes
sim!(output, neighbors_rule)
"><pre><span class="pl-k">using</span> DynamicGrids, ColorSchemes, Colors, BenchmarkTools

<span class="pl-k">const</span> DEAD, ALIVE, BURNING <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>

neighbors_rule <span class="pl-k">=</span> <span class="pl-k">let</span> prob_combustion<span class="pl-k">=</span><span class="pl-c1">0.0001</span>, prob_regrowth<span class="pl-k">=</span><span class="pl-c1">0.01</span>
    <span class="pl-c1">Neighbors</span>(<span class="pl-c1">Moore</span>(<span class="pl-c1">1</span>)) <span class="pl-k">do</span> neighborhood, cell
        <span class="pl-k">if</span> cell <span class="pl-k">==</span> ALIVE
            <span class="pl-k">if</span> BURNING <span class="pl-k">in</span> neighborhood
                BURNING
            <span class="pl-k">else</span>
                <span class="pl-c1">rand</span>() <span class="pl-k">&lt;=</span> prob_combustion <span class="pl-k">?</span> BURNING <span class="pl-k">:</span> ALIVE
            <span class="pl-k">end</span>
        <span class="pl-k">elseif</span> cell <span class="pl-k">==</span> BURNING
            DEAD
        <span class="pl-k">else</span>
            <span class="pl-c1">rand</span>() <span class="pl-k">&lt;=</span> prob_regrowth <span class="pl-k">?</span> ALIVE <span class="pl-k">:</span> DEAD
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Set up the init array and output (using a Gtk window)</span>
init <span class="pl-k">=</span> <span class="pl-c1">fill</span>(ALIVE, <span class="pl-c1">400</span>, <span class="pl-c1">400</span>)
output <span class="pl-k">=</span> <span class="pl-c1">GifOutput</span>(init; 
    filename<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>forestfire.gif<span class="pl-pds">"</span></span>, tspan<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">200</span>, fps<span class="pl-k">=</span><span class="pl-c1">25</span>, 
    minval<span class="pl-k">=</span>DEAD, maxval<span class="pl-k">=</span>BURNING, 
    imagegen<span class="pl-k">=</span><span class="pl-c1">Image</span>(scheme<span class="pl-k">=</span>ColorSchemes<span class="pl-k">.</span>rainbow, zerocolor<span class="pl-k">=</span><span class="pl-c1">RGB24</span>(<span class="pl-c1">0.0</span>))
)

<span class="pl-c"><span class="pl-c">#</span> Run the simulation, which will save a gif when it completes</span>
<span class="pl-c1">sim!</span>(output, neighbors_rule)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/2534009/72052469-5450c580-3319-11ea-8948-5196d1c6fd33.gif"><img src="https://user-images.githubusercontent.com/2534009/72052469-5450c580-3319-11ea-8948-5196d1c6fd33.gif" alt="forestfire" style="max-width:100%;"></a></p>
<p>Timing the simulation for 200 steps, the performance is quite good. This
particular CPU has six cores, and we get a 5.25x speedup by using all of them,
which indicates good scaling:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="bench_output = ResultOutput(init; tspan=1:200)

julia&gt; @btime sim!($bench_output, $neighbors_rule);
  477.183 ms (903 allocations: 2.57 MiB)

julia&gt; @btime sim!($bench_output, $neighbors_rule; proc=ThreadedCPU());
  91.321 ms (15188 allocations: 4.07 MiB)
"><pre>bench_output <span class="pl-k">=</span> <span class="pl-c1">ResultOutput</span>(init; tspan<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">200</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sim!</span>(<span class="pl-k">$</span>bench_output, <span class="pl-k">$</span>neighbors_rule);
  <span class="pl-c1">477.183</span> ms (<span class="pl-c1">903</span> allocations<span class="pl-k">:</span> <span class="pl-c1">2.57</span> MiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sim!</span>(<span class="pl-k">$</span>bench_output, <span class="pl-k">$</span>neighbors_rule; proc<span class="pl-k">=</span><span class="pl-c1">ThreadedCPU</span>());
  <span class="pl-c1">91.321</span> ms (<span class="pl-c1">15188</span> allocations<span class="pl-k">:</span> <span class="pl-c1">4.07</span> MiB)</pre></div>
<p>We can also <em>invert</em> the algorithm, setting cells in the neighborhood to burning
if the current cell is burning, by using the <code>SetNeighbors</code> rule:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="setneighbors_rule = let prob_combustion=0.0001, prob_regrowth=0.01
    SetNeighbors(Moore(1)) do data, neighborhood, cell, I
        if cell == DEAD
            if rand() &lt;= prob_regrowth
                data[I...] = ALIVE
            end
        elseif cell == BURNING
            for pos in positions(neighborhood, I)
                if data[pos...] == ALIVE
                    data[pos...] = BURNING
                end
            end
            data[I...] = DEAD
        elseif cell == ALIVE
            if rand() &lt;= prob_combustion 
                data[I...] = BURNING
            end
        end
    end
end
"><pre>setneighbors_rule <span class="pl-k">=</span> <span class="pl-k">let</span> prob_combustion<span class="pl-k">=</span><span class="pl-c1">0.0001</span>, prob_regrowth<span class="pl-k">=</span><span class="pl-c1">0.01</span>
    <span class="pl-c1">SetNeighbors</span>(<span class="pl-c1">Moore</span>(<span class="pl-c1">1</span>)) <span class="pl-k">do</span> data, neighborhood, cell, I
        <span class="pl-k">if</span> cell <span class="pl-k">==</span> DEAD
            <span class="pl-k">if</span> <span class="pl-c1">rand</span>() <span class="pl-k">&lt;=</span> prob_regrowth
                data[I<span class="pl-k">...</span>] <span class="pl-k">=</span> ALIVE
            <span class="pl-k">end</span>
        <span class="pl-k">elseif</span> cell <span class="pl-k">==</span> BURNING
            <span class="pl-k">for</span> pos <span class="pl-k">in</span> <span class="pl-c1">positions</span>(neighborhood, I)
                <span class="pl-k">if</span> data[pos<span class="pl-k">...</span>] <span class="pl-k">==</span> ALIVE
                    data[pos<span class="pl-k">...</span>] <span class="pl-k">=</span> BURNING
                <span class="pl-k">end</span>
            <span class="pl-k">end</span>
            data[I<span class="pl-k">...</span>] <span class="pl-k">=</span> DEAD
        <span class="pl-k">elseif</span> cell <span class="pl-k">==</span> ALIVE
            <span class="pl-k">if</span> <span class="pl-c1">rand</span>() <span class="pl-k">&lt;=</span> prob_combustion 
                data[I<span class="pl-k">...</span>] <span class="pl-k">=</span> BURNING
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p><em>Note: we are not using <code>add!</code>, instead we just set the grid value directly.
This usually risks errors if multiple cells set different values. Here they
only ever set a currently living cell to burning in the next timestep. It doesn't
matter if this happens multiple times, the result is the same.</em></p>
<p>And in this case (a fairly sparse simulation), this rule is faster:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; @btime sim!($bench_output, $setneighbors_rule);
  261.969 ms (903 allocations: 2.57 MiB)

julia&gt; @btime sim!($bench_output, $setneighbors_rule; proc=ThreadedCPU());
  65.489 ms (7154 allocations: 3.17 MiB)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sim!</span>(<span class="pl-k">$</span>bench_output, <span class="pl-k">$</span>setneighbors_rule);
  <span class="pl-c1">261.969</span> ms (<span class="pl-c1">903</span> allocations<span class="pl-k">:</span> <span class="pl-c1">2.57</span> MiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sim!</span>(<span class="pl-k">$</span>bench_output, <span class="pl-k">$</span>setneighbors_rule; proc<span class="pl-k">=</span><span class="pl-c1">ThreadedCPU</span>());
  <span class="pl-c1">65.489</span> ms (<span class="pl-c1">7154</span> allocations<span class="pl-k">:</span> <span class="pl-c1">3.17</span> MiB)</pre></div>
<p>But the scaling is not quite as good, at 3.9x for 6 cores. The first
method may be better on a machine with a lot of cores.</p>
<p>Last, we can slightly rewrite these rules for GPU, as <code>rand</code> is not available
within a GPU kernel. Instead we call <code>CUDA.rand!</code> on the entire parent array
of the <code>:rand</code> grid, using a <code>SetGrid</code> rule:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using CUDAKernels, CUDA

randomiser = SetGrid{Tuple{},:rand}() do randgrid
    CUDA.rand!(parent(randgrid))
end
"><pre><span class="pl-k">using</span> CUDAKernels, CUDA

randomiser <span class="pl-k">=</span> <span class="pl-c1">SetGrid</span><span class="pl-c1">{Tuple{},:rand}</span>() <span class="pl-k">do</span> randgrid
    CUDA<span class="pl-k">.</span><span class="pl-c1">rand!</span>(<span class="pl-c1">parent</span>(randgrid))
<span class="pl-k">end</span></pre></div>
<p>Now we define a Neighbors version for GPU, using the <code>:rand</code> grid values
instead of <code>rand()</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="neighbors_gpu = let prob_combustion=0.0001, prob_regrowth=0.01
    Neighbors{Tuple{:ff,:rand},:ff}(Moore(1)) do neighborhood, (cell, rand)
        if cell == ALIVE
            if BURNING in neighborhood
                BURNING
            else
                rand &lt;= prob_combustion ? BURNING : ALIVE
            end
        elseif cell == BURNING
            DEAD
        else
            rand &lt;= prob_regrowth ? ALIVE : DEAD
        end
    end
end
"><pre>neighbors_gpu <span class="pl-k">=</span> <span class="pl-k">let</span> prob_combustion<span class="pl-k">=</span><span class="pl-c1">0.0001</span>, prob_regrowth<span class="pl-k">=</span><span class="pl-c1">0.01</span>
    <span class="pl-c1">Neighbors</span><span class="pl-c1">{Tuple{:ff,:rand},:ff}</span>(<span class="pl-c1">Moore</span>(<span class="pl-c1">1</span>)) <span class="pl-k">do</span> neighborhood, (cell, rand)
        <span class="pl-k">if</span> cell <span class="pl-k">==</span> ALIVE
            <span class="pl-k">if</span> BURNING <span class="pl-k">in</span> neighborhood
                BURNING
            <span class="pl-k">else</span>
                rand <span class="pl-k">&lt;=</span> prob_combustion <span class="pl-k">?</span> BURNING <span class="pl-k">:</span> ALIVE
            <span class="pl-k">end</span>
        <span class="pl-k">elseif</span> cell <span class="pl-k">==</span> BURNING
            DEAD
        <span class="pl-k">else</span>
            rand <span class="pl-k">&lt;=</span> prob_regrowth <span class="pl-k">?</span> ALIVE <span class="pl-k">:</span> DEAD
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p>And a SetNeighbors version for GPU:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="setneighbors_gpu = let prob_combustion=0.0001, prob_regrowth=0.01
    SetNeighbors{Tuple{:ff,:rand},:ff}(Moore(1)) do data, neighborhood, (cell, rand), I
        if cell == DEAD
            if rand &lt;= prob_regrowth
                data[:ff][I...] = ALIVE
            end
        elseif cell == BURNING
            for pos in positions(neighborhood, I)
                if data[:ff][pos...] == ALIVE
                    data[:ff][pos...] = BURNING
                end
            end
            data[:ff][I...] = DEAD
        elseif cell == ALIVE
            if rand &lt;= prob_combustion 
                data[:ff][I...] = BURNING
            end
        end
    end
end
"><pre>setneighbors_gpu <span class="pl-k">=</span> <span class="pl-k">let</span> prob_combustion<span class="pl-k">=</span><span class="pl-c1">0.0001</span>, prob_regrowth<span class="pl-k">=</span><span class="pl-c1">0.01</span>
    <span class="pl-c1">SetNeighbors</span><span class="pl-c1">{Tuple{:ff,:rand},:ff}</span>(<span class="pl-c1">Moore</span>(<span class="pl-c1">1</span>)) <span class="pl-k">do</span> data, neighborhood, (cell, rand), I
        <span class="pl-k">if</span> cell <span class="pl-k">==</span> DEAD
            <span class="pl-k">if</span> rand <span class="pl-k">&lt;=</span> prob_regrowth
                data[<span class="pl-c1">:ff</span>][I<span class="pl-k">...</span>] <span class="pl-k">=</span> ALIVE
            <span class="pl-k">end</span>
        <span class="pl-k">elseif</span> cell <span class="pl-k">==</span> BURNING
            <span class="pl-k">for</span> pos <span class="pl-k">in</span> <span class="pl-c1">positions</span>(neighborhood, I)
                <span class="pl-k">if</span> data[<span class="pl-c1">:ff</span>][pos<span class="pl-k">...</span>] <span class="pl-k">==</span> ALIVE
                    data[<span class="pl-c1">:ff</span>][pos<span class="pl-k">...</span>] <span class="pl-k">=</span> BURNING
                <span class="pl-k">end</span>
            <span class="pl-k">end</span>
            data[<span class="pl-c1">:ff</span>][I<span class="pl-k">...</span>] <span class="pl-k">=</span> DEAD
        <span class="pl-k">elseif</span> cell <span class="pl-k">==</span> ALIVE
            <span class="pl-k">if</span> rand <span class="pl-k">&lt;=</span> prob_combustion 
                data[<span class="pl-c1">:ff</span>][I<span class="pl-k">...</span>] <span class="pl-k">=</span> BURNING
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p>Now we benchmark both version on a GTX 1080. Despite the overhead of reading and
writing two grids, this turns out to be even faster again:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="bench_output_rand = ResultOutput((ff=init, rand=zeros(size(init))); tspan=1:200)

julia&gt; @btime sim!($bench_output_rand, $randomiser, $neighbors_gpu; proc=CuGPU());
  30.621 ms (186284 allocations: 17.19 MiB)

julia&gt; @btime sim!($bench_output_rand, $randomiser, $setneighbors_gpu; proc=CuGPU());
  22.685 ms (147339 allocations: 15.61 MiB)
"><pre>bench_output_rand <span class="pl-k">=</span> <span class="pl-c1">ResultOutput</span>((ff<span class="pl-k">=</span>init, rand<span class="pl-k">=</span><span class="pl-c1">zeros</span>(<span class="pl-c1">size</span>(init))); tspan<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">200</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sim!</span>(<span class="pl-k">$</span>bench_output_rand, <span class="pl-k">$</span>randomiser, <span class="pl-k">$</span>neighbors_gpu; proc<span class="pl-k">=</span><span class="pl-c1">CuGPU</span>());
  <span class="pl-c1">30.621</span> ms (<span class="pl-c1">186284</span> allocations<span class="pl-k">:</span> <span class="pl-c1">17.19</span> MiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sim!</span>(<span class="pl-k">$</span>bench_output_rand, <span class="pl-k">$</span>randomiser, <span class="pl-k">$</span>setneighbors_gpu; proc<span class="pl-k">=</span><span class="pl-c1">CuGPU</span>());
  <span class="pl-c1">22.685</span> ms (<span class="pl-c1">147339</span> allocations<span class="pl-k">:</span> <span class="pl-c1">15.61</span> MiB)</pre></div>
<p>That is, we are running the rule at a rate of <em>1.4 billion times per second</em>.
These timings could be improved (maybe 10-20%) by using grids of <code>Int32</code> or
<code>Int16</code> to use less memory and cache. But we will stop here!</p>
<h2><a id="user-content-alternatives" class="anchor" aria-hidden="true" href="#alternatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternatives</h2>
<p><a href="https://github.com/JuliaDynamics/Agents.jl">Agents.jl</a> can also do
cellular-automata style simulations. The design of Agents.jl is to iterate over
a list of agents, instead of broadcasting over an array of cells. This approach
is well suited to when you need to track the movement and details about
individual agents throughout the simulation.</p>
<p>However, for simple grid models where you don't need to track individuals,
DynamicGrids.jl is orders of magnitude faster than Agents.jl, and usually
requires less code to define a model. For low-density simulations like the
forest fire model above, it can be one or two orders of magnitudes faster, while
for higher activity rules like the game of life on a randomised grid, it is two
to three, even four order of magnitude faster, increasing with grid size. If you
are doing grid-based simulation and you don't need to track individual agents,
DynamicGrids.jl is probably the best tool. For other use cases where you need to
track individuals, try Agents.jl.</p>
</article></div>