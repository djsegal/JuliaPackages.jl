<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-vtkdataio" class="anchor" aria-hidden="true" href="#vtkdataio"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>VTKDataIO</h1>
<h2 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h2>
<p dir="auto">VTKDataIO.jl presents a number of input, output and visualization functionalities for geometric meshes with point and cell scalar and vector data. This module attempts to bridge between VTKDataTypes.jl, Julia's native module for representing VTK data types and the Visualization Toolkit (VTK) hence giving access to many of VTK's capabilities to Julia users.</p>
<h2 dir="auto"><a id="user-content-python-version" class="anchor" aria-hidden="true" href="#python-version"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Python version</h2>
<p dir="auto"><strong>VTKDataIO.jl was only tested with Python 3.8.</strong> Make sure <a href="https://github.com/JuliaPy/PyCall.jl">PyCall</a> is buit to use Python 3.8.</p>
<h2 dir="auto"><a id="user-content-summary-of-capabilities" class="anchor" aria-hidden="true" href="#summary-of-capabilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Summary of capabilities</h2>
<h3 dir="auto"><a id="user-content-input-and-output" class="anchor" aria-hidden="true" href="#input-and-output"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Input and output</h3>
<p dir="auto">You can use VTKDataIO.jl to read/write any of the following file formats into/from the corresponding type in VTKDataTypes.jl: vtk, vtu, vtp, vts, vtr, vti, vtm, pvd, stl, ply. You can do this using <code>read_vtk</code>, <code>write_vtk</code>, <code>read_stl</code>, <code>write_stl</code>, <code>read_ply</code>, and <code>write_ply</code>.</p>
<h3 dir="auto"><a id="user-content-visualization-and-rendered-output" class="anchor" aria-hidden="true" href="#visualization-and-rendered-output"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Visualization and rendered output</h3>
<p dir="auto">You can use VTKDataIO.jl to visualize a scalar or vector field with a 3D heat map and a legend. This includes point-based coloring or cell based coloring, as well as other features such as wireframe and glyph representations. The resulting visualization can be written to ply or x3d formats. You can do this using <code>visualize</code>, <code>write_x3d</code>, and <code>write_ply</code>. <code>visualize_3ds</code> can also be used to visualize 3ds files directly.</p>
<h3 dir="auto"><a id="user-content-interfacing-with-pythons-vtk" class="anchor" aria-hidden="true" href="#interfacing-with-pythons-vtk"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interfacing with Python's VTK</h3>
<p dir="auto">You can use <code>PyVTK</code> to change a Julia native VTK object to a VTK data PyObject that can be used in your own VTK pipeline through PyCall. You can also use <code>_VTKDataTypes</code> to change a VTK data PyObject back to Julia's native VTK types.</p>
<h2 dir="auto"><a id="user-content-test-cases" class="anchor" aria-hidden="true" href="#test-cases"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Test cases</h2>
<p dir="auto">If you run the following code, you should be able to get a cubic mesh with randomly coloured cells.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using VTKDataTypes
using VTKDataIO

x = y = z = [-2, -1, 0, 1, 2];
rect = VTKRectilinearData((x, y, z));
rect.cell_data[&quot;Cell scalar&quot;] = reshape([rand() for i in 1:num_of_cells(rect)], cell_extents(rect));
visualize(rect, color=&quot;Cell scalar&quot;)"><pre class="notranslate"><code>using VTKDataTypes
using VTKDataIO

x = y = z = [-2, -1, 0, 1, 2];
rect = VTKRectilinearData((x, y, z));
rect.cell_data["Cell scalar"] = reshape([rand() for i in 1:num_of_cells(rect)], cell_extents(rect));
visualize(rect, color="Cell scalar")
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/19524993/27942949-d09cb120-62e3-11e7-926a-4931d466388c.png"><img src="https://user-images.githubusercontent.com/19524993/27942949-d09cb120-62e3-11e7-926a-4931d466388c.png" alt="image" style="max-width: 100%;"></a></p>
<p dir="auto">You can also do point-based coloring as so:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="rect.point_data[&quot;Point scalar&quot;] = reshape([rand() for i in 1:num_of_points(rect)], extents(rect));
visualize(rect, color=&quot;Point scalar&quot;)"><pre class="notranslate"><code>rect.point_data["Point scalar"] = reshape([rand() for i in 1:num_of_points(rect)], extents(rect));
visualize(rect, color="Point scalar")
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/19524993/27943028-86c4f0fc-62e4-11e7-899e-fe19fcd326d2.png"><img src="https://user-images.githubusercontent.com/19524993/27943028-86c4f0fc-62e4-11e7-899e-fe19fcd326d2.png" alt="image" style="max-width: 100%;"></a></p>
<p dir="auto">Point based vector data can be represented by arrows using the <code>representation</code> option.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="rect.point_data[&quot;Point vector&quot;] = reshape([2*rand()-1 for i in 1:3*num_of_points(rect)], (3, extents(rect)...));
visualize(rect, color=&quot;Point vector&quot;, representation=:glyph, scale_factor=0.5)"><pre class="notranslate"><code>rect.point_data["Point vector"] = reshape([2*rand()-1 for i in 1:3*num_of_points(rect)], (3, extents(rect)...));
visualize(rect, color="Point vector", representation=:glyph, scale_factor=0.5)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/19524993/27943114-2abdb770-62e5-11e7-8c25-320037604285.png"><img src="https://user-images.githubusercontent.com/19524993/27943114-2abdb770-62e5-11e7-8c25-320037604285.png" alt="image" style="max-width: 100%;"></a></p>
<p dir="auto">Wireframe representation can be used as follows:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="visualize(rect, color=&quot;Point scalar&quot;, representation=:wireframe)"><pre class="notranslate"><code>visualize(rect, color="Point scalar", representation=:wireframe)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/19524993/27991226-8b2b60c8-6478-11e7-8bd9-0d451a212ba2.png"><img src="https://user-images.githubusercontent.com/19524993/27991226-8b2b60c8-6478-11e7-8bd9-0d451a212ba2.png" alt="image" style="max-width: 100%;"></a></p>
<p dir="auto">If you have the RGB colors data directly, you can inform the <code>visualize</code> function to use it using the <code>RGB = true</code> option as so:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="rect.point_data[&quot;RGB colors&quot;] = reshape([round(255*rand()) for i in 1:3*num_of_points(rect)], (3, extents(rect)...));
visualize(rect, color=&quot;RGB colors&quot;, RGB=true)"><pre class="notranslate"><code>rect.point_data["RGB colors"] = reshape([round(255*rand()) for i in 1:3*num_of_points(rect)], (3, extents(rect)...));
visualize(rect, color="RGB colors", RGB=true)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/19524993/27943459-0a56382e-62e8-11e7-993d-95b676338f97.png"><img src="https://user-images.githubusercontent.com/19524993/27943459-0a56382e-62e8-11e7-993d-95b676338f97.png" alt="image" style="max-width: 100%;"></a></p>
</article></div>