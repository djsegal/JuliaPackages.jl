<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-neuralfieldeqjl" class="anchor" aria-hidden="true" href="#neuralfieldeqjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NeuralFieldEq.jl</h1>
<table>
<thead>
<tr>
<th align="center"><strong>Docs</strong></th>
<th align="center"><strong>Build Status</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://tiagoseq.github.io/NFEdocs.jl/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="docs" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a></td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tiagoseq/NeuralFieldEq.jl/actions/workflows/ci.yml/badge.svg"><img src="https://github.com/tiagoseq/NeuralFieldEq.jl/actions/workflows/ci.yml/badge.svg" alt="Build" style="max-width: 100%;"></a> <a href="https://codecov.io/gh/tiagoseq/NeuralFieldEq.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/fbba9244d005bee45bd53d393de9808f42d5f4808ec35a932366e71a983ba61d/68747470733a2f2f636f6465636f762e696f2f67682f746961676f7365712f4e657572616c4669656c6445712e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d556b576a6e436f4c5549" alt="codecov" data-canonical-src="https://codecov.io/gh/tiagoseq/NeuralFieldEq.jl/branch/master/graph/badge.svg?token=UkWjnCoLUI" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table>
<h3 dir="auto"><a id="user-content-publications" class="anchor" aria-hidden="true" href="#publications"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Publications</h3>
<ul dir="auto">
<li><a href="https://link.springer.com/article/10.1007/s10827-022-00816-w" rel="nofollow">Numerical simulations of one- and two-dimensional stochastic neural field equations with delay</a></li>
<li><a href="https://doi.org/10.21105/joss.03974" rel="nofollow"><img src="https://camo.githubusercontent.com/5d915b8ebd4c43bd045677aee1381e359b81b127bfe2193de1787d4eda569812/68747470733a2f2f6a6f73732e7468656f6a2e6f72672f7061706572732f31302e32313130352f6a6f73732e30333937342f7374617475732e737667" alt="DOI" data-canonical-src="https://joss.theoj.org/papers/10.21105/joss.03974/status.svg" style="max-width: 100%;"></a></li>
<li><a href="https://fenix.tecnico.ulisboa.pt/downloadFile/1126295043839328/Tese_finalversion_TiagoSequeira.pdf" rel="nofollow">Master's thesis</a></li>
</ul>
<h2 dir="auto"><a id="user-content-about" class="anchor" aria-hidden="true" href="#about"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>About</h2>
<p dir="auto">The numerical method implemented in <code>NeuralFieldEq.jl</code> was developed within the scope of the thesis <a href="https://fenix.tecnico.ulisboa.pt/cursos/mma/dissertacao/1691203502344856" rel="nofollow">Sequeira 2021</a> under the supervision of professor Pedro M. Lima. The method combined the novel numerical scheme published originally by <a href="https://hal.inria.fr/hal-00872132/document" rel="nofollow">Hutt &amp; Rougier 2013</a> for delayed NFE in the context of the stochastic scenario presented by <a href="https://link.springer.com/content/pdf/10.1186/2190-8567-4-1.pdf" rel="nofollow">Kuehn &amp; Riedler 2014</a> where the convergence of spectral methods was proved in stochastic neural fields with additive white noise and spatial correlation.</p>
<p dir="auto">Hence, this package aims to numerically approximate solutions of Neural Field Equations in one- or two-dimensional spaces, with or without delay and in the deterministic or stochastic scenarios described below.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto"><code>NeuralFieldEq.jl</code> <strong>requires Julia version 1.5 or greater</strong>. You can install Julia <a href="https://julialang.org/downloads/" rel="nofollow">here</a>. Once installation is complete, open a Julia REPL and run the following code to install the package:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(&quot;NeuralFieldEq&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>NeuralFieldEq<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-dependencies" class="anchor" aria-hidden="true" href="#dependencies"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Dependencies</h2>
<p dir="auto">The package will install the following dependencies <code>FFTW.jl</code>, <code>Distributions.jl</code>, <code>ProgressMeter.jl</code> and <code>LinearAlgebra.jl</code>.</p>
<h2 dir="auto"><a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Documentation</h2>
<p dir="auto">Please check the <a href="https://tiagoseq.github.io/NFEdocs.jl" rel="nofollow">documentation</a> to get started with neural field equations and with the solver itself</p>
<h2 dir="auto"><a id="user-content-brief-overview" class="anchor" aria-hidden="true" href="#brief-overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Brief overview</h2>
<p dir="auto">The solver is divided into three steps:</p>
<ul dir="auto">
<li>Introduce the parameters and functions using the structures <code>Input1D</code> or <code>Input2D</code>;</li>
<li>Pre-process the NFE using the function <code>probNFE</code>;</li>
<li>Solve the equation using the function <code>solveNFE</code> at time instants chosen by the user, with or without noise.</li>
</ul>
<p dir="auto">With respect to the structures <code>Input1D</code> and <code>Input2D</code>, they are needed to wrap the inputs needed to define our NFE. They have the following order:</p>
<ul dir="auto">
<li><code>α  :: AbstractFloat</code>: Decay rate</li>
<li><code>v  :: AbstractFloat</code>: Axonal speed</li>
<li><code>V0 :: fV0</code>          : Initial condition (constant or a function)</li>
<li><code>L  :: Number</code>       : Domain's length</li>
<li><code>N  :: Integer</code>      : Number of spatial nodes</li>
<li><code>T  :: AbstractFloat</code>: Time span</li>
<li><code>n  :: Integer</code>      : Number of time nodes</li>
<li><code>I  :: fI</code>           : External input function</li>
<li><code>K  :: fK</code>           : Connectivity function</li>
<li><code>S  :: fS</code>           : Firing rate function</li>
</ul>
<p dir="auto"><strong>Remark 1</strong>: The function <code>I</code>, depending on the domain dimension, has to have <code>x</code>,<code>t</code> or <code>x</code>,<code>y</code>,<code>t</code> as its arguments. Function <code>K</code> has <code>x</code> or <code>x</code>,<code>y</code>. Function <code>S</code> with <code>V</code>.</p>
<p dir="auto">Once we define our input structure, we can now pass as input to function <code>probNFE</code>, where the NFE is prepared to be solved using the function <code>solveNFE</code>.</p>
<p dir="auto"><strong>Remark 2</strong>: Currently, to work with the non-delayed problem, the velocity to insert must satisfy the condition: <code>v&gt;L/(sqrt(2)*Δt)</code> in 2D and <code>v&gt;L/(2*Δt)</code> in 1D, meaning that in practice the user must specify a big velocity (ex.: <code>999999.0</code>)</p>
<p dir="auto">The solver has the following generic structure:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="nfe  = Input1D(α,v,V0,L,N,T,n,I,K,S); # Wrap the inputs in structure Input1D
prob = probNFE(nfe)                   # Pre-process the NFE to be computed

# Solve the deterministic 1D problem
Vdet = solveNFE(prob,[t1,t2,t3]) # solution saved at t1, t2, and t3

# Solve the stochastic 1D problem np times
# ϵ level of additive noise, spatial correlation (0.1 default value)
Vsto  = solveNFE(prob,[t1,t2,t3],ϵ,np,ξ=0.1)
Vsto2 = solveNFE(prob,[t1,t2,t3],ϵ,np,0.15) # solution w/ xi=0.15 spatial corr "><pre>nfe  <span class="pl-k">=</span> <span class="pl-c1">Input1D</span>(α,v,V0,L,N,T,n,I,K,S); <span class="pl-c"><span class="pl-c">#</span> Wrap the inputs in structure Input1D</span>
prob <span class="pl-k">=</span> <span class="pl-c1">probNFE</span>(nfe)                   <span class="pl-c"><span class="pl-c">#</span> Pre-process the NFE to be computed</span>

<span class="pl-c"><span class="pl-c">#</span> Solve the deterministic 1D problem</span>
Vdet <span class="pl-k">=</span> <span class="pl-c1">solveNFE</span>(prob,[t1,t2,t3]) <span class="pl-c"><span class="pl-c">#</span> solution saved at t1, t2, and t3</span>

<span class="pl-c"><span class="pl-c">#</span> Solve the stochastic 1D problem np times</span>
<span class="pl-c"><span class="pl-c">#</span> ϵ level of additive noise, spatial correlation (0.1 default value)</span>
Vsto  <span class="pl-k">=</span> <span class="pl-c1">solveNFE</span>(prob,[t1,t2,t3],ϵ,np,ξ<span class="pl-k">=</span><span class="pl-c1">0.1</span>)
Vsto2 <span class="pl-k">=</span> <span class="pl-c1">solveNFE</span>(prob,[t1,t2,t3],ϵ,np,<span class="pl-c1">0.15</span>) <span class="pl-c"><span class="pl-c">#</span> solution w/ xi=0.15 spatial corr </span></pre></div>
<h2 dir="auto"><a id="user-content-example-neural-field-with-breather-type-instabilities" class="anchor" aria-hidden="true" href="#example-neural-field-with-breather-type-instabilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example: Neural field with breather type instabilities</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using NeuralFieldEq, Plots

# Define functions
I(x,y,t) = (5.0/(32.0*pi))*exp(-(x^2+y^2)/32.0)
function K(x,y)
    A = 20.0/(10.0*pi)
    B = 14.0/(18.0*pi)
    return A*exp(-sqrt(x^2+y^2)) - B*exp(-sqrt(x^2+y^2)/3.0)
end
S(V) = V &lt;=0.005 ? 0.0 : 1.0 # heaviside function H(V-0.005)

# Define parameters
a  = 1.0
V0 = 0.0
L  = 20
N  = 256
T  = 80.0
n  = 1600
tj = 0:0.2:T; # Instants to save the solution

# Wrap inputs and prepare the NFEs to be computed
nfe_v5  = Input2D(a,5.0,V0,L,N,T,n,I,K,S); # Solution with v=5
nfe_v3  = Input2D(a,3.0,V0,L,N,T,n,I,K,S); # Solution with v=3
prob_v5 = probNFE(nfe_v5)
prob_v3 = probNFE(nfe_v3)

# Solve NFEs
V_v5 = solveNFE(prob_v5,tj)
V_v3 = solveNFE(prob_v3,tj)"><pre><span class="pl-k">using</span> NeuralFieldEq, Plots

<span class="pl-c"><span class="pl-c">#</span> Define functions</span>
<span class="pl-en">I</span>(x,y,t) <span class="pl-k">=</span> (<span class="pl-c1">5.0</span><span class="pl-k">/</span>(<span class="pl-c1">32.0</span><span class="pl-k">*</span><span class="pl-c1">pi</span>))<span class="pl-k">*</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span>(x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>y<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">/</span><span class="pl-c1">32.0</span>)
<span class="pl-k">function</span> <span class="pl-en">K</span>(x,y)
    A <span class="pl-k">=</span> <span class="pl-c1">20.0</span><span class="pl-k">/</span>(<span class="pl-c1">10.0</span><span class="pl-k">*</span><span class="pl-c1">pi</span>)
    B <span class="pl-k">=</span> <span class="pl-c1">14.0</span><span class="pl-k">/</span>(<span class="pl-c1">18.0</span><span class="pl-k">*</span><span class="pl-c1">pi</span>)
    <span class="pl-k">return</span> A<span class="pl-k">*</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">sqrt</span>(x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>y<span class="pl-k">^</span><span class="pl-c1">2</span>)) <span class="pl-k">-</span> B<span class="pl-k">*</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">sqrt</span>(x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>y<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">/</span><span class="pl-c1">3.0</span>)
<span class="pl-k">end</span>
<span class="pl-en">S</span>(V) <span class="pl-k">=</span> V <span class="pl-k">&lt;=</span><span class="pl-c1">0.005</span> <span class="pl-k">?</span> <span class="pl-c1">0.0</span> <span class="pl-k">:</span> <span class="pl-c1">1.0</span> <span class="pl-c"><span class="pl-c">#</span> heaviside function H(V-0.005)</span>

<span class="pl-c"><span class="pl-c">#</span> Define parameters</span>
a  <span class="pl-k">=</span> <span class="pl-c1">1.0</span>
V0 <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
L  <span class="pl-k">=</span> <span class="pl-c1">20</span>
N  <span class="pl-k">=</span> <span class="pl-c1">256</span>
T  <span class="pl-k">=</span> <span class="pl-c1">80.0</span>
n  <span class="pl-k">=</span> <span class="pl-c1">1600</span>
tj <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0.2</span><span class="pl-k">:</span>T; <span class="pl-c"><span class="pl-c">#</span> Instants to save the solution</span>

<span class="pl-c"><span class="pl-c">#</span> Wrap inputs and prepare the NFEs to be computed</span>
nfe_v5  <span class="pl-k">=</span> <span class="pl-c1">Input2D</span>(a,<span class="pl-c1">5.0</span>,V0,L,N,T,n,I,K,S); <span class="pl-c"><span class="pl-c">#</span> Solution with v=5</span>
nfe_v3  <span class="pl-k">=</span> <span class="pl-c1">Input2D</span>(a,<span class="pl-c1">3.0</span>,V0,L,N,T,n,I,K,S); <span class="pl-c"><span class="pl-c">#</span> Solution with v=3</span>
prob_v5 <span class="pl-k">=</span> <span class="pl-c1">probNFE</span>(nfe_v5)
prob_v3 <span class="pl-k">=</span> <span class="pl-c1">probNFE</span>(nfe_v3)

<span class="pl-c"><span class="pl-c">#</span> Solve NFEs</span>
V_v5 <span class="pl-k">=</span> <span class="pl-c1">solveNFE</span>(prob_v5,tj)
V_v3 <span class="pl-k">=</span> <span class="pl-c1">solveNFE</span>(prob_v3,tj)</pre></div>
<p dir="auto">Check the  for the animated solutions of these problems and other examples.</p>
<p dir="auto">Check the <a href="https://tiagoseq.github.io/NFEdocs.jl/dev/examples/" rel="nofollow">Example</a> section of the documentation, for the animated solutions to these problems and many other examples.</p>
<h2 dir="auto"><a id="user-content-support-and-contributions" class="anchor" aria-hidden="true" href="#support-and-contributions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Support and contributions</h2>
<p dir="auto">The software in this repository was developed as part of academic research carried out in the context of the master's thesis <a href="https://fenix.tecnico.ulisboa.pt/cursos/mma/dissertacao/1691203502344856" rel="nofollow">Numerical Simulations of One- and Two-dimensional Stochastic Neural Field Equations with Delay</a>. If you would like to help support it, please star the repository, consider to use the solver in your research, give your valuable feedback, and feel free to contribute to the package. Improving the documentation, giving ideas and suggestions, contributing lines of code, etc.</p>
<p dir="auto">Any issues that you find, please, report <a href="https://github.com/tiagoseq/NeuralFieldEq.jl/issues">here</a>.</p>
<h2 dir="auto"><a id="user-content-list-of-features-to-implement" class="anchor" aria-hidden="true" href="#list-of-features-to-implement"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>List of features to implement</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Define a new FFT implementation in this module (as indicated in the readme of <a href="https://github.com/JuliaMath/AbstractFFTs.jl">AbstractFFTs.jl</a>)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Refactor the code in order to handle the 1D and 2D cases generically (so, no longer the need to have 1D and 2D versions of the same function)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Write the non-delayed case <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="178744c341ca3ab94a4459f24ac5994f">$v=\infty$</math-renderer> of the solver</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add the possibility of handling single-precision floats (Float32). Currently it only supports double-precision floats</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add new numerical schemes with higher order of convergence in time (such as the Milstein method)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Add new numerical methods with higher order of convergence in space (in this case the advantage of the speed of FFTs will be lost)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Better solution handling</li>
</ul>
<h3 dir="auto">
<a id="user-content-contributors" class="anchor" aria-hidden="true" href="#contributors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contributors</h3>
<ul dir="auto">
<li><a href="https://github.com/tiagoseq">Tiago Sequeira</a></li>
</ul>
</article></div>