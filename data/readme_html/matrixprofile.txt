<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-matrixprofile" class="anchor" aria-hidden="true" href="#matrixprofile"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MatrixProfile</h1>
<p><a href="https://github.com/baggepinnen/MatrixProfile.jl/actions"><img src="https://github.com/baggepinnen/MatrixProfile.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/baggepinnen/MatrixProfile.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/b591de27532fbfeefea596d98823c96b8e61c056615c15d194a681be604a9676/68747470733a2f2f636f6465636f762e696f2f67682f626167676570696e6e656e2f4d617472697850726f66696c652e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/baggepinnen/MatrixProfile.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>Time-series analysis using the matrix profile. The matrix profile <code>P</code> tells you which sub-sequences of a time series <code>T</code> are similar to each other, and which are most dissimilar from all other. This will allow you to find repeated patterns, or <em>motifs</em>, as well as finding outliers and anomalies. Here's a blog post that introduces the matrix profile with lots of nice figures and examples: <a href="https://towardsdatascience.com/introduction-to-matrix-profiles-5568f3375d90" rel="nofollow">https://towardsdatascience.com/introduction-to-matrix-profiles-5568f3375d90</a></p>
<h3><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h3>
<p>This package is registered and can be installed with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Pkg
pkg&quot;add MatrixProfile&quot;
"><pre><span class="pl-k">using</span> Pkg
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">pkg</span>"</span>add MatrixProfile<span class="pl-pds">"</span></span></pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The function <code>matrix_profile</code> returns the matrix profile and profile indices. Here's an example where we insert a repeated pattern in an otherwise random time series.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using MatrixProfile, Plots
t  = range(0, stop=1, step=1/10)
y0 = sin.(2pi .* t)
T  = [randn(20); y0; randn(20); y0; randn(20)]
window_length = length(y0)
profile = matrix_profile(T, window_length)
plot(profile) # Should have minima at 21 and 52
"><pre><span class="pl-k">using</span> MatrixProfile, Plots
t  <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, stop<span class="pl-k">=</span><span class="pl-c1">1</span>, step<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">10</span>)
y0 <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">2</span>pi <span class="pl-k">.*</span> t)
T  <span class="pl-k">=</span> [<span class="pl-c1">randn</span>(<span class="pl-c1">20</span>); y0; <span class="pl-c1">randn</span>(<span class="pl-c1">20</span>); y0; <span class="pl-c1">randn</span>(<span class="pl-c1">20</span>)]
window_length <span class="pl-k">=</span> <span class="pl-c1">length</span>(y0)
profile <span class="pl-k">=</span> <span class="pl-c1">matrix_profile</span>(T, window_length)
<span class="pl-c1">plot</span>(profile) <span class="pl-c"><span class="pl-c">#</span> Should have minima at 21 and 52</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figures/mp.svg"><img src="figures/mp.svg" alt="matrix_profile" style="max-width:100%;"></a></p>
<p>The matrix profile have two sharp minima at the onsets of the repeated pattern. The parameter <code>window_length</code> determines how long pattern to search for.</p>
<h3><a id="user-content-analysis-across-different-time-series" class="anchor" aria-hidden="true" href="#analysis-across-different-time-series"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Analysis across different time-series</h3>
<p>If called like</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="profile = matrix_profile(A, B, m, [dist])
"><pre>profile <span class="pl-k">=</span> <span class="pl-c1">matrix_profile</span>(A, B, m, [dist])</pre></div>
<p>consecutive windows of <code>A</code> will be compared to the entire <code>B</code>. The resulting matrix profile will have a length that depends on <code>B</code>, and indicate with small values when a window of <code>A</code> appeared in <code>B</code>, and with large values when no window in <code>A</code> matched the corresponding window in <code>B</code>. This is not a symmetric function, in general, <code>matrix_profile(A, B) != matrix_profile(B, A)</code>.</p>
<h3><a id="user-content-runtime" class="anchor" aria-hidden="true" href="#runtime"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Runtime</h3>
<p><code>matrix_profile</code> benefits greatly in speed from the use of <code>Float32</code> instead of <code>Float64</code>, but may accumulate some error for very long time series (&gt; 10⁶ perhaps). The computational time scales as the square of the length of <code>T</code>, but is invariant to the window length. Calculating the matrix profile of <code>2^17 ≈ 100k</code> points takes less than minute on a laptop.</p>
<p>If <code>dist</code> is provided, a generic (slow) method is used. If <code>dist</code> is not provided and the inputs <code>A,B</code> are one dimensional vectors of numbers, a fast method is used. The fast method handles long time series, <code>length(A) = length(B) = 100k</code> takes less than 30s.</p>
<p>If the time-series is sampled very fast in relation to the time scale on which interesting things happen, you may try the function <a href="https://juliadsp.github.io/DSP.jl/stable/filters/#DSP.Filters.resample" rel="nofollow"><code>resample(T, fraction::Real)</code></a> to reduce the amount of data to process. Example, <code>resample(T, desired_samplerate/original_samplerate)</code>.</p>
<h2><a id="user-content-motif-grouping" class="anchor" aria-hidden="true" href="#motif-grouping"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Motif grouping</h2>
<p>Using the fake data from the example above, we can do</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="k = 2
mot = motifs(profile, k; r=2, th=5)
plot(profile, mot)
# plot(mot) # Motifs can be plotted on their own for a different view.
"><pre>k <span class="pl-k">=</span> <span class="pl-c1">2</span>
mot <span class="pl-k">=</span> <span class="pl-c1">motifs</span>(profile, k; r<span class="pl-k">=</span><span class="pl-c1">2</span>, th<span class="pl-k">=</span><span class="pl-c1">5</span>)
<span class="pl-c1">plot</span>(profile, mot)
<span class="pl-c"><span class="pl-c">#</span> plot(mot) # Motifs can be plotted on their own for a different view.</span></pre></div>
<ul>
<li><code>k</code> is the number of motifs to extract</li>
<li><code>r</code> controls how similar two windows must be to belong to the same motif. A higher value leads to more windows being grouped together.</li>
<li><code>th</code> is a threshold on how nearby in time two motifs are allowed to be.
<a target="_blank" rel="noopener noreferrer" href="figures/motifs.svg"><img src="figures/motifs.svg" alt="motif_plot" style="max-width:100%;"></a></li>
</ul>
<p>Also see the function <code>anomalies(profile)</code> to find anomalies (or outliers) in the data, sometimes called <em>discords</em>.</p>
<h2><a id="user-content-arbitrary-metrics-and-input-types" class="anchor" aria-hidden="true" href="#arbitrary-metrics-and-input-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Arbitrary metrics and input types</h2>
<p>The matrix profile can be computed for any sequence of things that has a "time axis" and a notion of distance. The examples so far have dealt with one-dimensional arrays of real numbers with the Euclidean metric, for which the matrix profile is particularly efficient to compute. We do not have to limit ourselves to this setting, though, and <code>matrix_profile</code> accepts any array-like object and any distance function on the form <code>dist(x,y)</code>. The interface looks like this</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="profile = matrix_profile(T, m, dist)
"><pre>profile <span class="pl-k">=</span> <span class="pl-c1">matrix_profile</span>(T, m, dist)</pre></div>
<p>If <code>T</code> is a high-dimensional array, time is considered to be the last axis. <code>T</code> can also be a vector of any arbitrary julia objects for which the function <code>dist(x,y)</code> is defined. Note that if <code>T</code> has a long time dimensions, the matrix profile will be expensive to compute, 𝒪(n²log(n)). This method does not make use of the STOMP algorithm, since this is limited to one-dimensional data under the Euclidean metric.</p>
<h2><a id="user-content-mp-distance" class="anchor" aria-hidden="true" href="#mp-distance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MP distance</h2>
<p>See <code>mpdist(A,B,m)</code>.</p>
<h2><a id="user-content-segmentation--change-point-detection" class="anchor" aria-hidden="true" href="#segmentation--change-point-detection"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Segmentation / change-point detection</h2>
<p>The most likely segmentation of a time series into two is calculated using <code>segment(p::Profile)</code>. A more detailed analysis can be performed using <code>sp = segment_profile(p::Profile)</code> which returns a vector of the same length as <code>p</code>, where a low value at index <code>i</code> indicates that few nearest-neighbor arcs pass over index <code>i</code>, <code>sp</code> thus form sort-of a "segmentation profile".</p>
<h2><a id="user-content-time-series-snippets" class="anchor" aria-hidden="true" href="#time-series-snippets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Time series snippets</h2>
<p>To summarize a time series in the form of a small number of snippets, we have the function <code>snippets</code>.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="snips = snippets(T, 3, 100)
plot(snips)
"><pre>snips <span class="pl-k">=</span> <span class="pl-c1">snippets</span>(T, <span class="pl-c1">3</span>, <span class="pl-c1">100</span>)
<span class="pl-c1">plot</span>(snips)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figures/snippets.svg"><img src="figures/snippets.svg" alt="snippets" style="max-width:100%;"></a></p>
<p>The arguments to <code>snippets</code> are</p>
<ul>
<li>The time series</li>
<li>The desired number of snippets</li>
<li>The length of each snippet</li>
<li>Optional <code>m</code>: the length of a small subsequence to be used internally, defaults to 10% of the snippet length.</li>
</ul>
<p>This function can take a while to run for long time-series, for <code>length(T) = 15k</code>, it takes less than a minute on a laptop. The time depends strongly on the internal window length parameter.</p>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>References</h2>
<ul>
<li>The STOMP algorithm used in <code>matrix_profile</code> is detailed in the paper <a href="https://www.cs.ucr.edu/~eamonn/STOMP_GPU_final_submission_camera_ready.pdf" rel="nofollow">Matrix profile II</a>.</li>
<li>The algorithm used in <code>segment</code> and <code>segment_profile</code> comes from <a href="https://www.cs.ucr.edu/~eamonn/Segmentation_ICDM.pdf" rel="nofollow">Matrix Profile VIII</a></li>
<li>The MP distance is described in <a href="https://www.cs.ucr.edu/~eamonn/MPdist_Expanded.pdf" rel="nofollow">Matrix profile XII</a></li>
<li>The algorithm for extraction of time-series snippets comes from <a href="https://www.cs.ucr.edu/~eamonn/Time_Series_Snippets_10pages.pdf" rel="nofollow">Matrix profile XIII</a></li>
</ul>
</article></div>