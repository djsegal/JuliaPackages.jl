<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-localfiltersjl" class="anchor" aria-hidden="true" href="#localfiltersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LocalFilters.jl</h1>
<p dir="auto"><a href="https://emmt.github.io/LocalFilters.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Doc. Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://emmt.github.io/LocalFilters.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Doc. Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="./LICENSE.md"><img src="https://camo.githubusercontent.com/bbf49a2eb96e6f718803f2493bd7aa3baae61abb09b7f8fc185a94e08c504dc6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d627269676874677265656e2e7376673f7374796c653d666c6174" alt="License" data-canonical-src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" style="max-width: 100%;"></a>
<a href="https://github.com/emmt/LocalFilters.jl/actions/workflows/CI.yml?query=branch%3Amaster"><img src="https://github.com/emmt/LocalFilters.jl/actions/workflows/CI.yml/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/emmt/LocalFilters-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/ad53730062b3d05fcc104284b2a9b31f8efeb958b6ffa94858de48c194199a68/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f656d6d742f4c6f63616c46696c746572732e6a6c3f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/emmt/LocalFilters.jl?branch=master" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/emmt/LocalFilters.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/a9b855b586aaf0eb73a0ad776c46375d950a7115a3376fa68317cb94b082eba2/687474703a2f2f636f6465636f762e696f2f6769746875622f656d6d742f4c6f63616c46696c746572732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="Coverage" data-canonical-src="http://codecov.io/github/emmt/LocalFilters.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="http://julialang.org/" rel="nofollow">Julia</a> package <code>LocalFilters</code> implements
multi-dimensional local filters such as discrete convolution, local mean,
mathematical morphology, etc., and provides support to build custom local
filters.</p>
<p dir="auto">This page summarizes the principles and the features of <code>LocalFilters</code>, the
<a href="doc-dev-url">Reference Manual</a> provides more exhaustive documentation. This
document is structured as follows:</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="#available-filters">Available filters</a> lists ready to use filters.</p>
</li>
<li>
<p dir="auto"><a href="#neighborhoods">Neighborhoods</a> describes the concept of <em>neighborhoods</em>,
also known as <em>sliding windows</em> in image processing or <em>structuring element</em>
in mathematical morphology.</p>
</li>
<li>
<p dir="auto"><a href="#build-your-own-filters">Build your own filters</a> explains how to implement
custom local filters.</p>
</li>
<li>
<p dir="auto"><a href="#installation">Installation</a> gives instructions to install the package.</p>
</li>
</ul>
<p dir="auto">Packages with overlapping functionalities:</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://github.com/JuliaImages/ImageFiltering.jl">ImageFiltering</a> for local
filters on multidimensional arrays (not just <em>images</em>), also implement
various boundary conditions;</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/JuliaImages/ImageMorphology.jl">ImageMorphology</a> for fast
morphological operations with separable structuring elements;</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-available-filters" class="anchor" aria-hidden="true" href="#available-filters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Available filters</h2>
<p dir="auto"><code>LocalFilters</code> provides a number of linear and non-linear filters. All methods
have an <em>in-place</em> counterpart which can be called to avoid allocations.</p>
<h3 dir="auto"><a id="user-content-linear-filters" class="anchor" aria-hidden="true" href="#linear-filters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Linear filters</h3>
<p dir="auto"><code>LocalFilters</code> provides the following linear filters:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>localmean(A,B=3)</code> performs a local averaging of <code>A</code> in a neighborhood defined
by <code>B</code>.</p>
</li>
<li>
<p dir="auto"><code>correlate(A,B)</code> performs a discrete correlation of <code>A</code> by the kernel <code>B</code>.
This is the most general linear filter.</p>
</li>
<li>
<p dir="auto"><code>convolve(A,B)</code> performs a discrete convolution of <code>A</code> by the kernel <code>B</code>.
This is the same as a discrete correlation of <code>A</code> by the symmetrical of <code>B</code>.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-mathematical-morphology" class="anchor" aria-hidden="true" href="#mathematical-morphology"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Mathematical morphology</h3>
<p dir="auto"><code>LocalFilters</code> implements the following <a href="https://en.wikipedia.org/wiki/Mathematical_morphology" rel="nofollow">mathematical
morphology</a> operations:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>erode(A,B=3)</code> performs an erosion (local minimum) of <code>A</code> by the structuring
element <code>B</code>;</p>
</li>
<li>
<p dir="auto"><code>dilate(A,B=3)</code> performs a dilation (local maximum) of <code>A</code> by the structuring
element <code>B</code>;</p>
</li>
<li>
<p dir="auto"><code>localextrema(A,B=3)</code> yields the erosion and the dilation of <code>A</code> by the
structuring element <code>B</code>;</p>
</li>
<li>
<p dir="auto"><code>opening(A,B=3)</code> performs an erosion followed by a dilation of <code>A</code> by the
structuring element <code>B</code>;</p>
</li>
<li>
<p dir="auto"><code>closing(A,B=3)</code> performs a dilation followed by an erosion of <code>A</code> by the
structuring element <code>B</code>;</p>
</li>
<li>
<p dir="auto"><code>top_hat(A,B=3[,S])</code> performs a summit detection of <code>A</code> by the structuring
element <code>B</code> (argument <code>S</code> may be optionally supplied to pre-smooth <code>A</code> by
<code>S</code>);</p>
</li>
<li>
<p dir="auto"><code>bottom_hat(A,B=3[,S])</code> performs a valley detection of <code>A</code> by the structuring
element <code>B</code> (argument <code>S</code> may be optionally supplied to pre-smooth <code>A</code> by
<code>S</code>).</p>
</li>
</ul>
<p dir="auto">In mathematical morphology, the structuring element <code>B</code> defines the local
neighborhood of each index in the source array. It can be a sliding
hyper-rectangular Cartesian window or an array of booleans to define a more
complex neighborhood shape. If <code>B</code> is a single odd integer (as it is by
default), the structuring element is assumed to be a sliding window of size <code>B</code>
along every dimension of <code>A</code>.</p>
<h3 dir="auto"><a id="user-content-other-non-linear-filters" class="anchor" aria-hidden="true" href="#other-non-linear-filters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Other non-linear filters</h3>
<p dir="auto"><code>LocalFilters</code> provides an instance of the <a href="https://en.wikipedia.org/wiki/Bilateral_filter" rel="nofollow">bilateral
filter</a>:</p>
<ul dir="auto">
<li><code>bilateralfilter(A,F,G,B)</code> performs a bilateral filtering of array <code>A</code> with
<code>F</code> the range kernel for smoothing differences in values, <code>G</code> the spatial
kernel for smoothing differences in coordinates, and <code>B</code> the neighborhood.
Alternatively one can specify the range and spatial parameters
<code>bilateralfilter(A,σr,σs,B=2*round(Int,3σs)+1)</code> for using Gaussian kernels
with standard deviations <code>σr</code> and <code>σs</code>.</li>
</ul>
<h2 dir="auto"><a id="user-content-build-your-own-filters" class="anchor" aria-hidden="true" href="#build-your-own-filters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Build your own filters</h2>
<p dir="auto">In <code>LocalFilters</code>, a local filtering operation, say <code>dst = filter(A, B)</code> with
<code>A</code> the source of the operation and <code>B</code> the neighborhood or the kernel
associated with the filter, is implemented by the following pseudo-code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for i ∈ indices(dst)
    v = initial
    for j ∈ indices(A) ∩ (indices(B) + i)
        v = update(v, A[j], B[j-i])
    end
    dst[i] = final(v)
end"><pre><span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">indices</span>(dst)
    v <span class="pl-k">=</span> initial
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">indices</span>(A) <span class="pl-k">∩</span> (<span class="pl-c1">indices</span>(B) <span class="pl-k">+</span> i)
        v <span class="pl-k">=</span> <span class="pl-c1">update</span>(v, A[j], B[j<span class="pl-k">-</span>i])
    <span class="pl-k">end</span>
    dst[i] <span class="pl-k">=</span> <span class="pl-c1">final</span>(v)
<span class="pl-k">end</span></pre></div>
<p dir="auto">where <code>indices(A)</code> denotes the set of indices of <code>A</code> while <code>indices(B) + i</code>
denotes the set of indices <code>j</code> such that <code>j - i ∈ indices(B)</code> with <code>indices(B)</code>
the set of indices of <code>B</code>. In other words, <code>j ∈ indices(A) ∩ (indices(B) + i)</code>
means all indices <code>j</code> such that <code>j ∈ indices(A)</code> and <code>j - i ∈ indices(B)</code>,
hence <code>A[j]</code> and <code>B[j-i]</code> are in-bounds. In <code>LocalFilters</code>, indices <code>i</code> and <code>j</code>
are multi-dimensional Cartesian indices, thus <code>indices(A)</code> is the analogous of
<code>CartesianIndices(A)</code> in Julia.</p>
<p dir="auto">The behavior of the filter is completely determined by the neighborhood or
kernel <code>B</code>, by the type of the state variable <code>v</code>, its <code>initial</code> value for each
entry of the destination, and by the methods <code>update</code> and <code>final</code>.</p>
<p dir="auto">Such a filter can be applied by calling <code>localfilter!</code> as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="localfilter!(dst, A, B, initial, update, final = identity) -&gt; dst"><pre><span class="pl-c1">localfilter!</span>(dst, A, B, initial, update, final <span class="pl-k">=</span> identity) <span class="pl-k">-&gt;</span> dst</pre></div>
<p dir="auto">As shown by the following examples, this simple scheme allows the
implementation of a variety of linear and non-linear local filters:</p>
<ul dir="auto">
<li>
<p dir="auto">Implementing a <strong>local average</strong> of <code>A</code> in a neighborhood defined by an array
<code>B</code> of booleans is done with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="localfilter!(dst, A, B,
             (zero(a), 0), # initial, state = (sum_of_values, count_of_values)
             (v,a,b) -&gt; ifelse(b, (v[1] + a, v[2] + 1), v), # update
             (v) -&gt; v[1]/v[2]) # final"><pre><span class="pl-c1">localfilter!</span>(dst, A, B,
             (<span class="pl-c1">zero</span>(a), <span class="pl-c1">0</span>), <span class="pl-c"><span class="pl-c">#</span> initial, state = (sum_of_values, count_of_values)</span>
             (v,a,b) <span class="pl-k">-&gt;</span> <span class="pl-c1">ifelse</span>(b, (v[<span class="pl-c1">1</span>] <span class="pl-k">+</span> a, v[<span class="pl-c1">2</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>), v), <span class="pl-c"><span class="pl-c">#</span> update</span>
             (v) <span class="pl-k">-&gt;</span> v[<span class="pl-c1">1</span>]<span class="pl-k">/</span>v[<span class="pl-c1">2</span>]) <span class="pl-c"><span class="pl-c">#</span> final</span></pre></div>
</li>
<li>
<p dir="auto">Assuming <code>T = eltype(dst)</code> is a suitable element type for the result, a
<strong>discrete convolution</strong> of <code>A</code> by <code>B</code> can be implemented with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="localfilter!(dst, A, B,
             zero(T), # initial
             (v,a,b) -&gt; v + a*b) # update"><pre><span class="pl-c1">localfilter!</span>(dst, A, B,
             <span class="pl-c1">zero</span>(T), <span class="pl-c"><span class="pl-c">#</span> initial</span>
             (v,a,b) <span class="pl-k">-&gt;</span> v <span class="pl-k">+</span> a<span class="pl-k">*</span>b) <span class="pl-c"><span class="pl-c">#</span> update</span></pre></div>
<p dir="auto">There are no needs to specify the <code>final</code> method here, as the default
<code>final=identity</code>, does the job.</p>
</li>
<li>
<p dir="auto">Computing a local maximum (that is, a <strong>dilation</strong> in mathematical morphology
terms) of array <code>A</code> with a kernel <code>B</code> whose entries are booleans can be done
with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="localfilter!(dst, A, B,
             typemin(a), # initial
             (v,a,b) -&gt; ((b &amp; (v &lt; a)) ? a : v)) # update"><pre><span class="pl-c1">localfilter!</span>(dst, A, B,
             <span class="pl-c1">typemin</span>(a), <span class="pl-c"><span class="pl-c">#</span> initial</span>
             (v,a,b) <span class="pl-k">-&gt;</span> ((b <span class="pl-k">&amp;</span> (v <span class="pl-k">&lt;</span> a)) <span class="pl-k">?</span> a <span class="pl-k">:</span> v)) <span class="pl-c"><span class="pl-c">#</span> update</span></pre></div>
<p dir="auto">As in the above example, there are no needs to specify the <code>final</code> method
here. Note the use of a bitwise <code>&amp;</code> instead of a <code>&amp;&amp;</code> in the <code>update</code> method
to avoid branching.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">To install the last official version:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
pkg&quot;add LocalFilters&quot;"><pre><span class="pl-k">using</span> Pkg
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">pkg</span>"</span>add LocalFilters<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">To use the last development version, install with Pkg, the Julia package
manager, as an unregistered Julia package (press the ] key to enter the Pkg
REPL mode):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
pkg&quot;add https://github.com/emmt/LocalFilters.jl&quot;"><pre><span class="pl-k">using</span> Pkg
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">pkg</span>"</span>add https://github.com/emmt/LocalFilters.jl<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">The <code>LocalFilters</code> package is pure Julia code and nothing has to be build.</p>
</article></div>