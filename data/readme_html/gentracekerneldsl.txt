<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-gentracekerneldsljl" class="anchor" aria-hidden="true" href="#gentracekerneldsljl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GenTraceKernelDSL.jl</h1>
<p dir="auto">This package provides a DSL for constructing <em>trace kernels</em>, stochastic
maps between the traces of <a href="https://github.com/probcomp/Gen.jl">Gen</a> generative
functions, for use as (generalized) Metropolis-Hastings or proposal distributions in sequential Monte Carlo.  (Specifically, trace kernels are used to define a a type of sequential Monte Carlo algorithm called an <a href="https://github.com/probcomp/GenSMCP3.jl">SMCP<sup>3</sup></a> algorithm.)</p>
<p dir="auto">This package can be viewed as a refactoring of <a href="https://github.com/probcomp/Gen.jl/blob/a96a77991e0e43f208272e9241c8f2434ffdedbf/docs/src/ref/trace_translators.md">Gen's Trace Translator functionality</a>,
described in <a href="https://www.mct.dev/assets/mct-thesis.pdf" rel="nofollow">Marco Cusumano-Towner's thesis</a> and also in the arXiv preprint
<a href="https://arxiv.org/abs/2007.09871" rel="nofollow">Automating Involutive MCMC using Probabilistic and Differentiable Programming</a>.
Unlike Gen's trace transform DSL, this package does not enforce separation of the "probablistic" and "differentiable" components of a trace translator: users may freely mix sampling with deterministic transformations to describe arbitrary stochastic transformations.</p>
<h2 dir="auto"><a id="user-content-dsl" class="anchor" aria-hidden="true" href="#dsl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DSL</h2>
<p dir="auto">A kernel function is declared using the <code>@kernel</code> macro.
The kernel's body may contain deterministic Julia code, as well as <code>~</code> expressions,
familiar from Gen:</p>
<ul dir="auto">
<li><code>{:x} ~ dist(args)</code> samples from a Gen distribution at address <code>:x</code></li>
<li><code>{:x} ~ gen_fn(args)</code> samples from a Gen generative function at address <code>:x</code>, <strong>and evaluates to the <em>trace</em> of the function, rather than its return value</strong></li>
<li><code>{:x} ~ kernel_fn(args)</code> calls another <code>@kernel</code>-defined function at address <code>:x</code>, <strong>and evaluates to its return value.</strong></li>
</ul>
<p dir="auto">As in Gen, <code>x = {:x} ~ f()</code> can be shortened to <code>x ~ f()</code>, and—for generative function or kernel calls—the <code>{*} ~ f()</code> syntax can be used to splice the choices made by <code>f</code> into the "top level" of the caller's choicemap.</p>
<p dir="auto">Kernels intended for use as MH proposals should accept a current trace as their first argument, and return a Tuple of: (1) a <code>ChoiceMap</code> of proposed values to update in the trace, and (2) a <code>ChoiceMap</code> specifying a reverse move.</p>
<p dir="auto">Kernels inteded for use as SMC proposals should be written in pairs: a forward and backward kernel. The forward (backward) kernel should accept a previous (subsequent) model trace as its first argument, and return a Tuple containing: (1) a <code>ChoiceMap</code> specifying a proposed next (previous) model state, and (2) a <code>ChoiceMap</code> of the backward (forward) kernel that would recover the previous (subsequent) model state.  See <a href="https://github.com/probcomp/GenSMCP3.jl">GenSMCP3</a> for details of how to use kernel DSL proposals within SMC, and for inter-operation between the kernel DSL and <a href="https://github.com/probcomp/GenParticleFilters.jl">Gen's particle filtering library</a>.</p>
<p dir="auto">For example, here is what <a href="https://github.com/probcomp/Gen.jl/blob/master/examples/involutive_mcmc/involution_mh_minimal_example.jl">Gen's example split-merge proposal</a> looks like written in the DSL:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@kernel function split_merge_proposal(trace)
    if trace[:z]
        # Currently two means, switch to one
        m, u  = merge_mean(trace[:m1], trace[:m2])
        return choicemap(:z =&gt; false, :m =&gt; m), choicemap(:u =&gt; u)
    else
        # Currently one mean, switch to two
        u ~ uniform_continuous(0, 1)
        m1, m2 = split_mean(trace[:m], u)
        return choicemap(:z =&gt; true, :m1 =&gt; m1, :m2 =&gt; m2), choicemap()
    end
end"><pre><span class="pl-c1">@kernel</span> <span class="pl-k">function</span> <span class="pl-en">split_merge_proposal</span>(trace)
    <span class="pl-k">if</span> trace[<span class="pl-c1">:z</span>]
        <span class="pl-c"><span class="pl-c">#</span> Currently two means, switch to one</span>
        m, u  <span class="pl-k">=</span> <span class="pl-c1">merge_mean</span>(trace[<span class="pl-c1">:m1</span>], trace[<span class="pl-c1">:m2</span>])
        <span class="pl-k">return</span> <span class="pl-c1">choicemap</span>(<span class="pl-c1">:z</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>, <span class="pl-c1">:m</span> <span class="pl-k">=&gt;</span> m), <span class="pl-c1">choicemap</span>(<span class="pl-c1">:u</span> <span class="pl-k">=&gt;</span> u)
    <span class="pl-k">else</span>
        <span class="pl-c"><span class="pl-c">#</span> Currently one mean, switch to two</span>
        u <span class="pl-k">~</span> <span class="pl-c1">uniform_continuous</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>)
        m1, m2 <span class="pl-k">=</span> <span class="pl-c1">split_mean</span>(trace[<span class="pl-c1">:m</span>], u)
        <span class="pl-k">return</span> <span class="pl-c1">choicemap</span>(<span class="pl-c1">:z</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>, <span class="pl-c1">:m1</span> <span class="pl-k">=&gt;</span> m1, <span class="pl-c1">:m2</span> <span class="pl-k">=&gt;</span> m2), <span class="pl-c1">choicemap</span>()
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Kernels can be passed to <code>Gen.metropolis_hastings(trace, proposal)</code> for use in Metropolis Hastings MCMC, or used with <a href="https://github.com/probcomp/GenSMCP3.jl">GenSMCP3</a> for use in sequential Monte Carlo.</p>

<p dir="auto">See <code>example.jl</code> for a full example.</p>
</article></div>