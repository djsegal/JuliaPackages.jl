<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a href="https://travis-ci.org/sisl/LocalFunctionApproximation.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/5ef2666cadeaa76b8b57709b29f4cb7dc3bd39ce500d98e1aa21c631a2721b13/68747470733a2f2f7472617669732d63692e6f72672f7369736c2f4c6f63616c46756e6374696f6e417070726f78696d6174696f6e2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/sisl/LocalFunctionApproximation.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/sisl/LocalFunctionApproximation.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/b0e8065c21b9dae6de8bbf6e3d386fb411b1b1f0ac1e6fdfeea9490bde93ad70/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f7369736c2f4c6f63616c46756e6374696f6e417070726f78696d6174696f6e2e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/sisl/LocalFunctionApproximation.jl/badge.svg?branch=master" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-localfunctionapproximation" class="anchor" aria-hidden="true" href="#localfunctionapproximation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LocalFunctionApproximation</h1>
<p dir="auto">This package provides local function approximators that interpolates a scalar-valued function across a vector space. It does so based on the values of the function at "nearby" points, based on an appropriate locality metric, and not via any global regression or fitting function. Currently it supports multi-linear and simplex interpolations for multi-dimensional grids, and k-nearest-neighbor
interpolation. Two important dependencies are <a href="https://github.com/sisl/GridInterpolations.jl/blob/master/src/GridInterpolations.jl">GridInterpolations</a>
and <a href="https://github.com/KristofferC/NearestNeighbors.jl">NearestNeighbors</a>.</p>
<h2 dir="auto"><a id="user-content-installation-and-usage" class="anchor" aria-hidden="true" href="#installation-and-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation and Usage</h2>
<p dir="auto">Start Julia and run the following:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Pkg.add(&quot;LocalFunctionApproximation&quot;)
using LocalFunctionApproximation"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>LocalFunctionApproximation<span class="pl-pds">"</span></span>)
<span class="pl-k">using</span> LocalFunctionApproximation</pre></div>
<h2 dir="auto"><a id="user-content-create-function-approximators" class="anchor" aria-hidden="true" href="#create-function-approximators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Create Function Approximators</h2>
<p dir="auto">Create a rectangular grid for interpolation using <code>GridInterpolations</code> and create the function approximator
that uses it:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using GridInterpolations # Make the grid interpolations module available
grid = RectangleGrid([0., 0.5, 1.],[0., 0.5, 1.])      # rectangular grid
grid_values = [8., 1., 6., 3., 5., 7., 4., 9., 2.]     # corresponding values at each grid point
gifa = LocalGIFunctionApproximator(grid, grid_values)  # create the function approximator using the grid and values"><pre><span class="pl-k">using</span> GridInterpolations <span class="pl-c"><span class="pl-c">#</span> Make the grid interpolations module available</span>
grid <span class="pl-k">=</span> <span class="pl-c1">RectangleGrid</span>([<span class="pl-c1">0.</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">1.</span>],[<span class="pl-c1">0.</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">1.</span>])      <span class="pl-c"><span class="pl-c">#</span> rectangular grid</span>
grid_values <span class="pl-k">=</span> [<span class="pl-c1">8.</span>, <span class="pl-c1">1.</span>, <span class="pl-c1">6.</span>, <span class="pl-c1">3.</span>, <span class="pl-c1">5.</span>, <span class="pl-c1">7.</span>, <span class="pl-c1">4.</span>, <span class="pl-c1">9.</span>, <span class="pl-c1">2.</span>]     <span class="pl-c"><span class="pl-c">#</span> corresponding values at each grid point</span>
gifa <span class="pl-k">=</span> <span class="pl-c1">LocalGIFunctionApproximator</span>(grid, grid_values)  <span class="pl-c"><span class="pl-c">#</span> create the function approximator using the grid and values</span></pre></div>
<p dir="auto">Create a nearest neighbor tree using <code>NearestNeighbors</code> and create the corresponding approximator:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using NearestNeighbors, StaticArrays
points = [SVector(0.,0.), SVector(0.,1.), SVector(1.,1.), SVector(1.,0.)]   # the 4 corners of the unit square
nntree = KDTree(points)                                                     # create a KDTree using the points
vals = [1., 1., -1., -1]                                                    # values corresponding to points
k = 2                                                                       # the k parameter for knn approximator
knnfa = LocalNNFunctionApproximator(nntree, points, k)"><pre><span class="pl-k">using</span> NearestNeighbors, StaticArrays
points <span class="pl-k">=</span> [<span class="pl-c1">SVector</span>(<span class="pl-c1">0.</span>,<span class="pl-c1">0.</span>), <span class="pl-c1">SVector</span>(<span class="pl-c1">0.</span>,<span class="pl-c1">1.</span>), <span class="pl-c1">SVector</span>(<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>), <span class="pl-c1">SVector</span>(<span class="pl-c1">1.</span>,<span class="pl-c1">0.</span>)]   <span class="pl-c"><span class="pl-c">#</span> the 4 corners of the unit square</span>
nntree <span class="pl-k">=</span> <span class="pl-c1">KDTree</span>(points)                                                     <span class="pl-c"><span class="pl-c">#</span> create a KDTree using the points</span>
vals <span class="pl-k">=</span> [<span class="pl-c1">1.</span>, <span class="pl-c1">1.</span>, <span class="pl-k">-</span><span class="pl-c1">1.</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>]                                                    <span class="pl-c"><span class="pl-c">#</span> values corresponding to points</span>
k <span class="pl-k">=</span> <span class="pl-c1">2</span>                                                                       <span class="pl-c"><span class="pl-c">#</span> the k parameter for knn approximator</span>
knnfa <span class="pl-k">=</span> <span class="pl-c1">LocalNNFunctionApproximator</span>(nntree, points, k)</pre></div>
<h2 dir="auto"><a id="user-content-compute-values-at-arbitrary-points" class="anchor" aria-hidden="true" href="#compute-values-at-arbitrary-points"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Compute values at arbitrary points</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="point = rand(2)             # random 2D point
compute_value(gifa, point)  # obtain the value by interpolating the function at that point       
compute_value(knnfa, point) # do the same for the kNN approximator"><pre>point <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>)             <span class="pl-c"><span class="pl-c">#</span> random 2D point</span>
<span class="pl-c1">compute_value</span>(gifa, point)  <span class="pl-c"><span class="pl-c">#</span> obtain the value by interpolating the function at that point       </span>
<span class="pl-c1">compute_value</span>(knnfa, point) <span class="pl-c"><span class="pl-c">#</span> do the same for the kNN approximator</span></pre></div>
<p dir="auto">A typical use case for this package is for Local Approximation Value Iteration, as shown <a href="https://github.com/Shushman/LocalApproximationValueIteration.jl">here</a>.</p>
</article></div>