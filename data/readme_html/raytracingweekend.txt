<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-raytracingweekend" class="anchor" aria-hidden="true" href="#raytracingweekend"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>RayTracingWeekend</h1>
<p dir="auto">Adapted from <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html" rel="nofollow">Ray Tracing In One Weekend by Peter Shirley</a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="img/pluto_RayTracingWeekend_final_cell.png"><img src="img/pluto_RayTracingWeekend_final_cell.png" alt="This final cell (bunch of spheres) runs in 3.2s" style="max-width: 100%;"></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="img/pluto_RayTracingWeekend.png"><img src="img/pluto_RayTracingWeekend.png" alt="Example of image generated by this code, and some Julia code using math characters" style="max-width: 100%;"></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="img/scene_random_spheres_1920x1080.png"><img src="img/scene_random_spheres_1920x1080.png" alt="Final image of book 1 - random spheres" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-run" class="anchor" aria-hidden="true" href="#run"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Run</h1>
<p dir="auto">You have 2 options.</p>
<h2 dir="auto"><a id="user-content-pluto_raytracingweekendjl" class="anchor" aria-hidden="true" href="#pluto_raytracingweekendjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>pluto_RayTracingWeekend.jl</h2>
<p dir="auto">This is a Pluto.jl notebook, best suited for learning alongside (e.g. if you're a Julia beginner) or quick interactive experimentation. This self-contained version matches Peter Shirley's first book, "Raytracing in 1 weekend". See below (<code>Adapting C++ --&gt; Julia</code>) for tips on how to start it, and how it differs from the C++ version.</p>
<h2 dir="auto"><a id="user-content-this-module--srcprotoprotojl" class="anchor" aria-hidden="true" href="#this-module--srcprotoprotojl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>This module + src/proto/proto.jl</h2>
<p dir="auto">This is a short script that runs various tests and records historical timings on my Ryzen 3700 PC. It's best suited for benchmarking.</p>
<p dir="auto">To run interactively with vscode:</p>
<ol dir="auto">
<li>F1, <code>Julia: Start REPL</code></li>
<li><code>] activate RayTracingWeekend</code></li>
<li>Open <code>src/proto/proto.jl</code>, press shift-enter to run lines, see plots.</li>
</ol>
<h1 dir="auto"><a id="user-content-implementation-details" class="anchor" aria-hidden="true" href="#implementation-details"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementation details</h1>
<p dir="auto">This Julia code is more complicated than required, because I optimized it for execution speed rather than code simplicity. I also plan to support running on GPU, to see if I can match optimized SIMD C++/CUDA/ROCM performance. Finally, I refrained from implementing high-level optimizations like BVHs and smarter sampling, because I want a fair comparison with the C++ implementation.</p>
<p dir="auto">So:</p>
<ul dir="auto">
<li>We're using parameterized floating-point types (thanks @woclass!), which allows us to switch between Float32 and Float64 calculations, but makes the code somewhat more complex...</li>
<li>We're using Vec3 for both C++'s <code>Vec3</code> and <code>Color</code>.</li>
<li>I tried to minimize memory allocations (allocation on the stack instead of the heap, e.g. using StaticArrays)</li>
<li>I plan to pre-allocate groups of rays into tensors to support higher parallelism (but only after I exhausted less intrusive low-level optimizations, to be fair against the SIMD-optimized C++ implementation that doesn't go to that extent)</li>
</ul>
<p dir="auto">If you're interested in the performance details and the latest optimizations, please:</p>
<ol dir="auto">
<li>participate in this discussion: <a href="https://discourse.julialang.org/t/ray-tracing-in-a-week-end-julia-vs-simd-optimized-c" rel="nofollow">https://discourse.julialang.org/t/ray-tracing-in-a-week-end-julia-vs-simd-optimized-c</a></li>
<li>see the git history and comments in <code>proto.jl</code>, where I make the latest changes, and will occasionally merge them back in the Pluto notebook.</li>
</ol>
<h1 dir="auto"><a id="user-content-competitive-targets-gpsnoopys-ispc-c-and-vulkan-implementations" class="anchor" aria-hidden="true" href="#competitive-targets-gpsnoopys-ispc-c-and-vulkan-implementations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Competitive Targets: GPSnoopy's ISPC C++ and Vulkan implementations</h1>
<p dir="auto"><a href="https://github.com/GPSnoopy/RayTracingInOneWeekend">https://github.com/GPSnoopy/RayTracingInOneWeekend</a></p>
<p dir="auto">All perf tests were run on my Ryzen 3700 (not overclocked) on Ubuntu 20.04.</p>
<h2 dir="auto"><a id="user-content-gpsnoopys-c-implementation-using-gcc" class="anchor" aria-hidden="true" href="#gpsnoopys-c-implementation-using-gcc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GPSnoopy's C++ implementation using GCC</h2>
<ol dir="auto">
<li>I modified the code to run at 1920x1080x1000 instead of 3840x2160x1000.</li>
<li>Compiled with <code>g++ -o book1 -std=c++1z -Wall -Wextra -O3 -ffast-math -march=znver2 main.cpp -lpthread</code>, using <code>gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)</code>.</li>
</ol>
<ul dir="auto">
<li>Notice <code>-ffast-math</code> - I haven't tried that yet in my Julia version.</li>
<li><code>-march=znver2</code> allows gcc to optimize specifically for this Zen2 CPU architecture.</li>
</ul>
<ol start="3" dir="auto">
<li>Even though I have 16 physical threads on this CPU, gcc reports it only used 14 threads. The CPU temperature hovered around 83 degrees Celsius, i.e. warm but not alarming.</li>
<li>I examined the code, and it looks like it's using the same algorithms, i.e. no BVH. I also checked that the threaded model is similar.</li>
<li>I have no idea whether GCC tries to vectorize the code, and by how much.</li>
</ol>
<p dir="auto">Result of <code>time ./book1</code>: <strong>22m59s</strong> (1379s).</p>
<h2 dir="auto"><a id="user-content-gpsnoopys-ispc-implementation" class="anchor" aria-hidden="true" href="#gpsnoopys-ispc-implementation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GPSnoopy's ISPC implementation</h2>
<p dir="auto">IIUC ISPC is a customized version of C specialized for SIMD and GPGPU.</p>
<ol dir="auto">
<li>I modified the code to run at 1920x1080x1000 instead of 3840x2160x1000.</li>
<li>Compiled with the <code>build_linux.sh</code> script, using <code>ispc-v1.16.1-linux</code> (i.e. latest stable compiler version)</li>
<li>All 16 threads seemed in use, the fans were pushed to the max, and the temperature hovered around 91.3 degrees Celsius... I'm not sure it would be a good idea to let it run for long at that temperature. I'd feel safer if I had a liquid-cooled heat sink...</li>
<li>I took a brief look at the ISPC code and I guess their high performance can in part be explained by a more optimized memory layout and of course, a language and compiler focused 100% on SIMD.</li>
</ol>
<p dir="auto">Result of <code>time ./book1</code>: <strong>6m5s</strong>. A very impressive speed-up!</p>
<h2 dir="auto"><a id="user-content-latest-julia-version-see-protojl" class="anchor" aria-hidden="true" href="#latest-julia-version-see-protojl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Latest Julia version (see proto.jl)</h2>
<p dir="auto">Method:</p>
<ol dir="auto">
<li>In proto.jl, uncomment <code>@time render(scene_random_spheres(; elem_type=ELEM_TYPE), t_cam1, 1920, 1000)</code></li>
<li>then run using <code>julia --project=. --threads=16 --math-mode=fast --optimize=3 --cpu-target=znver2 src/proto.jl</code>.</li>
</ol>
<p dir="auto">Notes:</p>
<ul dir="auto">
<li>The following arguments didn't make any noticeable difference (yet?): <code>--math-mode=fast --optimize=3 --cpu-target=znver2</code></li>
<li>I didn't add <code>@fastmath</code> to any lines of code yet.</li>
<li>I didn't try to optimize w/ SIMD/LoopVectorization yet.</li>
<li>I use Float64, compared to the C++ versions that use Float32. (But Float32 in this Julia implementation is currently slower.)</li>
<li>I haven't tried running the Julia profiler yet, there are probably low-hanging fruits left that don't require algorithmic change.</li>
<li>The C++ version uses a 32-bit Mersenne IIUC, might be a bit faster to compute and certainly much less random than the SOTA Xoroshiro128Plus I use in Julia.</li>
</ul>
<p dir="auto">Latest results:</p>
<ul dir="auto">
<li>With 16 threads: <strong>21m22s</strong></li>
<li>with 14 threads: <strong>21m45s</strong> (1306s), i.e. now ~5.6% faster than the equivalent GCC C++ version!</li>
</ul>
<p dir="auto">Detailed timings, starting from my original, super-slow version.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="After some optimization, took ~5.6 hours:
  20171.646846 seconds (94.73 G allocations: 2.496 TiB, 1.06% gc time)
... however the image looked weird... too blurry
After removing all remaining Color, Vec3, replacing them with @SVector[]... took ~3.7 hours:
  13326.770907 seconds (29.82 G allocations: 714.941 GiB, 0.36% gc time)
Using convert(Float32, ...) instead of MyFloat(...):
Don't specify return value of Option{HitRecord} in hit()
Don't initialize unnecessary elements in HitRecord(): 
Took ~4.1 hours:
  14723.339976 seconds (5.45 G allocations: 243.044 GiB, 0.11% gc time) # WORSE, probably because we're writing a lot more to stack...?
Replace MyFloat by Float32:
Lots of other optimizations including @inline lots of stuff: 
   6018.101653 seconds (5.39 G allocations: 241.139 GiB, 0.21% gc time) (1.67 hour)
@woclass's rand(Float32) to avoid Float64s: (expected to provide 2.2% speed up)
@woclass's &quot;Use alias instead of new struct&quot;, i.e. `const HittableList = Vector{Hittable}`
@woclass's Vec3{T} with T=Float64: (7.8% speed-up!): 
   5268.175362 seconds (4.79 G allocations: 357.005 GiB, 0.47% gc time) (1.46 hours)
Above was all using 1 single thread. With 16 threads: (~20 minutes)
   1210.363539 seconds (4.94 G allocations: 368.435 GiB, 10.08% gc time)
Above was all using max bounces=4, since this looked fine to me (except the negatively scaled sphere). 
Switching to max bounces=16 to match C++ version decreased performance by 7.2%:
   1298.522674 seconds (5.43 G allocations: 404.519 GiB, 10.18% gc time)
Using @inbounds, @simd in low-level functions:
   1314.510565 seconds (5.53 G allocations: 411.753 GiB, 10.21% gc time) # NOTE: difference due to randomness?
Adapt @Christ_Foster's Base.getproperty w/ @inline @inbounds: (expect 3-5% speed-up)
Eliminate the off-by-half-a-pixel offset: (expect ~2.5% speed-up)
Fixed, per-thread RNGs with fixed seeds (expecting no noticeable change in speed)
 Using 16 threads: (21m22s)
   1282.437499 seconds (5.53 G allocations: 411.742 GiB, 10.08% gc time) (i.e. 2.5% speed-up... currently GC- and memory-bound?)
 Using 14 threads: (21m45s)
   1305.767627 seconds (5.53 G allocations: 411.741 GiB, 9.97% gc time)"><pre class="notranslate"><code>After some optimization, took ~5.6 hours:
  20171.646846 seconds (94.73 G allocations: 2.496 TiB, 1.06% gc time)
... however the image looked weird... too blurry
After removing all remaining Color, Vec3, replacing them with @SVector[]... took ~3.7 hours:
  13326.770907 seconds (29.82 G allocations: 714.941 GiB, 0.36% gc time)
Using convert(Float32, ...) instead of MyFloat(...):
Don't specify return value of Option{HitRecord} in hit()
Don't initialize unnecessary elements in HitRecord(): 
Took ~4.1 hours:
  14723.339976 seconds (5.45 G allocations: 243.044 GiB, 0.11% gc time) # WORSE, probably because we're writing a lot more to stack...?
Replace MyFloat by Float32:
Lots of other optimizations including @inline lots of stuff: 
   6018.101653 seconds (5.39 G allocations: 241.139 GiB, 0.21% gc time) (1.67 hour)
@woclass's rand(Float32) to avoid Float64s: (expected to provide 2.2% speed up)
@woclass's "Use alias instead of new struct", i.e. `const HittableList = Vector{Hittable}`
@woclass's Vec3{T} with T=Float64: (7.8% speed-up!): 
   5268.175362 seconds (4.79 G allocations: 357.005 GiB, 0.47% gc time) (1.46 hours)
Above was all using 1 single thread. With 16 threads: (~20 minutes)
   1210.363539 seconds (4.94 G allocations: 368.435 GiB, 10.08% gc time)
Above was all using max bounces=4, since this looked fine to me (except the negatively scaled sphere). 
Switching to max bounces=16 to match C++ version decreased performance by 7.2%:
   1298.522674 seconds (5.43 G allocations: 404.519 GiB, 10.18% gc time)
Using @inbounds, @simd in low-level functions:
   1314.510565 seconds (5.53 G allocations: 411.753 GiB, 10.21% gc time) # NOTE: difference due to randomness?
Adapt @Christ_Foster's Base.getproperty w/ @inline @inbounds: (expect 3-5% speed-up)
Eliminate the off-by-half-a-pixel offset: (expect ~2.5% speed-up)
Fixed, per-thread RNGs with fixed seeds (expecting no noticeable change in speed)
 Using 16 threads: (21m22s)
   1282.437499 seconds (5.53 G allocations: 411.742 GiB, 10.08% gc time) (i.e. 2.5% speed-up... currently GC- and memory-bound?)
 Using 14 threads: (21m45s)
   1305.767627 seconds (5.53 G allocations: 411.741 GiB, 9.97% gc time)
</code></pre></div>
<h1 dir="auto"><a id="user-content-adapting-c----julia" class="anchor" aria-hidden="true" href="#adapting-c----julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Adapting C++ --&gt; Julia</h1>
<p dir="auto">These notes may be useful if you're new to Julia...</p>
<ol dir="auto">
<li>To start the notebook: <a href="https://github.com/fonsp/Pluto.jl#lets-do-it">Pluto installation and usage</a></li>
<li>Using the web interface, open the <code>pluto_RayTracingWeekend.jl</code> file.</li>
<li>The first time it may take up to 1-2 mins to download all the necessary packages, and evaluate all the cells.</li>
<li>Please note that the Julia coding conventions aren't respected in this project, in part to make it easier to follow along the C++ code.</li>
<li>Tips on starting with Julia:</li>
</ol>
<ul dir="auto">
<li>consult the references below</li>
<li>if you don't know how to type a unicode character (e.g. n⃗) in Julia, use the Julia help <code>julia</code> then <code>?</code>, then cut-and-paste the character. That particular character is typed using <code>n\vec</code> then pressing TAB.</li>
</ul>
<p dir="auto">Unlike the C++ implementation:</p>
<ul dir="auto">
<li>I didn't implement each chapter separately (except for the first few), instead I focused on making the Pluto.jl implementation able to run most examples in the book with minimal duplication in the code.</li>
<li>I didn't bother implementing PPM file format support, no point for it since Pluto.jl and vscode can both display images directly without saving them to disk first.</li>
<li>Julia uses i for row, j for column, so I inverted some of the loops (to iterate through columns first) and some of the C++ code's variable names.</li>
<li>When saving final pixels, IIUC the C++ code uses a Y-up coordinate system for writing images. Julia's <code>Image</code>s and matrices point down, so I used <code>(ny-i)</code> instead of <code>i</code> for the row number.</li>
<li>Pluto.jl supports having cells/code defined in arbitrary orders. I tried to keep the code from low-level to high-level, but in some cases it wasn't practical, especially since Pluto.jl doesn't seem to support moving more than one cell at a time.</li>
<li>I normalize the ray direction right away, instead of optionally doing it in later functions... I think it's easier to reason about it that way, and the extra cost is probably marginal.</li>
<li>I use a <code>const _no_hit = HitRecord{Float64}()</code> to indicate a no hit... I thought this was speed things up, but this is probably a bad idea...</li>
</ul>
<h1 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References:</h1>
<ul dir="auto">
<li><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html" rel="nofollow">Ray Tracing In One Weekend by Peter Shirley</a></li>
<li><a href="https://github.com/mitmath/18337">ChrisRackauckhas's awesome MIT course of Parallel Computing and Scientific Machine Learning</a>: I only watched the first few lessons on performance optimization so far, but I learnt a lot already and highly recommend it.</li>
<li><a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-Point-Numbers" rel="nofollow">https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-Point-Numbers</a></li>
<li>Other Julia raytracers
<ul dir="auto">
<li><a href="https://github.com/cshenton/RayTracing.jl">cshenton's Julia implementation</a>: This was useful as a starting point as I developed something roughly similar at first, then I tried it optimize it further.</li>
<li><a href="https://github.com/pxl-th/Trace.jl">https://github.com/pxl-th/Trace.jl</a> : more sophisticated raytracer based on this excellent book: Physically Based Rendering: From Theory to Implementation"</li>
<li><a href="https://github.com/paulmelis/riow.jl">https://github.com/paulmelis/riow.jl</a> : another example based on Peter Shirley's books</li>
</ul>
</li>
</ul>
<h1 dir="auto"><a id="user-content-special-thanks-to" class="anchor" aria-hidden="true" href="#special-thanks-to"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Special thanks to:</h1>
<ul dir="auto">
<li>@woclass: who recommended major clean-ups and speed-ups, I learnt a lot from his code!</li>
<li>@Chris_Foster: lots of great suggestions to clean-up and speed-up the code!</li>
</ul>
<h1 dir="auto"><a id="user-content-possible-next-steps" class="anchor" aria-hidden="true" href="#possible-next-steps"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Possible next steps</h1>
<h2 dir="auto"><a id="user-content-short-term" class="anchor" aria-hidden="true" href="#short-term"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Short-term</h2>
<ul dir="auto">
<li>investigate whether Float32 perf degradation can be fixed (doubled the allocations...)</li>
<li>update pluto_RayTracingWeekend.jl, then share on Twitter, etc.</li>
<li>break the code into multiple files...</li>
<li>replace <code>const _no_hit = HitRecord{Float64}()</code> by a distance check (would be type-independent)
<ul dir="auto">
<li>then re-run Float32 and Float64 perf tests</li>
</ul>
</li>
<li>Read on the SIMD libraries, try to figure out the best approach. (I’ll welcome any suggestion you have!)</li>
<li>save image, e.g. PNG</li>
<li>continue watching MIT course</li>
</ul>
<h2 dir="auto"><a id="user-content-long-term" class="anchor" aria-hidden="true" href="#long-term"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Long-term</h2>
<ul dir="auto">
<li>Implement the rest of Peter Shirley's books, especially BVHs</li>
<li>GPU through CUDA, ROCM
<ul dir="auto">
<li>Probably integrate <code>Making the materials and hit system fully concrete with tight inner loops</code> idea from @Chris_Foster</li>
<li>The only remaining allocations that appear expensive are of <code>HitRecord</code>s (on the stack)</li>
<li>Probably pre-allocate the ray batches (I don’t know how they are called in the litterature) to later simplify the GPU (and probably the SIMD) implementation.</li>
<li>implement versions of hit, scatter, etc. that operate on an entire tensor at once.
(i.e. efficiently parallelizable with SIMD or GPU)</li>
<li>use FieldVector and/or StructOfArrays?</li>
</ul>
</li>
<li>Vulkan RT interface, e.g. port of <a href="https://github.com/KhronosGroup/Vulkan-Samples/tree/master/samples/extensions/raytracing_basic">https://github.com/KhronosGroup/Vulkan-Samples/tree/master/samples/extensions/raytracing_basic</a></li>
</ul>
<h1 dir="auto"><a id="user-content-failed-attempts" class="anchor" aria-hidden="true" href="#failed-attempts"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Failed attempts</h1>
<h2 dir="auto"><a id="user-content-using-basegetproperty-for-vecx-instead-of-vec1" class="anchor" aria-hidden="true" href="#using-basegetproperty-for-vecx-instead-of-vec1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>using Base.getproperty() for <code>vec.x</code> instead of <code>vec[1]</code>.</h2>
<p dir="auto">This was meant to be a convenient function to get <code>some_vec.x</code> or <code>some_color.r</code>, but this caused ~41 allocations per call, so this was a huge bottleneck.
TODO: replace by a lens? i.e. see <a href="https://youtu.be/vkAOYeTpLg0?t=426" rel="nofollow">https://youtu.be/vkAOYeTpLg0?t=426</a></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="import Base.getproperty
function Base.getproperty(vec::SVector{3}, sym::Symbol)
    #  TODO: use a dictionary that maps symbols to indices, e.g. Dict(:x-&gt;1)
    if sym in [:x, :r]
        return vec[1]
    elseif sym in [:y, :g]
        return vec[2]
    elseif sym in [:z, :b]
        return vec[3]
    else
        return getfield(vec, sym)
    end
end"><pre class="notranslate"><code>import Base.getproperty
function Base.getproperty(vec::SVector{3}, sym::Symbol)
    #  TODO: use a dictionary that maps symbols to indices, e.g. Dict(:x-&gt;1)
    if sym in [:x, :r]
        return vec[1]
    elseif sym in [:y, :g]
        return vec[2]
    elseif sym in [:z, :b]
        return vec[3]
    else
        return getfield(vec, sym)
    end
end
</code></pre></div>
<h2 dir="auto"><a id="user-content-negatively-scaled-sphere-needs-4-bounces" class="anchor" aria-hidden="true" href="#negatively-scaled-sphere-needs-4-bounces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Negatively scaled sphere needs &gt;4 bounces</h2>
<p dir="auto">Previously I used 4 bounces max per ray path, and the negatively scaled sphere had a black halo inside it. Increasing the bounce count to 16 resolved the issue.</p>
</article></div>