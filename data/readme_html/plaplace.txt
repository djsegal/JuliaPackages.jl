<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/66529462/184855093-33aca1eb-96a3-447f-adb6-42d2ac0a5a10.png"><img src="https://user-images.githubusercontent.com/66529462/184855093-33aca1eb-96a3-447f-adb6-42d2ac0a5a10.png" alt="fem" width="400" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-a-solver-for-problems-of-the-p-laplacian-pde-operator" class="anchor" aria-hidden="true" href="#a-solver-for-problems-of-the-p-laplacian-pde-operator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A Solver for Problems of the <em>p</em>-Laplacian PDE Operator.</h2>
<p dir="auto">This package provides a solver for problems of the scalar or vector-valued <a href="https://en.wikipedia.org/wiki/P-Laplacian" rel="nofollow"><em>p</em>-Laplacian</a> with finite <em>p</em> including source terms and mixed Dirichlet-Neumann boundary conditions.
The solver works iteratively based on a piece-wise linear finite element discretization and interior-point methods.
Theory can be found in the publications [<a href="#references">1</a>] and [<a href="#references">2</a>].</p>
<p dir="auto">The implementation is based on the finite element library <a href="https://github.com/msiebenborn/MinFEM.jl">MinFEM</a>.
Thus, it is able to import meshes in GMSH v1, v2 and v4 format and outputs VTK format for Paraview as well as statistics in plain txt.</p>
<p dir="auto">Start by adding the PLaplace package to our julia installation and test it.
Note that the test might take some time depending on your machine since it solves a full validation problem provided by the method of manufactured solutions [<a href="#references">3</a>].
Thus, open the julia REPL, hit the <strong>]</strong> key and type</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add PLaplace
test PLaplace"><pre class="notranslate"><code>add PLaplace
test PLaplace
</code></pre></div>
<h2 dir="auto"><a id="user-content-an-example-problem" class="anchor" aria-hidden="true" href="#an-example-problem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An Example Problem</h2>
<p dir="auto">Lets go through a code for the <em>p</em>-Laplace equation on a unit square once with inhomogeneous Dirichlet boundary conditions and once with mixed homogenous Dirichlet and inhomogeneous Neumann boundary conditions.</p>
<p dir="auto">First we have to load the package PLaplace.
Here we also load the package MinFEM to gain access to it's mesh generation functions.
With these we then generate a uniform, triangular 30x30 mesh for the unit square.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PLaplace, MinFEM

mesh = unit_square(30)"><pre><span class="pl-k">using</span> PLaplace, MinFEM

mesh <span class="pl-k">=</span> <span class="pl-c1">unit_square</span>(<span class="pl-c1">30</span>)</pre></div>
<p dir="auto">As an alternative: Download the package from github to obtain the examples and meshes and navigate, within the julia console, to the <strong>examples</strong> folder.
Then import one of the mesh files generated with GMSH.
Here the additional include of MinFEM is not necessary.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PLaplace

mesh = import_mesh(&quot;../meshes/square.msh&quot;)"><pre><span class="pl-k">using</span> PLaplace

mesh <span class="pl-k">=</span> <span class="pl-c1">import_mesh</span>(<span class="pl-s"><span class="pl-pds">"</span>../meshes/square.msh<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">In the next step we specify the boundary conditions.
As the default procedure we simply specify julia functions as shown here for a non-homogenous dirichlet boundary condition.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g(x) = x[1]^2"><pre><span class="pl-en">g</span>(x) <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<p dir="auto">The same has to be done for mixed boundary conditions denoting one function for the Dirichlet part and one for the Neumann part. Note that also homogenous conditions need to be specified.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g(x) = 0
h(x) = x[1]^1 - x[2]^2"><pre><span class="pl-en">g</span>(x) <span class="pl-k">=</span> <span class="pl-c1">0</span>
<span class="pl-en">h</span>(x) <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">1</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<p dir="auto">Alternatively, the package also support providing all boundary conditions and the source term as discrete values.
Either as FEM coefficients on the nodes or values on quadrature points of the boundary elements.
Note that this procedure is only recommended for experienced users or if an analytical description of the function is not available.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g = evaluate_mesh_function(mesh, x -&gt; x[1]^2)"><pre>g <span class="pl-k">=</span> <span class="pl-c1">evaluate_mesh_function</span>(mesh, x <span class="pl-k">-&gt;</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>)</pre></div>
<p dir="auto">Next, we need to specify the boundary sets for the respective conditions.
For pure Dirichlet problems it is easiest to select all physical boundaries of the mesh.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="dirichletBoundary = select_boundaries(mesh)"><pre>dirichletBoundary <span class="pl-k">=</span> <span class="pl-c1">select_boundaries</span>(mesh)</pre></div>
<p dir="auto">For mixed problems it is required to select the boundaries manually.
Note that the mesh in this example is designed to have four physical boundaries identified by the indices 1001-1004.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="dirichletBoundary = select_boundaries(mesh, 1001, 1004)
neumannBoundary = select_boundaries(mesh, 1002, 1003)"><pre>dirichletBoundary <span class="pl-k">=</span> <span class="pl-c1">select_boundaries</span>(mesh, <span class="pl-c1">1001</span>, <span class="pl-c1">1004</span>)
neumannBoundary <span class="pl-k">=</span> <span class="pl-c1">select_boundaries</span>(mesh, <span class="pl-c1">1002</span>, <span class="pl-c1">1003</span>)</pre></div>
<p dir="auto">Finally, we solve the problem and write the solution in a file for visualization with Paraview.
The object data of the custom type <code>PLaplaceData</code> contains further relevant data generated during the iteration.
The most important parameters, such as iteration counts and obtained accuracy, can be appended to a log file in .txt format.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="p = 3.0
data = solve_plaplace(p, mesh, g, dirichletBoundary)

mkpath(&quot;results&quot;)
write_result_to_vtk(&quot;results/example_$p&quot;, data)

mkpath(&quot;logs&quot;)
write_log(&quot;logs/example&quot;, data)"><pre>p <span class="pl-k">=</span> <span class="pl-c1">3.0</span>
data <span class="pl-k">=</span> <span class="pl-c1">solve_plaplace</span>(p, mesh, g, dirichletBoundary)

<span class="pl-c1">mkpath</span>(<span class="pl-s"><span class="pl-pds">"</span>results<span class="pl-pds">"</span></span>)
<span class="pl-c1">write_result_to_vtk</span>(<span class="pl-s"><span class="pl-pds">"</span>results/example_<span class="pl-v">$p</span><span class="pl-pds">"</span></span>, data)

<span class="pl-c1">mkpath</span>(<span class="pl-s"><span class="pl-pds">"</span>logs<span class="pl-pds">"</span></span>)
<span class="pl-c1">write_log</span>(<span class="pl-s"><span class="pl-pds">"</span>logs/example<span class="pl-pds">"</span></span>, data)</pre></div>
<p dir="auto">While the solution routine always needs the parameter <em>p</em>, the mesh and the Dirichlet boundary information, it can be provided with a number of optional keyword arguments.
The most prominent ones for Neumann boundary handling are shown here.
For a full list including solver parameters see the documentation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="data = solve_plaplace(p, mesh, g, dirichletBoundary, h=h, neumannBoundary=neumannBoundary)"><pre>data <span class="pl-k">=</span> <span class="pl-c1">solve_plaplace</span>(p, mesh, g, dirichletBoundary, h<span class="pl-k">=</span>h, neumannBoundary<span class="pl-k">=</span>neumannBoundary)</pre></div>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">[1] S. Loisel. “<a href="https://link.springer.com/article/10.1007/s00211-020-01141-z" rel="nofollow">Efficient algorithms for solving the p-Laplacian in polynomial time</a>”. Numerische
Mathematik 146.2, pp. 369–400. 2020.<br>
[2] H. Wyschka and M. Siebenborn. “<a href="https://arxiv.org/abs/2208.06897" rel="nofollow">Towards computing high-order p-harmonic descent directions and their limits in shape optimization</a>”. arXiv (Preprint). 2022<br>
[3] K. Salari and P. Knupp. “<a href="https://www.osti.gov/biblio/759450-wLI4Ux/native/" rel="nofollow">Code Verification by the Method of Manufactured Solutions</a>”. Sandia Report. 2000.</p>
</article></div>