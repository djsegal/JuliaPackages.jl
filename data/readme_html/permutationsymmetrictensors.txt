<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-permutationsymmetrictensorsjl" class="anchor" aria-hidden="true" href="#permutationsymmetrictensorsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PermutationSymmetricTensors.jl</h1>
<p dir="auto"><a href="https://github.com/IlianPihlajamaa/PermutationSymmetricTensors.jl/actions"><img src="https://github.com/IlianPihlajamaa/PermutationSymmetricTensors.jl/workflows/CI/badge.svg" alt="Build status (Github Actions)" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/IlianPihlajamaa/PermutationSymmetricTensors.jl?branch=main" rel="nofollow"><img src="https://camo.githubusercontent.com/032e62c06d3791515c42d1e23bdda12b8e75bafaf21a656b5b78565f4f619fd5/687474703a2f2f636f6465636f762e696f2f6769746875622f496c69616e5069686c616a616d61612f5065726d75746174696f6e53796d6d657472696354656e736f72732e6a6c2f636f7665726167652e7376673f6272616e63683d6d61696e" alt="codecov.io" data-canonical-src="http://codecov.io/github/IlianPihlajamaa/PermutationSymmetricTensors.jl/coverage.svg?branch=main" style="max-width: 100%;"></a></p>

<p dir="auto">PermutationSymmetricTensors.jl provides an efficient framework for the use of multidimensional arrays that are symmetric under any permutation of their indices, implemented in pure Julia. Such symmetric tensors are implemented in the <code>SymmetricTensor{T, N, dim}</code> type, where <code>T</code> is the element type, <code>dim</code> is the number of indices required to index into the tensor, and <code>N</code> is the maximal index for each dimension. For example, to index a <code>SymmetricTensor{ComplexF64, 20, 6}</code>, you need 6 indices between 1 and 20. Note that we use the computer science definition of a tensor instead of the mathematical one: in the following, a tensor is just a multi-dimensional container of elements of some type <code>T</code>. As described above, we refer to the number of indices as the dimension of this tensor, because that is semantically consistent with the definition of a multidimensional array. In mathematics and physics texts, what we call dimension is usually referred to as the order, degree or rank of a tensor.</p>
<p dir="auto">This package exports basic constructors of <code>SymmetricTensor</code>s, and a few convenience functions for working with them. The main advantage of using a <code>SymmetricTensor</code> is that it requires much less memory to store than the full array would.</p>
<h2 dir="auto"><a id="user-content-construction" class="anchor" aria-hidden="true" href="#construction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Construction</h2>
<p dir="auto">A <code>SymmetricTensor</code> can conveniently be constructed using <code>zeros</code>, <code>ones</code>, <code>similar</code> and <code>rand</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using PermutationSymmetricTensors

julia&gt; a = rand(SymmetricTensor{Float64, 2, 3})
2×2×2 SymmetricTensor{Float64, 2, 3}:
[:, :, 1] =
 0.117155  0.815916
 0.815916  0.978778

[:, :, 2] =
 0.815916  0.978778
 0.978778  0.825148

julia&gt; b = zeros(SymmetricTensor{ComplexF32, 3, 3})
3×3×3 SymmetricTensor{ComplexF32, 3, 3}:
[:, :, 1] =
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 2] =
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 3] =
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im

julia&gt;  c = ones(SymmetricTensor{Bool, 2, 2})
2×2 SymmetricTensor{Bool, 2, 2}:
 1  1
 1  1
 
julia&gt; d = similar(c)
2×2 SymmetricTensor{Bool, 2, 2}:
 0  0
 0  0

julia&gt; e = similar(d, Char)
2×2 SymmetricTensor{Char, 2, 2}:
 '\0'                '\x00\x00\x00\x01'
 '\x00\x00\x00\x01'  '\x00\x00\x00\x01'"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> PermutationSymmetricTensors

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>})
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SymmetricTensor{Float64, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.117155</span>  <span class="pl-c1">0.815916</span>
 <span class="pl-c1">0.815916</span>  <span class="pl-c1">0.978778</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.815916</span>  <span class="pl-c1">0.978778</span>
 <span class="pl-c1">0.978778</span>  <span class="pl-c1">0.825148</span>

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(SymmetricTensor{ComplexF32, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>})
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> SymmetricTensor{ComplexF32, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

[:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

julia<span class="pl-k">&gt;</span>  c <span class="pl-k">=</span> <span class="pl-c1">ones</span>(SymmetricTensor{Bool, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>})
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SymmetricTensor{Bool, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">1</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">1</span>
 
julia<span class="pl-k">&gt;</span> d <span class="pl-k">=</span> <span class="pl-c1">similar</span>(c)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SymmetricTensor{Bool, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>  <span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> e <span class="pl-k">=</span> <span class="pl-c1">similar</span>(d, Char)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SymmetricTensor{Char, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>                <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>01<span class="pl-pds">'</span></span>
 <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>01<span class="pl-pds">'</span></span>  <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>00<span class="pl-cce">\x</span>01<span class="pl-pds">'</span></span></pre></div>
<p dir="auto">Since the tensor is parametrized with its size, it is not necessary to provide any other arguments to <code>zeros</code>, <code>ones</code>, or <code>rand</code>. If the standard library <code>Random</code> is imported, <code>rand!(a)</code> will also work.</p>
<p dir="auto">In order to create a <code>SymmetricTensor</code> from data stored in a <code>Vector{T}</code> directly, a constructor <code>SymmetricTensor(data, Val(N), Val(dim))</code> can be called. It is important to make sure that the length of the given vector <code>data</code> agrees with the number of unique elements in the requested <code>SymmetricTensor</code>. The function <code>find_symmetric_tensor_size(N, dim)</code> is useful for that purpose. Given the number of elements in each dimension <code>N</code> and the number of dimensions <code>dim</code>, it returns the number of distinct elements that a <code>SymmetricTensor{T, N, dim}</code> needs to store.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; L = find_symmetric_tensor_size(3, 3)
10

julia&gt; data = collect(1:L)
10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10

julia&gt; SymmetricTensor(data, Val(3), Val(3))
3×3×3 SymmetricTensor{Int64, 3, 3}:
[:, :, 1] =
 1  2  3
 2  4  5
 3  5  6

[:, :, 2] =
 2  4  5
 4  7  8
 5  8  9

[:, :, 3] =
 3  5   6
 5  8   9
 6  9  10
"><pre>julia<span class="pl-k">&gt;</span> L <span class="pl-k">=</span> <span class="pl-c1">find_symmetric_tensor_size</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)
<span class="pl-c1">10</span>

julia<span class="pl-k">&gt;</span> data <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>L)
<span class="pl-c1">10</span><span class="pl-k">-</span>element Vector{Int64}<span class="pl-k">:</span>
  <span class="pl-c1">1</span>
  <span class="pl-c1">2</span>
  <span class="pl-c1">3</span>
  <span class="pl-c1">4</span>
  <span class="pl-c1">5</span>
  <span class="pl-c1">6</span>
  <span class="pl-c1">7</span>
  <span class="pl-c1">8</span>
  <span class="pl-c1">9</span>
 <span class="pl-c1">10</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">SymmetricTensor</span>(data, <span class="pl-c1">Val</span>(<span class="pl-c1">3</span>), <span class="pl-c1">Val</span>(<span class="pl-c1">3</span>))
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> SymmetricTensor{Int64, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">2</span>  <span class="pl-c1">3</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">4</span>  <span class="pl-c1">5</span>
 <span class="pl-c1">3</span>  <span class="pl-c1">5</span>  <span class="pl-c1">6</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">2</span>  <span class="pl-c1">4</span>  <span class="pl-c1">5</span>
 <span class="pl-c1">4</span>  <span class="pl-c1">7</span>  <span class="pl-c1">8</span>
 <span class="pl-c1">5</span>  <span class="pl-c1">8</span>  <span class="pl-c1">9</span>

[:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
 <span class="pl-c1">3</span>  <span class="pl-c1">5</span>   <span class="pl-c1">6</span>
 <span class="pl-c1">5</span>  <span class="pl-c1">8</span>   <span class="pl-c1">9</span>
 <span class="pl-c1">6</span>  <span class="pl-c1">9</span>  <span class="pl-c1">10</span>
</pre></div>
<p dir="auto">Note that <code>SymmetricTensor</code>s leverage symmetry to minimize memory usage. It easy to create <code>SymmetricTensors</code> that would have more elements than <code>typemax(Int64)</code>, if they had been stored naively.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; d = rand(SymmetricTensor{Float64, 14, 17});

julia&gt; println(&quot;This tensor requires &quot;, round(sizeof(d)/2^30, digits=2), &quot;GB memory&quot;)
This tensor requires 0.89GB memory

julia&gt; println(&quot;a full array of this shape would require &quot;, length(d)*8/2^30, &quot;GB memory.&quot;)
a full array of this shape would require 2.27e11GB memory.

julia&gt; println(&quot;it would have &quot;, 14^17, &quot; elements.&quot;)
it would have -6402141418087907328 elements.

julia&gt; println(&quot;oops, I meant &quot;, big(14)^17)
oops, I meant 30491346729331195904"><pre>julia<span class="pl-k">&gt;</span> d <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">14</span>, <span class="pl-c1">17</span>});

julia<span class="pl-k">&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>This tensor requires <span class="pl-pds">"</span></span>, <span class="pl-c1">round</span>(<span class="pl-c1">sizeof</span>(d)<span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">30</span>, digits<span class="pl-k">=</span><span class="pl-c1">2</span>), <span class="pl-s"><span class="pl-pds">"</span>GB memory<span class="pl-pds">"</span></span>)
This tensor requires <span class="pl-c1">0.89</span>GB memory

julia<span class="pl-k">&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>a full array of this shape would require <span class="pl-pds">"</span></span>, <span class="pl-c1">length</span>(d)<span class="pl-k">*</span><span class="pl-c1">8</span><span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">30</span>, <span class="pl-s"><span class="pl-pds">"</span>GB memory.<span class="pl-pds">"</span></span>)
a full array of this shape would require <span class="pl-c1">2.27e11</span>GB memory.

julia<span class="pl-k">&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>it would have <span class="pl-pds">"</span></span>, <span class="pl-c1">14</span><span class="pl-k">^</span><span class="pl-c1">17</span>, <span class="pl-s"><span class="pl-pds">"</span> elements.<span class="pl-pds">"</span></span>)
it would have <span class="pl-k">-</span><span class="pl-c1">6402141418087907328</span> elements.

julia<span class="pl-k">&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>oops, I meant <span class="pl-pds">"</span></span>, <span class="pl-c1">big</span>(<span class="pl-c1">14</span>)<span class="pl-k">^</span><span class="pl-c1">17</span>)
oops, I meant <span class="pl-c1">30491346729331195904</span></pre></div>
<p dir="auto">In the second line, the computation <code>14^17</code> overflowed, and therefore returned the wrong result. This is important to take this into account when calculating the sum of all elements of a <code>SymmetricTensor{Int, N, dim}</code>, if it is very large. To make iteration work on arrays for which <code>N^dim &gt; typemax(Int)</code>, <code>length(d)</code> returns an <code>Int128</code> in those cases.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt;  d = rand(SymmetricTensor{Float64, 15, 20});
julia&gt; length(d)
332525673007965087890625
julia&gt; typeof(ans)
Int128

julia&gt; d = rand(SymmetricTensor{Float64, 15, 2});
julia&gt; length(d)
225
julia&gt; typeof(ans)
Int64"><pre>julia<span class="pl-k">&gt;</span>  d <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">15</span>, <span class="pl-c1">20</span>});
julia<span class="pl-k">&gt;</span> <span class="pl-c1">length</span>(d)
<span class="pl-c1">332525673007965087890625</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(ans)
Int128

julia<span class="pl-k">&gt;</span> d <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">15</span>, <span class="pl-c1">2</span>});
julia<span class="pl-k">&gt;</span> <span class="pl-c1">length</span>(d)
<span class="pl-c1">225</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(ans)
Int64</pre></div>
<h2 dir="auto"><a id="user-content-standard-use" class="anchor" aria-hidden="true" href="#standard-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Standard use</h2>
<p dir="auto">The tensors can be indexed and mutated at will.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; a = rand(SymmetricTensor{Int8, 3, 3})
3×3×3 SymmetricTensor{Int8, 3, 3}:
[:, :, 1] =
 -115  -31  117
  -31  110   95
  117   95  -57

[:, :, 2] =
 -31  110    95
 110  -30    33
  95   33  -106

[:, :, 3] =
 117    95   -57
  95    33  -106
 -57  -106    87

julia&gt; a[1,2,3]
95

julia&gt; a[3,1,2]
95

julia&gt; a[3,2,2] = 6
6

julia&gt; a
3×3×3 SymmetricTensor{Int8, 3, 3}:
[:, :, 1] =
 -115  -31  117
  -31  110   95
  117   95  -57

[:, :, 2] =
 -31  110    95
 110  -30     6
  95    6  -106

[:, :, 3] =
 117    95   -57
  95     6  -106
 -57  -106    87

julia&gt; a[:, 1, 1] .= 0
3-element view(::SymmetricTensor{Int8, 3, 3}, :, 1, 1) with eltype Int8:
 0
 0
 0

julia&gt; a
3×3×3 SymmetricTensor{Int8, 3, 3}:
[:, :, 1] =
 0    0    0
 0  110   95
 0   95  -57

[:, :, 2] =
   0  110    95
 110  -30     6
  95    6  -106

[:, :, 3] =
   0    95   -57
  95     6  -106
 -57  -106    87"><pre>julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Int8, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>})
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> SymmetricTensor{Int8, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-k">-</span><span class="pl-c1">115</span>  <span class="pl-k">-</span><span class="pl-c1">31</span>  <span class="pl-c1">117</span>
  <span class="pl-k">-</span><span class="pl-c1">31</span>  <span class="pl-c1">110</span>   <span class="pl-c1">95</span>
  <span class="pl-c1">117</span>   <span class="pl-c1">95</span>  <span class="pl-k">-</span><span class="pl-c1">57</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-k">-</span><span class="pl-c1">31</span>  <span class="pl-c1">110</span>    <span class="pl-c1">95</span>
 <span class="pl-c1">110</span>  <span class="pl-k">-</span><span class="pl-c1">30</span>    <span class="pl-c1">33</span>
  <span class="pl-c1">95</span>   <span class="pl-c1">33</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>

[:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
 <span class="pl-c1">117</span>    <span class="pl-c1">95</span>   <span class="pl-k">-</span><span class="pl-c1">57</span>
  <span class="pl-c1">95</span>    <span class="pl-c1">33</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>
 <span class="pl-k">-</span><span class="pl-c1">57</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>    <span class="pl-c1">87</span>

julia<span class="pl-k">&gt;</span> a[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]
<span class="pl-c1">95</span>

julia<span class="pl-k">&gt;</span> a[<span class="pl-c1">3</span>,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]
<span class="pl-c1">95</span>

julia<span class="pl-k">&gt;</span> a[<span class="pl-c1">3</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">6</span>
<span class="pl-c1">6</span>

julia<span class="pl-k">&gt;</span> a
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> SymmetricTensor{Int8, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-k">-</span><span class="pl-c1">115</span>  <span class="pl-k">-</span><span class="pl-c1">31</span>  <span class="pl-c1">117</span>
  <span class="pl-k">-</span><span class="pl-c1">31</span>  <span class="pl-c1">110</span>   <span class="pl-c1">95</span>
  <span class="pl-c1">117</span>   <span class="pl-c1">95</span>  <span class="pl-k">-</span><span class="pl-c1">57</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-k">-</span><span class="pl-c1">31</span>  <span class="pl-c1">110</span>    <span class="pl-c1">95</span>
 <span class="pl-c1">110</span>  <span class="pl-k">-</span><span class="pl-c1">30</span>     <span class="pl-c1">6</span>
  <span class="pl-c1">95</span>    <span class="pl-c1">6</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>

[:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
 <span class="pl-c1">117</span>    <span class="pl-c1">95</span>   <span class="pl-k">-</span><span class="pl-c1">57</span>
  <span class="pl-c1">95</span>     <span class="pl-c1">6</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>
 <span class="pl-k">-</span><span class="pl-c1">57</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>    <span class="pl-c1">87</span>

julia<span class="pl-k">&gt;</span> a[:, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">.=</span> <span class="pl-c1">0</span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element <span class="pl-c1">view</span>(<span class="pl-k">::</span><span class="pl-c1">SymmetricTensor{Int8, 3, 3}</span>, :, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>) with eltype Int8<span class="pl-k">:</span>
 <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> a
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> SymmetricTensor{Int8, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0</span>    <span class="pl-c1">0</span>    <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>  <span class="pl-c1">110</span>   <span class="pl-c1">95</span>
 <span class="pl-c1">0</span>   <span class="pl-c1">95</span>  <span class="pl-k">-</span><span class="pl-c1">57</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
   <span class="pl-c1">0</span>  <span class="pl-c1">110</span>    <span class="pl-c1">95</span>
 <span class="pl-c1">110</span>  <span class="pl-k">-</span><span class="pl-c1">30</span>     <span class="pl-c1">6</span>
  <span class="pl-c1">95</span>    <span class="pl-c1">6</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>

[:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
   <span class="pl-c1">0</span>    <span class="pl-c1">95</span>   <span class="pl-k">-</span><span class="pl-c1">57</span>
  <span class="pl-c1">95</span>     <span class="pl-c1">6</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>
 <span class="pl-k">-</span><span class="pl-c1">57</span>  <span class="pl-k">-</span><span class="pl-c1">106</span>    <span class="pl-c1">87</span></pre></div>
<p dir="auto">As, you can see, mutating one element also mutates all elements that are equivalent under index permutation.</p>
<p dir="auto">They can also be iterated over and support most operations that arbitrary <code>AbstractArray</code>s do.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; a = rand(SymmetricTensor{BigFloat, 2, 4});

julia&gt; for (i,ai) in enumerate(a)
           println((; i, ai))
       end
(i = 1, ai = 0.2504089172066270587643679267492732606636747737542205201257084506876941174077477)
(i = 2, ai = 0.1860567927479512764579583273597475579165054085072190505299583862788352760987293)
(i = 3, ai = 0.1860567927479512764579583273597475579165054085072190505299583862788352760987293)
(i = 4, ai = 0.4835838555693179868982759692607130469187769066045701314885210270407212019687799)
(i = 5, ai = 0.1860567927479512764579583273597475579165054085072190505299583862788352760987293)
(i = 6, ai = 0.4835838555693179868982759692607130469187769066045701314885210270407212019687799)
(i = 7, ai = 0.4835838555693179868982759692607130469187769066045701314885210270407212019687799)
(i = 8, ai = 0.3477955309561294416780053339785331891151633045252627608308216556228621260564572)
(i = 9, ai = 0.1860567927479512764579583273597475579165054085072190505299583862788352760987293)
(i = 10, ai = 0.4835838555693179868982759692607130469187769066045701314885210270407212019687799)
(i = 11, ai = 0.4835838555693179868982759692607130469187769066045701314885210270407212019687799)
(i = 12, ai = 0.3477955309561294416780053339785331891151633045252627608308216556228621260564572)
(i = 13, ai = 0.4835838555693179868982759692607130469187769066045701314885210270407212019687799)
(i = 14, ai = 0.3477955309561294416780053339785331891151633045252627608308216556228621260564572)
(i = 15, ai = 0.3477955309561294416780053339785331891151633045252627608308216556228621260564572)
(i = 16, ai = 0.6260418198971816214133682349248890223510908167601655542512797867183309913317024)

julia&gt; size(a)
(2, 2, 2, 2)

julia&gt; ndims(a)
4

julia&gt; axes(a)
(Base.OneTo(2), Base.OneTo(2), Base.OneTo(2), Base.OneTo(2))

julia&gt; length(a)
16

julia&gt; sum(a)
5.913363165336039474111246622591563552654101882271734108751234567257141929172806

julia&gt; prod(a)
3.515296863282957514709371560171304793858187682416751663789389978162540592035332e-08

julia&gt; extrema(a)
(0.1860567927479512764579583273597475579165054085072190505299583862788352760987293, 0.6260418198971816214133682349248890223510908167601655542512797867183309913317024)

julia&gt; lastindex(a)
16

julia&gt; [i for i in eachindex(a)]
2×2×2×2 Array{CartesianIndex{4}, 4}:
[:, :, 1, 1] =
 CartesianIndex(1, 1, 1, 1)  CartesianIndex(1, 2, 1, 1)
 CartesianIndex(2, 1, 1, 1)  CartesianIndex(2, 2, 1, 1)

[:, :, 2, 1] =
 CartesianIndex(1, 1, 2, 1)  CartesianIndex(1, 2, 2, 1)
 CartesianIndex(2, 1, 2, 1)  CartesianIndex(2, 2, 2, 1)

[:, :, 1, 2] =
 CartesianIndex(1, 1, 1, 2)  CartesianIndex(1, 2, 1, 2)
 CartesianIndex(2, 1, 1, 2)  CartesianIndex(2, 2, 1, 2)

[:, :, 2, 2] =
 CartesianIndex(1, 1, 2, 2)  CartesianIndex(1, 2, 2, 2)
 CartesianIndex(2, 1, 2, 2)  CartesianIndex(2, 2, 2, 2)"><pre>julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{BigFloat, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>});

julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> (i,ai) <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(a)
           <span class="pl-c1">println</span>((; i, ai))
       <span class="pl-k">end</span>
(i <span class="pl-k">=</span> <span class="pl-c1">1</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.2504089172066270587643679267492732606636747737542205201257084506876941174077477</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">2</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.1860567927479512764579583273597475579165054085072190505299583862788352760987293</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">3</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.1860567927479512764579583273597475579165054085072190505299583862788352760987293</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">4</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.4835838555693179868982759692607130469187769066045701314885210270407212019687799</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">5</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.1860567927479512764579583273597475579165054085072190505299583862788352760987293</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">6</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.4835838555693179868982759692607130469187769066045701314885210270407212019687799</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">7</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.4835838555693179868982759692607130469187769066045701314885210270407212019687799</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">8</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.3477955309561294416780053339785331891151633045252627608308216556228621260564572</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">9</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.1860567927479512764579583273597475579165054085072190505299583862788352760987293</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">10</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.4835838555693179868982759692607130469187769066045701314885210270407212019687799</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">11</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.4835838555693179868982759692607130469187769066045701314885210270407212019687799</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">12</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.3477955309561294416780053339785331891151633045252627608308216556228621260564572</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">13</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.4835838555693179868982759692607130469187769066045701314885210270407212019687799</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">14</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.3477955309561294416780053339785331891151633045252627608308216556228621260564572</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">15</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.3477955309561294416780053339785331891151633045252627608308216556228621260564572</span>)
(i <span class="pl-k">=</span> <span class="pl-c1">16</span>, ai <span class="pl-k">=</span> <span class="pl-c1">0.6260418198971816214133682349248890223510908167601655542512797867183309913317024</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">size</span>(a)
(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ndims</span>(a)
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">axes</span>(a)
(Base<span class="pl-k">.</span><span class="pl-c1">OneTo</span>(<span class="pl-c1">2</span>), Base<span class="pl-k">.</span><span class="pl-c1">OneTo</span>(<span class="pl-c1">2</span>), Base<span class="pl-k">.</span><span class="pl-c1">OneTo</span>(<span class="pl-c1">2</span>), Base<span class="pl-k">.</span><span class="pl-c1">OneTo</span>(<span class="pl-c1">2</span>))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">length</span>(a)
<span class="pl-c1">16</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(a)
<span class="pl-c1">5.913363165336039474111246622591563552654101882271734108751234567257141929172806</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">prod</span>(a)
<span class="pl-c1">3.515296863282957514709371560171304793858187682416751663789389978162540592035332e-08</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">extrema</span>(a)
(<span class="pl-c1">0.1860567927479512764579583273597475579165054085072190505299583862788352760987293</span>, <span class="pl-c1">0.6260418198971816214133682349248890223510908167601655542512797867183309913317024</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">lastindex</span>(a)
<span class="pl-c1">16</span>

julia<span class="pl-k">&gt;</span> [i <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(a)]
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{CartesianIndex{<span class="pl-c1">4</span>}, <span class="pl-c1">4</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)

[:, :, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>)
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>)

[:, :, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>)

[:, :, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
 <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)  <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)</pre></div>
<p dir="auto">However, the only functions from <code>Base</code> that are explicitly overloaded are <code>zeros</code>, <code>ones</code>, <code>rand(!)</code>, <code>similar</code>, <code>sizeof</code>, <code>size</code>, <code>length</code>, <code>getindex</code>, and <code>setindex!</code>. All other operations shown above fall back to the implementations for <code>AbstractArray</code> of which <code>SymmetricTensor</code> is a subtype. Many therefore have highly suboptimal performance. More examples of that are given in the Performance section below.</p>
<p dir="auto">Currently, broadcasting will always convert a <code>SymmetricTensor</code> into a full <code>N</code>-dimensional <code>Array</code>. For simple broadcasts, such as applying elementwise functions, instead consider broadcasting on the <code>data</code>-field, which holds all data that the symmetric tensor contains.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @time a = rand(SymmetricTensor{Float64, 10, 8});
  0.000170 seconds (13 allocations: 191.266 KiB)

julia&gt; @time b = a .* 0;
  2.755832 seconds (4 allocations: 762.940 MiB, 1.64% gc time)

julia&gt; typeof(b)
Array{Float64, 8}

julia&gt; @time c = similar(a);
  0.000125 seconds (13 allocations: 191.266 KiB)
  
julia&gt; @time c.data .= a.data .* 0 .+ 1;
  0.000023 seconds (4 allocations: 128 bytes)
  
julia&gt; sum(c) == length(c)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">10</span>, <span class="pl-c1">8</span>});
  <span class="pl-c1">0.000170</span> seconds (<span class="pl-c1">13</span> allocations<span class="pl-k">:</span> <span class="pl-c1">191.266</span> KiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> b <span class="pl-k">=</span> a <span class="pl-k">.*</span> <span class="pl-c1">0</span>;
  <span class="pl-c1">2.755832</span> seconds (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">762.940</span> MiB, <span class="pl-c1">1.64</span><span class="pl-k">%</span> gc time)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(b)
Array{Float64, <span class="pl-c1">8</span>}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> c <span class="pl-k">=</span> <span class="pl-c1">similar</span>(a);
  <span class="pl-c1">0.000125</span> seconds (<span class="pl-c1">13</span> allocations<span class="pl-k">:</span> <span class="pl-c1">191.266</span> KiB)
  
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> c<span class="pl-k">.</span>data <span class="pl-k">.=</span> a<span class="pl-k">.</span>data <span class="pl-k">.*</span> <span class="pl-c1">0</span> <span class="pl-k">.+</span> <span class="pl-c1">1</span>;
  <span class="pl-c1">0.000023</span> seconds (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">128</span> bytes)
  
julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(c) <span class="pl-k">==</span> <span class="pl-c1">length</span>(c)
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Be aware that some inplace operations can give unexpected results:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; a = rand(SymmetricTensor{Float64, 2, 2})
2×2 SymmetricTensor{Float64, 2, 2}:
 0.520987  0.84325
 0.84325   0.693854
 
julia&gt; sort!(a, dims=2)
2×2 SymmetricTensor{Float64, 2, 2}:
 0.520987  0.693854
 0.693854  0.84325"><pre>julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>})
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SymmetricTensor{Float64, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.520987</span>  <span class="pl-c1">0.84325</span>
 <span class="pl-c1">0.84325</span>   <span class="pl-c1">0.693854</span>
 
julia<span class="pl-k">&gt;</span> <span class="pl-c1">sort!</span>(a, dims<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SymmetricTensor{Float64, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.520987</span>  <span class="pl-c1">0.693854</span>
 <span class="pl-c1">0.693854</span>  <span class="pl-c1">0.84325</span></pre></div>
<h2 dir="auto"><a id="user-content-convenience-functions" class="anchor" aria-hidden="true" href="#convenience-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Convenience Functions</h2>
<p dir="auto"><code>find_full_indices(N, dim)</code> or <code>find_full_indices(a::SymmetricTensor)</code> returns an ordered array of tuples of indices (i1, i2, i3, ..., i{dim}) such that i1 &gt;= i2 &gt;= i3 ... &gt;= i{dim}. This can be used to find the cartesian index that corresponds the index of the underlying data vector of a <code>SymmetricTensor{T, N, dim}</code>.
Example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; find_full_indices(3, 3)
  10-element Vector{Tuple{Int32, Int32, Int32}}:
  (1, 1, 1)
  (2, 1, 1)
  (3, 1, 1)
  (2, 2, 1)
  (3, 2, 1)
  (3, 3, 1)
  (2, 2, 2)
  (3, 2, 2)
  (3, 3, 2)
  (3, 3, 3)
  
julia&gt; a = rand(SymmetricTensor{Float64, 2, 8});

julia&gt; full_indices = find_full_indices(a)
9-element Vector{NTuple{8, Int32}}:
 (1, 1, 1, 1, 1, 1, 1, 1)
 (2, 1, 1, 1, 1, 1, 1, 1)
 (2, 2, 1, 1, 1, 1, 1, 1)
 (2, 2, 2, 1, 1, 1, 1, 1)
 (2, 2, 2, 2, 1, 1, 1, 1)
 (2, 2, 2, 2, 2, 1, 1, 1)
 (2, 2, 2, 2, 2, 2, 1, 1)
 (2, 2, 2, 2, 2, 2, 2, 1)
 (2, 2, 2, 2, 2, 2, 2, 2)
 
 julia&gt; a.data[4]
0.405316936154127

julia&gt; indices = full_indices[4]
(2, 2, 2, 1, 1, 1, 1, 1)

julia&gt; a[indices...]
0.405316936154127"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">find_full_indices</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)
  <span class="pl-c1">10</span><span class="pl-k">-</span>element Vector{Tuple{Int32, Int32, Int32}}<span class="pl-k">:</span>
  (<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
  (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
  (<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
  (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>)
  (<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>)
  (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">1</span>)
  (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
  (<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
  (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>)
  (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>)
  
julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">2</span>, <span class="pl-c1">8</span>});

julia<span class="pl-k">&gt;</span> full_indices <span class="pl-k">=</span> <span class="pl-c1">find_full_indices</span>(a)
<span class="pl-c1">9</span><span class="pl-k">-</span>element Vector{NTuple{<span class="pl-c1">8</span>, Int32}}<span class="pl-k">:</span>
 (<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>)
 (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
 
 julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>data[<span class="pl-c1">4</span>]
<span class="pl-c1">0.405316936154127</span>

julia<span class="pl-k">&gt;</span> indices <span class="pl-k">=</span> full_indices[<span class="pl-c1">4</span>]
(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)

julia<span class="pl-k">&gt;</span> a[indices<span class="pl-k">...</span>]
<span class="pl-c1">0.405316936154127</span></pre></div>
<p dir="auto"><code>find_degeneracy(N, dim)</code> or <code>find_degeneracy(a::SymmetricTensor)</code> returns a SymmetricTensor{Int64, N, dim} of which each element specifies the number of index permutations that point to the same element.
Examples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="  julia&gt; find_degeneracy(3, 3)
  3×3×3 SymmetricTensor{Int64, 3, 3}:
  [:, :, 1] =
  1  3  3
  3  3  6
  3  6  3

  [:, :, 2] =
  3  3  6
  3  1  3
  6  3  3

  [:, :, 3] =
  3  6  3
  6  3  3
  3  3  1

  julia&gt; a = rand(SymmetricTensor{Float64, 2,4});

  julia&gt; find_degeneracy(a)
  2×2×2×2 SymmetricTensor{Int64, 2, 4}:
  [:, :, 1, 1] =
  1  4
  4  6

  [:, :, 2, 1] =
  4  6
  6  4

  [:, :, 1, 2] =
  4  6
  6  4

  [:, :, 2, 2] =
  6  4
  4  1"><pre>  julia<span class="pl-k">&gt;</span> <span class="pl-c1">find_degeneracy</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)
  <span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> SymmetricTensor{Int64, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
  [:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
  <span class="pl-c1">1</span>  <span class="pl-c1">3</span>  <span class="pl-c1">3</span>
  <span class="pl-c1">3</span>  <span class="pl-c1">3</span>  <span class="pl-c1">6</span>
  <span class="pl-c1">3</span>  <span class="pl-c1">6</span>  <span class="pl-c1">3</span>

  [:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
  <span class="pl-c1">3</span>  <span class="pl-c1">3</span>  <span class="pl-c1">6</span>
  <span class="pl-c1">3</span>  <span class="pl-c1">1</span>  <span class="pl-c1">3</span>
  <span class="pl-c1">6</span>  <span class="pl-c1">3</span>  <span class="pl-c1">3</span>

  [:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
  <span class="pl-c1">3</span>  <span class="pl-c1">6</span>  <span class="pl-c1">3</span>
  <span class="pl-c1">6</span>  <span class="pl-c1">3</span>  <span class="pl-c1">3</span>
  <span class="pl-c1">3</span>  <span class="pl-c1">3</span>  <span class="pl-c1">1</span>

  julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">2</span>,<span class="pl-c1">4</span>});

  julia<span class="pl-k">&gt;</span> <span class="pl-c1">find_degeneracy</span>(a)
  <span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SymmetricTensor{Int64, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>}<span class="pl-k">:</span>
  [:, :, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
  <span class="pl-c1">1</span>  <span class="pl-c1">4</span>
  <span class="pl-c1">4</span>  <span class="pl-c1">6</span>

  [:, :, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
  <span class="pl-c1">4</span>  <span class="pl-c1">6</span>
  <span class="pl-c1">6</span>  <span class="pl-c1">4</span>

  [:, :, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
  <span class="pl-c1">4</span>  <span class="pl-c1">6</span>
  <span class="pl-c1">6</span>  <span class="pl-c1">4</span>

  [:, :, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
  <span class="pl-c1">6</span>  <span class="pl-c1">4</span>
  <span class="pl-c1">4</span>  <span class="pl-c1">1</span></pre></div>
<h2 dir="auto"><a id="user-content-performance" class="anchor" aria-hidden="true" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance</h2>
<p dir="auto"><code>SymmetricTensor</code>s should be used mainly to save memory as explained above. In exchange, they sacrifice the performance of indexing. However, as we shall see, also many basic operations on symmetric tensors outperform those applied to full arrays, if their dimensionality is sufficiently large.</p>
<p dir="auto">Creation and indexing:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using BenchmarkTools

julia&gt; N = 100;  dim = 2;

julia&gt; a = @btime zeros(ntuple(x-&gt;N,dim));
  2.571 μs (2 allocations: 78.17 KiB)

julia&gt; b = @btime zeros(SymmetricTensor{Float64, $N, $dim});
  6.250 μs (7 allocations: 41.45 KiB)

julia&gt; @btime $a[53, 23]
  1.900 ns (0 allocations: 0 bytes)
0.0

julia&gt; @btime $b[53, 23]
  2.200 ns (0 allocations: 0 bytes)
0.0


julia&gt; N = 100;  dim = 4;

julia&gt; a = @btime zeros(ntuple(x-&gt;$N, $dim));
  93.489 ms (4 allocations: 762.94 MiB)

julia&gt; b = @btime zeros(SymmetricTensor{Float64, $N, $dim});
  4.803 ms (9 allocations: 33.74 MiB)

julia&gt; @btime $a[53, 23, 23, 12]
  1.900 ns (0 allocations: 0 bytes)
0.0

julia&gt; @btime $b[53, 23, 23, 12]
  3.300 ns (0 allocations: 0 bytes)
0.0


julia&gt; N = 10;  dim = 9;

julia&gt; a = @btime zeros(ntuple(x-&gt;$N, $dim));
  883.687 ms (4 allocations: 7.45 GiB)

julia&gt; b = @btime zeros(SymmetricTensor{Float64, $N, $dim});
  170.900 μs (15 allocations: 381.67 KiB)

julia&gt; @btime $a[5,2,6,8,5,3,4,5,7]
  4.400 ns (0 allocations: 0 bytes)
0.0

julia&gt; @btime $b[5,2,6,8,5,3,4,5,7]
  32.864 ns (0 allocations: 0 bytes)
0.0"><pre><span class="pl-k">using</span> BenchmarkTools

julia<span class="pl-k">&gt;</span> N <span class="pl-k">=</span> <span class="pl-c1">100</span>;  dim <span class="pl-k">=</span> <span class="pl-c1">2</span>;

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">ntuple</span>(x<span class="pl-k">-&gt;</span>N,dim));
  <span class="pl-c1">2.571</span> μs (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">78.17</span> KiB)

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">zeros</span>(SymmetricTensor{Float64, <span class="pl-k">$</span>N, <span class="pl-k">$</span>dim});
  <span class="pl-c1">6.250</span> μs (<span class="pl-c1">7</span> allocations<span class="pl-k">:</span> <span class="pl-c1">41.45</span> KiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>a[<span class="pl-c1">53</span>, <span class="pl-c1">23</span>]
  <span class="pl-c1">1.900</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">0.0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>b[<span class="pl-c1">53</span>, <span class="pl-c1">23</span>]
  <span class="pl-c1">2.200</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">0.0</span>


julia<span class="pl-k">&gt;</span> N <span class="pl-k">=</span> <span class="pl-c1">100</span>;  dim <span class="pl-k">=</span> <span class="pl-c1">4</span>;

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">ntuple</span>(x<span class="pl-k">-&gt;</span><span class="pl-k">$</span>N, <span class="pl-k">$</span>dim));
  <span class="pl-c1">93.489</span> ms (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">762.94</span> MiB)

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">zeros</span>(SymmetricTensor{Float64, <span class="pl-k">$</span>N, <span class="pl-k">$</span>dim});
  <span class="pl-c1">4.803</span> ms (<span class="pl-c1">9</span> allocations<span class="pl-k">:</span> <span class="pl-c1">33.74</span> MiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>a[<span class="pl-c1">53</span>, <span class="pl-c1">23</span>, <span class="pl-c1">23</span>, <span class="pl-c1">12</span>]
  <span class="pl-c1">1.900</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">0.0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>b[<span class="pl-c1">53</span>, <span class="pl-c1">23</span>, <span class="pl-c1">23</span>, <span class="pl-c1">12</span>]
  <span class="pl-c1">3.300</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">0.0</span>


julia<span class="pl-k">&gt;</span> N <span class="pl-k">=</span> <span class="pl-c1">10</span>;  dim <span class="pl-k">=</span> <span class="pl-c1">9</span>;

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">ntuple</span>(x<span class="pl-k">-&gt;</span><span class="pl-k">$</span>N, <span class="pl-k">$</span>dim));
  <span class="pl-c1">883.687</span> ms (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">7.45</span> GiB)

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">zeros</span>(SymmetricTensor{Float64, <span class="pl-k">$</span>N, <span class="pl-k">$</span>dim});
  <span class="pl-c1">170.900</span> μs (<span class="pl-c1">15</span> allocations<span class="pl-k">:</span> <span class="pl-c1">381.67</span> KiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>a[<span class="pl-c1">5</span>,<span class="pl-c1">2</span>,<span class="pl-c1">6</span>,<span class="pl-c1">8</span>,<span class="pl-c1">5</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>]
  <span class="pl-c1">4.400</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">0.0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>b[<span class="pl-c1">5</span>,<span class="pl-c1">2</span>,<span class="pl-c1">6</span>,<span class="pl-c1">8</span>,<span class="pl-c1">5</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>]
  <span class="pl-c1">32.864</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">0.0</span></pre></div>
<p dir="auto">Even though indexing into a <code>SymmetricTensor</code> is slower than it is into a standard <code>Array</code>, by abusing the symmetry of the underlying data, many basic operations can be made very efficient by applying them to the <code>data</code> field of the tensor directly, instead of on the tensor itself.</p>
<p dir="auto">Example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; N = 5;  dim = 9;

julia&gt; a = rand(SymmetricTensor{Float64, N, dim});

julia&gt; b = a .* 1; # full array

julia&gt; @btime extrema($a)
  72.330 ms (0 allocations: 0 bytes)
(0.0011042800114182683, 0.9971024600776325)

julia&gt; @btime extrema($b)
  3.807 ms (0 allocations: 0 bytes)
(0.0011042800114182683, 0.9971024600776325)

julia&gt; @btime extrema($a.data)
  1.600 μs (0 allocations: 0 bytes)
(0.0011042800114182683, 0.9971024600776325)"><pre>julia<span class="pl-k">&gt;</span> N <span class="pl-k">=</span> <span class="pl-c1">5</span>;  dim <span class="pl-k">=</span> <span class="pl-c1">9</span>;

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, N, dim});

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> a <span class="pl-k">.*</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">#</span> full array</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">extrema</span>(<span class="pl-k">$</span>a)
  <span class="pl-c1">72.330</span> ms (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">0.0011042800114182683</span>, <span class="pl-c1">0.9971024600776325</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">extrema</span>(<span class="pl-k">$</span>b)
  <span class="pl-c1">3.807</span> ms (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">0.0011042800114182683</span>, <span class="pl-c1">0.9971024600776325</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">extrema</span>(<span class="pl-k">$</span>a<span class="pl-k">.</span>data)
  <span class="pl-c1">1.600</span> μs (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">0.0011042800114182683</span>, <span class="pl-c1">0.9971024600776325</span>)</pre></div>
<p dir="auto">In the example above, by calling <code>extrema</code> on the <code>data</code> field, we avoided looping over the vast majority of the elements.</p>
<p dir="auto">The auxiliary functions <code>find_degeneracy</code> and <code>find_full_indices</code> are sometimes useful for implementing efficient computations on a <code>SymmetricTensor</code>.</p>
<p dir="auto">Example 1: find the index of the smallest element in a <code>SymmetricTensor</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; N = 5;  dim = 9;

julia&gt; a = rand(SymmetricTensor{Float64, N, dim});

julia&gt; b = a .* 1; # full array

julia&gt; @btime findmin($a)
  78.533 ms (0 allocations: 0 bytes)
(0.0011042800114182683, CartesianIndex(5, 5, 5, 3, 3, 3, 3, 3, 3))

julia&gt; @btime findmin($b)
  14.663 ms (0 allocations: 0 bytes)
(0.0011042800114182683, CartesianIndex(5, 5, 5, 3, 3, 3, 3, 3, 3))

julia&gt; full_indices = @btime find_full_indices(a);
  10.500 μs (6 allocations: 97.00 KiB)

julia&gt; @btime findmin($a.data)
  1.180 μs (0 allocations: 0 bytes)
(0.0011042800114182683, 670)

julia&gt; full_indices[670]
(5, 5, 5, 3, 3, 3, 3, 3, 3)"><pre>julia<span class="pl-k">&gt;</span> N <span class="pl-k">=</span> <span class="pl-c1">5</span>;  dim <span class="pl-k">=</span> <span class="pl-c1">9</span>;

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, N, dim});

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> a <span class="pl-k">.*</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">#</span> full array</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">findmin</span>(<span class="pl-k">$</span>a)
  <span class="pl-c1">78.533</span> ms (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">0.0011042800114182683</span>, <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">findmin</span>(<span class="pl-k">$</span>b)
  <span class="pl-c1">14.663</span> ms (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">0.0011042800114182683</span>, <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>))

julia<span class="pl-k">&gt;</span> full_indices <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">find_full_indices</span>(a);
  <span class="pl-c1">10.500</span> μs (<span class="pl-c1">6</span> allocations<span class="pl-k">:</span> <span class="pl-c1">97.00</span> KiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">findmin</span>(<span class="pl-k">$</span>a<span class="pl-k">.</span>data)
  <span class="pl-c1">1.180</span> μs (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
(<span class="pl-c1">0.0011042800114182683</span>, <span class="pl-c1">670</span>)

julia<span class="pl-k">&gt;</span> full_indices[<span class="pl-c1">670</span>]
(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>)</pre></div>
<p dir="auto">Example 2: sum of a <code>SymmetricTensor</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; a = rand(SymmetricTensor{Float64, 10, 8});

julia&gt; b = a .* 1; # full array

julia&gt; @btime sum($a)
  2.342 s (0 allocations: 0 bytes)
5.022884033216443e7

julia&gt; @btime sum($b)
  25.777 ms (0 allocations: 0 bytes)
5.022884033248687e7

julia&gt; degeneracy = @btime find_degeneracy($a);
  7.892 ms (193871 allocations: 4.42 MiB)

julia&gt; @btime sum($a.data .* $degeneracy.data) # would be even more efficient with LinearAlgebra.dot...
  13.900 μs (2 allocations: 189.98 KiB)
5.022884033248686e7"><pre>julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(SymmetricTensor{Float64, <span class="pl-c1">10</span>, <span class="pl-c1">8</span>});

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> a <span class="pl-k">.*</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">#</span> full array</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sum</span>(<span class="pl-k">$</span>a)
  <span class="pl-c1">2.342</span> s (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">5.022884033216443e7</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sum</span>(<span class="pl-k">$</span>b)
  <span class="pl-c1">25.777</span> ms (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">5.022884033248687e7</span>

julia<span class="pl-k">&gt;</span> degeneracy <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">find_degeneracy</span>(<span class="pl-k">$</span>a);
  <span class="pl-c1">7.892</span> ms (<span class="pl-c1">193871</span> allocations<span class="pl-k">:</span> <span class="pl-c1">4.42</span> MiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">sum</span>(<span class="pl-k">$</span>a<span class="pl-k">.</span>data <span class="pl-k">.*</span> <span class="pl-k">$</span>degeneracy<span class="pl-k">.</span>data) <span class="pl-c"><span class="pl-c">#</span> would be even more efficient with LinearAlgebra.dot...</span>
  <span class="pl-c1">13.900</span> μs (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">189.98</span> KiB)
<span class="pl-c1">5.022884033248686e7</span></pre></div>
<p dir="auto">Since <code>full_indices</code> and <code>degeneracy</code> depend only on the shape of <code>a</code>, they can often be precomputed for better performance.</p>
<h2 dir="auto"><a id="user-content-implementation" class="anchor" aria-hidden="true" href="#implementation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementation</h2>
<p dir="auto">An instance <code>a</code> of a <code>SymmetricTensor{T, N, dim}</code> contains two fields.</p>
<ul dir="auto">
<li><code>a.data</code> is a <code>Vector{T}</code> that stores all the elements of the symmetric tensor. Its length is given by <code>L = binomial(N-1+dim, dim)</code>, or more conveniently <code>L = find_symmetric_tensor_size(N, dim)</code>.</li>
<li><code>a.linear_indices</code> is a <code>Vector{Vector{Int64}}</code> that is needed when <code>a</code> is indexed. The outer vector has length <code>length(a.linear_indices)</code> equal to <code>dim</code>. The length of the elements of that vector are equal to <code>N</code>. To index a <code>SymmetricTensor{Float64, 50, 3}</code> at indices <code>I = (21, 45, 21)</code>, first the indices are sorted in descending order. Then, the linear index is found by evaluating <code>index = (A.linear_indices[1])[45] + (A.linear_indices[2])[21] + (A.linear_indices[3])[21]</code>. This linear index can now be used to get the value: <code>val = a.data[index]</code>.</li>
</ul>
<p dir="auto">Many methods for operating with <code>SymmetricTensors</code> are implemented using generated functions to provide efficient implementations based on their size.</p>
<h2 dir="auto"><a id="user-content-see-also" class="anchor" aria-hidden="true" href="#see-also"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>See also</h2>
<p dir="auto">There are two packages with comparable functionality, <a href="https://github.com/iitis/SymmetricTensors.jl">SymmetricTensors.jl</a> and <a href="https://github.com/Ferrite-FEM/Tensors.jl">Tensors.jl</a>.</p>
<p dir="auto">Tensors.jl provides immutable, stack-allocated 1-, 2-, and 4-dimensional symmetric tensors. This package is preferable if the tensors are small, that is, when they have fewer than roughly 100 elements. It is also more full-featured, implementing many different operations on the tensors instead of just the basic functionality.</p>
<p dir="auto">SymmetricTensors.jl provides a SymmetricTensor type just like the one exported in this package. Its implementation is based on a blocked memory pattern, sacrificing performance for cache locality. Some benchmarks:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import SymmetricTensors
using BenchmarkTools"><pre><span class="pl-k">import</span> SymmetricTensors
<span class="pl-k">using</span> BenchmarkTools</pre></div>
<p dir="auto">Tensor creation:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; T = Float64;
julia&gt; N = 30;
julia&gt; dim = 5;

julia&gt; a  = @btime rand(SymmetricTensors.SymmetricTensor{$T, $dim}, $N);
  2.601 s (21697571 allocations: 1.00 GiB)

julia&gt; sizeof(a.frame)
6075000

julia&gt; b  = @btime rand(PermutationSymmetricTensors.SymmetricTensor{$T, $N, $dim});
  642.400 μs (10 allocations: 2.12 MiB)

julia&gt; sizeof(b)
2227288"><pre>julia<span class="pl-k">&gt;</span> T <span class="pl-k">=</span> Float64;
julia<span class="pl-k">&gt;</span> N <span class="pl-k">=</span> <span class="pl-c1">30</span>;
julia<span class="pl-k">&gt;</span> dim <span class="pl-k">=</span> <span class="pl-c1">5</span>;

julia<span class="pl-k">&gt;</span> a  <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">rand</span>(SymmetricTensors<span class="pl-k">.</span>SymmetricTensor{<span class="pl-k">$</span>T, <span class="pl-k">$</span>dim}, <span class="pl-k">$</span>N);
  <span class="pl-c1">2.601</span> s (<span class="pl-c1">21697571</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.00</span> GiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(a<span class="pl-k">.</span>frame)
<span class="pl-c1">6075000</span>

julia<span class="pl-k">&gt;</span> b  <span class="pl-k">=</span> <span class="pl-c1">@btime</span> <span class="pl-c1">rand</span>(PermutationSymmetricTensors<span class="pl-k">.</span>SymmetricTensor{<span class="pl-k">$</span>T, <span class="pl-k">$</span>N, <span class="pl-k">$</span>dim});
  <span class="pl-c1">642.400</span> μs (<span class="pl-c1">10</span> allocations<span class="pl-k">:</span> <span class="pl-c1">2.12</span> MiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sizeof</span>(b)
<span class="pl-c1">2227288</span></pre></div>
<p dir="auto"><code>getindex</code> and <code>setindex!</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @btime $a[1,5,2,5,21];
  2.189 μs (24 allocations: 1.38 KiB)

julia&gt; @btime $a[1,5,2,5,21] = 6.0;
  50.800 μs (767 allocations: 51.06 KiB)

julia&gt; @btime $b[1,5,2,5,21];
  4.200 ns (0 allocations: 0 bytes)

julia&gt; @btime $b[1,5,2,5,21] = 6.0;
  4.500 ns (0 allocations: 0 bytes)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>a[<span class="pl-c1">1</span>,<span class="pl-c1">5</span>,<span class="pl-c1">2</span>,<span class="pl-c1">5</span>,<span class="pl-c1">21</span>];
  <span class="pl-c1">2.189</span> μs (<span class="pl-c1">24</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.38</span> KiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>a[<span class="pl-c1">1</span>,<span class="pl-c1">5</span>,<span class="pl-c1">2</span>,<span class="pl-c1">5</span>,<span class="pl-c1">21</span>] <span class="pl-k">=</span> <span class="pl-c1">6.0</span>;
  <span class="pl-c1">50.800</span> μs (<span class="pl-c1">767</span> allocations<span class="pl-k">:</span> <span class="pl-c1">51.06</span> KiB)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>b[<span class="pl-c1">1</span>,<span class="pl-c1">5</span>,<span class="pl-c1">2</span>,<span class="pl-c1">5</span>,<span class="pl-c1">21</span>];
  <span class="pl-c1">4.200</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>b[<span class="pl-c1">1</span>,<span class="pl-c1">5</span>,<span class="pl-c1">2</span>,<span class="pl-c1">5</span>,<span class="pl-c1">21</span>] <span class="pl-k">=</span> <span class="pl-c1">6.0</span>;
  <span class="pl-c1">4.500</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)</pre></div>
</article></div>