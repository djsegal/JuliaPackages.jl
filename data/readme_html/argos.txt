<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-argosjl" class="anchor" aria-hidden="true" href="#argosjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Argos.jl</h1>
<p dir="auto"><a href="https://exanauts.github.io/Argos.jl/" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a> <a href="https://github.com/exanauts/Argos.jl/actions?query=workflow"><img src="https://github.com/exanauts/Argos.jl/workflows/Run%20tests/badge.svg?branch=master" alt="" style="max-width: 100%;"></a> <a href="https://codecov.io/github/exanauts/Argos.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/ba4de4284a45776fea7b649b3c5a407b7b65d390d0164f32a89af20a6d458e7b/68747470733a2f2f636f6465636f762e696f2f67682f6578616e617574732f4172676f732e6a6c2f6272616e63682f6d61737465722f6772617068732f62616467652e7376673f6272616e63683d6d6173746572" alt="" data-canonical-src="https://codecov.io/gh/exanauts/Argos.jl/branch/master/graphs/badge.svg?branch=master" style="max-width: 100%;"></a> <a href="https://zenodo.org/badge/latestdoi/307942526" rel="nofollow"><img src="https://camo.githubusercontent.com/b24a029de95befad24d7c8d42f1f895321a729b23592219e695a49d163237df7/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3330373934323532362e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/307942526.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Argos.jl extends the power-system modeler <a href="https://github.com/exanauts/ExaPF.jl">ExaPF.jl</a>
and the interior-point solver <a href="https://github.com/MadNLP/MadNLP.jl">MadNLP.jl</a>
to solve optimal power flow (OPF) problems entirely in Julia.</p>
<p dir="auto">The package is structured as follows:</p>
<ul dir="auto">
<li>in <code>src/Evaluators/</code>, various optimization evaluators implement the different callbacks (objective, gradient, Hessian)
required in the optimization algorithms.</li>
<li>in <code>src/Algorithms/</code>, an Augmented Lagrangian algorithm is implemented, targeting
primarily the resolution of large-scale OPF problems on GPU architectures.</li>
<li>in <code>src/Wrappers/</code>, a wrapper for <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface</a> and a wrapper for <a href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/">NLPModels.jl</a> are implemented.</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">One can install Argos with the default package manager:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add Argos"><pre>add Argos</pre></div>
<p dir="auto">To check that everything is working as expected, please run</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="test Argos"><pre>test Argos</pre></div>
<p dir="auto">By default, this command tests all the <code>Evaluators</code> implemented in Argos
on the CPU and, if available, on a CUDA GPU.</p>
<h2 dir="auto"><a id="user-content-quickstart" class="anchor" aria-hidden="true" href="#quickstart"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quickstart</h2>
<p dir="auto">The function <code>run_opf</code> is the entry point to Argos.
It takes as input a path to a MATPOWER file and solves the associated OPF with MadNLP:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Solve in the full-space
ips = Argos.run_opf(&quot;data/case9.m&quot;, Argos.FullSpace())
"><pre><span class="pl-c"><span class="pl-c">#</span> Solve in the full-space</span>
ips <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">run_opf</span>(<span class="pl-s"><span class="pl-pds">"</span>data/case9.m<span class="pl-pds">"</span></span>, Argos<span class="pl-k">.</span><span class="pl-c1">FullSpace</span>())
</pre></div>
<p dir="auto">The second argument specifies the formulation used inside MadNLP to solve
the OPF problem. <code>FullSpace()</code> implements the classical full-space formulation,
(as implemented inside <a href="https://matpower.org/" rel="nofollow">MATPOWER</a> or
<a href="https://github.com/lanl-ansi/PowerModels.jl">PowerModels.jl</a>). Alternatively,
one may want to solve the OPF using the reduced-space formulation of Dommel and
Tinney:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Solve in the reduced-space
ips = Argos.run_opf(&quot;data/case9.m&quot;, Argos.DommelTinney())
"><pre><span class="pl-c"><span class="pl-c">#</span> Solve in the reduced-space</span>
ips <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">run_opf</span>(<span class="pl-s"><span class="pl-pds">"</span>data/case9.m<span class="pl-pds">"</span></span>, Argos<span class="pl-k">.</span><span class="pl-c1">DommelTinney</span>())
</pre></div>
<h2 dir="auto"><a id="user-content-how-to-use-argos-evaluators" class="anchor" aria-hidden="true" href="#how-to-use-argos-evaluators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use Argos' evaluators?</h2>
<p dir="auto">Argos implements two evaluators to solve the OPF problem:
the <code>FullSpaceEvaluator</code> implements the classical OPF formulation
in the full-space, whereas <code>ReducedSpaceEvaluator</code> implements the
reduced-space formulation of Dommel &amp; Tinney.</p>
<h3 dir="auto"><a id="user-content-using-an-evaluator" class="anchor" aria-hidden="true" href="#using-an-evaluator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using an evaluator</h3>
<p dir="auto">Instantiating a new evaluator from a MATPOWER file simply amounts to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Reduced-space evaluator
nlp = Argos.ReducedSpaceEvaluator(&quot;case57.m&quot;)
# Full-space evaluator
flp = Argos.FullSpaceEvaluator(&quot;case57.m&quot;)"><pre><span class="pl-c"><span class="pl-c">#</span> Reduced-space evaluator</span>
nlp <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">ReducedSpaceEvaluator</span>(<span class="pl-s"><span class="pl-pds">"</span>case57.m<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">#</span> Full-space evaluator</span>
flp <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">FullSpaceEvaluator</span>(<span class="pl-s"><span class="pl-pds">"</span>case57.m<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">An initial optimization variable can be computed as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="u = Argos.initial(nlp)"><pre>u <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">initial</span>(nlp)</pre></div>
<p dir="auto">The variable <code>u</code> is the control that will be used throughout the
optimization. Once a new point <code>u</code> obtained, one can refresh all the structures
inside <code>nlp</code> with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Argos.update!(nlp, u)"><pre>Argos<span class="pl-k">.</span><span class="pl-c1">update!</span>(nlp, u)</pre></div>
<p dir="auto">Once the structures are refreshed, the other callbacks can be evaluated as well:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Argos.objective(nlp, u) # objective
Argos.gradient(nlp, u)  # reduced gradient
Argos.jacobian(nlp, u)  # reduced Jacobian
Argos.hessian(nlp, u)   # reduced Hessian"><pre>Argos<span class="pl-k">.</span><span class="pl-c1">objective</span>(nlp, u) <span class="pl-c"><span class="pl-c">#</span> objective</span>
Argos<span class="pl-k">.</span><span class="pl-c1">gradient</span>(nlp, u)  <span class="pl-c"><span class="pl-c">#</span> reduced gradient</span>
Argos<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(nlp, u)  <span class="pl-c"><span class="pl-c">#</span> reduced Jacobian</span>
Argos<span class="pl-k">.</span><span class="pl-c1">hessian</span>(nlp, u)   <span class="pl-c"><span class="pl-c">#</span> reduced Hessian</span></pre></div>
<h3 dir="auto"><a id="user-content-moi-wrapper" class="anchor" aria-hidden="true" href="#moi-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MOI wrapper</h3>
<p dir="auto">Argos implements a wrapper to <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface</a>
to solve the optimal power flow problem with any nonlinear optimization solver compatible
with MathOptInterface:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="nlp = Argos.ReducedSpaceEvaluator(&quot;case57.m&quot;)
optimizer = Ipopt.Optimizer() # MOI optimizer
# Update tolerance to be above tolerance of Newton-Raphson subsolver
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;tol&quot;), 1e-5)
# Solve reduced space problem
solution = Argos.optimize!(optimizer, nlp)"><pre>nlp <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">ReducedSpaceEvaluator</span>(<span class="pl-s"><span class="pl-pds">"</span>case57.m<span class="pl-pds">"</span></span>)
optimizer <span class="pl-k">=</span> Ipopt<span class="pl-k">.</span><span class="pl-c1">Optimizer</span>() <span class="pl-c"><span class="pl-c">#</span> MOI optimizer</span>
<span class="pl-c"><span class="pl-c">#</span> Update tolerance to be above tolerance of Newton-Raphson subsolver</span>
MOI<span class="pl-k">.</span><span class="pl-c1">set</span>(optimizer, MOI<span class="pl-k">.</span><span class="pl-c1">RawOptimizerAttribute</span>(<span class="pl-s"><span class="pl-pds">"</span>tol<span class="pl-pds">"</span></span>), <span class="pl-c1">1e-5</span>)
<span class="pl-c"><span class="pl-c">#</span> Solve reduced space problem</span>
solution <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">optimize!</span>(optimizer, nlp)</pre></div>
<h3 dir="auto"><a id="user-content-nlpmodels-wrapper" class="anchor" aria-hidden="true" href="#nlpmodels-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NLPModels wrapper</h3>
<p dir="auto">Alternatively, one can use NLPModels.jl to wrap any evaluators implemented
in Argos. This amounts simply to:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="nlp = Argos.FullSpaceEvaluator(&quot;case57.m&quot;)
# Wrap in NLPModels
model = Argos.OPFModel(nlp)

x0 = NLPModels.get_x0(model)
obj = NLPModels.obj(model, x0)
"><pre>nlp <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">FullSpaceEvaluator</span>(<span class="pl-s"><span class="pl-pds">"</span>case57.m<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">#</span> Wrap in NLPModels</span>
model <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">OPFModel</span>(nlp)

x0 <span class="pl-k">=</span> NLPModels<span class="pl-k">.</span><span class="pl-c1">get_x0</span>(model)
obj <span class="pl-k">=</span> NLPModels<span class="pl-k">.</span><span class="pl-c1">obj</span>(model, x0)
</pre></div>
<p dir="auto">Once the evaluator is wrapped inside NLPModels.jl, we can leverage any
solver implemented in <a href="https://github.com/JuliaSmoothOptimizers/">JuliaSmoothOptimizers</a>
to solve the OPF problem.</p>
<h2 dir="auto"><a id="user-content-how-to-deport-the-solution-of-the-opf-on-the-gpu" class="anchor" aria-hidden="true" href="#how-to-deport-the-solution-of-the-opf-on-the-gpu"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to deport the solution of the OPF on the GPU?</h2>
<p dir="auto"><a href="https://github.com/exanauts/ExaPF.jl"><code>ExaPF.jl</code></a> is
using <a href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions</code></a>
to implement all its core operations. Hence, deporting the computation
on GPU accelerators is straightforward. Argos.jl inherits this behavior and
all evaluators can be instantiated on GPU accelerators, simply as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CUDAKernels # Load CUDA backend for KernelAbstractions
using ArgosCUDA
nlp = Argos.ReducedSpaceEvaluator(&quot;case57.m&quot;; device=CUDADevice())"><pre><span class="pl-k">using</span> CUDAKernels <span class="pl-c"><span class="pl-c">#</span> Load CUDA backend for KernelAbstractions</span>
<span class="pl-k">using</span> ArgosCUDA
nlp <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">ReducedSpaceEvaluator</span>(<span class="pl-s"><span class="pl-pds">"</span>case57.m<span class="pl-pds">"</span></span>; device<span class="pl-k">=</span><span class="pl-c1">CUDADevice</span>())</pre></div>
<p dir="auto">When doing so, all kernels are instantiated on the GPU to avoid
memory transfer between the host and the device. The sparse linear
algebra operations are handled by <code>cuSPARSE</code>, and the sparse factorizations
are performed using <code>cusolverRF</code> via the Julia wrapper <a href="https://github.com/exanauts/CUSOLVERRF.jl">CUSOLVERRF.jl</a>.
This package is loaded via the included <code>ArgosCUDA.jl</code> package in <code>/lib</code>.
When deporting the computation on the GPU, the reduced Hessian can be evaluated
in parallel.</p>
<h3 dir="auto"><a id="user-content-batch-evaluation-of-the-reduced-hessian" class="anchor" aria-hidden="true" href="#batch-evaluation-of-the-reduced-hessian"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Batch evaluation of the reduced Hessian</h3>
<p dir="auto">Instead of computing the reduced Hessian one Hessian-vector product after one Hessian-vector product,
the Hessian-vector products can be evaluated in batch.
To activate the batch evaluation for the reduced Hessian, please specify
the number of Hessian-vector products to perform in one batch as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="nlp = Argos.ReducedSpaceEvaluator(&quot;case57.m&quot;; device=CUDADevice(), nbatch_hessian=8)"><pre>nlp <span class="pl-k">=</span> Argos<span class="pl-k">.</span><span class="pl-c1">ReducedSpaceEvaluator</span>(<span class="pl-s"><span class="pl-pds">"</span>case57.m<span class="pl-pds">"</span></span>; device<span class="pl-k">=</span><span class="pl-c1">CUDADevice</span>(), nbatch_hessian<span class="pl-k">=</span><span class="pl-c1">8</span>)</pre></div>
<p dir="auto">Note that on large instances, the batch computation can be demanding in terms of GPU's memory.</p>
</article></div>