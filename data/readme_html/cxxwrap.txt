<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-cxxwrap" class="anchor" aria-hidden="true" href="#cxxwrap"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>CxxWrap</h1>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/JuliaInterop/CxxWrap.jl/workflows/test/badge.svg"><img src="https://github.com/JuliaInterop/CxxWrap.jl/workflows/test/badge.svg" alt="test" style="max-width: 100%;"></a></p>
<p dir="auto">This package aims to provide a Boost.Python-like wrapping for C++ types and functions to Julia.
The idea is to write the code for the Julia wrapper in C++, and then use a one-liner on the Julia side to make the wrapped C++ library available there.</p>
<p dir="auto">The mechanism behind this package is that functions and types are registered in C++ code that is compiled into a dynamic library.
This dynamic library is then loaded into Julia, where the Julia part of this package uses the data provided through a C interface to generate functions accessible from Julia.
The functions are passed to Julia either as raw function pointers (for regular C++ functions that  don't need argument or return type conversion) or std::functions (for lambda expressions and automatic conversion of arguments and return types).
The Julia side of this package wraps all this into Julia methods automatically.</p>
<p dir="auto">For this to work, the user must have a C++ compiler installed which supports C++17
(e.g. GCC 7, clang 5; for macOS users that means Xcode 9.3).</p>
<h2 dir="auto"><a id="user-content-whats-the-difference-with-cxxjl" class="anchor" aria-hidden="true" href="#whats-the-difference-with-cxxjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What's the difference with Cxx.jl?</h2>
<p dir="auto">With <a href="https://github.com/Keno/Cxx.jl/">Cxx.jl</a> it is possible to directly access C++ using the <code>@cxx</code> macro from Julia.
So when facing the task of wrapping a C++ library in a Julia package, authors now have two options:</p>
<ul dir="auto">
<li>Use Cxx.jl to write the wrapper package in Julia code (much like one uses <code>ccall</code> for wrapping a C library)</li>
<li>Use CxxWrap to write the wrapper completely in C++ (and one line of Julia code to load the .so)</li>
</ul>
<p dir="auto">Boost.Python also uses the latter (C++-only) approach, so translating existing Python bindings based on Boost.Python may be easier using CxxWrap.</p>
<h2 dir="auto"><a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features</h2>
<ul dir="auto">
<li>Support for C++ functions, member functions and lambdas</li>
<li>Classes with single inheritance, using abstract base classes on the Julia side</li>
<li>Trivial C++ classes can be converted to a Julia isbits immutable</li>
<li>Template classes map to parametric types, for the instantiations listed in the wrapper</li>
<li>Automatic wrapping of default and copy constructor (mapped to <code>copy</code>) if defined on the wrapped C++ class</li>
<li>Facilitate calling Julia functions from C++</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Just like any registered package, in pkg mode (<code>]</code> at the REPL)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add CxxWrap"><pre>add CxxWrap</pre></div>
<p dir="auto">CxxWrap v0.10 and later depends on the <code>libcxxwrap_julia_jll</code> <a href="https://julialang.org/blog/2019/11/artifacts/" rel="nofollow">JLL package</a> to manage the <code>libcxxwrap-julia</code> binaries. See the <a href="https://github.com/JuliaInterop/libcxxwrap-julia">libcxxwrap-julia Readme</a> for information on how to build this library yourself and force CxxWrap to use your own version.</p>
<h2 dir="auto"><a id="user-content-boost-python-hello-world-example" class="anchor" aria-hidden="true" href="#boost-python-hello-world-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Boost Python Hello World example</h2>
<p dir="auto">Let's try to reproduce the example from the <a href="http://www.boost.org/doc/libs/1_59_0/libs/python/doc/tutorial/doc/html/index.html" rel="nofollow">Boost.Python tutorial</a>.
Suppose we want to expose the following C++ function to Julia in a module called <code>CppHello</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="std::string greet()
{
   return &quot;hello, world&quot;;
}"><pre>std::string <span class="pl-en">greet</span>()
{
   <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>hello, world<span class="pl-pds">"</span></span>;
}</pre></div>
<p dir="auto">Using the C++ side of <code>CxxWrap</code>, this can be exposed as follows:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;jlcxx/jlcxx.hpp&quot;

JLCXX_MODULE define_julia_module(jlcxx::Module&amp; mod)
{
  mod.method(&quot;greet&quot;, &amp;greet);
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jlcxx/jlcxx.hpp<span class="pl-pds">"</span></span>

JLCXX_MODULE <span class="pl-en">define_julia_module</span>(jlcxx::Module&amp; mod)
{
  mod.<span class="pl-c1">method</span>(<span class="pl-s"><span class="pl-pds">"</span>greet<span class="pl-pds">"</span></span>, &amp;greet);
}</pre></div>
<p dir="auto">Once this code is compiled into a shared library (say <code>libhello.so</code>) it can be used in Julia as follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Load the module and generate the functions
module CppHello
  using CxxWrap
  @wrapmodule(joinpath(&quot;path/to/built/lib&quot;,&quot;libhello&quot;))

  function __init__()
    @initcxx
  end
end

# Call greet and show the result
@show CppHello.greet()"><pre><span class="pl-c"><span class="pl-c">#</span> Load the module and generate the functions</span>
<span class="pl-k">module</span> CppHello
  <span class="pl-k">using</span> CxxWrap
  <span class="pl-c1">@wrapmodule</span>(<span class="pl-c1">joinpath</span>(<span class="pl-s"><span class="pl-pds">"</span>path/to/built/lib<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>libhello<span class="pl-pds">"</span></span>))

  <span class="pl-k">function</span> <span class="pl-en">__init__</span>()
    <span class="pl-c1">@initcxx</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Call greet and show the result</span>
<span class="pl-c1">@show</span> CppHello<span class="pl-k">.</span><span class="pl-c1">greet</span>()</pre></div>
<p dir="auto">The code for this example can be found in [<code>hello.cpp</code>] in the <a href="https://github.com/JuliaInterop/libcxxwrap-julia/tree/master/examples">examples directory of the <code>libcxxwrap-julia</code> project</a> and <a href="test/hello.jl"><code>test/hello.jl</code></a>.
Note that the <code>__init__</code> function is necessary to support precompilation, which is on by default since Julia 1.0.</p>
<h2 dir="auto"><a id="user-content-compiling-the-c-code" class="anchor" aria-hidden="true" href="#compiling-the-c-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Compiling the C++ code</h2>
<p dir="auto">The recommended way to compile the C++ code is to use CMake to discover <code>libcxxwrap-julia</code> and the Julia libraries.
A full example is in the <a href="https://github.com/JuliaInterop/libcxxwrap-julia/tree/master/testlib-builder/src/testlib"><code>testlib</code> directory of <code>libcxxwrap-julia</code></a>.
The following sequence of commands can be used to build:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mkdir build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix /path/to/sourcedirectory
cmake --build . --config Release"><pre>mkdir build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix /path/to/sourcedirectory
cmake --build <span class="pl-c1">.</span> --config Release</pre></div>
<p dir="auto">The path for <code>CMAKE_PREFIX_PATH</code> can be obtained from Julia using:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using CxxWrap
julia&gt; CxxWrap.prefix_path()"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> CxxWrap
julia<span class="pl-k">&gt;</span> CxxWrap<span class="pl-k">.</span><span class="pl-c1">prefix_path</span>()</pre></div>
<h3 dir="auto"><a id="user-content-windows-and-msvc" class="anchor" aria-hidden="true" href="#windows-and-msvc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Windows and MSVC</h3>
<p dir="auto">The default binaries installed with CxxWrap are cross-compiled using GCC, and thus incompatible with Visual Studio C++ (MSVC).
In MSVC 2019, it is easy to check out <code>libcxxwrap-julia</code> from git, and then build it and the wrapper module from source.
Details are provided in the <a href="https://github.com/JuliaInterop/libcxxwrap-julia#building-on-windows">README</a>.</p>
<h2 dir="auto"><a id="user-content-module-entry-point" class="anchor" aria-hidden="true" href="#module-entry-point"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Module entry point</h2>
<p dir="auto">Above, we defined the module entry point as a function <code>JLCXX_MODULE define_julia_module(jlcxx::Module&amp; mod)</code>.
In the general case, there may be multiple modules defined in a single library, and each should have its own entry point, called within the appropriate module:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="JLCXX_MODULE define_module_a(jlcxx::Module&amp; mod)
{
  // add stuff for A
}

JLCXX_MODULE define_module_b(jlcxx::Module&amp; mod)
{
  // add stuff for B
}"><pre>JLCXX_MODULE <span class="pl-en">define_module_a</span>(jlcxx::Module&amp; mod)
{
  <span class="pl-c"><span class="pl-c">//</span> add stuff for A</span>
}

JLCXX_MODULE <span class="pl-en">define_module_b</span>(jlcxx::Module&amp; mod)
{
  <span class="pl-c"><span class="pl-c">//</span> add stuff for B</span>
}</pre></div>
<p dir="auto">In Julia, the name of the entry point must now be specified explicitly:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module A
  using CxxWrap
  @wrapmodule(&quot;mylib.so&quot;,:define_module_a)
end

module B
  using CxxWrap
  @wrapmodule(&quot;mylib.so&quot;,:define_module_b)
end"><pre><span class="pl-k">module</span> A
  <span class="pl-k">using</span> CxxWrap
  <span class="pl-c1">@wrapmodule</span>(<span class="pl-s"><span class="pl-pds">"</span>mylib.so<span class="pl-pds">"</span></span>,<span class="pl-c1">:define_module_a</span>)
<span class="pl-k">end</span>

<span class="pl-k">module</span> B
  <span class="pl-k">using</span> CxxWrap
  <span class="pl-c1">@wrapmodule</span>(<span class="pl-s"><span class="pl-pds">"</span>mylib.so<span class="pl-pds">"</span></span>,<span class="pl-c1">:define_module_b</span>)
<span class="pl-k">end</span></pre></div>
<p dir="auto">In specific cases, it may also be necessary to specify <code>dlopen</code> flags such as <code>RTLD_GLOBAL</code>.
These can be supplied in a third, optional argument to <code>@wrapmodule</code>, e.g:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@wrapmodule(CxxWrapCore.libcxxwrap_julia_stl, :define_cxxwrap_stl_module, Libdl.RTLD_GLOBAL)"><pre><span class="pl-c1">@wrapmodule</span>(CxxWrapCore<span class="pl-k">.</span>libcxxwrap_julia_stl, <span class="pl-c1">:define_cxxwrap_stl_module</span>, Libdl<span class="pl-k">.</span>RTLD_GLOBAL)</pre></div>
<h2 dir="auto"><a id="user-content-more-extensive-example-and-function-call-performance" class="anchor" aria-hidden="true" href="#more-extensive-example-and-function-call-performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>More extensive example and function call performance</h2>
<p dir="auto">A more extensive example, including wrapping a C++11 lambda and conversion for arrays can be found in <a href="https://github.com/JuliaInterop/libcxxwrap-julia/tree/master/examples/functions.cpp"><code>examples/functions.cpp</code></a> and <a href="test/functions.jl"><code>test/functions.jl</code></a>.
This test also includes some performance measurements, showing that the function call overhead is the same as using <code>ccall</code> on a C function if the C++ function is a regular function and does not require argument conversion.
When <code>std::function</code> is used (e.g. for C++ lambdas) extra overhead appears, as expected.</p>
<h2 dir="auto"><a id="user-content-exposing-classes" class="anchor" aria-hidden="true" href="#exposing-classes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Exposing classes</h2>
<p dir="auto">Consider the following C++ class to be wrapped:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct World
{
  World(const std::string&amp; message = &quot;default hello&quot;) : msg(message){}
  void set(const std::string&amp; msg) { this-&gt;msg = msg; }
  std::string greet() { return msg; }
  std::string msg;
  ~World() { std::cout &lt;&lt; &quot;Destroying World with message &quot; &lt;&lt; msg &lt;&lt; std::endl; }
};"><pre><span class="pl-k">struct</span> <span class="pl-en">World</span>
{
  <span class="pl-en">World</span>(<span class="pl-k">const</span> std::string&amp; message = <span class="pl-s"><span class="pl-pds">"</span>default hello<span class="pl-pds">"</span></span>) : msg(message){}
  <span class="pl-k">void</span> <span class="pl-en">set</span>(<span class="pl-k">const</span> std::string&amp; msg) { <span class="pl-c1">this</span>-&gt;<span class="pl-smi">msg</span> = msg; }
  std::string <span class="pl-en">greet</span>() { <span class="pl-k">return</span> msg; }
  std::string msg;
  <span class="pl-en">~World</span>() { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Destroying World with message <span class="pl-pds">"</span></span> &lt;&lt; msg &lt;&lt; std::endl; }
};</pre></div>
<p dir="auto">Wrapped in the entry point function as before and defining a module <code>CppTypes</code>, the code for exposing the type and some methods to Julia is:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="types.add_type&lt;World&gt;(&quot;World&quot;)
  .constructor&lt;const std::string&amp;&gt;()
  .method(&quot;set&quot;, &amp;World::set)
  .method(&quot;greet&quot;, &amp;World::greet);"><pre>types.add_type&lt;World&gt;(<span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span>)
  .constructor&lt;<span class="pl-k">const</span> std::string&amp;&gt;()
  .method(<span class="pl-s"><span class="pl-pds">"</span>set<span class="pl-pds">"</span></span>, &amp;World::set)
  .method(<span class="pl-s"><span class="pl-pds">"</span>greet<span class="pl-pds">"</span></span>, &amp;World::greet);</pre></div>
<p dir="auto">Here, the first line just adds the type.
The second line adds the non-default constructor taking a string.
Finally, the two <code>method</code> calls add member functions, using a pointer-to-member.
The member functions become free functions in Julia, taking their object as the first argument.
This can now be used in Julia as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="w = CppTypes.World()
@test CppTypes.greet(w) == &quot;default hello&quot;
CppTypes.set(w, &quot;hello&quot;)
@test CppTypes.greet(w) == &quot;hello&quot;"><pre>w <span class="pl-k">=</span> CppTypes<span class="pl-k">.</span><span class="pl-c1">World</span>()
<span class="pl-c1">@test</span> CppTypes<span class="pl-k">.</span><span class="pl-c1">greet</span>(w) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>default hello<span class="pl-pds">"</span></span>
CppTypes<span class="pl-k">.</span><span class="pl-c1">set</span>(w, <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>)
<span class="pl-c1">@test</span> CppTypes<span class="pl-k">.</span><span class="pl-c1">greet</span>(w) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">The manually added constructor using the <code>constructor</code> function also creates a finalizer.
This can be disabled by adding the argument <code>false</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="types.add_type&lt;World&gt;(&quot;World&quot;)
  .constructor&lt;const std::string&amp;&gt;(false);"><pre>types.add_type&lt;World&gt;(<span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span>)
  .constructor&lt;<span class="pl-k">const</span> std::string&amp;&gt;(<span class="pl-c1">false</span>);</pre></div>
<p dir="auto">The <code>add_type</code> function actually builds two Julia types related to <code>World</code>.
The first is an abstract type:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="abstract type World end"><pre><span class="pl-k">abstract type</span> World <span class="pl-k">end</span></pre></div>
<p dir="auto">The second is a mutable type (the "allocated" or "boxed" type) with the following structure:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mutable struct WorldAllocated &lt;: World
  cpp_object::Ptr{Cvoid}
end"><pre><span class="pl-k">mutable struct</span> WorldAllocated <span class="pl-k">&lt;:</span> <span class="pl-c1">World</span>
  cpp_object<span class="pl-k">::</span><span class="pl-c1">Ptr{Cvoid}</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">This type needs to be mutable, because it must have a finalizer attached to it that deletes the held C++ object.</p>
<p dir="auto">This means that the variable <code>w</code> in the above example is of concrete type <code>WorldAllocated</code> and letting it go out of scope may trigger the finalizer and delete the object.
When calling a C++ constructor, it is the responsibility of the caller to manage the lifetime of the resulting variable.</p>
<p dir="auto">The above types are used in method generation as follows, considering for example the greet method taking a <code>World</code> argument:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="greet(w::World) = ccall($fpointer, Any, (Ptr{Cvoid}, WorldRef), $thunk, cconvert(WorldRef, w))"><pre><span class="pl-en">greet</span>(w<span class="pl-k">::</span><span class="pl-c1">World</span>) <span class="pl-k">=</span> <span class="pl-c1">ccall</span>(<span class="pl-k">$</span>fpointer, Any, (Ptr{Cvoid}, WorldRef), <span class="pl-k">$</span>thunk, <span class="pl-c1">cconvert</span>(WorldRef, w))</pre></div>
<p dir="auto">Here, the <code>cconvert</code> from <code>WorldAllocated</code> to <code>WorldRef</code> is defined automatically when creating the type.</p>
<p dir="auto"><strong>Warning:</strong> The ordering of the C++ code matters: types used as function arguments or return types must be added before they are used in a function.</p>
<p dir="auto">The full code for this example and more info on immutables and bits types can be found in <a href="https://github.com/JuliaInterop/libcxxwrap-julia/tree/master/examples/types.cpp"><code>examples/types.cpp</code></a> and <a href="test/types.jl"><code>test/types.jl</code></a>.</p>
<h3 dir="auto"><a id="user-content-checking-for-null" class="anchor" aria-hidden="true" href="#checking-for-null"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Checking for null</h3>
<p dir="auto">Values returned from C++ can be checked for being null using the <code>isnull</code> function.</p>
<h2 dir="auto"><a id="user-content-setting-the-module-to-which-methods-are-added" class="anchor" aria-hidden="true" href="#setting-the-module-to-which-methods-are-added"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Setting the module to which methods are added</h2>
<p dir="auto">It is possible to add methods directly to e.g. the Julia <code>Base</code> module, using <code>set_override_module</code>.
After calling this, all methods will be added to the specified module.
To revert to the default behavior of adding methods to the current module, call <code>unset_override_module</code>.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mod.add_type&lt;A&gt;(&quot;A&quot;, jlcxx::julia_type(&quot;AbstractFloat&quot;, &quot;Base&quot;))
    .constructor&lt;double&gt;();
mod.set_override_module(mod.julia_module());
// == will be in the wrapped module:
mod.method(&quot;==&quot;, [](A&amp; a, A&amp; b) { return a == b; });
mod.set_override_module(jl_base_module);
// The following methods will be in Base
mod.method(&quot;+&quot;, [](A&amp; a, A&amp; b) { return a + b; });
mod.method(&quot;float&quot;, [](A&amp; a) { return a.get_val(); });
// Revert to default behavior
mod.unset_override_module();
mod.method(&quot;val&quot;, [](A&amp; a) { return a.get_val(); });"><pre>mod.add_type&lt;A&gt;(<span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, jlcxx::julia_type(<span class="pl-s"><span class="pl-pds">"</span>AbstractFloat<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Base<span class="pl-pds">"</span></span>))
    .constructor&lt;<span class="pl-k">double</span>&gt;();
mod.set_override_module(mod.julia_module());
<span class="pl-c"><span class="pl-c">//</span> == will be in the wrapped module:</span>
mod.method(<span class="pl-s"><span class="pl-pds">"</span>==<span class="pl-pds">"</span></span>, [](A&amp; a, A&amp; b) { <span class="pl-k">return</span> a == b; });
mod.set_override_module(jl_base_module);
<span class="pl-c"><span class="pl-c">//</span> The following methods will be in Base</span>
mod.method(<span class="pl-s"><span class="pl-pds">"</span>+<span class="pl-pds">"</span></span>, [](A&amp; a, A&amp; b) { <span class="pl-k">return</span> a + b; });
mod.method(<span class="pl-s"><span class="pl-pds">"</span>float<span class="pl-pds">"</span></span>, [](A&amp; a) { <span class="pl-k">return</span> a.<span class="pl-c1">get_val</span>(); });
<span class="pl-c"><span class="pl-c">//</span> Revert to default behavior</span>
mod.unset_override_module();
mod.method(<span class="pl-s"><span class="pl-pds">"</span>val<span class="pl-pds">"</span></span>, [](A&amp; a) { <span class="pl-k">return</span> a.<span class="pl-c1">get_val</span>(); });</pre></div>
<h2 dir="auto"><a id="user-content-inheritance" class="anchor" aria-hidden="true" href="#inheritance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Inheritance</h2>
<p dir="auto">To encapsulate inheritance, types must first inherit from each other in C++, so a <code>static_cast</code> to the base type can work:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct A
{
  virtual std::string message() const = 0;
  std::string data = &quot;mydata&quot;;
};

struct B : A
{
  virtual std::string message() const
  {
    return &quot;B&quot;;
  }
};"><pre><span class="pl-k">struct</span> <span class="pl-en">A</span>
{
  <span class="pl-k">virtual</span> std::string <span class="pl-en">message</span>() <span class="pl-k">const</span> = 0;
  std::string data = <span class="pl-s"><span class="pl-pds">"</span>mydata<span class="pl-pds">"</span></span>;
};

<span class="pl-k">struct</span> <span class="pl-en">B</span> : A
{
  <span class="pl-k">virtual</span> std::string <span class="pl-en">message</span>() <span class="pl-k">const</span>
  {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>;
  }
};</pre></div>
<p dir="auto">When adding the type, add the supertype as a second argument:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="types.add_type&lt;A&gt;(&quot;A&quot;).method(&quot;message&quot;, &amp;A::message);
types.add_type&lt;B&gt;(&quot;B&quot;, jlcxx::julia_base_type&lt;A&gt;());"><pre>types.add_type&lt;A&gt;(<span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>).method(<span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>, &amp;A::message);
types.add_type&lt;B&gt;(<span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, jlcxx::julia_base_type&lt;A&gt;());</pre></div>
<p dir="auto">The supertype is of type <code>jl_datatype_t*</code> and using the template function <code>jlcxx::julia_base_type</code> looks up the abstract type associated with <code>A</code> here.
Since the concrete arguments given to <code>ccall</code> are the reference types, we need a way to convert <code>BRef</code> into <code>ARef</code>.
To allow CxxWrap to figure out the correct static_cast to use, the hierarchy must be defined at compile time as follows:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace jlcxx
{
  template&lt;&gt; struct SuperType&lt;B&gt; { typedef A type; };
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">jlcxx</span>
{
  <span class="pl-k">template</span>&lt;&gt; <span class="pl-k">struct</span> <span class="pl-en">SuperType</span>&lt;B&gt; { <span class="pl-k">typedef</span> A type; };
}</pre></div>
<p dir="auto">There is also a variant taking a string for the type name and an optional Julia module name as second argument, which is useful for inheriting from a type defined in Julia, e.g.:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mod.add_type&lt;Teuchos::ParameterList&gt;(&quot;ParameterList&quot;, jlcxx::julia_type(&quot;AbstractDict&quot;, &quot;Base&quot;))"><pre>mod.add_type&lt;Teuchos::ParameterList&gt;(<span class="pl-s"><span class="pl-pds">"</span>ParameterList<span class="pl-pds">"</span></span>, jlcxx::julia_type(<span class="pl-s"><span class="pl-pds">"</span>AbstractDict<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Base<span class="pl-pds">"</span></span>))</pre></div>
<p dir="auto">The value returned by <code>add_type</code> also had a <code>dt()</code> method, useful in the case of template types:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto multi_vector_base = mod.add_type&lt;Parametric&lt;TypeVar&lt;1&gt;&gt;&gt;(&quot;MultiVectorBase&quot;);
auto vector_base = mod.add_type&lt;Parametric&lt;TypeVar&lt;1&gt;&gt;&gt;(&quot;VectorBase&quot;, multi_vector_base.dt());"><pre><span class="pl-k">auto</span> multi_vector_base = mod.add_type&lt;Parametric&lt;TypeVar&lt;<span class="pl-c1">1</span>&gt;&gt;&gt;(<span class="pl-s"><span class="pl-pds">"</span>MultiVectorBase<span class="pl-pds">"</span></span>);
<span class="pl-k">auto</span> vector_base = mod.add_type&lt;Parametric&lt;TypeVar&lt;<span class="pl-c1">1</span>&gt;&gt;&gt;(<span class="pl-s"><span class="pl-pds">"</span>VectorBase<span class="pl-pds">"</span></span>, multi_vector_base.dt());</pre></div>
<p dir="auto">See the test at <a href="https://github.com/JuliaInterop/libcxxwrap-julia/tree/master/examples/inheritance.cpp"><code>examples/inheritance.cpp</code></a> and <a href="test/inheritance.jl"><code>test/inheritance.jl</code></a>.</p>
<h2 dir="auto"><a id="user-content-enum-types" class="anchor" aria-hidden="true" href="#enum-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Enum types</h2>
<p dir="auto">Enum types are converted to strongly-typed bits types on the Julia side.
Consider the C++ enum:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="enum MyEnum
{
  EnumValA,
  EnumValB
};"><pre><span class="pl-k">enum</span> MyEnum
{
  EnumValA,
  EnumValB
};</pre></div>
<p dir="auto">This is registered as follows:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="JLCXX_MODULE define_types_module(jlcxx::Module&amp; types)
{
  types.add_bits&lt;MyEnum&gt;(&quot;MyEnum&quot;, jlcxx::julia_type(&quot;CppEnum&quot;));
  types.set_const(&quot;EnumValA&quot;, EnumValA);
  types.set_const(&quot;EnumValB&quot;, EnumValB);
}"><pre>JLCXX_MODULE <span class="pl-en">define_types_module</span>(jlcxx::Module&amp; types)
{
  types.<span class="pl-smi">add_bits</span>&lt;MyEnum&gt;(<span class="pl-s"><span class="pl-pds">"</span>MyEnum<span class="pl-pds">"</span></span>, <span class="pl-c1">jlcxx::julia_type</span>(<span class="pl-s"><span class="pl-pds">"</span>CppEnum<span class="pl-pds">"</span></span>));
  types.<span class="pl-c1">set_const</span>(<span class="pl-s"><span class="pl-pds">"</span>EnumValA<span class="pl-pds">"</span></span>, EnumValA);
  types.<span class="pl-c1">set_const</span>(<span class="pl-s"><span class="pl-pds">"</span>EnumValB<span class="pl-pds">"</span></span>, EnumValB);
}</pre></div>
<p dir="auto">The enum constants will be available on the Julia side as <code>CppTypes.EnumValA</code> and <code>CppTypes.EnumValB</code>, both of type <code>CppTypes.MyEnum</code>.
Wrapped C++ functions taking a <code>MyEnum</code> will only accept a value of type <code>CppTypes.MyEnum</code> in Julia.</p>
<h2 dir="auto"><a id="user-content-template-parametric-types" class="anchor" aria-hidden="true" href="#template-parametric-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Template (parametric) types</h2>
<p dir="auto">The natural Julia equivalent of a C++ template class is the parametric type.
The mapping is complicated by the fact that all possible parameter values must be compiled in advance, requiring a deviation from the syntax for adding a regular class.
Consider the following template class:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="template&lt;typename A, typename B&gt;
struct TemplateType
{
  typedef typename A::val_type first_val_type;
  typedef typename B::val_type second_val_type;

  first_val_type get_first()
  {
    return A::value();
  }

  second_val_type get_second()
  {
    return B::value();
  }
};"><pre><span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> A, <span class="pl-k">typename</span> B&gt;
<span class="pl-k">struct</span> <span class="pl-en">TemplateType</span>
{
  <span class="pl-k">typedef</span> <span class="pl-k">typename</span> A::val_type first_val_type;
  <span class="pl-k">typedef</span> <span class="pl-k">typename</span> B::val_type second_val_type;

  first_val_type <span class="pl-en">get_first</span>()
  {
    <span class="pl-k">return</span> <span class="pl-c1">A::value</span>();
  }

  second_val_type <span class="pl-en">get_second</span>()
  {
    <span class="pl-k">return</span> <span class="pl-c1">B::value</span>();
  }
};</pre></div>
<p dir="auto">The code for wrapping this is:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="types.add_type&lt;Parametric&lt;TypeVar&lt;1&gt;, TypeVar&lt;2&gt;&gt;&gt;(&quot;TemplateType&quot;)
  .apply&lt;TemplateType&lt;P1,P2&gt;, TemplateType&lt;P2,P1&gt;&gt;([](auto wrapped)
{
  typedef typename decltype(wrapped)::type WrappedT;
  wrapped.method(&quot;get_first&quot;, &amp;WrappedT::get_first);
  wrapped.method(&quot;get_second&quot;, &amp;WrappedT::get_second);
});"><pre>types.add_type&lt;Parametric&lt;TypeVar&lt;<span class="pl-c1">1</span>&gt;, TypeVar&lt;<span class="pl-c1">2</span>&gt;&gt;&gt;(<span class="pl-s"><span class="pl-pds">"</span>TemplateType<span class="pl-pds">"</span></span>)
  .apply&lt;TemplateType&lt;P1,P2&gt;, TemplateType&lt;P2,P1&gt;&gt;([](<span class="pl-k">auto</span> wrapped)
{
  <span class="pl-k">typedef</span> <span class="pl-k">typename</span> <span class="pl-smi">decltype</span>(wrapped)::type WrappedT;
  wrapped.<span class="pl-c1">method</span>(<span class="pl-s"><span class="pl-pds">"</span>get_first<span class="pl-pds">"</span></span>, &amp;WrappedT::get_first);
  wrapped.<span class="pl-c1">method</span>(<span class="pl-s"><span class="pl-pds">"</span>get_second<span class="pl-pds">"</span></span>, &amp;WrappedT::get_second);
});</pre></div>
<p dir="auto">The first line adds the parametric type, using the generic placeholder <code>Parametric</code> and a <code>TypeVar</code> for each parameter.
On the second line, the possible instantiations are created by calling <code>apply</code> on the result of <code>add_type</code>.
Here, we allow for <code>TemplateType&lt;P1,P2&gt;</code> and <code>TemplateType&lt;P2,P1&gt;</code> to exist, where <code>P1</code> and <code>P2</code> are C++ classes that also must be wrapped and that fulfill the requirements for being a parameter to <code>TemplateType</code>.
The argument to <code>apply</code> is a functor (generic C++14 lambda here) that takes the wrapped instantiated type (called <code>wrapped</code> here) as argument.
This object can then be used as before to define methods.
In the case of a generic lambda, the actual type being wrapped can be obtained using <code>decltype</code> as shown on the 4th line.</p>
<p dir="auto">Use on the Julia side:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import ParametricTypes.TemplateType, ParametricTypes.P1, ParametricTypes.P2

p1 = TemplateType{P1, P2}()
p2 = TemplateType{P2, P1}()

@test ParametricTypes.get_first(p1) == 1
@test ParametricTypes.get_second(p2) == 1"><pre><span class="pl-k">import</span> ParametricTypes<span class="pl-k">.</span>TemplateType, ParametricTypes<span class="pl-k">.</span>P1, ParametricTypes<span class="pl-k">.</span>P2

p1 <span class="pl-k">=</span> <span class="pl-c1">TemplateType</span><span class="pl-c1">{P1, P2}</span>()
p2 <span class="pl-k">=</span> <span class="pl-c1">TemplateType</span><span class="pl-c1">{P2, P1}</span>()

<span class="pl-c1">@test</span> ParametricTypes<span class="pl-k">.</span><span class="pl-c1">get_first</span>(p1) <span class="pl-k">==</span> <span class="pl-c1">1</span>
<span class="pl-c1">@test</span> ParametricTypes<span class="pl-k">.</span><span class="pl-c1">get_second</span>(p2) <span class="pl-k">==</span> <span class="pl-c1">1</span></pre></div>
<p dir="auto">There is also an <code>apply_combination</code> method to make applying all combinations of parameters shorter to write.</p>
<p dir="auto">Full example and test including non-type parameters at: <a href="https://github.com/JuliaInterop/libcxxwrap-julia/tree/master/examples/parametric.cpp"><code>examples/parametric.cpp</code></a> and <a href="test/parametric.jl"><code>test/parametric.jl</code></a>.</p>
<h2 dir="auto"><a id="user-content-constructors-and-destructors" class="anchor" aria-hidden="true" href="#constructors-and-destructors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Constructors and destructors</h2>
<p dir="auto">The default constructor and any manually added constructor using the <code>constructor</code> function will automatically create a Julia object that has a finalizer attached that calls delete to free the memory.
To write a C++ function that returns a new object that can be garbage-collected in Julia, use the <code>jlcxx::create</code> function:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="jlcxx::create&lt;Class&gt;(constructor_arg1, ...);"><pre>jlcxx::create&lt;Class&gt;(constructor_arg1, ...);</pre></div>
<p dir="auto">This will return the new C++ object wrapped in a <code>jl_value_t*</code> that has a finalizer.</p>
<h3 dir="auto"><a id="user-content-copy-constructor" class="anchor" aria-hidden="true" href="#copy-constructor"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Copy constructor</h3>
<p dir="auto">The copy constructor is mapped to Julia's standard <code>copy</code> function. Using the <code>.</code>-notation it can be used to easily create a Julia arrays from the elements of e.g. an <code>std::vector</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="wvec = cpp_function_returning_vector()
julia_array = copy.(wvec)"><pre>wvec <span class="pl-k">=</span> <span class="pl-c1">cpp_function_returning_vector</span>()
julia_array <span class="pl-k">=</span> <span class="pl-c1">copy</span>.(wvec)</pre></div>
<h2 dir="auto"><a id="user-content-call-operator-overload" class="anchor" aria-hidden="true" href="#call-operator-overload"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Call operator overload</h2>
<p dir="auto">Since Julia supports overloading the function call operator <code>()</code>, this can be used to wrap <code>operator()</code> by just omitting the method name:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct CallOperator
{
  int operator()() const
  {
    return 43;
  }
};

// ...

types.add_type&lt;CallOperator&gt;(&quot;CallOperator&quot;).method(&amp;CallOperator::operator());"><pre><span class="pl-k">struct</span> <span class="pl-en">CallOperator</span>
{
  <span class="pl-k">int</span> <span class="pl-en">operator</span>()() <span class="pl-k">const</span>
  {
    <span class="pl-k">return</span> <span class="pl-c1">43</span>;
  }
};

<span class="pl-c"><span class="pl-c">//</span> ...</span>

types.add_type&lt;CallOperator&gt;(<span class="pl-s"><span class="pl-pds">"</span>CallOperator<span class="pl-pds">"</span></span>).method(&amp;<span class="pl-en">CallOperator::operator</span>());</pre></div>
<p dir="auto">Use in Julia:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="call_op = CallOperator()
@test call_op() == 43"><pre>call_op <span class="pl-k">=</span> <span class="pl-c1">CallOperator</span>()
<span class="pl-c1">@test</span> <span class="pl-c1">call_op</span>() <span class="pl-k">==</span> <span class="pl-c1">43</span></pre></div>
<p dir="auto">The C++ function does not even have to be <code>operator()</code>, but of course it is most logical use case.</p>
<h2 dir="auto"><a id="user-content-automatic-argument-conversion" class="anchor" aria-hidden="true" href="#automatic-argument-conversion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Automatic argument conversion</h2>
<p dir="auto">By default, overloaded signatures for wrapper methods are generated, so a method taking a <code>double</code> in C++ can be called with e.g. an <code>Int</code> in Julia.
Wrapping a function like this:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mod.method(&quot;half_lambda&quot;, [](const double a) {return a*0.5;});"><pre>mod.method(<span class="pl-s"><span class="pl-pds">"</span>half_lambda<span class="pl-pds">"</span></span>, [](<span class="pl-k">const</span> <span class="pl-k">double</span> a) {<span class="pl-k">return</span> a*<span class="pl-c1">0.5</span>;});</pre></div>
<p dir="auto">then yields the methods:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="half_lambda(arg1::Int64)
half_lambda(arg1::Float64)"><pre><span class="pl-c1">half_lambda</span>(arg1<span class="pl-k">::</span><span class="pl-c1">Int64</span>)
<span class="pl-c1">half_lambda</span>(arg1<span class="pl-k">::</span><span class="pl-c1">Float64</span>)</pre></div>
<p dir="auto">In some cases (e.g. when a template parameter depends on the number type) this is not desired, so the behavior can be disabled on a per-argument basis using the <code>StrictlyTypedNumber</code> type.
Wrapping a function like this:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mod.method(&quot;strict_half&quot;, [](const jlcxx::StrictlyTypedNumber&lt;double&gt; a) {return a.value*0.5;});"><pre>mod.method(<span class="pl-s"><span class="pl-pds">"</span>strict_half<span class="pl-pds">"</span></span>, [](<span class="pl-k">const</span> jlcxx::StrictlyTypedNumber&lt;<span class="pl-k">double</span>&gt; a) {<span class="pl-k">return</span> a.<span class="pl-smi">value</span>*<span class="pl-c1">0.5</span>;});</pre></div>
<p dir="auto">will <em>only</em> yield the Julia method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="strict_half(arg1::Float64)"><pre><span class="pl-c1">strict_half</span>(arg1<span class="pl-k">::</span><span class="pl-c1">Float64</span>)</pre></div>
<p dir="auto">Note that in C++ the number value is accessed using the <code>value</code> member of <code>StrictlyTypedNumber</code>.</p>
<h3 dir="auto"><a id="user-content-customization" class="anchor" aria-hidden="true" href="#customization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Customization</h3>
<p dir="auto">The automatic overloading can be customized.
For example, to allow passing an <code>Int64</code> where a <code>UInt64</code> is normally expected, the following method can be added:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CxxWrap.argument_overloads(t::Type{UInt64}) = [Int64]"><pre>CxxWrap<span class="pl-k">.</span><span class="pl-en">argument_overloads</span>(t<span class="pl-k">::</span><span class="pl-c1">Type{UInt64}</span>) <span class="pl-k">=</span> [Int64]</pre></div>
<h2 dir="auto"><a id="user-content-integer-types" class="anchor" aria-hidden="true" href="#integer-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Integer types</h2>
<p dir="auto">Due to the fact that built-in integer types don't have an imposed size, they can't be mapped to Julia integer types in the same way on every platform. For CxxWrap, we take the following approach:</p>
<ul dir="auto">
<li>Fixed-size types such as <code>int32_t</code> are mapped directly to their Julia equivalents</li>
<li>Built-in types are mapped to a named type, e.g. the C++ type <code>long</code> becomes <code>CxxLong</code> in Julia. If in the given C++ implementation we have <code>long == int64_t</code>, then in Julia <code>CxxLong</code> will be an alias for <code>Int64</code>, otherwise it is its own bits type.</li>
</ul>
<p dir="auto">The following table gives an overview of the mapping, where some of the <code>Cxx*</code> types may actually be aliases for a Julia type:</p>
<table>
<thead>
<tr>
<th>C++</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int8_t</code></td>
<td><code>Int8</code></td>
</tr>
<tr>
<td><code>uint8_t</code></td>
<td><code>UInt8</code></td>
</tr>
<tr>
<td><code>int16_t</code></td>
<td><code>Int16</code></td>
</tr>
<tr>
<td><code>uint16_t</code></td>
<td><code>UInt16</code></td>
</tr>
<tr>
<td><code>int32_t</code></td>
<td><code>Int32</code></td>
</tr>
<tr>
<td><code>uint32_t</code></td>
<td><code>UInt32</code></td>
</tr>
<tr>
<td><code>int64_t</code></td>
<td><code>Int64</code></td>
</tr>
<tr>
<td><code>uint64_t</code></td>
<td><code>UInt64</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>CxxBool</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>CxxChar</code></td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td><code>CxxWchar</code></td>
</tr>
<tr>
<td><code>signed char</code></td>
<td><code>CxxSignedChar</code></td>
</tr>
<tr>
<td><code>unsigned char</code></td>
<td><code>CxxUChar</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>CxxShort</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td><code>CxxUShort</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>CxxInt</code></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td><code>CxxUInt</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>CxxLong</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td><code>CxxULong</code></td>
</tr>
<tr>
<td><code>long long</code></td>
<td><code>CxxLongLong</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td><code>CxxULongLong</code></td>
</tr>
</tbody>
</table>
<h2 dir="auto"><a id="user-content-pointers-and-references" class="anchor" aria-hidden="true" href="#pointers-and-references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Pointers and references</h2>
<p dir="auto">Simple pointers and references are treated the same way, and wrapped in a struct with as a single member the pointer to the C++ object.</p>
<h3 dir="auto"><a id="user-content-references-to-pointers" class="anchor" aria-hidden="true" href="#references-to-pointers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References to pointers</h3>
<p dir="auto">A reference to a pointer allows changing the referred object, e.g.:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="void writepointerref(MyData*&amp; ptrref)
{
  delete ptrref;
  ptrref = new MyData(30);
}"><pre><span class="pl-k">void</span> <span class="pl-en">writepointerref</span>(MyData*&amp; ptrref)
{
  <span class="pl-k">delete</span> ptrref;
  ptrref = <span class="pl-k">new</span> <span class="pl-c1">MyData</span>(<span class="pl-c1">30</span>);
}</pre></div>
<p dir="auto">is called from Julia as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d = PtrModif.MyData()
writepointerref(Ref(d))"><pre>d <span class="pl-k">=</span> PtrModif<span class="pl-k">.</span><span class="pl-c1">MyData</span>()
<span class="pl-c1">writepointerref</span>(<span class="pl-c1">Ref</span>(d))</pre></div>
<p dir="auto">Note that this modifies <code>d</code> itself, so <code>d</code> must be a <code>MyDataAllocated</code>.
More details are in the <code>pointer_modification</code> example.</p>
<h3 dir="auto"><a id="user-content-reference-to-bool" class="anchor" aria-hidden="true" href="#reference-to-bool"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reference to <code>bool</code></h3>
<p dir="auto">In the Julia C calling convention, a boolean is a <code>Cuchar</code>, so to pass a reference to a boolean to C++ you need:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="bref = Ref{Cuchar}(0)
boolref(bref)"><pre>bref <span class="pl-k">=</span> <span class="pl-c1">Ref</span><span class="pl-c1">{Cuchar}</span>(<span class="pl-c1">0</span>)
<span class="pl-c1">boolref</span>(bref)</pre></div>
<p dir="auto">Where <code>boolref</code> on the C++ side is:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mod.method(&quot;boolref&quot;, [] (bool&amp; b)
{
  b = !b;
});"><pre>mod.method(<span class="pl-s"><span class="pl-pds">"</span>boolref<span class="pl-pds">"</span></span>, [] (<span class="pl-k">bool</span>&amp; b)
{
  b = !b;
});</pre></div>
<p dir="auto">Strictly speaking, the representation of <code>bool</code> in C++ is implementation-defined, so this conversion relies on undefined behavior. Passing references to boolean is therefore not recommended, it is better to sidestep this by writing e.g. a wrapper function in C++ that returns a boolean by value.</p>
<h3 dir="auto"><a id="user-content-smart-pointers" class="anchor" aria-hidden="true" href="#smart-pointers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Smart pointers</h3>
<p dir="auto">Currently, <code>std::shared_ptr</code>, <code>std::unique_ptr</code> and <code>std::weak_ptr</code> are supported transparently.
Returning one of these pointer types will return an object inheriting from <code>SmartPointer{T}</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="types.method(&quot;shared_world_factory&quot;, []()
{
  return std::shared_ptr&lt;World&gt;(new World(&quot;shared factory hello&quot;));
});"><pre>types.method(<span class="pl-s"><span class="pl-pds">"</span>shared_world_factory<span class="pl-pds">"</span></span>, []()
{
  <span class="pl-k">return</span> std::shared_ptr&lt;World&gt;(<span class="pl-k">new</span> <span class="pl-c1">World</span>(<span class="pl-s"><span class="pl-pds">"</span>shared factory hello<span class="pl-pds">"</span></span>));
});</pre></div>
<p dir="auto">The shared pointer can then be used in a function taking an object of type <code>World</code> like this (the module is named <code>CppTypes</code> here):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="swf = CppTypes.shared_world_factory()
CppTypes.greet(swf[])"><pre>swf <span class="pl-k">=</span> CppTypes<span class="pl-k">.</span><span class="pl-c1">shared_world_factory</span>()
CppTypes<span class="pl-k">.</span><span class="pl-c1">greet</span>(swf[])</pre></div>
<h4 dir="auto"><a id="user-content-adding-a-custom-smart-pointer" class="anchor" aria-hidden="true" href="#adding-a-custom-smart-pointer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Adding a custom smart pointer</h4>
<p dir="auto">Suppose we have a "smart" pointer type defined as follows:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="template&lt;typename T&gt;
struct MySmartPointer
{
  MySmartPointer(T* ptr) : m_ptr(ptr)
  {
  }

  MySmartPointer(std::shared_ptr&lt;T&gt; ptr) : m_ptr(ptr.get())
  {
  }

  T&amp; operator*() const
  {
    return *m_ptr;
  }

  T* m_ptr;
};"><pre><span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">MySmartPointer</span>
{
  <span class="pl-en">MySmartPointer</span>(T* ptr) : m_ptr(ptr)
  {
  }

  <span class="pl-en">MySmartPointer</span>(std::shared_ptr&lt;T&gt; ptr) : m_ptr(ptr.get())
  {
  }

  T&amp; <span class="pl-k">operator</span>*() <span class="pl-k">const</span>
  {
    <span class="pl-k">return</span> *m_ptr;
  }

  T* m_ptr;
};</pre></div>
<p dir="auto">Specializing in the <code>jlcxx</code> namespace:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace jlcxx
{
  template&lt;typename T&gt; struct IsSmartPointerType&lt;cpp_types::MySmartPointer&lt;T&gt;&gt; : std::true_type { };
  template&lt;typename T&gt; struct ConstructorPointerType&lt;cpp_types::MySmartPointer&lt;T&gt;&gt; { typedef std::shared_ptr&lt;T&gt; type; };
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">jlcxx</span>
{
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">struct</span> <span class="pl-en">IsSmartPointerType</span>&lt;cpp_types::MySmartPointer&lt;T&gt;&gt; : std::true_type { };
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">struct</span> <span class="pl-en">ConstructorPointerType</span>&lt;cpp_types::MySmartPointer&lt;T&gt;&gt; { <span class="pl-k">typedef</span> std::shared_ptr&lt;T&gt; type; };
}</pre></div>
<p dir="auto">Here, the first line marks our type as a smart pointer, enabling automatic conversion from the pointer to its referenced type and adding the dereferencing pointer.
If the type uses inheritance and the hierarchy is defined using <code>SuperType</code>, automatic conversion to the pointer or reference of the base type is also supported.
The second line indicates that our smart pointer can be constructed from a <code>std::shared_ptr</code>, also adding auto-conversion for that case.
This is useful for a relation as in <code>std::weak_ptr</code> and <code>std::shared_ptr</code>, for example.</p>
<h2 dir="auto"><a id="user-content-function-arguments" class="anchor" aria-hidden="true" href="#function-arguments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Function arguments</h2>
<p dir="auto">Because C++ functions often return references or pointers, writing Julia functions that operate on C++ types can be tricky.
For example, writing a function like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia_greet(w::World) = greet_cpp(w)"><pre><span class="pl-en">julia_greet</span>(w<span class="pl-k">::</span><span class="pl-c1">World</span>) <span class="pl-k">=</span> <span class="pl-c1">greet_cpp</span>(w)</pre></div>
<p dir="auto">If <code>World</code> is a type from C++, this will only work with objects that have been constructed directly or that were returned by value from C++.
To make it work with references and pointers, we would need an additional method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia_greet(w::CxxWrap.CxxBaseRef{World}) = greet_cpp(w[])"><pre><span class="pl-en">julia_greet</span>(w<span class="pl-k">::</span><span class="pl-c1">CxxWrap.CxxBaseRef{World}</span>) <span class="pl-k">=</span> <span class="pl-c1">greet_cpp</span>(w[])</pre></div>
<p dir="auto">Note that in the general case, both the signature and the implementation need to change, making this cumbersome when there are many functions like this.
Enter the <code>@cxxdereference</code> macro.
Declaring the function like this makes sure it can accept both values and references:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@cxxdereference julia_greet(w::World) = greet_cpp(w)"><pre><span class="pl-c1">@cxxdereference</span> <span class="pl-en">julia_greet</span>(w<span class="pl-k">::</span><span class="pl-c1">World</span>) <span class="pl-k">=</span> <span class="pl-c1">greet_cpp</span>(w)</pre></div>
<p dir="auto">The <code>@cxxdereference</code> macro changes the function into:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function julia_greet(w::CxxWrap.reference_type_union(World))
    w = CxxWrap.dereference_argument(w)
    greet_cpp(w)
end"><pre><span class="pl-k">function</span> <span class="pl-en">julia_greet</span>(w<span class="pl-k">::</span><span class="pl-c1">CxxWrap.reference_type_union</span>(World))
    w <span class="pl-k">=</span> CxxWrap<span class="pl-k">.</span><span class="pl-c1">dereference_argument</span>(w)
    <span class="pl-c1">greet_cpp</span>(w)
<span class="pl-k">end</span></pre></div>
<p dir="auto">The type of <code>w</code> is now calculated by the <code>CxxWrap.reference_type_union</code> function, which resolves to <code>Union{World, CxxWrap.CxxBaseRef{World}, CxxWrap.SmartPointer{World}}</code>.
The behavior of the macro can be customized by adding methods to <code>CxxWrap.reference_type_union</code> and <code>CxxWrap.dereference_argument</code>.</p>
<h2 dir="auto"><a id="user-content-exceptions" class="anchor" aria-hidden="true" href="#exceptions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Exceptions</h2>
<p dir="auto">When directly adding a regular free C++ function as a method, it will be called directly using <code>ccall</code> and any exception will abort the Julia program.
To avoid this, you can force wrapping it in an <code>std::function</code> to intercept the exception automatically by setting the <code>force_convert</code> argument to <code>method</code> to true:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mod.method(&quot;test_exception&quot;, test_exception, true);"><pre>mod.method(<span class="pl-s"><span class="pl-pds">"</span>test_exception<span class="pl-pds">"</span></span>, test_exception, <span class="pl-c1">true</span>);</pre></div>
<p dir="auto">Member functions and lambdas are automatically wrapped in an <code>std::function</code> and so any exceptions thrown there are always intercepted and converted to a Julia exception.</p>
<h2 dir="auto"><a id="user-content-tuples" class="anchor" aria-hidden="true" href="#tuples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tuples</h2>
<p dir="auto">C++11 tuples can be converted to Julia tuples by including the <code>containers/tuple.hpp</code> header:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &quot;jlcxx/jlcxx.hpp&quot;
#include &quot;jlcxx/tuple.hpp&quot;

JLCXX_MODULE define_types_module(jlcxx::Module&amp; containers)
{
  containers.method(&quot;test_tuple&quot;, []() { return std::make_tuple(1, 2., 3.f); });
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jlcxx/jlcxx.hpp<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jlcxx/tuple.hpp<span class="pl-pds">"</span></span>

JLCXX_MODULE <span class="pl-en">define_types_module</span>(jlcxx::Module&amp; containers)
{
  containers.<span class="pl-c1">method</span>(<span class="pl-s"><span class="pl-pds">"</span>test_tuple<span class="pl-pds">"</span></span>, []() { <span class="pl-k">return</span> <span class="pl-c1">std::make_tuple</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>., <span class="pl-c1">3</span>.<span class="pl-smi">f</span>); });
}</pre></div>
<p dir="auto">Use in Julia:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CxxWrap
using Base.Test

module Containers
  @wrapmodule(libcontainers)
  export test_tuple
end
using Containers

@test test_tuple() == (1,2.0,3.0f0)"><pre><span class="pl-k">using</span> CxxWrap
<span class="pl-k">using</span> Base<span class="pl-k">.</span>Test

<span class="pl-k">module</span> Containers
  <span class="pl-c1">@wrapmodule</span>(libcontainers)
  <span class="pl-k">export</span> test_tuple
<span class="pl-k">end</span>
<span class="pl-k">using</span> Containers

<span class="pl-c1">@test</span> <span class="pl-c1">test_tuple</span>() <span class="pl-k">==</span> (<span class="pl-c1">1</span>,<span class="pl-c1">2.0</span>,<span class="pl-c1">3.0f0</span>)</pre></div>
<h2 dir="auto"><a id="user-content-working-with-arrays" class="anchor" aria-hidden="true" href="#working-with-arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Working with arrays</h2>
<h3 dir="auto"><a id="user-content-reference-native-julia-arrays" class="anchor" aria-hidden="true" href="#reference-native-julia-arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reference native Julia arrays</h3>
<p dir="auto">The <code>ArrayRef</code> type is provided to work conveniently with array data from Julia.
Defining a function like this in C++:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="void test_array_set(jlcxx::ArrayRef&lt;double&gt; a, const int64_t i, const double v)
{
  a[i] = v;
}"><pre><span class="pl-k">void</span> <span class="pl-en">test_array_set</span>(jlcxx::ArrayRef&lt;<span class="pl-k">double</span>&gt; a, <span class="pl-k">const</span> <span class="pl-c1">int64_t</span> i, <span class="pl-k">const</span> <span class="pl-k">double</span> v)
{
  a[i] = v;
}</pre></div>
<p dir="auto">This can be called from Julia as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ta = [1.,2.]
test_array_set(ta, 0, 3.)"><pre>ta <span class="pl-k">=</span> [<span class="pl-c1">1.</span>,<span class="pl-c1">2.</span>]
<span class="pl-c1">test_array_set</span>(ta, <span class="pl-c1">0</span>, <span class="pl-c1">3.</span>)</pre></div>
<p dir="auto">The <code>ArrayRef</code> type provides basic functionality:</p>
<ul dir="auto">
<li>iterators</li>
<li><code>size</code></li>
<li><code>[]</code> read-write accessor</li>
<li><code>push_back</code> for appending elements</li>
</ul>
<p dir="auto">Note that <code>ArrayRef</code> only works with primitive types, if you need a "boxed" type it has to be made an array of <code>Any</code> with type <code>ArrayRef&lt;jl_value_t*&gt;</code> in C++.</p>
<h3 dir="auto"><a id="user-content-const-arrays" class="anchor" aria-hidden="true" href="#const-arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Const arrays</h3>
<p dir="auto">Sometimes, a function returns a <code>const</code> pointer that is an array, either of fixed size or with a size that can be determined from elsewhere in the API.
Example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const double* const_vector()
{
  static double d[] = {1., 2., 3};
  return d;
}"><pre><span class="pl-k">const</span> <span class="pl-k">double</span>* <span class="pl-en">const_vector</span>()
{
  <span class="pl-k">static</span> <span class="pl-k">double</span> d[] = {<span class="pl-c1">1</span>., <span class="pl-c1">2</span>., <span class="pl-c1">3</span>};
  <span class="pl-k">return</span> d;
}</pre></div>
<p dir="auto">In this simple case, the most logical way to translate this would be as a tuple:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mymodule.method(&quot;const_ptr_arg&quot;, []() { return std::make_tuple(const_vector().ptr[0], const_vector().ptr[1], const_vector().ptr[2]); });"><pre>mymodule.method(<span class="pl-s"><span class="pl-pds">"</span>const_ptr_arg<span class="pl-pds">"</span></span>, []() { <span class="pl-k">return</span> <span class="pl-c1">std::make_tuple</span>(<span class="pl-c1">const_vector</span>().<span class="pl-smi">ptr</span>[<span class="pl-c1">0</span>], <span class="pl-c1">const_vector</span>().<span class="pl-smi">ptr</span>[<span class="pl-c1">1</span>], <span class="pl-c1">const_vector</span>().<span class="pl-smi">ptr</span>[<span class="pl-c1">2</span>]); });</pre></div>
<p dir="auto">In the case of a larger blob of heap-allocated data it makes more sense to convert this to a <code>ConstArray</code>, which implements the read-only part of the Julia array interface, so it exposes the data safely to Julia in a way that can be used natively:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mymodule.method(&quot;const_vector&quot;, []() { return jlcxx::make_const_array(const_vector(), 3); });"><pre>mymodule.method(<span class="pl-s"><span class="pl-pds">"</span>const_vector<span class="pl-pds">"</span></span>, []() { <span class="pl-k">return</span> <span class="pl-c1">jlcxx::make_const_array</span>(<span class="pl-c1">const_vector</span>(), <span class="pl-c1">3</span>); });</pre></div>
<p dir="auto">For multi-dimensional arrays, the <code>make_const_array</code> function takes multiple sizes, e.g.:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const double* const_matrix()
{
  static double d[2][3] = {{1., 2., 3}, {4., 5., 6.}};
  return &amp;d[0][0];
}

// ...module definition skipped...

mymodule.method(&quot;const_matrix&quot;, []() { return jlcxx::make_const_array(const_matrix(), 3, 2); });"><pre><span class="pl-k">const</span> <span class="pl-k">double</span>* <span class="pl-en">const_matrix</span>()
{
  <span class="pl-k">static</span> <span class="pl-k">double</span> d[<span class="pl-c1">2</span>][<span class="pl-c1">3</span>] = {{<span class="pl-c1">1</span>., <span class="pl-c1">2</span>., <span class="pl-c1">3</span>}, {<span class="pl-c1">4</span>., <span class="pl-c1">5</span>., <span class="pl-c1">6</span>.}};
  <span class="pl-k">return</span> &amp;d[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>];
}

<span class="pl-c"><span class="pl-c">//</span> ...module definition skipped...</span>

mymodule.method(<span class="pl-s"><span class="pl-pds">"</span>const_matrix<span class="pl-pds">"</span></span>, []() { <span class="pl-k">return</span> <span class="pl-c1">jlcxx::make_const_array</span>(<span class="pl-c1">const_matrix</span>(), <span class="pl-c1">3</span>, <span class="pl-c1">2</span>); });</pre></div>
<p dir="auto">Note that because of the column-major convention in Julia, the sizes are in reversed order from C++, so the Julia code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="display(const_matrix())"><pre><span class="pl-c1">display</span>(<span class="pl-c1">const_matrix</span>())</pre></div>
<p dir="auto">shows:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="3x2 ConstArray{Float64,2}:
 1.0  4.0
 2.0  5.0
 3.0  6.0"><pre class="notranslate"><code>3x2 ConstArray{Float64,2}:
 1.0  4.0
 2.0  5.0
 3.0  6.0
</code></pre></div>
<p dir="auto">An extra file has to be included to have constant array functionality: <code>#include "jlcxx/const_array.hpp"</code>.</p>
<h3 dir="auto"><a id="user-content-mutable-arrays" class="anchor" aria-hidden="true" href="#mutable-arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Mutable arrays</h3>
<p dir="auto">Replacing <code>make_const_array</code> in the examples above by <code>make_julia_array</code> creates a mutable, regular Julia array with memory owned by C++.</p>
<h2 dir="auto"><a id="user-content-calling-julia-functions-from-c" class="anchor" aria-hidden="true" href="#calling-julia-functions-from-c"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calling Julia functions from C++</h2>
<h3 dir="auto"><a id="user-content-direct-call-to-julia" class="anchor" aria-hidden="true" href="#direct-call-to-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Direct call to Julia</h3>
<p dir="auto">Directly calling Julia functions uses <code>jl_call</code> from <code>julia.h</code> but with a more convenient syntax and automatic argument conversion and boxing.
Use a <code>JuliaFunction</code> to get a functor that can be invoked directly.
Example for calling the <code>max</code> function from <code>Base</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mymodule.method(&quot;julia_max&quot;, [](double a, double b)
{
  jlcxx::JuliaFunction max(&quot;max&quot;);
  return max(a, b);
});"><pre>mymodule.method(<span class="pl-s"><span class="pl-pds">"</span>julia_max<span class="pl-pds">"</span></span>, [](<span class="pl-k">double</span> a, <span class="pl-k">double</span> b)
{
  jlcxx::JuliaFunction <span class="pl-smi">max</span>(<span class="pl-s"><span class="pl-pds">"</span>max<span class="pl-pds">"</span></span>);
  <span class="pl-k">return</span> <span class="pl-c1">max</span>(a, b);
});</pre></div>
<p dir="auto">Internally, the arguments and return value are boxed, making this method convenient but slower than calling a regular C function.</p>
<h3 dir="auto"><a id="user-content-safe-cfunction" class="anchor" aria-hidden="true" href="#safe-cfunction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Safe <code>cfunction</code></h3>
<p dir="auto">The macro <code>CxxWrap.@safe_cfunction</code> provides a wrapper around <code>Base.@cfunction</code> that checks the type of the function pointer.
Example C++ function:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mymodule.method(&quot;call_safe_function&quot;, [](double(*f)(double,double))
{
  if(f(1.,2.) != 3.)
  {
    throw std::runtime_error(&quot;Incorrect callback result, expected 3&quot;);
  }
});"><pre>mymodule.method(<span class="pl-s"><span class="pl-pds">"</span>call_safe_function<span class="pl-pds">"</span></span>, [](<span class="pl-k">double</span>(*f)(<span class="pl-k">double</span>,<span class="pl-k">double</span>))
{
  <span class="pl-k">if</span>(<span class="pl-c1">f</span>(<span class="pl-c1">1</span>.,<span class="pl-c1">2</span>.) != <span class="pl-c1">3</span>.)
  {
    <span class="pl-k">throw</span> <span class="pl-smi">std::runtime_error</span>(<span class="pl-s"><span class="pl-pds">"</span>Incorrect callback result, expected 3<span class="pl-pds">"</span></span>);
  }
});</pre></div>
<p dir="auto">Use from Julia:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="testf(x,y) = x+y
c_func = @safe_cfunction(testf, Float64, (Float64,Float64))
MyModule.call_safe_function(c_func)"><pre><span class="pl-en">testf</span>(x,y) <span class="pl-k">=</span> x<span class="pl-k">+</span>y
c_func <span class="pl-k">=</span> <span class="pl-c1">@safe_cfunction</span>(testf, Float64, (Float64,Float64))
MyModule<span class="pl-k">.</span><span class="pl-c1">call_safe_function</span>(c_func)</pre></div>
<p dir="auto">Using types different from the expected function pointer call will result in an error.
This check incurs a runtime overhead, so the idea here is that the function is converted only once and then applied many times on the C++ side.</p>
<p dir="auto">If the result of <code>@safe_cfunction</code> needs to be stored before the calling signature is known, direct conversion of the created structure (type <code>SafeCFunction</code>) is also possible.
It can then be converted later using <code>jlcxx::make_function_pointer</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mymodule.method(&quot;call_safe_function&quot;, [](jlcxx::SafeCFunction f_data)
{
  auto f = jlcxx::make_function_pointer&lt;double(double,double)&gt;(f_data);
  if(f(1.,2.) != 3.)
  {
    throw std::runtime_error(&quot;Incorrect callback result, expected 3&quot;);
  }
});"><pre>mymodule.method(<span class="pl-s"><span class="pl-pds">"</span>call_safe_function<span class="pl-pds">"</span></span>, [](jlcxx::SafeCFunction f_data)
{
  <span class="pl-k">auto</span> f = jlcxx::make_function_pointer&lt;<span class="pl-c1">double</span>(<span class="pl-k">double</span>,<span class="pl-k">double</span>)&gt;(f_data);
  <span class="pl-k">if</span>(<span class="pl-c1">f</span>(<span class="pl-c1">1</span>.,<span class="pl-c1">2</span>.) != <span class="pl-c1">3</span>.)
  {
    <span class="pl-k">throw</span> <span class="pl-smi">std::runtime_error</span>(<span class="pl-s"><span class="pl-pds">"</span>Incorrect callback result, expected 3<span class="pl-pds">"</span></span>);
  }
});</pre></div>
<p dir="auto">This method of calling a Julia function is less convenient, but the call overhead should be no larger than calling a regular C function through its pointer.</p>
<h2 dir="auto"><a id="user-content-adding-julia-code-to-the-module" class="anchor" aria-hidden="true" href="#adding-julia-code-to-the-module"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Adding Julia code to the module</h2>
<p dir="auto">Sometimes, you may want to write additional Julia code in the module that is built from C++.
To do this, call the <code>wrapmodule</code> method inside an appropriately named Julia module:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module ExtendedTypes

using CxxWrap
@wrapmodule(&quot;libextended&quot;)
export ExtendedWorld, greet

end"><pre><span class="pl-k">module</span> ExtendedTypes

<span class="pl-k">using</span> CxxWrap
<span class="pl-c1">@wrapmodule</span>(<span class="pl-s"><span class="pl-pds">"</span>libextended<span class="pl-pds">"</span></span>)
<span class="pl-k">export</span> ExtendedWorld, greet

<span class="pl-k">end</span></pre></div>
<p dir="auto">Here, <code>ExtendedTypes</code> is a name that matches the module name passed to <code>create_module</code> on the C++ side.
The <code>@wrapmodule</code> call works as before, but now the functions and types are defined in the existing <code>ExtendedTypes</code> module, and additional Julia code such as exports and macros can be defined.</p>
<p dir="auto">It is also possible to replace the <code>@wrapmodule</code> call with a call to <code>@readmodule</code> and then separately call <code>@wraptypes</code> and <code>@wrapfunctions</code>.
This allows using the types before the functions get called, which is useful for overloading the <code>argument_overloads</code> with types defined on the C++ side.</p>
<h2 dir="auto"><a id="user-content-overriding-finalization-behavior" class="anchor" aria-hidden="true" href="#overriding-finalization-behavior"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overriding finalization behavior</h2>
<p dir="auto">By default, objects that are allocated from Julia are also destroyed through a finalizer that calls <code>delete</code>. If you want to override this behavior, you can specialize the <code>jlcxx::Finalizer</code> class as follows, for example only doing something special in the case a tye has a <code>getImpl</code> function:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace jlcxx
{
  template&lt;typename T&gt;
  struct Finalizer&lt;T, SpecializedFinalizer&gt;
  {
    static void finalize(T* to_delete)
    {
      constexpr bool has_getImpl = requires(const T&amp; t) {
        t.getImpl();
      };

      if constexpr(has_getImpl) {
        std::cout &lt;&lt; &quot;calling specialized delete&quot; &lt;&lt; std::endl;
        delete to_delete;
      } else {
        delete to_delete;
      }
    }
  };
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">jlcxx</span>
{
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
  <span class="pl-k">struct</span> <span class="pl-en">Finalizer</span>&lt;T, SpecializedFinalizer&gt;
  {
    <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">finalize</span>(T* to_delete)
    {
      <span class="pl-k">constexpr</span> <span class="pl-k">bool</span> has_getImpl = <span class="pl-c1">requires</span>(<span class="pl-k">const</span> T&amp; t) {
        t.<span class="pl-c1">getImpl</span>();
      };

      <span class="pl-k">if</span> <span class="pl-k">constexpr</span>(has_getImpl) {
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>calling specialized delete<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
        <span class="pl-k">delete</span> to_delete;
      } <span class="pl-k">else</span> {
        <span class="pl-k">delete</span> to_delete;
      }
    }
  };
}</pre></div>
<p dir="auto">You  can also further specialize on <code>T</code> to get specific behavior depending on the concrete type.</p>
<h2 dir="auto"><a id="user-content-stl-support" class="anchor" aria-hidden="true" href="#stl-support"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>STL support</h2>
<p dir="auto">Version 0.9 introduces basic support for the C++ standard library, with mappings for <code>std::vector</code> (<code>StdVector</code>) and <code>std::string</code> (<code>StdString</code>).
To add support for e.g. vectors of your own type <code>World</code>, either just add methods that use an <code>std::vector&lt;World&gt;</code> as an argument, or manually wrap them using <code>jlcxx::stl::apply_stl&lt;World&gt;(mod);</code>.
For this to work, add <code>#include "jlcxx/stl.hpp"</code> to your C++ file.</p>
<p dir="auto">If the type <code>World</code> contains methods that take or return <code>std::</code> collections of type <code>World</code> or <code>World*</code>, however, you must first complete the type, so that CxxWrap can generate the type and the template specializations for the <code>std::</code> collections.
In this case, you can add those methods to your type like this:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="jlcxx::stl::apply_stl&lt;World*&gt;(mod);
mod.method(&quot;getSecondaryWorldVector&quot;, [](const World* p)-&gt;const std::vector&lt;World*&gt;&amp; {
    return p-&gt;getSecondaries();
});"><pre class="notranslate"><code>jlcxx::stl::apply_stl&lt;World*&gt;(mod);
mod.method("getSecondaryWorldVector", [](const World* p)-&gt;const std::vector&lt;World*&gt;&amp; {
    return p-&gt;getSecondaries();
});
</code></pre></div>
<p dir="auto">Linking wrappers using STL support requires adding <code>JlCxx::cxxwrap_julia_stl</code> to the <code>target_link_libraries</code> command in <code>CMakeLists.txt</code>.</p>
<h2 dir="auto"><a id="user-content-release-procedure" class="anchor" aria-hidden="true" href="#release-procedure"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Release procedure</h2>
<p dir="auto">Often, new releases of <code>CxxWrap</code> also require a new release of the C++ component <code>libcxxwrap-julia</code>, and a rebuild of its JLL package. To make sure everything is tested properly, the following procedure should be followed for each release that requires changing both the Julia and the C++ component:</p>
<ol dir="auto">
<li>Merge the changes to <code>CxxWrap</code> into the <code>testjll</code> branch</li>
<li>Create a PR in <code>libcxxwrap-julia</code> with the required changes there and make sure it passes all tests. These tests will run using the <code>CxxWrap#testjll</code> branch.</li>
<li>Merge the <code>libcxxwrap-julia</code> PR. This will build and publish a JLL, available through the <a href="https://github.com/barche/CxxWrapTestRegistry">CxxWrapTestRegistry</a></li>
<li>Make a PR in <code>CxxWrap</code> to merge <code>testjll</code> into <code>prerelease</code>. Verify that the tests pass (rerun them if needed, since the first push to <code>testjll</code> will have used the old JLL version). Don't merge this PR yet.</li>
<li>Tag the next <code>libcxxwrap-julia</code> release and update to this new release in Yggdrasil</li>
<li>Wait for the new JLL to appear in the registry and then merge the PR from point 4. Verify that the tests running on the <code>prerelease</code> branch pass, by merging the PR from point 4. The difference with the tests in the <code>testjll</code> branch is that the <code>prerelease</code> branch tests using the JLL in the Julia General repository.</li>
<li>Merge the CxxWrap <code>prerelease</code> branch into <code>main</code> and create a new release using Registrator.</li>
</ol>
<h2 dir="auto"><a id="user-content-breaking-changes-for-cxxwrap-07" class="anchor" aria-hidden="true" href="#breaking-changes-for-cxxwrap-07"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Breaking changes for CxxWrap 0.7</h2>
<ul dir="auto">
<li>
<p dir="auto"><code>JULIA_CPP_MODULE_BEGIN</code> and <code>JULIA_CPP_MODULE_END</code> no longer exists, define a function with return type <code>JLCXX_MODULE</code> in the global namespace instead.
By default, the Julia side expects this function to be named <code>define_julia_module</code>, but another name can be chosen and passed as a second argument to <code>@wrapmodule</code>.</p>
</li>
<li>
<p dir="auto"><code>wrap_modules</code> is removed, replace <code>wrap_modules(lib_file_path)</code> with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module Foo
  using CxxWrap
  @wrapmodule(lib_file_path)
end"><pre><span class="pl-k">module</span> Foo
  <span class="pl-k">using</span> CxxWrap
  <span class="pl-c1">@wrapmodule</span>(lib_file_path)
<span class="pl-k">end</span></pre></div>
</li>
<li>
<p dir="auto"><code>export_symbols</code> is removed, since all C++ modules are now wrapped in a corresponding module declared on the Julia side, so the regular Julia export statement can be used.</p>
</li>
<li>
<p dir="auto"><code>safe_cfunction</code> is now a macro, just like <code>cfunction</code> became a macro in Julia.</p>
</li>
<li>
<p dir="auto">Precompilation: add this function after the <code>@wrapmodule</code> macro:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function __init__()
  @initcxx
end"><pre><span class="pl-k">function</span> <span class="pl-en">__init__</span>()
  <span class="pl-c1">@initcxx</span>
<span class="pl-k">end</span></pre></div>
</li>
</ul>
<h2 dir="auto"><a id="user-content-breaking-changes-in-v09" class="anchor" aria-hidden="true" href="#breaking-changes-in-v09"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Breaking changes in v0.9</h2>
<ul dir="auto">
<li>No automatic conversion between Julia <code>String</code> and <code>std::string</code>, but <code>StdString</code> (which maps <code>std::string</code>) implements the Julia <code>AbstractString</code>interface.</li>
<li>No automatic dereference of const ref</li>
<li><code>ArrayRef</code> no longer supports boxed values</li>
<li>Custom smart pointer: use <code>jlcxx::add_smart_pointer&lt;MySmartPointer&gt;(module, "MySmartPointer")</code></li>
<li><code>IsMirroredType</code> instead of <code>IsImmutable</code> and <code>IsBits</code>, added using <code>map_type</code>.
By default, <code>IsMirroredType</code> is true for trivial standard layout types, so if you want to wrap these normally
(i.e. you get an unexpected error <code>Mirrored types (marked with IsMirroredType) can't be added using add_type, map them directly to a struct instead and use map_type</code>) then you have to explicitly disable the mirroring for that type:
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="template&lt;&gt; struct IsMirroredType&lt;Foo&gt; : std::false_type { };"><pre><span class="pl-k">template</span>&lt;&gt; <span class="pl-k">struct</span> <span class="pl-en">IsMirroredType</span>&lt;Foo&gt; : std::false_type { };</pre></div>
</li>
<li><code>box</code> C++ function takes an explicit template argument</li>
<li>Introduction of specific integer types, such as <code>CxxBool</code>, that map to the C++ equivalent (should be transparent except for template parameters)</li>
<li>Defining <code>SuperType</code> on the C++ side is now necessary for any kind of casting to base class, because the previous implementation was wrong in the case of multiple inheritance.</li>
<li>Use <code>Ref(CxxPtr(x))</code> for pointer or reference to pointer</li>
<li>Use <code>CxxPtr{MyData}(C_NULL)</code> instead of <code>nullptr(MyData)</code></li>
<li>Defining a C++ supertype in C++ must now be done using the <code>jlcxx::julia_base_type&lt;T&gt;()</code> function instead of <code>jlcxx::julia_type&lt;T&gt;()</code></li>
</ul>
<h2 dir="auto"><a id="user-content-breaking-changes-in-v010" class="anchor" aria-hidden="true" href="#breaking-changes-in-v010"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Breaking changes in v0.10</h2>
<ul dir="auto">
<li>Requires Julia 1.3 for the use of JLL packages</li>
<li>Reorganized integer types so the fixed-size types always map to built-in Julia types</li>
</ul>
<h2 dir="auto"><a id="user-content-breaking-changes-in-v013" class="anchor" aria-hidden="true" href="#breaking-changes-in-v013"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Breaking changes in v0.13</h2>
<ul dir="auto">
<li>Automatic dereferencing of smart pointers was removed, so some code may require adding the dereferencing operator <code>[]</code> explicitly. See <a href="https://github.com/JuliaInterop/CxxWrap.jl/pull/338" data-hovercard-type="pull_request" data-hovercard-url="/JuliaInterop/CxxWrap.jl/pull/338/hovercard">PR #338</a>.</li>
</ul>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<ul dir="auto">
<li><a href="https://www.youtube.com/watch?v=u7IaXwKSUU0" rel="nofollow">JuliaCon 2020 Talk: Julia and C++: a technical overview of CxxWrap.jl</a></li>
<li><a href="https://www.youtube.com/watch?v=VoXmXtqLhdo" rel="nofollow">JuliaCon 2020 Workshop: Wrapping a C++ library using CxxWrap.jl</a></li>
</ul>
</article></div>