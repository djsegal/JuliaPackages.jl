<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-mutabletypes" class="anchor" aria-hidden="true" href="#mutabletypes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MutableTypes</h1>
<p dir="auto">This package provides mutable boolean, integer, rational, real and complex types. Their arithmetic operators are overloaded. The package also exports wrappers for the common math functions.</p>
<p dir="auto">The intent of these mutable types is for their use in immutable data structures that contain a field or fields that need the capability to have their values changed during runtime. For example, a data structure that holds material properties may include a boolean field 'ruptured' that would get turned on (converted from false to true) after a rupture event has occurred, thereafter enabling a change in material properties to take place moving forward.</p>
<p dir="auto">To use this module you will need to add it to your package:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(url = &quot;https://github.com/AlanFreed/MutableTypes.jl&quot;)"><pre class="notranslate"><code>using Pkg
Pkg.add(url = "https://github.com/AlanFreed/MutableTypes.jl")
</code></pre></div>
<p dir="auto">Mutable core types are based upon two abstract types; they are:</p>
<ul dir="auto">
<li>MType     &lt;: Number</li>
<li>MNumber   &lt;: MType</li>
</ul>
<p dir="auto">Mutable data structures with a single field 'n' are introduced; specifically:</p>
<ul dir="auto">
<li>MBool     &lt;: MType      # n::Bool</li>
<li>MInteger  &lt;: MNumber    # n::Int64</li>
<li>MRational &lt;: MNumber    # n::Rational{Int64}</li>
<li>MReal     &lt;: MNumber    # n::Float64</li>
<li>MComplex  &lt;: MType      # n::Complex{Float64}</li>
</ul>
<p dir="auto">whose constructors look like a type casting, e.g., x = MReal(2.5).</p>
<p dir="auto">Methods for retrieval and assignment of all concrete mutable types include:</p>
<ul dir="auto">
<li>get, set! and toString</li>
</ul>
<p dir="auto">Overloaded operators include:</p>
<ul dir="auto">
<li>MBool:     ==, ≠, !</li>
<li>MInteger:  ==, ≠, &lt;, ≤, ≥, &gt;, +, -, *, ÷, %, ^</li>
<li>MRational: ==, ≠, &lt;, ≤, ≥, &gt;, +, -, *, //, /</li>
<li>MReal:     ==, ≠, ≈, &lt;, ≤, ≥, &gt;, +, -, *, /, ^</li>
<li>MComplex:  ==, ≠, ≈, +, -, *, /, ^</li>
</ul>
<p dir="auto">Methods common to all concrete mutable types include:</p>
<ul dir="auto">
<li>copy and deepcopy</li>
</ul>
<p dir="auto">A method for all numeric mutable types is:</p>
<ul dir="auto">
<li>abs</li>
</ul>
<p dir="auto">A method for all non-complex, numeric, mutable types is:</p>
<ul dir="auto">
<li>sign</li>
</ul>
<p dir="auto">Additional methods for the MRational type are:</p>
<ul dir="auto">
<li>numerator and denominator</li>
</ul>
<p dir="auto">Additional methods for the MReal type are:</p>
<ul dir="auto">
<li>round, ceil, floor and atan(y,x)</li>
</ul>
<p dir="auto">Additional methods for the MComplex type are:</p>
<ul dir="auto">
<li>abs2, real, imag, conj and angle</li>
</ul>
<p dir="auto">Math functions whose arguments are of types MReal or MComplex include:</p>
<ul dir="auto">
<li>sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh, log, log2, log10, exp, exp2 and exp10</li>
</ul>
<h2 dir="auto"><a id="user-content-notes" class="anchor" aria-hidden="true" href="#notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Notes</h2>
<p dir="auto">Operators, methods and math functions pertaining to these types (except for copy and deepcopy) return instances belonging to their associated core types: Bool, Integer, Rational, Real or Complex. This is because their intended use is to permit mutable fields to be incorporated into what are otherwise immutable data structures; thereby, allowing such fields to have a potential to change their values. Mutable fields belonging to immutable data structures have the necessary infrastructure to be able to be used seamlessly in simple mathematical formulae outside the data structure itself.</p>
<p dir="auto">There is an issue that arises whenever one attempts to overload functions <code>sqrt(x)</code> and <code>cbrt(x)</code> in that the compiler indicates that these functions overwrite themselves, causing the warning:</p>
<p dir="auto"><code>incremental compilation may be fatally broken for this module</code></p>
<p dir="auto">consequently, write code <code>x^0.5</code> in place of <code>sqrt(x)</code> and <code>x^(1/3)</code> in place of <code>cbrt(x)</code> to circumvent this problem.</p>
</article></div>