<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-rewritersjl" class="anchor" aria-hidden="true" href="#rewritersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Rewriters.jl</h1>
<p dir="auto">This package contains definitions for common combinators that are useful for symbolic expression rewriting.
Its purpose is to provide a shared library of combinators between various symbolic programming Julia packages, for example
<a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils.jl</a>, <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a> and <a href="https://github.com/0x0f0f0f/Metatheory.jl">Metatheory.jl</a>.</p>
<h2 dir="auto"><a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Documentation</h2>
<p dir="auto">A rewriter is any function which takes an expression and returns an expression
or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable
to the input expression.</p>
<p dir="auto">The <code>Rewriters</code> module contains some types which create and transform
rewriters.</p>
<ul dir="auto">
<li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li>
<li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies
each chained rewriter in the given order.
If a rewriter returns <code>nothing</code> this is treated as a no-change.</li>
<li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the
first successful application of one of the chained rewriters.</li>
<li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond
returns true, <code>rw2</code> if it retuns false</li>
<li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li>
<li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order
traversal of a given expression and applies the rewriter <code>rw</code>. Note that if
<code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will
also return nothing unless a match is found at every level of the walk.
<code>threaded=true</code> will use multi threading for traversal. <code>thread_cutoff</code> is
the minimum number of nodes in a subtree which should be walked in a
threaded spawn.</li>
<li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order traversal.</li>
<li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li>
<li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead
return <code>x</code> otherwise will return <code>rw(x)</code>.</li>
</ul>
</article></div>