<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-squaresymmetries" class="anchor" aria-hidden="true" href="#squaresymmetries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SquareSymmetries</h1>
<p dir="auto"><a href="https://github.com/icetube23/SquareSymmetries.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/icetube23/SquareSymmetries.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/icetube23/SquareSymmetries.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/47fa4c374a0109effe23029583da43910a45a4e20430a81681335b8e0377dc85/68747470733a2f2f636f6465636f762e696f2f67682f6963657475626532332f53717561726553796d6d6574726965732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/icetube23/SquareSymmetries.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://www.repostatus.org/#active" rel="nofollow"><img src="https://camo.githubusercontent.com/2261082c77808ea734741b12e535d02d23c4101f6b8dfec807f4ddc5ef2eeec0/68747470733a2f2f7777772e7265706f7374617475732e6f72672f6261646765732f6c61746573742f6163746976652e737667" alt="Project Status: Active - The project has reached a stable, usable state and is being actively developed." data-canonical-src="https://www.repostatus.org/badges/latest/active.svg" style="max-width: 100%;"></a>
<a href="https://github.com/invenia/BlueStyle"><img src="https://camo.githubusercontent.com/c18fbaa52d94d16b90b19701fc90d289b8a5bb920c74c79bab200b14e75420a4/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c75652d3434393564312e737667" alt="Code Style: Blue" data-canonical-src="https://img.shields.io/badge/code%20style-blue-4495d1.svg" style="max-width: 100%;"></a></p>
<p dir="auto">SquareSymmetries is a small Julia package that allows applying elements of the symmetry group of a square (a.k.a. the dihedral group <em>D<sub>4</sub></em>) to matrices. The symmetry group consists of operations like 90° rotations and flipping elements along an axis (see also <a href="https://en.wikipedia.org/wiki/Symmetry_group" rel="nofollow">here</a>).</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">To install this package, from the Julia REPL, enter Pkg mode by typing <code>]</code> and execute the following:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add SquareSymmetries"><pre>pkg<span class="pl-k">&gt;</span> add SquareSymmetries</pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">You can apply the provided operations (i.e., the group elements) to matrices just like a simple function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using SquareSymmetries

julia&gt; m = rand(2, 2)
2×2 Matrix{Float64}:
 0.945848  0.755452
 0.339932  0.975451

julia&gt; rotate90(m)
2×2 Matrix{Float64}:
 0.339932  0.945848
 0.975451  0.755452

julia&gt; flipx(m)
2×2 Matrix{Float64}:
 0.339932  0.975451
 0.945848  0.755452"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> SquareSymmetries

julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.945848</span>  <span class="pl-c1">0.755452</span>
 <span class="pl-c1">0.339932</span>  <span class="pl-c1">0.975451</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rotate90</span>(m)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.339932</span>  <span class="pl-c1">0.945848</span>
 <span class="pl-c1">0.975451</span>  <span class="pl-c1">0.755452</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">flipx</span>(m)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.339932</span>  <span class="pl-c1">0.975451</span>
 <span class="pl-c1">0.945848</span>  <span class="pl-c1">0.755452</span></pre></div>
<p dir="auto">You can also compose operations using Julia's function composition syntax:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; (rotate180 ∘ flipdiag)(m) # this is equivalent to flipadiag(m)
2×2 Matrix{Float64}:
 0.975451  0.755452
 0.339932  0.945848"><pre>julia<span class="pl-k">&gt;</span> (rotate180 <span class="pl-k">∘</span> flipdiag)(m) <span class="pl-c"><span class="pl-c">#</span> this is equivalent to flipadiag(m)</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.975451</span>  <span class="pl-c1">0.755452</span>
 <span class="pl-c1">0.339932</span>  <span class="pl-c1">0.945848</span></pre></div>
<h2 dir="auto"><a id="user-content-group-elements" class="anchor" aria-hidden="true" href="#group-elements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Group elements</h2>
<p dir="auto">This package provides all eight elements of <em>D<sub>4</sub></em>. Each element is represented by a Julia function: <code>unit</code>, <code>rotate90</code>, <code>rotate180</code>, <code>rotate270</code>, <code>flipx</code>, <code>flipy</code>, <code>flipdiag</code>, and <code>flipadiag</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; m = [&quot;a11&quot;, &quot;a12&quot;, &quot;a21&quot;, &quot;a22&quot;]
2×2 Matrix{String}:
 &quot;a11&quot;  &quot;a12&quot;
 &quot;a21&quot;  &quot;a22&quot;

julia&gt; unit(m) # identity
2×2 Matrix{String}:
 &quot;a11&quot;  &quot;a12&quot;
 &quot;a21&quot;  &quot;a22&quot;

julia&gt; rotate90(m) # rotate matrix by 90° to the right
2×2 Matrix{String}:
 &quot;a21&quot;  &quot;a11&quot;
 &quot;a22&quot;  &quot;a12&quot;

julia&gt; rotate180(m) # rotate by 180° (i.e., reverse elements)
2×2 Matrix{String}:
 &quot;a22&quot;  &quot;a21&quot;
 &quot;a12&quot;  &quot;a11&quot;

julia&gt; rotate270(m) # rotate 270° to the right (or 90° to the left)
2×2 Matrix{String}:
 &quot;a12&quot;  &quot;a22&quot;
 &quot;a11&quot;  &quot;a21&quot;

julia&gt; flipx(m) # flip elements along x-axis
2×2 Matrix{String}:
 &quot;a21&quot;  &quot;a22&quot;
 &quot;a11&quot;  &quot;a12&quot;

julia&gt; flipy(m) # flip elements along y-axis
2×2 Matrix{String}:
 &quot;a12&quot;  &quot;a11&quot;
 &quot;a22&quot;  &quot;a21&quot;

julia&gt; flipdiag(m) # flip elements along main diagonal (i.e., transpose)
2×2 Matrix{String}:
 &quot;a11&quot;  &quot;a21&quot;
 &quot;a12&quot;  &quot;a22&quot;

julia&gt; flipadiag(m) # flip elements along anti diagonal
2×2 Matrix{String}:
 &quot;a22&quot;  &quot;a12&quot;
 &quot;a21&quot;  &quot;a11&quot;"><pre>julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>]
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">unit</span>(m) <span class="pl-c"><span class="pl-c">#</span> identity</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rotate90</span>(m) <span class="pl-c"><span class="pl-c">#</span> rotate matrix by 90° to the right</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rotate180</span>(m) <span class="pl-c"><span class="pl-c">#</span> rotate by 180° (i.e., reverse elements)</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rotate270</span>(m) <span class="pl-c"><span class="pl-c">#</span> rotate 270° to the right (or 90° to the left)</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">flipx</span>(m) <span class="pl-c"><span class="pl-c">#</span> flip elements along x-axis</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">flipy</span>(m) <span class="pl-c"><span class="pl-c">#</span> flip elements along y-axis</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">flipdiag</span>(m) <span class="pl-c"><span class="pl-c">#</span> flip elements along main diagonal (i.e., transpose)</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">flipadiag</span>(m) <span class="pl-c"><span class="pl-c">#</span> flip elements along anti diagonal</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{String}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a22<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a12<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>a21<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>a11<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">To obtain all eight symmetries at once, you can use the <code>symmetries</code> function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; symmetries(m);"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">symmetries</span>(m);</pre></div>
<h2 dir="auto"><a id="user-content-symmetry-group-d4" class="anchor" aria-hidden="true" href="#symmetry-group-d4"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Symmetry group <em>D<sub>4</sub></em></h2>
<p dir="auto">Sometimes it might be useful to take advantage of the group structure of <em>D<sub>4</sub></em>. The group <em>D<sub>4</sub></em> consists of our group elements, the binary operation <code>∘</code>, and the unary operation <code>inv</code>. We can use this operations directly on our group elements:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; rotate90 ∘ rotate180
rotate270 (generic function with 1 method)

julia&gt; rotate180 ∘ rotate180
unit (generic function with 1 method)

julia&gt; inv(rotate270)
rotate90 (generic function with 1 method)

julia&gt; inv(flipdiag)
flipdiag (generic function with 1 method)"><pre>julia<span class="pl-k">&gt;</span> rotate90 <span class="pl-k">∘</span> rotate180
rotate270 (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> rotate180 <span class="pl-k">∘</span> rotate180
unit (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">inv</span>(rotate270)
rotate90 (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">inv</span>(flipdiag)
flipdiag (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)</pre></div>
<p dir="auto">We can make use of the fact that for group elements <em>g<sub>1</sub></em>,...,<em>g<sub>n</sub></em>, the transformation <em>g<sub>1</sub></em>(...<em>g<sub>n</sub></em>(<em>m</em>)...) can always be replaced by a single group element, i.e., by <em>g<sub>1</sub></em> ∘ ... ∘ <em>g<sub>n</sub></em>.<br>
This can improve performance because we effectively replace <em>n</em> computations by only a single computation. Consider this example where we want to validate that rotating by 180° twice indeed yields the original matrix:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; m = rand(10000, 10000); # some huge test matrix

julia&gt; @time rotate180(rotate180(m)) == m # this works but rotates the huge matrix twice
  0.228518 seconds (4 allocations: 1.490 GiB, 1.19% gc time)
true

julia&gt; @time (rotate180 ∘ rotate180)(m) == m # this is much more efficient as rotate180 ∘ rotate180 = unit = id
  0.045496 seconds
true"><pre>julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10000</span>, <span class="pl-c1">10000</span>); <span class="pl-c"><span class="pl-c">#</span> some huge test matrix</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> <span class="pl-c1">rotate180</span>(<span class="pl-c1">rotate180</span>(m)) <span class="pl-k">==</span> m <span class="pl-c"><span class="pl-c">#</span> this works but rotates the huge matrix twice</span>
  <span class="pl-c1">0.228518</span> seconds (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.490</span> GiB, <span class="pl-c1">1.19</span><span class="pl-k">%</span> gc time)
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> (rotate180 <span class="pl-k">∘</span> rotate180)(m) <span class="pl-k">==</span> m <span class="pl-c"><span class="pl-c">#</span> this is much more efficient as rotate180 ∘ rotate180 = unit = id</span>
  <span class="pl-c1">0.045496</span> seconds
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Admittedly, this example is somewhat artificial. Nevertheless, note the huge difference in allocated memory. This shows that whenever we have a situation where we need to apply multiple group elements consecutively, it is beneficial to take their composition first and apply it afterwards.</p>
<p dir="auto">It can also be useful to take the inverse of a group element. For example, consider you have an algorithm that performs some matrix transformation and this transformation should be invariant to the elements of <em>D<sub>4</sub></em>. Then, we could use the following code to verify this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; my_alg(m) = ... # some super clever matrix transformation

julia&gt; m = rand(10, 10); # our test matrix

julia&gt; for g in SquareSymmetries.D4
           @assert inv(g)(my_alg(g(m))) == my_alg(m)
       end "><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">my_alg</span>(m) <span class="pl-k">=</span> <span class="pl-k">...</span> <span class="pl-c"><span class="pl-c">#</span> some super clever matrix transformation</span>

julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10</span>, <span class="pl-c1">10</span>); <span class="pl-c"><span class="pl-c">#</span> our test matrix</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> g <span class="pl-k">in</span> SquareSymmetries<span class="pl-k">.</span>D4
           <span class="pl-c1">@assert</span> <span class="pl-c1">inv</span>(g)(<span class="pl-c1">my_alg</span>(<span class="pl-c1">g</span>(m))) <span class="pl-k">==</span> <span class="pl-c1">my_alg</span>(m)
       <span class="pl-k">end</span> </pre></div>
<p dir="auto">The above code checks that applying <code>my_alg</code> to <code>g(m)</code> and applying <code>inv(g)</code> (i.e., <em>g<sup>-1</sup></em>) to the output yields the same result as applying <code>my_alg</code> to <code>m</code> directly for all <em>g</em>.</p>
</article></div>