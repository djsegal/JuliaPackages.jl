<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-sphericalharmonicarrays" class="anchor" aria-hidden="true" href="#sphericalharmonicarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SphericalHarmonicArrays</h1>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/jishnub/SphericalHarmonicArrays.jl/workflows/CI/badge.svg?branch=master"><img src="https://github.com/jishnub/SphericalHarmonicArrays.jl/workflows/CI/badge.svg?branch=master" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jishnub/SphericalHarmonicArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ff76dfd4f1de3399b8a25a8820f318a3cde4d62aae6b9eaf6026d43e076f2eb3/68747470733a2f2f636f6465636f762e696f2f67682f6a6973686e75622f53706865726963616c4861726d6f6e69634172726179732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/jishnub/SphericalHarmonicArrays.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://jishnub.github.io/SphericalHarmonicArrays.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://jishnub.github.io/SphericalHarmonicArrays.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Arrays to store spherical-harmonic coefficients, that may be indexed by modes as well as array indices. The type used for this is named <code>SHArray</code>, and the aliases <code>SHVector</code> and <code>SHMatrix</code> are exported for covenience. <code>SHArray</code> is a wrapper around an underlying parent array, usually dense, that is indexed according to iterators that are specified while constructing the type. The arrays may have mixed axes, where certain axes are indexed using spherical harmonic modes whereas the others are indexed like the parent array.</p>
<h2 dir="auto"><a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting Started</h2>
<h3 dir="auto"><a id="user-content-installing" class="anchor" aria-hidden="true" href="#installing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installing</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ]
pkg&gt; add SphericalHarmonicArrays

julia&gt; using SphericalHarmonicArrays"><pre>julia<span class="pl-k">&gt;</span> ]
pkg<span class="pl-k">&gt;</span> add SphericalHarmonicArrays

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> SphericalHarmonicArrays</pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">This package uses iterators from <a href="https://github.com/jishnub/SphericalHarmonicModes.jl">SphericalHarmonicModes.jl</a> for indexing. All the iterators available in the package may be used as axes. Take a look at that package to understand more about the iterators being used here.</p>
<h2 dir="auto"><a id="user-content-shvector" class="anchor" aria-hidden="true" href="#shvector"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SHVector</h2>
<p dir="auto">An <code>SHVector</code> is a 1D array indexed using spherical harmonic modes.</p>
<h3 dir="auto"><a id="user-content-creating-an-shvector" class="anchor" aria-hidden="true" href="#creating-an-shvector"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Creating an SHVector</h3>
<p dir="auto">The simplest constructor assigns the array automatically based on the number of modes specified.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; modes=LM(1:1)
Spherical harmonic modes with l increasing faster than m
(l_min = 1, l_max = 1, m_min = -1, m_max = 1)

julia&gt; SHVector{Float64}(modes)
3-element SHArray(::Array{Float64,1}, (LM(1:1, -1:1),)):
 0.0
 0.0
 0.0"><pre>julia<span class="pl-k">&gt;</span> modes<span class="pl-k">=</span><span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)
Spherical harmonic modes with l increasing faster than m
(l_min <span class="pl-k">=</span> <span class="pl-c1">1</span>, l_max <span class="pl-k">=</span> <span class="pl-c1">1</span>, m_min <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>, m_max <span class="pl-k">=</span> <span class="pl-c1">1</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHVector</span><span class="pl-c1">{Float64}</span>(modes)
<span class="pl-c1">3</span><span class="pl-k">-</span>element <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,1}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>),))<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span></pre></div>
<p dir="auto">The parent array may be preallocated.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; v = ones(3);

julia&gt; shv = SHVector(v,modes)
3-element SHArray(::Array{Float64,1}, (LM(1:1, -1:1),)):
 1.0
 1.0
 1.0

julia&gt; v[1] = 4 # update the parent array
4

julia&gt; shv # updated as well
3-element SHArray{Float64,1,Array{Float64,1},Tuple{LM},1}:
 4.0
 1.0
 1.0"><pre>julia<span class="pl-k">&gt;</span> v <span class="pl-k">=</span> <span class="pl-c1">ones</span>(<span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> shv <span class="pl-k">=</span> <span class="pl-c1">SHVector</span>(v,modes)
<span class="pl-c1">3</span><span class="pl-k">-</span>element <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,1}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>),))<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span>
 <span class="pl-c1">1.0</span>
 <span class="pl-c1">1.0</span>

julia<span class="pl-k">&gt;</span> v[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">4</span> <span class="pl-c"><span class="pl-c">#</span> update the parent array</span>
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> shv <span class="pl-c"><span class="pl-c">#</span> updated as well</span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Float64,<span class="pl-c1">1</span>,Array{Float64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">4.0</span>
 <span class="pl-c1">1.0</span>
 <span class="pl-c1">1.0</span></pre></div>
<h3 dir="auto"><a id="user-content-indexing" class="anchor" aria-hidden="true" href="#indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Indexing</h3>
<p dir="auto">An <code>SHVector</code> may be indexed either linearly as a normal vector, or using the modes that are stored in the array. Linear indexing is faster as this simply passes the indices to the parent, so this is what should be used if all the indices of the array are being iterated over. Modes need to be specified as a tuple of integers, eg. <code>(l,m)</code>, corresponding to the type of axis iterator that was used to create the <code>SHVector</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; v = [1,2,3]; shv=SHVector(v, LM(1:1))
3-element SHArray{Int64,1,Array{Int64,1},Tuple{LM},1}:
 1
 2
 3

julia&gt; shv[2]
2

julia&gt; shv[(1,0)] # indexed using (l,m)
2

julia&gt; @btime $shv[2] # Linear indexing
  2.026 ns (0 allocations: 0 bytes)
2

julia&gt; mode=(1,0); @btime $shv[$mode] # Indexing using modes
  9.774 ns (0 allocations: 0 bytes)
2

julia&gt; @. shv = 56 # broadcasting works as expected
3-element Array{Int64,1}:
 56
 56
 56

julia&gt; shv[(1,-1)] = 6 # can set indices using modes, in this case it's specificed as an (l,m) pair
6

julia&gt; shv
3-element SHArray{Int64,1,Array{Int64,1},Tuple{LM},1}:
  6
 56
 56"><pre>julia<span class="pl-k">&gt;</span> v <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]; shv<span class="pl-k">=</span><span class="pl-c1">SHVector</span>(v, <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>))
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Int64,<span class="pl-c1">1</span>,Array{Int64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>
 <span class="pl-c1">2</span>
 <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> shv[<span class="pl-c1">2</span>]
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> shv[(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)] <span class="pl-c"><span class="pl-c">#</span> indexed using (l,m)</span>
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>shv[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> Linear indexing</span>
  <span class="pl-c1">2.026</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> mode<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>shv[<span class="pl-k">$</span>mode] <span class="pl-c"><span class="pl-c">#</span> Indexing using modes</span>
  <span class="pl-c1">9.774</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@.</span> shv <span class="pl-k">=</span> <span class="pl-c1">56</span> <span class="pl-c"><span class="pl-c">#</span> broadcasting works as expected</span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">56</span>
 <span class="pl-c1">56</span>
 <span class="pl-c1">56</span>

julia<span class="pl-k">&gt;</span> shv[(<span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span>)] <span class="pl-k">=</span> <span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span> can set indices using modes, in this case it's specificed as an (l,m) pair</span>
<span class="pl-c1">6</span>

julia<span class="pl-k">&gt;</span> shv
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Int64,<span class="pl-c1">1</span>,Array{Int64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
  <span class="pl-c1">6</span>
 <span class="pl-c1">56</span>
 <span class="pl-c1">56</span></pre></div>
<p dir="auto">Note that in this specific case it is more efficient to define the mode range as
<code>LM(SingleValuedRange(1))</code>. Using this, we obtain</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; shv = SHVector(v, LM(SingleValuedRange(1)));

julia&gt; mode=(1,0); @btime $shv[$mode]
  3.734 ns (0 allocations: 0 bytes)
2"><pre>julia<span class="pl-k">&gt;</span> shv <span class="pl-k">=</span> <span class="pl-c1">SHVector</span>(v, <span class="pl-c1">LM</span>(<span class="pl-c1">SingleValuedRange</span>(<span class="pl-c1">1</span>)));

julia<span class="pl-k">&gt;</span> mode<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>shv[<span class="pl-k">$</span>mode]
  <span class="pl-c1">3.734</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">2</span></pre></div>
<p dir="auto">Indexing operations are significantly more performant for arrays constructed using these special ranges.</p>
<h2 dir="auto"><a id="user-content-shmatrix" class="anchor" aria-hidden="true" href="#shmatrix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SHMatrix</h2>
<p dir="auto">An <code>SHMatrix</code> is a 2D array with both axes storing spherical harmonic coefficients.</p>
<h3 dir="auto"><a id="user-content-creating-an-shmatrix" class="anchor" aria-hidden="true" href="#creating-an-shmatrix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Creating an SHMatrix</h3>
<p dir="auto">The constructors are similar to those of <code>SHVector</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; SHMatrix{Float64}(LM(1:2, 1:1),LM(1:1))
2×3 SHArray(::Array{Float64,2}, (LM(1:2, 1:1), LM(1:1, -1:1))):
 0.0  0.0  0.0
 0.0  0.0  0.0

# may combine different iterators as axes
julia&gt; SHMatrix{Float64}(LM(1:2, 1:1),ML(1:1))
2×3 SHArray(::Array{Float64,2}, (LM(1:2, 1:1), ML(1:1, -1:1))):
 0.0  0.0  0.0
 0.0  0.0  0.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHMatrix</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>))
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

<span class="pl-c"><span class="pl-c">#</span> may combine different iterators as axes</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHMatrix</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>),<span class="pl-c1">ML</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>))
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>), <span class="pl-c1">ML</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span></pre></div>
<h3 dir="auto"><a id="user-content-indexing-1" class="anchor" aria-hidden="true" href="#indexing-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Indexing</h3>
<p dir="auto">The matrix elements may be accessed with a combination of mode indices or the index style of the parent array.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; shm = SHMatrix{Float64}(LM(1:2,1:1), LM(1:1))
2×3 SHArray(::Array{Float64,2}, (LM(1:2, 1:1), LM(1:1, -1:1))):
 0.0  0.0  0.0
 0.0  0.0  0.0

# Linear indexing works if the parent array supports it
julia&gt; for i in eachindex(shm)
       shm[i]=i
       end

julia&gt; shm
2×3 SHArray(::Array{Float64,2}, (LM(1:2, 1:1), LM(1:1, -1:1))):
 1.0  3.0  5.0
 2.0  4.0  6.0

# Both axes may be indexed using modes
julia&gt; shm[(1,1),(1,0)]
3.0

# Any axis may be indexed using the corresponding mode
julia&gt; shm[(1,1), 2]
3.0 + 0.0im

# May use any combination of Cartesian and fancy mode indexing
julia&gt; shm[1,2] == shm[(1,1),2] == shm[1,(1,0)] ==shm[(1,1),(1,0)]
true

julia&gt; mode1=(1,1);mode2=(1,0); @btime $shm[$mode1,$mode2] # twice as expensive as SHVector
  19.026 ns (0 allocations: 0 bytes)
3.0 + 0.0im"><pre>julia<span class="pl-k">&gt;</span> shm <span class="pl-k">=</span> <span class="pl-c1">SHMatrix</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>))
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

<span class="pl-c"><span class="pl-c">#</span> Linear indexing works if the parent array supports it</span>
julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(shm)
       shm[i]<span class="pl-k">=</span>i
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> shm
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span>  <span class="pl-c1">3.0</span>  <span class="pl-c1">5.0</span>
 <span class="pl-c1">2.0</span>  <span class="pl-c1">4.0</span>  <span class="pl-c1">6.0</span>

<span class="pl-c"><span class="pl-c">#</span> Both axes may be indexed using modes</span>
julia<span class="pl-k">&gt;</span> shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)]
<span class="pl-c1">3.0</span>

<span class="pl-c"><span class="pl-c">#</span> Any axis may be indexed using the corresponding mode</span>
julia<span class="pl-k">&gt;</span> shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>), <span class="pl-c1">2</span>]
<span class="pl-c1">3.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span>

<span class="pl-c"><span class="pl-c">#</span> May use any combination of Cartesian and fancy mode indexing</span>
julia<span class="pl-k">&gt;</span> shm[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">==</span> shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),<span class="pl-c1">2</span>] <span class="pl-k">==</span> shm[<span class="pl-c1">1</span>,(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)] <span class="pl-k">==</span>shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)]
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> mode1<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>);mode2<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>shm[<span class="pl-k">$</span>mode1,<span class="pl-k">$</span>mode2] <span class="pl-c"><span class="pl-c">#</span> twice as expensive as SHVector</span>
  <span class="pl-c1">19.026</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">3.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span></pre></div>
<h2 dir="auto"><a id="user-content-sharray" class="anchor" aria-hidden="true" href="#sharray"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SHArray</h2>
<p dir="auto">This is the most general type of an array with any axis possibly being indexed using a collection of modes. This differs from the previously described aliases as some (or all) axes need not be indexed using modes.</p>
<h3 dir="auto"><a id="user-content-creating-an-sharray" class="anchor" aria-hidden="true" href="#creating-an-sharray"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Creating an SHArray</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; sha = SHArray(zeros(1),(LM(1:1,0:0),))
1-element SHArray(::Array{Float64,1}, (LM(1:1, 0:0),)):
 0.0

# SHVector is an alias for a 1D SHArray that is indexed with modes
julia&gt; sha isa SHVector
true

julia&gt; SHArray{Float64}((LM(1:1,0:0),1:2)) # supports OffsetArrays
1×2 SHArray(OffsetArray(::Array{Float64,2}, 1:1, 1:2), (LM(1:1, 0:0), 1:2)) with indices 1:1×1:2:
 0.0  0.0"><pre>julia<span class="pl-k">&gt;</span> sha <span class="pl-k">=</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">1</span>),(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),))
<span class="pl-c1">1</span><span class="pl-k">-</span>element <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,1}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),))<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>

<span class="pl-c"><span class="pl-c">#</span> SHVector is an alias for a 1D SHArray that is indexed with modes</span>
julia<span class="pl-k">&gt;</span> sha <span class="pl-k">isa</span> SHVector
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHArray</span><span class="pl-c1">{Float64}</span>((<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) <span class="pl-c"><span class="pl-c">#</span> supports OffsetArrays</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">OffsetArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>), (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>), <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span></pre></div>
<p dir="auto">The arrays may have mixed axes, where some store spherical harmonic modes and some don't.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; sha = SHArray{Float64}((LM(1:1,0:0),-1:1,ML(0:1,0:0)))
1×3×2 SHArray(OffsetArray(::Array{Float64,3}, 1:1, -1:1, 1:2), (LM(1:1, 0:0), -1:1, ML(0:1, 0:0))) with indices 1:1×-1:1×1:2:
[:, :, 1] =
 0.0  0.0  0.0

[:, :, 2] =
 0.0  0.0  0.0"><pre>julia<span class="pl-k">&gt;</span> sha <span class="pl-k">=</span> <span class="pl-c1">SHArray</span><span class="pl-c1">{Float64}</span>((<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">ML</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>)))
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">OffsetArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,3}</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>), (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>), <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">ML</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>))) with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span></pre></div>
<h3 dir="auto"><a id="user-content-indexing-2" class="anchor" aria-hidden="true" href="#indexing-2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Indexing</h3>
<p dir="auto">Indexing is similar to <code>SHVector</code> and <code>SHMatrix</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; SHArray{Float64}((1:1, LM(1:1,0:1)))
1×2 SHArray(OffsetArray(::Array{Float64,2}, 1:1, 1:2), (1:1, LM(1:1, 0:1))) with indices 1:1×1:2:
 0.0  0.0

julia&gt; sha[1,(1,0)] = 4 # first index
4

julia&gt; sha[1,2] = 5 # second index
5

julia&gt; sha
1×2 SHArray(OffsetArray(::Array{Float64,2}, 1:1, 1:2), (1:1, LM(1:1, 0:1))) with indices 1:1×1:2:
 4.0  5.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHArray</span><span class="pl-c1">{Float64}</span>((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>)))
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">OffsetArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>), (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>))) with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

julia<span class="pl-k">&gt;</span> sha[<span class="pl-c1">1</span>,(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)] <span class="pl-k">=</span> <span class="pl-c1">4</span> <span class="pl-c"><span class="pl-c">#</span> first index</span>
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> sha[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">5</span> <span class="pl-c"><span class="pl-c">#</span> second index</span>
<span class="pl-c1">5</span>

julia<span class="pl-k">&gt;</span> sha
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">OffsetArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>), (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>))) with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">4.0</span>  <span class="pl-c1">5.0</span></pre></div>
<h2 dir="auto"><a id="user-content-broadcasting" class="anchor" aria-hidden="true" href="#broadcasting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Broadcasting</h2>
<p dir="auto"><code>SHArray</code>s retain information about their modes upon broadcasting. If multiple <code>SHArray</code>s are involved in a broadcast operation, the result has the same axes as the one with the most dimensions. The dimensions being broadcasted over, if indexed with modes, have to exactly match for all the <code>SHArray</code>s involved in the operation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; s = SHMatrix{Float64}(LM(1:1,0:0),LM(1:1,-1:0)); s .= 4
1×2 SHArray(::Array{Float64,2}, (LM(1:1, 0:0), LM(1:1, -1:0))):
 4.0  4.0

julia&gt; s + s
1×2 SHArray(::Array{Float64,2}, (LM(1:1, 0:0), LM(1:1, -1:0))):
 8.0  8.0

julia&gt; s .* s
1×2 SHArray(::Array{Float64,2}, (LM(1:1, 0:0), LM(1:1, -1:0))):
 16.0  16.0

julia&gt; sv = SHVector{Float64}(first(SphericalHarmonicArrays.modes(s))); sv .= 6;

julia&gt; s .* sv # Leading dimensions of s and sv are the same
1×2 SHArray(::Array{Float64,2}, (LM(1:1, 0:0), LM(1:1, -1:0))):
 24.0  24.0"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">SHMatrix</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>)); s <span class="pl-k">.=</span> <span class="pl-c1">4</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">4.0</span>  <span class="pl-c1">4.0</span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">+</span> s
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">8.0</span>  <span class="pl-c1">8.0</span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">.*</span> s
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">16.0</span>  <span class="pl-c1">16.0</span>

julia<span class="pl-k">&gt;</span> sv <span class="pl-k">=</span> <span class="pl-c1">SHVector</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">first</span>(SphericalHarmonicArrays<span class="pl-k">.</span><span class="pl-c1">modes</span>(s))); sv <span class="pl-k">.=</span> <span class="pl-c1">6</span>;

julia<span class="pl-k">&gt;</span> s <span class="pl-k">.*</span> sv <span class="pl-c"><span class="pl-c">#</span> Leading dimensions of s and sv are the same</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">SHArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, (<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>), <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>)))<span class="pl-k">:</span>
 <span class="pl-c1">24.0</span>  <span class="pl-c1">24.0</span></pre></div>
<p dir="auto">Broadcasting operations might be slow, so watch out for performance drops.</p>
</article></div>