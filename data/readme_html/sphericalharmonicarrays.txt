<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-sphericalharmonicarrays" class="anchor" aria-hidden="true" href="#sphericalharmonicarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SphericalHarmonicArrays</h1>
<p><a href="https://travis-ci.com/jishnub/SphericalHarmonicArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f50734a1f95e2eeff894b6061c1c34c7be35030a/68747470733a2f2f7472617669732d63692e636f6d2f6a6973686e75622f53706865726963616c4861726d6f6e69634172726179732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jishnub/SphericalHarmonicArrays.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/jishnub/SphericalHarmonicArrays-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/73ab9366fd9d5b9cbc3aa0d4893667a77ceadd4f/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f6a6973686e75622f53706865726963616c4861726d6f6e69634172726179732e6a6c3f7376673d74727565" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/jishnub/SphericalHarmonicArrays.jl?svg=true" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/jishnub/SphericalHarmonicArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/32d1e8a4592366c6bcd6e9439bd1261bf7a21874/68747470733a2f2f636f6465636f762e696f2f67682f6a6973686e75622f53706865726963616c4861726d6f6e69634172726179732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/jishnub/SphericalHarmonicArrays.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>Arrays to store spherical-harmonic coefficients, that may be indexed by modes as well as array indices. The type used for this is named <code>SHArray</code>, and aliases such as <code>SHVector</code> and <code>SHMatrix</code> are exported for covenience. <code>SHArray</code> is a wrapper around an underlying parent array, usually dense, that is indexed according to iterators that are specified while constructing the type. The arrays may have mixed axes, where certain axes are indexed using spherical harmonic modes whereas the others are indexed like the parent array.</p>
<h2><a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Getting Started</h2>
<h3><a id="user-content-installing" class="anchor" aria-hidden="true" href="#installing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installing</h3>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> ]
pkg<span class="pl-k">&gt;</span> add SphericalHarmonicArrays

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> SphericalHarmonicArrays</pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>This package uses iterators from <a href="https://github.com/jishnub/SphericalHarmonicModes.jl">SphericalHarmonicModes.jl</a> for indexing. All the iterators available in the package may be used as axes. Take a look at that package to understand more about the iterators being used here.</p>
<h2><a id="user-content-shvector" class="anchor" aria-hidden="true" href="#shvector"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SHVector</h2>
<p>An <code>SHVector</code> is a 1D array indexed using spherical harmonic modes.</p>
<h3><a id="user-content-creating-an-shvector" class="anchor" aria-hidden="true" href="#creating-an-shvector"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Creating an SHVector</h3>
<p>The simplest constructor assigns the array automatically based on the number of modes specified.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> modes<span class="pl-k">=</span><span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)
Spherical harmonic modes with l increasing faster than m
(l_min <span class="pl-k">=</span> <span class="pl-c1">1</span>, l_max <span class="pl-k">=</span> <span class="pl-c1">1</span>, m_min <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>, m_max <span class="pl-k">=</span> <span class="pl-c1">1</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHVector</span>(modes) <span class="pl-c"><span class="pl-c">#</span> will assign an array to store the correct number of modes, 3 in this case</span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Complex{Float64},<span class="pl-c1">1</span>,Array{Complex{Float64},<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span></pre></div>
<p>The default element type of the parent array is <code>ComplexF64</code>, however this may be specified in the constructor.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHVector</span><span class="pl-c1">{Int}</span>(modes)
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Int64,<span class="pl-c1">1</span>,Array{Int64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>
 <span class="pl-c1">0</span></pre></div>
<p>The parent array may be preallocated.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> v<span class="pl-k">=</span><span class="pl-c1">ones</span>(<span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> shv<span class="pl-k">=</span><span class="pl-c1">SHVector</span>(v,modes)
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Float64,<span class="pl-c1">1</span>,Array{Float64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span>
 <span class="pl-c1">1.0</span>
 <span class="pl-c1">1.0</span>

julia<span class="pl-k">&gt;</span> v[<span class="pl-c1">1</span>]<span class="pl-k">=</span><span class="pl-c1">4</span> <span class="pl-c"><span class="pl-c">#</span> update the parent array</span>
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> shv <span class="pl-c"><span class="pl-c">#</span> updated as well</span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Float64,<span class="pl-c1">1</span>,Array{Float64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">4.0</span>
 <span class="pl-c1">1.0</span>
 <span class="pl-c1">1.0</span></pre></div>
<h3><a id="user-content-indexing" class="anchor" aria-hidden="true" href="#indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Indexing</h3>
<p>An <code>SHVector</code> may be indexed either linearly as a normal vector, or using the modes that are stored in the array. Linear indexing is faster as this simply passes the indices to the parent, so this is what should be used if all the indices of the array are being iterated over. Modes need to be specified as a tuple of integers, eg. <code>(l,m)</code>, corresponding to the type of axis iterator that was used to create the <code>SHVector</code>.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> v<span class="pl-k">=</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];shv<span class="pl-k">=</span><span class="pl-c1">SHVector</span>(v,<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>))
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Int64,<span class="pl-c1">1</span>,Array{Int64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>
 <span class="pl-c1">2</span>
 <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> shv[<span class="pl-c1">2</span>]
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> shv[(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)] <span class="pl-c"><span class="pl-c">#</span> indexed using (l,m)</span>
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>shv[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> Linear indexing</span>
  <span class="pl-c1">2.026</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> mode<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>shv[<span class="pl-k">$</span>mode] <span class="pl-c"><span class="pl-c">#</span> Indexing using modes</span>
  <span class="pl-c1">9.774</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@.</span> shv <span class="pl-k">=</span> <span class="pl-c1">56</span> <span class="pl-c"><span class="pl-c">#</span> broadcasting works as expected</span>
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">56</span>
 <span class="pl-c1">56</span>
 <span class="pl-c1">56</span>

julia<span class="pl-k">&gt;</span> shv[(<span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">=</span><span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span> can set indices using modes, in this case it's specificed as an (l,m) pair</span>
<span class="pl-c1">6</span>

julia<span class="pl-k">&gt;</span> shv
<span class="pl-c1">3</span><span class="pl-k">-</span>element SHArray{Int64,<span class="pl-c1">1</span>,Array{Int64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
  <span class="pl-c1">6</span>
 <span class="pl-c1">56</span>
 <span class="pl-c1">56</span></pre></div>
<h2><a id="user-content-shmatrix" class="anchor" aria-hidden="true" href="#shmatrix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SHMatrix</h2>
<p>An <code>SHMatrix</code> is a 2D array with both axes storing spherical harmonic coefficients.</p>
<h3><a id="user-content-creating-an-shmatrix" class="anchor" aria-hidden="true" href="#creating-an-shmatrix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Creating an SHMatrix</h3>
<p>The constructors are similar to those of <code>SHVector</code>.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHMatrix</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>)) <span class="pl-c"><span class="pl-c">#</span> need to speficy two axes</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,LM},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

<span class="pl-c"><span class="pl-c">#</span> may combine different iterators as axes</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHMatrix</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>),<span class="pl-c1">ML</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>))
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,ML},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span></pre></div>
<h3><a id="user-content-indexing-1" class="anchor" aria-hidden="true" href="#indexing-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Indexing</h3>
<p>The matrix elements may be accessed with a combination of mode indices or the index style of the parent array.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> shm<span class="pl-k">=</span><span class="pl-c1">SHMatrix</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>))
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,LM},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

<span class="pl-c"><span class="pl-c">#</span> Linear indexing works if the parent array supports it</span>
julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(shm)
       shm[i]<span class="pl-k">=</span>i
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> shm
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,LM},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">3.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">5.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>
 <span class="pl-c1">2.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">4.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">6.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

<span class="pl-c"><span class="pl-c">#</span> Both axes may be indexed using modes</span>
julia<span class="pl-k">&gt;</span> shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)]
<span class="pl-c1">3.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span>

<span class="pl-c"><span class="pl-c">#</span> Any axis may be indexed using the corresponding mode</span>
julia<span class="pl-k">&gt;</span> shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),<span class="pl-c1">2</span>]
<span class="pl-c1">3.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span>

<span class="pl-c"><span class="pl-c">#</span> May use any combination of Cartesian and fancy mode indexing</span>
julia<span class="pl-k">&gt;</span> shm[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">==</span> shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),<span class="pl-c1">2</span>] <span class="pl-k">==</span> shm[<span class="pl-c1">1</span>,(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)] <span class="pl-k">==</span>shm[(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)]
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> mode1<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>);mode2<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>shm[<span class="pl-k">$</span>mode1,<span class="pl-k">$</span>mode2] <span class="pl-c"><span class="pl-c">#</span> twice as expensive as SHVector</span>
  <span class="pl-c1">19.026</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">3.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span></pre></div>
<h2><a id="user-content-sharray" class="anchor" aria-hidden="true" href="#sharray"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SHArray</h2>
<p>This is the most general type of an array with any axis possibly being indexed using a collection of modes. This differs from the previously described aliases as some (or all) axes need not be indexed using modes.</p>
<h3><a id="user-content-creating-an-sharray" class="anchor" aria-hidden="true" href="#creating-an-sharray"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Creating an SHArray</h3>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> sha <span class="pl-k">=</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">1</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>))
<span class="pl-c1">1</span><span class="pl-k">-</span>element SHArray{Float64,<span class="pl-c1">1</span>,Array{Float64,<span class="pl-c1">1</span>},Tuple{LM},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>

<span class="pl-c"><span class="pl-c">#</span> SHVector is an alias for a 1D SHArray that is indexed with modes</span>
julia<span class="pl-k">&gt;</span> sha <span class="pl-k">isa</span> SHVector
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> returns an OffsetArray</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,OffsetArrays<span class="pl-k">.</span>OffsetArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>}},Tuple{LM,UnitRange{Int64}},<span class="pl-c1">1</span>} with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span></pre></div>
<p>If no parent array is specified and the first axis is a subtype of <code>AbstractArray</code>, the modes necessarily need to be passed as a <code>Tuple</code> to avoid ambiguity. This is because it's otherwise unclear if the first argument is the parent array or the first axis.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHArray</span>((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>))) <span class="pl-c"><span class="pl-c">#</span> second axis stores modes</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,OffsetArrays<span class="pl-k">.</span>OffsetArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>}},Tuple{UnitRange{Int64},LM},<span class="pl-c1">1</span>} with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

julia<span class="pl-k">&gt;</span> sha <span class="pl-k">=</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">ML</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>)) <span class="pl-c"><span class="pl-c">#</span> both axes stores modes</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Float64,<span class="pl-c1">2</span>,Array{Float64,<span class="pl-c1">2</span>},Tuple{LM,ML},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

<span class="pl-c"><span class="pl-c">#</span> SHMatrix is an alias for a 2D SHArray with both axes indexed with modes</span>
julia<span class="pl-k">&gt;</span> sha <span class="pl-k">isa</span> SHMatrix 
<span class="pl-c1">true</span></pre></div>
<p>It is also possible to create an empty wrapper around an array. This is essentially equivalent to an array and is retained for completeness.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)) <span class="pl-c"><span class="pl-c">#</span> no modes, equivalent to an Array</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Float64,<span class="pl-c1">2</span>,Array{Float64,<span class="pl-c1">2</span>},Tuple{Base<span class="pl-k">.</span>OneTo{Int64},Base<span class="pl-k">.</span>OneTo{Int64}},<span class="pl-c1">0</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span></pre></div>
<p>The arrays may have mixed axes, where some store spherical harmonic modes and some don't.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> sha <span class="pl-k">=</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,<span class="pl-c1">ML</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>)) <span class="pl-c"><span class="pl-c">#</span> mixed axes</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">3</span>,OffsetArrays<span class="pl-k">.</span>OffsetArray{Complex{Float64},<span class="pl-c1">3</span>,Array{Complex{Float64},<span class="pl-c1">3</span>}},Tuple{LM,UnitRange{Int64},ML},<span class="pl-c1">2</span>} with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span></pre></div>
<h3><a id="user-content-indexing-2" class="anchor" aria-hidden="true" href="#indexing-2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Indexing</h3>
<p>Indexing is similar to <code>SHVector</code> and <code>SHMatrix</code>. The performance depends on the number of axes being indexed with modes.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> sha <span class="pl-k">=</span> <span class="pl-c1">SHArray</span>((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>)))
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,OffsetArrays<span class="pl-k">.</span>OffsetArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>}},Tuple{UnitRange{Int64},LM},<span class="pl-c1">1</span>} with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">0.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

julia<span class="pl-k">&gt;</span> sha[<span class="pl-c1">1</span>,(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)]<span class="pl-k">=</span><span class="pl-c1">4</span> <span class="pl-c"><span class="pl-c">#</span> first index</span>
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> sha[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]<span class="pl-k">=</span><span class="pl-c1">5</span> <span class="pl-c"><span class="pl-c">#</span> second index</span>
<span class="pl-c1">5</span>

julia<span class="pl-k">&gt;</span> sha
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,OffsetArrays<span class="pl-k">.</span>OffsetArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>}},Tuple{UnitRange{Int64},LM},<span class="pl-c1">1</span>} with indices <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>
 <span class="pl-c1">4.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">5.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

julia<span class="pl-k">&gt;</span> sha <span class="pl-k">=</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,<span class="pl-c1">ML</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>));

julia<span class="pl-k">&gt;</span> mode1<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>);mode2<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>sha[<span class="pl-k">$</span>mode1,<span class="pl-c1">1</span>,<span class="pl-k">$</span>mode2]
  <span class="pl-c1">19.842</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">0.0</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span></pre></div>
<h2><a id="user-content-broadcasting" class="anchor" aria-hidden="true" href="#broadcasting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Broadcasting</h2>
<p><code>SHArray</code>s retain information about their modes upon broadcasting. If multiple <code>SHArray</code>s are involved in a broadcast operation, the result has the same axes as the one with the most dimensions. The dimensions being broadcasted over, if indexed with modes, have to exactly match for all the <code>SHArray</code>s involved in the operation.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">SHMatrix</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>));s <span class="pl-k">.=</span> <span class="pl-c1">4</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,LM},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">4.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">4.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">+</span> s
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,LM},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">8.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">8.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">.*</span> s
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,LM},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">16.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">16.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>

julia<span class="pl-k">&gt;</span> sv <span class="pl-k">=</span> <span class="pl-c1">SHVector</span>(<span class="pl-c1">first</span>(<span class="pl-c1">modes</span>(s)));sv <span class="pl-k">.=</span> <span class="pl-c1">6</span>;

julia<span class="pl-k">&gt;</span> s <span class="pl-k">.*</span> sv <span class="pl-c"><span class="pl-c">#</span> Leading dimensions of s and sv are the same</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">2</span> SHArray{Complex{Float64},<span class="pl-c1">2</span>,Array{Complex{Float64},<span class="pl-c1">2</span>},Tuple{LM,LM},<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">24.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span>  <span class="pl-c1">24.0</span><span class="pl-k">+</span><span class="pl-c1">0.0im</span></pre></div>
<p>Broadcasting operations might be slow, so watch out for performance drops.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> sm <span class="pl-k">=</span> <span class="pl-c1">SHMatrix</span>(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>));a <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">size</span>(sm));oa <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">map</span>(UnitRange,<span class="pl-c1">axes</span>(sm)));

<span class="pl-c"><span class="pl-c">#</span> Arrays are the fastest</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">@.</span> <span class="pl-k">$</span>a <span class="pl-k">+</span> <span class="pl-k">$</span>a;
  <span class="pl-c1">37.537</span> ns (<span class="pl-c1">1</span> allocation<span class="pl-k">:</span> <span class="pl-c1">96</span> bytes)

 <span class="pl-c"><span class="pl-c">#</span> OffsetArrays are slightly less performant</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">@.</span> <span class="pl-k">$</span>oa <span class="pl-k">+</span> <span class="pl-k">$</span>oa;
  <span class="pl-c1">47.043</span> ns (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">128</span> bytes)

<span class="pl-c"><span class="pl-c">#</span> SHMatrices are significantly less so</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">@.</span> <span class="pl-k">$</span>sm <span class="pl-k">+</span> <span class="pl-k">$</span>sm;
  <span class="pl-c1">80.524</span> ns (<span class="pl-c1">3</span> allocations<span class="pl-k">:</span> <span class="pl-c1">240</span> bytes)

julia<span class="pl-k">&gt;</span> sa <span class="pl-k">=</span> <span class="pl-c1">SHArray</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>),(<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0</span>),<span class="pl-c1">LM</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>)));

<span class="pl-c"><span class="pl-c">#</span> SHArrays that use an OffsetArray as the parent are even slower</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">@.</span> <span class="pl-k">$</span>sa <span class="pl-k">+</span> <span class="pl-k">$</span>sa;
  <span class="pl-c1">111.421</span> ns (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">256</span> bytes)

<span class="pl-c"><span class="pl-c">#</span> We may operate on the underlying array to regain performance, if the axes permit this.</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">parent</span>(<span class="pl-c1">parent</span>(<span class="pl-k">$</span>sa)) <span class="pl-k">.+</span> <span class="pl-c1">parent</span>(<span class="pl-c1">parent</span>(<span class="pl-k">$</span>sa));
  <span class="pl-c1">37.295</span> ns (<span class="pl-c1">1</span> allocation<span class="pl-k">:</span> <span class="pl-c1">96</span> bytes)</pre></div>
</article></div>