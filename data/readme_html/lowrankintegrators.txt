<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-lowrankintegratorsjl--" class="anchor" aria-hidden="true" href="#lowrankintegratorsjl--"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LowRankIntegrators.jl â€ƒ <a target="_blank" rel="noopener noreferrer" href="docs/assets/lowrankintegrators_logo.png"><img align="center" src="docs/assets/lowrankintegrators_logo.png" alt="logo" width="150/" style="max-width: 100%;"></a></h1>
<p dir="auto"><a href="https://github.com/FHoltorf/LowRankIntegrators.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/FHoltorf/LowRankIntegrators.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/FHoltorf/LowRankIntegrators.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/2f2791098592f741918fff817946c91668df4d660ba160be9ef47051a287d22f/68747470733a2f2f636f6465636f762e696f2f67682f46486f6c746f72662f4c6f7752616e6b496e7465677261746f72732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/FHoltorf/LowRankIntegrators.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">LowRankIntegrators.jl is a package for dynamical low rank approximation (DLRA) in Julia. DLRA can help you approximate the solution to (otherwise intractably) large matrix-valued ODEs.</p>
<h2 dir="auto"><a id="user-content-concept" class="anchor" aria-hidden="true" href="#concept"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Concept</h2>
<p dir="auto">Given a matrix-valued ODE,</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
\frac{dX}{dt}(t) = F(X(t),t), \ X(0) = X_0, \text{ for all } t \in [t_0, t_f]
$$</math-renderer></p>
<p dir="auto">with <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$X(t) \in \mathbb{R}^{n\times m}$</math-renderer> for all <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$t \in [t_0,t_f]$</math-renderer>, DLRA seeks to identify a rank <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$r \ll \min(n,m)$</math-renderer> approximation <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$Y(t)$</math-renderer> to the true solution <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$X(t)$</math-renderer>. This reduces memory requirements and under appropriate structural assumptions on the flow map <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$F$</math-renderer> can also speed up integration substantially.</p>
<p dir="auto">Conceptually, DLRA propagates a rank <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$r$</math-renderer> approximation of the intial condition (usually <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$Y(0) = \Pi_{\mathcal{M}_r} X_0$</math-renderer>, i.e., projection of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$X(0)$</math-renderer> onto the manifold of rank <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$r$</math-renderer> matrices) forward in time according to the Dirac-Frenkel time-varying variational principle:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
\frac{dY}{dt}(t) \in \mathcal{T}_{\mathcal{M}_r}(Y(t)) \text{ s.t. } \left| \frac{dY}{dt}(t) - F(Y(t),t) \right|_F \to \min
$$</math-renderer></p>
<p dir="auto">Here, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$\mathcal{T}_{\mathcal{M}_r}(Y(t))$</math-renderer> refers to the tangent space of the manifold of real <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$n\times m$</math-renderer> matrices of rank <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$r$</math-renderer> at the point <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$Y(t)$</math-renderer>. In other words, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$Y(t)$</math-renderer> is evolved according to the dynamics</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
\frac{dY}{dt}(t) = \Pi_{\mathcal{T}_{\mathcal{M}_r}(Y(t))} F(Y(t),t).
$$</math-renderer></p>
<p align="center" dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="docs/assets/DLRA_geometry.png"><img src="docs/assets/DLRA_geometry.png" alt="logo" width="400/" style="max-width: 100%;"></a> 
</p>
<h2 dir="auto">
<a id="user-content-example-applications" class="anchor" aria-hidden="true" href="#example-applications"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example applications</h2>
<p dir="auto">While seemingly abstract at first, the solution of exceedingly large matrix-valued ODEs is quite a common problem. In the following we briefly discuss two general applications.</p>
<h3 dir="auto">
<a id="user-content-time-series-data-compression" class="anchor" aria-hidden="true" href="#time-series-data-compression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Time series data compression</h3>
<p dir="auto">Given a stream of data as described by a function <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$A:[t_0,t_f] \to \mathbb{R}^{n\times m}$</math-renderer> mapping time point to a data matrix - for example a movie - we may consider the problem of compressing this data stream. This can be cast as solving a matrix-valued ODE</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
\frac{dX}{dt}(t) = \frac{dA}{dt}(t), \ X(0)= A(0), \text{ for all } t\in [t_0, t_f].
$$</math-renderer></p>
<p dir="auto">Thus, DLRA can be used to propagate a compression of this data forward in time which can be substantially cheaper than compressing the data at every instant of time with other methods.</p>
<h3 dir="auto">
<a id="user-content-uncertainty-quantification" class="anchor" aria-hidden="true" href="#uncertainty-quantification"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Uncertainty quantification</h3>
<p dir="auto">Given a parametric <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$n$</math-renderer>-dimensional ODE,</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
\frac{dx}{dt}(p;t) = f(x(p;t),p, t), \ x(p;0) = x_0(p), \text{ for all } t\in[t_0, t_f]
$$</math-renderer></p>
<p dir="auto">one often wishes to understand the parametric dependence of its solution. Arguably the simplest approach to this problem is sampling, where the ODE is simply evaluated for <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$m$</math-renderer> parameter values <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$p_1, \dots, p_m$</math-renderer>. In many cases, however, it may be exceedingly expensive to evaluate the above ODE <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$m$</math-renderer> times, in particular when the dimension <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$n$</math-renderer> of the state is large. In those cases, DLRA may provide a means to recover tractability of the sampling procedure at the cost of some amount of approximation. To see this, note that the solution of the sampling procedure may be arranged in a <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$n\times m$</math-renderer> matrix</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
X(t) := \begin{bmatrix}x(p_1;t) &amp; \cdots &amp; x(p_m;t) \end{bmatrix}
$$</math-renderer></p>
<p dir="auto">whose dynamics are governed by</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
F(X(t),t) := \begin{bmatrix}f(x(p_1;t),p_1,t) &amp; \cdots &amp; f(x(p_m;t), p_m, t) \end{bmatrix}.
$$</math-renderer></p>
<p dir="auto">Note further that applying DLRA to this problem can be viewed as applying a quite intuitive function expansion strategy to express the parametric solution <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$x(p;t)$</math-renderer>. Similar strategies form the basis of other uncertainty quantification methods such as polynomial chaos expansion. In particular, the use of DLRA can be viewed as the discrete analog of applying the following expansion Ansatz to the parametric solution <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$x(p;t)$</math-renderer>:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
x(p;t) \approx \sum_{i=1}^r u_i(t) z_i(p;t)
$$</math-renderer></p>
<p dir="auto">where, in contrast to other methods, the expansion modes <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$u_i(t)$</math-renderer> are allowed to vary over time rendering this Ansatz strictly more expressive than classical AnsÃ¤tze.</p>
<h2 dir="auto">
<a id="user-content-primitives" class="anchor" aria-hidden="true" href="#primitives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Primitives</h2>
<p dir="auto">LowRankIntegrators.jl relies on a handful of primitives to enable the non-intrusive use of DLRA. These are described below.</p>
<h3 dir="auto">
<a id="user-content-matrixdeproblem" class="anchor" aria-hidden="true" href="#matrixdeproblem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MatrixDEProblem</h3>
<p dir="auto">Given a matrix differential equation</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$$
\frac{dX}{dt}(t) = F(X(t),t), \ X(0) = X_0, \text{ for all } t \in [t_0, t_f]
$$</math-renderer></p>
<p dir="auto">to be approximately solved via DLRA, the problem shall be set up as <code>MatrixDEProblem(F,Y0,tspan)</code> where</p>
<ul dir="auto">
<li>
<code>F</code> is the right-hand-side of the matrix ODE. <code>F</code> must accept two arguments, the first one being the (matrix-valued) state and the second time (or appropriate independent variable).</li>
<li>
<code>Y0</code> is a low rank approximation of the initial condition. The rank of <code>Y0</code> determines the rank of the approximation unless a rank-adaptive integrator is used. <code>Y0</code> is to be of type <code>SVDLikeRepresentation</code> (see LowRankArithmetic.jl for details).</li>
<li>
<code>tspan</code> is a tuple holding the initial and final time for integration.</li>
</ul>
<h3 dir="auto">
<a id="user-content-matrixdataproblem" class="anchor" aria-hidden="true" href="#matrixdataproblem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MatrixDataProblem</h3>
<p dir="auto">If a data stream (or discrete sequence of data snapshots) is to be compressed via DLRA, then additional structure can be exploited. In this case, the problem shall be defined as <code>MatrixDataProblem(A,Y0,tspan)</code> where</p>
<ul dir="auto">
<li>
<code>A</code> is a function that describes the data stream, i.e., <code>A(t)</code> returns the data snapshot at time <code>t</code>.</li>
<li>
<code>Y0</code> is a low rank approximation of the initial data point <code>A(0)</code>. The rank of <code>Y0</code> determines the rank of the approximation unless a rank-adaptive integrator is used. <code>Y0</code> is to be of type <code>SVDLikeRepresentation</code> (see LowRankArithmetic.jl for details).</li>
<li>
<code>tspan</code> is a tuple holding the initial and final time for integration.</li>
</ul>
<p dir="auto">If the data stream is not available continuously, but instead in form of discrete (time-ordered) snapshots, the problem shall be defined as <code>MatrixDataProblem(A,Y0,tspan)</code> where</p>
<ul dir="auto">
<li>
<code>A</code> is a (time-ordered) vector of data matrix snapshots.</li>
<li>
<code>Y0</code> is a low rank approximation of the initial data point <code>A(0)</code>. The rank of <code>Y0</code> determines the rank of the approximation unless a rank-adaptive integrator is used.</li>
</ul>
<h3 dir="auto">
<a id="user-content-lowrankarithmeticjl" class="anchor" aria-hidden="true" href="#lowrankarithmeticjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LowRankArithmetic.jl</h3>
<p dir="auto">A key ingredient that allows LowRankIntegrators.jl to implement DLRA with minimal intrusion is <a href="https://github.com/FHoltorf/LowRankArithmetic.jl">LowRankArithmetic.jl</a>. Specifically, <a href="https://github.com/FHoltorf/LowRankArithmetic.jl">LowRankArithmetic.jl</a> facilitates the propagation of low rank factorizations through finite compositions of a <a href="https://github.com/FHoltorf/LowRankArithmetic.jl#readme">wide range</a> of arithmetic operations. This critically allows to take advantage of the low rank structure of the approximate solution <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$Y(t)$</math-renderer> when evaluating the dynamics <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$F(Y(t),t)$</math-renderer> and projections thereof without requiring a custom implementation of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$F$</math-renderer>. When <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$F$</math-renderer> is <em>not</em> a finite composition of the operations supported by LowRankArithmetic.jl and no custom implementation of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="216b3a9e9f43ac2032da4501234797d7">$F$</math-renderer> and projections thereof is provided by the user, the DLRA routines in this package are not expected to speed up the integration, however, substantial memory savings may still be achieved.</p>
<h3 dir="auto">
<a id="user-content-integration-routines" class="anchor" aria-hidden="true" href="#integration-routines"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Integration routines</h3>
<p dir="auto">While the concept of DLRA is quite intuitive, it is no easy task to realize it algorithmically and only a handful of integration algorithms have been proposed. LowRankIntegrators.jl currently implement the Lie-Trotter and Strang projector splitting algorithms proposed in [1] as well as the "unconventional integrator" proposed in [2] and its rank-adaptive counterpart [3]. This selection of algorithms was made to support those that are robust to the presence of small singular values in the approximation [4].</p>
<p dir="auto">Within LowRankIntegrators.jl the different integrators are specified by simple objects, allowing the specification of integrator specific options:</p>
<ul dir="auto">
<li>
<p dir="auto">Projector Splitting - <code>ProjectorSplitting(order)</code> where the optional argument <code>order</code> refers to the concrete type of the projector splitting algorithm. It can take values <code>PrimalLieTrotter()</code>, <code>DualLieTrotter()</code>, and <code>String()</code>. If no argument is specified, <code>order</code> defaults to <code>PrimalLieTrotter()</code></p>
</li>
<li>
<p dir="auto">Unconventional Algorithm - <code>UnconventionalAlgorithm()</code></p>
</li>
<li>
<p dir="auto">Rank adaptive unconventional Algorithm - <code>RankAdaptiveUnconventionalAlgorithm()</code></p>
</li>
</ul>
<h3 dir="auto">
<a id="user-content-solve" class="anchor" aria-hidden="true" href="#solve"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>solve</h3>
<p dir="auto">In order to finally solve a <code>MatrixDEProblem</code> or a <code>MatrixDataProblem</code>, the solve statement <code>solve(problem, alg, dt)</code> shall be called. Here</p>
<ul dir="auto">
<li>
<code>problem</code> refers to a properly defined <code>MatrixDEProblem</code> or <code>MatrixDataProblem</code>.</li>
<li>
<code>alg</code> refers to one of the supported DLRA integrators.</li>
<li>
<code>dt</code> refers to the integration step sizes. If <code>problem</code> is a <code>MatrixDataProblem</code> where the data is specified as discrete snapshots <code>dt</code> defaults to 1 so that the integrator steps through all provided snapshots in order.</li>
</ul>
<h2 dir="auto">
<a id="user-content-future-work" class="anchor" aria-hidden="true" href="#future-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Future Work</h2>
<p dir="auto">Future work will include integration routines for the dynamically orthogonal field equations.</p>
<h2 dir="auto">
<a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgements</h2>
<p dir="auto">This work is supported by NSF Award PHY-2028125 "SWQU: Composable Next Generation Software Framework for Space Weather Data Assimilation and Uncertainty Quantification".</p>
<h2 dir="auto">
<a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">[1] Lubich, Christian, and Ivan V. Oseledets. "A projector-splitting integrator for dynamical low-rank approximation." BIT Numerical Mathematics 54.1 (2014): 171-188.</p>
<p dir="auto">[2] Ceruti, Gianluca, and Christian Lubich. "An unconventional robust integrator for dynamical low-rank approximation." BIT Numerical Mathematics (2021): 1-22.</p>
<p dir="auto">[3] Ceruti, Gianluca, Jonas Kusch, and Christian Lubich. "A rank-adaptive robust integrator for dynamical low-rank approximation." arXiv preprint arXiv:2104.05247 (2021).</p>
<p dir="auto">[4] Kieri, Emil, Christian Lubich, and Hanna Walach. "Discretized dynamical low-rank approximation in the presence of small singular values." SIAM Journal on Numerical Analysis 54.2 (2016): 1020-1038.</p>
</article></div>