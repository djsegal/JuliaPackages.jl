<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p><a href="https://travis-ci.org/andrewcooke/ParserCombinator.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/0fcde28db80399b74a3a9610bd3f916575c13ae9/68747470733a2f2f7472617669732d63692e6f72672f616e64726577636f6f6b652f506172736572436f6d62696e61746f722e6a6c2e706e67" alt="Build Status" data-canonical-src="https://travis-ci.org/andrewcooke/ParserCombinator.jl.png" style="max-width:100%;"></a>
<a href="https://coveralls.io/r/andrewcooke/ParserCombinator.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c5731ac53b2905cda984d14a4df794877b7c3a6d/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f616e64726577636f6f6b652f506172736572436f6d62696e61746f722e6a6c2f62616467652e737667" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/andrewcooke/ParserCombinator.jl/badge.svg" style="max-width:100%;"></a></p>
<p><a href="http://pkg.julialang.org/?pkg=ParserCombinator&amp;ver=0.3" rel="nofollow"><img src="https://camo.githubusercontent.com/5e0f0313f596b2810e65ba02dc25240fac6ffc0a/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f506172736572436f6d62696e61746f725f302e332e737667" alt="ParserCombinator" data-canonical-src="http://pkg.julialang.org/badges/ParserCombinator_0.3.svg" style="max-width:100%;"></a>
<a href="http://pkg.julialang.org/?pkg=ParserCombinator&amp;ver=0.4" rel="nofollow"><img src="https://camo.githubusercontent.com/58820e8a7c5d58e6609dc6b00062af63e155646c/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f506172736572436f6d62696e61746f725f302e342e737667" alt="ParserCombinator" data-canonical-src="http://pkg.julialang.org/badges/ParserCombinator_0.4.svg" style="max-width:100%;"></a>
<a href="http://pkg.julialang.org/?pkg=ParserCombinator&amp;ver=0.5" rel="nofollow"><img src="https://camo.githubusercontent.com/8fbeb5ae803a8c86fb2608d6205ac58c65654966/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f506172736572436f6d62696e61746f725f302e352e737667" alt="ParserCombinator" data-canonical-src="http://pkg.julialang.org/badges/ParserCombinator_0.5.svg" style="max-width:100%;"></a></p>
<h1><a id="user-content-parsercombinator" class="anchor" aria-hidden="true" href="#parsercombinator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ParserCombinator</h1>
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#manual">Manual</a></li>
<li><a href="#parsers">Parsers</a></li>
<li><a href="#design">Design</a></li>
<li><a href="#releases">Releases</a></li>
</ul>
<p>A parser combinator library for Julia, similar to those in other languages,
like Haskell's Parsec or Python's pyparsing.  It can parse any iterable type
(not just strings) (except for regexp matchers, of course).</p>
<p>ParserCombinator's main advantage is its flexible <a href="#design">design</a>,
which separates the matchers from the evaluation strategy.  This makes
it <a href="#evaluation">easy</a> to "plug in" memoization, or debug traces, or
to restrict backtracking in a similar way to Parsec - all while using
the same grammar.</p>
<p>It also contains pre-built parsers for
<a href="#graph-modelling-language">Graph Modelling Language</a> and <a href="#dot">DOT</a>.</p>
<h2><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example</h2>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ParserCombinator


<span class="pl-c"><span class="pl-c">#</span> the AST nodes we will construct, with evaluation via calc()</span>

abstract Node
<span class="pl-k">==</span>(n1<span class="pl-k">::</span><span class="pl-c1">Node</span>, n2<span class="pl-k">::</span><span class="pl-c1">Node</span>) <span class="pl-k">=</span> n1<span class="pl-k">.</span>val <span class="pl-k">==</span> n2<span class="pl-k">.</span>val
<span class="pl-en">calc</span>(n<span class="pl-k">::</span><span class="pl-c1">Float64</span>) <span class="pl-k">=</span> n
type Inv<span class="pl-k">&lt;:</span><span class="pl-c1">Node</span> val <span class="pl-k">end</span>
<span class="pl-en">calc</span>(i<span class="pl-k">::</span><span class="pl-c1">Inv</span>) <span class="pl-k">=</span> <span class="pl-c1">1.0</span><span class="pl-k">/</span><span class="pl-c1">calc</span>(i<span class="pl-k">.</span>val)
type Prd<span class="pl-k">&lt;:</span><span class="pl-c1">Node</span> val <span class="pl-k">end</span>
<span class="pl-en">calc</span>(p<span class="pl-k">::</span><span class="pl-c1">Prd</span>) <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">prod</span>(<span class="pl-c1">map</span>(calc, p<span class="pl-k">.</span>val))
type Neg<span class="pl-k">&lt;:</span><span class="pl-c1">Node</span> val <span class="pl-k">end</span>
<span class="pl-en">calc</span>(n<span class="pl-k">::</span><span class="pl-c1">Neg</span>) <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">calc</span>(n<span class="pl-k">.</span>val)
type Sum<span class="pl-k">&lt;:</span><span class="pl-c1">Node</span> val <span class="pl-k">end</span>
<span class="pl-en">calc</span>(s<span class="pl-k">::</span><span class="pl-c1">Sum</span>) <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">sum</span>(<span class="pl-c1">map</span>(calc, s<span class="pl-k">.</span>val))


<span class="pl-c"><span class="pl-c">#</span> the grammar (the combinators!)</span>

sum <span class="pl-k">=</span> <span class="pl-c1">Delayed</span>()
val <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>(<span class="pl-pds">"</span></span> <span class="pl-k">+</span> sum <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>)<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-c1">PFloat64</span>()

neg <span class="pl-k">=</span> <span class="pl-c1">Delayed</span>()       <span class="pl-c"><span class="pl-c">#</span> allow multiple (or no) negations (eg ---3)</span>
neg<span class="pl-k">.</span>matcher <span class="pl-k">=</span> val <span class="pl-k">|</span> (<span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>-<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg <span class="pl-k">&gt;</span> Neg)

mul <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>*<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg
div <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>/<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg <span class="pl-k">&gt;</span> Inv
prd <span class="pl-k">=</span> neg <span class="pl-k">+</span> (mul <span class="pl-k">|</span> div)[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">|&gt;</span> Prd

add <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>+<span class="pl-pds">"</span></span> <span class="pl-k">+</span> prd
sub <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>-<span class="pl-pds">"</span></span> <span class="pl-k">+</span> prd <span class="pl-k">&gt;</span> Neg
sum<span class="pl-k">.</span>matcher <span class="pl-k">=</span> prd <span class="pl-k">+</span> (add <span class="pl-k">|</span> sub)[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">|&gt;</span> Sum

all <span class="pl-k">=</span> sum <span class="pl-k">+</span> <span class="pl-c1">Eos</span>()


<span class="pl-c"><span class="pl-c">#</span> and test </span>

<span class="pl-c"><span class="pl-c">#</span> this prints 2.5</span>
<span class="pl-c1">calc</span>(<span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>1+2*3/4<span class="pl-pds">"</span></span>, all)[<span class="pl-c1">1</span>])

<span class="pl-c"><span class="pl-c">#</span> this prints [Sum([Prd([1.0]),Prd([2.0])])]</span>
<span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>1+2<span class="pl-pds">"</span></span>, all)</pre></div>
<p>Some explanation of the above:</p>
<ul>
<li>
<p>I used rather a lot of "syntactic sugar".  You can use a more verbose,
"parser combinator" style if you prefer.  For example, <code>Seq(...)</code> instead of
<code>+</code>, or <code>App(...)</code> instead of <code>&gt;</code>.</p>
</li>
<li>
<p>The matcher <code>E"xyz"</code> matches and then discards the string <code>"xyz"</code>.</p>
</li>
<li>
<p>Every matcher returns a list of matched values.  This can be an empty list
if the match succeeded but matched nothing.</p>
</li>
<li>
<p>The operator <code>+</code> matches the expressions to either side and appends the
resulting lists.  Similarly, <code>|</code> matches one of two alternatives.</p>
</li>
<li>
<p>The operator <code>|&gt;</code> calls the function to the right, passing in the results
from the matchers on the left.</p>
</li>
<li>
<p><code>&gt;</code> is similar to <code>|&gt;</code> but interpolates the arguments (ie uses <code>...</code>).  So
instead of passing a list of values, it calls the function with multiple
arguments.</p>
</li>
<li>
<p><code>Delayed()</code> lets you define a loop in the grammar.</p>
</li>
<li>
<p>The syntax <code>[0:end]</code> is a greedy repeat of the matcher to the left.  An
alternative would be <code>Star(...)</code>, while <code>[3:4]</code> would match only 3 or 4
values.</p>
</li>
</ul>
<p>And it supports packrat parsing too (more exactly, it can memoize results to
avoid repeating matches).</p>
<p>Still, for large parsing tasks (eg parsing source code for a compiler) it
would probably be better to use a wrapper around an external parser generator,
like Anltr.</p>
<p><strong>Note:</strong> There's an <a href="https://github.com/JuliaLang/Compat.jl/issues/94">issue</a>
with the Compat library which means the code above (the assignment to
<code>Delayed.matcher</code>) doesn't work with 0.3.  See <a href="test/calc.jl">calc.jl</a> for
the uglier, hopefully temporary, 0.3 version.</p>
<h2><a id="user-content-install" class="anchor" aria-hidden="true" href="#install"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Install</h2>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>ParserCombinator<span class="pl-pds">"</span></span>)</pre></div>
<h2><a id="user-content-manual" class="anchor" aria-hidden="true" href="#manual"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Manual</h2>
<ul>
<li><a href="#evaluation">Evaluation</a></li>
<li><a href="#basic-matchers">Basic Matchers</a>
<ul>
<li><a href="#equality">Equality</a></li>
<li><a href="#sequences">Sequences</a></li>
<li><a href="#empty-values">Empty Values</a></li>
<li><a href="#alternates">Alternates</a></li>
<li><a href="#regular-expressions">Regular Expressions</a></li>
<li><a href="#repetition">Repetition</a></li>
<li><a href="#full-match">Full Match</a></li>
<li><a href="#transforms">Transforms</a></li>
<li><a href="#lookahead-and-negation">Lookahead And Negation</a></li>
</ul>
</li>
<li><a href="#other">Other</a>
<ul>
<li><a href="#backtracking">Backtracking</a></li>
<li><a href="#controlling-memory-use">Controlling Memory Use</a></li>
<li><a href="#spaces---pre-and-post-fixes">Spaces - Pre And Post-Fixes</a></li>
<li><a href="#locating-errors">Locating Errors</a></li>
<li><a href="#coding-style">Coding Style</a></li>
<li><a href="#adding-matchers">Adding Matchers</a></li>
<li><a href="#debugging">Debugging</a></li>
<li><a href="#more-information">More Information</a></li>
</ul>
</li>
</ul>
<h3><a id="user-content-evaluation" class="anchor" aria-hidden="true" href="#evaluation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Evaluation</h3>
<p>Once you have a grammar (see <a href="#basic-matchers">below</a>) you can
evaluate it against some input in various ways:</p>
<ul>
<li>
<p><code>parse_one()</code> - a simple, recursive decent parser with backtracking,
but no memoization.  Returns a single result or throws a
<code>ParserException</code>.</p>
</li>
<li>
<p><code>parse_all()</code> - a packrat parser, with memoization, that returns an
iterator (evaluated lazily) over all possible parses of the input.</p>
</li>
<li>
<p><code>parse_lines()</code> - a parser in which the source is parsed line by
line.  Pre-4.0.0 Julia copies strings that are passed to regex, so
this reduces memory use when using regular expressions.</p>
</li>
<li>
<p><code>parse_try()</code> - similar to Haskell's Parsec, with backtracking only
inside the <code>Try()</code> matcher.  More info
<a href="#controlling-memory-use">here</a>.</p>
</li>
<li>
<p><code>parse_dbg()</code> - as <code>parse_one()</code>, but also prints a trace of
evaluation for all of the matchers that are children of a <code>Trace()</code>
matchers.  Can also be used with other matchers via the keword
<code>delegate</code>; for example <code>parse_dbg(...; delegate=Cache)</code> will
provide tracing of the packrat parser (<code>parse_all()</code> above).  More
info <a href="#debugging">here</a>.</p>
</li>
</ul>
<p>These are all implemented by providing different <code>Config</code> subtypes.
For more information see <a href="#design">Design</a>, <a href="src/core/types.jl">types.jl</a>
and <a href="src/core/parsers.jl">parsers.jl</a>.</p>
<h3><a id="user-content-basic-matchers" class="anchor" aria-hidden="true" href="#basic-matchers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basic Matchers</h3>
<p>In what follows, remember that the power of parser combinators comes from how
you combine these.  They can all be nested, refer to each other, etc etc.</p>
<h4><a id="user-content-equality" class="anchor" aria-hidden="true" href="#equality"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Equality</h4>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-pds">"</span></span>))
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>abx<span class="pl-pds">"</span></span>))
ERROR<span class="pl-k">:</span> ParserCombinator<span class="pl-k">.</span><span class="pl-c1">ParserException</span>(<span class="pl-s"><span class="pl-pds">"</span>cannot parse<span class="pl-pds">"</span></span>)</pre></div>
<p>This is so common that there's a corresponding
<a href="http://julia.readthedocs.org/en/latest/manual/strings/#non-standard-string-literals" rel="nofollow">string literal</a>
(it's "e" for `Equal(), the corresponding matcher).</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>ab<span class="pl-pds">"</span></span>)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-pds">"</span></span></pre></div>
<h4><a id="user-content-sequences" class="anchor" aria-hidden="true" href="#sequences"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Sequences</h4>
<p>Matchers return lists of values.  Multiple matchers can return lists of lists,
or the results can be "flattened" a level (usually more useful):</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Series</span>(<span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>), <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Series</span>(<span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>), <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>); flatten<span class="pl-k">=</span><span class="pl-c1">false</span>))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Seq</span>(<span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>), <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">And</span>(<span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>), <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>b<span class="pl-pds">"</span></span>)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">&amp;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>b<span class="pl-pds">"</span></span>)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]</pre></div>
<p>Where <code>Series()</code> is implemented as <code>Seq()</code> or <code>And()</code>, depending on the value
of <code>flatten</code> (default <code>true</code>).</p>
<p><strong>Warning</strong> - The sugared syntax has to follow standard operator precedence,
where <code>|</code> binds <em>more tightly</em> that <code>+</code>.  This means that</p>
<div class="highlight highlight-source-julia"><pre>   matcher1 <span class="pl-k">+</span> matcher2 <span class="pl-k">|</span> matcher3</pre></div>
<p>is <em>almost always an error</em> because it means:</p>
<div class="highlight highlight-source-julia"><pre>   matcher1 <span class="pl-k">+</span> (matcher2 <span class="pl-k">|</span> matcher3)</pre></div>
<p>while what was intended was:</p>
<div class="highlight highlight-source-julia"><pre>   (matcher1 <span class="pl-k">+</span> matcher2) <span class="pl-k">|</span> matcher3</pre></div>
<h4><a id="user-content-empty-values" class="anchor" aria-hidden="true" href="#empty-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Empty Values</h4>
<p>Often, you want to match something but then discard it.  An empty (or
discarded) value is an empty list.  This may help explain why I said
flattening lists was useful above.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">And</span>(<span class="pl-c1">Drop</span>(<span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)), <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[]   
 Any[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Seq</span>(<span class="pl-c1">Drop</span>(<span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)), <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)))
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-k">~</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>b<span class="pl-pds">"</span></span>)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>b<span class="pl-pds">"</span></span>)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span></pre></div>
<p>Note the <code>~</code> (tilde / home directory) and capital <code>E</code> in the last two
examples, respectively.</p>
<h4><a id="user-content-alternates" class="anchor" aria-hidden="true" href="#alternates"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternates</h4>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Alt</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>x<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>a<span class="pl-pds">"</span></span>))
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>a<span class="pl-pds">"</span></span>)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span></pre></div>
<p><strong>Warning</strong> - The sugared syntax has to follow standard operator precedence,
where <code>|</code> binds <em>more tightly</em> that <code>+</code>.  This means that</p>
<div class="highlight highlight-source-julia"><pre>   matcher1 <span class="pl-k">+</span> matcher2 <span class="pl-k">|</span> matcher3</pre></div>
<p>is <em>almost always an error</em> because it means:</p>
<div class="highlight highlight-source-julia"><pre>   matcher1 <span class="pl-k">+</span> (matcher2 <span class="pl-k">|</span> matcher3)</pre></div>
<p>while what was intended was:</p>
<div class="highlight highlight-source-julia"><pre>   (matcher1 <span class="pl-k">+</span> matcher2) <span class="pl-k">|</span> matcher3</pre></div>
<h4><a id="user-content-regular-expressions" class="anchor" aria-hidden="true" href="#regular-expressions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Regular Expressions</h4>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Pattern</span>(<span class="pl-sr"><span class="pl-pds">r"</span>.b.<span class="pl-pds">"</span></span>))
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.b.<span class="pl-pds">"</span></span>)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">P</span>"</span>.<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>b.<span class="pl-pds">"</span></span>)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>bc<span class="pl-pds">"</span></span></pre></div>
<p>As with equality, a capital prefix to the string literal ("p" for "pattern" by
the way) implies that the value is dropped.</p>
<p>Note that regular expresions do not backtrack.  A typical, greedy,
regular expression will match as much of the input as possible, every
time that it is used.  Backtracking only exists within the library
matchers (which can duplicate regular expression functionality, when
needed).</p>
<h4><a id="user-content-repetition" class="anchor" aria-hidden="true" href="#repetition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Repetition</h4>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>))
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(<span class="pl-c1">parse_all</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]    

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>; flatten<span class="pl-k">=</span><span class="pl-c1">false</span>))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(<span class="pl-c1">parse_all</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>)))
<span class="pl-c1">4</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]    
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]        
 Any[]           

julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(<span class="pl-c1">parse_all</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>; greedy<span class="pl-k">=</span><span class="pl-c1">false</span>)))
<span class="pl-c1">4</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[]           
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]        
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]    
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>]</pre></div>
<p>You can also use <code>Depth()</code> and <code>Breadth()</code> for greedy and non-greedy repeats
directly (but <code>Repeat()</code> is more readable, I think).</p>
<p>The sugared version looks like this:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,:?])
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,:<span class="pl-k">&amp;</span>])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>,:<span class="pl-k">&amp;</span>,:?])
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]</pre></div>
<p>Where the <code>:?</code> symbol is equivalent to <code>greedy=false</code> and <code>:&amp;</code> to
<code>flatten=false</code> (compare with <code>+</code> and <code>&amp;</code> above).</p>
<p>There are also some well-known special cases:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(<span class="pl-c1">parse_all</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Plus</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>)))
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]    
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]        

julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(<span class="pl-c1">parse_all</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Star</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>)))
<span class="pl-c1">4</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>]
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>]    
 Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]        
 Any[]           </pre></div>
<h4><a id="user-content-full-match" class="anchor" aria-hidden="true" href="#full-match"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Full Match</h4>
<p>To ensure that all the input is matched, add <code>Eos()</code> to the end of the
grammar.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>) <span class="pl-k">+</span> <span class="pl-c1">Eos</span>())
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Equal</span>(<span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-pds">"</span></span>) <span class="pl-k">+</span> <span class="pl-c1">Eos</span>())
ERROR<span class="pl-k">:</span> ParserCombinator<span class="pl-k">.</span><span class="pl-c1">ParserException</span>(<span class="pl-s"><span class="pl-pds">"</span>cannot parse<span class="pl-pds">"</span></span>)</pre></div>
<h4><a id="user-content-transforms" class="anchor" aria-hidden="true" href="#transforms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Transforms</h4>
<p>Use <code>App()</code> or <code>&gt;</code> to pass the current results to a function (or datatype
constructor) as individual values.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">App</span>(<span class="pl-c1">Star</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>), tuple))
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 (<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Star</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>) <span class="pl-k">&gt;</span> string)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span></pre></div>
<p>The action of <code>Appl()</code> and <code>|&gt;</code> is similar, but everything is passed as a
single argument (a list).</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> type Node children <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Appl</span>(<span class="pl-c1">Star</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>), Node))
<span class="pl-c1">1</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">Node</span>(Any[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>])

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Star</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>.<span class="pl-pds">"</span></span>) <span class="pl-k">|&gt;</span> x <span class="pl-k">-&gt;</span> <span class="pl-c1">map</span>(uppercase, x))
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span></pre></div>
<h4><a id="user-content-lookahead-and-negation" class="anchor" aria-hidden="true" href="#lookahead-and-negation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lookahead And Negation</h4>
<p>Sometimes you can't write a clean grammar that just consumes data: you need to
check ahead to avoid something.  Or you need to check ahead to make sure
something works a certain way.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>12c<span class="pl-pds">"</span></span>, <span class="pl-c1">Lookahead</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span><span class="pl-cce">\d</span><span class="pl-pds">"</span></span>) <span class="pl-k">+</span> <span class="pl-c1">PInt</span>() <span class="pl-k">+</span> <span class="pl-c1">Dot</span>())
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">12</span>   
   <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">parse_one</span>(<span class="pl-s"><span class="pl-pds">"</span>12c<span class="pl-pds">"</span></span>, <span class="pl-c1">Not</span>(<span class="pl-c1">Lookahead</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>[a-z]<span class="pl-pds">"</span></span>)) <span class="pl-k">+</span> <span class="pl-c1">PInt</span>() <span class="pl-k">+</span> <span class="pl-c1">Dot</span>())
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">12</span>   
   <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span></pre></div>
<p>More generally, <code>Not()</code> replaces any match with failure, and failure with an
empty match (ie the empty list).</p>
<h3><a id="user-content-other" class="anchor" aria-hidden="true" href="#other"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Other</h3>
<h4><a id="user-content-backtracking" class="anchor" aria-hidden="true" href="#backtracking"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Backtracking</h4>
<p>By default, matchers will backtrack as necessary.</p>
<p>In some (unusual) cases, it is useful to disable backtracking.  For
example, see PCRE's "possessive" matching.  This can be done here on a
case-by-case basis by adding <code>backtrack=false</code> to <code>Repeat()</code>,
<code>Alternatives()</code> and <code>Series()</code>, or by appending <code>!</code> to the matchers
that those functions generate: <code>Depth!</code>, <code>Breadth!</code>, <code>Alt!</code>, <code>Seq!</code>
and <code>And!</code>.</p>
<p>For example,</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">collect</span>(<span class="pl-c1">parse_all</span>(<span class="pl-s"><span class="pl-pds">"</span>123abc<span class="pl-pds">"</span></span>, <span class="pl-c1">Seq!</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span><span class="pl-cce">\d</span><span class="pl-pds">"</span></span>[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>], <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>[a-z]<span class="pl-pds">"</span></span>[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>])))</pre></div>
<p>will give just a single match, because <code>Seq!</code> (with trailing <code>!</code>) does
not backtrack the <code>Repeat()</code> child matchers.</p>
<p>However, since regular expressions do not backtrack, it would have been
simpler, and faster, to write the above as</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">collect</span>(<span class="pl-c1">parse_all</span>(<span class="pl-s"><span class="pl-pds">"</span>123abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span><span class="pl-cce">\d</span>+[a-z]+<span class="pl-pds">"</span></span>))</pre></div>
<p>Using <code>backtrack=false</code> only disables backtracking of the direct
children of those matchers.  To disable <em>all</em> backtracking, then the
change must be made to <em>all</em> matchers in the grammar.  For example, in
theory, the following two grammars have different backtracking
behaviour:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">Series</span>(<span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>), <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>b<span class="pl-pds">"</span></span>; backtrack<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c1">Series</span>(<span class="pl-c1">Repeat</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>; backtrack<span class="pl-k">=</span><span class="pl-c1">false</span>), <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>b<span class="pl-pds">"</span></span>; backtrack<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p>(although, in practice, they are identical, in this contrived example,
because <code>e"a"</code> doesn't backtrack anyway).</p>
<p>This makes a grammar more efficient, but also more specific.  It can
reduce the memory consumed by the parser, but does not guarantee that
resources will be released - see the next section for a better
approach to reducing memory use.</p>
<h4><a id="user-content-controlling-memory-use" class="anchor" aria-hidden="true" href="#controlling-memory-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Controlling Memory Use</h4>
<p>Haskell's Parsec, if I understand correctly, does not backtrack by
default.  More exactly, it does not allow input that has been consumed
(matched) to be read again.  This reduces memory consumption (at least
when parsing files, since read data can be discarded), but only
accepts LL(1) grammars.</p>
<p>To allow parsing of a wider range of grammars, Parsec then introduces
the <code>Try</code> combinator, which enables backtracking in some (generally
small) portion of the grammar.</p>
<p>The same approach can be used with this library, using <code>parse_try</code>.</p>
<pre><code>file1.txt:
abcdefghijklmnopqrstuvwxyz
0123456789
</code></pre>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">open</span>(<span class="pl-s"><span class="pl-pds">"</span>test1.txt<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>) <span class="pl-k">do</span> io
    <span class="pl-c"><span class="pl-c">#</span> this throws an execption because it requires backtracking</span>
    <span class="pl-c1">parse_try</span>(io, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>[a-z]<span class="pl-pds">"</span></span>[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>m<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> string)
<span class="pl-k">end</span>

<span class="pl-c1">open</span>(<span class="pl-s"><span class="pl-pds">"</span>test1.txt<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>) <span class="pl-k">do</span> io
    <span class="pl-c"><span class="pl-c">#</span> this (with Try(...)) works fine</span>
    <span class="pl-c1">parse_try</span>(io, <span class="pl-c1">Try</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>[a-z]<span class="pl-pds">"</span></span>[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">e</span>"</span>m<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> string))
<span class="pl-k">end</span></pre></div>
<p>Without backtracking, error messages using the <code>Error()</code> matcher are
much more useful (this is why Parsec can provide good error messages):</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">try</span>
         <span class="pl-c1">parse_try</span>(<span class="pl-s"><span class="pl-pds">"</span>?<span class="pl-pds">"</span></span>, <span class="pl-c1">Alt!</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span>[a-z]<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span><span class="pl-cce">\d</span><span class="pl-pds">"</span></span>, <span class="pl-c1">Error</span>(<span class="pl-s"><span class="pl-pds">"</span>not letter or number<span class="pl-pds">"</span></span>)))
       <span class="pl-k">catch</span> x
         <span class="pl-c1">println</span>(x<span class="pl-k">.</span>msg)
       <span class="pl-k">end</span>
not letter or number at (<span class="pl-c1">1</span>,<span class="pl-c1">1</span>)
?
<span class="pl-k">^</span></pre></div>
<p>where the <code>(1,1)</code> is line number and column - so this failed on the first
character of the first line.</p>
<p>Finally, note that this is implemented at the source level, by restricting
what text is visible to the matchers.  Matchers that <em>could</em> backtrack will
still make the attempt.  So you should also <a href="#backtracking">disable backtracking in the
matchers</a>, where you do not need it, for an efficient grammar.</p>
<h4><a id="user-content-spaces---pre-and-post-fixes" class="anchor" aria-hidden="true" href="#spaces---pre-and-post-fixes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Spaces - Pre And Post-Fixes</h4>
<p>The lack of a lexer can complicate the handling of whitespace when
using parser combinators.  This library includes the ability to add
arbitrary matchers before or after named matchers in the grammar -
something that can be useful for matching and discarding whitespace.</p>
<p>For example,</p>
<div class="highlight highlight-source-julia"><pre>spc <span class="pl-k">=</span> <span class="pl-c1">Drop</span>(<span class="pl-c1">Star</span>(<span class="pl-c1">Space</span>()))

<span class="pl-c1">@with_pre</span> spc <span class="pl-k">begin</span>

    sum <span class="pl-k">=</span> <span class="pl-c1">Delayed</span>()
    val <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>(<span class="pl-pds">"</span></span> <span class="pl-k">+</span> spc <span class="pl-k">+</span> sum <span class="pl-k">+</span> spc <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>)<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-c1">PFloat64</span>()

    neg <span class="pl-k">=</span> <span class="pl-c1">Delayed</span>()             <span class="pl-c"><span class="pl-c">#</span> allow multiple negations (eg ---3)</span>
    neg<span class="pl-k">.</span>matcher <span class="pl-k">=</span> <span class="pl-c1">Nullable</span><span class="pl-c1">{Matcher}</span>(val <span class="pl-k">|</span> (<span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>-<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg <span class="pl-k">&gt;</span> Neg))

    mul <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>*<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg
    div <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>/<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg <span class="pl-k">&gt;</span> Inv
    prd <span class="pl-k">=</span> neg <span class="pl-k">+</span> (mul <span class="pl-k">|</span> div)[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">|&gt;</span> Prd

    add <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>+<span class="pl-pds">"</span></span> <span class="pl-k">+</span> prd
    sub <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>-<span class="pl-pds">"</span></span> <span class="pl-k">+</span> prd <span class="pl-k">&gt;</span> Neg
    sum<span class="pl-k">.</span>matcher <span class="pl-k">=</span> <span class="pl-c1">Nullable</span><span class="pl-c1">{Matcher}</span>(prd <span class="pl-k">+</span> (add <span class="pl-k">|</span> sub)[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">|&gt;</span> Sum)

    all <span class="pl-k">=</span> sum <span class="pl-k">+</span> spc <span class="pl-k">+</span> <span class="pl-c1">Eos</span>()

<span class="pl-k">end</span></pre></div>
<p>extends the parser given earlier to discard whitespace between numbers
and symbols.  The automatc addition of <code>spc</code> as a prefix to named
matchers (those assigned to a variable: <code>sum</code>, <code>val</code>, <code>neg</code>, etc)
means that it only needs to be added explicitly in a few places.</p>
<h4><a id="user-content-locating-errors" class="anchor" aria-hidden="true" href="#locating-errors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Locating Errors</h4>
<p>Sometimes it is useful to report to the user where the input text is
"wrong".  For a recursive descent parser one useful indicator is the
maximum depth reached in the source.</p>
<p>This can be retrieved using the <code>Debug</code> config.  Here is a simple
example that delegates to <code>NoCache</code> (the default confg for
<code>parse_one()</code>):</p>
<div class="highlight highlight-source-julia"><pre>grammar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">p</span>"</span><span class="pl-cce">\d</span>+<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-c1">Eos</span>()
source <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>123abc<span class="pl-pds">"</span></span>
             <span class="pl-c"><span class="pl-c">#</span> make the parser task</span>
debug, task <span class="pl-k">=</span> <span class="pl-c1">make</span>(Debug, source, grammar; delegate<span class="pl-k">=</span>NoCache)
<span class="pl-c1">once</span>(task)   <span class="pl-c"><span class="pl-c">#</span> this does the parsing and throws an exception</span>
             <span class="pl-c"><span class="pl-c">#</span> the debug config now contains max_iter</span>
<span class="pl-c1">println</span>(source[debug<span class="pl-k">.</span>max_iter<span class="pl-k">:</span><span class="pl-c1">end</span>])   <span class="pl-c"><span class="pl-c">#</span> show the error location "abc"</span></pre></div>
<p>This is a little complex because I don't pre-define a function for
this case (cf <code>parse_one()</code>).  Please email me if you think I should
(currently it's unclear what features to support directly, and what to
leave for "advanced" users).</p>
<p>For more information see <a href="src/core/parsers.jl">parsers.jl</a> and
<a href="src/core/debug.jl">debug.jl</a>.</p>
<p>An alternative approach to error messages is to use <code>parse_try()</code> with
the <code>Error()</code> matcher - see <a href="#controlling-memory-use">here</a>.</p>
<h4><a id="user-content-coding-style" class="anchor" aria-hidden="true" href="#coding-style"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Coding Style</h4>
<p>Don't go reinventing regexps.  The built-in regexp engine is way, way more
efficient than this library could ever be.  So call out to regexps liberally.
The <code>p"..."</code> syntax makes it easy.</p>
<p>But don't use regular expressions if you need to backtrack what is
being matched.</p>
<p>Drop stuff you don't need.</p>
<p>Transform things into containers so that your result has nice types.  Look at
how the <a href="#example">example</a> works.</p>
<p>Understand the format you are parsing.  What motivated the person who
designed the format?  Compare the <a href="src/gml/GML.jl">GML</a> and
<a href="src/dot/DOT.jl">DOT</a> parsers - they return different results because
the format authors cared about different things.  GML is an elegant,
general data format, while DOT is a sequential description - a
program, almost - that encodes graph layouts.</p>
<h4><a id="user-content-adding-matchers" class="anchor" aria-hidden="true" href="#adding-matchers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Adding Matchers</h4>
<p>First, are you sure you need to add a matcher?  You can do a <em>lot</em> with
<a href="#transforms">transforms</a>.</p>
<p>If you do, here are some places to get started:</p>
<ul>
<li>
<p><code>Equal()</code> in <a href="src/core/matchers.jl">matchers.jl</a> is a great example for
something that does a simple, single thing, and returns success or failure.</p>
</li>
<li>
<p>Most matchers that call to a sub-matcher can be implemented as transforms.
But if you insist, there's an example in <a href="test/case.jl">case.jl</a>.</p>
</li>
<li>
<p>If you want to write complex, stateful matchers then I'm afraid you're going
to have to learn from the code for <code>Repeat()</code> and <code>Series()</code>.  Enjoy!</p>
</li>
</ul>
<h4><a id="user-content-debugging" class="anchor" aria-hidden="true" href="#debugging"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Debugging</h4>
<p>Debugging a grammar can be a frustrating experience - there are times when it
really helps to have a simple view "inside" what is happening.  This is
supported by <code>parse_dbg</code> which will print a record of all messages (execute
and response - see <a href="#design">design</a>) for matchers inside a <code>Trace()</code> matcher.</p>
<p>In addition, if the grammar is defined inside a <code>@with_names</code> macro, the
symbols used to identify various parts of the grammar (the variable names)
are displayed when appropriate.</p>
<p>Here's a full example (you can view less by applying <code>Trace()</code> to only the
matchers you care about):</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@with_names</span> <span class="pl-k">begin</span>

    sum <span class="pl-k">=</span> <span class="pl-c1">Delayed</span>()
    val <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>(<span class="pl-pds">"</span></span> <span class="pl-k">+</span> sum <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>)<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-c1">PFloat64</span>()

    neg <span class="pl-k">=</span> <span class="pl-c1">Delayed</span>()             <span class="pl-c"><span class="pl-c">#</span> allow multiple negations (eg ---3)</span>
    neg<span class="pl-k">.</span>matcher <span class="pl-k">=</span> val <span class="pl-k">|</span> (<span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>-<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg <span class="pl-k">&gt;</span> Neg)
    
    mul <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>*<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg
    div <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>/<span class="pl-pds">"</span></span> <span class="pl-k">+</span> neg <span class="pl-k">&gt;</span> Inv
    prd <span class="pl-k">=</span> neg <span class="pl-k">+</span> (mul <span class="pl-k">|</span> div)[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">|&gt;</span> Prd
    
    add <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>+<span class="pl-pds">"</span></span> <span class="pl-k">+</span> prd
    sub <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">E</span>"</span>-<span class="pl-pds">"</span></span> <span class="pl-k">+</span> prd <span class="pl-k">&gt;</span> Neg
    sum<span class="pl-k">.</span>matcher <span class="pl-k">=</span> prd <span class="pl-k">+</span> (add <span class="pl-k">|</span> sub)[<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">end</span>] <span class="pl-k">|&gt;</span> Sum
    
    all <span class="pl-k">=</span> sum <span class="pl-k">+</span> <span class="pl-c1">Eos</span>()
<span class="pl-k">end</span>

<span class="pl-c1">parse_dbg</span>(<span class="pl-s"><span class="pl-pds">"</span>1+2*3/4<span class="pl-pds">"</span></span>, <span class="pl-c1">Trace</span>(all))</pre></div>
<p>which gives:</p>
<pre><code>  1:1+2*3/4    00 Trace-&gt;all
  1:1+2*3/4    01  all-&gt;sum
  1:1+2*3/4    02   Transform-&gt;Seq
  1:1+2*3/4    03    Seq-&gt;prd
  1:1+2*3/4    04     prd-&gt;Seq
  1:1+2*3/4    05      Seq-&gt;neg
  1:1+2*3/4    06       Alt-&gt;Seq
  1:1+2*3/4    07        Seq-&gt;Drop
  1:1+2*3/4    08         Drop-&gt;Equal
   :           08         Drop&lt;-!!!
   :           07        Seq&lt;-!!!
   :           06       Alt&lt;-!!!
  1:1+2*3/4    06       Alt-&gt;Transform
  1:1+2*3/4    07        Transform-&gt;Pattern
  2:+2*3/4     07        Transform&lt;-{"1"}
  2:+2*3/4     06       Alt&lt;-{1.0}
  2:+2*3/4     05      Seq&lt;-{1.0}
  2:+2*3/4     05      Seq-&gt;Depth
  2:+2*3/4     06       Depth-&gt;Alt
  2:+2*3/4     07        Alt-&gt;mul
  2:+2*3/4     08         mul-&gt;Drop
  2:+2*3/4     09          Drop-&gt;Equal
   :           09          Drop&lt;-!!!
   :           08         mul&lt;-!!!
   :           07        Alt&lt;-!!!
  2:+2*3/4     07        Alt-&gt;div
  2:+2*3/4     08         div-&gt;Seq
  2:+2*3/4     09          Seq-&gt;Drop
  2:+2*3/4     10 Drop-&gt;Equal
   :           10 Drop&lt;-!!!
   :           09          Seq&lt;-!!!
   :           08         div&lt;-!!!
   :           07        Alt&lt;-!!!
   :           06       Depth&lt;-!!!
  2:+2*3/4     05      Seq&lt;-{}
  2:+2*3/4     04     prd&lt;-{1.0}
  2:+2*3/4     03    Seq&lt;-{Prd({1.0})}
  2:+2*3/4     03    Seq-&gt;Depth
  2:+2*3/4     04     Depth-&gt;Alt
  2:+2*3/4     05      Alt-&gt;add
  2:+2*3/4     06       add-&gt;Drop
  2:+2*3/4     07        Drop-&gt;Equal
  3:2*3/4      07        Drop&lt;-{"+"}
  3:2*3/4      06       add&lt;-{}
  3:2*3/4      06       add-&gt;prd
  3:2*3/4      07        prd-&gt;Seq
  3:2*3/4      08         Seq-&gt;neg
  3:2*3/4      09          Alt-&gt;Seq
  3:2*3/4      10 Seq-&gt;Drop
  3:2*3/4      11  Drop-&gt;Equal
   :           11  Drop&lt;-!!!
   :           10 Seq&lt;-!!!
   :           09          Alt&lt;-!!!
  3:2*3/4      09          Alt-&gt;Transform
  3:2*3/4      10 Transform-&gt;Pattern
  4:*3/4       10 Transform&lt;-{"2"}
  4:*3/4       09          Alt&lt;-{2.0}
  4:*3/4       08         Seq&lt;-{2.0}
  4:*3/4       08         Seq-&gt;Depth
  4:*3/4       09          Depth-&gt;Alt
  4:*3/4       10 Alt-&gt;mul
  4:*3/4       11  mul-&gt;Drop
  4:*3/4       12   Drop-&gt;Equal
  5:3/4        12   Drop&lt;-{"*"}
  5:3/4        11  mul&lt;-{}
  5:3/4        11  mul-&gt;neg
  5:3/4        12   Alt-&gt;Seq
  5:3/4        13    Seq-&gt;Drop
  5:3/4        14     Drop-&gt;Equal
   :           14     Drop&lt;-!!!
   :           13    Seq&lt;-!!!
   :           12   Alt&lt;-!!!
  5:3/4        12   Alt-&gt;Transform
  5:3/4        13    Transform-&gt;Pattern
  6:/4         13    Transform&lt;-{"3"}
  6:/4         12   Alt&lt;-{3.0}
  6:/4         11  mul&lt;-{3.0}
  6:/4         10 Alt&lt;-{3.0}
  6:/4         09          Depth&lt;-{3.0}
  6:/4         09          Depth-&gt;Alt
  6:/4         10 Alt-&gt;mul
  6:/4         11  mul-&gt;Drop
  6:/4         12   Drop-&gt;Equal
   :           12   Drop&lt;-!!!
   :           11  mul&lt;-!!!
   :           10 Alt&lt;-!!!
  6:/4         10 Alt-&gt;div
  6:/4         11  div-&gt;Seq
  6:/4         12   Seq-&gt;Drop
  6:/4         13    Drop-&gt;Equal
  7:4          13    Drop&lt;-{"/"}
  7:4          12   Seq&lt;-{}
  7:4          12   Seq-&gt;neg
  7:4          13    Alt-&gt;Seq
  7:4          14     Seq-&gt;Drop
  7:4          15      Drop-&gt;Equal
   :           15      Drop&lt;-!!!
   :           14     Seq&lt;-!!!
   :           13    Alt&lt;-!!!
  7:4          13    Alt-&gt;Transform
  7:4          14     Transform-&gt;Pattern
  8:           14     Transform&lt;-{"4"}
  8:           13    Alt&lt;-{4.0}
  8:           12   Seq&lt;-{4.0}
  8:           11  div&lt;-{4.0}
  8:           10 Alt&lt;-{Inv(4.0)}
  8:           09          Depth&lt;-{Inv(4.0)}
  8:           09          Depth-&gt;Alt
  8:           10 Alt-&gt;mul
  8:           11  mul-&gt;Drop
  8:           12   Drop-&gt;Equal
   :           12   Drop&lt;-!!!
   :           11  mul&lt;-!!!
   :           10 Alt&lt;-!!!
  8:           10 Alt-&gt;div
  8:           11  div-&gt;Seq
  8:           12   Seq-&gt;Drop
  8:           13    Drop-&gt;Equal
   :           13    Drop&lt;-!!!
   :           12   Seq&lt;-!!!
   :           11  div&lt;-!!!
   :           10 Alt&lt;-!!!
   :           09          Depth&lt;-!!!
  8:           08         Seq&lt;-{3.0,Inv(4.0)}
  8:           07        prd&lt;-{2.0,3.0,Inv(4.0)}
  8:           06       add&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           05      Alt&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           04     Depth&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           04     Depth-&gt;Alt
  8:           05      Alt-&gt;add
  8:           06       add-&gt;Drop
  8:           07        Drop-&gt;Equal
   :           07        Drop&lt;-!!!
   :           06       add&lt;-!!!
   :           05      Alt&lt;-!!!
  8:           05      Alt-&gt;sub
  8:           06       sub-&gt;Seq
  8:           07        Seq-&gt;Drop
  8:           08         Drop-&gt;Equal
   :           08         Drop&lt;-!!!
   :           07        Seq&lt;-!!!
   :           06       sub&lt;-!!!
   :           05      Alt&lt;-!!!
   :           04     Depth&lt;-!!!
  8:           03    Seq&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           02   Transform&lt;-{Prd({1.0}),Prd({2.0,3.0,Inv(4.0)})}
  8:           01  all&lt;-{Sum({Prd({1.0}),Prd({2.0,3.0,Inv(4.0)})})}
  8:           01  all-&gt;Eos
  8:           01  all&lt;-{}
  8:           00 Trace&lt;-{Sum({Prd({1.0}),Prd({2.0,3.0,Inv(4.0)})})}
</code></pre>
<p>Some things to note here:</p>
<ul>
<li>
<p>The number on the left is the current iterator, followed by the source
at the current offset.</p>
</li>
<li>
<p>The second column of numbers is the depth (relative to <code>Trace()</code>).  The
indentation of the messages to the right reflects this, but "wraps" every
10 levels.</p>
</li>
<li>
<p>The message flow shows execute as <code>-&gt;</code> and response as <code>&lt;-</code>.  Matcher names
are replaced by variable names (eg <code>sum</code>) where appropriate.</p>
</li>
<li>
<p>This functionality is implemented as a separate parser <code>Config</code> instance, so
has no performance penalty when not used.  See <a href="src/core/debug.jl">debug.jl</a> for
more details.</p>
</li>
</ul>
<p>Finally, printing a matcher gives a useful tree view of the grammar.
Loops are elided with <code>...</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">println</span>(all)</pre></div>
<p>gives</p>
<pre><code>all
+-[1]:sum
| `-TransSuccess
|   +-Seq
|   | +-[1]:prd
|   | | +-Seq
|   | | | +-[1]:neg
|   | | | | `-Alt
|   | | | |   +-[1]:Seq
|   | | | |   | +-[1]:Drop
|   | | | |   | | `-Equal
|   | | | |   | |   `-"("
|   | | | |   | +-[2]:sum...
|   | | | |   | `-[3]:Drop
|   | | | |   |   `-Equal
|   | | | |   |     `-")"
|   | | | |   +-[2]:TransSuccess
|   | | | |   | +-Pattern
|   | | | |   | | `-r"-?(\d*\.?\d+|\d+\.\d*)([eE]\d+)?"
|   | | | |   | `-f
|   | | | |   `-[3]:TransSuccess
|   | | | |     +-Seq
|   | | | |     | +-[1]:Drop
|   | | | |     | | `-Equal
|   | | | |     | |   `-"-"
|   | | | |     | `-[2]:neg...
|   | | | |     `-f
|   | | | `-[2]:Depth
|   | | |   +-Alt
|   | | |   | +-[1]:mul
|   | | |   | | +-[1]:Drop
|   | | |   | | | `-Equal
|   | | |   | | |   `-"*"
|   | | |   | | `-[2]:neg...
|   | | |   | `-[2]:div
|   | | |   |   +-Seq
|   | | |   |   | +-[1]:Drop
|   | | |   |   | | `-Equal
|   | | |   |   | |   `-"/"
|   | | |   |   | `-[2]:neg...
|   | | |   |   `-f
|   | | |   +-lo=0
|   | | |   +-hi=9223372036854775807
|   | | |   `-flatten=true
|   | | `-f
|   | `-[2]:Depth
|   |   +-Alt
|   |   | +-[1]:add
|   |   | | +-[1]:Drop
|   |   | | | `-Equal
|   |   | | |   `-"+"
|   |   | | `-[2]:prd...
|   |   | `-[2]:sub
|   |   |   +-Seq
|   |   |   | +-[1]:Drop
|   |   |   | | `-Equal
|   |   |   | |   `-"-"
|   |   |   | `-[2]:prd...
|   |   |   `-f
|   |   +-lo=0
|   |   +-hi=9223372036854775807
|   |   `-flatten=true
|   `-f
`-[2]:Eos
</code></pre>
<p>Also, <code>parse_XXX(...., debug=true)</code> will show a strack trace from within the
main parse loop (which gives more information on the source of any error).</p>
<h4><a id="user-content-more-information" class="anchor" aria-hidden="true" href="#more-information"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>More Information</h4>
<p>For more details, I'm afraid your best bet is the source code:</p>
<ul>
<li>
<p><a href="src/core/types/jl">types.jl</a> introduces the types use throughout the code</p>
</li>
<li>
<p><a href="src/core/matchers.jl">matchers.jl</a> defines things like <code>Seq</code> and <code>Repeat</code></p>
</li>
<li>
<p><a href="src/core/sugar.jl">sugar.jl</a> adds <code>+</code>, <code>[...]</code> etc</p>
</li>
<li>
<p><a href="src/core/extras.jl">extras.jl</a> has parsers for Int, Float, etc</p>
</li>
<li>
<p><a href="src/core/parsers.jl">parsers.jl</a> has more info on creating the <code>parse_one</code> and
<code>parse_all</code> functions</p>
</li>
<li>
<p><a href="src/core/transforms.jl">transforms.jl</a> defines how results can be manipulated</p>
</li>
<li>
<p><a href="test/tests.jl">tests.jl</a> has a pile of one-liner tests that might be useful</p>
</li>
<li>
<p><a href="test/debug.jl">debug.jl</a> shows how to enable debug mode</p>
</li>
<li>
<p><a href="test/case.jl">case.jl</a> has an example of a user-defined combinator</p>
</li>
</ul>
<h2><a id="user-content-parsers" class="anchor" aria-hidden="true" href="#parsers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parsers</h2>
<h3><a id="user-content-graph-modelling-language" class="anchor" aria-hidden="true" href="#graph-modelling-language"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Graph Modelling Language</h3>
<p>GML describes a graph using a general dict / list format (something like
JSON).</p>
<ul>
<li>
<p><code>parse_raw</code> returns lists and tuples that directly match the GML structure.</p>
</li>
<li>
<p><code>parse_dict</code> places the same data in nested dicts and vectors.  The keys are
symbols, so you access a file using the syntax <code>dict[:field]</code>.</p>
<p><code>parse_dict()</code> has two important keyword arguments: <code>lists</code>
is a list of keys that should be stored as lists (default is <code>:graph, :node, :edge</code>); <code>unsafe</code> should be set to <code>true</code> if mutiple values for
other keys should be discarded (default <code>false</code>).  The underlying
issue is that it is not clear from the file format which keys are
lists, so the user must specify them; by default an error is thrown if
this information is incomplete, but <code>unsafe</code> can be set if a user
doesn't care about those attributes.</p>
</li>
</ul>
<p>Note that the parser does not conform fully to the
<a href="https://en.wikipedia.org/wiki/Graph_Modelling_Language" rel="nofollow">specifications</a>:
ISO 8859-1 entities are not decoded (the parser should accept UTF 8);
integers and floats are 64bit; strings can be any length; no check is
made for required fields.</p>
<p>For example, to print node IDs and edge connections in a graph</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ParserCombinator<span class="pl-k">.</span>Parsers<span class="pl-k">.</span>GML

my_graph <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>graph [</span>
<span class="pl-s">  node [id 1]</span>
<span class="pl-s">  node [id 2]</span>
<span class="pl-s">  node [id 3]</span>
<span class="pl-s">  edge [source 1 target 2]</span>
<span class="pl-s">  edge [source 2 target 3]</span>
<span class="pl-s">  edge [source 3 target 1]</span>
<span class="pl-s">]<span class="pl-pds">"</span></span>

root <span class="pl-k">=</span> <span class="pl-c1">parse_dict</span>(my_graph)

<span class="pl-k">for</span> graph <span class="pl-k">in</span> root[<span class="pl-c1">:graph</span>]  <span class="pl-c"><span class="pl-c">#</span> there could be multiple graphs</span>
    <span class="pl-k">for</span> node <span class="pl-k">in</span> graph[<span class="pl-c1">:node</span>]
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>node <span class="pl-v">$(node[<span class="pl-c1">:id</span>])</span><span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
    <span class="pl-k">for</span> edge <span class="pl-k">in</span> graph[<span class="pl-c1">:edge</span>]
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>edge <span class="pl-v">$(edge[<span class="pl-c1">:source</span>])</span> - <span class="pl-v">$(edge[<span class="pl-c1">:target</span>])</span><span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p>giving</p>
<pre><code>node 1
node 2
node 3
edge 1 - 2
edge 2 - 3
edge 3 - 1
</code></pre>
<p>For further details, please read <a href="src/gml/GML.jl">GML.jl</a>.</p>
<h3><a id="user-content-dot" class="anchor" aria-hidden="true" href="#dot"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DOT</h3>
<p>DOT describes a graph using a complex format that resembles a program (with
mutable state) more than a specification (see comments in
<a href="src/dot/DOT.jl">source</a>).</p>
<ul>
<li>
<p><code>parse_dot</code> returns a list of structured AST (see the types in
<a href="src/dot/DOT.jl">DOT.jl</a>), one per graph in the file.  It has one keyword
argument, <code>debug</code>, which takes a <code>Bool</code> and enables the usual debugging
output.</p>
</li>
<li>
<p><code>nodes(g::Graph)</code> extracts a set of node names from the structured AST.</p>
</li>
<li>
<p><code>edges(g::Graph)</code> extracts a set of edge names (node name pairs) from the
structured AST.</p>
</li>
</ul>
<p>For example, to print node IDs and edge connections in a graph</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ParserCombinator<span class="pl-k">.</span>Parsers<span class="pl-k">.</span>DOT

my_graph <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>graph {</span>
<span class="pl-s">  1 -- 2</span>
<span class="pl-s">  2 -- 3</span>
<span class="pl-s">  3 -- 1</span>
<span class="pl-s">}<span class="pl-pds">"</span></span>

root <span class="pl-k">=</span> <span class="pl-c1">parse_dot</span>(my_graph)

<span class="pl-k">for</span> node <span class="pl-k">in</span> <span class="pl-c1">nodes</span>(root)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>node <span class="pl-v">$(node)</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-k">for</span> (node1, node2) <span class="pl-k">in</span> <span class="pl-c1">edges</span>(root)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>edge <span class="pl-v">$(node1)</span> - <span class="pl-v">$(node2)</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span></pre></div>
<p>giving</p>
<pre><code>node 2
node 3
edge 2 - 3
edge 1 - 3
edge 1 - 2
</code></pre>
<p>Nodes and edges are unordered (returned as a <code>Set</code>).  The graph specification
is undirected (cf <code>digraph {...}</code>) and so the order of nodes in an edge is in
canonical (sorted) form.</p>
<h2><a id="user-content-design" class="anchor" aria-hidden="true" href="#design"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Design</h2>
<p>For a longer discussion of the design of ParserCombinator.jl, please see
<a href="http://www.acooke.org/cute/DetailedDi0.html" rel="nofollow">this blog post</a>, also available
<a href="design.txt">here</a>.</p>
<h3><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Overview</h3>
<p>Parser combinators were first written (afaik) in functional languages
where tail calls do not consume stack.  Also, packrat parsers are
easiest to implement in lazy languages, since shared, cached results
are "free".</p>
<p>Julia has neither tail recursion optimisation nor lazy evaluation.</p>
<p>On the other hand, tail call optimisation is not much use when you
want to support backtracking or combine results from child parsers.
And it is possible to implement combinators for repeated matches using
iteration rather than recursion.</p>
<p>In short, life is complicated.  Different parser features have
different costs and any particular implementation choice needs to be
defended with detailed analysis.  Ideally we want an approach that
supports features with low overhead by default, but which can be
extended to accomodate more expensive features when necessary.</p>
<p>This library defines the grammar in a static graph, which is then
"interpreted" using an explicit trampoline (described in more detail
below).  The main advantages are:</p>
<ul>
<li>
<p>Describing the grammar in a static graph of types, rather than
mutually recursive functions, gives better integration with Julia's
method dispatch.  So, for example, we can overload operators like
<code>+</code> to sequence matchers, or use macros to modify the grammar at
compile time.  And the "execution" of the grammar is simple, using
dispatch on the graph nodes.</p>
</li>
<li>
<p>The semantics of the parser can be modified by changing the
trampoline implementation (which can also be done by method dispatch
on a "configuration" type).  This allows, for example, the choice of
whether to use memoization to be separated from the grammar itself.</p>
</li>
<li>
<p>State is explicitly identified and encapsulated, simplifying both
backtracking (resumption from the current state) and memoization.</p>
</li>
</ul>
<p>The main disadvantages are:</p>
<ul>
<li>
<p>Defining new combinators is more complex.  The behaviour of a
matcher is defined as a group of methods that correspond to
transitions in a state machine.  On the other hand, with dispatch on
the grammar and state nodes, the implementation remains idiomatic
and compact.</p>
</li>
<li>
<p>Although the "feel" and "end result" of the library are similar to
other parser combinator libraries (the grammar types handled are as
expected, for example), one could argue that the matchers are not
"real" combinators (what is written by the user is a graph of types,
not a set of recursive functions, even if the final execution logic
is equivalent).</p>
</li>
</ul>
<h3><a id="user-content-trampoline-protocol" class="anchor" aria-hidden="true" href="#trampoline-protocol"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Trampoline Protocol</h3>
<p>A matcher is invoked by a call to</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">execute</span>(k<span class="pl-k">::</span><span class="pl-c1">Config</span>, m<span class="pl-k">::</span><span class="pl-c1">Matcher</span>, s<span class="pl-k">::</span><span class="pl-c1">State</span>, i) <span class="pl-k">::</span> <span class="pl-c1">Message</span></pre></div>
<p>where <code>k</code> must include, at a minimum, the field <code>k.source</code> that
follows the <a href="http://julia.readthedocs.org/en/latest/stdlib/collections/?highlight=iterator" rel="nofollow">iterator
protocol</a>
when used with <code>i</code>.  So, for example, <code>next(k.source, i)</code> returns the
next value from the source, plus a new iter.</p>
<p>The initial call (ie the first time a given value of <code>i</code> is used,
before any backtracking) will have <code>s</code> equal to <code>CLEAN</code>.</p>
<p>A matcher returns a <code>Message</code> which indicates to the trampoline how
processing should continue:</p>
<ul>
<li>
<p><code>Failure</code> indicates that the match has failed and probably (depending
on parent matcher and configuration) triggers backtracking.  There
is a single instance of the type, <code>FAILURE</code>.</p>
</li>
<li>
<p><code>Success</code> indicates that the match succeeded, and so contains a
result (of type <code>Value</code>, which is a type alias for <code>Any[]</code>) together
with the updated iter <code>i</code> and any state that the matcher will need
to look for further matchers (this can be be <code>DIRTY</code> which is
globally used to indicate that all further matches will fail).</p>
</li>
<li>
<p><code>Execute</code> which results in a "nested" call to a child matcher's
<code>execute</code> method (as above).</p>
</li>
</ul>
<p>The <code>FAILURE</code> and <code>Success</code> messages are processed by the trampoline
and (typically, although a trampoline implementation may also use
cached values) result in calls to</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">failure</span>(k<span class="pl-k">::</span><span class="pl-c1">Config</span>, m<span class="pl-k">::</span><span class="pl-c1">Matcher</span>, s<span class="pl-k">::</span><span class="pl-c1">State</span>) <span class="pl-k">::</span> <span class="pl-c1">Message</span>

<span class="pl-c1">success</span>(k<span class="pl-k">::</span><span class="pl-c1">Config</span>, m<span class="pl-k">::</span><span class="pl-c1">Matcher</span>, s<span class="pl-k">::</span><span class="pl-c1">State</span>, t<span class="pl-k">::</span><span class="pl-c1">State</span>, i, r<span class="pl-k">::</span><span class="pl-c1">Value</span>) <span class="pl-k">::</span> <span class="pl-c1">Message</span></pre></div>
<p>where the parent matcher (<code>m</code>) can do any clean-up work, resulting in a new
<code>Message</code>.</p>
<p>Note that the child's state, <code>t</code>, is returned to the parent.  It is
the responsibility of the parent to save this (in its own state) if it
wants to re-call the child.</p>
<h3><a id="user-content-source-input-text-protocol" class="anchor" aria-hidden="true" href="#source-input-text-protocol"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Source (Input Text) Protocol</h3>
<p>The source text is read using the
<a href="http://julia.readthedocs.org/en/latest/stdlib/collections/?highlight=iterator" rel="nofollow">standard Julia iterator protocol</a>,
extended with several methods defined in <a href="src/core/sources.jl">sources.jl</a>.</p>
<p>The use of iterators means that <code>Dot()</code> returns characters, not strings.  But
in practice that matcher is rarely used (particularly since, with strings, you
can use regular expressions - <code>p"pattern"</code> for example), and you can construct
a string from multiple characters using <code>&gt; string</code>.</p>
<h2><a id="user-content-releases" class="anchor" aria-hidden="true" href="#releases"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Releases</h2>
<p>1.7.0 - 2015-10-13 - Added DOT parser.</p>
<p>1.6.0 - 2015-07-26 - Changed from <code>s"</code> to <code>e"</code>; added support for fast regex
patch.</p>
<p>1.5.0 - 2015-07-25 - Clarified source handling; improved
<a href="issues/5">GML speed</a>.</p>
<p>1.4.0 - 2015-07-18 - Added GML parser; related parse_try fixes.</p>
<p>1.3.0 - 2015-06-27 - Added parse_try.</p>
<p>1.2.0 - 2015-06-28 - Trampoline side rewritten; more execution modes.</p>
<p>1.1.0 - 2015-06-07 - Fixed calc example; debug mode; much rewriting.</p>
<p>1.0.0 - ~2015-06-03 - More or less feature complete.</p>
</article></div>