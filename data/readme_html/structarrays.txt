<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-structarrays" class="anchor" aria-hidden="true" href="#structarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>StructArrays</h1>
<p><a href="https://github.com/JuliaArrays/StructArrays.jl/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/JuliaArrays/StructArrays.jl/workflows/CI/badge.svg?branch=master" alt="CI" style="max-width:100%;"></a>
<a href="http://codecov.io/github/JuliaArrays/StructArrays.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/273707ee8283d80c483a7f6c91a2bb5867bcb4a1d2b486bd64b286565c80faf7/687474703a2f2f636f6465636f762e696f2f6769746875622f4a756c69614172726179732f5374727563744172726179732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/JuliaArrays/StructArrays.jl/coverage.svg?branch=master" style="max-width:100%;"></a>
<a href="https://JuliaArrays.github.io/StructArrays.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a></p>
<p>This package introduces the type <code>StructArray</code> which is an <code>AbstractArray</code> whose elements are <code>struct</code> (for example <code>NamedTuples</code>,  or <code>ComplexF64</code>, or a custom user defined <code>struct</code>). While a <code>StructArray</code> iterates <code>structs</code>, the layout is column based (meaning each field of the <code>struct</code> is stored in a separate <code>Array</code>).</p>
<p><code>Base.getproperty</code> or the dot syntax can be used to access columns, whereas rows can be accessed with <code>getindex</code>.</p>
<p>The package was largely inspired by the <code>Columns</code> type in <a href="https://github.com/JuliaComputing/IndexedTables.jl">IndexedTables</a> which it now replaces.</p>
<h2><a id="user-content-example-usage-to-store-complex-numbers" class="anchor" aria-hidden="true" href="#example-usage-to-store-complex-numbers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example usage to store complex numbers</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; using StructArrays, Random

julia&gt; Random.seed!(4);

julia&gt; s = StructArray{ComplexF64}((rand(2,2), rand(2,2)))
2×2 StructArray(::Array{Float64,2}, ::Array{Float64,2}) with eltype Complex{Float64}:
 0.680079+0.625239im   0.92407+0.267358im
 0.874437+0.737254im  0.929336+0.804478im

julia&gt; s[1, 1]
0.680079235935741 + 0.6252391193298537im

julia&gt; s.re
2×2 Array{Float64,2}:
 0.680079  0.92407
 0.874437  0.929336

julia&gt; StructArrays.components(s) # obtain all field arrays as a named tuple
(re = [0.680079 0.92407; 0.874437 0.929336], im = [0.625239 0.267358; 0.737254 0.804478])
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> StructArrays, Random

julia<span class="pl-k">&gt;</span> Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">4</span>);

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">StructArray</span><span class="pl-c1">{ComplexF64}</span>((<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)))
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>) with eltype Complex{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.680079</span><span class="pl-k">+</span><span class="pl-c1">0.625239im</span>   <span class="pl-c1">0.92407</span><span class="pl-k">+</span><span class="pl-c1">0.267358im</span>
 <span class="pl-c1">0.874437</span><span class="pl-k">+</span><span class="pl-c1">0.737254im</span>  <span class="pl-c1">0.929336</span><span class="pl-k">+</span><span class="pl-c1">0.804478im</span>

julia<span class="pl-k">&gt;</span> s[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>]
<span class="pl-c1">0.680079235935741</span> <span class="pl-k">+</span> <span class="pl-c1">0.6252391193298537im</span>

julia<span class="pl-k">&gt;</span> s<span class="pl-k">.</span>re
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Float64,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.680079</span>  <span class="pl-c1">0.92407</span>
 <span class="pl-c1">0.874437</span>  <span class="pl-c1">0.929336</span>

julia<span class="pl-k">&gt;</span> StructArrays<span class="pl-k">.</span><span class="pl-c1">components</span>(s) <span class="pl-c"><span class="pl-c">#</span> obtain all field arrays as a named tuple</span>
(re <span class="pl-k">=</span> [<span class="pl-c1">0.680079</span> <span class="pl-c1">0.92407</span>; <span class="pl-c1">0.874437</span> <span class="pl-c1">0.929336</span>], im <span class="pl-k">=</span> [<span class="pl-c1">0.625239</span> <span class="pl-c1">0.267358</span>; <span class="pl-c1">0.737254</span> <span class="pl-c1">0.804478</span>])</pre></div>
<p>Note that the same approach can be used directly from an <code>Array</code> of complex numbers:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; StructArray([1+im, 3-2im])
2-element StructArray(::Array{Int64,1}, ::Array{Int64,1}) with eltype Complex{Int64}:
 1 + 1im
 3 - 2im
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">StructArray</span>([<span class="pl-c1">1</span><span class="pl-k">+</span>im, <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">2im</span>])
<span class="pl-c1">2</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>) with eltype Complex{Int64}<span class="pl-k">:</span>
 <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">1im</span>
 <span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">2im</span></pre></div>
<h3><a id="user-content-collection-and-initialization" class="anchor" aria-hidden="true" href="#collection-and-initialization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Collection and initialization</h3>
<p>One can also create a <code>StructArray</code> from an iterable of structs without creating an intermediate <code>Array</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; StructArray(log(j+2.0*im) for j in 1:10)
10-element StructArray(::Array{Float64,1}, ::Array{Float64,1}) with eltype Complex{Float64}:
 0.8047189562170501 + 1.1071487177940904im
 1.0397207708399179 + 0.7853981633974483im
 1.2824746787307684 + 0.5880026035475675im
 1.4978661367769954 + 0.4636476090008061im
  1.683647914993237 + 0.3805063771123649im
 1.8444397270569681 + 0.3217505543966422im
  1.985145956776061 + 0.27829965900511133im
 2.1097538525880535 + 0.24497866312686414im
 2.2213256282451583 + 0.21866894587394195im
 2.3221954495706862 + 0.19739555984988078im
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">StructArray</span>(<span class="pl-c1">log</span>(j<span class="pl-k">+</span><span class="pl-c1">2.0</span><span class="pl-k">*</span>im) <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>)
<span class="pl-c1">10</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Float64,1}</span>) with eltype Complex{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.8047189562170501</span> <span class="pl-k">+</span> <span class="pl-c1">1.1071487177940904im</span>
 <span class="pl-c1">1.0397207708399179</span> <span class="pl-k">+</span> <span class="pl-c1">0.7853981633974483im</span>
 <span class="pl-c1">1.2824746787307684</span> <span class="pl-k">+</span> <span class="pl-c1">0.5880026035475675im</span>
 <span class="pl-c1">1.4978661367769954</span> <span class="pl-k">+</span> <span class="pl-c1">0.4636476090008061im</span>
  <span class="pl-c1">1.683647914993237</span> <span class="pl-k">+</span> <span class="pl-c1">0.3805063771123649im</span>
 <span class="pl-c1">1.8444397270569681</span> <span class="pl-k">+</span> <span class="pl-c1">0.3217505543966422im</span>
  <span class="pl-c1">1.985145956776061</span> <span class="pl-k">+</span> <span class="pl-c1">0.27829965900511133im</span>
 <span class="pl-c1">2.1097538525880535</span> <span class="pl-k">+</span> <span class="pl-c1">0.24497866312686414im</span>
 <span class="pl-c1">2.2213256282451583</span> <span class="pl-k">+</span> <span class="pl-c1">0.21866894587394195im</span>
 <span class="pl-c1">2.3221954495706862</span> <span class="pl-k">+</span> <span class="pl-c1">0.19739555984988078im</span></pre></div>
<p>Another option is to create an uninitialized <code>StructArray</code> and then fill it with data. Just like in normal arrays, this is done with the <code>undef</code> syntax:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; s = StructArray{ComplexF64}(undef, 2, 2)
2×2 StructArray(::Array{Float64,2}, ::Array{Float64,2}) with eltype Complex{Float64}:
 6.91646e-310+6.91646e-310im  6.91646e-310+6.91646e-310im
 6.91646e-310+6.91646e-310im  6.91646e-310+6.91646e-310im

julia&gt; rand!(s)
2×2 StructArray(::Array{Float64,2}, ::Array{Float64,2}) with eltype Complex{Float64}:
 0.680079+0.874437im  0.625239+0.737254im
  0.92407+0.929336im  0.267358+0.804478im
"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">StructArray</span><span class="pl-c1">{ComplexF64}</span>(undef, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>) with eltype Complex{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">6.91646e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91646e-310im</span>  <span class="pl-c1">6.91646e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91646e-310im</span>
 <span class="pl-c1">6.91646e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91646e-310im</span>  <span class="pl-c1">6.91646e-310</span><span class="pl-k">+</span><span class="pl-c1">6.91646e-310im</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rand!</span>(s)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Float64,2}</span>) with eltype Complex{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.680079</span><span class="pl-k">+</span><span class="pl-c1">0.874437im</span>  <span class="pl-c1">0.625239</span><span class="pl-k">+</span><span class="pl-c1">0.737254im</span>
  <span class="pl-c1">0.92407</span><span class="pl-k">+</span><span class="pl-c1">0.929336im</span>  <span class="pl-c1">0.267358</span><span class="pl-k">+</span><span class="pl-c1">0.804478im</span></pre></div>
<h3><a id="user-content-using-custom-array-types" class="anchor" aria-hidden="true" href="#using-custom-array-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using custom array types</h3>
<p>StructArrays supports using custom array types. It is always possible to pass field arrays of a custom type. The "custom array of structs to struct of custom arrays" transformation will use the <code>similar</code> method of the custom array type. This can be useful when working on the GPU for example:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; using StructArrays, CuArrays

julia&gt; a = CuArray(rand(Float32, 10));

julia&gt; b = CuArray(rand(Float32, 10));

julia&gt; StructArray{ComplexF32}((a, b))
10-element StructArray(::CuArray{Float32,1}, ::CuArray{Float32,1}) with eltype Complex{Float32}:
  0.19555175f0 + 0.9604322f0im
  0.68348145f0 + 0.5778245f0im
  0.69664395f0 + 0.79825306f0im
 0.118531585f0 + 0.3031248f0im
  0.80057466f0 + 0.8964418f0im
  0.63772964f0 + 0.2923274f0im
  0.65374136f0 + 0.7932533f0im
   0.6043732f0 + 0.65964353f0im
   0.1106627f0 + 0.090207934f0im
    0.707458f0 + 0.1700114f0im

julia&gt; c = CuArray(rand(ComplexF32, 10));

julia&gt; StructArray(c)
10-element StructArray(::Array{Float32,1}, ::Array{Float32,1}) with eltype Complex{Float32}:
  0.7176411f0 + 0.864058f0im
   0.252609f0 + 0.14824867f0im
 0.26842773f0 + 0.9084332f0im
 0.33128333f0 + 0.5106474f0im
  0.6509278f0 + 0.87059164f0im
  0.9522146f0 + 0.053706646f0im
   0.899577f0 + 0.63242567f0im
   0.325814f0 + 0.59225655f0im
 0.56267905f0 + 0.21927536f0im
 0.49719965f0 + 0.754143f0im
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> StructArrays, CuArrays

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">CuArray</span>(<span class="pl-c1">rand</span>(Float32, <span class="pl-c1">10</span>));

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">CuArray</span>(<span class="pl-c1">rand</span>(Float32, <span class="pl-c1">10</span>));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">StructArray</span><span class="pl-c1">{ComplexF32}</span>((a, b))
<span class="pl-c1">10</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">CuArray{Float32,1}</span>, <span class="pl-k">::</span><span class="pl-c1">CuArray{Float32,1}</span>) with eltype Complex{Float32}<span class="pl-k">:</span>
  <span class="pl-c1">0.19555175f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.9604322f0im</span>
  <span class="pl-c1">0.68348145f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.5778245f0im</span>
  <span class="pl-c1">0.69664395f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.79825306f0im</span>
 <span class="pl-c1">0.118531585f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.3031248f0im</span>
  <span class="pl-c1">0.80057466f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.8964418f0im</span>
  <span class="pl-c1">0.63772964f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.2923274f0im</span>
  <span class="pl-c1">0.65374136f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.7932533f0im</span>
   <span class="pl-c1">0.6043732f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.65964353f0im</span>
   <span class="pl-c1">0.1106627f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.090207934f0im</span>
    <span class="pl-c1">0.707458f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.1700114f0im</span>

julia<span class="pl-k">&gt;</span> c <span class="pl-k">=</span> <span class="pl-c1">CuArray</span>(<span class="pl-c1">rand</span>(ComplexF32, <span class="pl-c1">10</span>));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">StructArray</span>(c)
<span class="pl-c1">10</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float32,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Float32,1}</span>) with eltype Complex{Float32}<span class="pl-k">:</span>
  <span class="pl-c1">0.7176411f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.864058f0im</span>
   <span class="pl-c1">0.252609f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.14824867f0im</span>
 <span class="pl-c1">0.26842773f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.9084332f0im</span>
 <span class="pl-c1">0.33128333f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.5106474f0im</span>
  <span class="pl-c1">0.6509278f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.87059164f0im</span>
  <span class="pl-c1">0.9522146f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.053706646f0im</span>
   <span class="pl-c1">0.899577f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.63242567f0im</span>
   <span class="pl-c1">0.325814f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.59225655f0im</span>
 <span class="pl-c1">0.56267905f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.21927536f0im</span>
 <span class="pl-c1">0.49719965f0</span> <span class="pl-k">+</span> <span class="pl-c1">0.754143f0im</span></pre></div>
<p>If you already have your data in a <code>StructArray</code> with field arrays of a given format (say plain <code>Array</code>) you can change them with <code>replace_storage</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; s = StructArray([1.0+im, 2.0-im])
2-element StructArray(::Array{Float64,1}, ::Array{Float64,1}) with eltype Complex{Float64}:
 1.0 + 1.0im
 2.0 - 1.0im

julia&gt; replace_storage(CuArray, s)
2-element StructArray(::CuArray{Float64,1}, ::CuArray{Float64,1}) with eltype Complex{Float64}:
 1.0 + 1.0im
 2.0 - 1.0im
"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">StructArray</span>([<span class="pl-c1">1.0</span><span class="pl-k">+</span>im, <span class="pl-c1">2.0</span><span class="pl-k">-</span>im])
<span class="pl-c1">2</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Float64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Float64,1}</span>) with eltype Complex{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span> <span class="pl-k">+</span> <span class="pl-c1">1.0im</span>
 <span class="pl-c1">2.0</span> <span class="pl-k">-</span> <span class="pl-c1">1.0im</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">replace_storage</span>(CuArray, s)
<span class="pl-c1">2</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">CuArray{Float64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">CuArray{Float64,1}</span>) with eltype Complex{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span> <span class="pl-k">+</span> <span class="pl-c1">1.0im</span>
 <span class="pl-c1">2.0</span> <span class="pl-k">-</span> <span class="pl-c1">1.0im</span></pre></div>
<h2><a id="user-content-example-usage-to-store-a-data-table" class="anchor" aria-hidden="true" href="#example-usage-to-store-a-data-table"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example usage to store a data table</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; t = StructArray((a = [1, 2], b = [&quot;x&quot;, &quot;y&quot;]))
2-element StructArray(::Array{Int64,1}, ::Array{String,1}) with eltype NamedTuple{(:a, :b),Tuple{Int64,String}}:
 (a = 1, b = &quot;x&quot;)
 (a = 2, b = &quot;y&quot;)

julia&gt; t[1]
(a = 1, b = &quot;x&quot;)

julia&gt; t.a
2-element Array{Int64,1}:
 1
 2

julia&gt; push!(t, (a = 3, b = &quot;z&quot;))
3-element StructArray(::Array{Int64,1}, ::Array{String,1}) with eltype NamedTuple{(:a, :b),Tuple{Int64,String}}:
 (a = 1, b = &quot;x&quot;)
 (a = 2, b = &quot;y&quot;)
 (a = 3, b = &quot;z&quot;)
"><pre>julia<span class="pl-k">&gt;</span> t <span class="pl-k">=</span> <span class="pl-c1">StructArray</span>((a <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], b <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>]))
<span class="pl-c1">2</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{String,1}</span>) with eltype NamedTuple{(<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>),Tuple{Int64,String}}<span class="pl-k">:</span>
 (a <span class="pl-k">=</span> <span class="pl-c1">1</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>)
 (a <span class="pl-k">=</span> <span class="pl-c1">2</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>)

julia<span class="pl-k">&gt;</span> t[<span class="pl-c1">1</span>]
(a <span class="pl-k">=</span> <span class="pl-c1">1</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>)

julia<span class="pl-k">&gt;</span> t<span class="pl-k">.</span>a
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Int64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>
 <span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">push!</span>(t, (a <span class="pl-k">=</span> <span class="pl-c1">3</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>z<span class="pl-pds">"</span></span>))
<span class="pl-c1">3</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{String,1}</span>) with eltype NamedTuple{(<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>),Tuple{Int64,String}}<span class="pl-k">:</span>
 (a <span class="pl-k">=</span> <span class="pl-c1">1</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>)
 (a <span class="pl-k">=</span> <span class="pl-c1">2</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>)
 (a <span class="pl-k">=</span> <span class="pl-c1">3</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>z<span class="pl-pds">"</span></span>)</pre></div>
<h3><a id="user-content-lazy-row-iteration" class="anchor" aria-hidden="true" href="#lazy-row-iteration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lazy row iteration</h3>
<p>StructArrays also provides a <code>LazyRow</code> wrapper for lazy row iteration. <code>LazyRow(t, i)</code> does not materialize the i-th row but returns a lazy wrapper around it on which <code>getproperty</code> does the correct thing. This is useful when the row has many fields only some of which are necessary. It also allows changing columns in place.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; t = StructArray((a = [1, 2], b = [&quot;x&quot;, &quot;y&quot;]));

julia&gt; LazyRow(t, 2).a
2

julia&gt; LazyRow(t, 2).a = 123
123

julia&gt; t
2-element StructArray(::Array{Int64,1}, ::Array{String,1}) with eltype NamedTuple{(:a, :b),Tuple{Int64,String}}:
 (a = 1, b = &quot;x&quot;)
 (a = 123, b = &quot;y&quot;)
"><pre>julia<span class="pl-k">&gt;</span> t <span class="pl-k">=</span> <span class="pl-c1">StructArray</span>((a <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], b <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>]));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">LazyRow</span>(t, <span class="pl-c1">2</span>)<span class="pl-k">.</span>a
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">LazyRow</span>(t, <span class="pl-c1">2</span>)<span class="pl-k">.</span>a <span class="pl-k">=</span> <span class="pl-c1">123</span>
<span class="pl-c1">123</span>

julia<span class="pl-k">&gt;</span> t
<span class="pl-c1">2</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{String,1}</span>) with eltype NamedTuple{(<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>),Tuple{Int64,String}}<span class="pl-k">:</span>
 (a <span class="pl-k">=</span> <span class="pl-c1">1</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>)
 (a <span class="pl-k">=</span> <span class="pl-c1">123</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>)</pre></div>
<p>To iterate in a lazy way one can simply iterate <code>LazyRows</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; map(t -&gt; t.b ^ t.a, LazyRows(t))
2-element Array{String,1}:
 &quot;x&quot;
 &quot;yy&quot;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(t <span class="pl-k">-&gt;</span> t<span class="pl-k">.</span>b <span class="pl-k">^</span> t<span class="pl-k">.</span>a, <span class="pl-c1">LazyRows</span>(t))
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{String,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>yy<span class="pl-pds">"</span></span></pre></div>
<h2><a id="user-content-advanced-structures-with-non-standard-data-layout" class="anchor" aria-hidden="true" href="#advanced-structures-with-non-standard-data-layout"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Advanced: structures with non-standard data layout</h2>
<p>StructArrays support structures with custom data layout. The user is required to overload <code>staticschema</code> in order to define the custom layout, <code>component</code> to access fields of the custom layout, and <code>createinstance(T, fields...)</code> to create an instance of type <code>T</code> from its custom fields <code>fields</code>. In other word, given <code>x::T</code>, <code>createinstance(T, (component(x, f) for f in fieldnames(staticschema(T)))...)</code> should successfully return an instance of type <code>T</code>.</p>
<p>Here is an example of a type <code>MyType</code> that has as custom fields either its field <code>data</code> or fields of its field <code>rest</code> (which is a named tuple):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using StructArrays

struct MyType{T, NT&lt;:NamedTuple}
    data::T
    rest::NT
end

MyType(x; kwargs...) = MyType(x, values(kwargs))

function StructArrays.staticschema(::Type{MyType{T, NamedTuple{names, types}}}) where {T, names, types}
    return NamedTuple{(:data, names...), Base.tuple_type_cons(T, types)}
end

function StructArrays.component(m::MyType, key::Symbol)
    return key === :data ? getfield(m, 1) : getfield(getfield(m, 2), key)
end

# generate an instance of MyType type
function StructArrays.createinstance(::Type{MyType{T, NT}}, x, args...) where {T, NT}
    return MyType(x, NT(args))
end

s = [MyType(rand(), a=1, b=2) for i in 1:10]
StructArray(s)
"><pre><span class="pl-k">using</span> StructArrays

<span class="pl-k">struct</span> MyType{T, NT<span class="pl-k">&lt;:</span><span class="pl-c1">NamedTuple</span>}
    data<span class="pl-k">::</span><span class="pl-c1">T</span>
    rest<span class="pl-k">::</span><span class="pl-c1">NT</span>
<span class="pl-k">end</span>

<span class="pl-en">MyType</span>(x; kwargs<span class="pl-k">...</span>) <span class="pl-k">=</span> <span class="pl-c1">MyType</span>(x, <span class="pl-c1">values</span>(kwargs))

<span class="pl-k">function</span> StructArrays<span class="pl-k">.</span><span class="pl-en">staticschema</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MyType{T, NamedTuple{names, types}}}</span>) <span class="pl-k">where</span> {T, names, types}
    <span class="pl-k">return</span> NamedTuple{(<span class="pl-c1">:data</span>, names<span class="pl-k">...</span>), Base<span class="pl-k">.</span><span class="pl-c1">tuple_type_cons</span>(T, types)}
<span class="pl-k">end</span>

<span class="pl-k">function</span> StructArrays<span class="pl-k">.</span><span class="pl-en">component</span>(m<span class="pl-k">::</span><span class="pl-c1">MyType</span>, key<span class="pl-k">::</span><span class="pl-c1">Symbol</span>)
    <span class="pl-k">return</span> key <span class="pl-k">===</span> <span class="pl-c1">:data</span> <span class="pl-k">?</span> <span class="pl-c1">getfield</span>(m, <span class="pl-c1">1</span>) <span class="pl-k">:</span> <span class="pl-c1">getfield</span>(<span class="pl-c1">getfield</span>(m, <span class="pl-c1">2</span>), key)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> generate an instance of MyType type</span>
<span class="pl-k">function</span> StructArrays<span class="pl-k">.</span><span class="pl-en">createinstance</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MyType{T, NT}}</span>, x, args<span class="pl-k">...</span>) <span class="pl-k">where</span> {T, NT}
    <span class="pl-k">return</span> <span class="pl-c1">MyType</span>(x, <span class="pl-c1">NT</span>(args))
<span class="pl-k">end</span>

s <span class="pl-k">=</span> [<span class="pl-c1">MyType</span>(<span class="pl-c1">rand</span>(), a<span class="pl-k">=</span><span class="pl-c1">1</span>, b<span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>]
<span class="pl-c1">StructArray</span>(s)</pre></div>
<p>In the above example, our <code>MyType</code> was composed of <code>data</code> of type <code>Float64</code> and <code>rest</code> of type <code>NamedTuple</code>. In many practical cases where there are custom types involved it's hard for StructArrays to automatically widen the types in case they are heterogeneous. The following example demonstrates a widening method in that scenario.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Tables

# add a source of custom type data
struct Location{U}
    x::U
    y::U
end
struct Region{V}
    area::V
end

s1 = MyType(Location(1, 0), place = &quot;Delhi&quot;, rainfall = 200)
s2 = MyType(Location(2.5, 1.9), place = &quot;Mumbai&quot;, rainfall = 1010)
s3 = MyType(Region([Location(1, 0), Location(2.5, 1.9)]), place = &quot;North India&quot;, rainfall = missing)

s = [s1, s2, s3]
# Now if we try to do StructArray(s)
# we will get an error

function meta_table(iter)
    cols = Tables.columntable(iter)
    meta_table(first(cols), Base.tail(cols)) 
end

function meta_table(data, rest::NT) where NT&lt;:NamedTuple
    F = MyType{eltype(data), StructArrays.eltypes(NT)}
    return StructArray{F}(; data=data, rest...)
end

meta_table(s)
"><pre><span class="pl-k">using</span> Tables

<span class="pl-c"><span class="pl-c">#</span> add a source of custom type data</span>
<span class="pl-k">struct</span> Location{U}
    x<span class="pl-k">::</span><span class="pl-c1">U</span>
    y<span class="pl-k">::</span><span class="pl-c1">U</span>
<span class="pl-k">end</span>
<span class="pl-k">struct</span> Region{V}
    area<span class="pl-k">::</span><span class="pl-c1">V</span>
<span class="pl-k">end</span>

s1 <span class="pl-k">=</span> <span class="pl-c1">MyType</span>(<span class="pl-c1">Location</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>), place <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Delhi<span class="pl-pds">"</span></span>, rainfall <span class="pl-k">=</span> <span class="pl-c1">200</span>)
s2 <span class="pl-k">=</span> <span class="pl-c1">MyType</span>(<span class="pl-c1">Location</span>(<span class="pl-c1">2.5</span>, <span class="pl-c1">1.9</span>), place <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Mumbai<span class="pl-pds">"</span></span>, rainfall <span class="pl-k">=</span> <span class="pl-c1">1010</span>)
s3 <span class="pl-k">=</span> <span class="pl-c1">MyType</span>(<span class="pl-c1">Region</span>([<span class="pl-c1">Location</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>), <span class="pl-c1">Location</span>(<span class="pl-c1">2.5</span>, <span class="pl-c1">1.9</span>)]), place <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>North India<span class="pl-pds">"</span></span>, rainfall <span class="pl-k">=</span> <span class="pl-c1">missing</span>)

s <span class="pl-k">=</span> [s1, s2, s3]
<span class="pl-c"><span class="pl-c">#</span> Now if we try to do StructArray(s)</span>
<span class="pl-c"><span class="pl-c">#</span> we will get an error</span>

<span class="pl-k">function</span> <span class="pl-en">meta_table</span>(iter)
    cols <span class="pl-k">=</span> Tables<span class="pl-k">.</span><span class="pl-c1">columntable</span>(iter)
    <span class="pl-c1">meta_table</span>(<span class="pl-c1">first</span>(cols), Base<span class="pl-k">.</span><span class="pl-c1">tail</span>(cols)) 
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">meta_table</span>(data, rest<span class="pl-k">::</span><span class="pl-c1">NT</span>) <span class="pl-k">where</span> NT<span class="pl-k">&lt;:</span><span class="pl-c1">NamedTuple</span>
    F <span class="pl-k">=</span> MyType{<span class="pl-c1">eltype</span>(data), StructArrays<span class="pl-k">.</span><span class="pl-c1">eltypes</span>(NT)}
    <span class="pl-k">return</span> <span class="pl-c1">StructArray</span><span class="pl-c1">{F}</span>(; data<span class="pl-k">=</span>data, rest<span class="pl-k">...</span>)
<span class="pl-k">end</span>

<span class="pl-c1">meta_table</span>(s)</pre></div>
<p>The above strategy has been tested and implemented in <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>.</p>
<h2><a id="user-content-advanced-mutate-or-widen-style-accumulation" class="anchor" aria-hidden="true" href="#advanced-mutate-or-widen-style-accumulation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Advanced: mutate-or-widen style accumulation</h2>
<p>StructArrays provides a function <code>StructArrays.append!!(dest, src)</code> (unexported) for "mutate-or-widen" style accumulation.  This function can be used via <a href="https://juliafolds.github.io/BangBang.jl/dev/#BangBang.append!!" rel="nofollow"><code>BangBang.append!!</code></a> and <a href="https://juliafolds.github.io/BangBang.jl/dev/#BangBang.push!!" rel="nofollow"><code>BangBang.push!!</code></a> as well.</p>
<p><code>StructArrays.append!!</code> works like <code>append!(dest, src)</code> if <code>dest</code> can contain all element types in <code>src</code> iterator; i.e., it <em>mutates</em> <code>dest</code> in-place:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; dest = StructVector((a=[1], b=[2]))
1-element StructArray(::Array{Int64,1}, ::Array{Int64,1}) with eltype NamedTuple{(:a, :b),Tuple{Int64,Int64}}:
 (a = 1, b = 2)

julia&gt; StructArrays.append!!(dest, [(a = 3, b = 4)])
2-element StructArray(::Array{Int64,1}, ::Array{Int64,1}) with eltype NamedTuple{(:a, :b),Tuple{Int64,Int64}}:
 (a = 1, b = 2)
 (a = 3, b = 4)

julia&gt; ans === dest
true
"><pre>julia<span class="pl-k">&gt;</span> dest <span class="pl-k">=</span> <span class="pl-c1">StructVector</span>((a<span class="pl-k">=</span>[<span class="pl-c1">1</span>], b<span class="pl-k">=</span>[<span class="pl-c1">2</span>]))
<span class="pl-c1">1</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>) with eltype NamedTuple{(<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>),Tuple{Int64,Int64}}<span class="pl-k">:</span>
 (a <span class="pl-k">=</span> <span class="pl-c1">1</span>, b <span class="pl-k">=</span> <span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> StructArrays<span class="pl-k">.</span><span class="pl-c1">append!!</span>(dest, [(a <span class="pl-k">=</span> <span class="pl-c1">3</span>, b <span class="pl-k">=</span> <span class="pl-c1">4</span>)])
<span class="pl-c1">2</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>) with eltype NamedTuple{(<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>),Tuple{Int64,Int64}}<span class="pl-k">:</span>
 (a <span class="pl-k">=</span> <span class="pl-c1">1</span>, b <span class="pl-k">=</span> <span class="pl-c1">2</span>)
 (a <span class="pl-k">=</span> <span class="pl-c1">3</span>, b <span class="pl-k">=</span> <span class="pl-c1">4</span>)

julia<span class="pl-k">&gt;</span> ans <span class="pl-k">===</span> dest
<span class="pl-c1">true</span></pre></div>
<p>Unlike <code>append!</code>, <code>append!!</code> can also <em>widen</em> element type of <code>dest</code> array:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; StructArrays.append!!(dest, [(a = missing, b = 6)])
3-element StructArray(::Array{Union{Missing, Int64},1}, ::Array{Int64,1}) with eltype NamedTuple{(:a, :b),Tuple{Union{Missing, Int64},Int64}}:
 NamedTuple{(:a, :b),Tuple{Union{Missing, Int64},Int64}}((1, 2))
 NamedTuple{(:a, :b),Tuple{Union{Missing, Int64},Int64}}((3, 4))
 NamedTuple{(:a, :b),Tuple{Union{Missing, Int64},Int64}}((missing, 6))

julia&gt; ans === dest
false
"><pre>julia<span class="pl-k">&gt;</span> StructArrays<span class="pl-k">.</span><span class="pl-c1">append!!</span>(dest, [(a <span class="pl-k">=</span> <span class="pl-c1">missing</span>, b <span class="pl-k">=</span> <span class="pl-c1">6</span>)])
<span class="pl-c1">3</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Array{Union{Missing, Int64},1}</span>, <span class="pl-k">::</span><span class="pl-c1">Array{Int64,1}</span>) with eltype NamedTuple{(<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>),Tuple{Union{Missing, Int64},Int64}}<span class="pl-k">:</span>
 <span class="pl-c1">NamedTuple</span><span class="pl-c1">{(:a, :b),Tuple{Union{Missing, Int64},Int64}}</span>((<span class="pl-c1">1</span>, <span class="pl-c1">2</span>))
 <span class="pl-c1">NamedTuple</span><span class="pl-c1">{(:a, :b),Tuple{Union{Missing, Int64},Int64}}</span>((<span class="pl-c1">3</span>, <span class="pl-c1">4</span>))
 <span class="pl-c1">NamedTuple</span><span class="pl-c1">{(:a, :b),Tuple{Union{Missing, Int64},Int64}}</span>((<span class="pl-c1">missing</span>, <span class="pl-c1">6</span>))

julia<span class="pl-k">&gt;</span> ans <span class="pl-k">===</span> dest
<span class="pl-c1">false</span></pre></div>
<p>Since the original array <code>dest</code> cannot hold the input, a new array is created (<code>ans !== dest</code>).</p>
<p>Combined with <a href="https://docs.julialang.org/en/latest/manual/performance-tips/#kernel-functions-1" rel="nofollow">function barriers</a>, <code>append!!</code> is a useful building block for implementing <code>collect</code>-like functions.</p>
<h2><a id="user-content-advanced-using-structarrays-in-cuda-kernels" class="anchor" aria-hidden="true" href="#advanced-using-structarrays-in-cuda-kernels"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Advanced: using StructArrays in CUDA kernels</h2>
<p>It is possible to combine StructArrays with <a href="https://github.com/JuliaGPU/CUDAnative.jl">CUDAnative</a>, in order to create CUDA kernels that work on StructArrays directly on the GPU. Make sure you are familiar with the CUDAnative documentation (esp. kernels with plain <code>CuArray</code>s) before experimenting with kernels based on <code>StructArray</code>s.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using CUDAnative, CuArrays, StructArrays
d = StructArray(a = rand(100), b = rand(100))

# move to GPU
dd = replace_storage(CuArray, d)
de = similar(dd)

# a simple kernel, to copy the content of `dd` onto `de`
function kernel!(dest, src)
    i = (blockIdx().x-1)*blockDim().x + threadIdx().x
    if i &lt;= length(dest)
        dest[i] = src[i]
    end
    return nothing
end

threads = 1024
blocks = cld(length(dd),threads)

@cuda threads=threads blocks=blocks kernel!(de, dd)
"><pre><span class="pl-k">using</span> CUDAnative, CuArrays, StructArrays
d <span class="pl-k">=</span> <span class="pl-c1">StructArray</span>(a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>), b <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>))

<span class="pl-c"><span class="pl-c">#</span> move to GPU</span>
dd <span class="pl-k">=</span> <span class="pl-c1">replace_storage</span>(CuArray, d)
de <span class="pl-k">=</span> <span class="pl-c1">similar</span>(dd)

<span class="pl-c"><span class="pl-c">#</span> a simple kernel, to copy the content of `dd` onto `de`</span>
<span class="pl-k">function</span> <span class="pl-en">kernel!</span>(dest, src)
    i <span class="pl-k">=</span> (<span class="pl-c1">blockIdx</span>()<span class="pl-k">.</span>x<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span><span class="pl-c1">blockDim</span>()<span class="pl-k">.</span>x <span class="pl-k">+</span> <span class="pl-c1">threadIdx</span>()<span class="pl-k">.</span>x
    <span class="pl-k">if</span> i <span class="pl-k">&lt;=</span> <span class="pl-c1">length</span>(dest)
        dest[i] <span class="pl-k">=</span> src[i]
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>

threads <span class="pl-k">=</span> <span class="pl-c1">1024</span>
blocks <span class="pl-k">=</span> <span class="pl-c1">cld</span>(<span class="pl-c1">length</span>(dd),threads)

<span class="pl-c1">@cuda</span> threads<span class="pl-k">=</span>threads blocks<span class="pl-k">=</span>blocks <span class="pl-c1">kernel!</span>(de, dd)</pre></div>
<h2><a id="user-content-applying-a-function-on-each-field-array" class="anchor" aria-hidden="true" href="#applying-a-function-on-each-field-array"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Applying a function on each field array</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; struct Foo
       a::Int
       b::String
       end

julia&gt; s = StructArray([Foo(11, &quot;a&quot;), Foo(22, &quot;b&quot;), Foo(33, &quot;c&quot;), Foo(44, &quot;d&quot;), Foo(55, &quot;e&quot;)]);

julia&gt; s
5-element StructArray(::Vector{Int64}, ::Vector{String}) with eltype Foo:
 Foo(11, &quot;a&quot;)
 Foo(22, &quot;b&quot;)
 Foo(33, &quot;c&quot;)
 Foo(44, &quot;d&quot;)
 Foo(55, &quot;e&quot;)

julia&gt; StructArrays.foreachfield(v -&gt; deleteat!(v, 3), s)

julia&gt; s
4-element StructArray(::Vector{Int64}, ::Vector{String}) with eltype Foo:
 Foo(11, &quot;a&quot;)
 Foo(22, &quot;b&quot;)
 Foo(44, &quot;d&quot;)
 Foo(55, &quot;e&quot;)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Foo
       a<span class="pl-k">::</span><span class="pl-c1">Int</span>
       b<span class="pl-k">::</span><span class="pl-c1">String</span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">StructArray</span>([<span class="pl-c1">Foo</span>(<span class="pl-c1">11</span>, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>), <span class="pl-c1">Foo</span>(<span class="pl-c1">22</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>), <span class="pl-c1">Foo</span>(<span class="pl-c1">33</span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>), <span class="pl-c1">Foo</span>(<span class="pl-c1">44</span>, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>), <span class="pl-c1">Foo</span>(<span class="pl-c1">55</span>, <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>)]);

julia<span class="pl-k">&gt;</span> s
<span class="pl-c1">5</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Int64}</span>, <span class="pl-k">::</span><span class="pl-c1">Vector{String}</span>) with eltype Foo<span class="pl-k">:</span>
 <span class="pl-c1">Foo</span>(<span class="pl-c1">11</span>, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)
 <span class="pl-c1">Foo</span>(<span class="pl-c1">22</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)
 <span class="pl-c1">Foo</span>(<span class="pl-c1">33</span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)
 <span class="pl-c1">Foo</span>(<span class="pl-c1">44</span>, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>)
 <span class="pl-c1">Foo</span>(<span class="pl-c1">55</span>, <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>)

julia<span class="pl-k">&gt;</span> StructArrays<span class="pl-k">.</span><span class="pl-c1">foreachfield</span>(v <span class="pl-k">-&gt;</span> <span class="pl-c1">deleteat!</span>(v, <span class="pl-c1">3</span>), s)

julia<span class="pl-k">&gt;</span> s
<span class="pl-c1">4</span><span class="pl-k">-</span>element <span class="pl-c1">StructArray</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Int64}</span>, <span class="pl-k">::</span><span class="pl-c1">Vector{String}</span>) with eltype Foo<span class="pl-k">:</span>
 <span class="pl-c1">Foo</span>(<span class="pl-c1">11</span>, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)
 <span class="pl-c1">Foo</span>(<span class="pl-c1">22</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)
 <span class="pl-c1">Foo</span>(<span class="pl-c1">44</span>, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>)
 <span class="pl-c1">Foo</span>(<span class="pl-c1">55</span>, <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>)</pre></div>
</article></div>