<div id="readme" class="md" data-path="readme.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-sortingsortingoutjl" class="anchor" aria-hidden="true" href="#sortingsortingoutjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SortingSortingOut.jl</h1>
<p>Experiments with a new sorting &amp; ordering API for Julia.</p>
<h2><a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Features</h2>
<h3><a id="user-content-composable-order-types" class="anchor" aria-hidden="true" href="#composable-order-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Composable order types</h3>
<p>Exports functor-like objects <code>By</code>, <code>Rev</code> and <code>Op</code> and the predefined ordering</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">const</span> Forward <span class="pl-k">=</span> <span class="pl-c1">Op</span>(isless)
<span class="pl-k">const</span> Backward <span class="pl-k">=</span> <span class="pl-c1">Rev</span>(Forward)</pre></div>
<p>These objects compose well:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">method_in_some_package!</span>(xs<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>, ord) <span class="pl-k">=</span> <span class="pl-c1">my_sort!</span>(xs, <span class="pl-c1">Rev</span>(<span class="pl-c1">By</span>(abs, ord)))

xs <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">7</span>)
perm <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">7</span>)
ord <span class="pl-k">=</span> <span class="pl-c1">By</span>(i <span class="pl-k">-&gt;</span> xs[i])
<span class="pl-c1">method_in_some_package!</span>(perm, ord)

<span class="pl-c1">@show</span> xs[perm]
<span class="pl-c"><span class="pl-c">#</span> xs[perm] = [-1.20628, 1.03054, -0.929885, -0.620184, 0.391168, -0.29274, 0.172728]</span></pre></div>
<h3><a id="user-content-better-dispatch-of-specialized-algorithms" class="anchor" aria-hidden="true" href="#better-dispatch-of-specialized-algorithms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Better dispatch of specialized algorithms</h3>
<p>Currently we have an advanced sorting algorithm to sort <code>Float64</code> and <code>Float32</code> by the order
induced by <code>isless</code>, but the downside is that we <em>almost never</em> dispatch on it in practice
because of the restrictive signature:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">sort!</span>(v<span class="pl-k">::</span><span class="pl-c1">AbstractVector{&lt;:Union{Float32,Float64}}</span>, <span class="pl-k">...</span>)</pre></div>
<p>For instance <code>sort([1.0, 2.0, -3.0], by = abs)</code> will not match the signature.</p>
<p><strong>The proposed fix</strong> in this package is to canonicalize the order instances such that we can
dispatch on (a) the inferred type that goes into the comparison function, (b) the comparison
function itself and (c) the direction (forward or backward).</p>
<p>Internally it works by summarizing composed ordering types in a linearized fashion via a
function called <code>flatten</code>. This function takes an ordering and element type of the vector
and returns a <code>TrivialOrder{T,F,R&lt;:Bool,B} &lt;: Ord</code> instance (and sometimes the original
order if it thinks the order is nontrivial). Here <code>T</code> is the type that goes into the
comparison function, <code>F</code> is the type of the comparison function itself, <code>R</code> is true when
sorting in reverse and <code>B</code> is a tuple of types of all the gathered <code>by</code> functions /
transformations. An explicit example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">&gt;</span> xs <span class="pl-k">=</span> [<span class="pl-c1">6</span>, <span class="pl-c1">5</span>, <span class="pl-c1">2</span>, <span class="pl-c1">7</span>]
<span class="pl-k">&gt;</span> ord <span class="pl-k">=</span> <span class="pl-c1">By</span>(inv, <span class="pl-c1">Rev</span>(<span class="pl-c1">By</span>(abs, Backward))) <span class="pl-c"><span class="pl-c">#</span> 2 by functions</span>
<span class="pl-k">&gt;</span> effective_ord <span class="pl-k">=</span> SortingSortingOut<span class="pl-k">.</span><span class="pl-c1">flatten</span>(ord, <span class="pl-c1">eltype</span>(xs))
<span class="pl-c1">TrivialOrder</span><span class="pl-c1">{Float64,typeof(isless),false,Tuple{typeof(inv),typeof(abs)}}</span>(isless, (inv, abs))
<span class="pl-c"><span class="pl-c">#</span> Effectively this order comes down to sorting `Float64` with `isless`, so sorting will</span>
<span class="pl-c"><span class="pl-c">#</span> automatically dispatch on the efficient algorithm for this order.</span>
<span class="pl-k">&gt;</span> <span class="pl-c1">my_sort!</span>(xs, effective_ord)</pre></div>
<p>The above is completely equivalent to:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">&gt;</span> <span class="pl-c1">my_sort!</span>(xs, ord)</pre></div>
<h4><a id="user-content-example-sorting-products-by-weight" class="anchor" aria-hidden="true" href="#example-sorting-products-by-weight"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: sorting products by weight</h4>
<table>
<thead>
<tr>
<th>n</th>
<th><code>sort!</code></th>
<th><code>my_sort!</code></th>
<th>speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>10_000</td>
<td>1.113 ms</td>
<td>560.6 μs</td>
<td>2.0x</td>
</tr>
<tr>
<td>1_000</td>
<td>66.00 μs</td>
<td>11.66 μs</td>
<td>5.7x</td>
</tr>
<tr>
<td>100</td>
<td>2.021 μs</td>
<td>615.6 ns</td>
<td>3.3x</td>
</tr>
</tbody>
</table>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> SortingSortingOut, BenchmarkTools

<span class="pl-k">struct</span> Product
    price<span class="pl-k">::</span><span class="pl-c1">Int</span>
    weight<span class="pl-k">::</span><span class="pl-c1">Float64</span>
<span class="pl-k">end</span>

<span class="pl-en">weight</span>(p<span class="pl-k">::</span><span class="pl-c1">Product</span>) <span class="pl-k">=</span> p<span class="pl-k">.</span>weight

<span class="pl-k">function</span> <span class="pl-en">sort_products</span>(n <span class="pl-k">=</span> <span class="pl-c1">100</span>)
    products <span class="pl-k">=</span> [<span class="pl-c1">Product</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>), <span class="pl-c1">100</span><span class="pl-c1">rand</span>()) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span> : n]

    fst <span class="pl-k">=</span> <span class="pl-c1">@benchmark</span> <span class="pl-c1">sort!</span>(ps, by <span class="pl-k">=</span> <span class="pl-k">$</span>weight) setup <span class="pl-k">=</span> (ps <span class="pl-k">=</span> <span class="pl-c1">copy</span>(<span class="pl-k">$</span>products))
    snd <span class="pl-k">=</span> <span class="pl-c1">@benchmark</span> <span class="pl-c1">my_sort!</span>(ps, <span class="pl-k">$</span>(<span class="pl-c1">By</span>(weight))) setup <span class="pl-k">=</span> (ps <span class="pl-k">=</span> <span class="pl-c1">copy</span>(<span class="pl-k">$</span>products))

    fst, snd
<span class="pl-k">end</span></pre></div>
<h4><a id="user-content-example-sorting-complex-numbers-by-absolute-magnitude" class="anchor" aria-hidden="true" href="#example-sorting-complex-numbers-by-absolute-magnitude"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: sorting complex numbers by absolute magnitude</h4>
<table>
<thead>
<tr>
<th>n</th>
<th><code>sort!</code></th>
<th><code>my_sort!</code></th>
<th>speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>10_000</td>
<td>1.128 ms</td>
<td>722.3 μs</td>
<td>1.6x</td>
</tr>
<tr>
<td>1_000</td>
<td>49.62 μs</td>
<td>28.16 μs</td>
<td>1.8x</td>
</tr>
<tr>
<td>100</td>
<td>2.296 μs</td>
<td>787.5 ns</td>
<td>2.9x</td>
</tr>
</tbody>
</table>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> SortingSortingOut, BenchmarkTools

<span class="pl-k">function</span> <span class="pl-en">sort_by_magnitude</span>(n <span class="pl-k">=</span> <span class="pl-c1">1_000</span>)
    xs <span class="pl-k">=</span> <span class="pl-c1">rand</span>(ComplexF64, n)

    fst <span class="pl-k">=</span> <span class="pl-c1">@benchmark</span> <span class="pl-c1">sort!</span>(ys, by <span class="pl-k">=</span> <span class="pl-k">$</span>abs2) setup <span class="pl-k">=</span> (ys <span class="pl-k">=</span> <span class="pl-c1">copy</span>(<span class="pl-k">$</span>xs))
    snd <span class="pl-k">=</span> <span class="pl-c1">@benchmark</span> <span class="pl-c1">my_sort!</span>(ys, <span class="pl-k">$</span>(<span class="pl-c1">By</span>(abs2))) setup <span class="pl-k">=</span> (ys <span class="pl-k">=</span> <span class="pl-c1">copy</span>(<span class="pl-k">$</span>xs))

    fst, snd
<span class="pl-k">end</span></pre></div>
<h4><a id="user-content-sorting-vectors-of-small-unions" class="anchor" aria-hidden="true" href="#sorting-vectors-of-small-unions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Sorting vectors of small unions</h4>
<p>Via the exact same logic as the fast floating point sort code, we could potentially also
efficiently sort <code>Vector{Union{T,Nothing}}</code> by partitioning the vector in <code>[T..., Nothing...]</code>
first, and subsequently calling a fast sort method on the first bit with just <code>T</code>'s.</p>
<p>And this package would then allow to also sort <code>sort!(v, by = maybe_something)</code> where the
function <code>maybe_something</code> returns for instance <code>Union{T,Missing}</code> values.</p>
<p>However, AFAIK this cannot yet work because we cannot convince the compiler (without
overhead) that a value of type <code>Union{T,Nothing}</code> is actually a <code>T</code>  -- even when we're
100% sure it is.</p>
<h3><a id="user-content-maximum-and-minimum-accept-ord-instances" class="anchor" aria-hidden="true" href="#maximum-and-minimum-accept-ord-instances"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>maximum</code> and <code>minimum</code> accept <code>Ord</code> instances</h3>
<p>Two changes to these methods:</p>
<ol>
<li>They return <code>nothing</code> when an empty collection is passed</li>
<li>They accept <code>Ord</code> instances and satisfy
<code>my_maximum(xs, ord) == my_sort(Vector(xs), ord)[end]</code> and
<code>my_minimum(xs, ord) === my_sort(Vector(xs), ord)[1]</code>.</li>
</ol>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> SortingSortingOut

<span class="pl-c1">my_maximum</span>([<span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-k">-</span><span class="pl-c1">5</span>], <span class="pl-c1">By</span>(abs)) <span class="pl-c"><span class="pl-c">#</span> -5</span>
<span class="pl-c1">my_maximum</span>((i <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span> : <span class="pl-c1">10</span>), Forward) <span class="pl-c"><span class="pl-c">#</span> 10</span>
<span class="pl-c1">my_maximum</span>([]) <span class="pl-c"><span class="pl-c">#</span> nothing</span></pre></div>
<h3><a id="user-content-make-search-convenient----search-by-transformed-value-not-by-specific-vector-element" class="anchor" aria-hidden="true" href="#make-search-convenient----search-by-transformed-value-not-by-specific-vector-element"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Make search convenient -- search by (transformed) value, not by specific vector element</h3>
<p>Currently there is an <a href="https://github.com/JuliaLang/julia/issues/9429">unresolved issue</a>
in Julia Base where one has to construct a "fake" vector element in order to search. For
instance:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Product
         name<span class="pl-k">::</span><span class="pl-c1">String</span>
         price<span class="pl-k">::</span><span class="pl-c1">Int</span>
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> products <span class="pl-k">=</span> [<span class="pl-c1">Product</span>(<span class="pl-s"><span class="pl-pds">"</span>Apple<span class="pl-pds">"</span></span>, <span class="pl-c1">75</span>), <span class="pl-c1">Product</span>(<span class="pl-s"><span class="pl-pds">"</span>Book<span class="pl-pds">"</span></span>, <span class="pl-c1">1200</span>), <span class="pl-c1">Product</span>(<span class="pl-s"><span class="pl-pds">"</span>Car<span class="pl-pds">"</span></span>, <span class="pl-c1">50000</span>)];

julia<span class="pl-k">&gt;</span> <span class="pl-c1">searchsortedfirst</span>(products, <span class="pl-c1">100</span>, by <span class="pl-k">=</span> p <span class="pl-k">-&gt;</span> p<span class="pl-k">.</span>price)
ERROR<span class="pl-k">:</span> type Int64 has no field price

julia<span class="pl-k">&gt;</span> <span class="pl-c1">searchsortedfirst</span>(products, <span class="pl-c1">Product</span>(<span class="pl-s"><span class="pl-pds">"</span>Fake product<span class="pl-pds">"</span></span>, <span class="pl-c1">100</span>), by <span class="pl-k">=</span> p <span class="pl-k">-&gt;</span> p<span class="pl-k">.</span>price)
<span class="pl-c1">2</span></pre></div>
<p>A solution to this problem is to implement a new comparison function:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">is_price_less</span>(product<span class="pl-k">::</span><span class="pl-c1">Product</span>, price<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">=</span> <span class="pl-c1">isless</span>(product<span class="pl-k">.</span>price, price);
julia<span class="pl-k">&gt;</span> <span class="pl-en">is_price_less</span>(price<span class="pl-k">::</span><span class="pl-c1">Int</span>, product<span class="pl-k">::</span><span class="pl-c1">Product</span>) <span class="pl-k">=</span> <span class="pl-c1">isless</span>(price, product<span class="pl-k">.</span>price);
julia<span class="pl-k">&gt;</span> <span class="pl-c1">searchsortedfirst</span>(products, <span class="pl-c1">100</span>, lt <span class="pl-k">=</span> is_price_less)
<span class="pl-c1">2</span></pre></div>
<p>but this seems more verbose than necessary and will not work whenever the type of the
transformed value is equal to the original element type of the vector.</p>
<p>For instance, suppose we have a vector of integers sorted by absolute magnitude, and we
naively search for the index of the first value greater than or equal to <code>-2</code>. This should
obvioulsy be the first index. The following does <em>not</em> work as (maybe?) expected</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">searchsortedfirst</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-k">-</span><span class="pl-c1">2</span>, by <span class="pl-k">=</span> abs)
<span class="pl-c1">2</span></pre></div>
<p>since <code>-2</code> gets transformd to <code>2</code>. To solve this we have to provide a different comparison
operator and build a <code>Wrapper</code> struct to make multiple dispatch work:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Wrapper
         value
       <span class="pl-k">end</span>;
julia<span class="pl-k">&gt;</span> <span class="pl-en">abs_lt</span>(a, b<span class="pl-k">::</span><span class="pl-c1">Wrapper</span>) <span class="pl-k">=</span> <span class="pl-c1">isless</span>(<span class="pl-c1">abs</span>(a), b<span class="pl-k">.</span>value)
julia<span class="pl-k">&gt;</span> <span class="pl-en">abs_lt</span>(a<span class="pl-k">::</span><span class="pl-c1">Wrapper</span>, b) <span class="pl-k">=</span> <span class="pl-c1">isless</span>(a<span class="pl-k">.</span>value, <span class="pl-c1">abs</span>(b))
julia<span class="pl-k">&gt;</span> <span class="pl-c1">searchsortedfirst</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-c1">Wrapper</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>), lt <span class="pl-k">=</span> abs_lt)
<span class="pl-c1">1</span></pre></div>
<p>But this is very verbose and hard to untangle. Also it does not seem to compose well.</p>
<p>To address this, this package provides a wrapper type called <code>Value</code> which allows you to
write simple one-liners:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">lowerbound</span>(products, <span class="pl-c1">100</span>, <span class="pl-c1">By</span>(p <span class="pl-k">-&gt;</span> p<span class="pl-k">.</span>price))
ERROR<span class="pl-k">:</span> type Int64 has no field price

julia<span class="pl-k">&gt;</span> <span class="pl-c1">lowerbound</span>(products, <span class="pl-c1">Value</span>(<span class="pl-c1">100</span>), <span class="pl-c1">By</span>(p <span class="pl-k">-&gt;</span> p<span class="pl-k">.</span>price))
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">lowerbound</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">By</span>(abs)) <span class="pl-c"><span class="pl-c">#</span> transformation applies to -2</span>
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">lowerbound</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-c1">Value</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>), <span class="pl-c1">By</span>(abs)) <span class="pl-c"><span class="pl-c">#</span> no transformation of -2</span>
<span class="pl-c1">1</span></pre></div>
<p>Also note that the functions have been renamed a bit:</p>
<ul>
<li><code>searchsortedfirst</code> -&gt; <code>lowerbound</code></li>
<li><code>searchsortedlast</code> -&gt; <code>upperbound</code></li>
<li><code>searchsorted</code> -&gt; <code>equalrange</code></li>
</ul>
</article></div>