<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-edkitjl" class="anchor" aria-hidden="true" href="#edkitjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>EDKit.jl</h1>
<p dir="auto">Julia package for general many-body exact diagonalization calculation. The package provide a general Hamiltonian constructing routine for specific symmetry sectors. The functionalities can be extended with user-defined bases.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Run the following script in the <code>Pkg REPL</code> environment:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add EDKit"><pre>pkg<span class="pl-k">&gt;</span> add EDKit</pre></div>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<h2 dir="auto"><a id="user-content-xxz-model-with-random-field" class="anchor" aria-hidden="true" href="#xxz-model-with-random-field"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>XXZ Model with Random Field</h2>
<p dir="auto">Consider the Hamiltonian</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="6578524b6bb95da13a04a355fb4e29b1">$$H = \sum_i\left(\sigma_i^x \sigma^x_{i+1} + \sigma^y_i\sigma^y_{i+1} + h_i \sigma^z_i\sigma^z_{i+1}\right).$$</math-renderer>
<p dir="auto">We choose the system size to be <code>L=10</code>. The Hamiltonian need 3 generic information:</p>
<ol dir="auto">
<li>Local operators represented by matrices;</li>
<li>Site indices where each local operator acts on;</li>
<li>Basis, if use the default tensor-product basis, only need to provide the system size.</li>
</ol>
<p dir="auto">The following script generate the information we need to generate XXZ Hamiltonian:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="L = 10
mats = [
    fill(spin(&quot;XX&quot;), L);
    fill(spin(&quot;YY&quot;), L);
    [randn() * spin(&quot;ZZ&quot;) for i=1:L]
]
inds = [
    [[i, mod(i, L)+1] for i=1:L];
    [[i, mod(i, L)+1] for i=1:L];
    [[i, mod(i, L)+1] for i=1:L]
]
H = operator(mats, inds, L)"><pre>L <span class="pl-k">=</span> <span class="pl-c1">10</span>
mats <span class="pl-k">=</span> [
    <span class="pl-c1">fill</span>(<span class="pl-c1">spin</span>(<span class="pl-s"><span class="pl-pds">"</span>XX<span class="pl-pds">"</span></span>), L);
    <span class="pl-c1">fill</span>(<span class="pl-c1">spin</span>(<span class="pl-s"><span class="pl-pds">"</span>YY<span class="pl-pds">"</span></span>), L);
    [<span class="pl-c1">randn</span>() <span class="pl-k">*</span> <span class="pl-c1">spin</span>(<span class="pl-s"><span class="pl-pds">"</span>ZZ<span class="pl-pds">"</span></span>) <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>L]
]
inds <span class="pl-k">=</span> [
    [[i, <span class="pl-c1">mod</span>(i, L)<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>L];
    [[i, <span class="pl-c1">mod</span>(i, L)<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>L];
    [[i, <span class="pl-c1">mod</span>(i, L)<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>L]
]
H <span class="pl-k">=</span> <span class="pl-c1">operator</span>(mats, inds, L)</pre></div>
<p dir="auto">Then we can use the constructor <code>operator</code> to create Hamiltonian:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; H = operator(mats, inds, L)
Operator of size (1024, 1024) with 10 terms."><pre>julia<span class="pl-k">&gt;</span> H <span class="pl-k">=</span> <span class="pl-c1">operator</span>(mats, inds, L)
Operator of size (<span class="pl-c1">1024</span>, <span class="pl-c1">1024</span>) with <span class="pl-c1">10</span> terms.</pre></div>
<p dir="auto">The constructor return an <code>Operator</code> object, which is a linear operator that can act on vector/ matrix. For example, we can act <code>H</code> on the ferromagnetic state:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ψ = zeros(2^L); ψ[1] = 1; H * random_state
1024-element Vector{Float64}:
 -1.5539463277491536
  5.969061189628827
  3.439873269795492
  1.6217619009059376
  0.6101231697221667
  6.663735992405236
  ⋮
  5.517409105968883
  0.9498121684380652
 -0.0004996659995972763
  2.6020967735388734
  4.99027405325114
 -1.4831032210847952"><pre>julia<span class="pl-k">&gt;</span> ψ <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">2</span><span class="pl-k">^</span>L); ψ[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>; H <span class="pl-k">*</span> random_state
<span class="pl-c1">1024</span><span class="pl-k">-</span>element Vector{Float64}<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">1.5539463277491536</span>
  <span class="pl-c1">5.969061189628827</span>
  <span class="pl-c1">3.439873269795492</span>
  <span class="pl-c1">1.6217619009059376</span>
  <span class="pl-c1">0.6101231697221667</span>
  <span class="pl-c1">6.663735992405236</span>
  ⋮
  <span class="pl-c1">5.517409105968883</span>
  <span class="pl-c1">0.9498121684380652</span>
 <span class="pl-k">-</span><span class="pl-c1">0.0004996659995972763</span>
  <span class="pl-c1">2.6020967735388734</span>
  <span class="pl-c1">4.99027405325114</span>
 <span class="pl-k">-</span><span class="pl-c1">1.4831032210847952</span></pre></div>
<p dir="auto">If we need a matrix representation of the Hamitonian, we can convert <code>H</code> to julia array by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Array(H)
1024×1024 Matrix{Float64}:
 -1.55617  0.0       0.0       0.0     …   0.0      0.0       0.0
  0.0      4.18381   2.0       0.0         0.0      0.0       0.0
  0.0      2.0      -1.42438   0.0         0.0      0.0       0.0
  0.0      0.0       0.0      -1.5901      0.0      0.0       0.0
  0.0      0.0       2.0       0.0         0.0      0.0       0.0
  0.0      0.0       0.0       2.0     …   0.0      0.0       0.0
  ⋮                                    ⋱                     
  0.0      0.0       0.0       0.0         0.0      0.0       0.0
  0.0      0.0       0.0       0.0         2.0      0.0       0.0
  0.0      0.0       0.0       0.0     …   0.0      0.0       0.0
  0.0      0.0       0.0       0.0        -1.42438  2.0       0.0
  0.0      0.0       0.0       0.0         2.0      4.18381   0.0
  0.0      0.0       0.0       0.0         0.0      0.0      -1.55617"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Array</span>(H)
<span class="pl-c1">1024</span><span class="pl-k">×</span><span class="pl-c1">1024</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">1.55617</span>  <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>     …   <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">4.18381</span>   <span class="pl-c1">2.0</span>       <span class="pl-c1">0.0</span>         <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">2.0</span>      <span class="pl-k">-</span><span class="pl-c1">1.42438</span>   <span class="pl-c1">0.0</span>         <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>      <span class="pl-k">-</span><span class="pl-c1">1.5901</span>      <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">2.0</span>       <span class="pl-c1">0.0</span>         <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">2.0</span>     …   <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  ⋮                                    ⋱                     
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>         <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>         <span class="pl-c1">2.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>     …   <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>        <span class="pl-k">-</span><span class="pl-c1">1.42438</span>  <span class="pl-c1">2.0</span>       <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>         <span class="pl-c1">2.0</span>      <span class="pl-c1">4.18381</span>   <span class="pl-c1">0.0</span>
  <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>         <span class="pl-c1">0.0</span>      <span class="pl-c1">0.0</span>      <span class="pl-k">-</span><span class="pl-c1">1.55617</span></pre></div>
<p dir="auto">Or use the function <code>sparse</code> to create the sparse matrix (requires the module <code>SparseArrays</code> being imported):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; sparse(H)
1024×1024 SparseMatrixCSC{Float64, Int64} with 6144 stored entries:
⠻⣦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⢹⡻⣮⡳⠄⢠⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠙⠎⢿⣷⡀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠲⣄⠈⠻⣦⣄⠙⠀⠀⠀⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠳⣄⠙⡻⣮⡳⡄⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠙⠮⢻⣶⡄⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀
⢤⡀⠀⠀⠀⠀⠠⣄⠀⠀⠀⠉⠛⣤⣀⠀⠀⠀⠙⠂⠀⠀⠀⠀⠈⠓
⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠘⠿⣧⡲⣄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠘⢮⡻⣮⣄⠙⢦⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⠀⠀⠀⣄⠙⠻⣦⡀⠙⠦⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠈⢿⣷⡰⣄⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠃⠐⢮⡻⣮⣇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠻⣦"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">sparse</span>(H)
<span class="pl-c1">1024</span><span class="pl-k">×</span><span class="pl-c1">1024</span> SparseMatrixCSC{Float64, Int64} with <span class="pl-c1">6144</span> stored entries<span class="pl-k">:</span>
⠻⣦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⢹⡻⣮⡳⠄⢠⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠙⠎⢿⣷⡀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠲⣄⠈⠻⣦⣄⠙⠀⠀⠀⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠳⣄⠙⡻⣮⡳⡄⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠙⠮⢻⣶⡄⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀
⢤⡀⠀⠀⠀⠀⠠⣄⠀⠀⠀⠉⠛⣤⣀⠀⠀⠀⠙⠂⠀⠀⠀⠀⠈⠓
⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠘⠿⣧⡲⣄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠘⢮⡻⣮⣄⠙⢦⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⠀⠀⠀⣄⠙⠻⣦⡀⠙⠦⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠈⢿⣷⡰⣄⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠃⠐⢮⡻⣮⣇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠻⣦</pre></div>
<h2 dir="auto">
<a id="user-content-solving-aklt-model-using-symmetries" class="anchor" aria-hidden="true" href="#solving-aklt-model-using-symmetries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Solving AKLT Model Using Symmetries</h2>
<p dir="auto">Consider the AKLT model</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="6578524b6bb95da13a04a355fb4e29b1">$$H = \sum_i\left[\vec S_i \cdot \vec S_{i+1} + \frac{1}{3}\left(\vec S_i \cdot \vec S_{i+1}\right)^2\right],$$</math-renderer>
<p dir="auto">with system size chosen to be <code>L=8</code>. The Hamiltonian operator for this translational-invariant Hamiltonian can be constructed using the <code>trans_inv_operator</code> function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="L = 8
SS = spin((1, &quot;xx&quot;), (1, &quot;yy&quot;), (1, &quot;zz&quot;), D=3)
mat = SS + 1/3 * SS^2
H = trans_inv_operator(mat, 1:2, L)"><pre>L <span class="pl-k">=</span> <span class="pl-c1">8</span>
SS <span class="pl-k">=</span> <span class="pl-c1">spin</span>((<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>xx<span class="pl-pds">"</span></span>), (<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>yy<span class="pl-pds">"</span></span>), (<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>zz<span class="pl-pds">"</span></span>), D<span class="pl-k">=</span><span class="pl-c1">3</span>)
mat <span class="pl-k">=</span> SS <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">3</span> <span class="pl-k">*</span> SS<span class="pl-k">^</span><span class="pl-c1">2</span>
H <span class="pl-k">=</span> <span class="pl-c1">trans_inv_operator</span>(mat, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, L)</pre></div>
<p dir="auto">The second input specifies the indices the operators act on.</p>
<p dir="auto">Because of the translational symmetry, we can simplify the problem by considering the symmetry. We construct a translational-symmetric basis by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="B = TranslationalBasis(L=8, k=8, base=3)"><pre>B <span class="pl-k">=</span> <span class="pl-c1">TranslationalBasis</span>(L<span class="pl-k">=</span><span class="pl-c1">8</span>, k<span class="pl-k">=</span><span class="pl-c1">8</span>, base<span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>
<p dir="auto">Here, <code>L</code> is the length of the system, and <code>k</code> labels the momentum <code>k = 0,...,L-1</code> (integer multiply of 2π/L). The function <code>TranslationalBasis</code> return a basis object containing 834 states. We can obtain the Hamiltonian in this sector by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; H = trans_inv_operator(mat, 1:2, B)
Operator of size (834, 834) with 8 terms."><pre>julia<span class="pl-k">&gt;</span> H <span class="pl-k">=</span> <span class="pl-c1">trans_inv_operator</span>(mat, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, B)
Operator of size (<span class="pl-c1">834</span>, <span class="pl-c1">834</span>) with <span class="pl-c1">8</span> terms.</pre></div>
<p dir="auto">In addition, we can take into account the total <code>S^z</code> conservation, by constructing the basis</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="B = TranslationalBasis(L=8, N=8, k=0, base=3)"><pre>B <span class="pl-k">=</span> <span class="pl-c1">TranslationalBasis</span>(L<span class="pl-k">=</span><span class="pl-c1">8</span>, N<span class="pl-k">=</span><span class="pl-c1">8</span>, k<span class="pl-k">=</span><span class="pl-c1">0</span>, base<span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>
<p dir="auto">where the <code>N</code> is the filling number with respect to all-spin-down state. N=L means we select those states whose total <code>Sz</code> equalls 0 (note that we use 0,1,2 to label the <code>Sz=1,0,-1</code> states). This gives a further reduced Hamiltonian matrix:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; H = trans_inv_operator(mat, 1:2, B)
Operator of size (142, 142) with 8 terms."><pre>julia<span class="pl-k">&gt;</span> H <span class="pl-k">=</span> <span class="pl-c1">trans_inv_operator</span>(mat, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, B)
Operator of size (<span class="pl-c1">142</span>, <span class="pl-c1">142</span>) with <span class="pl-c1">8</span> terms.</pre></div>
<p dir="auto">We can go on step further by considering the spatial reflection symmetry.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="B = TranslationParityBasis(L=8, N=0, k=0, p=1, base=3)"><pre>B <span class="pl-k">=</span> <span class="pl-c1">TranslationParityBasis</span>(L<span class="pl-k">=</span><span class="pl-c1">8</span>, N<span class="pl-k">=</span><span class="pl-c1">0</span>, k<span class="pl-k">=</span><span class="pl-c1">0</span>, p<span class="pl-k">=</span><span class="pl-c1">1</span>, base<span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>
<p dir="auto">where the <code>p</code> argument is the parity <code>p = ±1</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; H = trans_inv_operator(mat, 1:2, B)
Operator of size (84, 84) with 8 terms."><pre>julia<span class="pl-k">&gt;</span> H <span class="pl-k">=</span> <span class="pl-c1">trans_inv_operator</span>(mat, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, B)
Operator of size (<span class="pl-c1">84</span>, <span class="pl-c1">84</span>) with <span class="pl-c1">8</span> terms.</pre></div>
<h2 dir="auto">
<a id="user-content-pxp-model-and-entanglement-entropy" class="anchor" aria-hidden="true" href="#pxp-model-and-entanglement-entropy"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PXP Model and Entanglement Entropy</h2>
<p dir="auto">Consider the PXP model</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="6578524b6bb95da13a04a355fb4e29b1">$$H = \sum_i \left(P^0_{i-1} \sigma^x_i P^0_{i+1}\right).$$</math-renderer>
<p dir="auto">Note that the model is defined on the Hilbert space where there is no local <code>|↑↑⟩</code> configuration. For system size <code>L=20</code> and in sector <code>k=0,p=+1</code>, the Hamiltonian is constructed by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mat = begin
    P = [1 0; 0 0]
    kron(P, spin(&quot;X&quot;), P)
end
pxpf(v::Vector{&lt;:Integer}) = all(v[i]==0 || v[mod(i, length(v))+1]==0 for i=1:length(v))
basis = TranslationParityBasis(L=20, f=pxpf, k=0, p=1)
H = trans_inv_operator(mat, 2, basis)"><pre>mat <span class="pl-k">=</span> <span class="pl-k">begin</span>
    P <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span>; <span class="pl-c1">0</span> <span class="pl-c1">0</span>]
    <span class="pl-c1">kron</span>(P, <span class="pl-c1">spin</span>(<span class="pl-s"><span class="pl-pds">"</span>X<span class="pl-pds">"</span></span>), P)
<span class="pl-k">end</span>
<span class="pl-en">pxpf</span>(v<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Integer}</span>) <span class="pl-k">=</span> <span class="pl-c1">all</span>(v[i]<span class="pl-k">==</span><span class="pl-c1">0</span> <span class="pl-k">||</span> v[<span class="pl-c1">mod</span>(i, <span class="pl-c1">length</span>(v))<span class="pl-k">+</span><span class="pl-c1">1</span>]<span class="pl-k">==</span><span class="pl-c1">0</span> <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(v))
basis <span class="pl-k">=</span> <span class="pl-c1">TranslationParityBasis</span>(L<span class="pl-k">=</span><span class="pl-c1">20</span>, f<span class="pl-k">=</span>pxpf, k<span class="pl-k">=</span><span class="pl-c1">0</span>, p<span class="pl-k">=</span><span class="pl-c1">1</span>)
H <span class="pl-k">=</span> <span class="pl-c1">trans_inv_operator</span>(mat, <span class="pl-c1">2</span>, basis)</pre></div>
<p dir="auto">where <code>f</code> augument is the selection function for the basis state that can be user defined. We can then diagonalize the Hamiltonian. The bipartite entanglement entropy for each eigenstates can be computed by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vals, vecs = Array(H) |&gt; Hermitian |&gt; eigen
EE = [ent_S(vecs[:,i], 1:L÷2, basis) for i=1:size(basis,1)]
scatter(vals, EE, xlabel=&quot;E&quot;,ylabel=&quot;S&quot;,legend=false)"><pre>vals, vecs <span class="pl-k">=</span> <span class="pl-c1">Array</span>(H) <span class="pl-k">|&gt;</span> Hermitian <span class="pl-k">|&gt;</span> eigen
EE <span class="pl-k">=</span> [<span class="pl-c1">ent_S</span>(vecs[:,i], <span class="pl-c1">1</span><span class="pl-k">:</span>L<span class="pl-k">÷</span><span class="pl-c1">2</span>, basis) <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(basis,<span class="pl-c1">1</span>)]
<span class="pl-c1">scatter</span>(vals, EE, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>E<span class="pl-pds">"</span></span>,ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>S<span class="pl-pds">"</span></span>,legend<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto">The plot is</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/EE.png"><img src="docs/src/EE.png" alt="" style="max-width: 100%;"></a></p>
</article></div>