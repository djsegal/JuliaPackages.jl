<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-merakitjl" class="anchor" aria-hidden="true" href="#merakitjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MERAKit.jl</h1>
<p><a href="https://mhauru.github.io/MERAKit.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/mhauru/MERAKit.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a563fb267482aa1bf3998509c4e8b29df327060b249e8c196a3af88ca940d685/68747470733a2f2f7472617669732d63692e6f72672f6d68617572752f4d4552414b69742e6a6c2e7376673f6272616e63683d6d6173746572" alt="" data-canonical-src="https://travis-ci.org/mhauru/MERAKit.jl.svg?branch=master" style="max-width:100%;"></a> <a href="https://codecov.io/gh/mhauru/MERAKit.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e116d387acfa5065cb946a87342549341b1a21e0906e9c67f44918f249798681/68747470733a2f2f636f6465636f762e696f2f67682f6d68617572752f4d4552414b69742e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="" data-canonical-src="https://codecov.io/gh/mhauru/MERAKit.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>MERAKit.jl provides Julia implementations of <a href="https://arxiv.org/abs/quant-ph/0610099" rel="nofollow">Multiscale Entaglement Renormalization Ansatz</a> algorithms.
At the moment it only implements infinite, translation invariant MERA.
It has implementations of ternary, binary, and modified binary MERA, with functions for doing energy minimization, evaluating local expectation values, and computing scaling dimensions.
Energy can be minimised using either the classic <a href="https://arxiv.org/abs/0707.1454" rel="nofollow">alternating energy minimization algorithm</a>, that in the code is called the Evenbly-Vidal algorithm, or using <a href="https://arxiv.org/abs/2007.03638" rel="nofollow">gradient-based optimization methods</a>.
MERAKit.jl makes extensive use of <a href="https://github.com/Jutho/TensorKit.jl">TensorKit</a>, and uses it to support global internal group symmetries, both Abelian and non-Abelian, as well as anyonic MERAs.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="]add https://github.com/mhauru/MERAKit.jl
"><pre><code>]add https://github.com/mhauru/MERAKit.jl
</code></pre></div>
<p>or if you also want the demo scripts discussed below,</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="git clone https://github.com/mhauru/MERAKit.jl
"><pre><code>git clone https://github.com/mhauru/MERAKit.jl
</code></pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The reference documentation can be found <a href="https://mhauru.github.io/MERAKit.jl/dev/" rel="nofollow">here</a>.
However, in practice the best way to get started is to use the script <code>demo/demo.jl</code> as an example: <code>julia --project=. demo/demo.jl</code> should get you running.
It runs energy minimization on the Ising model, using a bond dimension 8 ternary MERA, and computes scaling dimensions and entanglement entropies for the resulting MERA.
It shows you how to initialize a random MERA, optimize it for a given Hamiltonian, and measure things from the MERA.
It also shows you how to gradually increase the bond dimension during an optimization, something that is often very helpful in aiding convergence.
Once you've gone through <code>demo.jl</code>, you can check out the reference docs for things like additional options for how to do energy minimization, etc.</p>
<p>If you have any questions, requests, or issues, feel free to open a GitHub issue or email <a href="mailto:markus@mhauru.org">markus@mhauru.org</a>.</p>
<h2><a id="user-content-structure-of-the-package" class="anchor" aria-hidden="true" href="#structure-of-the-package"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Structure of the package</h2>
<p>The actual library is obviously in <code>src</code>.
The type system is based on an abstract type <code>GenericMERA{N, LT} where LT &lt;: Layer</code>, and its concrete subtypes such as <code>TernaryMERA{N} = GenericMERA{N, TernaryLayer}</code> and <code>BinaryMERA{N} = GenericMERA{N, BinaryLayer}</code>.
Here's a rough summary of the contents of each file in <code>src</code>:</p>
<ul>
<li><code>MERAKit.jl</code>: Exports, imports, and inclusion of the other files.</li>
<li><code>layer.jl</code>: Define the abstract type <code>Layer</code>, and empty functions for it that subtypes should implement.</li>
<li><code>genericmera.jl</code>: The <code>GenericMERA</code> type and all functions that are common to all types of MERAs.</li>
<li><code>meracache.jl</code>: A cache for things like ascended operators and environments, used by <code>GenericMERA</code>.</li>
<li><code>simplelayer.jl</code>: <code>SimpleLayer &lt;: Layer</code>, an abstract type for layers that are made out of a collection of tensors and nothing else, and methods for it. All of the current concrete layer types are subtypes of <code>SimpleLayer</code>.</li>
<li><code>binarylayer.jl</code>, <code>ternarylayer.jl</code>, <code>modifiedbinarylayer.jl</code>: The concrete layer types, and all methods that depend on the specific type of MERA, e.g. diagrams for contraction of ascending and descending superoperators.</li>
<li><code>modifiedbinaryop.jl</code>: The <code>ModifiedBinaryOp</code> type, that's used for representing the alternating structure of operators ascended/descended through a <code>ModifiedBinaryMERA</code>.</li>
<li><code>tensortools.jl</code>: Utilities, mostly related to <code>TensorMap</code>s.</li>
</ul>
<p>See also <code>test/runtests.jl</code> for the test suite.</p>
</article></div>