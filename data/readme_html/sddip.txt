<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-sddip" class="anchor" aria-hidden="true" href="#sddip"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SDDiP</h1>
<p><a href="https://travis-ci.org/lkapelevich/SDDiP.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d33fefa2baf30444496b1c5685b0cee51dbc6bd4/68747470733a2f2f7472617669732d63692e6f72672f6c6b6170656c65766963682f53444469502e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/lkapelevich/SDDiP.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p><a href="https://coveralls.io/github/lkapelevich/SDDiP.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/9ecf4f41c008d9193730a2659be0949d34a36a02/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6c6b6170656c65766963682f53444469502e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/lkapelevich/SDDiP.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a></p>
<p><a href="http://codecov.io/github/lkapelevich/SDDiP.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/359bc3fe2a64d9895cf18d9310a0fe7d4385310f/687474703a2f2f636f6465636f762e696f2f6769746875622f6c6b6170656c65766963682f53444469502e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/lkapelevich/SDDiP.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>This repository contains old code moved to and maintained in <a href="https://github.com/odow/SDDP.jl" title="SDDP.jl"><code>SDDP.jl</code></a>.</p>
<p>SDDiP is a version of SDDP for integer local or state variables.
If a model includes integer variables, we cannot compute cut coefficients in the way we normally do in SDDP (by querying duals from an LP solver). In SDDiP, each stage problem is solved via its Lagrangian dual in the backward pass.</p>
<p>The implementation of SDDiP in this package comes from the paper by <em>Zhou, J., Ahmed, S., Sun, X.A.</em> (2016): Nested Decomposition of Multistage Stochastic
Integer Programs with Binary State Variables.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">clone</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/lkapelevich/SDDiP.jl<span class="pl-pds">"</span></span>)</pre></div>
<p>This package is built upon <a href="https://github.com/odow/">@odow</a>'s SDDP package, <a href="https://github.com/odow/SDDP.jl" title="SDDP.jl"><code>SDDP.jl</code></a>:</p>
<div class="highlight highlight-source-julia"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">clone</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/odow/SDDP.jl<span class="pl-pds">"</span></span>)</pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>Note there are some examples in the <em>examples</em> folder.</p>
<p>The first step is to become familiar with <code>SDDP.jl</code>. For this, have a look at the <code>SDDP.jl</code> <a href="https://odow.github.io/SDDP.jl/latest/" title="SDDP.jl latest" rel="nofollow">documentation</a>.</p>
<h3><a id="user-content-calling-the-solver" class="anchor" aria-hidden="true" href="#calling-the-solver"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Calling the solver</h3>
<p>Using <code>SDDP.jl</code>, a user should include a call to <code>setSDDiPsolver!</code> at the end of a stage problem definition:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">setSDDiPsolver!</span>(sp<span class="pl-k">::</span><span class="pl-c1">JuMP.Model</span>; method<span class="pl-k">=</span><span class="pl-c1">KelleyMethod</span>(), pattern<span class="pl-k">=</span><span class="pl-c1">Pattern</span>(), MIPsolver<span class="pl-k">=</span>sp<span class="pl-k">.</span>solver, LPsolver<span class="pl-k">=</span>MIPsolver)</pre></div>
<p>The keyword arguments are as follows.</p>
<ul>
<li><code>method</code>: An <code>AbstractLagrangianMethod</code> object from that defines how the Lagrangian will be solved. See the readme in <em>src/Lagrangian</em>.</li>
<li><code>pattern</code>: Allows us to choose to add Lagrangian cuts, Benders cuts, or strengthened Benders cuts every so often. See <strong>Pattern</strong> below.</li>
<li><code>MIPsolver</code>: The solver that will be used every time a MIP is solved.</li>
<li><code>LPsolver</code>: The solver that is used ever time an LP is solved.</li>
</ul>
<h3><a id="user-content-declaring-state-variables" class="anchor" aria-hidden="true" href="#declaring-state-variables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Declaring state variables</h3>
<p>We can declare state variables using the <code>@binarystate</code> macro  (like <a href="https://github.com/odow/">@state</a>).</p>
<p>There are four required arguments. The first three come from <code>@state</code>:</p>
<ul>
<li>A stage problem object,</li>
<li>State at the end of a stage (written like a JuMP variable),</li>
<li>State at the start of a stage.</li>
</ul>
<p>The fourth argument is special for SDDiP:</p>
<ul>
<li>Type of variable: binary (Bin), integer (Int), or continuous (Cont).</li>
</ul>
<p>For example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@binarystate</span>(sp, <span class="pl-c1">1</span> <span class="pl-k">&lt;=</span> x[i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>] <span class="pl-k">&lt;=</span> <span class="pl-c1">10</span>, x0 <span class="pl-k">==</span> <span class="pl-c1">ones</span>(<span class="pl-c1">3</span>)[i] , Int)</pre></div>
<p>Although our state may be described by variables that are binary, integer, or continuous,
only binary variables are ever registered as state variables in the SDDP model.</p>
<p>We will compute the binary expansion of integer and continuous variables
(as described in <em>Zhou, J., et. al.</em> (2016)).</p>
<p>For continuous variables, we can also specify a precision for binary expansion as
an optional fifth argument.</p>
<p>For example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@binarystate</span>(sp, <span class="pl-c1">1</span> <span class="pl-k">&lt;=</span> x[i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>] <span class="pl-k">&lt;=</span> <span class="pl-c1">10</span>, x0 <span class="pl-k">==</span> <span class="pl-c1">ones</span>(<span class="pl-c1">3</span>)[i] , Cont, <span class="pl-c1">0.01</span>)</pre></div>
<p>If a precision is not specified, the default precision is 0.1.</p>
<h4><a id="user-content-pattern" class="anchor" aria-hidden="true" href="#pattern"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern</h4>
<p>The Pattern function has the definition:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">Pattern</span>(;benders<span class="pl-k">=</span><span class="pl-c1">0</span>, strengthened_benders<span class="pl-k">=</span><span class="pl-c1">0</span>, integer_optimality<span class="pl-k">=</span><span class="pl-c1">0</span>, lagrangian<span class="pl-k">=</span><span class="pl-c1">1</span>)</pre></div>
<p>with, for example,</p>
<pre><code>Pattern(benders=0, strengthened_benders=1, lagrangian=4)
</code></pre>
<p>meaning that in every cycle of 5 iterations, we should add 1 strengthened Benders cut and 4 Lagrangian cuts.</p>
</article></div>