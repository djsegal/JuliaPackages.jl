<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-differentiablestatespacemodels" class="anchor" aria-hidden="true" href="#differentiablestatespacemodels"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DifferentiableStateSpaceModels</h1>
<p dir="auto"><a href="https://github.com/HighDimensionalEconLab/DifferentiableStateSpaceModels.jl/actions"><img src="https://github.com/HighDimensionalEconLab/DifferentiableStateSpaceModels.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/HighDimensionalEconLab/DifferentiableStateSpaceModels.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/935de9da384ac079cb3cdc80771ba28694a87d50f44d3fcacb6e25c3ae3b8f1b/68747470733a2f2f636f6465636f762e696f2f67682f4869676844696d656e73696f6e616c45636f6e4c61622f446966666572656e746961626c65537461746553706163654d6f64656c732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/HighDimensionalEconLab/DifferentiableStateSpaceModels.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><strong>Warning:</strong>  This package is a proof of concept.  While the code will remain working with proper use of a <a href="https://pkgdocs.julialang.org/v1/" rel="nofollow">Julia manifest</a>, we can't guarantee ongoing support and maintenance, so you should be prepared to modify the source and help maintain it if using this code for projects.</p>
<p dir="auto">For a more complete example with the code below and Bayesian estimation, see the <a href="https://nbviewer.org/github/HighDimensionalEconLab/DifferentiableStateSpaceModels.jl/blob/main/notebooks/estimate_rbc.ipynb" rel="nofollow">rbc estimation notebook</a>.</p>
<h2 dir="auto"><a id="user-content-development-and-benchmarking" class="anchor" aria-hidden="true" href="#development-and-benchmarking"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Development and Benchmarking</h2>
<p dir="auto">See <a href="development.md">development.md</a> for contributing code and running benchmarks</p>
<h1 dir="auto"><a id="user-content-model-class" class="anchor" aria-hidden="true" href="#model-class"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Model Class</h1>
<p dir="auto">The model follows <a href="http://www.columbia.edu/~mu2166/2nd_order/2nd_order.pdf" rel="nofollow">Schmitt-Grohe and Uribe (2004)</a> timing convention.  The system takes a nonlinear expectational difference equation including all first-order conditions for decisions and the system evolution equations,</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
\mathbb{E}_{t}\mathcal{H}\left(y',y,x',x;p\right)=0
$$</math-renderer></p>
<p dir="auto">where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$y$</math-renderer> are the control variables, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$x$</math-renderer> are the states, and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer> is a vector of deep parameters of interest.  Expectations are taken over forward-looking variables and an underlying random process <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\epsilon'$</math-renderer>.</p>
<p dir="auto">In addition, we consider an observation equation - which might be noisy, for</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
z = Q \cdot \begin{bmatrix}y &amp;x\end{bmatrix}^{\top} + \nu
$$</math-renderer></p>
<p dir="auto">where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\nu$</math-renderer> may or may not be normally distributed but <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbb{E}(\nu) = 0$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbb{V}(\nu) = \Omega(p) \Omega(p)^{\top}$</math-renderer>.</p>
<p dir="auto">Assume that there is a non-stochastic steady state of this problem as <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$y_{ss}, x_{ss}$</math-renderer>.</p>
<h2 dir="auto">
<a id="user-content-perturbation-solution" class="anchor" aria-hidden="true" href="#perturbation-solution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Perturbation Solution</h2>
<p dir="auto">Define the deviation from the non-stochastic steady state as <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\hat{x} \equiv x - x_{ss}, \hat{y} \equiv y - y_{ss},$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\hat{z} \equiv z - z_{ss}$</math-renderer>.</p>
<p dir="auto">The solution finds the first or second order perturbation around that non-stochastic steady state, and yields</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
x' = h(x; p) + \eta \ \Gamma(p)\ \epsilon'
$$</math-renderer></p>
<p dir="auto">where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\eta$</math-renderer> describes how shocks affect the law of motion and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbb{E}(\epsilon') = 0$</math-renderer>.  Frequently this would be organized such that <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbb{V}(\epsilon)= I$</math-renderer>, but that is not required.  In addition, it could instead be interpreted as for <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$x' = h(x; p) + \eta \ \epsilon'$</math-renderer> with <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbb{V}(\epsilon') = \Gamma(p) \Gamma(p)^{\top}$</math-renderer>.</p>
<p dir="auto">and with the policy equation,</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
y = g(x; p)
$$</math-renderer></p>
<p dir="auto">and finally, substitution in for the observation equation</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
z= Q \begin{bmatrix} g(x;p) \\ x \end{bmatrix} + \nu
$$</math-renderer></p>
<h2 dir="auto">
<a id="user-content-first-order-solutions" class="anchor" aria-hidden="true" href="#first-order-solutions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>First Order Solutions</h2>
<p dir="auto">Perturbation approximates the above model equations, where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$h$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$g$</math-renderer> are not available explicitly, by a Taylor expansion around the steady state. For example, in the case of the 1st order model the solution finds</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
\hat{x}' = A(p)\ \hat{x} + B(p) \epsilon'
$$</math-renderer></p>
<p dir="auto">and</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
\hat{y} = g_x(p) \ \hat{x}
$$</math-renderer></p>
<p dir="auto">and</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
\hat{z} = C(p)\ \hat{x} + \nu
$$</math-renderer></p>
<p dir="auto">where</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$$
C(p) \equiv Q \begin{bmatrix} g_x(p) \\ I\end{bmatrix},
$$</math-renderer></p>
<p dir="auto"><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$B(p) \equiv \eta \Gamma(p)$</math-renderer>, and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbb{V}(v) = D(\nu) D(p)^{\top}$</math-renderer>.  Normality of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\nu$</math-renderer> or <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\epsilon'$</math-renderer> is not required in general.</p>
<p dir="auto">This is a linear state-space model and if the priors and shocks are Gaussian, a marginal likelihood can be evaluated with classic methods such as a Kalman Filter.  The output of the perturbation can be used manually, or in conjunction with <a href="https://github.com/SciML/DifferenceEquations.jl">DifferenceEquations.jl</a>.</p>
<p dir="auto">Second-order solutions are defined similarly.  See the estimation notebook for more details.</p>
<h2 dir="auto">
<a id="user-content-gradients" class="anchor" aria-hidden="true" href="#gradients"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Gradients</h2>
<p dir="auto">All of the above use standard solution methods.  The primary contribution of this package is that all of these model elements are <strong>differentiable</strong>. Hence, these gradeients can be composed for use in applications such as optimization, gradient-based estimation methods, and with  <a href="https://github.com/SciML/DifferenceEquations.jl">DifferenceEquations.jl</a>  which provides differentiable simulations and likelihoods for state-space models.  That is, if we think of a perturbation solver mapping <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer> to solutions (e.g. in first order <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbf{P}(p) \to (A, B, C, D)$</math-renderer>, then we can find the gradients <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\partial_p \mathbf{P}(p), \partial_p A(p)$</math-renderer> etc.  Or, when these gradients are available for use with reverse-mode auto-differentiation, it can take "wobbles" in <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$A, B, C, D$</math-renderer> and go back to the "wiggles" of the underlying <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer> through <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\mathbf{P}$</math-renderer>.  See <a href="https://juliadiff.org/ChainRulesCore.jl/stable/maths/propagators.html" rel="nofollow">ChainRules.jl</a> for more details on AD.</p>
<h1 dir="auto">
<a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h1>
<h2 dir="auto">
<a id="user-content-model-primitives" class="anchor" aria-hidden="true" href="#model-primitives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Model Primitives</h2>
<p dir="auto">Models are defined using a Dynare-style DSL using <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a>.  The list of primitives are:</p>
<ol dir="auto">
<li>The list of variables for the controls <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$y$</math-renderer>, state <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$x$</math-renderer>, and deep parameters <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer>.</li>
<li>The set of equations <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$H$</math-renderer> as a function of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p, y(t), y(t+1), x(t),$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$x(t+1)$</math-renderer>.  No <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$t-1$</math-renderer> timing is allowed.</li>
<li>The loading of shocks <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\eta$</math-renderer> as a fixed matrix of constants</li>
<li>The shock covariance Cholesky factor <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\Gamma$</math-renderer> as a function of parameters <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer>
</li>
<li>The observation equation <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$Q$</math-renderer> as a fixed matrix.</li>
<li>The Cholesky factor of the observation errors, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$\Omega$</math-renderer> as a function of parameters <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer>.  At this point only a diagonal matrix is supported.</li>
<li>Either the steady state equations for all of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$y$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$x$</math-renderer> in closed form as a function of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer>, or initial conditions for the nonlinear solution to solve for the steady state as functions of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="548876fd7f05589ab00e65692727d553">$p$</math-renderer>
</li>
</ol>
<h2 dir="auto">
<a id="user-content-defining-models" class="anchor" aria-hidden="true" href="#defining-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Defining Models</h2>
<p dir="auto">Install this package with <code>] add DifferentiableStateSpaceModels</code>, then the full code to create the RBC model is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="∞ = Inf
@variables α, β, ρ, δ, σ, Ω_1
@variables t::Integer, k(..), z(..), c(..), q(..)

x = [k, z] # states
y = [c, q] # controls
p = [α, β, ρ, δ, σ, Ω_1] # parameters

H = [1 / c(t) - (β / c(t + 1)) * (α * exp(z(t + 1)) * k(t + 1)^(α - 1) + (1 - δ)),
     c(t) + k(t + 1) - (1 - δ) * k(t) - q(t),
     q(t) - exp(z(t)) * k(t)^α,
     z(t + 1) - ρ * z(t)]  # system of model equations

# analytic solutions for the steady state.  Could pass initial values and run solver and use initial values with steady_states_iv
steady_states = [k(∞) ~ (((1 / β) - 1 + δ) / α)^(1 / (α - 1)),
                 z(∞) ~ 0,
                 c(∞) ~ (((1 / β) - 1 + δ) / α)^(α / (α - 1)) -
                        δ * (((1 / β) - 1 + δ) / α)^(1 / (α - 1)),
                 q(∞) ~ (((1 / β) - 1 + δ) / α)^(α / (α - 1))]


Γ = [σ;;] # matrix for the 1 shock.  The [;;] notation just makes it a matrix rather than vector in julia
η = [0; -1;;] # η is n_x * n_ϵ matrix.  The [;; ]notation just makes it a matrix rather than vector in julia

# observation matrix.  order is &quot;y&quot; then &quot;x&quot; variables, so [c,q,k,z] in this example
Q = [1.0 0  0   0; # select c as first &quot;z&quot; observable
     0   0  1.0 0] # select k as second &quot;z&quot; observable

# diagonal cholesky of covariance matrix for observation noise (so these are standard deviations).  Non-diagonal observation noise not currently supported
Ω = [Ω_1, Ω_1]

# Generates the files and includes if required.  If the model is already created, then just loads
overwrite_model_cache  = true
model_rbc = @make_and_include_perturbation_model(&quot;rbc_notebook_example&quot;, H, (; t, y, x, p, steady_states, Γ, Ω, η, Q, overwrite_model_cache))"><pre>∞ <span class="pl-k">=</span> <span class="pl-c1">Inf</span>
<span class="pl-c1">@variables</span> α, β, ρ, δ, σ, Ω_1
<span class="pl-c1">@variables</span> t<span class="pl-k">::</span><span class="pl-c1">Integer</span>, <span class="pl-c1">k</span>(<span class="pl-k">..</span>), <span class="pl-c1">z</span>(<span class="pl-k">..</span>), <span class="pl-c1">c</span>(<span class="pl-k">..</span>), <span class="pl-c1">q</span>(<span class="pl-k">..</span>)

x <span class="pl-k">=</span> [k, z] <span class="pl-c"><span class="pl-c">#</span> states</span>
y <span class="pl-k">=</span> [c, q] <span class="pl-c"><span class="pl-c">#</span> controls</span>
p <span class="pl-k">=</span> [α, β, ρ, δ, σ, Ω_1] <span class="pl-c"><span class="pl-c">#</span> parameters</span>

H <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-k">/</span> <span class="pl-c1">c</span>(t) <span class="pl-k">-</span> (β <span class="pl-k">/</span> <span class="pl-c1">c</span>(t <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">*</span> (α <span class="pl-k">*</span> <span class="pl-c1">exp</span>(<span class="pl-c1">z</span>(t <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">*</span> <span class="pl-c1">k</span>(t <span class="pl-k">+</span> <span class="pl-c1">1</span>)<span class="pl-k">^</span>(α <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">+</span> (<span class="pl-c1">1</span> <span class="pl-k">-</span> δ)),
     <span class="pl-c1">c</span>(t) <span class="pl-k">+</span> <span class="pl-c1">k</span>(t <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">-</span> (<span class="pl-c1">1</span> <span class="pl-k">-</span> δ) <span class="pl-k">*</span> <span class="pl-c1">k</span>(t) <span class="pl-k">-</span> <span class="pl-c1">q</span>(t),
     <span class="pl-c1">q</span>(t) <span class="pl-k">-</span> <span class="pl-c1">exp</span>(<span class="pl-c1">z</span>(t)) <span class="pl-k">*</span> <span class="pl-c1">k</span>(t)<span class="pl-k">^</span>α,
     <span class="pl-c1">z</span>(t <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">-</span> ρ <span class="pl-k">*</span> <span class="pl-c1">z</span>(t)]  <span class="pl-c"><span class="pl-c">#</span> system of model equations</span>

<span class="pl-c"><span class="pl-c">#</span> analytic solutions for the steady state.  Could pass initial values and run solver and use initial values with steady_states_iv</span>
steady_states <span class="pl-k">=</span> [<span class="pl-c1">k</span>(∞) <span class="pl-k">~</span> (((<span class="pl-c1">1</span> <span class="pl-k">/</span> β) <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> δ) <span class="pl-k">/</span> α)<span class="pl-k">^</span>(<span class="pl-c1">1</span> <span class="pl-k">/</span> (α <span class="pl-k">-</span> <span class="pl-c1">1</span>)),
                 <span class="pl-c1">z</span>(∞) <span class="pl-k">~</span> <span class="pl-c1">0</span>,
                 <span class="pl-c1">c</span>(∞) <span class="pl-k">~</span> (((<span class="pl-c1">1</span> <span class="pl-k">/</span> β) <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> δ) <span class="pl-k">/</span> α)<span class="pl-k">^</span>(α <span class="pl-k">/</span> (α <span class="pl-k">-</span> <span class="pl-c1">1</span>)) <span class="pl-k">-</span>
                        δ <span class="pl-k">*</span> (((<span class="pl-c1">1</span> <span class="pl-k">/</span> β) <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> δ) <span class="pl-k">/</span> α)<span class="pl-k">^</span>(<span class="pl-c1">1</span> <span class="pl-k">/</span> (α <span class="pl-k">-</span> <span class="pl-c1">1</span>)),
                 <span class="pl-c1">q</span>(∞) <span class="pl-k">~</span> (((<span class="pl-c1">1</span> <span class="pl-k">/</span> β) <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> δ) <span class="pl-k">/</span> α)<span class="pl-k">^</span>(α <span class="pl-k">/</span> (α <span class="pl-k">-</span> <span class="pl-c1">1</span>))]


Γ <span class="pl-k">=</span> [σ;;] <span class="pl-c"><span class="pl-c">#</span> matrix for the 1 shock.  The [;;] notation just makes it a matrix rather than vector in julia</span>
η <span class="pl-k">=</span> [<span class="pl-c1">0</span>; <span class="pl-k">-</span><span class="pl-c1">1</span>;;] <span class="pl-c"><span class="pl-c">#</span> η is n_x * n_ϵ matrix.  The [;; ]notation just makes it a matrix rather than vector in julia</span>

<span class="pl-c"><span class="pl-c">#</span> observation matrix.  order is "y" then "x" variables, so [c,q,k,z] in this example</span>
Q <span class="pl-k">=</span> [<span class="pl-c1">1.0</span> <span class="pl-c1">0</span>  <span class="pl-c1">0</span>   <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">#</span> select c as first "z" observable</span>
     <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-c1">1.0</span> <span class="pl-c1">0</span>] <span class="pl-c"><span class="pl-c">#</span> select k as second "z" observable</span>

<span class="pl-c"><span class="pl-c">#</span> diagonal cholesky of covariance matrix for observation noise (so these are standard deviations).  Non-diagonal observation noise not currently supported</span>
Ω <span class="pl-k">=</span> [Ω_1, Ω_1]

<span class="pl-c"><span class="pl-c">#</span> Generates the files and includes if required.  If the model is already created, then just loads</span>
overwrite_model_cache  <span class="pl-k">=</span> <span class="pl-c1">true</span>
model_rbc <span class="pl-k">=</span> <span class="pl-c1">@make_and_include_perturbation_model</span>(<span class="pl-s"><span class="pl-pds">"</span>rbc_notebook_example<span class="pl-pds">"</span></span>, H, (; t, y, x, p, steady_states, Γ, Ω, η, Q, overwrite_model_cache))</pre></div>
<p dir="auto">After generation of the model, they can be included as any other julia files in your code (e.g. <code>include(joinpath(pkgdir(DifferentiableStateSpaceModels), ".function_cache","my_model.jl"))</code>) or moved somewhere more convenient.</p>
<p dir="auto">Inclusion through the <code>@make_and_include_perturbation_model</code> creates the model automatically; after direct inclusion through a julia file, you can create a model with <code>m = PerturbationModel(Main.my_model)</code>.</p>
<h2 dir="auto">
<a id="user-content-solving-perturbations" class="anchor" aria-hidden="true" href="#solving-perturbations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Solving Perturbations</h2>
<p dir="auto">Assuming the above model was created and loaded in one way or another as <code>m</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="p_f = (ρ = 0.2, δ = 0.02, σ = 0.01, Ω_1 = 0.01) # Fixed parameters
p_d = (α = 0.5, β = 0.95) # Pseudo-true values
sol = generate_perturbation(model_rbc, p_d, p_f) # Solution to the first-order RBC
sol_2 = generate_perturbation(model_rbc, p_d, p_f, Val(2)); # Solution to the second-order RBC
@show sol.retcode, sol_2.retcode, verify_steady_state(m, p_d, p_f) # the final call checks that the analytically provided steady-state solution is correct"><pre>p_f <span class="pl-k">=</span> (ρ <span class="pl-k">=</span> <span class="pl-c1">0.2</span>, δ <span class="pl-k">=</span> <span class="pl-c1">0.02</span>, σ <span class="pl-k">=</span> <span class="pl-c1">0.01</span>, Ω_1 <span class="pl-k">=</span> <span class="pl-c1">0.01</span>) <span class="pl-c"><span class="pl-c">#</span> Fixed parameters</span>
p_d <span class="pl-k">=</span> (α <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, β <span class="pl-k">=</span> <span class="pl-c1">0.95</span>) <span class="pl-c"><span class="pl-c">#</span> Pseudo-true values</span>
sol <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(model_rbc, p_d, p_f) <span class="pl-c"><span class="pl-c">#</span> Solution to the first-order RBC</span>
sol_2 <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(model_rbc, p_d, p_f, <span class="pl-c1">Val</span>(<span class="pl-c1">2</span>)); <span class="pl-c"><span class="pl-c">#</span> Solution to the second-order RBC</span>
<span class="pl-c1">@show</span> sol<span class="pl-k">.</span>retcode, sol_2<span class="pl-k">.</span>retcode, <span class="pl-c1">verify_steady_state</span>(m, p_d, p_f) <span class="pl-c"><span class="pl-c">#</span> the final call checks that the analytically provided steady-state solution is correct</span></pre></div>
<p dir="auto">The perturbation solution (in the canonical form described in the top section) can be queried from the resulting solution.  A few examples for the first order solution are below,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@show sol.y, sol.x  # steady states y_ss and x_ss  These are the values such that y ≡ ŷ + sol.y and x ≡ x̂ + sol.x
@show sol.g_x # the policy
@show sol.A, sol.B # the evolution equation of the state, so that x̂' = A x̂ + B ϵ
@show sol.C, sol.D; # the evolution equation of the state, so that z = C x̂ + ν  with variance of ν as D D'.
@show sol.x_ergodic_var; # covariance matrix of the ergodic distribution of x̂, which is mean zero since x̂ ≡ x - x_ss"><pre><span class="pl-c1">@show</span> sol<span class="pl-k">.</span>y, sol<span class="pl-k">.</span>x  <span class="pl-c"><span class="pl-c">#</span> steady states y_ss and x_ss  These are the values such that y ≡ ŷ + sol.y and x ≡ x̂ + sol.x</span>
<span class="pl-c1">@show</span> sol<span class="pl-k">.</span>g_x <span class="pl-c"><span class="pl-c">#</span> the policy</span>
<span class="pl-c1">@show</span> sol<span class="pl-k">.</span>A, sol<span class="pl-k">.</span>B <span class="pl-c"><span class="pl-c">#</span> the evolution equation of the state, so that x̂' = A x̂ + B ϵ</span>
<span class="pl-c1">@show</span> sol<span class="pl-k">.</span>C, sol<span class="pl-k">.</span>D; <span class="pl-c"><span class="pl-c">#</span> the evolution equation of the state, so that z = C x̂ + ν  with variance of ν as D D'.</span>
<span class="pl-c1">@show</span> sol<span class="pl-k">.</span>x_ergodic_var; <span class="pl-c"><span class="pl-c">#</span> covariance matrix of the ergodic distribution of x̂, which is mean zero since x̂ ≡ x - x_ss</span></pre></div>
<h2 dir="auto">
<a id="user-content-functions-of-perturbation-solutions-and-their-derivatives" class="anchor" aria-hidden="true" href="#functions-of-perturbation-solutions-and-their-derivatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Functions of Perturbation Solutions (and their Derivatives)</h2>
<p dir="auto">The core feature of this library is to enable gradients of the perturbation solutions with respect to parameters (i.e., anything in the <code>p_d</code> vector).  To show this, we will construct a function which uses the resulting law of motion and finds the gradient of the results with respect to this value.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function IRF(p_d, ϵ_0; m, p_f, steps)
    sol = generate_perturbation(m, p_d, p_f) # First-order perturbation by default, pass Val(2) as additional argument to do 2nd order.
    x = sol.B * ϵ_0 # start after applying impulse with the model's shock η and Γ(p)
    for _ in 1:steps
        # A note: you cannot use mutating expressions here with most AD code.  i.e. x .= sol.A * x  wouldn't work
        # For more elaborate simuluations, you would want to use DifferenceEquations.jl in practice
        x = sol.A * x # iterate forward using first-order observation equation        
    end    
    return [0, 1]' * sol.C * x # choose the second observable using the model's C observation equation since first-order
end

m = model_rbc  # ensure notebook executed above
p_f = (ρ=0.2, δ=0.02, σ=0.01, Ω_1=0.01) # not differentiated 
p_d = (α=0.5, β=0.95) # different parameters
steps = 10 # steps ahead to forecast
ϵ_0 = [1.0] # shock size
IRF(p_d, ϵ_0; m, p_f, steps) # Function works on its own, calculating perturbation"><pre><span class="pl-k">function</span> <span class="pl-en">IRF</span>(p_d, ϵ_0; m, p_f, steps)
    sol <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(m, p_d, p_f) <span class="pl-c"><span class="pl-c">#</span> First-order perturbation by default, pass Val(2) as additional argument to do 2nd order.</span>
    x <span class="pl-k">=</span> sol<span class="pl-k">.</span>B <span class="pl-k">*</span> ϵ_0 <span class="pl-c"><span class="pl-c">#</span> start after applying impulse with the model's shock η and Γ(p)</span>
    <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>steps
        <span class="pl-c"><span class="pl-c">#</span> A note: you cannot use mutating expressions here with most AD code.  i.e. x .= sol.A * x  wouldn't work</span>
        <span class="pl-c"><span class="pl-c">#</span> For more elaborate simuluations, you would want to use DifferenceEquations.jl in practice</span>
        x <span class="pl-k">=</span> sol<span class="pl-k">.</span>A <span class="pl-k">*</span> x <span class="pl-c"><span class="pl-c">#</span> iterate forward using first-order observation equation        </span>
    <span class="pl-k">end</span>    
    <span class="pl-k">return</span> [<span class="pl-c1">0</span>, <span class="pl-c1">1</span>]<span class="pl-k">'</span> <span class="pl-k">*</span> sol<span class="pl-k">.</span>C <span class="pl-k">*</span> x <span class="pl-c"><span class="pl-c">#</span> choose the second observable using the model's C observation equation since first-order</span>
<span class="pl-k">end</span>

m <span class="pl-k">=</span> model_rbc  <span class="pl-c"><span class="pl-c">#</span> ensure notebook executed above</span>
p_f <span class="pl-k">=</span> (ρ<span class="pl-k">=</span><span class="pl-c1">0.2</span>, δ<span class="pl-k">=</span><span class="pl-c1">0.02</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.01</span>, Ω_1<span class="pl-k">=</span><span class="pl-c1">0.01</span>) <span class="pl-c"><span class="pl-c">#</span> not differentiated </span>
p_d <span class="pl-k">=</span> (α<span class="pl-k">=</span><span class="pl-c1">0.5</span>, β<span class="pl-k">=</span><span class="pl-c1">0.95</span>) <span class="pl-c"><span class="pl-c">#</span> different parameters</span>
steps <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-c"><span class="pl-c">#</span> steps ahead to forecast</span>
ϵ_0 <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>] <span class="pl-c"><span class="pl-c">#</span> shock size</span>
<span class="pl-c1">IRF</span>(p_d, ϵ_0; m, p_f, steps) <span class="pl-c"><span class="pl-c">#</span> Function works on its own, calculating perturbation</span></pre></div>
<h2 dir="auto">
<a id="user-content-derivatives-of-the-perturbation-solvers" class="anchor" aria-hidden="true" href="#derivatives-of-the-perturbation-solvers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Derivatives of the Perturbation Solvers</h2>
<p dir="auto">The perturbation solver fills a cache for values used for calculating derivatives.</p>
<p dir="auto">For example,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Zygote
function f(params; m, p_f)
    p_d = (α=params[1], β=params[2])  # Differentiated parameters
    sol = generate_perturbation(m, p_d, p_f) # Default is first-order.
    return sum(sol.A) # An ad-hoc example: reducing the law-of-motion matrix into one number
end

# To call it
m = PerturbationModel(Main.my_model)
p_f = (ρ=0.2, δ=0.02, σ=0.01, Ω_1=0.01)
param_val = [0.5, 0.95] # as a vector, but not required
display(f(param_val; m, p_f)) # Function works on its own, calculating perturbation
# Query the solution
@assert f(param_val; m, p_f) ≈ 7.366206154679124

# But you can also get its gradient with Zygote/etc.
display(gradient(params -&gt; f(params; m, p_f), param_val))
# Result check
gradient(params -&gt; f(params; m, p_f), param_val)[1] ≈ [61.41968376547458, 106.44095661062319]"><pre><span class="pl-k">using</span> Zygote
<span class="pl-k">function</span> <span class="pl-en">f</span>(params; m, p_f)
    p_d <span class="pl-k">=</span> (α<span class="pl-k">=</span>params[<span class="pl-c1">1</span>], β<span class="pl-k">=</span>params[<span class="pl-c1">2</span>])  <span class="pl-c"><span class="pl-c">#</span> Differentiated parameters</span>
    sol <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(m, p_d, p_f) <span class="pl-c"><span class="pl-c">#</span> Default is first-order.</span>
    <span class="pl-k">return</span> <span class="pl-c1">sum</span>(sol<span class="pl-k">.</span>A) <span class="pl-c"><span class="pl-c">#</span> An ad-hoc example: reducing the law-of-motion matrix into one number</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> To call it</span>
m <span class="pl-k">=</span> <span class="pl-c1">PerturbationModel</span>(Main<span class="pl-k">.</span>my_model)
p_f <span class="pl-k">=</span> (ρ<span class="pl-k">=</span><span class="pl-c1">0.2</span>, δ<span class="pl-k">=</span><span class="pl-c1">0.02</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.01</span>, Ω_1<span class="pl-k">=</span><span class="pl-c1">0.01</span>)
param_val <span class="pl-k">=</span> [<span class="pl-c1">0.5</span>, <span class="pl-c1">0.95</span>] <span class="pl-c"><span class="pl-c">#</span> as a vector, but not required</span>
<span class="pl-c1">display</span>(<span class="pl-c1">f</span>(param_val; m, p_f)) <span class="pl-c"><span class="pl-c">#</span> Function works on its own, calculating perturbation</span>
<span class="pl-c"><span class="pl-c">#</span> Query the solution</span>
<span class="pl-c1">@assert</span> <span class="pl-c1">f</span>(param_val; m, p_f) <span class="pl-k">≈</span> <span class="pl-c1">7.366206154679124</span>

<span class="pl-c"><span class="pl-c">#</span> But you can also get its gradient with Zygote/etc.</span>
<span class="pl-c1">display</span>(<span class="pl-c1">gradient</span>(params <span class="pl-k">-&gt;</span> <span class="pl-c1">f</span>(params; m, p_f), param_val))
<span class="pl-c"><span class="pl-c">#</span> Result check</span>
<span class="pl-c1">gradient</span>(params <span class="pl-k">-&gt;</span> <span class="pl-c1">f</span>(params; m, p_f), param_val)[<span class="pl-c1">1</span>] <span class="pl-k">≈</span> [<span class="pl-c1">61.41968376547458</span>, <span class="pl-c1">106.44095661062319</span>]</pre></div>
<p dir="auto">However, the real benefit is that this function can itself be differentiated, to find gradients with respect to the deep parameters <code>p_d</code> and the shock <code>ϵ_0</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Using the Zygote auto-differentiation library already loaded above
p_d = (α=0.5, β=0.95) # different parameters
ϵ_0 = [1.0] # shock size
IRF_grad = gradient((p_d, ϵ_0) -&gt; IRF(p_d, ϵ_0; m, p_f, steps), p_d, ϵ_0) # &quot;closes&quot; over the m, p_f, and steps to create a new function, and differentiates it with respect to other arguments"><pre><span class="pl-c"><span class="pl-c">#</span> Using the Zygote auto-differentiation library already loaded above</span>
p_d <span class="pl-k">=</span> (α<span class="pl-k">=</span><span class="pl-c1">0.5</span>, β<span class="pl-k">=</span><span class="pl-c1">0.95</span>) <span class="pl-c"><span class="pl-c">#</span> different parameters</span>
ϵ_0 <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>] <span class="pl-c"><span class="pl-c">#</span> shock size</span>
IRF_grad <span class="pl-k">=</span> <span class="pl-c1">gradient</span>((p_d, ϵ_0) <span class="pl-k">-&gt;</span> <span class="pl-c1">IRF</span>(p_d, ϵ_0; m, p_f, steps), p_d, ϵ_0) <span class="pl-c"><span class="pl-c">#</span> "closes" over the m, p_f, and steps to create a new function, and differentiates it with respect to other arguments</span></pre></div>
<h2 dir="auto">
<a id="user-content-simulating-data-with-differenceequations" class="anchor" aria-hidden="true" href="#simulating-data-with-differenceequations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simulating Data with DifferenceEquations</h2>
<h2 dir="auto">
<a id="user-content-simulating-with-differenceequationsjl" class="anchor" aria-hidden="true" href="#simulating-with-differenceequationsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simulating with DifferenceEquations.jl</h2>
<p dir="auto">The manual iteration of the state-space model from the perturbation solution is possible, but can be verbose and difficult to achieve efficiency for gradients.  One benefit of this package is that it creates state-space models in a form consistent with <a href="https://github.com/SciML/DifferenceEquations.jl">DifferenceEquations.jl</a> which can be easily simulated, visualized, and estimated.</p>
<p dir="auto">To do this, we will calculate a perturbation solution then simulate it for various <code>x_0</code> drawn from the ergodic solution.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="p_f = (ρ = 0.2, δ = 0.02, σ = 0.01, Ω_1 = 0.01) # Fixed parameters
p_d = (α = 0.5, β = 0.95) # Pseudo-true values
m = model_rbc  # ensure notebook executed above
sol = generate_perturbation(m, p_d, p_f) # Solution to the first-order RBC

# Simulate T observations from a random initial condition
T = 20

# draw from ergodic distribution for the initial condition
x_iv = MvNormal(sol.x_ergodic_var)
problem = LinearStateSpaceProblem(sol, x_iv, (0, T))
plot(solve(problem))"><pre>p_f <span class="pl-k">=</span> (ρ <span class="pl-k">=</span> <span class="pl-c1">0.2</span>, δ <span class="pl-k">=</span> <span class="pl-c1">0.02</span>, σ <span class="pl-k">=</span> <span class="pl-c1">0.01</span>, Ω_1 <span class="pl-k">=</span> <span class="pl-c1">0.01</span>) <span class="pl-c"><span class="pl-c">#</span> Fixed parameters</span>
p_d <span class="pl-k">=</span> (α <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, β <span class="pl-k">=</span> <span class="pl-c1">0.95</span>) <span class="pl-c"><span class="pl-c">#</span> Pseudo-true values</span>
m <span class="pl-k">=</span> model_rbc  <span class="pl-c"><span class="pl-c">#</span> ensure notebook executed above</span>
sol <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(m, p_d, p_f) <span class="pl-c"><span class="pl-c">#</span> Solution to the first-order RBC</span>

<span class="pl-c"><span class="pl-c">#</span> Simulate T observations from a random initial condition</span>
T <span class="pl-k">=</span> <span class="pl-c1">20</span>

<span class="pl-c"><span class="pl-c">#</span> draw from ergodic distribution for the initial condition</span>
x_iv <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(sol<span class="pl-k">.</span>x_ergodic_var)
problem <span class="pl-k">=</span> <span class="pl-c1">LinearStateSpaceProblem</span>(sol, x_iv, (<span class="pl-c1">0</span>, T))
<span class="pl-c1">plot</span>(<span class="pl-c1">solve</span>(problem))</pre></div>
<p dir="auto">The <code>LinearStateSpaceProblem</code> type is automatically constructed from the underlying perturbation.  However, we can override any of these options, or pass in our own noise rather than simulate it for a particular experiment</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="noise = Matrix([1.0; zeros(T-1)]') # the ϵ shocks are &quot;noise&quot; in DifferenceEquations for SciML compatibility
x_iv = [0.0, 0.0]  # can pass in a single value rather than a distribution 
problem = LinearStateSpaceProblem(sol, x_iv, (0, T); noise)
plot(solve(problem))"><pre>noise <span class="pl-k">=</span> <span class="pl-c1">Matrix</span>([<span class="pl-c1">1.0</span>; <span class="pl-c1">zeros</span>(T<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">'</span>) <span class="pl-c"><span class="pl-c">#</span> the ϵ shocks are "noise" in DifferenceEquations for SciML compatibility</span>
x_iv <span class="pl-k">=</span> [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>]  <span class="pl-c"><span class="pl-c">#</span> can pass in a single value rather than a distribution </span>
problem <span class="pl-k">=</span> <span class="pl-c1">LinearStateSpaceProblem</span>(sol, x_iv, (<span class="pl-c1">0</span>, T); noise)
<span class="pl-c1">plot</span>(<span class="pl-c1">solve</span>(problem))</pre></div>
<p dir="auto">To demonstrate the composition of gradients between DifferenceEquations and DifferentiableStateSpaceModels lets adapt this function to simulates an impulse with fixed noise and looks at the final observable</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function last_observable(p_d, noise, x_iv; m, p_f, T)
    sol = generate_perturbation(m, p_d, p_f)
    problem = LinearStateSpaceProblem(sol, x_iv, (0, T);noise, observables_noise = nothing)  # removing observation noise
    return solve(problem).z[end][2]  # return 2nd argument of last observable
end
T = 100
noise = Matrix([1.0; zeros(T-1)]') # the ϵ shocks are &quot;noise&quot; in DifferenceEquations for SciML compatibility
x_iv = [0.0, 0.0]  # can pass in a single value rather than a distribution
p_f = (ρ = 0.2, δ = 0.02, σ = 0.01, Ω_1 = 0.01) # Fixed parameters
p_d = (α = 0.5, β = 0.95) # Pseudo-true values
m = model_rbc  # ensure notebook executed above
last_observable(p_d, noise, x_iv; m, p_f, T)"><pre><span class="pl-k">function</span> <span class="pl-en">last_observable</span>(p_d, noise, x_iv; m, p_f, T)
    sol <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(m, p_d, p_f)
    problem <span class="pl-k">=</span> <span class="pl-c1">LinearStateSpaceProblem</span>(sol, x_iv, (<span class="pl-c1">0</span>, T);noise, observables_noise <span class="pl-k">=</span> <span class="pl-c1">nothing</span>)  <span class="pl-c"><span class="pl-c">#</span> removing observation noise</span>
    <span class="pl-k">return</span> <span class="pl-c1">solve</span>(problem)<span class="pl-k">.</span>z[<span class="pl-c1">end</span>][<span class="pl-c1">2</span>]  <span class="pl-c"><span class="pl-c">#</span> return 2nd argument of last observable</span>
<span class="pl-k">end</span>
T <span class="pl-k">=</span> <span class="pl-c1">100</span>
noise <span class="pl-k">=</span> <span class="pl-c1">Matrix</span>([<span class="pl-c1">1.0</span>; <span class="pl-c1">zeros</span>(T<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">'</span>) <span class="pl-c"><span class="pl-c">#</span> the ϵ shocks are "noise" in DifferenceEquations for SciML compatibility</span>
x_iv <span class="pl-k">=</span> [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>]  <span class="pl-c"><span class="pl-c">#</span> can pass in a single value rather than a distribution</span>
p_f <span class="pl-k">=</span> (ρ <span class="pl-k">=</span> <span class="pl-c1">0.2</span>, δ <span class="pl-k">=</span> <span class="pl-c1">0.02</span>, σ <span class="pl-k">=</span> <span class="pl-c1">0.01</span>, Ω_1 <span class="pl-k">=</span> <span class="pl-c1">0.01</span>) <span class="pl-c"><span class="pl-c">#</span> Fixed parameters</span>
p_d <span class="pl-k">=</span> (α <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, β <span class="pl-k">=</span> <span class="pl-c1">0.95</span>) <span class="pl-c"><span class="pl-c">#</span> Pseudo-true values</span>
m <span class="pl-k">=</span> model_rbc  <span class="pl-c"><span class="pl-c">#</span> ensure notebook executed above</span>
<span class="pl-c1">last_observable</span>(p_d, noise, x_iv; m, p_f, T)</pre></div>
<p dir="auto">And, as before, we can calculate gradients with respect to the underlying <code>p_d</code> parameters, but also with respect to the noise which will demonstrate a key benefit of these methods, as they can let us do a joint likelihood of the latent variables in cases where they cannot be easily marginalized out (e.g., non-Gaussian or nonlinear).  Note that the dimensionality of this gradient is over 100.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="gradient((p_d, noise, x_iv) -&gt; last_observable(p_d, noise, x_iv; m, p_f, T), p_d, noise, x_iv)"><pre><span class="pl-c1">gradient</span>((p_d, noise, x_iv) <span class="pl-k">-&gt;</span> <span class="pl-c1">last_observable</span>(p_d, noise, x_iv; m, p_f, T), p_d, noise, x_iv)</pre></div>
<p dir="auto">Finally, we can use a simple utility functions to investigate an IRF.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="p_f = (ρ = 0.2, δ = 0.02, σ = 0.01, Ω_1 = 0.01) # Fixed parameters
p_d = (α = 0.5, β = 0.95) # Pseudo-true values
m = model_rbc
sol = generate_perturbation(model_rbc, p_d, p_f)
ϵ0 = [1.0]
T = 10
sim = irf(sol, ϵ0, T)
plot(sim)"><pre>p_f <span class="pl-k">=</span> (ρ <span class="pl-k">=</span> <span class="pl-c1">0.2</span>, δ <span class="pl-k">=</span> <span class="pl-c1">0.02</span>, σ <span class="pl-k">=</span> <span class="pl-c1">0.01</span>, Ω_1 <span class="pl-k">=</span> <span class="pl-c1">0.01</span>) <span class="pl-c"><span class="pl-c">#</span> Fixed parameters</span>
p_d <span class="pl-k">=</span> (α <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, β <span class="pl-k">=</span> <span class="pl-c1">0.95</span>) <span class="pl-c"><span class="pl-c">#</span> Pseudo-true values</span>
m <span class="pl-k">=</span> model_rbc
sol <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(model_rbc, p_d, p_f)
ϵ0 <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>]
T <span class="pl-k">=</span> <span class="pl-c1">10</span>
sim <span class="pl-k">=</span> <span class="pl-c1">irf</span>(sol, ϵ0, T)
<span class="pl-c1">plot</span>(sim)</pre></div>
<h2 dir="auto">
<a id="user-content-sneak-peak-at-sciml-compatible-functionality" class="anchor" aria-hidden="true" href="#sneak-peak-at-sciml-compatible-functionality"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sneak Peak at SciML Compatible Functionality</h2>
<p dir="auto">Finally, there are a variety of features of SciML which are supported.  For example, parallel simulations of ensembles and associated summary statistics.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Simulate multiple trajectories with T observations
trajectories = 40
x_iv = MvNormal(sol.x_ergodic_var)
problem = LinearStateSpaceProblem(sol, x_iv, (0, T))

# Solve multiple trajectories and plot an ensemble
ensemble_results = solve(EnsembleProblem(problem), DirectIteration(), EnsembleThreads();
                 trajectories)
summ = EnsembleSummary(ensemble_results)  # see SciML documentation.  Calculates median and other quantles automatically.
summ.med # median values for the &quot;x&quot; simulated ensembles

plot(summ, fillalpha= 0.2) # plots by default show the median and quantiles of both variables.  Modifying transparency as an example"><pre><span class="pl-c"><span class="pl-c">#</span> Simulate multiple trajectories with T observations</span>
trajectories <span class="pl-k">=</span> <span class="pl-c1">40</span>
x_iv <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(sol<span class="pl-k">.</span>x_ergodic_var)
problem <span class="pl-k">=</span> <span class="pl-c1">LinearStateSpaceProblem</span>(sol, x_iv, (<span class="pl-c1">0</span>, T))

<span class="pl-c"><span class="pl-c">#</span> Solve multiple trajectories and plot an ensemble</span>
ensemble_results <span class="pl-k">=</span> <span class="pl-c1">solve</span>(<span class="pl-c1">EnsembleProblem</span>(problem), <span class="pl-c1">DirectIteration</span>(), <span class="pl-c1">EnsembleThreads</span>();
                 trajectories)
summ <span class="pl-k">=</span> <span class="pl-c1">EnsembleSummary</span>(ensemble_results)  <span class="pl-c"><span class="pl-c">#</span> see SciML documentation.  Calculates median and other quantles automatically.</span>
summ<span class="pl-k">.</span>med <span class="pl-c"><span class="pl-c">#</span> median values for the "x" simulated ensembles</span>

<span class="pl-c1">plot</span>(summ, fillalpha<span class="pl-k">=</span> <span class="pl-c1">0.2</span>) <span class="pl-c"><span class="pl-c">#</span> plots by default show the median and quantiles of both variables.  Modifying transparency as an example</span></pre></div>
<h2 dir="auto">
<a id="user-content-calculate-sequence-of-observables" class="anchor" aria-hidden="true" href="#calculate-sequence-of-observables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calculate sequence of observables</h2>
<p dir="auto">We can use the underlying state-space model to easily simulate states and observables</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Simulate T observations
T = 20

p_f = (ρ = 0.2, δ = 0.02, σ = 0.01, Ω_1 = 0.01) # Fixed parameters
p_d = (α = 0.5, β = 0.95) # Pseudo-true values
sol = generate_perturbation(model_rbc, p_d, p_f) # Solution to the first-order RBC

x_iv = MvNormal(sol.x_ergodic_var) # draw initial conditions from the ergodic distribution
problem = LinearStateSpaceProblem(sol, x_iv, (0, T))
sim = solve(problem, DirectIteration())
ϵ = sim.W # store the underlying noise in the simulation

# Collapse to simulated observables as a matrix  - as required by current DifferenceEquations.jl likelihood
# see https://github.com/SciML/DifferenceEquations.jl/issues/55 for direct support of this datastructure
z_rbc = hcat(sim.z...) "><pre><span class="pl-c"><span class="pl-c">#</span> Simulate T observations</span>
T <span class="pl-k">=</span> <span class="pl-c1">20</span>

p_f <span class="pl-k">=</span> (ρ <span class="pl-k">=</span> <span class="pl-c1">0.2</span>, δ <span class="pl-k">=</span> <span class="pl-c1">0.02</span>, σ <span class="pl-k">=</span> <span class="pl-c1">0.01</span>, Ω_1 <span class="pl-k">=</span> <span class="pl-c1">0.01</span>) <span class="pl-c"><span class="pl-c">#</span> Fixed parameters</span>
p_d <span class="pl-k">=</span> (α <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, β <span class="pl-k">=</span> <span class="pl-c1">0.95</span>) <span class="pl-c"><span class="pl-c">#</span> Pseudo-true values</span>
sol <span class="pl-k">=</span> <span class="pl-c1">generate_perturbation</span>(model_rbc, p_d, p_f) <span class="pl-c"><span class="pl-c">#</span> Solution to the first-order RBC</span>

x_iv <span class="pl-k">=</span> <span class="pl-c1">MvNormal</span>(sol<span class="pl-k">.</span>x_ergodic_var) <span class="pl-c"><span class="pl-c">#</span> draw initial conditions from the ergodic distribution</span>
problem <span class="pl-k">=</span> <span class="pl-c1">LinearStateSpaceProblem</span>(sol, x_iv, (<span class="pl-c1">0</span>, T))
sim <span class="pl-k">=</span> <span class="pl-c1">solve</span>(problem, <span class="pl-c1">DirectIteration</span>())
ϵ <span class="pl-k">=</span> sim<span class="pl-k">.</span>W <span class="pl-c"><span class="pl-c">#</span> store the underlying noise in the simulation</span>

<span class="pl-c"><span class="pl-c">#</span> Collapse to simulated observables as a matrix  - as required by current DifferenceEquations.jl likelihood</span>
<span class="pl-c"><span class="pl-c">#</span> see https://github.com/SciML/DifferenceEquations.jl/issues/55 for direct support of this datastructure</span>
z_rbc <span class="pl-k">=</span> <span class="pl-c1">hcat</span>(sim<span class="pl-k">.</span>z<span class="pl-k">...</span>) </pre></div>
</article></div>