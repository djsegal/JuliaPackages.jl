<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-radialbasisfunctionmodels" class="anchor" aria-hidden="true" href="#radialbasisfunctionmodels"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>RadialBasisFunctionModels</h1>
<p dir="auto"><a href="https://manuelbb-upb.github.io/RadialBasisFunctionModels.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://manuelbb-upb.github.io/RadialBasisFunctionModels.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/manuelbb-upb/RadialBasisFunctionModels.jl/actions"><img src="https://github.com/manuelbb-upb/RadialBasisFunctionModels.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/manuelbb-upb/RadialBasisFunctionModels.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/352e48b7c7e51d383f567d574aed7dbaaa8bf94cc5eda0c4226eeaa0aa11437b/68747470733a2f2f636f6465636f762e696f2f67682f6d616e75656c62622d7570622f52616469616c426173697346756e6374696f6e4d6f64656c732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/manuelbb-upb/RadialBasisFunctionModels.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-description" class="anchor" aria-hidden="true" href="#description"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Description</h1>
<p dir="auto">This package provides Radial Basis Function (RBF) models with polynomial tails.
RBF models are a special case of kernel machines that can interpolate high-dimensional
and nonlinear data.</p>
<h1 dir="auto"><a id="user-content-usage-examples" class="anchor" aria-hidden="true" href="#usage-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage Examples</h1>
<p dir="auto">First load the <code>RadialBasisFunctionModels</code> package.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using RadialBasisFunctionModels"><pre><span class="pl-k">using</span> RadialBasisFunctionModels</pre></div>
<h2 dir="auto"><a id="user-content-interpolating-rbf-model" class="anchor" aria-hidden="true" href="#interpolating-rbf-model"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interpolating RBF Model</h2>
<h3 dir="auto"><a id="user-content-one-dimensional-data" class="anchor" aria-hidden="true" href="#one-dimensional-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>One dimensional data</h3>
<p dir="auto">The main type <code>RBFModel</code> uses vectors internally, but we can easily
interpolate 1-dimensional data.
Assume, e.g., we want to interpolate <code>f:ℝ → ℝ, f(x) = x^2</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f = x -&gt; x^2"><pre>f <span class="pl-k">=</span> x <span class="pl-k">-&gt;</span> x<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<p dir="auto">Define 5 training sites <code>X</code> and evaluate to get <code>Y</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X = collect( LinRange(-4,4,5) )
Y = f.(X)"><pre>X <span class="pl-k">=</span> <span class="pl-c1">collect</span>( <span class="pl-c1">LinRange</span>(<span class="pl-k">-</span><span class="pl-c1">4</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>) )
Y <span class="pl-k">=</span> <span class="pl-c1">f</span>.(X)</pre></div>
<p dir="auto">Initialize the <code>RadialFunction</code> to use for the RBF model:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="φ = Multiquadric()"><pre>φ <span class="pl-k">=</span> <span class="pl-c1">Multiquadric</span>()</pre></div>
<p dir="auto">Construct an interpolating model with linear polynomial tail:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="rbf = RBFModel( X, Y, φ, 1)"><pre>rbf <span class="pl-k">=</span> <span class="pl-c1">RBFModel</span>( X, Y, φ, <span class="pl-c1">1</span>)</pre></div>
<p dir="auto">We can evaluate <code>rbf</code> at the data points;
By default, vectors are returned.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Z = rbf.(X)"><pre>Z <span class="pl-k">=</span> <span class="pl-c1">rbf</span>.(X)</pre></div>
<p dir="auto">Now</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Z isa Vector"><pre>Z <span class="pl-k">isa</span> Vector</pre></div>
<p dir="auto">and</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Z[1] isa AbstractVector{&lt;:Real}"><pre>Z[<span class="pl-c1">1</span>] <span class="pl-k">isa</span> AbstractVector{<span class="pl-k">&lt;:</span><span class="pl-c1">Real</span>}</pre></div>
<p dir="auto">The results should be close to the data labels <code>Y</code>, i.e., <code>Z[1] ≈ Y[1]</code> etc.</p>
<p dir="auto"><code>X</code> contains Floats, but we can pass them to <code>rbf</code>.
Usually you have feature vectors and they are always supported:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@test rbf( [ X[1], ] ) == Z[1]"><pre><span class="pl-c1">@test</span> <span class="pl-c1">rbf</span>( [ X[<span class="pl-c1">1</span>], ] ) <span class="pl-k">==</span> Z[<span class="pl-c1">1</span>]</pre></div>
<p dir="auto">For 1 dimensional labels we can actually disable the vector output:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="rbf_scalar = RBFInterpolationModel( X, Y, φ, 1; vector_output = false)
Z_scalar = rbf_scalar.( X )

Z_scalar isa Vector{Float64}
all( Z_scalar[i] == Z[i][1] for i = 1 : length(Z) )"><pre>rbf_scalar <span class="pl-k">=</span> <span class="pl-c1">RBFInterpolationModel</span>( X, Y, φ, <span class="pl-c1">1</span>; vector_output <span class="pl-k">=</span> <span class="pl-c1">false</span>)
Z_scalar <span class="pl-k">=</span> <span class="pl-c1">rbf_scalar</span>.( X )

Z_scalar <span class="pl-k">isa</span> Vector{Float64}
<span class="pl-c1">all</span>( Z_scalar[i] <span class="pl-k">==</span> Z[i][<span class="pl-c1">1</span>] <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">length</span>(Z) )</pre></div>
<p dir="auto">The data precision of the training data is preserved when determining the model
coefficients.
Accordingly, the return type precision is also at least that of the training data.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X_f0 = Float32.(X)
Y_f0 = f.(X_f0)
rbf_f0 = RBFInterpolationModel( X_f0, Y_f0, φ, 1)
rbf_f0.(X_f0) isa Vector{Vector{Float32}}"><pre>X_f0 <span class="pl-k">=</span> <span class="pl-c1">Float32</span>.(X)
Y_f0 <span class="pl-k">=</span> <span class="pl-c1">f</span>.(X_f0)
rbf_f0 <span class="pl-k">=</span> <span class="pl-c1">RBFInterpolationModel</span>( X_f0, Y_f0, φ, <span class="pl-c1">1</span>)
<span class="pl-c1">rbf_f0</span>.(X_f0) <span class="pl-k">isa</span> Vector{Vector{Float32}}</pre></div>
<p dir="auto">If you are using statically sized arrays, they work too!
You can provide a vector of statically sized arrays or, if
you have only few centers ( number of variables × number of centers &lt;= 100),
provide a statically sized vector of statically sized vectors to maybe profit
from faster matrix multiplications when evaluating:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using StaticArrays
features = [ @SVector(rand(3)) for i = 1 : 5 ]
labels = [ @SVector(rand(3)) for i = 1 : 5 ]
centers = SVector{5}(features)
rbf_sized = RBFModel( features, labels; centers )"><pre><span class="pl-k">using</span> StaticArrays
features <span class="pl-k">=</span> [ <span class="pl-c1">@SVector</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">5</span> ]
labels <span class="pl-k">=</span> [ <span class="pl-c1">@SVector</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">5</span> ]
centers <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{5}</span>(features)
rbf_sized <span class="pl-k">=</span> <span class="pl-c1">RBFModel</span>( features, labels; centers )</pre></div>
<p dir="auto">Now, the model uses sized matrices internally.
For most input vectors a <code>SizedVector</code> would be returned.
But there is a "type guarding" function for static arrays so that output has the same
array type (by conversion, if necessary):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x_vec = rand(3)
x_s = SVector{3}(x_vec)
x_m = MVector{3}(x_vec)
x_sized = SizedVector{3}(x_vec)

rbf_sized( x_vec ) isa Vector
rbf_sized( x_s ) isa SVector
rbf_sized( x_m ) isa MVector
rbf_sized( x_sized ) isa SizedVector"><pre>x_vec <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)
x_s <span class="pl-k">=</span> <span class="pl-c1">SVector</span><span class="pl-c1">{3}</span>(x_vec)
x_m <span class="pl-k">=</span> <span class="pl-c1">MVector</span><span class="pl-c1">{3}</span>(x_vec)
x_sized <span class="pl-k">=</span> <span class="pl-c1">SizedVector</span><span class="pl-c1">{3}</span>(x_vec)

<span class="pl-c1">rbf_sized</span>( x_vec ) <span class="pl-k">isa</span> Vector
<span class="pl-c1">rbf_sized</span>( x_s ) <span class="pl-k">isa</span> SVector
<span class="pl-c1">rbf_sized</span>( x_m ) <span class="pl-k">isa</span> MVector
<span class="pl-c1">rbf_sized</span>( x_sized ) <span class="pl-k">isa</span> SizedVector</pre></div>
<h3 dir="auto"><a id="user-content-using-kernel-names" class="anchor" aria-hidden="true" href="#using-kernel-names"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using Kernel Names</h3>
<p dir="auto">Instead of initializing <code>RadialFunction</code>s beforehand,
their names can be used. Currently supported are:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content=":gaussian, :multiquadric, :inv_multiquadric, :cubic, :thin_plate_spline"><pre class="notranslate"><code>:gaussian, :multiquadric, :inv_multiquadric, :cubic, :thin_plate_spline
</code></pre></div>
<p dir="auto">You can do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="RBFModel(features, labels, :gaussian)"><pre><span class="pl-c1">RBFModel</span>(features, labels, <span class="pl-c1">:gaussian</span>)</pre></div>
<p dir="auto">or, to specify kernel arguments:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="RBFModel(features, labels, :multiquadric, [1.0, 1//2])"><pre><span class="pl-c1">RBFModel</span>(features, labels, <span class="pl-c1">:multiquadric</span>, [<span class="pl-c1">1.0</span>, <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>])</pre></div>
<h2 dir="auto"><a id="user-content-machines" class="anchor" aria-hidden="true" href="#machines"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Machines</h2>
<p dir="auto">There is an MLJ wrapper for the RBFInterpolationModel, exported as <code>RBFInterpolator</code>.
It can be used like other regressors and takes the kernel name as a symbol (and kernel arguments as a vector).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MLJBase
X,y = @load_boston

r = RBFInterpolator(; kernel_name = :multiquadric )
R = machine(r, X, y)

MLJBase.fit!(R)
MLJBase.predict(R, X)"><pre><span class="pl-k">using</span> MLJBase
X,y <span class="pl-k">=</span> <span class="pl-c1">@load_boston</span>

r <span class="pl-k">=</span> <span class="pl-c1">RBFInterpolator</span>(; kernel_name <span class="pl-k">=</span> <span class="pl-c1">:multiquadric</span> )
R <span class="pl-k">=</span> <span class="pl-c1">machine</span>(r, X, y)

MLJBase<span class="pl-k">.</span><span class="pl-c1">fit!</span>(R)
MLJBase<span class="pl-k">.</span><span class="pl-c1">predict</span>(R, X)</pre></div>
<p dir="auto">You can do similar things (for vector valued data) with the <code>RBFMachineWithKernel</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X = [ rand(2) for i = 1 : 10 ]
Y = [ rand(2) for i = 1 : 10 ]

R = RBFMachine(;features = X, labels = Y, kernel_name = :gaussian )
R isa RBFMachineWithKernel
RadialBasisFunctionModels.fit!(R)
R( X[1] ) ≈ Y[1]"><pre>X <span class="pl-k">=</span> [ <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">10</span> ]
Y <span class="pl-k">=</span> [ <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">10</span> ]

R <span class="pl-k">=</span> <span class="pl-c1">RBFMachine</span>(;features <span class="pl-k">=</span> X, labels <span class="pl-k">=</span> Y, kernel_name <span class="pl-k">=</span> <span class="pl-c1">:gaussian</span> )
R <span class="pl-k">isa</span> RBFMachineWithKernel
RadialBasisFunctionModels<span class="pl-k">.</span><span class="pl-c1">fit!</span>(R)
<span class="pl-c1">R</span>( X[<span class="pl-c1">1</span>] ) <span class="pl-k">≈</span> Y[<span class="pl-c1">1</span>]</pre></div>
<p dir="auto">Such a machine can be initialized empty and data can be added:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="R = RBFMachine()
add_data!(R, X, Y)"><pre>R <span class="pl-k">=</span> <span class="pl-c1">RBFMachine</span>()
<span class="pl-c1">add_data!</span>(R, X, Y)</pre></div>
<hr>
<p dir="auto"><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p>
</article></div>