<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><p><a href="https://travis-ci.com/MasonProtter/Symbolics.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/96a5018bc4437d6855ee808cfab4a5a9020e982d/68747470733a2f2f7472617669732d63692e636f6d2f4d61736f6e50726f747465722f53796d626f6c6963732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/MasonProtter/Symbolics.jl.svg?branch=master" style="max-width:100%;"></a> <a href="https://ci.appveyor.com/project/MasonProtter/symbolics-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/13e11370e203b7740b74760ac67554fb7007a6f7/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f646d74687978356872367564616374322f6272616e63682f6d61737465723f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/dmthyx5hr6udact2/branch/master?svg=true" style="max-width:100%;"></a> <a href="https://codecov.io/gh/MasonProtter/Symbolics.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e3b3c07301b1acfd48a3aa38e9eec54c6e687ec1/68747470733a2f2f636f6465636f762e696f2f67682f4d61736f6e50726f747465722f53796d626f6c6963732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/MasonProtter/Symbolics.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<h1><a id="user-content-symbolicsjl" class="anchor" aria-hidden="true" href="#symbolicsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Symbolics.jl</h1>
<p>This is a package I'm throwing together after getting inspired by the talk <a href="https://www.youtube.com/watch?v=7PoajCqNKpg" rel="nofollow">Physics in Clojure</a> which was about porting scmutils to clojure. scmutils is a Scheme package with a very interesting and powerful computer algebra system meant as a companion to the book <a href="https://mitpress.mit.edu/books/structure-and-interpretation-classical-mechanics-second-edition" rel="nofollow">Structure and Interpretation of Classical Mechanics</a>.</p>
<p>My intention with Symbolics.jl is to attempt to recreate the functionality of scmutils in julia using julian syntax. The package is slowly morphing into some sort of hybrid between scmutils and Mathematica.</p>
<p>This package works on Julia 1.0. To add it, simply</p>
<pre><code>pkg&gt; add https://github.com/MasonProtter/Symbolics.jl
</code></pre>
<p>Note: This package is very much a work in progress! Don't rely on it for <em>anything</em> important.</p>
<p>Examples of use:</p>
<ol>
<li>Basic algebra</li>
</ol>
<div class="highlight highlight-source-julia"><pre>julia <span class="pl-k">&gt;</span> <span class="pl-k">using</span> Symbolics

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@sym</span> x y z t;

julia<span class="pl-k">&gt;</span> x<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> x<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-c1">2</span> <span class="pl-k">*</span> x <span class="pl-k">^</span> <span class="pl-c1">2</span></pre></div>
<ol start="2">
<li>You can replace symbols in expressions</li>
</ol>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> ex <span class="pl-k">=</span> <span class="pl-c1">2</span>x <span class="pl-k">+</span> x<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-c1">2</span>x <span class="pl-k">+</span> x<span class="pl-k">^</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ex</span>(x <span class="pl-k">=&gt;</span> y)
<span class="pl-c1">2</span>y <span class="pl-k">+</span> y<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<ol start="3">
<li>functional composition</li>
</ol>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">f</span>(x) <span class="pl-k">=</span> x<span class="pl-k">^</span><span class="pl-c1">3</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-en">g</span>(x) <span class="pl-k">=</span> x<span class="pl-k">^</span><span class="pl-c1">2</span>;

julia<span class="pl-k">&gt;</span> f <span class="pl-k">+</span> g
(<span class="pl-k">::</span><span class="pl-c"><span class="pl-c">#</span>70) (generic function with 1 method)</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ans</span>(x)
x <span class="pl-k">^</span> <span class="pl-c1">3</span> <span class="pl-k">+</span> x <span class="pl-k">^</span> <span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> f <span class="pl-k">*</span> g
(<span class="pl-k">::</span><span class="pl-c"><span class="pl-c">#</span>72) (generic function with 1 method)</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ans</span>(x)
x <span class="pl-k">^</span> <span class="pl-c1">5</span></pre></div>
<ol start="4">
<li>(Automatic) symbolic differentiation, now with higher derivatives and no pertubration confusion!</li>
</ol>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">D</span>(f<span class="pl-k">+</span>g)(x)
<span class="pl-c1">3</span> <span class="pl-k">*</span> x <span class="pl-k">^</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">2</span>x

julia<span class="pl-k">&gt;</span> (D<span class="pl-k">^</span><span class="pl-c1">2</span>)(f<span class="pl-k">+</span>g)(x)
<span class="pl-c1">3</span> <span class="pl-k">*</span> (<span class="pl-c1">2</span>x) <span class="pl-k">+</span> <span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> (D<span class="pl-k">^</span><span class="pl-c1">3</span>)(f<span class="pl-k">+</span>g)(x)
<span class="pl-c1">6</span></pre></div>
<p>The derivative operator, <code>D</code> is of type <code>Dtype &lt;: Operator &lt;: Function</code>. The reason for this is because operations on functions should sometimes behave differently than operations on differential operators. Currently the only difference is in exponentiation, such that <code>:^(f::Function, n) = x -&gt; f(x)^n</code> whereas <code>:^(o::Operator,n::Integer) = x -&gt; o(o( ... o(x)))</code> where the operator <code>o</code> has been applied to <code>x</code> <code>n</code> times.</p>
<ol start="5">
<li>Symbolic expressions are callable and can be differentiated</li>
</ol>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">D</span>(<span class="pl-c1">x</span>(t)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-c1">x</span>(t), t)
<span class="pl-c1">2</span> <span class="pl-k">*</span> (x)(t) <span class="pl-k">*</span> (<span class="pl-c1">D</span>(x))(t) <span class="pl-k">+</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> (<span class="pl-c1">D</span>(x))(t)</pre></div>
<h1><a id="user-content-new-generate-the-euler-lagrange-equations-from-a-lagrangian" class="anchor" aria-hidden="true" href="#new-generate-the-euler-lagrange-equations-from-a-lagrangian"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>New: Generate the Euler Lagrange Equations from a Lagrangian</h1>
<p>We can now define a Lagrangian, say that of a simple harmonic oscillator as</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Symbolics

<span class="pl-c1">@sym</span> x m ω t

<span class="pl-k">function</span> <span class="pl-en">L</span>(local_tuple<span class="pl-k">::</span><span class="pl-c1">UpTuple</span>)
    t, q, qdot <span class="pl-k">=</span> local_tuple<span class="pl-k">.</span>data
   (<span class="pl-c1">0.5</span>m)<span class="pl-k">*</span>qdot<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> (<span class="pl-c1">0.5</span>m<span class="pl-k">*</span>ω<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>q<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-k">end</span></pre></div>
<p>where the local_tuple is an object describing a time, posisition and velocity (ie. all the relevant phase space data). According to SICM, this data should be provided by a function <code>Γ(w)</code> where <code>w</code> defines a trajectory through space. <code>Γ</code> is defined as</p>
<div class="highlight highlight-source-julia"><pre>Γ(w) <span class="pl-k">=</span> t <span class="pl-k">-&gt;</span> <span class="pl-c1">UpTuple</span>([t, <span class="pl-c1">w</span>(t), <span class="pl-c1">D</span>(w)(t)])</pre></div>
<p>Hence, as shown in SICM, the Euler-Lagrange condition for stationary action may be written as the functional</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">Lagrange_Equations</span>(L) <span class="pl-k">=</span> w <span class="pl-k">-&gt;</span> <span class="pl-c1">D</span>(∂(<span class="pl-c1">3</span>)(L)<span class="pl-k">∘</span>Γ(w)) <span class="pl-k">-</span> ∂(<span class="pl-c1">2</span>)(L)<span class="pl-k">∘</span>Γ(w)</pre></div>
<p>where <code>∂(3)</code> means partial derivative with respect to velocity and <code>∂(2)</code> means partial derivative with respect to position (ie. the third and second elements of the local tuple respectively). Putting this all together, we may execute</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Lagrange_Equations</span>(L)(x)(t)
(<span class="pl-c1">D</span>(<span class="pl-c1">D</span>(x)))(t) <span class="pl-k">*</span> m <span class="pl-k">+</span> (x)(t) <span class="pl-k">*</span> m <span class="pl-k">*</span> ω <span class="pl-k">^</span> <span class="pl-c1">2</span></pre></div>
<p>which when set equal to zero is the equation of motion for a simple harmonic oscillator, generated in pure Julia code code symbolically!</p>
</article></div>