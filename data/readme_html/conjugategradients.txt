<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-conjugategradientsjl" class="anchor" aria-hidden="true" href="#conjugategradientsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ConjugateGradients.jl</h1>
<p dir="auto"><code>ConjugateGradients.jl</code> is a flexible, non-allocating Julia implementation of the conjugate gradient and biconjugate gradient stabilized methods.</p>
<h2 dir="auto"><a id="user-content-requirements" class="anchor" aria-hidden="true" href="#requirements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Requirements</h2>
<ul dir="auto">
<li>Julia 1.2 and up</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ]
pkg&gt; add ConjugateGradients"><pre>julia<span class="pl-k">&gt;</span> ]
pkg<span class="pl-k">&gt;</span> add ConjugateGradients</pre></div>
<h2 dir="auto"><a id="user-content-why-use-conjugategradientsjl" class="anchor" aria-hidden="true" href="#why-use-conjugategradientsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Why use ConjugateGradients.jl?</h2>
<p dir="auto">There are a few great iterative solver packages available for Julia: <a href="https://github.com/JuliaMath/IterativeSolvers.jl">IterativeSolvers.jl</a>, <a href="https://github.com/lruthotto/KrylovMethods.jl">KrylovMethods.jl</a>, and <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl">Krylov.jl</a>. These are all very well rounded and complete packages.</p>
<p dir="auto">This package, <code>ConjugateGradients.jl</code>, is built around reducing allocations as much as possible for a particular type of problem. As far as I know, if your program will be using an iterative solver <em>within</em> another iterative process, this module will result in less allocations compared to the previously mentioned packages<sup>*</sup>.</p>
<p dir="auto">Also, in other iterative solvers, calls to BLAS functions are preferred for obvious reasons. This package uses Julia's multiple dispatch functionality to decide whether to use BLAS or native Julia code to make calculations based on the type associated with the arrays. This gives greater flexibility with types not represented by floating point numbers.</p>
<p dir="auto"><em><sup>*</sup> Hint: take a look at <a href="https://github.com/mcovalt/ILUZero.jl">ILUZero.jl</a> if this type of solver would be beneficial to your project. Combined, these packages can help reduce allocations in those hot paths.</em></p>
<h2 dir="auto"><a id="user-content-how-to-use" class="anchor" aria-hidden="true" href="#how-to-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using ConjugateGradients"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> ConjugateGradients</pre></div>
<p dir="auto">For the conjugate gradient method to solve for <code>x</code> in <code>Ax=b</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x, exit_code, num_iters = cg(A, b; kwargs...)"><pre>x, exit_code, num_iters <span class="pl-k">=</span> <span class="pl-c1">cg</span>(A, b; kwargs<span class="pl-k">...</span>)</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="exit_code, num_iters = cg!(A, b, x; kwargs...)"><pre>exit_code, num_iters <span class="pl-k">=</span> <span class="pl-c1">cg!</span>(A, b, x; kwargs<span class="pl-k">...</span>)</pre></div>
<p dir="auto">For the biconjugate gradient stabilized method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x, exit_code, num_iters = bicgstab(A, b; kwargs...)"><pre>x, exit_code, num_iters <span class="pl-k">=</span> <span class="pl-c1">bicgstab</span>(A, b; kwargs<span class="pl-k">...</span>)</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="exit_code, num_iters = bicgstab!(A, b, x; kwargs...)"><pre>exit_code, num_iters <span class="pl-k">=</span> <span class="pl-c1">bicgstab!</span>(A, b, x; kwargs<span class="pl-k">...</span>)</pre></div>
<p dir="auto">Where <code>A</code> must be able to be applied as a function such that <code>A(b, x)</code> and the <code>kwargs</code> are:</p>
<ul dir="auto">
<li><code>tol = 1e-6</code>: The tolerance of the minimum residual before convergence is accepted.</li>
<li><code>maxIter = 100</code>: The maximum number of iterations to perform.</li>
<li><code>tolRho = 1e-40</code>: [<code>bicgstab</code> only] The tolerance of <code>dot(current residual, initial residual)</code>.</li>
<li><code>precon = nothing</code>: The preconditioner. The preconditioner must act as an in-place function of the form <code>f(out, in)</code>.</li>
<li><code>data = nothing</code>: The preallocation of the arrays used for solving the system.</li>
</ul>
<h3 dir="auto"><a id="user-content-preallocating" class="anchor" aria-hidden="true" href="#preallocating"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Preallocating</h3>
<p dir="auto">The <code>data</code> keyword points to an object containing the preallocated vectors necessary for the functions. If nothing is provided, these vectors will be allocated at each call. The data objects can be created like so:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CGD = CGData(n, T)"><pre>CGD <span class="pl-k">=</span> <span class="pl-c1">CGData</span>(n, T)</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="BCGD = BiCGStabData(n, T)"><pre>BCGD <span class="pl-k">=</span> <span class="pl-c1">BiCGStabData</span>(n, T)</pre></div>
<p dir="auto">Here, <code>n</code> is the dimension of the problem and <code>T</code> is the type of the elements in the problem (e.g. <code>Float64</code>).</p>
<h3 dir="auto"><a id="user-content-deciphering-the-exit-code" class="anchor" aria-hidden="true" href="#deciphering-the-exit-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Deciphering the exit code</h3>
<p dir="auto">The <code>exit_code</code> can be read with the following function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="exit_string = reader(exit_code)"><pre>exit_string <span class="pl-k">=</span> <span class="pl-c1">reader</span>(exit_code)</pre></div>
<h3 dir="auto"><a id="user-content-a-tip-for-a-and-the-preconditioner" class="anchor" aria-hidden="true" href="#a-tip-for-a-and-the-preconditioner"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A tip for <code>A</code> and the preconditioner</h3>
<p dir="auto">The operator <code>A</code> and the preconditioner must be expressed as functions. If <code>A</code> is a matrix, one can do:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x, exit_code, num_iters = cg((x,y) -&gt; mul!(x,A,y), b; kwargs...)"><pre>x, exit_code, num_iters <span class="pl-k">=</span> <span class="pl-c1">cg</span>((x,y) <span class="pl-k">-&gt;</span> <span class="pl-c1">mul!</span>(x,A,y), b; kwargs<span class="pl-k">...</span>)</pre></div>
<p dir="auto">Another useful representation of <code>A</code> is a custom struct. For example, let's consider <code>(B*C + D)x = b</code>. Instead of wasting time to build <code>B*C + D</code>, we can create a non-allocating version of it.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct MyA
    B::SparseMatrixCSC{Float64,Int64}
    C::SparseMatrixCSC{Float64,Int64}
    D::SparseMatrixCSC{Float64,Int64}
    cacheVec::Vector{Float64}
end

function (t::MyA)(out::Vector{Float64}, x::Vector{Float64})
    mul!(t.cacheVec, t.C, x)
    mul!(out, t.B, t.cacheVec)
    mul!(t.cacheVec, t.D, x)
    out .+= t.cacheVec
end

A = MyA(B, C, D, zeros(n))"><pre><span class="pl-k">struct</span> MyA
    B<span class="pl-k">::</span><span class="pl-c1">SparseMatrixCSC{Float64,Int64}</span>
    C<span class="pl-k">::</span><span class="pl-c1">SparseMatrixCSC{Float64,Int64}</span>
    D<span class="pl-k">::</span><span class="pl-c1">SparseMatrixCSC{Float64,Int64}</span>
    cacheVec<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> (t<span class="pl-k">::</span><span class="pl-c1">MyA</span>)(out<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, x<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>)
    <span class="pl-c1">mul!</span>(t<span class="pl-k">.</span>cacheVec, t<span class="pl-k">.</span>C, x)
    <span class="pl-c1">mul!</span>(out, t<span class="pl-k">.</span>B, t<span class="pl-k">.</span>cacheVec)
    <span class="pl-c1">mul!</span>(t<span class="pl-k">.</span>cacheVec, t<span class="pl-k">.</span>D, x)
    out <span class="pl-k">.+</span><span class="pl-k">=</span> t<span class="pl-k">.</span>cacheVec
<span class="pl-k">end</span>

A <span class="pl-k">=</span> <span class="pl-c1">MyA</span>(B, C, D, <span class="pl-c1">zeros</span>(n))</pre></div>
</article></div>