<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p><a href="https://github.com/VaclavMacha/EvalMetrics.jl/actions?query=workflow%3ACI"><img src="https://github.com/VaclavMacha/EvalMetrics.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/VaclavMacha/EvalMetrics.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/0d3cd57e1df1af36645ac88ff03c3f6a8be02e3404e1503741b0fb9ccefd97fc/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f5661636c61764d616368612f4576616c4d6574726963732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/VaclavMacha/EvalMetrics.jl/badge.svg?branch=master" style="max-width:100%;"></a>
<a href="http://codecov.io/github/VaclavMacha/EvalMetrics.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/f90a0483c7d4d2d38e4ffb13f46937d98fba3f572e6b82a406c5fe56cd8567f1/687474703a2f2f636f6465636f762e696f2f6769746875622f5661636c61764d616368612f4576616c4d6574726963732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/VaclavMacha/EvalMetrics.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<h1><a id="user-content-evalmetricsjl" class="anchor" aria-hidden="true" href="#evalmetricsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>EvalMetrics.jl</h1>
<p>Utility package for scoring binary classification models.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>Execute the following command in Julia Pkg REPL (<code>EvalMetrics.jl</code> requires julia 1.0 or higher)</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="(v1.5) pkg&gt; add EvalMetrics
"><pre>(v1.<span class="pl-c1">5</span>) pkg<span class="pl-k">&gt;</span> add EvalMetrics</pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<h3><a id="user-content-quickstart" class="anchor" aria-hidden="true" href="#quickstart"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Quickstart</h3>
<p>The fastest way of getting started is to use a simple <code>binary_eval_report</code> function in the following way:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; using EvalMetrics, Random

julia&gt; Random.seed!(123);

julia&gt; targets = rand(0:1, 100);

julia&gt; scores = rand(100);

julia&gt; binary_eval_report(targets, scores)
Dict{String,Real} with 8 entries:
  &quot;precision@fpr0.05&quot;          =&gt; 0.0
  &quot;recall@fpr0.05&quot;             =&gt; 0.0
  &quot;accuracy@fpr0.05&quot;           =&gt; 0.45
  &quot;au_prcurve&quot;                 =&gt; 0.460134
  &quot;samples&quot;                    =&gt; 100
  &quot;true negative rate@fpr0.05&quot; =&gt; 0.957447
  &quot;au_roccurve&quot;                =&gt; 0.42232
  &quot;prevalence&quot;                 =&gt; 0.53
  
julia&gt; binary_eval_report(targets, scores, 0.001)
Dict{String,Real} with 8 entries:
  &quot;recall@fpr0.001&quot;             =&gt; 0.0
  &quot;au_prcurve&quot;                  =&gt; 0.460134
  &quot;samples&quot;                     =&gt; 100
  &quot;precision@fpr0.001&quot;          =&gt; 1.0
  &quot;au_roccurve&quot;                 =&gt; 0.42232
  &quot;accuracy@fpr0.001&quot;           =&gt; 0.47
  &quot;prevalence&quot;                  =&gt; 0.53
  &quot;true negative rate@fpr0.001&quot; =&gt; 1.0
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> EvalMetrics, Random

julia<span class="pl-k">&gt;</span> Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">123</span>);

julia<span class="pl-k">&gt;</span> targets <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">100</span>);

julia<span class="pl-k">&gt;</span> scores <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">binary_eval_report</span>(targets, scores)
Dict{String,Real} with <span class="pl-c1">8</span> entries<span class="pl-k">:</span>
  <span class="pl-s"><span class="pl-pds">"</span>precision@fpr0.05<span class="pl-pds">"</span></span>          <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>
  <span class="pl-s"><span class="pl-pds">"</span>recall@fpr0.05<span class="pl-pds">"</span></span>             <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>
  <span class="pl-s"><span class="pl-pds">"</span>accuracy@fpr0.05<span class="pl-pds">"</span></span>           <span class="pl-k">=&gt;</span> <span class="pl-c1">0.45</span>
  <span class="pl-s"><span class="pl-pds">"</span>au_prcurve<span class="pl-pds">"</span></span>                 <span class="pl-k">=&gt;</span> <span class="pl-c1">0.460134</span>
  <span class="pl-s"><span class="pl-pds">"</span>samples<span class="pl-pds">"</span></span>                    <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span>
  <span class="pl-s"><span class="pl-pds">"</span>true negative rate@fpr0.05<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0.957447</span>
  <span class="pl-s"><span class="pl-pds">"</span>au_roccurve<span class="pl-pds">"</span></span>                <span class="pl-k">=&gt;</span> <span class="pl-c1">0.42232</span>
  <span class="pl-s"><span class="pl-pds">"</span>prevalence<span class="pl-pds">"</span></span>                 <span class="pl-k">=&gt;</span> <span class="pl-c1">0.53</span>
  
julia<span class="pl-k">&gt;</span> <span class="pl-c1">binary_eval_report</span>(targets, scores, <span class="pl-c1">0.001</span>)
Dict{String,Real} with <span class="pl-c1">8</span> entries<span class="pl-k">:</span>
  <span class="pl-s"><span class="pl-pds">"</span>recall@fpr0.001<span class="pl-pds">"</span></span>             <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>
  <span class="pl-s"><span class="pl-pds">"</span>au_prcurve<span class="pl-pds">"</span></span>                  <span class="pl-k">=&gt;</span> <span class="pl-c1">0.460134</span>
  <span class="pl-s"><span class="pl-pds">"</span>samples<span class="pl-pds">"</span></span>                     <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span>
  <span class="pl-s"><span class="pl-pds">"</span>precision@fpr0.001<span class="pl-pds">"</span></span>          <span class="pl-k">=&gt;</span> <span class="pl-c1">1.0</span>
  <span class="pl-s"><span class="pl-pds">"</span>au_roccurve<span class="pl-pds">"</span></span>                 <span class="pl-k">=&gt;</span> <span class="pl-c1">0.42232</span>
  <span class="pl-s"><span class="pl-pds">"</span>accuracy@fpr0.001<span class="pl-pds">"</span></span>           <span class="pl-k">=&gt;</span> <span class="pl-c1">0.47</span>
  <span class="pl-s"><span class="pl-pds">"</span>prevalence<span class="pl-pds">"</span></span>                  <span class="pl-k">=&gt;</span> <span class="pl-c1">0.53</span>
  <span class="pl-s"><span class="pl-pds">"</span>true negative rate@fpr0.001<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1.0</span></pre></div>
<h3><a id="user-content-confusion-matrix" class="anchor" aria-hidden="true" href="#confusion-matrix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Confusion Matrix</h3>
<p>The core the package is the <code>ConfusionMatrix</code> structure, which represents the <a href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="nofollow">confusion matrix</a> in the following form</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">Actual positives</th>
<th align="center">Actual negatives</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Predicted positives</strong></td>
<td align="center">tp (# true positives)</td>
<td align="center">fp (# false positives)</td>
</tr>
<tr>
<td><strong>Predicted negatives</strong></td>
<td align="center">fn (# false negatives)</td>
<td align="center">tn (# true negatives)</td>
</tr>
<tr>
<td></td>
<td align="center">p  (# positives)</td>
<td align="center">n (# negatives)</td>
</tr>
</tbody>
</table>
<p>The confusion matrix can be calculated from targets and predicted values or from targets, scores, and one or more decision thresholds</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; thres = 0.6;

julia&gt; predicts  = scores .&gt;= thres;

julia&gt; cm1 = ConfusionMatrix(targets, predicts)
ConfusionMatrix{Int64}(53, 47, 18, 24, 23, 35)

julia&gt; cm2 = ConfusionMatrix(targets, scores, thres)
ConfusionMatrix{Int64}(53, 47, 18, 24, 23, 35)

julia&gt; cm3 = ConfusionMatrix(targets, scores, thres)
ConfusionMatrix{Int64}(53, 47, 18, 24, 23, 35)

julia&gt; cm4 = ConfusionMatrix(targets, scores, [thres, thres])
2-element Array{ConfusionMatrix{Int64},1}:
 ConfusionMatrix{Int64}(53, 47, 18, 24, 23, 35)
 ConfusionMatrix{Int64}(53, 47, 18, 24, 23, 35)
"><pre>julia<span class="pl-k">&gt;</span> thres <span class="pl-k">=</span> <span class="pl-c1">0.6</span>;

julia<span class="pl-k">&gt;</span> predicts  <span class="pl-k">=</span> scores <span class="pl-k">.&gt;=</span> thres;

julia<span class="pl-k">&gt;</span> cm1 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, predicts)
<span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)

julia<span class="pl-k">&gt;</span> cm2 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, scores, thres)
<span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)

julia<span class="pl-k">&gt;</span> cm3 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, scores, thres)
<span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)

julia<span class="pl-k">&gt;</span> cm4 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, scores, [thres, thres])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{ConfusionMatrix{Int64},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)
 <span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)</pre></div>
<p>The package provides many basic classification metrics based on the confusion matrix.  The following table provides a list of all available metrics and its aliases</p>
<table>
<thead>
<tr>
<th>Classification metric</th>
<th align="center">Aliases</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true_positive</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>true_negative</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_positive</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_negative</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>true_positive_rate</code></td>
<td align="center"><code>sensitivity</code>,  <code>recall</code>, <code>hit_rate</code></td>
</tr>
<tr>
<td><code>true_negative_rate</code></td>
<td align="center"><code>specificity</code>,  <code>selectivity</code></td>
</tr>
<tr>
<td><code>false_positive_rate</code></td>
<td align="center"><code>fall_out</code>, <code>type_I_error</code></td>
</tr>
<tr>
<td><code>false_negative_rate</code></td>
<td align="center"><code>miss_rate</code>, <code>type_II_error</code></td>
</tr>
<tr>
<td><code>precision</code></td>
<td align="center"><code>positive_predictive_value</code></td>
</tr>
<tr>
<td><code>negative_predictive_value</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_discovery_rate</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_omission_rate</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>threat_score</code></td>
<td align="center"><code>critical_success_index</code></td>
</tr>
<tr>
<td><code>accuracy</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>balanced_accuracy</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>error_rate</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>balanced_error_rate</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>f1_score</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>fβ_score</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>matthews_correlation_coefficient</code></td>
<td align="center"><code>mcc</code></td>
</tr>
<tr>
<td><code>quant</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>positive_likelihood_ratio</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>negative_likelihood_ratio</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>diagnostic_odds_ratio</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>prevalence</code></td>
<td align="center"></td>
</tr>
</tbody>
</table>
<p>Each metric can be computed from the <code>ConfusionMatrix</code> structure</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; recall(cm1)
0.33962264150943394

julia&gt; recall(cm2)
0.33962264150943394

julia&gt; recall(cm3)
0.33962264150943394

julia&gt; recall(cm4)
2-element Array{Float64,1}:
 0.33962264150943394
 0.33962264150943394
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm1)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm2)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm3)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm4)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span></pre></div>
<p>The other option is to compute the metric directly from targets and predicted values or from targets, scores, and one or more decision thresholds</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; recall(targets, predicts)
0.33962264150943394

julia&gt; recall(targets, scores, thres)
0.33962264150943394

julia&gt; recall(targets, scores, thres)
0.33962264150943394

julia&gt; recall(targets, scores, [thres, thres])
2-element Array{Float64,1}:
 0.33962264150943394
 0.33962264150943394
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, predicts)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, scores, [thres, thres])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span></pre></div>
<h3><a id="user-content-user-defined-classification-metrics" class="anchor" aria-hidden="true" href="#user-defined-classification-metrics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>User defined classification metrics</h3>
<p>It may occur that some useful metric is not defined in the package. To simplify the process of defining a new metric, the package provides the <code>@metric</code> macro and <code>apply</code> function.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="import EvalMetrics: @metric, metric

@metric MyRecall

apply(::Type{MyRecall}, x::ConfusionMatrix) = x.tp/x.p
"><pre><span class="pl-k">import</span> EvalMetrics<span class="pl-k">:</span> <span class="pl-c1">@metric</span>, metric

<span class="pl-c1">@metric</span> MyRecall

<span class="pl-en">apply</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MyRecall}</span>, x<span class="pl-k">::</span><span class="pl-c1">ConfusionMatrix</span>) <span class="pl-k">=</span> x<span class="pl-k">.</span>tp<span class="pl-k">/</span>x<span class="pl-k">.</span>p</pre></div>
<p>In the previous example, macro <code>@metric</code> defines a new abstract type <code>MyRecall</code> (used for dispatch) and a function <code>myrecall</code> (for easy use of the new metric).  With defined abstract type <code>MyRecall</code>, the next step is to define a new method for the <code>apply</code> function. This method must have exactly two input arguments: <code>Type{MyRecall}</code> and <code>ConfusionMatrix</code>.  If another argument is needed, it can be added as a keyword argument.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="apply(::Type{Fβ_score}, x::ConfusionMatrix; β::Real = 1) =
    (1 + β^2)*precision(x)*recall(x)/(β^2*precision(x) + recall(x))
"><pre><span class="pl-en">apply</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Fβ_score}</span>, x<span class="pl-k">::</span><span class="pl-c1">ConfusionMatrix</span>; β<span class="pl-k">::</span><span class="pl-c1">Real</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>) <span class="pl-k">=</span>
    (<span class="pl-c1">1</span> <span class="pl-k">+</span> β<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span><span class="pl-c1">precision</span>(x)<span class="pl-k">*</span><span class="pl-c1">recall</span>(x)<span class="pl-k">/</span>(β<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">precision</span>(x) <span class="pl-k">+</span> <span class="pl-c1">recall</span>(x))</pre></div>
<p>It is easy to check that the <code>myrecall</code> metric returns the same outputs as the <code>recall</code> metric defined in the package</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; myrecall(cm1)
0.33962264150943394

julia&gt; myrecall(cm2)
0.33962264150943394

julia&gt; myrecall(cm3)
0.33962264150943394

julia&gt; myrecall(cm4)
2-element Array{Float64,1}:
 0.33962264150943394
 0.33962264150943394
julia&gt; myrecall(targets, predicts)
0.33962264150943394

julia&gt; myrecall(targets, scores, thres)
0.33962264150943394

julia&gt; myrecall(targets, scores, thres)
0.33962264150943394

julia&gt; myrecall(targets, scores, [thres, thres])
2-element Array{Float64,1}:
 0.33962264150943394
 0.33962264150943394
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm1)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm2)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm3)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm4)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, predicts)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, scores, [thres, thres])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span></pre></div>
<h3><a id="user-content-label-encodings" class="anchor" aria-hidden="true" href="#label-encodings"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Label encodings</h3>
<p>Different label encodings are considered common in different machine learning applications. For example, support vector machines use <code>1</code> as a positive label and <code>-1</code> as a negative label. On the other hand, it is common for neural networks to use <code>0</code> as a negative label. The package provides some basic label encodings listed in the following table</p>
<table>
<thead>
<tr>
<th>Encoding</th>
<th align="center">positive label(s)</th>
<th align="center">negative label(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OneZero(::Type{T})</code></td>
<td align="center"><code>one(T)</code></td>
<td align="center"><code>zero(T)</code></td>
</tr>
<tr>
<td><code>OneMinusOne(::Type{T})</code></td>
<td align="center"><code>one(T)</code></td>
<td align="center"><code>-one(T)</code></td>
</tr>
<tr>
<td><code>OneTwo(::Type{T})</code></td>
<td align="center"><code>one(T)</code></td>
<td align="center"><code>2*one(T)</code></td>
</tr>
<tr>
<td><code>OneVsOne(::Type{T}, pos::T, neg::T)</code></td>
<td align="center"><code>pos</code></td>
<td align="center"><code>neg</code></td>
</tr>
<tr>
<td><code>OneVsRest(::Type{T}, pos::T, neg::AbstractVector{T})</code></td>
<td align="center"><code>pos</code></td>
<td align="center"><code>neg</code></td>
</tr>
<tr>
<td><code>RestVsOne(::Type{T}, pos::AbstractVector{T}, neg::T)</code></td>
<td align="center"><code>pos</code></td>
<td align="center"><code>neg</code></td>
</tr>
</tbody>
</table>
<p>The <code>current_encoding</code> function can be used to verify which encoding is currently in use (by default it is <code>OneZero</code> encoding)</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; enc = current_encoding()
OneZero{Float64}:
   positive class: 1.0
   negative class: 0.0
"><pre>julia<span class="pl-k">&gt;</span> enc <span class="pl-k">=</span> <span class="pl-c1">current_encoding</span>()
OneZero{Float64}<span class="pl-k">:</span>
   positive class<span class="pl-k">:</span> <span class="pl-c1">1.0</span>
   negative class<span class="pl-k">:</span> <span class="pl-c1">0.0</span></pre></div>
<p>One way to use a different encoding is to pass the new encoding as the first argument</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; enc_new = OneVsOne(:positive, :negative)
OneVsOne{Symbol}:
   positive class: positive
   negative class: negative

julia&gt; targets_recoded = recode.(enc, enc_new, targets);

julia&gt; predicts_recoded = recode.(enc, enc_new, predicts);

julia&gt; recall(enc, targets, predicts)
0.33962264150943394

julia&gt; recall(enc_new, targets_recoded, predicts_recoded)
0.33962264150943394
"><pre>julia<span class="pl-k">&gt;</span> enc_new <span class="pl-k">=</span> <span class="pl-c1">OneVsOne</span>(<span class="pl-c1">:positive</span>, <span class="pl-c1">:negative</span>)
OneVsOne{Symbol}<span class="pl-k">:</span>
   positive class<span class="pl-k">:</span> positive
   negative class<span class="pl-k">:</span> negative

julia<span class="pl-k">&gt;</span> targets_recoded <span class="pl-k">=</span> <span class="pl-c1">recode</span>.(enc, enc_new, targets);

julia<span class="pl-k">&gt;</span> predicts_recoded <span class="pl-k">=</span> <span class="pl-c1">recode</span>.(enc, enc_new, predicts);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(enc, targets, predicts)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(enc_new, targets_recoded, predicts_recoded)
<span class="pl-c1">0.33962264150943394</span></pre></div>
<p>The second way is to change the current encoding to the one you want</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; set_encoding(OneVsOne(:positive, :negative))
OneVsOne{Symbol}:
   positive class: positive
   negative class: negative

julia&gt; recall(targets_recoded, predicts_recoded)
0.33962264150943394
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">set_encoding</span>(<span class="pl-c1">OneVsOne</span>(<span class="pl-c1">:positive</span>, <span class="pl-c1">:negative</span>))
OneVsOne{Symbol}<span class="pl-k">:</span>
   positive class<span class="pl-k">:</span> positive
   negative class<span class="pl-k">:</span> negative

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets_recoded, predicts_recoded)
<span class="pl-c1">0.33962264150943394</span></pre></div>
<h3><a id="user-content-decision-thresholds-for-classification" class="anchor" aria-hidden="true" href="#decision-thresholds-for-classification"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Decision thresholds for classification</h3>
<p>The package provides a <code>thresholds(scores::RealVector, n::Int)</code> , which returns <code>n</code> decision thresholds which correspond to <code>n</code> evenly spaced quantiles of the given <code>scores</code> vector. The default value of <code>n</code> is <code>length(scores) + 1</code>.  The <code>thresholds</code> function has two keyword arguments <code>reduced::Bool</code> and <code>zerorecall::Bool</code></p>
<ul>
<li>If <code>reduced</code> is <code>true</code> (default), then the function returns <code>min(length(scores) + 1, n)</code> thresholds.</li>
<li>If <code>zerorecall</code>  is <code>true</code> (default), then the largest threshold is <code>maximum(scores)*(1 + eps())</code> otherwise <code>maximum(scores)</code>.</li>
</ul>
<p>The package also provides some other useful utilities</p>
<ul>
<li><code>threshold_at_tpr(targets::AbstractVector, scores::RealVector, tpr::Real)</code> returns the largest threshold <code>t</code> that satisfies <code>true_positive_rate(targets, scores, t) &gt;= tpr</code></li>
<li><code>threshold_at_tnr(targets::AbstractVector, scores::RealVector, tnr::Real)</code> returns the smallest threshold <code>t</code> that satisfies <code>true_negative_rate(targets, scores, t) &gt;= tnr</code></li>
<li><code>threshold_at_fpr(targets::AbstractVector, scores::RealVector, fpr::Real)</code> returns the smallest threshold <code>t</code> that satisfies <code>false_positive_rate(targets, scores, t) &lt;= fpr</code></li>
<li><code>threshold_at_fnr(targets::AbstractVector, scores::RealVector, fnr::Real)</code> returns the largest threshold <code>t</code> that satisfies <code>false_negative_rate(targets, scores, t) &lt;= fnr</code></li>
</ul>
<p>All four functions can be called with an encoding of type <code>AbstractEncoding</code> as the first parameter to use a different encoding than default.</p>
<h3><a id="user-content-evaluation-curves" class="anchor" aria-hidden="true" href="#evaluation-curves"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Evaluation curves</h3>
<p>Functionality for measuring performance with curves is implemented in the package as well. For example, a precision-recall (PR) curve can be computed as follows:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; scores = [0.74, 0.48, 0.23, 0.91, 0.33, 0.92, 0.83, 0.61, 0.68, 0.09];

julia&gt; targets = collect(1:10 .&gt;= 3);

julia&gt; prcurve(targets, scores)
([1.0, 0.875, 0.75, 0.625, 0.625, 0.5, 0.375, 0.375, 0.25, 0.125, 0.0],
 [0.8, 0.7777777777777778, 0.75, 0.7142857142857143, 0.8333333333333334, 0.8, 0.75, 1.0, 1.0, 1.0, 1.0])

"><pre>julia<span class="pl-k">&gt;</span> scores <span class="pl-k">=</span> [<span class="pl-c1">0.74</span>, <span class="pl-c1">0.48</span>, <span class="pl-c1">0.23</span>, <span class="pl-c1">0.91</span>, <span class="pl-c1">0.33</span>, <span class="pl-c1">0.92</span>, <span class="pl-c1">0.83</span>, <span class="pl-c1">0.61</span>, <span class="pl-c1">0.68</span>, <span class="pl-c1">0.09</span>];

julia<span class="pl-k">&gt;</span> targets <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span> <span class="pl-k">.&gt;=</span> <span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">prcurve</span>(targets, scores)
([<span class="pl-c1">1.0</span>, <span class="pl-c1">0.875</span>, <span class="pl-c1">0.75</span>, <span class="pl-c1">0.625</span>, <span class="pl-c1">0.625</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">0.375</span>, <span class="pl-c1">0.375</span>, <span class="pl-c1">0.25</span>, <span class="pl-c1">0.125</span>, <span class="pl-c1">0.0</span>],
 [<span class="pl-c1">0.8</span>, <span class="pl-c1">0.7777777777777778</span>, <span class="pl-c1">0.75</span>, <span class="pl-c1">0.7142857142857143</span>, <span class="pl-c1">0.8333333333333334</span>, <span class="pl-c1">0.8</span>, <span class="pl-c1">0.75</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>])
</pre></div>
<p>All possible calls:</p>
<ul>
<li><code>prcurve(targets::AbstractVector, scores::RealVector)</code> returns all <code>length(target) + 1</code> points</li>
<li><code>prcurve(enc::AbstractEncoding, target::AbstractVector, scores::RealVector)</code> makes different encodings possible</li>
<li><code>prcurve(targets::AbstractVector, scores::RealVector, thres::RealVector)</code> uses provided threshols to compute individual points</li>
<li><code>prcurve(enc::AbstractEncoding, target::AbstractVector, scores::RealVector, thres::RealVector)</code></li>
<li><code>prcurve(cms::AbstractVector{&lt;:ConfusionMatrix})</code></li>
</ul>
<p>We can also compute area under the curve using the <code>auc_trapezoidal</code> function which uses the trapezoidal rule as follows:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; auc_trapezoidal(prcurve(targets, scores)...)
0.8595734126984128
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">auc_trapezoidal</span>(<span class="pl-c1">prcurve</span>(targets, scores)<span class="pl-k">...</span>)
<span class="pl-c1">0.8595734126984128</span></pre></div>
<p>However, a convenience function <code>au_prcurve</code> is provided with exactly the same signature as <code>prcurve</code> function. Moreover, any <code>curve(PRCurve, args...)</code> or <code>auc(PRCurve, args...)</code> call is equivalent to <code>prcurve(args...)</code> and <code>au_prcurve(args...)</code>, respectively.</p>
<p>Besides PR curve, Receiver operating characteristic (ROC) curve is also available out of the box with analogical definitions of <code>roccurve</code> and <code>au_roccurve</code>.</p>
<p>All points of the curve, as well as area under curve scores are computed using the highest possible resolution by default. This can be changed by a keyword argument <code>npoints</code></p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; length.(prcurve(targets, scores))
(11, 11)
julia&gt; length.(prcurve(targets, scores; npoints=9))
(9, 9)
julia&gt; auprcurve(targets, scores)
0.8595734126984128
julia&gt; au_prcurve(targets, scores; npoints=9)
0.8826388888888889
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">length</span>.(<span class="pl-c1">prcurve</span>(targets, scores))
(<span class="pl-c1">11</span>, <span class="pl-c1">11</span>)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">length</span>.(<span class="pl-c1">prcurve</span>(targets, scores; npoints<span class="pl-k">=</span><span class="pl-c1">9</span>))
(<span class="pl-c1">9</span>, <span class="pl-c1">9</span>)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">auprcurve</span>(targets, scores)
<span class="pl-c1">0.8595734126984128</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">au_prcurve</span>(targets, scores; npoints<span class="pl-k">=</span><span class="pl-c1">9</span>)
<span class="pl-c1">0.8826388888888889</span></pre></div>
<h4><a id="user-content-plotting" class="anchor" aria-hidden="true" href="#plotting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Plotting</h4>
<p>For plotting purposes, <code>EvalMetrics.jl</code> provides recipes for the <code>Plots</code> library:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; using Plots; pyplot()
julia&gt; using Random, MLBase; Random.seed!(42);
julia&gt; scores = sort(rand(10000));
julia&gt; targets = scores .&gt;= 0.99;
julia&gt; targets[MLBase.sample(findall(0.98 .&lt;= scores .&lt; 0.99), 30; replace = false)] .= true;
julia&gt; targets[MLBase.sample(findall(0.99 .&lt;= scores .&lt; 0.995), 30; replace = false)] .= false;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Plots; <span class="pl-c1">pyplot</span>()
julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Random, MLBase; Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">42</span>);
julia<span class="pl-k">&gt;</span> scores <span class="pl-k">=</span> <span class="pl-c1">sort</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">10000</span>));
julia<span class="pl-k">&gt;</span> targets <span class="pl-k">=</span> scores <span class="pl-k">.&gt;=</span> <span class="pl-c1">0.99</span>;
julia<span class="pl-k">&gt;</span> targets[MLBase<span class="pl-k">.</span><span class="pl-c1">sample</span>(<span class="pl-c1">findall</span>(<span class="pl-c1">0.98</span> <span class="pl-k">.&lt;=</span> scores <span class="pl-k">.&lt;</span> <span class="pl-c1">0.99</span>), <span class="pl-c1">30</span>; replace <span class="pl-k">=</span> <span class="pl-c1">false</span>)] <span class="pl-k">.=</span> <span class="pl-c1">true</span>;
julia<span class="pl-k">&gt;</span> targets[MLBase<span class="pl-k">.</span><span class="pl-c1">sample</span>(<span class="pl-c1">findall</span>(<span class="pl-c1">0.99</span> <span class="pl-k">.&lt;=</span> scores <span class="pl-k">.&lt;</span> <span class="pl-c1">0.995</span>), <span class="pl-c1">30</span>; replace <span class="pl-k">=</span> <span class="pl-c1">false</span>)] <span class="pl-k">.=</span> <span class="pl-c1">false</span>;</pre></div>
<p>Then, any of the following can be used:</p>
<ul>
<li><code>prplot(targets::AbstractVector, scores::RealVector)</code> to use the full resolution:</li>
</ul>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; prplot(targets, scores)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot</span>(targets, scores)</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/pr1.png?raw=true"><img src="docs/pr1.png?raw=true" style="max-width:100%;"></a>
</p>
<ul>
<li><code>prplot(targets::AbstractVector, scores::RealVector, thresholds::RealVector)</code> to specify thresholds that will be used</li>
<li><code>prplot!(enc::AbstractEncoding, targets::AbstractVector, scores::RealVector)</code> to use a different encoding than default</li>
<li><code>prplot!(enc::AbstractEncoding, targets::AbstractVector, scores::RealVector, thresholds::RealVector)</code></li>
</ul>
<p>Furthermore, one can use vectors of vectors like <code>[targets1, targets2]</code> and <code>[scores1, scores2])</code> to plot multiple curves at once. The calls stay the same:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; prplot([targets, targets], [scores, scores .+ rand(10000) ./ 5])
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot</span>([targets, targets], [scores, scores <span class="pl-k">.+</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10000</span>) <span class="pl-k">./</span> <span class="pl-c1">5</span>])</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/pr2.png?raw=true"><img src="docs/pr2.png?raw=true" style="max-width:100%;"></a>
</p>
<p>For ROC curve use <code>rocplot</code> analogically:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; rocplot(targets, scores)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">rocplot</span>(targets, scores)</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/roc1.png?raw=true"><img src="docs/roc1.png?raw=true" style="max-width:100%;"></a>
</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; rocplot([targets, targets], [scores, scores .+ rand(10000) ./ 5])
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">rocplot</span>([targets, targets], [scores, scores <span class="pl-k">.+</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10000</span>) <span class="pl-k">./</span> <span class="pl-c1">5</span>])</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/roc2.png?raw=true"><img src="docs/roc2.png?raw=true" style="max-width:100%;"></a>
</p>
<p>'Modifying' versions with exclamation marks <code>prplot!</code> and <code>rocplot!</code> work as well.</p>
<p>The appearance of the plot can be changed in exactly the same way as with <code>Plots</code> library. Therefore, keyword arguments such as <code>xguide</code>, <code>xlims</code>, <code>grid</code>, <code>fill</code> can all be used:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; prplot(targets, scores; xguide=&quot;RECALL&quot;, fill=:green, grid=false, xlims=(0.8, 1.0))
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot</span>(targets, scores; xguide<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>RECALL<span class="pl-pds">"</span></span>, fill<span class="pl-k">=</span><span class="pl-c1">:green</span>, grid<span class="pl-k">=</span><span class="pl-c1">false</span>, xlims<span class="pl-k">=</span>(<span class="pl-c1">0.8</span>, <span class="pl-c1">1.0</span>))</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/pr3.png?raw=true"><img src="docs/pr3.png?raw=true" style="max-width:100%;"></a>
</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; rocplot(targets, scores, title=&quot;Title&quot;, label=&quot;experiment&quot;, xscale=:log10)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">rocplot</span>(targets, scores, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Title<span class="pl-pds">"</span></span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>experiment<span class="pl-pds">"</span></span>, xscale<span class="pl-k">=</span><span class="pl-c1">:log10</span>)</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/roc3.png?raw=true"><img src="docs/roc3.png?raw=true" style="max-width:100%;"></a>
</p>
<p>Here, limits on x axis are appropriately changed, unless overridden by using <code>xlims</code> keyword argument.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; rocplot([targets, targets], [scores, scores .+ rand(10000) ./ 5], label=[&quot;a&quot; &quot;b&quot;;])
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">rocplot</span>([targets, targets], [scores, scores <span class="pl-k">.+</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10000</span>) <span class="pl-k">./</span> <span class="pl-c1">5</span>], label<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>;])</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/roc4.png?raw=true"><img src="docs/roc4.png?raw=true" style="max-width:100%;"></a>
</p>
<p>By default, plotted curves have 300 points, which are sampled to retain as much information as possible. This amounts to sampling false positive rate in case of ROC curves and true positive rate in case of PR curves instead of raw thresholds. The number of points can be again changed by keyword argument <code>npoints</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; prplot(targets, scores; npoints=Inf, label=&quot;Original&quot;) 
julia&gt; prplot!(targets, scores; npoints=10, label=&quot;Sampled (10 points)&quot;) 
julia&gt; prplot!(targets, scores; npoints=100, label=&quot;Sampled (100 points)&quot;) 
julia&gt; prplot!(targets, scores; npoints=1000, label=&quot;Sampled (1000 points)&quot;) 
julia&gt; prplot!(targets, scores; npoints=5000, label=&quot;Sampled (5000 points)&quot;) 
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot</span>(targets, scores; npoints<span class="pl-k">=</span><span class="pl-c1">Inf</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Original<span class="pl-pds">"</span></span>) 
julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot!</span>(targets, scores; npoints<span class="pl-k">=</span><span class="pl-c1">10</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Sampled (10 points)<span class="pl-pds">"</span></span>) 
julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot!</span>(targets, scores; npoints<span class="pl-k">=</span><span class="pl-c1">100</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Sampled (100 points)<span class="pl-pds">"</span></span>) 
julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot!</span>(targets, scores; npoints<span class="pl-k">=</span><span class="pl-c1">1000</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Sampled (1000 points)<span class="pl-pds">"</span></span>) 
julia<span class="pl-k">&gt;</span> <span class="pl-c1">prplot!</span>(targets, scores; npoints<span class="pl-k">=</span><span class="pl-c1">5000</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Sampled (5000 points)<span class="pl-pds">"</span></span>) </pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/pr4.png?raw=true"><img src="docs/pr4.png?raw=true" style="max-width:100%;"></a>
</p>
<p>Note that even though we visuallize smaller number of points, the displayed auc score is computed from all points. In case when logarithmic scale is used, the sampling is also done in logarithmic scale.</p>
<p>Other than that, <code>diagonal</code> keyword indicates the diagonal in the plot, and <code>aucshow</code> toggles, whether auc score is appended to a label:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; rocplot(targets, scores; aucshow=false, label=&quot;a&quot;, diagonal=true)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">rocplot</span>(targets, scores; aucshow<span class="pl-k">=</span><span class="pl-c1">false</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, diagonal<span class="pl-k">=</span><span class="pl-c1">true</span>)</pre></div>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="docs/roc5.png?raw=true"><img src="docs/roc5.png?raw=true" style="max-width:100%;"></a>
</p>
<h4><a id="user-content-user-defined-curves" class="anchor" aria-hidden="true" href="#user-defined-curves"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>User-defined curves</h4>
<p>PR and ROC curves are available out of the box. Additional curve definitions can be provided in the similar way as new metrics are defined using macro <code>@curve</code> and defining <code>apply</code> function, which computes a point on the curve. For instance, ROC curve can be defined this way:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; import EvalMetrics: @curve, apply 

julia&gt; @curve MyROCCurve

julia&gt; apply(::Type{MyROCCurve}, cms::AbstractVector{ConfusionMatrix{T}}) where T &lt;: Real =
    (false_positive_rate(cms), true_positive_rate(cms))

julia&gt; myroccurve(targets, scores) == roccurve(targets, scores)
true
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">import</span> EvalMetrics<span class="pl-k">:</span> <span class="pl-c1">@curve</span>, apply 

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@curve</span> MyROCCurve

julia<span class="pl-k">&gt;</span> <span class="pl-en">apply</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MyROCCurve}</span>, cms<span class="pl-k">::</span><span class="pl-c1">AbstractVector{ConfusionMatrix{T}}</span>) <span class="pl-k">where</span> T <span class="pl-k">&lt;:</span> <span class="pl-c1">Real</span> <span class="pl-k">=</span>
    (<span class="pl-c1">false_positive_rate</span>(cms), <span class="pl-c1">true_positive_rate</span>(cms))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myroccurve</span>(targets, scores) <span class="pl-k">==</span> <span class="pl-c1">roccurve</span>(targets, scores)
<span class="pl-c1">true</span></pre></div>
<p>In order to be able to sample from x axis while plotting, <code>sampling_function</code> and <code>lowest_metric_value</code> must be provided as well.</p>
</article></div>