<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p><a href="https://travis-ci.com/VaclavMacha/EvalMetrics.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/48aa1c898657c518ba195beca10f326cd6e1ea1a/68747470733a2f2f7472617669732d63692e636f6d2f5661636c61764d616368612f4576616c4d6574726963732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/VaclavMacha/EvalMetrics.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/VaclavMacha/EvalMetrics.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/614c95cbd4bd84bb28cb035b4bf9957962770c44/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f5661636c61764d616368612f4576616c4d6574726963732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/VaclavMacha/EvalMetrics.jl/badge.svg?branch=master" style="max-width:100%;"></a>
<a href="http://codecov.io/github/VaclavMacha/EvalMetrics.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/96a6ca3e3faf113830e756b55896015c742a9000/687474703a2f2f636f6465636f762e696f2f6769746875622f5661636c61764d616368612f4576616c4d6574726963732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/VaclavMacha/EvalMetrics.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<h1><a id="user-content-evalmetricsjl" class="anchor" aria-hidden="true" href="#evalmetricsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>EvalMetrics.jl</h1>
<p>Utility package for scoring binary classification models.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>Execute the following command in Julia Pkg REPL</p>
<div class="highlight highlight-source-julia"><pre>(v1<span class="pl-c1">.4</span>) pkg<span class="pl-k">&gt;</span> add EvalMetrics</pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The core the package is the <code>ConfusionMatrix</code> structure, which represents the <a href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="nofollow">confusion matrix</a> in the following form</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">Actual positives</th>
<th align="center">Actual negatives</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Predicted positives</strong></td>
<td align="center">tp (# true positives)</td>
<td align="center">fp (# false positives)</td>
</tr>
<tr>
<td><strong>Predicted negatives</strong></td>
<td align="center">fn (# false negatives)</td>
<td align="center">tn (# true negatives)</td>
</tr>
<tr>
<td></td>
<td align="center">p  (# positives)</td>
<td align="center">n (# negatives)</td>
</tr>
</tbody>
</table>
<p>The confusion matrix can be calculated from targets and predicted values or from targets, scores, and one or more decision thresholds</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> EvalMetrics, Random

julia<span class="pl-k">&gt;</span> Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">123</span>);

julia<span class="pl-k">&gt;</span> targets <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>, <span class="pl-c1">100</span>);

julia<span class="pl-k">&gt;</span> scores <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>);

julia<span class="pl-k">&gt;</span> thres <span class="pl-k">=</span> <span class="pl-c1">0.6</span>;

julia<span class="pl-k">&gt;</span> predicts  <span class="pl-k">=</span> scores <span class="pl-k">.&gt;=</span> thres;

julia<span class="pl-k">&gt;</span> cm1 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, predicts)
<span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)

julia<span class="pl-k">&gt;</span> cm2 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, scores, thres)
<span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)

julia<span class="pl-k">&gt;</span> cm3 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, scores, thres)
<span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)

julia<span class="pl-k">&gt;</span> cm4 <span class="pl-k">=</span> <span class="pl-c1">ConfusionMatrix</span>(targets, scores, [thres, thres])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{ConfusionMatrix{Int64},<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)
 <span class="pl-c1">ConfusionMatrix</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">53</span>, <span class="pl-c1">47</span>, <span class="pl-c1">18</span>, <span class="pl-c1">24</span>, <span class="pl-c1">23</span>, <span class="pl-c1">35</span>)</pre></div>
<p>The package provides many basic classification metrics based on the confusion matrix.  The following table provides a list of all available metrics and its aliases</p>
<table>
<thead>
<tr>
<th>Classification metric</th>
<th align="center">Aliases</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true_positive</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>true_negative</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_positive</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_negative</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>true_positive_rate</code></td>
<td align="center"><code>sensitivity</code>,  <code>recall</code>, <code>hit_rate</code></td>
</tr>
<tr>
<td><code>true_negative_rate</code></td>
<td align="center"><code>specificity</code>,  <code>selectivity</code></td>
</tr>
<tr>
<td><code>false_positive_rate</code></td>
<td align="center"><code>fall_out</code>, <code>type_I_error</code></td>
</tr>
<tr>
<td><code>false_negative_rate</code></td>
<td align="center"><code>miss_rate</code>, <code>type_II_error</code></td>
</tr>
<tr>
<td><code>precision</code></td>
<td align="center"><code>positive_predictive_value</code></td>
</tr>
<tr>
<td><code>negative_predictive_value</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_discovery_rate</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>false_omission_rate</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>threat_score</code></td>
<td align="center"><code>critical_success_index</code></td>
</tr>
<tr>
<td><code>accuracy</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>balanced_accuracy</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>f1_score</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>fÎ²_score</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>matthews_correlation_coefficient</code></td>
<td align="center"><code>mcc</code></td>
</tr>
<tr>
<td><code>quant</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>positive_likelihood_ratio</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>negative_likelihood_ratio</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>diagnostic_odds_ratio</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>prevalence</code></td>
<td align="center"></td>
</tr>
</tbody>
</table>
<p>Each metric can be computed from the <code>ConfusionMatrix</code> structure</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm1)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm2)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm3)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(cm4)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span></pre></div>
<p>The other option is to compute the metric directly from targets and predicted values or from targets, scores, and one or more decision thresholds</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, predicts)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets, scores, [thres, thres])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span></pre></div>
<h3><a id="user-content-user-defined-classification-metrics" class="anchor" aria-hidden="true" href="#user-defined-classification-metrics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>User defined classification metrics</h3>
<p>It may occur that some useful metric is not defined in the package. To simplify the process of defining a new metric, the package provides the <code>@metric</code> macro and <code>apply</code> function.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">import</span> EvalMetrics<span class="pl-k">:</span> <span class="pl-c1">@metric</span>, metric

<span class="pl-c1">@metric</span> MyRecall

<span class="pl-en">apply</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MyRecall}</span>, x<span class="pl-k">::</span><span class="pl-c1">ConfusionMatrix</span>) <span class="pl-k">=</span> x<span class="pl-k">.</span>tp<span class="pl-k">/</span>x<span class="pl-k">.</span>p</pre></div>
<p>In the previous example, macro <code>@metric</code> defines a new abstract type <code>MyRecall</code> (used for dispatch) and a function <code>myrecall</code> (for easy use of the new metric).  With defined abstract type <code>MyRecall</code>, the next step is to define a new method for the <code>apply</code> function. This method must have exactly two input arguments: <code>Type{MyRecall}</code> and <code>ConfusionMatrix</code>.  If another argument is needed, it can be added as a keyword argument.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">apply</span>(<span class="pl-k">::</span><span class="pl-c1">Type{FÎ²_score}</span>, x<span class="pl-k">::</span><span class="pl-c1">ConfusionMatrix</span>; Î²<span class="pl-k">::</span><span class="pl-c1">Real</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>) <span class="pl-k">=</span>
    (<span class="pl-c1">1</span> <span class="pl-k">+</span> Î²<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span><span class="pl-c1">precision</span>(x)<span class="pl-k">*</span><span class="pl-c1">recall</span>(x)<span class="pl-k">/</span>(Î²<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">precision</span>(x) <span class="pl-k">+</span> <span class="pl-c1">recall</span>(x))</pre></div>
<p>It is easy to check that the <code>myrecall</code> metric returns the same outputs as the <code>recall</code> metric defined in the package</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm1)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm2)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm3)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(cm4)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, predicts)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, scores, thres)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">myrecall</span>(targets, scores, [thres, thres])
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{Float64,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.33962264150943394</span>
 <span class="pl-c1">0.33962264150943394</span></pre></div>
<h3><a id="user-content-label-encodings" class="anchor" aria-hidden="true" href="#label-encodings"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Label encodings</h3>
<p>Different label encodings are considered common in different machine learning applications. For example, supporting vector machines use <code>1</code> as a positive label and <code>-1</code> as a negative label. On the other hand, it is common for neural networks to use <code>0</code> as a negative label. The package provides some basic label encodings listed in the following table</p>
<table>
<thead>
<tr>
<th>Encoding</th>
<th align="center">positive label(s)</th>
<th align="center">negative label(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OneZero(::Type{T})</code></td>
<td align="center"><code>one(T)</code></td>
<td align="center"><code>zero(T)</code></td>
</tr>
<tr>
<td><code>OneMinusOne(::Type{T})</code></td>
<td align="center"><code>one(T)</code></td>
<td align="center"><code>-one(T)</code></td>
</tr>
<tr>
<td><code>OneTwo(::Type{T})</code></td>
<td align="center"><code>one(T)</code></td>
<td align="center"><code>2*one(T)</code></td>
</tr>
<tr>
<td><code>OneVsOne(::Type{T}, pos::T, neg::T)</code></td>
<td align="center"><code>pos</code></td>
<td align="center"><code>neg</code></td>
</tr>
<tr>
<td><code>OneVsRest(::Type{T}, pos::T, neg::AbstractVector{T})</code></td>
<td align="center"><code>pos</code></td>
<td align="center"><code>neg</code></td>
</tr>
<tr>
<td><code>RestVsOne(::Type{T}, pos::AbstractVector{T}, neg::T)</code></td>
<td align="center"><code>pos</code></td>
<td align="center"><code>neg</code></td>
</tr>
</tbody>
</table>
<p>The <code>current_encoding</code> function can be used to verify which encoding is currently in use (by default it is <code>OneZero</code> encoding)</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> enc <span class="pl-k">=</span> <span class="pl-c1">current_encoding</span>()
OneZero{Float64}<span class="pl-k">:</span>
   positive class<span class="pl-k">:</span> <span class="pl-c1">1.0</span>
   negative class<span class="pl-k">:</span> <span class="pl-c1">0.0</span></pre></div>
<p>One way to use a different encoding is to pass the new encoding as the first argument</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> enc_new <span class="pl-k">=</span> <span class="pl-c1">OneVsOne</span>(<span class="pl-c1">:positive</span>, <span class="pl-c1">:negative</span>)
OneVsOne{Symbol}<span class="pl-k">:</span>
   positive class<span class="pl-k">:</span> positive
   negative class<span class="pl-k">:</span> negative

julia<span class="pl-k">&gt;</span> targets_recoded <span class="pl-k">=</span> <span class="pl-c1">recode</span>.(enc, enc_new, targets);

julia<span class="pl-k">&gt;</span> predicts_recoded <span class="pl-k">=</span> <span class="pl-c1">recode</span>.(enc, enc_new, predicts);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(enc, targets, predicts)
<span class="pl-c1">0.33962264150943394</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(enc_new, targets_recoded, predicts_recoded)
<span class="pl-c1">0.33962264150943394</span></pre></div>
<p>The second way is to change the current encoding to the one you want</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">set_encoding</span>(<span class="pl-c1">OneVsOne</span>(<span class="pl-c1">:positive</span>, <span class="pl-c1">:negative</span>))
OneVsOne{Symbol}<span class="pl-k">:</span>
   positive class<span class="pl-k">:</span> positive
   negative class<span class="pl-k">:</span> negative

julia<span class="pl-k">&gt;</span> <span class="pl-c1">recall</span>(targets_recoded, predicts_recoded)
<span class="pl-c1">0.33962264150943394</span></pre></div>
<h3><a id="user-content-decision-thresholds-for-classification" class="anchor" aria-hidden="true" href="#decision-thresholds-for-classification"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Decision thresholds for classification</h3>
<p>The package provides a <code>thresholds(scores::RealVector, n::Int)</code> , which returns <code>n</code> decision thresholds which correspond to <code>n</code> evenly spaced quantiles of the given <code>scores</code> vector. The default value of <code>n</code> is <code>length(scores) + 1</code>.  The <code>thresholds</code> function has two keyword arguments <code>reduced::Bool</code> and <code>zerorecall::Bool</code></p>
<ul>
<li>If <code>reduced</code> is <code>true</code> (default), then the function returns <code>min(length(scores) + 1, n)</code> thresholds.</li>
<li>If <code>zerorecall</code>  is <code>true</code> (default), then the largest threshold is <code>maximum(scores)*(1 + eps())</code> otherwise <code>maximum(scores)</code>.</li>
</ul>
<p>The package also provides some other useful utilities</p>
<ul>
<li><code>threshold_at_tpr(target::IntegerVector, scores::RealVector, tpr::Real)</code> returns the largest threshold <code>t</code> that satisfies <code>true_positive_rate(target, scores, t) &gt;= tpr</code></li>
<li><code>threshold_at_tnr(target::IntegerVector, scores::RealVector, tnr::Real)</code>returns the smallest threshold <code>t</code> that satisfies <code>true_negative_rate(target, scores, t) &gt;= tnr</code></li>
<li><code>threshold_at_fpr(target::IntegerVector, scores::RealVector, fpr::Real)</code> returns the smallest threshold <code>t</code> that satisfies <code>false_positive_rate(target, scores, t) &lt;= fpr</code></li>
<li><code>threshold_at_fnr(target::IntegerVector, scores::RealVector, fnr::Real)</code> returns the largest threshold <code>t</code> that satisfies <code>false_negative_rate(target, scores, t) &lt;= fnr</code></li>
</ul>
</article></div>