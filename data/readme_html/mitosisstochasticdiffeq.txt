<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-mitosisstochasticdiffeqjl" class="anchor" aria-hidden="true" href="#mitosisstochasticdiffeqjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MitosisStochasticDiffEq.jl</h1>
<p dir="auto"><a href="https://mschauer.github.io/MitosisStochasticDiffEq.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://mschauer.github.io/MitosisStochasticDiffEq.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/mschauer/MitosisStochasticDiffEq.jl/actions"><img src="https://github.com/mschauer/MitosisStochasticDiffEq.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto">Implements the <a href="https://github.com/mschauer/Mitosis.jl">Mitosis transformation rules</a> <code>backwardfilter</code> and <code>forwardguiding</code> for SciML's <a href="https://github.com/SciML/StochasticDiffEq.jl"><code>StochasticDiffEq</code></a> problems.</p>
<p dir="auto">If the (possibly non-linear) drift depends linearly on parameters, estimate the parameters from continuous observations by <code>regression</code>.</p>
<p dir="auto"><a href="https://www.youtube.com/watch?v=rie7MTvPpIs" rel="nofollow"><img src="https://camo.githubusercontent.com/57a97cba08ff441964d0f56e181bcd0dbcb7a2e25e8b252eccf5204fce1986f9/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f726965374d5476507049732f302e6a7067" alt="MitosisStochasticDiffEq.jl - Filtering &amp; Guiding for SDEs | Frank Schäfer | JuliaCon2021E" data-canonical-src="https://img.youtube.com/vi/rie7MTvPpIs/0.jpg" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-synopsis" class="anchor" aria-hidden="true" href="#synopsis"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Synopsis</h2>
<p dir="auto"><em>MitosisStochasticDiffEq</em> implements the backward filter and the forward change of measure  of the Automatic Backward Filtering Forward Guiding paradigm  (van der Meulen and Schauer, 2020) as transformation rules for SDE models,  suitable to be incorporated into probabilistic programming approaches.</p>
<p dir="auto">In particular, this package implements the equations ... of section 9.1, [2] further detailed in [1]. The recursion for the quantity c in [1, Theorem 3.3 (Information filter)] is replaced by the simpler rule from [2, Example 10.8.]</p>
<h2 dir="auto"><a id="user-content-show-reel" class="anchor" aria-hidden="true" href="#show-reel"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Show reel</h2>
<h3 dir="auto"><a id="user-content-bayesian-regression-on-the-drift-parameter-of-an-sde" class="anchor" aria-hidden="true" href="#bayesian-regression-on-the-drift-parameter-of-an-sde"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Bayesian regression on the drift parameter of an SDE</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using StochasticDiffEq
using Random
using MitosisStochasticDiffEq
import MitosisStochasticDiffEq as MSDE
using LinearAlgebra, Statistics

# Model and sensitivity
function f(du, u, θ, t)
    c = 0.2 * θ
    du[1] = -0.1 * u[1] + c * u[2]
    du[2] = - c * u[1] - 0.1 * u[2]
    return
end
function g(du, u, θ, t)
    fill!(du, 0.15)
    return
end

# b is linear in the parameter with Jacobian
function b_jac(J,x,θ,t)
    J .= false
    J[1,1] =   0.2 * x[2]
    J[2,1] = - 0.2 * x[1]
    nothing
end
# and intercept
function b_icpt(dx,x,θ,t)
    dx .= false
    dx[1] = -0.1 * x[1]
    dx[2] = -0.1 * x[2]
    nothing
end

# Simulate path ensemble
x0 = [1.0, 1.0]
tspan = (0.0, 20.0)
θ0 = 1.0
dt = 0.05
t = range(tspan...; step=dt)

prob = SDEProblem{true}(f, g, x0, tspan, θ0)
ensembleprob = EnsembleProblem(prob)
ensemblesol = solve(
    ensembleprob, EM(), EnsembleThreads(); dt=dt, saveat=t, trajectories=1000
)

# Inference on drift parameters
sdekernel = MSDE.SDEKernel(f,g,t,0*θ0)
ϕprototype = zeros((length(x0),length(θ0))) # prototypes for vectors
yprototype = zeros((length(x0),))
R = MSDE.Regression!(sdekernel,yprototype,paramjac_prototype=ϕprototype,paramjac=b_jac,intercept=b_icpt)
prior_precision = 0.1I(1)
posterior = MSDE.conjugate(R, ensemblesol, prior_precision)
print(mean(posterior)[], &quot; ± &quot;, sqrt(cov(posterior)[]))"><pre><span class="pl-k">using</span> StochasticDiffEq
<span class="pl-k">using</span> Random
<span class="pl-k">using</span> MitosisStochasticDiffEq
<span class="pl-k">import</span> MitosisStochasticDiffEq <span class="pl-k">as</span> MSDE
<span class="pl-k">using</span> LinearAlgebra, Statistics

<span class="pl-c"><span class="pl-c">#</span> Model and sensitivity</span>
<span class="pl-k">function</span> <span class="pl-en">f</span>(du, u, θ, t)
    c <span class="pl-k">=</span> <span class="pl-c1">0.2</span> <span class="pl-k">*</span> θ
    du[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0.1</span> <span class="pl-k">*</span> u[<span class="pl-c1">1</span>] <span class="pl-k">+</span> c <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]
    du[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span> c <span class="pl-k">*</span> u[<span class="pl-c1">1</span>] <span class="pl-k">-</span> <span class="pl-c1">0.1</span> <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]
    <span class="pl-k">return</span>
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">g</span>(du, u, θ, t)
    <span class="pl-c1">fill!</span>(du, <span class="pl-c1">0.15</span>)
    <span class="pl-k">return</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> b is linear in the parameter with Jacobian</span>
<span class="pl-k">function</span> <span class="pl-en">b_jac</span>(J,x,θ,t)
    J <span class="pl-k">.=</span> <span class="pl-c1">false</span>
    J[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span>   <span class="pl-c1">0.2</span> <span class="pl-k">*</span> x[<span class="pl-c1">2</span>]
    J[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">-</span> <span class="pl-c1">0.2</span> <span class="pl-k">*</span> x[<span class="pl-c1">1</span>]
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> and intercept</span>
<span class="pl-k">function</span> <span class="pl-en">b_icpt</span>(dx,x,θ,t)
    dx <span class="pl-k">.=</span> <span class="pl-c1">false</span>
    dx[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0.1</span> <span class="pl-k">*</span> x[<span class="pl-c1">1</span>]
    dx[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0.1</span> <span class="pl-k">*</span> x[<span class="pl-c1">2</span>]
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Simulate path ensemble</span>
x0 <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>]
tspan <span class="pl-k">=</span> (<span class="pl-c1">0.0</span>, <span class="pl-c1">20.0</span>)
θ0 <span class="pl-k">=</span> <span class="pl-c1">1.0</span>
dt <span class="pl-k">=</span> <span class="pl-c1">0.05</span>
t <span class="pl-k">=</span> <span class="pl-c1">range</span>(tspan<span class="pl-k">...</span>; step<span class="pl-k">=</span>dt)

prob <span class="pl-k">=</span> <span class="pl-c1">SDEProblem</span><span class="pl-c1">{true}</span>(f, g, x0, tspan, θ0)
ensembleprob <span class="pl-k">=</span> <span class="pl-c1">EnsembleProblem</span>(prob)
ensemblesol <span class="pl-k">=</span> <span class="pl-c1">solve</span>(
    ensembleprob, <span class="pl-c1">EM</span>(), <span class="pl-c1">EnsembleThreads</span>(); dt<span class="pl-k">=</span>dt, saveat<span class="pl-k">=</span>t, trajectories<span class="pl-k">=</span><span class="pl-c1">1000</span>
)

<span class="pl-c"><span class="pl-c">#</span> Inference on drift parameters</span>
sdekernel <span class="pl-k">=</span> MSDE<span class="pl-k">.</span><span class="pl-c1">SDEKernel</span>(f,g,t,<span class="pl-c1">0</span><span class="pl-k">*</span>θ0)
ϕprototype <span class="pl-k">=</span> <span class="pl-c1">zeros</span>((<span class="pl-c1">length</span>(x0),<span class="pl-c1">length</span>(θ0))) <span class="pl-c"><span class="pl-c">#</span> prototypes for vectors</span>
yprototype <span class="pl-k">=</span> <span class="pl-c1">zeros</span>((<span class="pl-c1">length</span>(x0),))
R <span class="pl-k">=</span> MSDE<span class="pl-k">.</span><span class="pl-c1">Regression!</span>(sdekernel,yprototype,paramjac_prototype<span class="pl-k">=</span>ϕprototype,paramjac<span class="pl-k">=</span>b_jac,intercept<span class="pl-k">=</span>b_icpt)
prior_precision <span class="pl-k">=</span> <span class="pl-c1">0.1</span><span class="pl-c1">I</span>(<span class="pl-c1">1</span>)
posterior <span class="pl-k">=</span> MSDE<span class="pl-k">.</span><span class="pl-c1">conjugate</span>(R, ensemblesol, prior_precision)
<span class="pl-c1">print</span>(<span class="pl-c1">mean</span>(posterior)[], <span class="pl-s"><span class="pl-pds">"</span> ± <span class="pl-pds">"</span></span>, <span class="pl-c1">sqrt</span>(<span class="pl-c1">cov</span>(posterior)[]))</pre></div>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<ul dir="auto">
<li>[1] Marcin Mider, Moritz Schauer, Frank van der Meulen (2020): Continuous-discrete smoothing of diffusions. <a href="https://arxiv.org/abs/arxiv:1712.03807" rel="nofollow">[arxiv:1712.03807]</a>.</li>
<li>[2] Frank van der Meulen, Moritz Schauer (2020): Automatic Backward Filtering Forward Guiding for Markov processes and graphical models. <a href="https://arxiv.org/abs/2010.03509" rel="nofollow">[arXiv:2010.03509]</a>.</li>
</ul>
</article></div>