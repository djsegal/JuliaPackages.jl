<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-implicit-3d-plots" class="anchor" aria-hidden="true" href="#implicit-3d-plots"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implicit 3D Plots</h1>
<p>Visualizing parametrized space curves or surfaces is not complicated: We simply need to iterate the parametrization's domain (usually <a target="_blank" rel="noopener noreferrer" href="https://render.githubusercontent.com/render/math?math=\mathbb{R}"><img src="https://render.githubusercontent.com/render/math?math=\mathbb{R}" style="max-width:100%;"></a>) and get a reasonably smooth plot as a result. Implicitly defined surfaces and curves pose a problem however: If we were to proceed in a similar manner, we would have to iterate through <a target="_blank" rel="noopener noreferrer" href="https://render.githubusercontent.com/render/math?math=\mathbb{R}^3"><img src="https://render.githubusercontent.com/render/math?math=\mathbb{R}^3" style="max-width:100%;"></a> and check, whether the implicit equations are 0 in any of the points. This approach is problematic in two ways. Firstly, numerics and potentially instable implicit functions prohibit this method: It is unlikely, that we will find rational points that actually lie on the curve or surface in this way. Generally, this method will only yield points that <em>approximately</em> lie on the implicit set. However, this we could cope with: the grid can be chosen arbitrarily small, so thoretically we could reach machine presision with this method - at the expense of a reasonable runtime. More problematically however, there is no natural notion of what point <em>comes next</em> on the curve or surface. In the case of parametrized curves, we always know the next point on the curve, because there is a natural total order on <a target="_blank" rel="noopener noreferrer" href="https://render.githubusercontent.com/render/math?math=\mathbb{R}"><img src="https://render.githubusercontent.com/render/math?math=\mathbb{R}" style="max-width:100%;"></a>. Finding the next point on a parametrized curve is harder, as the proximity of points is an insufficient criterion in this setting, as the closest point might not be unique.</p>
<p>Drawing inspiration from the Julia package <a href="https://github.com/saschatimme/ImplicitPlots.jl" title="ImplicitPlots.jl">ImplicitPlots.jl</a> there is a way out from this dilemma though. Using the library <a href="https://github.com/JuliaGeometry/Meshing.jl" title="Meshing.jl">Meshing.jl</a> immediately enables us to sample an implicit surface and form a mesh between the points that covers the surface. For implicit space curves, let us recall that if the space curve can be represented by two equations, we can simply intersect the two corresponding surfaces to obtain the space curve. For this reason, we can utilize the previously mentioned meshes and intersect them.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(url=&quot;https://github.com/matthiashimmelmann/Implicit3DPlotting.jl.git&quot;)
"><pre><code>using Pkg
Pkg.add(url="https://github.com/matthiashimmelmann/Implicit3DPlotting.jl.git")
</code></pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>There are two main methods in this package: <code>plot_implicit_surface</code> and <code>plot_implicit_curve</code>. Let us first consider an example of the former:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; f(x) = x[1]^2+x[2]^2-x[3]^2-1
julia&gt; scene = plot_implicit_surface(f; transparency=false)
"><pre><code>julia&gt; f(x) = x[1]^2+x[2]^2-x[3]^2-1
julia&gt; scene = plot_implicit_surface(f; transparency=false)
</code></pre></div>
<p>The result of this can be seen in the following image:</p>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/65544132/114864346-2b0ec700-9df1-11eb-8ad4-4ef2d4e1c9f3.png"><img src="https://user-images.githubusercontent.com/65544132/114864346-2b0ec700-9df1-11eb-8ad4-4ef2d4e1c9f3.png" width="600" height="600" style="max-width:100%;"></a>
</p>
<p>Notice that the standard options are that the plot's color is <code>:steelblue</code>, the plot is transparent, the surface's shading is activated and the standard meshing method is <code>MarchingCubes</code>, because it is slightly faster than <code>MarchingTetrahedra</code>.</p>
<p>As an example of the latter method, let us consider the input</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; f(x)=x[1]^2+x[2]^2-x[3]^2-1
julia&gt; g(x)=x[1]^2+x[2]^2+x[3]^2-2
julia&gt; plot_implicit_curve(f, g)
"><pre><code>julia&gt; f(x)=x[1]^2+x[2]^2-x[3]^2-1
julia&gt; g(x)=x[1]^2+x[2]^2+x[3]^2-2
julia&gt; plot_implicit_curve(f, g)
</code></pre></div>
<p>which produces the following picture:</p>
<p align="center">
  <a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/65544132/114867917-a1152d00-9df5-11eb-9b38-b1fd69a8ce8f.png"><img src="https://user-images.githubusercontent.com/65544132/114867917-a1152d00-9df5-11eb-9b38-b1fd69a8ce8f.png" width="600" height="600" style="max-width:100%;"></a>
</p>
<p>In this context, it is important to notice that the two implicit surfaces generated by the implicit equations need to lie in relative general position. If they are only kissing, the mesh might not be able to reflect their intersection properly.</p>
</article></div>