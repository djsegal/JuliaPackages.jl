<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-implicit-3d-plots" class="anchor" aria-hidden="true" href="#implicit-3d-plots"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implicit 3D Plots</h1>
<p dir="auto">Visualizing parametrized space curves or surfaces is not complicated: We simply need to iterate the parametrization's domain (usually <a target="_blank" rel="noopener noreferrer nofollow" href="https://render.githubusercontent.com/render/math?math=\mathbb{R}"><img src="https://render.githubusercontent.com/render/math?math=\mathbb{R}" style="max-width: 100%;"></a>) and get a reasonably smooth plot as a result. Implicitly defined surfaces and curves pose a problem however: If we were to proceed in a similar manner, we would have to iterate through <a target="_blank" rel="noopener noreferrer nofollow" href="https://render.githubusercontent.com/render/math?math=\mathbb{R}^3"><img src="https://render.githubusercontent.com/render/math?math=\mathbb{R}^3" style="max-width: 100%;"></a> and check, whether the implicit equations are 0 in any of the points. This approach is problematic in two ways. Firstly, numerics and potentially instable implicit functions prohibit this method: It is unlikely, that we will find rational points that actually lie on the curve or surface in this way. Generally, this method will only yield points that <em>approximately</em> lie on the implicit set. However, this we could cope with: the grid can be chosen arbitrarily small, so thoretically we could reach machine presision with this method - at the expense of a reasonable runtime. More problematically however, there is no natural notion of what point <em>comes next</em> on the curve or surface. In the case of parametrized curves, we always know the next point on the curve, because there is a natural total order on <a target="_blank" rel="noopener noreferrer nofollow" href="https://render.githubusercontent.com/render/math?math=\mathbb{R}"><img src="https://render.githubusercontent.com/render/math?math=\mathbb{R}" style="max-width: 100%;"></a>. Finding the next point on an implicit curve is harder, as the proximity of points is an insufficient criterion in this setting and the closest point might not be unique.</p>
<p dir="auto">Drawing inspiration from the Julia package <a href="https://github.com/saschatimme/ImplicitPlots.jl" title="ImplicitPlots.jl">ImplicitPlots.jl</a> there is a way out from this dilemma though. Using the library <a href="https://github.com/JuliaGeometry/Meshing.jl" title="Meshing.jl">Meshing.jl</a> immediately enables us to sample an implicit surface and form a mesh between the points that covers the surface. For implicit space curves, let us recall that since a space curve can be represented by two equations, we can simply intersect the two corresponding surfaces to obtain an approximation. For this reason, we can utilize the previously mentioned meshes and intersect them. Afterwards, <a href="https://github.com/JuliaPlots/Makie.jl" title="Makie.jl">Makie.jl</a> is utilized to visualize the outcome.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; ]
(@v1.7) pkg&gt; add Implicit3DPlotting"><pre class="notranslate"><code>julia&gt; ]
(@v1.7) pkg&gt; add Implicit3DPlotting
</code></pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">There are two main methods in this package: <code>plot_implicit_surface</code> and <code>plot_implicit_curve</code>. Let us first consider an example of the former:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; f(x) = x[1]^2+x[2]^2-x[3]^2-1
julia&gt; scene = plot_implicit_surface(f; transparency=false, xlims=(-3,3), ylims=(-3,3), zlims=(-3,3))"><pre class="notranslate"><code>julia&gt; f(x) = x[1]^2+x[2]^2-x[3]^2-1
julia&gt; scene = plot_implicit_surface(f; transparency=false, xlims=(-3,3), ylims=(-3,3), zlims=(-3,3))
</code></pre></div>
<p dir="auto">The result of this can be seen in the following image:</p>
<p align="center" dir="auto">
  <a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/65544132/114864346-2b0ec700-9df1-11eb-8ad4-4ef2d4e1c9f3.png"><img src="https://user-images.githubusercontent.com/65544132/114864346-2b0ec700-9df1-11eb-8ad4-4ef2d4e1c9f3.png" width="600" height="600" style="max-width: 100%;"></a>
</p>
<p dir="auto">Notice that the standard options are that the plot's color is <code>:steelblue</code>, the plot is transparent, the surface's shading is activated, the standard meshing method is <code>MarchingCubes</code>, because it is slightly faster than <code>MarchingTetrahedra</code>, and the standard search domain is the hypercube <code>[-3,3]^3</code> per default. All these settings can be changed in the package's methods. All possible options are listed at the end of the README file.</p>
<p dir="auto">As an example of the <code>plot_implicit_curve</code>, let us consider the input</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; f(x)=x[1]^2+x[2]^2-x[3]^2-1
julia&gt; g(x)=x[1]^2+x[2]^2+x[3]^2-2
julia&gt; plot_implicit_curve(f, g)"><pre class="notranslate"><code>julia&gt; f(x)=x[1]^2+x[2]^2-x[3]^2-1
julia&gt; g(x)=x[1]^2+x[2]^2+x[3]^2-2
julia&gt; plot_implicit_curve(f, g)
</code></pre></div>
<p dir="auto">which produces the following picture:</p>
<p align="center" dir="auto">
  <a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/65544132/114867917-a1152d00-9df5-11eb-9b38-b1fd69a8ce8f.png"><img src="https://user-images.githubusercontent.com/65544132/114867917-a1152d00-9df5-11eb-9b38-b1fd69a8ce8f.png" width="600" height="600" style="max-width: 100%;"></a>
</p>
<p dir="auto">In this context, it is important to notice that the two implicit surfaces generated by the implicit equations need to lie in relative general position. If they are only kissing, the mesh might not be able to reflect their intersection properly.</p>
<p dir="auto">Since the 0.1.7 update, it is possible to use different Makie backends. In particular, the OpenGL-based backend <code>GLMakie</code> and the WebGL-based backend <code>WGLMakie</code> are admissible. The default is <code>GLMakie</code>. They can be called via the boolean input <code>WGLMode</code> that is accepted by all exported methods by the package <code>Implicit3DPlotting</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; plot_implicit_surface(f; WGLMode=false) # to use the GLMakie backend
julia&gt; plot_implicit_curve(f, g; WGLMode=true) # to use the WGLMakie backend"><pre class="notranslate"><code>julia&gt; plot_implicit_surface(f; WGLMode=false) # to use the GLMakie backend
julia&gt; plot_implicit_curve(f, g; WGLMode=true) # to use the WGLMakie backend
</code></pre></div>
<h2 dir="auto"><a id="user-content-options" class="anchor" aria-hidden="true" href="#options"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Options</h2>
<p dir="auto">The options that can be changed in the methods for plotting 3D curves and surfaces are given below. They should be added after the semicolon in the methods <code>plot_implicit_curve</code> or <code>plot_implicit_surface</code>, e.g. as follows: <code>plot_implicit_surface(f; kwargs...)</code>.</p>
<ul dir="auto">
<li><code>xlims</code>, <code>ylims</code> and <code>zlims</code> are vectors that determine the search domain for the meshing algorithms: <code>xlims = (-3,3)</code>,</li>
<li><code>color = :steelblue</code>,</li>
<li>For surfaces: <code>transparency = true</code>,</li>
<li>For surfaces: <code>shading = true</code>,</li>
<li>For surfaces: Do we want the plot to be displayed as a 1-skeleton (wireframe) or a surface? <code>wireframe = false</code>,</li>
<li>For surfaces: Add a color map dependent on the surface's <a target="_blank" rel="noopener noreferrer nofollow" href="https://render.githubusercontent.com/render/math?math=z"><img src="https://render.githubusercontent.com/render/math?math=z" style="max-width: 100%;"></a>-value by <code>zcolormap = :viridis</code> (for other color schemes, see <a href="https://docs.juliaplots.org/latest/generated/colorschemes/" rel="nofollow">https://docs.juliaplots.org/latest/generated/colorschemes/</a>),</li>
<li>Marching tetrahedra or marching cubes? <code>MarchingModeIsCubes = true</code>,</li>
<li>Samples determine the accuracy of the plot's display. The higher the sampling numbers, the better. <code>samples=(35,35,35)</code>,</li>
<li>Display axes? <code>show_axis = true</code>,</li>
<li><code>resolution=(800,800)</code>,</li>
<li><code>scale_plot=false</code>,</li>
<li>Should the plot be displayed in-line or in an external window? <code>in_line=false</code>,</li>
<li>For curves: How thick should the linestroke be? <code>linewidth = 1.5</code>,</li>
<li>We can rescale the plot with <code>scaling = (x,y,z)</code>,</li>
<li>Other <code>GLMakie</code>-based <code>kwargs...</code> (see <a href="https://makie.juliaplots.org/stable/" rel="nofollow">https://makie.juliaplots.org/stable/</a>).</li>
</ul>
</article></div>