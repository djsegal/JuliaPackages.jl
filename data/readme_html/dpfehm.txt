<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-dpfehm-a-differentiable-subsurface-physics-simulator" class="anchor" aria-hidden="true" href="#dpfehm-a-differentiable-subsurface-physics-simulator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DPFEHM: A Differentiable Subsurface Physics Simulator</h1>
<p dir="auto"><a href="https://codecov.io/gh/OrchardLANL/DPFEHM.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a1e1bf515f39784f3732252c039bdc154a17013b59d57c53d12725bcac1e1246/68747470733a2f2f636f6465636f762e696f2f67682f4f7263686172644c414e4c2f44504645484d2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f6c6162656c3d636f6465636f76" alt="codecov" data-canonical-src="https://codecov.io/gh/OrchardLANL/DPFEHM.jl/branch/master/graph/badge.svg?label=codecov" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-description" class="anchor" aria-hidden="true" href="#description"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Description</h2>
<p dir="auto">DPFEHM is a <a href="http://julialang.org/" rel="nofollow">Julia</a> module that includes differentiable numerical models with a focus on the Earth's subsurface, especially fluid flow. Currently it supports the groundwater flow equations (single phase flow), Richards equation (air/water), the advection-dispersion equation, and the 2d wave equation. Since it is differentiable, it can easily be combined with machine learning models in a workflow such as this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/OrchardLANL/DPFEHM.jl/blob/c7665b027edd8bb8bfed70d25bb8b869caf254bf/examples/pressure_management/pressure_management_workflow.png"><img src="https://github.com/OrchardLANL/DPFEHM.jl/raw/c7665b027edd8bb8bfed70d25bb8b869caf254bf/examples/pressure_management/pressure_management_workflow.png" alt="Pressure management with DPFEHM and machine learning" style="max-width: 100%;"></a></p>
<p dir="auto">This workflow shows how to train a machine learning model to mitigate problems with injecting fluid into the earth's subsurface (such as induced seismicity or leakage of carbon dioxide). More details on this workflow are available <a href="https://arxiv.org/abs/2206.10718" rel="nofollow">here</a>.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Within Julia, you can install DPFEHM and test that it works by running</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import Pkg
Pkg.add(&quot;DPFEHM&quot;)
Pkg.test(&quot;DPFEHM&quot;)"><pre><span class="pl-k">import</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>DPFEHM<span class="pl-pds">"</span></span>)
Pkg<span class="pl-k">.</span><span class="pl-c1">test</span>(<span class="pl-s"><span class="pl-pds">"</span>DPFEHM<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic Usage</h2>
<p dir="auto">The <a href="https://github.com/OrchardLANL/DPFEHM.jl/tree/master/examples">examples</a> are a good place to get started to see how to use DPFEHM. Two examples will be described in detail here that illustrate the basic usage patterns via an examples of steady-state single-phase flow and transient Richards equation.</p>
<h3 dir="auto"><a id="user-content-steady-state-single-phase-flow" class="anchor" aria-hidden="true" href="#steady-state-single-phase-flow"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><a href="https://github.com/OrchardLANL/DPFEHM.jl/blob/master/examples/gw_steadystate_3d/inputdeck.jl">Steady-state single-phase flow</a></h3>
<p dir="auto">Here, we solve a steady-state single phase flow problem . Let's start by importing several libraries that we will use.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import DPFEHM
import GaussianRandomFields
import Optim
import PyPlot
import Random
import Zygote
Random.seed!(0)#set the seed so we can reproduce the same results with each run"><pre><span class="pl-k">import</span> DPFEHM
<span class="pl-k">import</span> GaussianRandomFields
<span class="pl-k">import</span> Optim
<span class="pl-k">import</span> PyPlot
<span class="pl-k">import</span> Random
<span class="pl-k">import</span> Zygote
Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">0</span>)<span class="pl-c"><span class="pl-c">#</span>set the seed so we can reproduce the same results with each run</span></pre></div>
<p dir="auto">Next, we'll set up the grid. Here, we use a regular grid with 100,000 nodes that covers a domain that is 50 meters by 50 meters by 5 meters.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mins = [0, 0, 0]; maxs = [50, 50, 5]#size of the domain, in meters
ns = [100, 100, 10]#number of nodes on the grid
coords, neighbors, areasoverlengths, _ = DPFEHM.regulargrid3d(mins, maxs, ns)#build the grid"><pre>mins <span class="pl-k">=</span> [<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>]; maxs <span class="pl-k">=</span> [<span class="pl-c1">50</span>, <span class="pl-c1">50</span>, <span class="pl-c1">5</span>]<span class="pl-c"><span class="pl-c">#</span>size of the domain, in meters</span>
ns <span class="pl-k">=</span> [<span class="pl-c1">100</span>, <span class="pl-c1">100</span>, <span class="pl-c1">10</span>]<span class="pl-c"><span class="pl-c">#</span>number of nodes on the grid</span>
coords, neighbors, areasoverlengths, _ <span class="pl-k">=</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">regulargrid3d</span>(mins, maxs, ns)<span class="pl-c"><span class="pl-c">#</span>build the grid</span></pre></div>
<p dir="auto">The result of this grid-building is three variables that we will use. The, <code>coords</code> is a matrix describing the coordinates of the cell centers on the grid. The second, <code>neighbors</code>, is an array describing which cells neighbor other cells. The third, <code>areasoverlengths</code>, is another array whose length is equal to the length of <code>neighbors</code> and describes the area of the interface between two neighboring cells dividing by the length between the cell centers. The last variable is dumped to <code>_</code> and gives the volumes of the cells. The volumes of the cells are not needed for steady state problems, so they are not used in this example.</p>
<p dir="auto">Now we set up the boundary conditions.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Qs = zeros(size(coords, 2))
injectionnode = 1#inject in the lower left corner
Qs[injectionnode] = 1e-4#m^3/s
dirichletnodes = Int[size(coords, 2)]#fix the pressure in the upper right corner
dirichleths = zeros(size(coords, 2))
dirichleths[size(coords, 2)] = 0.0"><pre>Qs <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>))
injectionnode <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-c"><span class="pl-c">#</span>inject in the lower left corner</span>
Qs[injectionnode] <span class="pl-k">=</span> <span class="pl-c1">1e-4</span><span class="pl-c"><span class="pl-c">#</span>m^3/s</span>
dirichletnodes <span class="pl-k">=</span> Int[<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>)]<span class="pl-c"><span class="pl-c">#</span>fix the pressure in the upper right corner</span>
dirichleths <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>))
dirichleths[<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>)] <span class="pl-k">=</span> <span class="pl-c1">0.0</span></pre></div>
<p dir="auto">The variable <code>Qs</code> describes fluid sources/sinks -- the amount of fluid injected at cell <code>i</code> on the grid is given by <code>Qs[i]</code>. In this example, the only place were we inject fluid is at node 1. Another variable, <code>dirichletnodes</code> is a list of cells at which the pressure will be fixed. In this example, the pressure is fixed at the last cell, which is cell number <code>size(coords, 2)</code>. The variable <code>dirichleths</code> describes the pressures (or heads in hydrology jargon) that the cells are fixed at. Note that the length of <code>dirichleths</code> is <code>size(coords, 2)</code>, but these values are ignored except at the indices that appear in <code>dirichletnodes</code>.</p>
<p dir="auto">The final set-up step before moving on to solving the equations is to construct a heterogeneous conductivity field.
Here, we use the package <code>GaussianRandomFields</code> to construct a conductivity field with a correlation length of 50 meters. The mean of the log-conductivity is <code>1e-4</code>meters/second (note that we use a natural logarithm when defining this), and the standard deviation of the log-conductivity is 1. <code>GaussianRandomFields</code> is used to construct a field in 2 dimensions and then it is copied through each of the layers, so that the heterogeneity only exists in the x and y coordinate directions, but not in the z direction.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="lambda = 50.0#meters -- correlation length of log-conductivity
sigma = 1.0#standard deviation of log-conductivity
mu = -9.0#mean of log conductivity -- ~1e-4 m/s, like clean sand here https://en.wikipedia.org/wiki/Hydraulic_conductivity#/media/File:Groundwater_Freeze_and_Cherry_1979_Table_2-2.png
cov = GaussianRandomFields.CovarianceFunction(2, GaussianRandomFields.Matern(lambda, 1; σ=sigma))
x_pts = range(mins[1], maxs[1]; length=ns[1])
y_pts = range(mins[2], maxs[2]; length=ns[2])
num_eigenvectors = 200
grf = GaussianRandomFields.GaussianRandomField(cov, GaussianRandomFields.KarhunenLoeve(num_eigenvectors), x_pts, y_pts)
logKs = zeros(reverse(ns)...)
logKs2d = mu .+ GaussianRandomFields.sample(grf)'#generate a random realization of the log-conductivity field
for i = 1:ns[3]#copy the 2d field to each of the 3d layers
	v = view(logKs, i, :, :)
	v .= logKs2d
end"><pre>lambda <span class="pl-k">=</span> <span class="pl-c1">50.0</span><span class="pl-c"><span class="pl-c">#</span>meters -- correlation length of log-conductivity</span>
sigma <span class="pl-k">=</span> <span class="pl-c1">1.0</span><span class="pl-c"><span class="pl-c">#</span>standard deviation of log-conductivity</span>
mu <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">9.0</span><span class="pl-c"><span class="pl-c">#</span>mean of log conductivity -- ~1e-4 m/s, like clean sand here https://en.wikipedia.org/wiki/Hydraulic_conductivity#/media/File:Groundwater_Freeze_and_Cherry_1979_Table_2-2.png</span>
cov <span class="pl-k">=</span> GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">CovarianceFunction</span>(<span class="pl-c1">2</span>, GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">Matern</span>(lambda, <span class="pl-c1">1</span>; σ<span class="pl-k">=</span>sigma))
x_pts <span class="pl-k">=</span> <span class="pl-c1">range</span>(mins[<span class="pl-c1">1</span>], maxs[<span class="pl-c1">1</span>]; length<span class="pl-k">=</span>ns[<span class="pl-c1">1</span>])
y_pts <span class="pl-k">=</span> <span class="pl-c1">range</span>(mins[<span class="pl-c1">2</span>], maxs[<span class="pl-c1">2</span>]; length<span class="pl-k">=</span>ns[<span class="pl-c1">2</span>])
num_eigenvectors <span class="pl-k">=</span> <span class="pl-c1">200</span>
grf <span class="pl-k">=</span> GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">GaussianRandomField</span>(cov, GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">KarhunenLoeve</span>(num_eigenvectors), x_pts, y_pts)
logKs <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">reverse</span>(ns)<span class="pl-k">...</span>)
logKs2d <span class="pl-k">=</span> mu <span class="pl-k">.+</span> GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">sample</span>(grf)<span class="pl-k">'</span><span class="pl-c"><span class="pl-c">#</span>generate a random realization of the log-conductivity field</span>
<span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>ns[<span class="pl-c1">3</span>]<span class="pl-c"><span class="pl-c">#</span>copy the 2d field to each of the 3d layers</span>
	v <span class="pl-k">=</span> <span class="pl-c1">view</span>(logKs, i, :, :)
	v <span class="pl-k">.=</span> logKs2d
<span class="pl-k">end</span></pre></div>
<p dir="auto">The conductivity field is shown:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/gw_steadystate_3d/conductivity.png"><img src="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/gw_steadystate_3d/conductivity.png" alt="Conductivity field" style="max-width: 100%;"></a></p>

<p dir="auto">Now, we look to solve the flow problem. First, we define a helper function, <code>logKs2Ks_neighbors</code>. This function is needed because the flow solver wants to know the conductivity on the interface between two cells, but our previous construction defined the conductivities at the cells themselves. It also converts from log-conductivity to conductivity and uses the geometric mean to move from the cells to the interfaces. The heart of this code is the call to <code>DPFEHM.groundwater_steadystate</code>, which solves the single phase steady-state flow problem that we pose. The <code>solveforh</code> function calls this function and returns the result after reshaping.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="logKs2Ks_neighbors(Ks) = exp.(0.5 * (Ks[map(p-&gt;p[1], neighbors)] .+ Ks[map(p-&gt;p[2], neighbors)]))#convert from permeabilities at the nodes to permeabilities connecting the nodes
function solveforh(logKs, dirichleths)
	@assert length(logKs) == length(Qs)
	Ks_neighbors = logKs2Ks_neighbors(logKs)
	return reshape(DPFEHM.groundwater_steadystate(Ks_neighbors, neighbors, areasoverlengths, dirichletnodes, dirichleths, Qs), reverse(ns)...)
	end
end"><pre><span class="pl-en">logKs2Ks_neighbors</span>(Ks) <span class="pl-k">=</span> <span class="pl-c1">exp</span>.(<span class="pl-c1">0.5</span> <span class="pl-k">*</span> (Ks[<span class="pl-c1">map</span>(p<span class="pl-k">-&gt;</span>p[<span class="pl-c1">1</span>], neighbors)] <span class="pl-k">.+</span> Ks[<span class="pl-c1">map</span>(p<span class="pl-k">-&gt;</span>p[<span class="pl-c1">2</span>], neighbors)]))<span class="pl-c"><span class="pl-c">#</span>convert from permeabilities at the nodes to permeabilities connecting the nodes</span>
<span class="pl-k">function</span> <span class="pl-en">solveforh</span>(logKs, dirichleths)
	<span class="pl-c1">@assert</span> <span class="pl-c1">length</span>(logKs) <span class="pl-k">==</span> <span class="pl-c1">length</span>(Qs)
	Ks_neighbors <span class="pl-k">=</span> <span class="pl-c1">logKs2Ks_neighbors</span>(logKs)
	<span class="pl-k">return</span> <span class="pl-c1">reshape</span>(DPFEHM<span class="pl-k">.</span><span class="pl-c1">groundwater_steadystate</span>(Ks_neighbors, neighbors, areasoverlengths, dirichletnodes, dirichleths, Qs), <span class="pl-c1">reverse</span>(ns)<span class="pl-k">...</span>)
	<span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">With this function in hand, we can solve the problem using the <code>solveforh</code> wrapper function we previously defined. This function requires us to explicitly pass in <code>logKs</code> (the hydraulic conductivity) and <code>dirichleths</code> (the fixed-head boundary condition), but the other inputs to <code>DPFEHM.groundwater_steadystate</code> are fixed to global values.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="h = solveforh(logKs, dirichleths)#solve for the head"><pre>h <span class="pl-k">=</span> <span class="pl-c1">solveforh</span>(logKs, dirichleths)<span class="pl-c"><span class="pl-c">#</span>solve for the head</span></pre></div>
<p dir="auto">The head at the bottom layer of the domain is shown (note the pressure is higher in the lower corner, where there is fluid injection, than in the rest of the domain):</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/gw_steadystate_3d/head.png"><img src="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/gw_steadystate_3d/head.png" alt="Head field" style="max-width: 100%;"></a></p>

<p dir="auto">DPFEHM also allows us to compute the gradient of functions involving <code>DPFEHM.groundwater_steadystate</code> using <code>Zygote.gradient</code> or <code>Zygote.pullback</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="isfreenode, nodei2freenodei, freenodei2nodei = DPFEHM.getfreenodes(length(dirichleths), dirichletnodes)
gradient_node = nodei2freenodei[div(size(coords, 2), 2) + 500]
gradient_node_x = coords[1, gradient_node]
gradient_node_y = coords[2, gradient_node]
grad = Zygote.gradient((x, y)-&gt;solveforh(x, y)[gradient_node], logKs, dirichleths)#calculate the gradient (which involves a redundant calculation of the forward pass)
function_evaluation, back = Zygote.pullback((x, y)-&gt;solveforh(x, y)[gradient_node], logKs, dirichleths)#this pullback thing lets us not redo the forward pass
print(&quot;gradient time&quot;)
grad2 = back(1.0)#compute the gradient of a function involving solveforh using Zygote.pullback"><pre>isfreenode, nodei2freenodei, freenodei2nodei <span class="pl-k">=</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">getfreenodes</span>(<span class="pl-c1">length</span>(dirichleths), dirichletnodes)
gradient_node <span class="pl-k">=</span> nodei2freenodei[<span class="pl-c1">div</span>(<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>), <span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">500</span>]
gradient_node_x <span class="pl-k">=</span> coords[<span class="pl-c1">1</span>, gradient_node]
gradient_node_y <span class="pl-k">=</span> coords[<span class="pl-c1">2</span>, gradient_node]
grad <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">gradient</span>((x, y)<span class="pl-k">-&gt;</span><span class="pl-c1">solveforh</span>(x, y)[gradient_node], logKs, dirichleths)<span class="pl-c"><span class="pl-c">#</span>calculate the gradient (which involves a redundant calculation of the forward pass)</span>
function_evaluation, back <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">pullback</span>((x, y)<span class="pl-k">-&gt;</span><span class="pl-c1">solveforh</span>(x, y)[gradient_node], logKs, dirichleths)<span class="pl-c"><span class="pl-c">#</span>this pullback thing lets us not redo the forward pass</span>
<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>gradient time<span class="pl-pds">"</span></span>)
grad2 <span class="pl-k">=</span> <span class="pl-c1">back</span>(<span class="pl-c1">1.0</span>)<span class="pl-c"><span class="pl-c">#</span>compute the gradient of a function involving solveforh using Zygote.pullback</span></pre></div>
<p dir="auto">Note that the function <code>DPFEHM.getfreenodes</code> allows one to map indices between the free nodes (i.e., the ones that do not have fixed-pressure boundary conditions) and all nodes. The gradient of <code>logK</code> at the bottom layer of the domain is shown:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/gw_steadystate_3d/gradient.png"><img src="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/gw_steadystate_3d/gradient.png" alt="Gradient field" style="max-width: 100%;"></a></p>

<h3 dir="auto"><a id="user-content-transient-richards-flow" class="anchor" aria-hidden="true" href="#transient-richards-flow"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><a href="https://github.com/OrchardLANL/DPFEHM.jl/blob/master/examples/richards_transient_3d/inputdeck.jl">Transient Richards flow</a></h3>
<p dir="auto">Now, we consider an example using DPFEHM's solver for <a href="https://en.wikipedia.org/wiki/Richards_equation" rel="nofollow">Richards equation</a>, which can be used to model flow in a porous medium where both air and water fill the pores (i.e., unsaturated flow). This example is similar to the previous example and we again start by importing several libraries, setting up the grid (lower resolution this time), the boundary conditions, and the conductivity.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import DifferentiableBackwardEuler
import DPFEHM
import GaussianRandomFields
import PyPlot
import Random
import Zygote
Random.seed!(0)#set the seed so we get the same permeability over and over

#set up the grid
mins = [0, 0, 0]; maxs = [50, 50, 5]#size of the domain, in meters
ns = [30, 30, 3]#number of nodes on the grid
coords, neighbors, areasoverlengths, volumes = DPFEHM.regulargrid3d(mins, maxs, ns)#build the grid

#set up the boundary conditions
Qs = zeros(size(coords, 2))
injectionnode = 1#inject in the lower left corner
Qs[injectionnode] = 1e-4#m^3/s
dirichletnodes = Int[size(coords, 2)]#fix the pressure in the upper right corner
dirichleths = zeros(size(coords, 2))
dirichleths[size(coords, 2)] = 0.0

#set up the conductivity field
lambda = 50.0#meters -- correlation length of log-conductivity
sigma = 1.0#standard deviation of log-conductivity
mu = -9.0#mean of log conductivity -- ~1e-4 m/s, like clean sand here https://en.wikipedia.org/wiki/Hydraulic_conductivity#/media/File:Groundwater_Freeze_and_Cherry_1979_Table_2-2.png
cov = GaussianRandomFields.CovarianceFunction(2, GaussianRandomFields.Matern(lambda, 1; σ=sigma))
x_pts = range(mins[1], maxs[1]; length=ns[1])
y_pts = range(mins[2], maxs[2]; length=ns[2])
num_eigenvectors = 200
grf = GaussianRandomFields.GaussianRandomField(cov, GaussianRandomFields.KarhunenLoeve(num_eigenvectors), x_pts, y_pts)
logKs = zeros(reverse(ns)...)
logKs2d = mu .+ GaussianRandomFields.sample(grf)'#generate a random realization of the log-conductivity field
for i = 1:ns[3]#copy the 2d field to each of the 3d layers
	v = view(logKs, i, :, :)
	v .= logKs2d
end"><pre><span class="pl-k">import</span> DifferentiableBackwardEuler
<span class="pl-k">import</span> DPFEHM
<span class="pl-k">import</span> GaussianRandomFields
<span class="pl-k">import</span> PyPlot
<span class="pl-k">import</span> Random
<span class="pl-k">import</span> Zygote
Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">0</span>)<span class="pl-c"><span class="pl-c">#</span>set the seed so we get the same permeability over and over</span>

<span class="pl-c"><span class="pl-c">#</span>set up the grid</span>
mins <span class="pl-k">=</span> [<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>]; maxs <span class="pl-k">=</span> [<span class="pl-c1">50</span>, <span class="pl-c1">50</span>, <span class="pl-c1">5</span>]<span class="pl-c"><span class="pl-c">#</span>size of the domain, in meters</span>
ns <span class="pl-k">=</span> [<span class="pl-c1">30</span>, <span class="pl-c1">30</span>, <span class="pl-c1">3</span>]<span class="pl-c"><span class="pl-c">#</span>number of nodes on the grid</span>
coords, neighbors, areasoverlengths, volumes <span class="pl-k">=</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">regulargrid3d</span>(mins, maxs, ns)<span class="pl-c"><span class="pl-c">#</span>build the grid</span>

<span class="pl-c"><span class="pl-c">#</span>set up the boundary conditions</span>
Qs <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>))
injectionnode <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-c"><span class="pl-c">#</span>inject in the lower left corner</span>
Qs[injectionnode] <span class="pl-k">=</span> <span class="pl-c1">1e-4</span><span class="pl-c"><span class="pl-c">#</span>m^3/s</span>
dirichletnodes <span class="pl-k">=</span> Int[<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>)]<span class="pl-c"><span class="pl-c">#</span>fix the pressure in the upper right corner</span>
dirichleths <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>))
dirichleths[<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>)] <span class="pl-k">=</span> <span class="pl-c1">0.0</span>

<span class="pl-c"><span class="pl-c">#</span>set up the conductivity field</span>
lambda <span class="pl-k">=</span> <span class="pl-c1">50.0</span><span class="pl-c"><span class="pl-c">#</span>meters -- correlation length of log-conductivity</span>
sigma <span class="pl-k">=</span> <span class="pl-c1">1.0</span><span class="pl-c"><span class="pl-c">#</span>standard deviation of log-conductivity</span>
mu <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">9.0</span><span class="pl-c"><span class="pl-c">#</span>mean of log conductivity -- ~1e-4 m/s, like clean sand here https://en.wikipedia.org/wiki/Hydraulic_conductivity#/media/File:Groundwater_Freeze_and_Cherry_1979_Table_2-2.png</span>
cov <span class="pl-k">=</span> GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">CovarianceFunction</span>(<span class="pl-c1">2</span>, GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">Matern</span>(lambda, <span class="pl-c1">1</span>; σ<span class="pl-k">=</span>sigma))
x_pts <span class="pl-k">=</span> <span class="pl-c1">range</span>(mins[<span class="pl-c1">1</span>], maxs[<span class="pl-c1">1</span>]; length<span class="pl-k">=</span>ns[<span class="pl-c1">1</span>])
y_pts <span class="pl-k">=</span> <span class="pl-c1">range</span>(mins[<span class="pl-c1">2</span>], maxs[<span class="pl-c1">2</span>]; length<span class="pl-k">=</span>ns[<span class="pl-c1">2</span>])
num_eigenvectors <span class="pl-k">=</span> <span class="pl-c1">200</span>
grf <span class="pl-k">=</span> GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">GaussianRandomField</span>(cov, GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">KarhunenLoeve</span>(num_eigenvectors), x_pts, y_pts)
logKs <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">reverse</span>(ns)<span class="pl-k">...</span>)
logKs2d <span class="pl-k">=</span> mu <span class="pl-k">.+</span> GaussianRandomFields<span class="pl-k">.</span><span class="pl-c1">sample</span>(grf)<span class="pl-k">'</span><span class="pl-c"><span class="pl-c">#</span>generate a random realization of the log-conductivity field</span>
<span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>ns[<span class="pl-c1">3</span>]<span class="pl-c"><span class="pl-c">#</span>copy the 2d field to each of the 3d layers</span>
	v <span class="pl-k">=</span> <span class="pl-c1">view</span>(logKs, i, :, :)
	v <span class="pl-k">.=</span> logKs2d
<span class="pl-k">end</span></pre></div>

<p dir="auto">Since we'll be solving a time-dependent problem this time, we must set the initial condition and define a storage parameter. Note that in unsaturated flows the storage parameter is often neglected (and this can be achieved by setting <code>specificstorage</code> to an array of ones), but this problem involves a saturated flow so we include it here. Since this is a multi-phase flow problem, we also need to define a couple parameters that control the hydraulic conductivity's dependence on the saturation. The conductivity is given by the conductivity when saturated multiplied by a relative permeability (which depends on the saturation and varies between 0 and 1).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#set up the initial condition, the storage, and the van genuchten parameters for relative permeability
h0 = zeros(size(coords, 2))#initial condition
specificstorage = fill(0.1, size(coords, 2))#storage
alphas = fill(0.5, length(neighbors))#van genuchten relative permeability parameters
Ns = fill(1.25, length(neighbors))"><pre><span class="pl-c"><span class="pl-c">#</span>set up the initial condition, the storage, and the van genuchten parameters for relative permeability</span>
h0 <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>))<span class="pl-c"><span class="pl-c">#</span>initial condition</span>
specificstorage <span class="pl-k">=</span> <span class="pl-c1">fill</span>(<span class="pl-c1">0.1</span>, <span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>))<span class="pl-c"><span class="pl-c">#</span>storage</span>
alphas <span class="pl-k">=</span> <span class="pl-c1">fill</span>(<span class="pl-c1">0.5</span>, <span class="pl-c1">length</span>(neighbors))<span class="pl-c"><span class="pl-c">#</span>van genuchten relative permeability parameters</span>
Ns <span class="pl-k">=</span> <span class="pl-c1">fill</span>(<span class="pl-c1">1.25</span>, <span class="pl-c1">length</span>(neighbors))</pre></div>
<p dir="auto">With the basic description of the problem complete, now we can start to write the code for solving the equations. Note that the <code>solveforh</code> function does not call <code>DPFEHM.richards_steadystate</code> to solve the equations, and instead calls <code>DifferentiableBackwardEuler.steps</code>. The first argument to <code>DifferentiableBackwardEuler.steps</code> is the initial condition, but only at the nodes that are not controlled by the Dirichlet boundary conditions. The most important parts of this call are <code>f_richards</code>, <code>f_richards_u</code>, and <code>f_richards_p</code>, which we will describe in the next paragraph. The argument <code>0.0</code> is the initial time, and <code>60 * 60 * 24 * 365 * 1</code> gives the simulation time (in seconds, so 1 year). The keyword arguments will eventually be passed to <code>DifferentialEquations.solve</code>. The last step adds the boundary conditions back into the solution, which is needed since <code>DifferentiableBackwardEuler.steps</code> only solves the equations on the free nodes (i.e, the nodes where the pressure is not fixed by the boundary conditions).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="logKs2Ks_neighbors(Ks) = exp.(0.5 * (Ks[map(p-&gt;p[1], neighbors)] .+ Ks[map(p-&gt;p[2], neighbors)]))#convert from permeabilities at the nodes to permeabilities at the interface between nodes using the geometric mean
isfreenode, nodei2freenodei, freenodei2nodei = DPFEHM.getfreenodes(length(Qs), dirichletnodes)
function solveforh(logKs, dirichleths)
	@assert length(logKs) == length(Qs)
	Ks_neighbors = logKs2Ks_neighbors(logKs)
	p = [Ks_neighbors; dirichleths]
	h_richards = DifferentiableBackwardEuler.steps(h0[isfreenode], f_richards, f_richards_u, f_richards_p, f_richards_t, p, 0.0, 60 * 60 * 24 * 365 * 1; abstol=1e-1, reltol=1e-1)
	h_with_bcs = hcat(map(i-&gt;DPFEHM.addboundaryconditions(h_richards[:, i], dirichletnodes, dirichleths, isfreenode, nodei2freenodei), 1:size(h_richards, 2))...)#add the dirichlet boundary conditions back
	return h_with_bcs
end"><pre><span class="pl-en">logKs2Ks_neighbors</span>(Ks) <span class="pl-k">=</span> <span class="pl-c1">exp</span>.(<span class="pl-c1">0.5</span> <span class="pl-k">*</span> (Ks[<span class="pl-c1">map</span>(p<span class="pl-k">-&gt;</span>p[<span class="pl-c1">1</span>], neighbors)] <span class="pl-k">.+</span> Ks[<span class="pl-c1">map</span>(p<span class="pl-k">-&gt;</span>p[<span class="pl-c1">2</span>], neighbors)]))<span class="pl-c"><span class="pl-c">#</span>convert from permeabilities at the nodes to permeabilities at the interface between nodes using the geometric mean</span>
isfreenode, nodei2freenodei, freenodei2nodei <span class="pl-k">=</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">getfreenodes</span>(<span class="pl-c1">length</span>(Qs), dirichletnodes)
<span class="pl-k">function</span> <span class="pl-en">solveforh</span>(logKs, dirichleths)
	<span class="pl-c1">@assert</span> <span class="pl-c1">length</span>(logKs) <span class="pl-k">==</span> <span class="pl-c1">length</span>(Qs)
	Ks_neighbors <span class="pl-k">=</span> <span class="pl-c1">logKs2Ks_neighbors</span>(logKs)
	p <span class="pl-k">=</span> [Ks_neighbors; dirichleths]
	h_richards <span class="pl-k">=</span> DifferentiableBackwardEuler<span class="pl-k">.</span><span class="pl-c1">steps</span>(h0[isfreenode], f_richards, f_richards_u, f_richards_p, f_richards_t, p, <span class="pl-c1">0.0</span>, <span class="pl-c1">60</span> <span class="pl-k">*</span> <span class="pl-c1">60</span> <span class="pl-k">*</span> <span class="pl-c1">24</span> <span class="pl-k">*</span> <span class="pl-c1">365</span> <span class="pl-k">*</span> <span class="pl-c1">1</span>; abstol<span class="pl-k">=</span><span class="pl-c1">1e-1</span>, reltol<span class="pl-k">=</span><span class="pl-c1">1e-1</span>)
	h_with_bcs <span class="pl-k">=</span> <span class="pl-c1">hcat</span>(<span class="pl-c1">map</span>(i<span class="pl-k">-&gt;</span>DPFEHM<span class="pl-k">.</span><span class="pl-c1">addboundaryconditions</span>(h_richards[:, i], dirichletnodes, dirichleths, isfreenode, nodei2freenodei), <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(h_richards, <span class="pl-c1">2</span>))<span class="pl-k">...</span>)<span class="pl-c"><span class="pl-c">#</span>add the dirichlet boundary conditions back</span>
	<span class="pl-k">return</span> h_with_bcs
<span class="pl-k">end</span></pre></div>

<p dir="auto">Now, we define the key functions <code>f_richards</code>, <code>f_richards_u</code>, and <code>f_richards_p</code> from the previous paragraph. The function <code>f_richards</code> basically tells <code>DifferentiableBackwardEuler</code> to solve du/dt=<code>f_richards</code> and this is the function <code>richards_residuals</code>. The function <code>f_richards_u</code> is the Jacobian of <code>f_richards</code> with respect to the variable that is being integrated by <code>DifferentiableBackwardEuler</code>. We can compute the Jacobian of <code>richards_residuals</code> with respect to any of its inputs using the function <code>DPFEHM.richards_XYZ</code> where <code>XZY</code> is the name of the argument (as defined within DPFEHM). In the jargon of DPFEHM's Richards equation solve, the variable we are solving for is named <code>psi</code>, so <code>f_richards_u</code> just unpacks the parameters and calls <code>DPFEHM.richards_psi</code>. The function <code>f_richards_p</code> is the Jacobian of <code>f_richards</code> with respect to the parameter <code>p</code>. Since <code>p</code> consists of <code>Ks</code> and <code>dirichleths</code> (or <code>dirichletpsis</code> in the jargon of DPFEHM's Richards solver), we concatenate the two Jacobians <code>DPFEHM.richards_Ks</code> and <code>DPFEHM.richards_dirichletpsis</code>. The last function <code>f_richards_t</code> is currently unused, but in principle should give the Jacobian of <code>f_richards</code> with respect to <code>t</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#set up some functions needed by DifferentiableBackwardEuler
function f_richards(u, p, t)#tells DifferentiableBackwardEuler to solve du/dt=f_richards
	Ks, dirichleths = unpack(p)
	return DPFEHM.richards_residuals(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
end
function f_richards_u(u, p, t)#give DifferentiableBackwardEuler the derivative of f_richards with respect to u -- needed for the backward euler method that we use
	Ks, dirichleths = unpack(p)
	return DPFEHM.richards_psi(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
end
function f_richards_p(u, p, t)#give DifferentiableBackwardEuler the derivative of f_richards with respect to p -- needed for computing gradients with respect to p of functions involving the richards equation solution
	Ks, dirichleths = unpack(p)
	J1 = DPFEHM.richards_Ks(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
	J2 = DPFEHM.richards_dirichletpsis(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
	return hcat(J1, J2)
end
f_richards_t(u, p, t) = zeros(length(u))#the DifferentiableBackwardEuler API requires this but it currently isn't used"><pre><span class="pl-c"><span class="pl-c">#</span>set up some functions needed by DifferentiableBackwardEuler</span>
<span class="pl-k">function</span> <span class="pl-en">f_richards</span>(u, p, t)<span class="pl-c"><span class="pl-c">#</span>tells DifferentiableBackwardEuler to solve du/dt=f_richards</span>
	Ks, dirichleths <span class="pl-k">=</span> <span class="pl-c1">unpack</span>(p)
	<span class="pl-k">return</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">richards_residuals</span>(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">f_richards_u</span>(u, p, t)<span class="pl-c"><span class="pl-c">#</span>give DifferentiableBackwardEuler the derivative of f_richards with respect to u -- needed for the backward euler method that we use</span>
	Ks, dirichleths <span class="pl-k">=</span> <span class="pl-c1">unpack</span>(p)
	<span class="pl-k">return</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">richards_psi</span>(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">f_richards_p</span>(u, p, t)<span class="pl-c"><span class="pl-c">#</span>give DifferentiableBackwardEuler the derivative of f_richards with respect to p -- needed for computing gradients with respect to p of functions involving the richards equation solution</span>
	Ks, dirichleths <span class="pl-k">=</span> <span class="pl-c1">unpack</span>(p)
	J1 <span class="pl-k">=</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">richards_Ks</span>(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
	J2 <span class="pl-k">=</span> DPFEHM<span class="pl-k">.</span><span class="pl-c1">richards_dirichletpsis</span>(u, Ks, neighbors, areasoverlengths, dirichletnodes, dirichleths, coords, alphas, Ns, Qs, specificstorage, volumes)
	<span class="pl-k">return</span> <span class="pl-c1">hcat</span>(J1, J2)
<span class="pl-k">end</span>
<span class="pl-en">f_richards_t</span>(u, p, t) <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">length</span>(u))<span class="pl-c"><span class="pl-c">#</span>the DifferentiableBackwardEuler API requires this but it currently isn't used</span></pre></div>
<p dir="auto">These functions use a helper function, <code>unpack</code>, which unpacks the "parameters" <code>p</code> from a big array into two smaller arrays. Here, <code>unpack</code> converts <code>p</code> into the conductivities, <code>Ks</code> and boundary conditions, <code>dirichleths</code>. We can also think of packing the parameters by doing `p = [Ks; dirichleths]'. This packing/unpacking is needed because DifferentiableBackwardEuler needs the parameters to be in a single array.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function unpack(p)
	@assert length(p) == length(neighbors) + size(coords, 2)
	Ks = p[1:length(neighbors)]
	dirichleths = p[length(neighbors) + 1:length(neighbors) + size(coords, 2)]
	return Ks, dirichleths
end"><pre><span class="pl-k">function</span> <span class="pl-en">unpack</span>(p)
	<span class="pl-c1">@assert</span> <span class="pl-c1">length</span>(p) <span class="pl-k">==</span> <span class="pl-c1">length</span>(neighbors) <span class="pl-k">+</span> <span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>)
	Ks <span class="pl-k">=</span> p[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(neighbors)]
	dirichleths <span class="pl-k">=</span> p[<span class="pl-c1">length</span>(neighbors) <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(neighbors) <span class="pl-k">+</span> <span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>)]
	<span class="pl-k">return</span> Ks, dirichleths
<span class="pl-k">end</span></pre></div>
<p dir="auto">Now, we can solve the equations using <code>solveforh</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="h = solveforh(logKs, dirichleths)#solve for the head"><pre>h <span class="pl-k">=</span> <span class="pl-c1">solveforh</span>(logKs, dirichleths)<span class="pl-c"><span class="pl-c">#</span>solve for the head</span></pre></div>

<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/richards_transient_3d/head.png"><img src="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/richards_transient_3d/head.png" alt="Pressure" style="max-width: 100%;"></a></p>
<p dir="auto">Finally, we can compute the gradient of functions involving the solution of these equations using <code>Zygote.gradient</code> or <code>Zygote.pullback</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="hflat2h3d(h) = reshape(h, reverse(ns)...)
gradient_node = div(size(coords, 2) + ns[3] * ns[2], 2)
gradient_node_x = coords[1, gradient_node]
gradient_node_y = coords[2, gradient_node]
grad = Zygote.gradient((x, y)-&gt;hflat2h3d(solveforh(x, y)[:, end])[gradient_node], logKs, dirichleths)#calculate the gradient (which involves a redundant calculation of the forward pass)"><pre><span class="pl-en">hflat2h3d</span>(h) <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(h, <span class="pl-c1">reverse</span>(ns)<span class="pl-k">...</span>)
gradient_node <span class="pl-k">=</span> <span class="pl-c1">div</span>(<span class="pl-c1">size</span>(coords, <span class="pl-c1">2</span>) <span class="pl-k">+</span> ns[<span class="pl-c1">3</span>] <span class="pl-k">*</span> ns[<span class="pl-c1">2</span>], <span class="pl-c1">2</span>)
gradient_node_x <span class="pl-k">=</span> coords[<span class="pl-c1">1</span>, gradient_node]
gradient_node_y <span class="pl-k">=</span> coords[<span class="pl-c1">2</span>, gradient_node]
grad <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">gradient</span>((x, y)<span class="pl-k">-&gt;</span><span class="pl-c1">hflat2h3d</span>(<span class="pl-c1">solveforh</span>(x, y)[:, <span class="pl-c1">end</span>])[gradient_node], logKs, dirichleths)<span class="pl-c"><span class="pl-c">#</span>calculate the gradient (which involves a redundant calculation of the forward pass)</span></pre></div>

<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/richards_transient_3d/gradient.png"><img src="https://raw.githubusercontent.com/OrchardLANL/DPFEHM.jl/master/examples/richards_transient_3d/gradient.png" alt="Gradient" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-advanced-usage" class="anchor" aria-hidden="true" href="#advanced-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Advanced usage</h2>
<p dir="auto">The <a href="https://github.com/OrchardLANL/DPFEHM.jl/tree/master/examples">examples</a> illustrate more advanced usage including <a href="https://github.com/OrchardLANL/DPFEHM.jl/blob/master/examples/gw_multigrid_inverse/inputdeck.jl">inverse problems</a>, <a href="https://github.com/OrchardLANL/DPFEHM.jl/blob/master/examples/pressure_management/ex.jl">combining DPFEHM with a neural network</a>, <a href="https://github.com/OrchardLANL/DPFEHM.jl/blob/master/examples/fracture_network_solver_scaling/plots_for_paper.jl">flow on discrete fracture networks</a>, as well as solving the <a href="https://github.com/OrchardLANL/DPFEHM.jl/blob/master/examples/transport/ex.jl">advection-dispersion</a> and <a href="https://github.com/OrchardLANL/DPFEHM.jl/blob/master/examples/wave_propagation_2d/ex.jl">wave</a> equations.</p>
<h2 dir="auto"><a id="user-content-note-on-the-numerical-methods" class="anchor" aria-hidden="true" href="#note-on-the-numerical-methods"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Note on the numerical methods</h2>
<p dir="auto">DPFEHM generally uses a two-point flux approximation to discretize the equations. This means, for example, that when the fluid flux between cell <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="aa66916828fbeda808fb30f4fd0a0665">$i$</math-renderer> and cell <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="aa66916828fbeda808fb30f4fd0a0665">$j$</math-renderer> that is proportional to the pressure gradient, the pressure gradient is approximated as being proportional to <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="aa66916828fbeda808fb30f4fd0a0665">$p_i-p_j$</math-renderer> where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="aa66916828fbeda808fb30f4fd0a0665">$p_i$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="aa66916828fbeda808fb30f4fd0a0665">$p_j$</math-renderer> are the pressures in cells <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="aa66916828fbeda808fb30f4fd0a0665">$i$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="aa66916828fbeda808fb30f4fd0a0665">$j$</math-renderer>, respectively.</p>
<h2 dir="auto">
<a id="user-content-license" class="anchor" aria-hidden="true" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>License</h2>
<p dir="auto">DPFEHM is provided under a BSD style license. See LICENSE.md file for the full text.</p>
<p dir="auto">This package is part of the Orchard suite, known internally as C20086 Orchard.</p>
<h2 dir="auto">
<a id="user-content-development-and-questions" class="anchor" aria-hidden="true" href="#development-and-questions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Development and questions</h2>
<p dir="auto">If you would like to contribute to DPFEHM, please for the repo and make a pull request. If you have any questions, please contact Daniel O'Malley, <a href="mailto:omalled@lanl.gov">omalled@lanl.gov</a>.</p>
</article></div>