<div id="readme" class="md" data-path="readme.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-reactivedynamicsjl-" class="anchor" aria-hidden="true" href="#reactivedynamicsjl-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ReactiveDynamics.jl <br></h1>
<p align="center" dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="docs/src/assets/diagram1.png"><img src="docs/src/assets/diagram1.png" alt="wiring diagram" style="max-width: 100%;"></a> <br>
  <a href="#about">About</a> |
  <a href="#context-dynamics-of-value-evolution-dyve">Context</a> |
  <a href="#four-sketches">Four Sketches</a> |
  <a href="https://merck.github.io/ReactiveDynamics.jl/stable" rel="nofollow">Documentation</a>
</p>
<h2 dir="auto"><a id="user-content-about" class="anchor" aria-hidden="true" href="#about"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>About</h2>
<p dir="auto">The package provides a category of reaction (transportation) network-type problems formalized on top of the <strong><a href="https://ncatlab.org/nlab/show/generalized+algebraic+theory" rel="nofollow">generalized algebraic theory</a></strong>, and is compatible with the <strong><a href="https://sciml.ai/" rel="nofollow">SciML</a></strong> ecosystem.</p>
<p dir="auto">Our motivation stems from the area of <strong><a href="https://www.youtube.com/watch?v=o-Yp8A7BPE8" rel="nofollow">system dynamics</a></strong>, which is a mathematical modeling approach to frame, analyze, and optimize complex (nonlinear) dynamical systems, to augment the strategy and policy design.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/diagram2.png"><img src="docs/src/assets/diagram2.png" align="right" alt="wiring diagram" style="max-width: 100%;"></a></p>
<p dir="auto">The central concept is of a <b>transition</b> (transport, flow, rule, reaction - a subcategory of general algebraic action). Generally, a transition prescribes a stochastic rule which repeatedly transforms the modeled system's <b>resources</b>. An elementary instance of such an ontology is provided by chemical reaction networks.
</p><p dir="auto">A <b>reaction network</b> (system modeled) is then a tuple <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="8980b0c40e921df61b50a90c1a0fd86e">$(T, R)$</math-renderer>, where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="8980b0c40e921df61b50a90c1a0fd86e">$T$</math-renderer> is a set of the transitions and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="8980b0c40e921df61b50a90c1a0fd86e">$R$</math-renderer> is a set of the network's resource classes (aka species). The simultaneous action of transitions on the resources evolves the dynamical system.</p>
<p dir="auto">The transitions are generally <strong>stateful</strong> (i.e., act over a period of time). Moreover, at each time step a quantum of the a transition's instances is brought into the scope, where the size of the batch is drived by a Poisson counting process. A transition takes the from <code>rate, a*A + b*B + ... --&gt; c*C + ...</code>, where <code>rate</code> gives the expected batch size per time unit. <code>A</code>, <code>B</code>, etc., are the resources, and <code>a</code>, <code>b</code>, etc., are the generalized stoichiometry coefficients. Note that both <code>rate</code> and the "coefficients" can in fact be given by a function which depends on the system's instantaneous state (stochastic, in general). In particular, even the structural form of a transition can be stochastic, as will be demonstrated shortly.</p>
<p dir="auto"></p>
<p dir="auto">An instance of a stateful transition evolves gradually from its genesis up to the terminal point, where the products on the instance's right hand-side are put into the system. An instance advances proportionally to the quantity of resources allocated. To understand this behavior, we note that the system's resource classes (or occurences of a resource class in a transition) may be assigned a <strong>modality</strong>; a modality governs the interaction between the resource and the transition, as well as the interpretation of the generalized stoichiometry coefficient.</p>
<p dir="auto">In particular, a resource can be allocated to an instance either for the instance's lifetime or a single time step of the model's evolution (after each time step, the resource may be reallocated based on the global demand). Moreover, the coefficient of a resource on the left hand-side can either be interpreted as a total amount of the resource required or as an amount required per time unit. Similarly, it is possible to declare a resource <strong>conserved</strong>, in which case it is returned into the scope once the instance terminates.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/diagram3.png"><img src="docs/src/assets/diagram3.png" align="left" alt="attributes diagram" style="max-width: 100%;"></a></p>
<p dir="auto">The transitions are <b>parametric</b>. That is, it is possible to set the period over which an instance of a transition acts in the system (as well as the maximal period of this action), the total number of transition's instances allowed to exist in the system, etc. An annotated transition takes the form <code>rate, a*A + b*B + ... --&gt; c*C + ..., prm =&gt; val, ...</code>, where the numerical values can be given by a function which depends on the system's state. Internally, the reaction network is represented as an <a href="https://algebraicjulia.github.io/Catlab.jl/dev/generated/wiring_diagrams/wd_cset/" rel="nofollow"><b>attributed C-set</b></a>.</p>
<p dir="auto">For an overview of accepted attributes for both transitions and species classes, read the <a href="https://merck.github.io/ReactiveDynamics.jl/#Update-model-objects" rel="nofollow">docs</a></p>
<p dir="auto">A network's dynamics is specified using a compact <strong>modeling metalanguage</strong>. Moreover, we have integrated another expression comprehension metalanguage which makes it easy to generate arbitrarily complex dynamics from a single template transition!</p>
<p dir="auto">Taking <strong>unions</strong> of reaction networks is fully supported, and it is possible to identify the resource classes as appropriate.</p>
<p dir="auto">Moreover, it is possible to <strong>export and import</strong> reaction network dynamics using the <a href="https://toml.io/" rel="nofollow">TOML</a> format.</p>
<p dir="auto">Once a network's dynamics is specified, it can be converted to a problem and simulated. The exported problem is a <strong><code>DiscreteProblem</code></strong> compatible with <strong><a href="https://diffeq.sciml.ai/stable/" rel="nofollow">DifferentialEquations.jl</a></strong> ecosystem, and hence the latter package's all powerful capabilities are available. For better user experience, we have tailored and exported many of the functionalities within the modeling metalanguage, including ensemble analysis, parameter optimization, parameter inference, etc. Would you guess that <strong><a href="https://arxiv.org/abs/2001.04385" rel="nofollow">universal differential equations</a></strong> are supported? If even the dynamics is unknown, you may just infer it!</p>
<h2 dir="auto">
<a id="user-content-context-dynamics-of-value-evolution-dyve" class="anchor" aria-hidden="true" href="#context-dynamics-of-value-evolution-dyve"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Context: Dynamics of Value Evolution (DyVE)</h2>
<p dir="auto">The package is an integral part of the <strong>Dynamics of Value Evolution (DyVE)</strong> computational framework for learning, designing, integrating, simulating, and optimizing R&amp;D process models, to better inform strategic decisions in science and business.</p>
<p dir="auto">As the framework evolves, multiple functionalities have matured enough to become standalone packages.</p>
<p dir="auto">This includes <strong><a href="https://github.com/Merck/GeneratedExpressions.jl">GeneratedExpressions.jl</a></strong>, a metalanguage to support code-less expression comprehensions. In the present context, expression comprehensions are used to generate complex dynamics from user-specified template transitions.</p>
<p dir="auto">Another package is <strong><a href="https://github.com/Merck/AlgebraicAgents.jl">AlgebraicAgents.jl</a></strong>, a lightweight package to enable hierarchical, heterogeneous dynamical systems co-integration. It implements a highly scalable, fully customizable interface featuring sums and compositions of dynamical systems. In present context, we note it can be used to co-integrate a reaction network problem with, e.g., a stochastic ordinary differential problem!</p>
<h2 dir="auto">
<a id="user-content-four-sketches" class="anchor" aria-hidden="true" href="#four-sketches"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Four Sketches</h2>
<p dir="auto">For other examples, see the <strong><a href="tutorial">tutorials</a></strong>.</p>
<h3 dir="auto">
<a id="user-content-sir-model" class="anchor" aria-hidden="true" href="#sir-model"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SIR Model</h3>
<p dir="auto">The acronym SIR stands for susceptible, infected, and recovered, and as such the SIR model attempts to capture the dynamics of disease spread. We express the SIR dynamics as a reaction network using the compact modeling metalanguage.</p>
<p dir="auto">Follow the SIR model's reactions:</p>
<p align="center" dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="docs/src/assets/sir_reactions.png"><img src="docs/src/assets/sir_reactions.png" alt="SIR reactions" style="max-width: 100%;"></a> <br>
</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ReactiveDynamics

# model dynamics
sir_acs = @ReactionNetwork begin
        α*S*I, S+I --&gt; 2I, name=&gt;I2R
        β*I, I --&gt; R, name=&gt;R2S 
end

# simulation parameters
## initial values
@prob_init sir_acs S=999 I=10 R=0
## uncertainty in initial values (Gaussian)
@prob_uncertainty sir_acs S=10. I=5.
## parameters
@prob_params sir_acs α=0.0001 β=0.01
## other arguments passed to the solver
@prob_meta sir_acs tspan=250 dt=.1"><pre><span class="pl-k">using</span> ReactiveDynamics

<span class="pl-c"><span class="pl-c">#</span> model dynamics</span>
sir_acs <span class="pl-k">=</span> <span class="pl-c1">@ReactionNetwork</span> <span class="pl-k">begin</span>
        α<span class="pl-k">*</span>S<span class="pl-k">*</span>I, S<span class="pl-k">+</span>I <span class="pl-k">--&gt;</span> <span class="pl-c1">2</span>I, name<span class="pl-k">=&gt;</span>I2R
        β<span class="pl-k">*</span>I, I <span class="pl-k">--&gt;</span> R, name<span class="pl-k">=&gt;</span>R2S 
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> simulation parameters</span>
<span class="pl-c"><span class="pl-c">#</span># initial values</span>
<span class="pl-c1">@prob_init</span> sir_acs S<span class="pl-k">=</span><span class="pl-c1">999</span> I<span class="pl-k">=</span><span class="pl-c1">10</span> R<span class="pl-k">=</span><span class="pl-c1">0</span>
<span class="pl-c"><span class="pl-c">#</span># uncertainty in initial values (Gaussian)</span>
<span class="pl-c1">@prob_uncertainty</span> sir_acs S<span class="pl-k">=</span><span class="pl-c1">10.</span> I<span class="pl-k">=</span><span class="pl-c1">5.</span>
<span class="pl-c"><span class="pl-c">#</span># parameters</span>
<span class="pl-c1">@prob_params</span> sir_acs α<span class="pl-k">=</span><span class="pl-c1">0.0001</span> β<span class="pl-k">=</span><span class="pl-c1">0.01</span>
<span class="pl-c"><span class="pl-c">#</span># other arguments passed to the solver</span>
<span class="pl-c1">@prob_meta</span> sir_acs tspan<span class="pl-k">=</span><span class="pl-c1">250</span> dt<span class="pl-k">=</span>.<span class="pl-c1">1</span></pre></div>
<p dir="auto">The resulting reaction network is represented as an attributed C-set:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/sir_acs.png"><img src="docs/src/assets/sir_acs.png" alt="sir acs" style="max-width: 100%;"></a></p>
<p dir="auto">Next we solve the problem.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="# turn model into a problem
prob = @problematize sir_acs

# solve the problem over multiple trajectories
sol = @solve prob trajectories=20

# plot the solution
@plot sol plot_type=summary
## show only species S
@plot sol plot_type=summary show=:S
## plot evolution over (0., 100.) in green (propagates to Plots.jl)
@plot sol plot_type=summary c=:green xlimits=(.0, 100.)"><pre class="notranslate"><code># turn model into a problem
prob = @problematize sir_acs

# solve the problem over multiple trajectories
sol = @solve prob trajectories=20

# plot the solution
@plot sol plot_type=summary
## show only species S
@plot sol plot_type=summary show=:S
## plot evolution over (0., 100.) in green (propagates to Plots.jl)
@plot sol plot_type=summary c=:green xlimits=(.0, 100.)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/sir_plot.png"><img src="docs/src/assets/sir_plot.png" alt="sir plots" style="max-width: 100%;"></a></p>
<h3 dir="auto">
<a id="user-content-a-primer-on-attributed-transitions" class="anchor" aria-hidden="true" href="#a-primer-on-attributed-transitions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A Primer on Attributed Transitions</h3>
<p dir="auto">Before we move on to more intricate examples demonstrating generative capabilities of the package, let's sketch a toy pharma model with as little as three transitions.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="toy_pharma_model = @ReactionNetwork"><pre>toy_pharma_model <span class="pl-k">=</span> <span class="pl-c1">@ReactionNetwork</span></pre></div>
<p dir="auto">First, a <strong>"discovery" transition</strong> will take a team of scientist and a portion of a company's budget at the input (say, for experimental resources), and it will <strong>output candidate compounds</strong>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@push toy_pharma_model α(candidate_compound, marketed_drug, κ) 3*@conserved(scientist) + @rate(budget) --&gt; candidate_compound name=&gt;discovery probability=&gt;.3 cycletime=&gt;6 priority=&gt;.5"><pre><span class="pl-c1">@push</span> toy_pharma_model <span class="pl-c1">α</span>(candidate_compound, marketed_drug, κ) <span class="pl-c1">3</span><span class="pl-k">*</span><span class="pl-c1">@conserved</span>(scientist) <span class="pl-k">+</span> <span class="pl-c1">@rate</span>(budget) <span class="pl-k">--&gt;</span> candidate_compound name<span class="pl-k">=&gt;</span>discovery probability<span class="pl-k">=&gt;</span>.<span class="pl-c1">3</span> cycletime<span class="pl-k">=&gt;</span><span class="pl-c1">6</span> priority<span class="pl-k">=&gt;</span>.<span class="pl-c1">5</span></pre></div>
<p dir="auto">Note that per a time unit, <code>α(candidate_compound, marketed_drug, κ)</code> "discovery" projects will be started. We provide a name of the class of transitions (<code>name=&gt;discovery</code>), set up a probability of the transition terminating successfully (<code>probability=&gt;.3</code>), a cycle time (<code>cycletime=&gt;6</code>), and we provide a weight of the transitions' class for use in resource allocation (<code>priority=&gt;.5</code>).</p>
<p dir="auto">Moreover, we annotate "scientists" as a conserved resource (no matter how the project terminates, the workforce isn't consumed), i.e., <code>@conserved(scientist)</code>, and we state that a unit "budget" is consumed per a time unit, i.e., <code>@rate(budget)</code>.</p>
<p dir="auto">Next, <strong>candidate compounds will undergo clinical trials</strong>. If successful, a compound transforms into a marketed drug, and the company receives a premium.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@push toy_pharma_model β(candidate_compound, marketed_drug) candidate_compound + 5*@conserved(scientist) + 2*@rate(budget) --&gt; marketed_drug + 5*budget name=&gt;dx2market probability=&gt;.5+.001*@t() cycletime=&gt;4"><pre><span class="pl-c1">@push</span> toy_pharma_model <span class="pl-c1">β</span>(candidate_compound, marketed_drug) candidate_compound <span class="pl-k">+</span> <span class="pl-c1">5</span><span class="pl-k">*</span><span class="pl-c1">@conserved</span>(scientist) <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">@rate</span>(budget) <span class="pl-k">--&gt;</span> marketed_drug <span class="pl-k">+</span> <span class="pl-c1">5</span><span class="pl-k">*</span>budget name<span class="pl-k">=&gt;</span>dx2market probability<span class="pl-k">=&gt;</span>.<span class="pl-c1">5</span><span class="pl-k">+</span>.<span class="pl-c1">001</span><span class="pl-k">*</span><span class="pl-c1">@t</span>() cycletime<span class="pl-k">=&gt;</span><span class="pl-c1">4</span></pre></div>
<p dir="auto">Note that as time evolves, the probability of technical success increases, i.e., <code>probability=&gt;.5+.001*@t()</code>.</p>
<p dir="auto">In addition, <strong>marketed drugs bring profit to the company</strong> - which will fuel invention of new drugs.</p>
<p dir="auto">We model the situation as a periodic callback.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@periodic toy_pharma_model 1. budget += 11*marketed_drug"><pre><span class="pl-c1">@periodic</span> toy_pharma_model <span class="pl-c1">1.</span> budget <span class="pl-k">+=</span> <span class="pl-c1">11</span><span class="pl-k">*</span>marketed_drug</pre></div>
<p dir="auto">A <strong>marketed drug may eventually be withdrawn</strong> from the market. To account for such scenario, we add the following transition:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@push toy_pharma_model  γ*marketed_drug marketed_drug --&gt; ∅ name=&gt;drug_withdrawn"><pre><span class="pl-c1">@push</span> toy_pharma_model  γ<span class="pl-k">*</span>marketed_drug marketed_drug <span class="pl-k">--&gt;</span> ∅ name<span class="pl-k">=&gt;</span>drug_withdrawn</pre></div>
<p dir="auto">Next we provide the functions <code>α</code> and <code>β</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@register α(number_candidate_compounds, number_marketed_drugs, κ) = κ + exp(-number_candidate_compounds) + exp(-number_marketed_drugs)
@register β(number_candidate_compounds, number_marketed_drugs) = numbercandidate_compounds + exp(-number_marketed_drugs)"><pre><span class="pl-c1">@register</span> <span class="pl-en">α</span>(number_candidate_compounds, number_marketed_drugs, κ) <span class="pl-k">=</span> κ <span class="pl-k">+</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span>number_candidate_compounds) <span class="pl-k">+</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span>number_marketed_drugs)
<span class="pl-c1">@register</span> <span class="pl-en">β</span>(number_candidate_compounds, number_marketed_drugs) <span class="pl-k">=</span> numbercandidate_compounds <span class="pl-k">+</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span>number_marketed_drugs)</pre></div>
<p dir="auto">Likewise, we set the remaining parameters, initial values, and model metadata:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
# simulation parameters
## initial values
@prob_init toy_pharma_model candidate_compound=5 marketed_drug=6 scientist=20 budget=100
## parameters
@prob_params toy_pharma_model κ=4 γ=.1
## other arguments passed to the solver
@prob_meta toy_pharma_model tspan=250 dt=.1"><pre><span class="pl-c"><span class="pl-c">#</span> simulation parameters</span>
<span class="pl-c"><span class="pl-c">#</span># initial values</span>
<span class="pl-c1">@prob_init</span> toy_pharma_model candidate_compound<span class="pl-k">=</span><span class="pl-c1">5</span> marketed_drug<span class="pl-k">=</span><span class="pl-c1">6</span> scientist<span class="pl-k">=</span><span class="pl-c1">20</span> budget<span class="pl-k">=</span><span class="pl-c1">100</span>
<span class="pl-c"><span class="pl-c">#</span># parameters</span>
<span class="pl-c1">@prob_params</span> toy_pharma_model κ<span class="pl-k">=</span><span class="pl-c1">4</span> γ<span class="pl-k">=</span>.<span class="pl-c1">1</span>
<span class="pl-c"><span class="pl-c">#</span># other arguments passed to the solver</span>
<span class="pl-c1">@prob_meta</span> toy_pharma_model tspan<span class="pl-k">=</span><span class="pl-c1">250</span> dt<span class="pl-k">=</span>.<span class="pl-c1">1</span></pre></div>
<p dir="auto">And we problematize the model, solve the problem, and plot the solution:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="prob = @problematize toy_pharma_model
sol = @solve prob trajectories=20
@plot sol plot_type=summary show=[:candidate_compound, :marketed_drug]"><pre>prob <span class="pl-k">=</span> <span class="pl-c1">@problematize</span> toy_pharma_model
sol <span class="pl-k">=</span> <span class="pl-c1">@solve</span> prob trajectories<span class="pl-k">=</span><span class="pl-c1">20</span>
<span class="pl-c1">@plot</span> sol plot_type<span class="pl-k">=</span>summary show<span class="pl-k">=</span>[<span class="pl-c1">:candidate_compound</span>, <span class="pl-c1">:marketed_drug</span>]</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/toy_pharma.png"><img src="docs/src/assets/toy_pharma.png" alt="plot" style="max-width: 100%;"></a></p>
<h3 dir="auto">
<a id="user-content-sparse-interactions" class="anchor" aria-hidden="true" href="#sparse-interactions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sparse Interactions</h3>
<p dir="auto">We introduce a complex reaction network as a union of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="8980b0c40e921df61b50a90c1a0fd86e">$n_{\text{models}}$</math-renderer> reaction networks, where the off-diagonal interactions are sparse.</p>
<p dir="auto">To harness the capabilities of <strong>GeneratedExpressions.jl</strong>, let us first declare a template atomic model.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# submodel.jl
# substitute $r as the global number of resources, $i as the submodel identifier
@register begin 
        push!(ns, rand(1:5)); ϵ = 10e-2
        push!(M, rand(ns[$i], ns[$i])); foreach(i -&gt; M[$i][i, i] += ϵ, 1:ns[$i])
        foreach(i -&gt; M[$i][i, :] /= sum(M[$i][i, :]), 1:ns[$i])
        push!(cycle_times, rand(1:5, ns[$i], ns[$i]))
        push!(demand, rand(1:10, ns[$i], ns[$i], $r)); push!(production, rand(1:10, ns[$i], ns[$i], $r))
end
    
# generate submodel dynamics
push!(rd_models, @ReactionNetwork begin
                M[$i][$m, $n], state[$m] + {demand[$i][$m, $n, $l]*resource[$l], l=1:$r, dlm=+} --&gt; state[$n] + 
                        {production[$i][$m, $n, $l]*resource[$l], l=1:$r, dlm=+}, cycle_time=&gt;cycle_times[$i][$m, $n], probability_of_success=&gt;$m*$n/(n[$i])^2
        end m=1:ReactiveDynamics.ns[$i] n=1:ReactiveDynamics.ns[$i]
)"><pre><span class="pl-c"><span class="pl-c">#</span> submodel.jl</span>
<span class="pl-c"><span class="pl-c">#</span> substitute $r as the global number of resources, $i as the submodel identifier</span>
<span class="pl-c1">@register</span> <span class="pl-k">begin</span> 
        <span class="pl-c1">push!</span>(ns, <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>)); ϵ <span class="pl-k">=</span> <span class="pl-c1">10e-2</span>
        <span class="pl-c1">push!</span>(M, <span class="pl-c1">rand</span>(ns[<span class="pl-k">$</span>i], ns[<span class="pl-k">$</span>i])); <span class="pl-c1">foreach</span>(i <span class="pl-k">-&gt;</span> M[<span class="pl-k">$</span>i][i, i] <span class="pl-k">+=</span> ϵ, <span class="pl-c1">1</span><span class="pl-k">:</span>ns[<span class="pl-k">$</span>i])
        <span class="pl-c1">foreach</span>(i <span class="pl-k">-&gt;</span> M[<span class="pl-k">$</span>i][i, :] <span class="pl-k">/=</span> <span class="pl-c1">sum</span>(M[<span class="pl-k">$</span>i][i, :]), <span class="pl-c1">1</span><span class="pl-k">:</span>ns[<span class="pl-k">$</span>i])
        <span class="pl-c1">push!</span>(cycle_times, <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, ns[<span class="pl-k">$</span>i], ns[<span class="pl-k">$</span>i]))
        <span class="pl-c1">push!</span>(demand, <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>, ns[<span class="pl-k">$</span>i], ns[<span class="pl-k">$</span>i], <span class="pl-k">$</span>r)); <span class="pl-c1">push!</span>(production, <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>, ns[<span class="pl-k">$</span>i], ns[<span class="pl-k">$</span>i], <span class="pl-k">$</span>r))
<span class="pl-k">end</span>
    
<span class="pl-c"><span class="pl-c">#</span> generate submodel dynamics</span>
<span class="pl-c1">push!</span>(rd_models, <span class="pl-c1">@ReactionNetwork</span> <span class="pl-k">begin</span>
                M[<span class="pl-k">$</span>i][<span class="pl-k">$</span>m, <span class="pl-k">$</span>n], state[<span class="pl-k">$</span>m] <span class="pl-k">+</span> {demand[<span class="pl-k">$</span>i][<span class="pl-k">$</span>m, <span class="pl-k">$</span>n, <span class="pl-k">$</span>l]<span class="pl-k">*</span>resource[<span class="pl-k">$</span>l], l<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-k">$</span>r, dlm<span class="pl-k">=</span><span class="pl-k">+</span>} <span class="pl-k">--&gt;</span> state[<span class="pl-k">$</span>n] <span class="pl-k">+</span> 
                        {production[<span class="pl-k">$</span>i][<span class="pl-k">$</span>m, <span class="pl-k">$</span>n, <span class="pl-k">$</span>l]<span class="pl-k">*</span>resource[<span class="pl-k">$</span>l], l<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-k">$</span>r, dlm<span class="pl-k">=</span><span class="pl-k">+</span>}, cycle_time<span class="pl-k">=&gt;</span>cycle_times[<span class="pl-k">$</span>i][<span class="pl-k">$</span>m, <span class="pl-k">$</span>n], probability_of_success<span class="pl-k">=&gt;</span><span class="pl-k">$</span>m<span class="pl-k">*</span><span class="pl-k">$</span>n<span class="pl-k">/</span>(n[<span class="pl-k">$</span>i])<span class="pl-k">^</span><span class="pl-c1">2</span>
        <span class="pl-k">end</span> m<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>ReactiveDynamics<span class="pl-k">.</span>ns[<span class="pl-k">$</span>i] n<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>ReactiveDynamics<span class="pl-k">.</span>ns[<span class="pl-k">$</span>i]
)</pre></div>
<p dir="auto">The next step is to instantiate the atomic models (submodels).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ReactiveDynamics
## setup the environment
rd_models = ReactiveDynamics.ReactionNetwork[] # submodels

# needs to live within ReactiveDynamics's scope
# the arrays will contain the submodel
@register begin
    ns = Int[] # size of submodels
    M = Array[] # transition intensities of submodels
    cycle_times = Array[] # cycle times of transitions in submodels
    demand = Array[]; production = Array[] # resource production / generation for transitions in submodels
end"><pre><span class="pl-k">using</span> ReactiveDynamics
<span class="pl-c"><span class="pl-c">#</span># setup the environment</span>
rd_models <span class="pl-k">=</span> ReactiveDynamics<span class="pl-k">.</span>ReactionNetwork[] <span class="pl-c"><span class="pl-c">#</span> submodels</span>

<span class="pl-c"><span class="pl-c">#</span> needs to live within ReactiveDynamics's scope</span>
<span class="pl-c"><span class="pl-c">#</span> the arrays will contain the submodel</span>
<span class="pl-c1">@register</span> <span class="pl-k">begin</span>
    ns <span class="pl-k">=</span> Int[] <span class="pl-c"><span class="pl-c">#</span> size of submodels</span>
    M <span class="pl-k">=</span> Array[] <span class="pl-c"><span class="pl-c">#</span> transition intensities of submodels</span>
    cycle_times <span class="pl-k">=</span> Array[] <span class="pl-c"><span class="pl-c">#</span> cycle times of transitions in submodels</span>
    demand <span class="pl-k">=</span> Array[]; production <span class="pl-k">=</span> Array[] <span class="pl-c"><span class="pl-c">#</span> resource production / generation for transitions in submodels</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Load <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="8980b0c40e921df61b50a90c1a0fd86e">$n_{\text{models}}$</math-renderer> the atomic models (substituting into <code>submodel.jl</code>):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n_models = 5; r = 2 # number of submodels, resources

# submodels: dense interactions
@generate {@fileval(submodel.jl, i=$i, r=r), i=1:n_models}"><pre>n_models <span class="pl-k">=</span> <span class="pl-c1">5</span>; r <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> number of submodels, resources</span>

<span class="pl-c"><span class="pl-c">#</span> submodels: dense interactions</span>
<span class="pl-c1">@generate</span> {<span class="pl-c1">@fileval</span>(submodel<span class="pl-k">.</span>jl, i<span class="pl-k">=</span><span class="pl-k">$</span>i, r<span class="pl-k">=</span>r), i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>n_models}</pre></div>
<p dir="auto">We take union of the atomic models, and we identify common resources.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# batch join over the submodels
rd_model = @generate &quot;@join {rd_models[\$i], i=1:n_models, dlm=' '}&quot;

# identify resources
@generate {@equalize(rd_model, @alias(resource[$j])={rd_models[$i].resource[$j], i=1:n_models, dlm=:(=)}), j=1:r}"><pre><span class="pl-c"><span class="pl-c">#</span> batch join over the submodels</span>
rd_model <span class="pl-k">=</span> <span class="pl-c1">@generate</span> <span class="pl-s"><span class="pl-pds">"</span>@join {rd_models[<span class="pl-cce">\$</span>i], i=1:n_models, dlm=' '}<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> identify resources</span>
<span class="pl-c1">@generate</span> {<span class="pl-c1">@equalize</span>(rd_model, <span class="pl-c1">@alias</span>(resource[<span class="pl-k">$</span>j])<span class="pl-k">=</span>{rd_models[<span class="pl-k">$</span>i]<span class="pl-k">.</span>resource[<span class="pl-k">$</span>j], i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>n_models, dlm<span class="pl-k">=</span>:(<span class="pl-k">=</span>)}), j<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>r}</pre></div>
<p dir="auto">Next step is to add some off-diagonal interactions.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# sparse off-diagonal interactions, sparse declaration
# again, we use GeneratedExpressions.jl
sparse_off_diagonal = zeros(sum(ReactiveDynamics.ns), sum(ReactiveDynamics.ns))
for i in 1:n_models
    j = rand(setdiff(1:n_models, (i, )))
    i_ix = rand(1:ReactiveDynamics.ns[i]); j_ix = rand(1:ReactiveDynamics.ns[j])
    sparse_off_diagonal[i_ix+sum(ReactiveDynamics.ns[1:i-1]), j_ix+sum(ReactiveDynamics.ns[1:j-1])] += 1
    interaction_ex = &quot;&quot;&quot;@push rd_model begin 1., var&quot;rd_models[$i].state[$i_ix]&quot; --&gt; var&quot;rd_models[$j]__state[$j_ix]&quot; end&quot;&quot;&quot;
    eval(Meta.parseall(interaction_ex))
end"><pre><span class="pl-c"><span class="pl-c">#</span> sparse off-diagonal interactions, sparse declaration</span>
<span class="pl-c"><span class="pl-c">#</span> again, we use GeneratedExpressions.jl</span>
sparse_off_diagonal <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">sum</span>(ReactiveDynamics<span class="pl-k">.</span>ns), <span class="pl-c1">sum</span>(ReactiveDynamics<span class="pl-k">.</span>ns))
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n_models
    j <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">setdiff</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>n_models, (i, )))
    i_ix <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>ReactiveDynamics<span class="pl-k">.</span>ns[i]); j_ix <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>ReactiveDynamics<span class="pl-k">.</span>ns[j])
    sparse_off_diagonal[i_ix<span class="pl-k">+</span><span class="pl-c1">sum</span>(ReactiveDynamics<span class="pl-k">.</span>ns[<span class="pl-c1">1</span><span class="pl-k">:</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>]), j_ix<span class="pl-k">+</span><span class="pl-c1">sum</span>(ReactiveDynamics<span class="pl-k">.</span>ns[<span class="pl-c1">1</span><span class="pl-k">:</span>j<span class="pl-k">-</span><span class="pl-c1">1</span>])] <span class="pl-k">+=</span> <span class="pl-c1">1</span>
    interaction_ex <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span>@push rd_model begin 1., var"rd_models[<span class="pl-v">$i</span>].state[<span class="pl-v">$i_ix</span>]" --&gt; var"rd_models[<span class="pl-v">$j</span>]__state[<span class="pl-v">$j_ix</span>]" end<span class="pl-pds">"""</span></span>
    <span class="pl-c1">eval</span>(Meta<span class="pl-k">.</span><span class="pl-c1">parseall</span>(interaction_ex))
<span class="pl-k">end</span></pre></div>
<p dir="auto">Let's plot the interactions:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/interactions.png"><img src="docs/src/assets/interactions.png" alt="interactions" style="max-width: 100%;"></a></p>
<p dir="auto">The resulting model can then be conveniently simulated using the modeling metalanguage.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ReactiveDynamics: nparts
u0 = rand(1:1000, nparts(rd_model, :S))
@prob_init rd_model u0

@prob_meta rd_model tspan=10

prob = @problematize rd_model
sol = @solve prob trajectories=2

# plot &quot;state&quot; species only
@plot sol plot_type=summary show=r&quot;state&quot;"><pre><span class="pl-k">using</span> ReactiveDynamics<span class="pl-k">:</span> nparts
u0 <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1000</span>, <span class="pl-c1">nparts</span>(rd_model, <span class="pl-c1">:S</span>))
<span class="pl-c1">@prob_init</span> rd_model u0

<span class="pl-c1">@prob_meta</span> rd_model tspan<span class="pl-k">=</span><span class="pl-c1">10</span>

prob <span class="pl-k">=</span> <span class="pl-c1">@problematize</span> rd_model
sol <span class="pl-k">=</span> <span class="pl-c1">@solve</span> prob trajectories<span class="pl-k">=</span><span class="pl-c1">2</span>

<span class="pl-c"><span class="pl-c">#</span> plot "state" species only</span>
<span class="pl-c1">@plot</span> sol plot_type<span class="pl-k">=</span>summary show<span class="pl-k">=</span><span class="pl-sr"><span class="pl-pds">r"</span>state<span class="pl-pds">"</span></span></pre></div>
<h3 dir="auto">
<a id="user-content-universal-differential-equations-fitting-unknown-dynamics" class="anchor" aria-hidden="true" href="#universal-differential-equations-fitting-unknown-dynamics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Universal Differential Equations: Fitting Unknown Dynamics</h3>
<p dir="auto">We demonstrate how to fit unknown part of dynamics to empirical data.</p>
<p dir="auto">We use <code>@register</code> to define a simple linear function within the scope of module <code>ReactiveDynamics</code>; parameters of the function will be then optimized for. Note that <code>function_to_learn</code> can be generally replaced with a neural network (Flux chain), etc.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="## some embedded function (neural network, etc.)
@register begin
    function function_to_learn(A, B, C, params)
        [A, B, C]' * params # params: 3-element vector
    end
end"><pre><span class="pl-c"><span class="pl-c">#</span># some embedded function (neural network, etc.)</span>
<span class="pl-c1">@register</span> <span class="pl-k">begin</span>
    <span class="pl-k">function</span> <span class="pl-en">function_to_learn</span>(A, B, C, params)
        [A, B, C]<span class="pl-k">'</span> <span class="pl-k">*</span> params <span class="pl-c"><span class="pl-c">#</span> params: 3-element vector</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Next we set up a simple dynamics and supply initial parameters.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="acs = @ReactionNetwork begin
    function_to_learn(A, B, C, params), A --&gt; B+C
    1., B --&gt; C
    2., C --&gt; B
end

# initial values, check params
@prob_init acs A=60. B=10. C=150.
@prob_params acs params=[.01, .01, .01]
@prob_meta acs tspan=100."><pre>acs <span class="pl-k">=</span> <span class="pl-c1">@ReactionNetwork</span> <span class="pl-k">begin</span>
    <span class="pl-c1">function_to_learn</span>(A, B, C, params), A <span class="pl-k">--&gt;</span> B<span class="pl-k">+</span>C
    <span class="pl-c1">1.</span>, B <span class="pl-k">--&gt;</span> C
    <span class="pl-c1">2.</span>, C <span class="pl-k">--&gt;</span> B
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> initial values, check params</span>
<span class="pl-c1">@prob_init</span> acs A<span class="pl-k">=</span><span class="pl-c1">60.</span> B<span class="pl-k">=</span><span class="pl-c1">10.</span> C<span class="pl-k">=</span><span class="pl-c1">150.</span>
<span class="pl-c1">@prob_params</span> acs params<span class="pl-k">=</span>[.<span class="pl-c1">01</span>, .<span class="pl-c1">01</span>, .<span class="pl-c1">01</span>]
<span class="pl-c1">@prob_meta</span> acs tspan<span class="pl-k">=</span><span class="pl-c1">100.</span></pre></div>
<p dir="auto">Let's next see the numerical results for the initial guess.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sol = @solve acs
@plot sol"><pre>sol <span class="pl-k">=</span> <span class="pl-c1">@solve</span> acs
<span class="pl-c1">@plot</span> sol</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/optim1.png"><img src="docs/src/assets/optim1.png" alt="plot" style="max-width: 100%;"></a></p>
<p dir="auto">Next we supply empirical data and fit <code>params</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="time_points = [1, 50, 100]
data = [60 30 5]

@fit_and_plot acs data time_points vars=[A] params α maxeval=200 lower_bounds=0 upper_bounds=.01"><pre>time_points <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">50</span>, <span class="pl-c1">100</span>]
data <span class="pl-k">=</span> [<span class="pl-c1">60</span> <span class="pl-c1">30</span> <span class="pl-c1">5</span>]

<span class="pl-c1">@fit_and_plot</span> acs data time_points vars<span class="pl-k">=</span>[A] params α maxeval<span class="pl-k">=</span><span class="pl-c1">200</span> lower_bounds<span class="pl-k">=</span><span class="pl-c1">0</span> upper_bounds<span class="pl-k">=</span>.<span class="pl-c1">01</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/optim2.png"><img src="docs/src/assets/optim2.png" alt="plot" style="max-width: 100%;"></a></p>
</article></div>