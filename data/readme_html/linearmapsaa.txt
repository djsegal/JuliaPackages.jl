<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-linearmapsaajl" class="anchor" aria-hidden="true" href="#linearmapsaajl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LinearMapsAA.jl</h1>
<p dir="auto"><a href="https://github.com/JeffFessler/LinearMapsAA.jl">https://github.com/JeffFessler/LinearMapsAA.jl</a></p>
<p dir="auto"><a href="https://github.com/JeffFessler/LinearMapsAA.jl/actions"><img src="https://github.com/JeffFessler/LinearMapsAA.jl/workflows/Unit%20test/badge.svg" alt="action status" style="max-width: 100%;"></a>
<a href="https://github.com/JeffFessler/LinearMapsAA.jl/actions?query=workflow%3ACI+branch%3Amain"><img src="https://github.com/JeffFessler/LinearMapsAA.jl/workflows/CI/badge.svg?branch=main" alt="build status" style="max-width: 100%;"></a>
<a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/L/LinearMapsAA.html" rel="nofollow"><img src="https://camo.githubusercontent.com/37ae9a668717c7c0d7389fbb9c9ac7cbcc1b3a17471a8aaa23b2160b52972897/68747470733a2f2f6a756c696163692e6769746875622e696f2f4e616e6f736f6c646965725265706f7274732f706b676576616c5f6261646765732f4c2f4c696e6561724d61707341412e737667" alt="pkgeval status" data-canonical-src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/L/LinearMapsAA.svg" style="max-width: 100%;"></a>
<a href="https://codecov.io/github/JeffFessler/LinearMapsAA.jl?branch=main" rel="nofollow"><img src="https://camo.githubusercontent.com/0e875e4be3c4398d82a5c6527ce05a4b4bd6af07c96b0a8cb609a0d662051ca5/68747470733a2f2f636f6465636f762e696f2f6769746875622f4a656666466573736c65722f4c696e6561724d61707341412e6a6c2f636f7665726167652e7376673f6272616e63683d6d61696e" alt="codecov.io" data-canonical-src="https://codecov.io/github/JeffFessler/LinearMapsAA.jl/coverage.svg?branch=main" style="max-width: 100%;"></a>
<a href="LICENSE"><img src="https://camo.githubusercontent.com/992daabc2aa4463339825f8333233ba330dd08c57068f6faf4bb598ab5a3df2e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d627269676874677265656e2e737667" alt="license" data-canonical-src="https://img.shields.io/badge/license-MIT-brightgreen.svg" style="max-width: 100%;"></a>
<a href="https://JeffFessler.github.io/LinearMapsAA.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="docs stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://JeffFessler.github.io/LinearMapsAA.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="docs dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package is an overlay for the package
<a href="https://github.com/Jutho/LinearMaps.jl"><code>LinearMaps.jl</code></a>
that allows one to represent linear operations
(like the FFT)
as a object that appears to the user like a matrix
but internally uses user-defined fast computations
for operations, especially multiplication.
With this package,
you can write and debug code
(especially for iterative algorithms)
using a small matrix <code>A</code>,
and then later replace it with a <code>LinearMapAX</code> object.</p>
<p dir="auto">The extra <code>AA</code> in the package name here has two meanings.</p>
<ul dir="auto">
<li>
<p dir="auto"><code>LinearMapAM</code> is a subtype of <code>AbstractArray{T,2}</code>, i.e.,
<a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array" rel="nofollow">conforms to (some of) the requirements of an <code>AbstractMatrix</code></a>
type.</p>
</li>
<li>
<p dir="auto">The package was developed in Ann Arbor, Michigan :)</p>
</li>
</ul>
<p dir="auto">As of <code>v0.6</code>,
the package produces objects of two types:</p>
<ul dir="auto">
<li><code>LinearMapAM</code> (think "Matrix") that is a subtype of <code>AbstractMatrix</code>.</li>
<li><code>LinearMapAO</code> (think "Operator") that is not a subtype of <code>AbstractMatrix</code>.</li>
<li>The general type <code>LinearMapAX</code> is a <code>Union</code> of both.</li>
<li>To convert a <code>LinearMapAM</code> to a <code>LinearMapAO</code>,
use <code>redim</code> or <code>LinearMapAO(A)</code></li>
<li>To convert a <code>LinearMapAO</code> to a <code>LinearMapAM</code>, use <code>undim</code>.</li>
</ul>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="N = 6
L = LinearMap(cumsum, y -&gt; reverse(cumsum(reverse(y))), N)
A = LinearMapAA(L) # version with no properties
A = LinearMapAA(L, (name=&quot;cumsum&quot;,))) # version with a NamedTuple of properties

Matrix(L), Matrix(A) # both the same 6 x 6 lower triangular matrix
A.name # returns &quot;cumsum&quot; here"><pre>N <span class="pl-k">=</span> <span class="pl-c1">6</span>
L <span class="pl-k">=</span> <span class="pl-c1">LinearMap</span>(cumsum, y <span class="pl-k">-&gt;</span> <span class="pl-c1">reverse</span>(<span class="pl-c1">cumsum</span>(<span class="pl-c1">reverse</span>(y))), N)
A <span class="pl-k">=</span> <span class="pl-c1">LinearMapAA</span>(L) <span class="pl-c"><span class="pl-c">#</span> version with no properties</span>
A <span class="pl-k">=</span> <span class="pl-c1">LinearMapAA</span>(L, (name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>cumsum<span class="pl-pds">"</span></span>,))) <span class="pl-c"><span class="pl-c">#</span> version with a NamedTuple of properties</span>

<span class="pl-c1">Matrix</span>(L), <span class="pl-c1">Matrix</span>(A) <span class="pl-c"><span class="pl-c">#</span> both the same 6 x 6 lower triangular matrix</span>
A<span class="pl-k">.</span>name <span class="pl-c"><span class="pl-c">#</span> returns "cumsum" here</span></pre></div>
<p dir="auto">Here is a more interesting example for signal processing.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearMapsAA
using FFTW: fft, bfft
N = 8
A = LinearMapAA(fft, bfft, (N, N), (name=&quot;fft&quot;,), T=ComplexF32)
@show A[:,2]"><pre><span class="pl-k">using</span> LinearMapsAA
<span class="pl-k">using</span> FFTW<span class="pl-k">:</span> fft, bfft
N <span class="pl-k">=</span> <span class="pl-c1">8</span>
A <span class="pl-k">=</span> <span class="pl-c1">LinearMapAA</span>(fft, bfft, (N, N), (name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>fft<span class="pl-pds">"</span></span>,), T<span class="pl-k">=</span>ComplexF32)
<span class="pl-c1">@show</span> A[:,<span class="pl-c1">2</span>]</pre></div>
<p dir="auto">For more details see the examples
in the
<a href="https://jefffessler.github.io/LinearMapsAA.jl/dev/" rel="nofollow">documentation</a>.</p>
<h2 dir="auto"><a id="user-content-features-shared-with-linearmap-objects" class="anchor" aria-hidden="true" href="#features-shared-with-linearmap-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features shared with <code>LinearMap</code> objects</h2>
<h4 dir="auto"><a id="user-content-object-combinations" class="anchor" aria-hidden="true" href="#object-combinations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Object combinations</h4>
<p dir="auto">A <code>LinearMapAX</code> object supports all of the features of a <code>LinearMap</code>.
In particular, if <code>A</code> and <code>B</code> are both <code>LinearMapAX</code> objects
of appropriate sizes,
then the following each make new <code>LinearMapAX</code> objects:</p>
<ul dir="auto">
<li>
<p dir="auto">Multiplication: <code>A * B</code></p>
</li>
<li>
<p dir="auto">Linear combination: <code>A + B</code>, <code>A - B</code>, <code>3A - 7B</code></p>
</li>
<li>
<p dir="auto">Kronecker products: <code>kron(A, B)</code></p>
</li>
<li>
<p dir="auto">Concatenation: <code>[A B]</code> <code>[A; B]</code> <code>[I A I]</code> <code>[A B; 2A 3I]</code> etc.</p>
</li>
</ul>
<p dir="auto">Caution: currently some shorthand concatenations are unsupported,
like <code>[I I A]</code>, though one can accomplish that one using
<code>lmaa_hcat(I, I, A)</code></p>
<h4 dir="auto"><a id="user-content-conversions" class="anchor" aria-hidden="true" href="#conversions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Conversions</h4>
<p dir="auto">Conversion to other data types
(may require lots of memory if <code>A</code> is big):</p>
<ul dir="auto">
<li>Convert to sparse: <code>sparse(A)</code></li>
<li>Convert to dense matrix: <code>Matrix(A)</code>.</li>
</ul>
<h4 dir="auto"><a id="user-content-avoiding-memory-allocations" class="anchor" aria-hidden="true" href="#avoiding-memory-allocations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Avoiding memory allocations</h4>
<p dir="auto">Like <code>LinearMap</code> objects,
both types of <code>LinearMapAX</code> objects support <code>mul!</code>
for storing the results in a previously allocated output array,
to avoid new memory allocations.
The basic syntax is to replace
<code>y = A * x</code> with
<code>mul!(y, A, x)</code>.
To make the code look more like the math,
use the <code>InplaceOps</code> package:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using InplaceOps
@! y = A * x # shorthand for mul!(y, A, x)"><pre><span class="pl-k">using</span> InplaceOps
@<span class="pl-k">!</span> y <span class="pl-k">=</span> A <span class="pl-k">*</span> x <span class="pl-c"><span class="pl-c">#</span> shorthand for mul!(y, A, x)</span></pre></div>
<h2 dir="auto"><a id="user-content-features-unique-to-linearmapsaa" class="anchor" aria-hidden="true" href="#features-unique-to-linearmapsaa"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features unique to <code>LinearMapsAA</code></h2>
<p dir="auto">A bonus feature provided by <code>LinearMapsAA</code>
is that a user can include a <code>NamedTuple</code> of properties
with it, and then retrieve those later
using the <code>A.key</code> syntax like one would do with a struct (composite type).<br>
The nice folks over at <code>LinearMaps.jl</code>
<a href="https://github.com/Jutho/LinearMaps.jl/issues/53" data-hovercard-type="issue" data-hovercard-url="/JuliaLinearAlgebra/LinearMaps.jl/issues/53/hovercard">helped get me started</a>
with this feature.
Often linear operators are associated
with some properties,
e.g.,
a wavelet transform arises
from some mother wavelet,
and it can be convenient
to carry those properties with the object itself.
Currently
the properties are lost when one combines
two or more <code>LinearMapAA</code> objects by adding, multiplying, concatenating, etc.</p>
<p dir="auto">The following features are provided
by a <code>LinearMapAX</code> object
due to its <code>getindex</code> support:</p>
<ul dir="auto">
<li>Columns or rows slicing: <code>A[:,5]</code>, <code>A[end,:]</code>etc. return a 1D vector</li>
<li>Elements: <code>A[4,5]</code> (returns a scalar)</li>
<li>Portions: <code>A[4:6,5:8]</code> (returns a dense matrix)</li>
<li>Linear indexing: <code>A[2:9]</code> (returns a 1D vector)</li>
<li>Convert to matrix: <code>A[:,:]</code> (if memory permits)</li>
<li>Convert to vector: <code>A[:]</code> (if memory permits).</li>
</ul>
<h2 dir="auto"><a id="user-content-operator-support" class="anchor" aria-hidden="true" href="#operator-support"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Operator support</h2>
<p dir="auto">A <code>LinearMapAO</code> object
represents a linear mapping
from some input array size
into some output array size
specified by the <code>idim</code> and <code>odim</code> options.
Here is a (simplified) example for 2D MRI,
where the operator maps a 2D input array
into a 1D output vector:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FFTW: fft, bfft
using LinearMapsAA
embed = (v, samp) -&gt; setindex!(fill(zero(eltype(v)),size(samp)), v, samp)
N = (128,64) # image size
samp = rand(N...) .&lt; 0.8 # random sampling pattern
K = sum(samp) # number of k-space samples
A = LinearMapAA(x -&gt; fft(x)[samp], y -&gt; bfft(embed(y,samp)),
    (K, prod(N)) ; prop = (name=&quot;fft&quot;,), T=ComplexF32, idim=N, odim=(K,))
x = rand(N...)
z = A' * (A * x) # result is a 2D array!
typeof(A) # LinearMapAO{ComplexF32, 1, 2}"><pre><span class="pl-k">using</span> FFTW<span class="pl-k">:</span> fft, bfft
<span class="pl-k">using</span> LinearMapsAA
embed <span class="pl-k">=</span> (v, samp) <span class="pl-k">-&gt;</span> <span class="pl-c1">setindex!</span>(<span class="pl-c1">fill</span>(<span class="pl-c1">zero</span>(<span class="pl-c1">eltype</span>(v)),<span class="pl-c1">size</span>(samp)), v, samp)
N <span class="pl-k">=</span> (<span class="pl-c1">128</span>,<span class="pl-c1">64</span>) <span class="pl-c"><span class="pl-c">#</span> image size</span>
samp <span class="pl-k">=</span> <span class="pl-c1">rand</span>(N<span class="pl-k">...</span>) <span class="pl-k">.&lt;</span> <span class="pl-c1">0.8</span> <span class="pl-c"><span class="pl-c">#</span> random sampling pattern</span>
K <span class="pl-k">=</span> <span class="pl-c1">sum</span>(samp) <span class="pl-c"><span class="pl-c">#</span> number of k-space samples</span>
A <span class="pl-k">=</span> <span class="pl-c1">LinearMapAA</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">fft</span>(x)[samp], y <span class="pl-k">-&gt;</span> <span class="pl-c1">bfft</span>(<span class="pl-c1">embed</span>(y,samp)),
    (K, <span class="pl-c1">prod</span>(N)) ; prop <span class="pl-k">=</span> (name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>fft<span class="pl-pds">"</span></span>,), T<span class="pl-k">=</span>ComplexF32, idim<span class="pl-k">=</span>N, odim<span class="pl-k">=</span>(K,))
x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(N<span class="pl-k">...</span>)
z <span class="pl-k">=</span> A<span class="pl-k">'</span> <span class="pl-k">*</span> (A <span class="pl-k">*</span> x) <span class="pl-c"><span class="pl-c">#</span> result is a 2D array!</span>
<span class="pl-c1">typeof</span>(A) <span class="pl-c"><span class="pl-c">#</span> LinearMapAO{ComplexF32, 1, 2}</span></pre></div>
<p dir="auto">For more details see FFT example in the
<a href="https://jefffessler.github.io/LinearMapsAA.jl/dev/" rel="nofollow">documentation</a>.</p>
<p dir="auto">The adjoint of this <code>LinearMapAO</code> object
maps a 1D vector of k-space samples
into a 2D image array.</p>
<p dir="auto">Multiplying a <code>M × N</code> matrix times a <code>N × K</code> matrix
can be thought of as multiplying the matrix
by each of the <code>K</code> columns,
yielding a <code>M × K</code> result.
Generalizing this to higher dimensional arrays,
if <code>A::LinearMapAO</code>
has "input dimensions" <code>idim=(2,3)</code>
and "output dimensions" <code>odim=(4,5,6)</code>
and you do <code>A*X</code> where <code>X::AbstractArray</code> has dimension <code>(2,3,7,8)</code>,
then the output will be an <code>Array</code> of dimension <code>(4,5,6,7,8)</code>.
In other words, it works block-wise.
(If you really want a new <code>LinearMapAO</code>, rather than an <code>Array</code>,
then you must first wrap <code>X</code> in a <code>LinearMapAO</code>.)
This behavior deliberately departs from the non-<code>Matrix</code> like behavior
in <code>LinearMaps</code> where <code>A*X</code> produces a new <code>LinearMap</code>.</p>
<p dir="auto">Here is a corresponding example (not useful; just for illustration).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearMapsAA
idim = (2,3)
odim = (4,5,6)
forward = x -&gt; repeat(reshape(x, (idim[1],1,idim[2])) ; outer=(2,5,2))
A = LinearMapAA(forward,
    (prod(odim), prod(idim)) ; prop = (name=&quot;test&quot;,), idim, odim)
x = rand(idim..., 7, 8)
y = A * x"><pre><span class="pl-k">using</span> LinearMapsAA
idim <span class="pl-k">=</span> (<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)
odim <span class="pl-k">=</span> (<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>)
forward <span class="pl-k">=</span> x <span class="pl-k">-&gt;</span> <span class="pl-c1">repeat</span>(<span class="pl-c1">reshape</span>(x, (idim[<span class="pl-c1">1</span>],<span class="pl-c1">1</span>,idim[<span class="pl-c1">2</span>])) ; outer<span class="pl-k">=</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>,<span class="pl-c1">2</span>))
A <span class="pl-k">=</span> <span class="pl-c1">LinearMapAA</span>(forward,
    (<span class="pl-c1">prod</span>(odim), <span class="pl-c1">prod</span>(idim)) ; prop <span class="pl-k">=</span> (name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>,), idim, odim)
x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(idim<span class="pl-k">...</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>)
y <span class="pl-k">=</span> A <span class="pl-k">*</span> x</pre></div>
<p dir="auto">In the spirit of such generality,
this package overloads <code>*</code> for <code>LinearAlgebra.I</code>
(and for <code>UniformScaling</code> objects more generally)
such that
<code>I * X == X</code>
even when <code>X</code> is an array of more than two dimensions.
(The original <code>LinearAlgebra.I</code> can only multiply
vectors and matrices,
which suffices for matrix algebra,
but not for general linear algebra.)</p>
<p dir="auto">Caution:
The <code>LinearMapAM</code> type should be quite stable now,
whereas <code>LinearMapAO</code> is new in <code>v0.6</code>.
The conversions <code>redim</code> and <code>undim</code>
are probably not thoroughly tested.
The safe bet is to use all
<code>LinearMapAM</code> objects
or all
<code>LinearMapAO</code> objects
rather than trying to mix and match.</p>
<h2 dir="auto"><a id="user-content-historical-note-about-getindex" class="anchor" aria-hidden="true" href="#historical-note-about-getindex"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Historical note about <code>getindex</code></h2>
<p dir="auto">An <code>AbstractArray</code>
must support a <code>getindex</code> operation.
The maintainers of the <code>LinearMaps.jl</code> package
<a href="https://github.com/Jutho/LinearMaps.jl/issues/38" data-hovercard-type="issue" data-hovercard-url="/JuliaLinearAlgebra/LinearMaps.jl/issues/38/hovercard">originally did not wish to add <code>getindex</code> there</a>,
so this package added that feature
(while avoiding "type piracy").
Eventually,
partial <code>getindex</code> support,
<a href="https://github.com/JuliaLinearAlgebra/LinearMaps.jl/pull/165" data-hovercard-type="pull_request" data-hovercard-url="/JuliaLinearAlgebra/LinearMaps.jl/pull/165/hovercard">specifically slicing</a>,
was added in
<a href="https://github.com/JuliaLinearAlgebra/LinearMaps.jl/releases/tag/v3.7.0">v3.7</a>
there.
As of v0.11,
this package uses that <code>getindex</code> implementation
and also supports only slicing.
This is a breaking change that could be easily reverted,
so please submit an issue if you have a use case
for more general use of <code>getindex</code>.</p>
<h2 dir="auto"><a id="user-content-historical-note-about-setindex" class="anchor" aria-hidden="true" href="#historical-note-about-setindex"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Historical note about <code>setindex!</code></h2>
<p dir="auto">The
<a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array" rel="nofollow">Julia manual section on the <code>AbstractArray</code> interface</a>
implies that an <code>AbstractArray</code>
should support a <code>setindex!</code> operation.
Versions of this package prior to v0.8.0
provided that capability,
mainly for completeness
and as a proof of principle,
solely for the <code>LinearMapAM</code> type.
However,
the reality is that many sub-types of <code>AbstractArray</code>
in the Julia ecosystem,
such as <code>LinearAlgebra.Diagonal</code>,
understandably do <em>not</em> support <code>setindex!</code>,
and it there seems to be no use
for it here either.
Supporting <code>setindex!</code> seems impossible with a concrete type
for a function map,
so it is no longer supported.
The key code is relegated to the <code>archive</code> directory.</p>
<h2 dir="auto"><a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related packages</h2>
<p dir="auto"><a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl"><code>LinearOperators.jl</code></a>
also provides <code>getindex</code>-like features,
but slicing there always returns another operator,
unlike with a matrix.
In contrast,
a <code>LinearMapAM</code> object is designed to behave
akin to a matrix,
except for operations like <code>svd</code> and <code>pinv</code>
that are unsuitable for large-scale problems.
However, one can try
<a href="https://julialinearalgebra.github.io/Arpack.jl/latest/index.html#Arpack.svds" rel="nofollow"><code>Arpack.svds(A)</code></a>
to compute a few SVD components.</p>
<p dir="auto"><a href="https://github.com/JuliaArrays/LazyArrays.jl"><code>LazyArrays.jl</code></a>
and
<a href="https://github.com/JuliaArrays/BlockArrays.jl"><code>BlockArrays.jl</code></a>
also have some related features,
but only for arrays,
not linear operators defined by functions,
so <code>LinearMaps</code> is more comprehensive.</p>
<p dir="auto"><a href="https://github.com/emmt/LazyAlgebra.jl"><code>LazyAlgebra.jl</code></a>
also has many related features, and supports nonlinear mappings.</p>
<p dir="auto"><a href="https://github.com/SciML/SciMLOperators.jl"><code>SciML/SciMLOperators.jl</code></a>
seems to be designed for "matrix-free" operators
that are functions of some possibly changing parameters.</p>
<p dir="auto">This package provides similar functionality
as the <code>Fatrix</code> / <code>fatrix</code> object in the
<a href="https://github.com/JeffFessler/mirt">Matlab version of MIRT</a>.
In particular,
the <code>odim</code> and <code>idim</code> features of those objects
are similar to those here.</p>
<p dir="auto"><a href="https://github.com/hakkelt/FunctionOperators.jl"><code>FunctionOperators.jl</code></a>
supports <code>inDims</code> and <code>outDims</code> features.</p>
<p dir="auto">Being a sub-type of <code>AbstractArray</code> can be useful
for other purposes,
such as using the nice
<a href="https://github.com/MichielStock/Kronecker.jl">Kronecker.jl</a>
package.</p>
<p dir="auto">Will this list keep growing,
or will the community settle
on some common <code>AbstractLinearMap</code> base?</p>
<h2 dir="auto"><a id="user-content-inter-operability" class="anchor" aria-hidden="true" href="#inter-operability"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Inter-operability</h2>
<p dir="auto">To promote inter-operability of different linear mapping packages,
this package provides methods
for wrapping other operator types into <code>LinearMapAX</code> types.
The syntax is simply
<code>LinearMapAA(L; kwargs...)</code>
where <code>L</code> can be any of the following types currently:</p>
<ul dir="auto">
<li><code>AbstractMatrix</code> (including <code>Matrix</code>, <code>SparseMatrixCSC</code>, <code>Diagonal</code>, among many others)</li>
<li><code>LinearMap</code> from
<a href="https://github.com/Jutho/LinearMaps.jl"><code>LinearMaps.jl</code></a></li>
<li><code>LinearOperator</code> from
<a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl"><code>LinearOperators.jl</code></a>.</li>
</ul>
<p dir="auto">Submit an issue or make a PR if there are other operator types
that one would like to have supported.
To minimize package dependencies,
the wrapping code for a <code>LinearOperator</code> uses
<a href="https://github.com/JuliaPackaging/Requires.jl">Requires.jl</a>.</p>
<h2 dir="auto"><a id="user-content-multiplication-properties" class="anchor" aria-hidden="true" href="#multiplication-properties"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multiplication properties</h2>
<p dir="auto">It can help developers and users
to know how multiplication operations should behave.</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="center">Shorthand</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>LinearMapAO</code></td>
<td align="center"><code>O</code></td>
</tr>
<tr>
<td align="left"><code>LinearMapAM</code></td>
<td align="center"><code>M</code></td>
</tr>
<tr>
<td align="left"><code>LinearMap</code></td>
<td align="center"><code>L</code></td>
</tr>
<tr>
<td align="left"><code>AbstractVector</code></td>
<td align="center"><code>v</code></td>
</tr>
<tr>
<td align="left"><code>AbstractMatrix</code></td>
<td align="center"><code>X</code></td>
</tr>
<tr>
<td align="left"><code>AbstractArray</code></td>
<td align="center"><code>A</code></td>
</tr>
<tr>
<td align="left"><code>LinearAlgebra.I</code></td>
<td align="center"><code>I</code></td>
</tr>
</tbody>
</table>
<p dir="auto">For <code>left * right</code> multiplication the results are as follows.</p>
<table>
<thead>
<tr>
<th align="center">Left</th>
<th align="center">Right</th>
<th align="center">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>M</code></td>
<td align="center"><code>v</code></td>
<td align="center"><code>v</code></td>
</tr>
<tr>
<td align="center"><code>v'</code></td>
<td align="center"><code>M</code></td>
<td align="center"><code>v'</code></td>
</tr>
<tr>
<td align="center"><code>M</code></td>
<td align="center"><code>X</code></td>
<td align="center"><code>X</code></td>
</tr>
<tr>
<td align="center"><code>X</code></td>
<td align="center"><code>M</code></td>
<td align="center"><code>X</code></td>
</tr>
<tr>
<td align="center"><code>M</code></td>
<td align="center"><code>M</code></td>
<td align="center"><code>M</code></td>
</tr>
<tr>
<td align="center"><code>M</code></td>
<td align="center"><code>L</code></td>
<td align="center"><code>M</code></td>
</tr>
<tr>
<td align="center"><code>L</code></td>
<td align="center"><code>M</code></td>
<td align="center"><code>M</code></td>
</tr>
<tr>
<td align="center"><code>O</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
</tr>
<tr>
<td align="center"><code>A</code></td>
<td align="center"><code>O</code></td>
<td align="center"><code>A</code></td>
</tr>
<tr>
<td align="center"><code>O</code></td>
<td align="center"><code>O</code></td>
<td align="center"><code>O</code></td>
</tr>
<tr>
<td align="center"><code>I</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
</tr>
</tbody>
</table>
<p dir="auto">The following subset of the above operations also work
for the in-place version <code>mul!(result, left, right)</code>:</p>
<table>
<thead>
<tr>
<th align="center">Left</th>
<th align="center">Right</th>
<th align="center">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>M</code></td>
<td align="center"><code>v</code></td>
<td align="center"><code>v</code></td>
</tr>
<tr>
<td align="center"><code>v'</code></td>
<td align="center"><code>M</code></td>
<td align="center"><code>v'</code></td>
</tr>
<tr>
<td align="center"><code>M</code></td>
<td align="center"><code>X</code></td>
<td align="center"><code>X</code></td>
</tr>
<tr>
<td align="center"><code>X</code></td>
<td align="center"><code>M</code></td>
<td align="center"><code>X</code></td>
</tr>
<tr>
<td align="center"><code>O</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
</tr>
<tr>
<td align="center"><code>A</code></td>
<td align="center"><code>O</code></td>
<td align="center"><code>A</code></td>
</tr>
</tbody>
</table>
<p dir="auto">There is one more special multiplication property.
If <code>O</code> is a <code>LinearMapAO</code> and <code>xv</code> is <code>Vector</code> of <code>AbstractArrays</code>,
then <code>O * xv</code> is equivalent to <code>[O * x for x in xv]</code>.
This is useful, for example,
in dynamic imaging
where one might store a video sequence
as a vector of 2D images,
rather than as a 3D array.
There is also a corresponding
<a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.mul!" rel="nofollow">5-argument <code>mul!</code></a>.
Each array in the <code>Vector</code> <code>xv</code>
must be compatible with multiplication on the left by <code>O</code>.</p>
<h2 dir="auto"><a id="user-content-credits" class="anchor" aria-hidden="true" href="#credits"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Credits</h2>
<p dir="auto">This software was developed at the
<a href="https://umich.edu/" rel="nofollow">University of Michigan</a>
by
<a href="https://web.eecs.umich.edu/~fessler" rel="nofollow">Jeff Fessler</a>
and his
<a href="https://web.eecs.umich.edu/~fessler/group" rel="nofollow">group</a>,
with substantial inspiration drawn
from the <code>LinearMaps</code> package.</p>
<h2 dir="auto"><a id="user-content-compatibility" class="anchor" aria-hidden="true" href="#compatibility"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Compatibility</h2>
<ul dir="auto">
<li>Version 0.2.0 tested with Julia 1.1 and 1.2</li>
<li>Version 0.3.0 requires Julia 1.3</li>
<li>Version 0.6.0 assumes Julia 1.4</li>
<li>Version 0.7.0 assumes Julia 1.6</li>
</ul>
<h2 dir="auto"><a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting started</h2>
<p dir="auto">This package is registered in the
<a href="https://github.com/JuliaRegistries/General"><code>General</code></a> registry,
so you can install it at the REPL with <code>] add LinearMapAA</code>.</p>
<p dir="auto">Here are
<a href="https://github.com/JeffFessler/MIRT.jl/blob/main/doc/start.md">detailed installation instructions</a>.</p>
<p dir="auto">This package is included in the
Michigan Image Reconstruction Toolbox
<a href="https://github.com/JeffFessler/MIRT.jl"><code>MIRT.jl</code></a>
and is exported there
so that MIRT users can use it
without "separate" installation.</p>


</article></div>