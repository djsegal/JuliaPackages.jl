<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-lazyjsonjl" class="anchor" aria-hidden="true" href="#lazyjsonjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LazyJSON.jl</h1>
<p dir="auto"><a href="https://travis-ci.org/JuliaCloud/LazyJSON.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/3882a8965d6c08269eacfaa001a9cf51a8690cb415b37328fe944814ef6195b3/68747470733a2f2f7472617669732d63692e6f72672f4a756c6961436c6f75642f4c617a794a534f4e2e6a6c2e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaCloud/LazyJSON.jl.svg" style="max-width: 100%;"></a></p>
<p dir="auto">LazyJSON is an interface for reading JSON data in Julia programs.</p>
<p dir="auto">If you find it useful, or not, please report your experiance in the <a href="https://discourse.julialang.org/t/announce-a-different-way-to-read-json-data-lazyjson-jl/9046" rel="nofollow">discourse thread</a>.</p>
<p dir="auto">LazyJSON provides direct access to values stored in a JSON text though standard Julia
interfaces: <code>Number</code>, <code>AbstractString</code>, <code>AbstractVector</code> and <code>AbstractDict</code>.</p>
<p dir="auto">The function <code>LazyJSON.value</code> constructs an object representing the value(s) of a JSON text.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="LazyJSON.value(jsontext::AbstractString) -&gt; Union{Bool,
                                                  LazyJSON.Number,
                                                  LazyJSON.String,
                                                  LazyJSON.Array,
                                                  LazyJSON.Object,
                                                  Nothing}
LazyJSON.Number &lt;: Base.Number
LazyJSON.String &lt;: AbstractString
LazyJSON.Array  &lt;: AbstractVector{Any}
LazyJSON.Object &lt;: AbstractDict{AbstractString,Any}"><pre>LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>) <span class="pl-k">-&gt;</span> Union{Bool,
                                                  LazyJSON<span class="pl-k">.</span>Number,
                                                  LazyJSON<span class="pl-k">.</span>String,
                                                  LazyJSON<span class="pl-k">.</span>Array,
                                                  LazyJSON<span class="pl-k">.</span>Object,
                                                  Nothing}
LazyJSON<span class="pl-k">.</span>Number <span class="pl-k">&lt;:</span> <span class="pl-c1">Base.Number</span>
LazyJSON<span class="pl-k">.</span>String <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractString</span>
LazyJSON<span class="pl-k">.</span>Array  <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractVector{Any}</span>
LazyJSON<span class="pl-k">.</span>Object <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractDict{AbstractString,Any}</span></pre></div>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; j = LazyJSON.value(&quot;&quot;&quot;{
           &quot;foo&quot;: [1, 2, 3, &quot;four&quot;]
           &quot;bar&quot;: null
       }&quot;&quot;&quot;)
LazyJSON.Object with 2 entries:
  &quot;foo&quot; =&gt; Any[1, 2, 3, &quot;four&quot;]
  &quot;bar&quot; =&gt; nothing

julia&gt; j[&quot;foo&quot;]
4-element LazyJSON.Array:
 1
 2
 3
  &quot;four&quot;

julia&gt; j[&quot;foo&quot;][4]
&quot;four&quot;

julia&gt; typeof(j[&quot;bar&quot;])
Nothing"><pre>julia<span class="pl-k">&gt;</span> j <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(<span class="pl-s"><span class="pl-pds">"""</span>{</span>
<span class="pl-s">           "foo": [1, 2, 3, "four"]</span>
<span class="pl-s">           "bar": null</span>
<span class="pl-s">       }<span class="pl-pds">"""</span></span>)
LazyJSON<span class="pl-k">.</span>Object with <span class="pl-c1">2</span> entries<span class="pl-k">:</span>
  <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> Any[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-s"><span class="pl-pds">"</span>four<span class="pl-pds">"</span></span>]
  <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">nothing</span>

julia<span class="pl-k">&gt;</span> j[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>]
<span class="pl-c1">4</span><span class="pl-k">-</span>element LazyJSON<span class="pl-k">.</span>Array<span class="pl-k">:</span>
 <span class="pl-c1">1</span>
 <span class="pl-c1">2</span>
 <span class="pl-c1">3</span>
  <span class="pl-s"><span class="pl-pds">"</span>four<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> j[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-c1">4</span>]
<span class="pl-s"><span class="pl-pds">"</span>four<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(j[<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>])
Nothing</pre></div>
<p dir="auto">The fields of JSON objects can also be accessed using <code>'.'</code> (<code>getproperty</code>)
syntax.</p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; j = LazyJSON.value(&quot;&quot;&quot;{
           &quot;foo&quot;: [1, 2, 3, &quot;four&quot;]
           &quot;bar&quot;: null
       }&quot;&quot;&quot;; getproperty=true)
julia&gt; j.foo
4-element LazyJSON.Array:
 1
 2
 3
  &quot;four&quot;"><pre>julia<span class="pl-k">&gt;</span> j <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(<span class="pl-s"><span class="pl-pds">"""</span>{</span>
<span class="pl-s">           "foo": [1, 2, 3, "four"]</span>
<span class="pl-s">           "bar": null</span>
<span class="pl-s">       }<span class="pl-pds">"""</span></span>; getproperty<span class="pl-k">=</span><span class="pl-c1">true</span>)
julia<span class="pl-k">&gt;</span> j<span class="pl-k">.</span>foo
<span class="pl-c1">4</span><span class="pl-k">-</span>element LazyJSON<span class="pl-k">.</span>Array<span class="pl-k">:</span>
 <span class="pl-c1">1</span>
 <span class="pl-c1">2</span>
 <span class="pl-c1">3</span>
  <span class="pl-s"><span class="pl-pds">"</span>four<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">JSON Objects can be converted to <code>struct</code> types.</p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; struct Point
           x::Int
           y::Int
       end

julia&gt; struct Line
           a::Point
           b::Point
       end

julia&gt; struct Arrow
           label::String
           segments::Vector{Line}
           dashed::Bool
       end

julia&gt; convert(Arrow, LazyJSON.value(&quot;&quot;&quot;{
           &quot;label&quot;: &quot;Hello&quot;,
           &quot;segments&quot;: [
                {&quot;a&quot;: {&quot;x&quot;: 1, &quot;y&quot;: 1}, &quot;b&quot;: {&quot;x&quot;: 2, &quot;y&quot;: 2}},
                {&quot;a&quot;: {&quot;x&quot;: 2, &quot;y&quot;: 2}, &quot;b&quot;: {&quot;x&quot;: 3, &quot;y&quot;: 3}}
            ],
            &quot;dashed&quot;: false
       }&quot;&quot;&quot;))
Arrow(&quot;Hello&quot;, Line[Line(Point(1, 1), Point(2, 2)), Line(Point(2, 2), Point(3, 3))], false)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Point
           x<span class="pl-k">::</span><span class="pl-c1">Int</span>
           y<span class="pl-k">::</span><span class="pl-c1">Int</span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Line
           a<span class="pl-k">::</span><span class="pl-c1">Point</span>
           b<span class="pl-k">::</span><span class="pl-c1">Point</span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Arrow
           label<span class="pl-k">::</span><span class="pl-c1">String</span>
           segments<span class="pl-k">::</span><span class="pl-c1">Vector{Line}</span>
           dashed<span class="pl-k">::</span><span class="pl-c1">Bool</span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">convert</span>(Arrow, LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(<span class="pl-s"><span class="pl-pds">"""</span>{</span>
<span class="pl-s">           "label": "Hello",</span>
<span class="pl-s">           "segments": [</span>
<span class="pl-s">                {"a": {"x": 1, "y": 1}, "b": {"x": 2, "y": 2}},</span>
<span class="pl-s">                {"a": {"x": 2, "y": 2}, "b": {"x": 3, "y": 3}}</span>
<span class="pl-s">            ],</span>
<span class="pl-s">            "dashed": false</span>
<span class="pl-s">       }<span class="pl-pds">"""</span></span>))
<span class="pl-c1">Arrow</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, Line[<span class="pl-c1">Line</span>(<span class="pl-c1">Point</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>), <span class="pl-c1">Point</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)), <span class="pl-c1">Line</span>(<span class="pl-c1">Point</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-c1">Point</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>))], <span class="pl-c1">false</span>)</pre></div>
<p dir="auto"><em>For compatibility with other JSON interfaces that have a <code>parse</code> function,
<code>LazyJSON.parse</code> is provided as an alias for <code>LazyJSON.value</code>. e.g.</em></p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; j = LazyJSON.parse(&quot;&quot;&quot;{
           &quot;foo&quot;: [1, 2, 3, &quot;four&quot;]
           &quot;bar&quot;: null
       }&quot;&quot;&quot;)

julia&gt; j[&quot;foo&quot;][4]
&quot;four&quot;"><pre>julia<span class="pl-k">&gt;</span> j <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">parse</span>(<span class="pl-s"><span class="pl-pds">"""</span>{</span>
<span class="pl-s">           "foo": [1, 2, 3, "four"]</span>
<span class="pl-s">           "bar": null</span>
<span class="pl-s">       }<span class="pl-pds">"""</span></span>)

julia<span class="pl-k">&gt;</span> j[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-c1">4</span>]
<span class="pl-s"><span class="pl-pds">"</span>four<span class="pl-pds">"</span></span></pre></div>
<h1 dir="auto"><a id="user-content-lazyness" class="anchor" aria-hidden="true" href="#lazyness"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Lazyness</h1>
<p dir="auto">LazyJSON is lazy in the sense that it assumes that its input is well formed JSON
text. It does not try to detect every type of JSON syntax error. If security is
a concern, JSON data of unknown providence should probably be validated before
use.</p>
<p dir="auto">LazyJSON is also lazy in the sense that it does not process any part of the JSON
text until values are requested through the <code>AbstractVector</code> and <code>AbstractDict</code>
interfaces.</p>
<p dir="auto">i.e. <code>j = LazyJSON.value(jsontext)</code> does no parsing and immediately
returns a thin wrapper object.</p>
<p dir="auto"><code>j["foo"]</code> calls <code>get(::AbstractDict, "foo")</code>, which parses just enough to find
the <code>"foo"</code> field.</p>
<p dir="auto"><code>j["foo"][4]</code> calls <code>getindex(::AbstractArray, 4)</code>, which continues paring up to
the fourth item in the array.</p>
<p dir="auto">This results in much less memory allocation compared to non-lazy parsers:</p>
<p dir="auto">JSON.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="j = String(read(&quot;ec2-2016-11-15.normal.json&quot;))
julia&gt; function f(json)
           v = JSON.parse(json)
           v[&quot;shapes&quot;][&quot;scope&quot;][&quot;enum&quot;][1]
       end

julia&gt; @time f(j)
  0.066773 seconds (66.43 k allocations: 7.087 MiB)
&quot;Availability Zone&quot;"><pre>j <span class="pl-k">=</span> <span class="pl-c1">String</span>(<span class="pl-c1">read</span>(<span class="pl-s"><span class="pl-pds">"</span>ec2-2016-11-15.normal.json<span class="pl-pds">"</span></span>))
julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">f</span>(json)
           v <span class="pl-k">=</span> JSON<span class="pl-k">.</span><span class="pl-c1">parse</span>(json)
           v[<span class="pl-s"><span class="pl-pds">"</span>shapes<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>scope<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>enum<span class="pl-pds">"</span></span>][<span class="pl-c1">1</span>]
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> <span class="pl-c1">f</span>(j)
  <span class="pl-c1">0.066773</span> seconds (<span class="pl-c1">66.43</span> k allocations<span class="pl-k">:</span> <span class="pl-c1">7.087</span> MiB)
<span class="pl-s"><span class="pl-pds">"</span>Availability Zone<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">LazyJSON.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; function f(json)
           v = LazyJSON.parse(json)
           v[&quot;shapes&quot;][&quot;scope&quot;][&quot;enum&quot;][1]
       end

julia&gt; @time f(j)
  0.001392 seconds (12 allocations: 384 bytes)
&quot;Availability Zone&quot;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">f</span>(json)
           v <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">parse</span>(json)
           v[<span class="pl-s"><span class="pl-pds">"</span>shapes<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>scope<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>enum<span class="pl-pds">"</span></span>][<span class="pl-c1">1</span>]
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time</span> <span class="pl-c1">f</span>(j)
  <span class="pl-c1">0.001392</span> seconds (<span class="pl-c1">12</span> allocations<span class="pl-k">:</span> <span class="pl-c1">384</span> bytes)
<span class="pl-s"><span class="pl-pds">"</span>Availability Zone<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">LazyJSON's <code>AbstractString</code> and <code>Number</code> implementations are lazy too.</p>
<p dir="auto">The text of a <code>LazyJSON.Number</code> is not parsed to <code>Int64</code> or <code>Float64</code> form
until it is needed for a numeric operation. If the number is only used in a
textual context, it need never be parsed at all. e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="j = LazyJSON.value(jsontext)
html = &quot;&quot;&quot;&lt;img width=$(j[&quot;width&quot;]), height=$(j[&quot;height&quot;])&gt;&quot;&quot;&quot;"><pre>j <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)
html <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span>&lt;img width=<span class="pl-v">$(j[<span class="pl-s"><span class="pl-pds">"</span>width<span class="pl-pds">"</span></span>])</span>, height=<span class="pl-v">$(j[<span class="pl-s"><span class="pl-pds">"</span>height<span class="pl-pds">"</span></span>])</span>&gt;<span class="pl-pds">"""</span></span></pre></div>
<p dir="auto">Likewise, the content of a <code>LazyJSON.String</code> is not interpreted until it is
accessed. If a <code>LazyJSON.String</code> containing complex UTF16 escape sequences is
compared to a UTF8 <code>Base.String</code>, and the two strings differ in the first
few characters, then the comparison will terminate before the any unescaping
work needs to be done.</p>
<h1 dir="auto"><a id="user-content-lazyjson-performance-considerations" class="anchor" aria-hidden="true" href="#lazyjson-performance-considerations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LazyJSON Performance Considerations</h1>
<h2 dir="auto"><a id="user-content-lazyjsonarray-performance" class="anchor" aria-hidden="true" href="#lazyjsonarray-performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LazyJSON.Array Performance</h2>
<p dir="auto">The <code>LazyJSON.Array</code> does not keep track of the indices of its items.
Every <code>array[i]</code> access scans all the values in the array until it reaches
the <code>i</code>th value. This is fast if you only need to access a single item,
even near the end of the array, because the alternative of transforming the
<code>LazyJSON.Array</code> into a <code>Base.Array</code> must scan the entire array and allocate
new memory for each item. It is also fast to access multiple items near the
start of the array. However, if you need random access to many items in a large
array it is better to convert it to a <code>Base.Array</code>.</p>
<p dir="auto">e.g.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="v = LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;bar&quot;][&quot;an_array&quot;]
v = convert(Vector{Any}, v)"><pre class="notranslate"><code>v = LazyJSON.value(jsontext)["foo"]["bar"]["an_array"]
v = convert(Vector{Any}, v)
</code></pre></div>
<p dir="auto">If you need to access the items in the array sequentially, the iteration
interface is very efficient, but incrementing an index is very inefficient.
<code>length(::LazyJSON.Array)</code> is also inefficient, in that it must scan the whole
array.</p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="v = LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;bar&quot;][&quot;an_array&quot;]
for i in v ✅
    println(i)
end

r = map(i -&gt; f(i), v) ✅

i = 1
while i &lt; length(v) ❌
    println(v[i]) ❌
end"><pre>v <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>an_array<span class="pl-pds">"</span></span>]
<span class="pl-k">for</span> i <span class="pl-k">in</span> v ✅
    <span class="pl-c1">println</span>(i)
<span class="pl-k">end</span>

r <span class="pl-k">=</span> <span class="pl-c1">map</span>(i <span class="pl-k">-&gt;</span> <span class="pl-c1">f</span>(i), v) ✅

i <span class="pl-k">=</span> <span class="pl-c1">1</span>
<span class="pl-k">while</span> i <span class="pl-k">&lt;</span> <span class="pl-c1">length</span>(v) ❌
    <span class="pl-c1">println</span>(v[i]) ❌
<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-lazyjsonobject-performance" class="anchor" aria-hidden="true" href="#lazyjsonobject-performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LazyJSON.Object Performance</h2>
<p dir="auto">The performance considerations for <code>LazyJSON.Object</code> are similar to those
described above for <code>LazyJSON.Array</code>. The <code>LazyJSON.Object</code> does not keep a
hash table of keys. Every <code>object["key"]</code> access scans all the keys in the
object until it finds a match. Accessing a keys in an object with a small
number of keys is efficient. Accessing a few keys in an object with many keys
is effiecient. However, if you need random acess to many keys in a large object
it is better to convert it to a <code>Base.Dict</code>.</p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="v = LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;bar&quot;][&quot;an_object_with_many_keys&quot;]
v = convert(Dict, v)"><pre>v <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>an_object_with_many_keys<span class="pl-pds">"</span></span>]
v <span class="pl-k">=</span> <span class="pl-c1">convert</span>(Dict, v)</pre></div>
<p dir="auto"><code>length(::LazyJSON.Object)</code> is inefficient, in that it must scan the whole
object.
If you need to access the key value pairs sequentially, the iteration
interface is very efficient.</p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="o = LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;bar&quot;][&quot;an_object_with_many_keys&quot;]
for (k, v) in o ✅
    println(k, v)
end

r = filter((k, v) -&gt; contains(i, r&quot;.jpg$&quot;, o)) ✅

for k in long_list_of_keys
    println(o[k]) ❌
end

d = convert(Dict, o)
for k in long_list_of_keys
    println(d[k]) ✅
end"><pre>o <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>an_object_with_many_keys<span class="pl-pds">"</span></span>]
<span class="pl-k">for</span> (k, v) <span class="pl-k">in</span> o ✅
    <span class="pl-c1">println</span>(k, v)
<span class="pl-k">end</span>

r <span class="pl-k">=</span> <span class="pl-c1">filter</span>((k, v) <span class="pl-k">-&gt;</span> <span class="pl-c1">contains</span>(i, <span class="pl-sr"><span class="pl-pds">r"</span>.jpg$<span class="pl-pds">"</span></span>, o)) ✅

<span class="pl-k">for</span> k <span class="pl-k">in</span> long_list_of_keys
    <span class="pl-c1">println</span>(o[k]) ❌
<span class="pl-k">end</span>

d <span class="pl-k">=</span> <span class="pl-c1">convert</span>(Dict, o)
<span class="pl-k">for</span> k <span class="pl-k">in</span> long_list_of_keys
    <span class="pl-c1">println</span>(d[k]) ✅
<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-lazyjsonnumber-performance" class="anchor" aria-hidden="true" href="#lazyjsonnumber-performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LazyJSON.Number Performance</h2>
<p dir="auto">Whenever a <code>LazyJSON.Number</code> is used in a numeric operation it must be parsed
from its string form into an <code>Int</code> or a <code>Float</code>. If you are only using each
each numetic value once, there is no performance penalty, as the string is only
parsed once. However if you need to use the numeric value many times, it is
better to convert it to a normal <code>Base</code> number type.</p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="i = LazyJSON.value(jsontext)[&quot;foo&quot;]
x = origin.x + i[&quot;width&quot;],  ✅ used once in an addition operation
y = origin.y + i[&quot;height&quot;]  ✅
draw(i[&quot;data&quot;], x, y)


limit = LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;limit&quot;]
i = 0
while i &lt; limit ❌ re-parsed every time the less than operation is evaluated
    i += 1
    ...
end
limit = convert(Int, LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;limit&quot;]) ✅


v = LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;ammounts&quot;]
total = sum(v) ✅ iteration is efficient, each number is parsed once.


struct Foo
    x::Int
    y::Int
end
i = LazyJSON.value(jsontext)[&quot;foo&quot;]
Foo(i[&quot;x&quot;], i[&quot;y&quot;]) ✅ converted to `Int` on assignment to struct fields.


v = LazyJSON.value(jsontext)[&quot;foo&quot;][&quot;values&quot;]
ints = convert(Vector{Int}, v) ✅ manual conversion when needed"><pre>i <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>]
x <span class="pl-k">=</span> origin<span class="pl-k">.</span>x <span class="pl-k">+</span> i[<span class="pl-s"><span class="pl-pds">"</span>width<span class="pl-pds">"</span></span>],  ✅ used once <span class="pl-k">in</span> an addition operation
y <span class="pl-k">=</span> origin<span class="pl-k">.</span>y <span class="pl-k">+</span> i[<span class="pl-s"><span class="pl-pds">"</span>height<span class="pl-pds">"</span></span>]  ✅
<span class="pl-c1">draw</span>(i[<span class="pl-s"><span class="pl-pds">"</span>data<span class="pl-pds">"</span></span>], x, y)


limit <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>limit<span class="pl-pds">"</span></span>]
i <span class="pl-k">=</span> <span class="pl-c1">0</span>
<span class="pl-k">while</span> i <span class="pl-k">&lt;</span> limit ❌ re<span class="pl-k">-</span>parsed every time the less than operation is evaluated
    i <span class="pl-k">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">...</span>
<span class="pl-k">end</span>
limit <span class="pl-k">=</span> <span class="pl-c1">convert</span>(Int, LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>limit<span class="pl-pds">"</span></span>]) ✅


v <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>ammounts<span class="pl-pds">"</span></span>]
total <span class="pl-k">=</span> <span class="pl-c1">sum</span>(v) ✅ iteration is efficient, each number is parsed once.


<span class="pl-k">struct</span> Foo
    x<span class="pl-k">::</span><span class="pl-c1">Int</span>
    y<span class="pl-k">::</span><span class="pl-c1">Int</span>
<span class="pl-k">end</span>
i <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>]
<span class="pl-c1">Foo</span>(i[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>], i[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>]) ✅ converted to <span class="pl-s"><span class="pl-pds">`</span>Int<span class="pl-pds">`</span></span> on assignment to <span class="pl-k">struct</span> fields.


v <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(jsontext)[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>values<span class="pl-pds">"</span></span>]
ints <span class="pl-k">=</span> <span class="pl-c1">convert</span>(Vector{Int}, v) ✅ manual conversion when needed</pre></div>
<h1 dir="auto"><a id="user-content-implementation" class="anchor" aria-hidden="true" href="#implementation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementation</h1>
<p dir="auto">Values are represented by a reference to the JSON text <code>String</code>
and the byte index of the value text. The <code>LazyJSON.value(jsontext)</code> function
simply returns a <code>LazyJSON.Value</code> object with <code>s = jsontext</code> and <code>i = 1</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="    String: {&quot;foo&quot;: 1,    &quot;bar&quot;: [1, 2, 3, &quot;four&quot;]}
            ▲                    ▲      ▲  ▲
            │                    │      │  │
            ├─────────────────┐  │      │  │
            │ LazyJSON.Array( s, i=9)   │  │   == Any[1, 2, 3, &quot;four&quot;]
            │                           │  │
            ├─────────────────┐  ┌──────┘  │
            │ LazyJSON.Number(s, i=16)     │   == 3
            │                              │
            ├─────────────────┐  ┌─────────┘
            │ LazyJSON.String(s, i=19)         == &quot;four&quot;
            │
            └─────────────────┬──┐
              LazyJSON.Object(s, i=1)"><pre class="notranslate"><code>    String: {"foo": 1,    "bar": [1, 2, 3, "four"]}
            ▲                    ▲      ▲  ▲
            │                    │      │  │
            ├─────────────────┐  │      │  │
            │ LazyJSON.Array( s, i=9)   │  │   == Any[1, 2, 3, "four"]
            │                           │  │
            ├─────────────────┐  ┌──────┘  │
            │ LazyJSON.Number(s, i=16)     │   == 3
            │                              │
            ├─────────────────┐  ┌─────────┘
            │ LazyJSON.String(s, i=19)         == "four"
            │
            └─────────────────┬──┐
              LazyJSON.Object(s, i=1)
</code></pre></div>
<p dir="auto">LazyJSON does not parse and translate values into concrete Julia <code>Number</code>,
<code>String</code>, <code>Array</code> or <code>Dict</code> objects. Instead it provides interface methods that
conform to the protocols of <code>Base.Number</code>, <code>AbstractString</code>, <code>AbstractVector</code>
and <code>AbstractDict</code>.  These methods interpret the JSON text on the fly and parse
only as much as is needed return the requested values.</p>
<h1 dir="auto"><a id="user-content-large-json-texts" class="anchor" aria-hidden="true" href="#large-json-texts"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Large JSON Texts</h1>
<p dir="auto">LazyJSON can process JSON files that are too big to fit in available RAM
by using the <code>mmap</code> interface.</p>
<p dir="auto">e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Mmap
f = open(&quot;huge_file_that_wont_fit_in_ram.json&quot;, &quot;r&quot;)
s = String(Mmap.mmap(f))
j = LazyJSON.value(s)
v = j[&quot;foo&quot;][&quot;bar&quot;]"><pre><span class="pl-k">using</span> Mmap
f <span class="pl-k">=</span> <span class="pl-c1">open</span>(<span class="pl-s"><span class="pl-pds">"</span>huge_file_that_wont_fit_in_ram.json<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>)
s <span class="pl-k">=</span> <span class="pl-c1">String</span>(Mmap<span class="pl-k">.</span><span class="pl-c1">mmap</span>(f))
j <span class="pl-k">=</span> LazyJSON<span class="pl-k">.</span><span class="pl-c1">value</span>(s)
v <span class="pl-k">=</span> j[<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>]</pre></div>
<p dir="auto">The operating stytem will lazily load enough chunks of the file into RAM to
reach field <code>"bar"</code> of opject <code>"foo"</code>.</p>
<h1 dir="auto"><a id="user-content-benchmarks" class="anchor" aria-hidden="true" href="#benchmarks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Benchmarks</h1>
<p dir="auto">For some workloads lazyness makes LazyJSON faster and less memory intensive
than JSON parsers that parse the entire JSON text and allocate a tree of
collection and value objects.</p>
<p dir="auto">The <code>test/benchmark.jl</code> test uses a <a href="https://github.com/samoconnor/jsonhack/blob/master/test/ec2-2016-11-15.normal.json">1MB AWS API definition JSON file</a>
to compare performance vs JSON.jl.  When accessing a value close to the
start of the file the lazy parser is orders of magnitude faster than JSON.jl,
for values near then end of the file, the lazy parser is about 6 times faster.
(Each test case is run once for JIT warmup, then 190 times for measurement.)</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Julia Version 0.7.0-DEV.3761
JSON.jl master Tue Feb 6, 98727675b635c8428effa30a2287a9fe6370e664

Access value close to start:
LazyJSON.jl:  0.000568 seconds (3.42 k allocations: 139.531 KiB)
JSON.jl:      6.410700 seconds (13.28 M allocations: 1.337 GiB, 3.17% gc time)


Access 2 values close to end:
LazyJSON.jl:  0.177059 seconds (7.79 k allocations: 347.344 KiB)
JSON.jl:      6.417241 seconds (13.28 M allocations: 1.337 GiB, 3.18% gc time)"><pre class="notranslate"><code>Julia Version 0.7.0-DEV.3761
JSON.jl master Tue Feb 6, 98727675b635c8428effa30a2287a9fe6370e664

Access value close to start:
LazyJSON.jl:  0.000568 seconds (3.42 k allocations: 139.531 KiB)
JSON.jl:      6.410700 seconds (13.28 M allocations: 1.337 GiB, 3.17% gc time)


Access 2 values close to end:
LazyJSON.jl:  0.177059 seconds (7.79 k allocations: 347.344 KiB)
JSON.jl:      6.417241 seconds (13.28 M allocations: 1.337 GiB, 3.18% gc time)
</code></pre></div>
<p dir="auto"><em>Note, until recently JSON.jl was taking ~1 second for the tests above.
It seems that it may be hampered deprecation of <code>IOBuffer(maxsize::Integer)</code>.</em></p>
<p dir="auto">The <code>test/benchmark_geo.jl</code> test uses a 1.2MB GeoJSON file
to compare performance vs JSON.jl. The first test extracts a country name
near the middle of the file. The second test checks that the country outline
polygon is at the expected coordinates.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Country name
LazyJSON.jl:  0.004762 seconds (190 allocations: 5.938 KiB)
JSON.jl:      1.063652 seconds (8.62 M allocations: 373.471 MiB, 11.19% gc time)

Map data
LazyJSON.jl:  0.011075 seconds (27.30 k allocations: 679.547 KiB)
JSON.jl:      1.064750 seconds (8.62 M allocations: 373.541 MiB, 10.75% gc time)"><pre class="notranslate"><code>Country name
LazyJSON.jl:  0.004762 seconds (190 allocations: 5.938 KiB)
JSON.jl:      1.063652 seconds (8.62 M allocations: 373.471 MiB, 11.19% gc time)

Map data
LazyJSON.jl:  0.011075 seconds (27.30 k allocations: 679.547 KiB)
JSON.jl:      1.064750 seconds (8.62 M allocations: 373.541 MiB, 10.75% gc time)
</code></pre></div>
<h1 dir="auto"><a id="user-content-todo" class="anchor" aria-hidden="true" href="#todo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>TODO:</h1>
<ul dir="auto">
<li>New Lazyer parser looses some format validation, consider recovering old
code validation code from <code>src/OldLazyJSON.jl</code></li>
</ul>
<h1 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h1>
<ul dir="auto">
<li>Another lazy JSON parser: <a href="https://github.com/doubledutch/LazyJSON">https://github.com/doubledutch/LazyJSON</a></li>
<li>RFC 7159: <a href="https://tools.ietf.org/html/rfc7159" rel="nofollow">https://tools.ietf.org/html/rfc7159</a></li>
</ul>
</article></div>