<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/logo.png"><img height="150" src="docs/src/assets/logo.png" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-directorbitsjl" class="anchor" aria-hidden="true" href="#directorbitsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DirectOrbits.jl</h1>
<p dir="auto">This was the privately registered version of <a href="https://github.com/sefffal/PlanetOrbits.jl">https://github.com/sefffal/PlanetOrbits.jl</a> while it was in development.</p>
<p dir="auto">This page is retained for compatibility &amp; history only.</p>
<p dir="auto"><a href="https://sefffal.github.io/DirectOrbits.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/sefffal/DirectOrbits.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d27398f2059323bcf1ae7c5ecd698ec3303d262c7188fea5b29afba272ecaf10/68747470733a2f2f636f6465636f762e696f2f67682f7365666666616c2f4469726563744f72626974732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d514c5443425756563938" alt="codecov" data-canonical-src="https://codecov.io/gh/sefffal/DirectOrbits.jl/branch/master/graph/badge.svg?token=QLTCBWVV98" style="max-width: 100%;"></a></p>
<p dir="auto">Tools for solving Keplerian orbits in the context of direct imaging.
The primary use case is mapping Keplerian orbital elements into Cartesian
coordinates at different times. A Plots.jl recipe is included for easily plotting orbits.</p>
<p dir="auto">Among other values, it calculates the projected positions of planets, as well as stellar radial velocity and proper motion anomaly. It's a great tool for visualizing different orbits (see examples) and generating nice animations (e.g. with Plots or Luxor.jl).</p>
<p dir="auto">This package has been designed for good performance and composability with a wide range of packages in the Julia ecosystem, including ForwardDiff.</p>
<p dir="auto">To fit orbits to observations, see <a href="https://github.com/sefffal/DirectDetections.jl">DirectDetections.jl</a>.</p>
<p dir="auto">See also <a href="https://github.com/sefffal/DirectImages.jl">DirectImages.jl</a>.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DirectOrbits

# See below for units and conventions on these parameters.
elements = KeplerianElementsDeg(a=1, i=45, e=0.25, τ=0, M=1, ω=0, Ω=120, plx=35)

# Display one full period of the orbit (run `using Plots` first)
using Plots
plot(elements, label=&quot;My Planet&quot;)"><pre><span class="pl-k">using</span> DirectOrbits

<span class="pl-c"><span class="pl-c">#</span> See below for units and conventions on these parameters.</span>
elements <span class="pl-k">=</span> <span class="pl-c1">KeplerianElementsDeg</span>(a<span class="pl-k">=</span><span class="pl-c1">1</span>, i<span class="pl-k">=</span><span class="pl-c1">45</span>, e<span class="pl-k">=</span><span class="pl-c1">0.25</span>, τ<span class="pl-k">=</span><span class="pl-c1">0</span>, M<span class="pl-k">=</span><span class="pl-c1">1</span>, ω<span class="pl-k">=</span><span class="pl-c1">0</span>, Ω<span class="pl-k">=</span><span class="pl-c1">120</span>, plx<span class="pl-k">=</span><span class="pl-c1">35</span>)

<span class="pl-c"><span class="pl-c">#</span> Display one full period of the orbit (run `using Plots` first)</span>
<span class="pl-k">using</span> Plots
<span class="pl-c1">plot</span>(elements, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>My Planet<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/assets/orbit-sample.png"><img src="docs/src/assets/orbit-sample.png" alt="Orbit Plot" style="max-width: 100%;"></a></p>
<p dir="auto">Note that by default the horizontal axis is flipped to match how it would look in the sky. The horizontal coordinates generated by these functions are not flipped in this way. If you use these coordinates to sample an image, you will have to either flip the image or negate the <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="28c738bd49a0b12227fb65b802de397d">$x$</math-renderer> coordinate.</p>
<p dir="auto">If you have an array of hundreds or thousands of orbits you want to visualize, just pass that array to <code>plot</code>. The opacity of the orbits will be reduced an appropriate amount.</p>
<p dir="auto">Get projected cartesian coordinates in milliarcseconds at a given epoch:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; pos = kep2cart(elements, 1.0) # at t time in days 
ComponentVector{Float64,typename(StaticArrays.SArray)...}(
    x = 19.583048010319406,  # mas
    y = 11.394360378798881,  # mas
    z = -19.659329553074404, # mas
    ẋ = 19.583048010319406,  # mas/year
    ẏ = 11.394360378798881,  # mas/year
    ż = 13602.351794764198   # m/s
)"><pre>julia<span class="pl-k">&gt;</span> pos <span class="pl-k">=</span> <span class="pl-c1">kep2cart</span>(elements, <span class="pl-c1">1.0</span>) <span class="pl-c"><span class="pl-c">#</span> at t time in days </span>
<span class="pl-c1">ComponentVector</span><span class="pl-c1">{Float64,typename(StaticArrays.SArray)...}</span>(
    x <span class="pl-k">=</span> <span class="pl-c1">19.583048010319406</span>,  <span class="pl-c"><span class="pl-c">#</span> mas</span>
    y <span class="pl-k">=</span> <span class="pl-c1">11.394360378798881</span>,  <span class="pl-c"><span class="pl-c">#</span> mas</span>
    z <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">19.659329553074404</span>, <span class="pl-c"><span class="pl-c">#</span> mas</span>
    ẋ <span class="pl-k">=</span> <span class="pl-c1">19.583048010319406</span>,  <span class="pl-c"><span class="pl-c">#</span> mas/year</span>
    ẏ <span class="pl-k">=</span> <span class="pl-c1">11.394360378798881</span>,  <span class="pl-c"><span class="pl-c">#</span> mas/year</span>
    ż <span class="pl-k">=</span> <span class="pl-c1">13602.351794764198</span>   <span class="pl-c"><span class="pl-c">#</span> m/s</span>
)</pre></div>
<p dir="auto">There are many convenience functions, including:</p>
<ul dir="auto">
<li>
<code>period(elements)</code>:  period of a the companion in days.</li>
<li>
<code>distance(elements)</code>:  distance to the system in pc</li>
<li>
<code>meanmotion(elements)</code>: mean motion about the primary in radians/yr</li>
<li>
<code>projectedseparation(elements, t)</code>: given orbital elements and a time, the projected separation between the primary and companion</li>
<li>
<code>raoff(elements, t)</code>: as above, but only the offset in Right Ascension (milliarcseconds)</li>
<li>
<code>decoff(elements, t)</code>: as above, but only the offset in declination (milliarcseconds)</li>
<li>
<code>radvel</code>: radial velocity in m/s of the planet or star (see docstring)</li>
<li>
<code>propmotionanom</code>: proper motion anomaly of the star due to the planet in milliarseconds / year</li>
</ul>
<p dir="auto">Showing an orbital elements object at the REPL will print a useful summary like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; elements
KeplerianElements{Float64}
─────────────────────────
a   [au ] = 1.0
i   [°  ] = 45.0
e         = 0.25
τ         = 0.0
M   [M⊙ ] = 1.0
ω   [°  ] = 0.0
Ω   [°  ] = 120.0
plx [mas] = 35.0
──────────────────────────
period      [yrs ] : 1.0
distance    [pc  ] : 28.6
mean motion [°/yr] : 360.0"><pre>julia<span class="pl-k">&gt;</span> elements
KeplerianElements{Float64}
─────────────────────────
a   [au ] <span class="pl-k">=</span> <span class="pl-c1">1.0</span>
i   [°  ] <span class="pl-k">=</span> <span class="pl-c1">45.0</span>
e         <span class="pl-k">=</span> <span class="pl-c1">0.25</span>
τ         <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
M   [M⊙ ] <span class="pl-k">=</span> <span class="pl-c1">1.0</span>
ω   [°  ] <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
Ω   [°  ] <span class="pl-k">=</span> <span class="pl-c1">120.0</span>
plx [mas] <span class="pl-k">=</span> <span class="pl-c1">35.0</span>
──────────────────────────
period      [yrs ] <span class="pl-k">:</span> <span class="pl-c1">1.0</span>
distance    [pc  ] <span class="pl-k">:</span> <span class="pl-c1">28.6</span>
mean motion [°<span class="pl-k">/</span>yr] <span class="pl-k">:</span> <span class="pl-c1">360.0</span></pre></div>
<p dir="auto">ComponentVectors wrapping SVectors are chosen for the return values. They are stack allocated and allow access by property
name, and behave as arrays. This makes it easy to compose with other packages.</p>
<h2 dir="auto">
<a id="user-content-units--conventions" class="anchor" aria-hidden="true" href="#units--conventions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Units &amp; Conventions</h2>
<p dir="auto">The main constructor, <code>KeplerianElements</code>, accepts the following parameters:</p>
<ul dir="auto">
<li>
<code>a</code>: Semi-major axis in astronomical units (AU)</li>
<li>
<code>i</code>: Inclination in radians</li>
<li>
<code>e</code>: Eccentricity in the range [0, 1)</li>
<li>
<code>τ</code>: Epoch of periastron passage, in fraction of orbit [0,1]</li>
<li>
<code>M</code>: Graviataion parameter of the central body, expressed in units of Solar mass.</li>
<li>
<code>ω</code>: Argument of periastron</li>
<li>
<code>Ω</code>: Longitude of the ascending node, radians.</li>
<li>
<code>plx</code>: Distance to the system expressed in milliarcseconds of parallax.</li>
</ul>
<p dir="auto">Thee parameter <code>τ</code> represents the epoch of periastron passage as a  fraction of the planet's orbit between 0 and 1. This follows the same convention as Orbitize! and you can read more about their choice in ther FAQ.</p>
<p dir="auto">Parameters can either be specified by position or as keyword arguments (but not a mix). Positional
arguments are recommended if you are creating objects in a tight loop.</p>
<p dir="auto">There is also a convenience constructor <code>KeplerianElementsDeg</code> that accepts <code>i</code>, <code>ω</code>, and <code>Ω</code> in units of degrees instead of radians.</p>
<p dir="auto">See <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/Orbit1.svg/1110px-Orbit1.svg.png" rel="nofollow">this diagram</a> from Wikipedia as a reference for the conventions used by this package (note ♈︎ is replaced by the celestial North pole).</p>
<h2 dir="auto">
<a id="user-content-image-warping" class="anchor" aria-hidden="true" href="#image-warping"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Image Warping</h2>
<p dir="auto">If you have an image of a system, you can warp the image as if each pixel were a test particle following Kepler's laws.
This is an easy way to see what a disk or a system of planets would look like at a time other than when it was captured.</p>
<p dir="auto">To make this possible, DirectOrbits.jl can create <code>OrbitalTransformation</code> objects. These follow the conventions set out
in CoordinateTransformations.jl and are compatible with ImageTransformations.jl.</p>
<p dir="auto">Example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ot = OrbitalTransformation(
    i = 0.3,
    e = 0.1,
    M = 1.0,
    ω = 0.5,
    Ω = 0.5,
    plx = 30.0,
    
    platescale=10.0, # mas/px
    dt = 3*365.25 # days forward in time
)

img_centered = centered(img)
img_future = warp(img_centered, ot, axes(i))

# Display with DirectImages.jl
using DirectImages
imshow2([img; img_future], clims=(0,1), cmap=:seaborn_icefire_gradient)"><pre>ot <span class="pl-k">=</span> <span class="pl-c1">OrbitalTransformation</span>(
    i <span class="pl-k">=</span> <span class="pl-c1">0.3</span>,
    e <span class="pl-k">=</span> <span class="pl-c1">0.1</span>,
    M <span class="pl-k">=</span> <span class="pl-c1">1.0</span>,
    ω <span class="pl-k">=</span> <span class="pl-c1">0.5</span>,
    Ω <span class="pl-k">=</span> <span class="pl-c1">0.5</span>,
    plx <span class="pl-k">=</span> <span class="pl-c1">30.0</span>,
    
    platescale<span class="pl-k">=</span><span class="pl-c1">10.0</span>, <span class="pl-c"><span class="pl-c">#</span> mas/px</span>
    dt <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">*</span><span class="pl-c1">365.25</span> <span class="pl-c"><span class="pl-c">#</span> days forward in time</span>
)

img_centered <span class="pl-k">=</span> <span class="pl-c1">centered</span>(img)
img_future <span class="pl-k">=</span> <span class="pl-c1">warp</span>(img_centered, ot, <span class="pl-c1">axes</span>(i))

<span class="pl-c"><span class="pl-c">#</span> Display with DirectImages.jl</span>
<span class="pl-k">using</span> DirectImages
<span class="pl-c1">imshow2</span>([img; img_future], clims<span class="pl-k">=</span>(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>), cmap<span class="pl-k">=</span><span class="pl-c1">:seaborn_icefire_gradient</span>)</pre></div>
<p dir="auto"><strong>Before, and After Orbital Transformation</strong><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/7330605/129625363-c0295432-47f4-4400-a5a7-7140a7e7d997.png"><img src="https://user-images.githubusercontent.com/7330605/129625363-c0295432-47f4-4400-a5a7-7140a7e7d997.png" alt="image" style="max-width: 100%;"></a></p>
<p dir="auto">Note the arguments <code>platescale</code> and <code>dt</code> are required, but <code>a</code> and <code>τ</code> are not. The position of the pixel in X/Y space uniquely determines the semi-major axis and epoch of periastron passage when the rest of the orbital parameters are known. <code>platescale</code> in units of milliarseconds/pixel is necessary to get the overall scale of the transform correct. This is because an orbital transformation is <strong>not</strong> linear (and therefore, care must be taken when composing an OrbitalTransformation with other CoordinateTransformations). Scaling an image will change the amount of rotation that occurs at each separation. <code>dt</code> is the the amount of time in days to project the image forward. It can also be negative to project the image into the past.</p>
<h2 dir="auto">
<a id="user-content-makie-recipe" class="anchor" aria-hidden="true" href="#makie-recipe"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Makie Recipe</h2>
<p dir="auto">There is a basic Makie plot recipe that allows you to plot a KeplerianElements:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CairoMakie
elements = KeplerianElementsDeg(a=1, i=45, e=0.25, τ=0, M=1, ω=0, Ω=120, plx=35)
lines(elements, axis=(;autolimitaspect=1, xreversed=true))"><pre><span class="pl-k">using</span> CairoMakie
elements <span class="pl-k">=</span> <span class="pl-c1">KeplerianElementsDeg</span>(a<span class="pl-k">=</span><span class="pl-c1">1</span>, i<span class="pl-k">=</span><span class="pl-c1">45</span>, e<span class="pl-k">=</span><span class="pl-c1">0.25</span>, τ<span class="pl-k">=</span><span class="pl-c1">0</span>, M<span class="pl-k">=</span><span class="pl-c1">1</span>, ω<span class="pl-k">=</span><span class="pl-c1">0</span>, Ω<span class="pl-k">=</span><span class="pl-c1">120</span>, plx<span class="pl-k">=</span><span class="pl-c1">35</span>)
<span class="pl-c1">lines</span>(elements, axis<span class="pl-k">=</span>(;autolimitaspect<span class="pl-k">=</span><span class="pl-c1">1</span>, xreversed<span class="pl-k">=</span><span class="pl-c1">true</span>))</pre></div>
<p dir="auto">Note that for Makie, you will have to reverse the x-axis manually whereas in Plots.jl it is set automatically.</p>
<h2 dir="auto">
<a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">This package is not in the General registery, but a personal registry for this and related packages.
To install it, first add the DirectRegistry containing this, and other related packages:</p>
<p dir="auto">(<code>]</code> to enter Pkg mode)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content=" pkg&gt; registry add https://github.com/sefffal/DirectRegistry
 pkg&gt; add DirectOrbits"><pre> pkg<span class="pl-k">&gt;</span> registry add https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>sefffal<span class="pl-k">/</span>DirectRegistry
 pkg<span class="pl-k">&gt;</span> add DirectOrbits</pre></div>
<p dir="auto">That's it! If you want to run it through a gauntlet of tests, type <code>]</code> followed by <code>test DirectOrbits</code></p>
<h2 dir="auto">
<a id="user-content-performance" class="anchor" aria-hidden="true" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance</h2>
<p dir="auto">On my 2017 Core i7 laptop, this library is able to calculate
a projected position from a set of orbital elements in just 48ns (circular orbit) or 166ns (eccentric).</p>
<p dir="auto">All the helper functions should work without any heap allocations
when using standard numeric types.</p>
<p dir="auto">Several parameters are pre-calculated when creating a KeplerianElements object. There is
therefore a slight advantage to re-use the same object if you are sampling many positions
from the same orbital elements (but we are only talking nanoseconds either way).</p>
<h2 dir="auto">
<a id="user-content-numerical-derivatives" class="anchor" aria-hidden="true" href="#numerical-derivatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Numerical Derivatives</h2>
<p dir="auto">This package works well with the autodiff package ForwardDiff.jl. For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ForwardDiff
ForwardDiff.derivative(t -&gt; radvel(elements, t), 123.0)"><pre><span class="pl-k">using</span> ForwardDiff
ForwardDiff<span class="pl-k">.</span><span class="pl-c1">derivative</span>(t <span class="pl-k">-&gt;</span> <span class="pl-c1">radvel</span>(elements, t), <span class="pl-c1">123.0</span>)</pre></div>
<p dir="auto">This has only a negligible overhead (maybe 15%) compared to calculating the value itself.
If you need access to both the value and the derivative, I recommend you use the DiffResults
package to calculate both at once for a 2x speedup:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DiffResults
g = let elements=elements
    t -&gt; raoff(elements, t)
end

# Set the result type
result_out = DiffResults.DiffResult(1.0,1.0)

# Calculate both the value and derivative at once
@btime res = ForwardDiff.derivative!($result_out, $g, 1.0)
#  205.487 ns (0 allocations: 0 bytes)

# Access each
rv = DiffResults.value(res)
drvdt = DiffResults.derivative(res, Val{1})"><pre><span class="pl-k">using</span> DiffResults
g <span class="pl-k">=</span> <span class="pl-k">let</span> elements<span class="pl-k">=</span>elements
    t <span class="pl-k">-&gt;</span> <span class="pl-c1">raoff</span>(elements, t)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Set the result type</span>
result_out <span class="pl-k">=</span> DiffResults<span class="pl-k">.</span><span class="pl-c1">DiffResult</span>(<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>)

<span class="pl-c"><span class="pl-c">#</span> Calculate both the value and derivative at once</span>
<span class="pl-c1">@btime</span> res <span class="pl-k">=</span> ForwardDiff<span class="pl-k">.</span><span class="pl-c1">derivative!</span>(<span class="pl-k">$</span>result_out, <span class="pl-k">$</span>g, <span class="pl-c1">1.0</span>)
<span class="pl-c"><span class="pl-c">#</span>  205.487 ns (0 allocations: 0 bytes)</span>

<span class="pl-c"><span class="pl-c">#</span> Access each</span>
rv <span class="pl-k">=</span> DiffResults<span class="pl-k">.</span><span class="pl-c1">value</span>(res)
drvdt <span class="pl-k">=</span> DiffResults<span class="pl-k">.</span><span class="pl-c1">derivative</span>(res, Val{<span class="pl-c1">1</span>})</pre></div>
<p dir="auto">The Zygote reverse diff package does not currently work with DirectOrbits.jl.</p>
<h2 dir="auto">
<a id="user-content-calculating-orbits-on-a-gpu" class="anchor" aria-hidden="true" href="#calculating-orbits-on-a-gpu"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calculating orbits on a GPU</h2>
<p dir="auto">Using the CUDA and StructArray packages, you can easily calculate ensembles of orbits on the GPU.</p>
<p dir="auto">For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DirectOrbits
using StructArrays
using CUDA

# Create a vector of different initial conditions
elements = [KeplerianElementsDeg(
    a=1.0,
    i=45.,
    e=0.1,
    τ=0,
    ω=20,
    Ω=10,
    plx=50,
    M=3.0,
) for a in 1:0.01:10000]

# Convert the storage to a struct array instead of array of structs.
elements_sa = StructArray(elements)
# Send to GPU
elements_cusa = replace_storage(CuArray, elements_sa)

# Allocate output storage
out = zeros(length(elements_sa)) # CPU
out_cu = zeros(length(elements_cusa)) # GPU

# Calculate the radial velocity of each orbit at time zero
@time            out .= radvel.(elements_sa, 0.0) # CPU
@time CUDA.@sync out_cu .= radvel.(elements_cusa, 0.0) # GPU"><pre><span class="pl-k">using</span> DirectOrbits
<span class="pl-k">using</span> StructArrays
<span class="pl-k">using</span> CUDA

<span class="pl-c"><span class="pl-c">#</span> Create a vector of different initial conditions</span>
elements <span class="pl-k">=</span> [<span class="pl-c1">KeplerianElementsDeg</span>(
    a<span class="pl-k">=</span><span class="pl-c1">1.0</span>,
    i<span class="pl-k">=</span><span class="pl-c1">45.</span>,
    e<span class="pl-k">=</span><span class="pl-c1">0.1</span>,
    τ<span class="pl-k">=</span><span class="pl-c1">0</span>,
    ω<span class="pl-k">=</span><span class="pl-c1">20</span>,
    Ω<span class="pl-k">=</span><span class="pl-c1">10</span>,
    plx<span class="pl-k">=</span><span class="pl-c1">50</span>,
    M<span class="pl-k">=</span><span class="pl-c1">3.0</span>,
) <span class="pl-k">for</span> a <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0.01</span><span class="pl-k">:</span><span class="pl-c1">10000</span>]

<span class="pl-c"><span class="pl-c">#</span> Convert the storage to a struct array instead of array of structs.</span>
elements_sa <span class="pl-k">=</span> <span class="pl-c1">StructArray</span>(elements)
<span class="pl-c"><span class="pl-c">#</span> Send to GPU</span>
elements_cusa <span class="pl-k">=</span> <span class="pl-c1">replace_storage</span>(CuArray, elements_sa)

<span class="pl-c"><span class="pl-c">#</span> Allocate output storage</span>
out <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">length</span>(elements_sa)) <span class="pl-c"><span class="pl-c">#</span> CPU</span>
out_cu <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">length</span>(elements_cusa)) <span class="pl-c"><span class="pl-c">#</span> GPU</span>

<span class="pl-c"><span class="pl-c">#</span> Calculate the radial velocity of each orbit at time zero</span>
<span class="pl-c1">@time</span>            out <span class="pl-k">.=</span> <span class="pl-c1">radvel</span>.(elements_sa, <span class="pl-c1">0.0</span>) <span class="pl-c"><span class="pl-c">#</span> CPU</span>
<span class="pl-c1">@time</span> CUDA<span class="pl-k">.</span><span class="pl-c1">@sync</span> out_cu <span class="pl-k">.=</span> <span class="pl-c1">radvel</span>.(elements_cusa, <span class="pl-c1">0.0</span>) <span class="pl-c"><span class="pl-c">#</span> GPU</span></pre></div>
<p dir="auto">On my laptop's pitiful GPU, the timing for the GPU calculation is still
17 times faster than on the CPU.</p>
</article></div>