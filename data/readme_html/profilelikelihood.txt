<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-profilelikelihood" class="anchor" aria-hidden="true" href="#profilelikelihood"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ProfileLikelihood</h1>
<p dir="auto"><a href="https://zenodo.org/badge/latestdoi/508701126" rel="nofollow"><img src="https://camo.githubusercontent.com/b3c6141f333532f099bfe46a361883b9085b9183a239ebe987640d4a24b2d7d0/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3530383730313132362e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/508701126.svg" style="max-width: 100%;"></a>
<a href="https://DanielVandH.github.io/ProfileLikelihood.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://DanielVandH.github.io/ProfileLikelihood.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package defines the routines required for computing maximum likelihood estimates and profile likelihoods. The optimisation routines are built around the <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a> interface, allowing us to e.g. easily switch between algorithms, between finite differences and automatic differentiation, and it allows for constraints to be defined with ease. Below we list the definitions we are using for likelihoods and profile likelihoods. This code works for univariate and bivariate profiles.</p>
<p dir="auto"><strong>Definition: Likelihood function</strong> (see Casella &amp; Berger, 2002): Let <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$f(\boldsymbol x \mid \boldsymbol \theta)$</math-renderer> denote the joint probability density function (PDF) of the sample <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol X = (X_1,\ldots,X_n)^{\mathsf T}$</math-renderer>, where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol \theta \in \Theta$</math-renderer> is some set of parameters and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\Theta$</math-renderer> is the parameter space. We define the <em>likelihood function</em> <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\mathcal L \colon \Theta \to [0, \infty)$</math-renderer> by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\mathcal L(\boldsymbol \theta \mid \boldsymbol x) = f(\boldsymbol x \mid \boldsymbol \theta)$</math-renderer> for some realisation <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol x = (x_1,\ldots,x_n)^{\mathsf T}$</math-renderer> of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol X$</math-renderer>. The <em>log-likelihood function</em> <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\ell\colon\Theta\to\mathbb R$</math-renderer> is defined by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\ell(\boldsymbol \theta \mid \boldsymbol x) =  \log\mathcal L(\boldsymbol\theta \mid \boldsymbol x)$</math-renderer>.The <em>maximum likelihood estimate</em> (MLE) <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\hat{\boldsymbol\theta}$</math-renderer> is the parameter <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol\theta$</math-renderer> that maximises the likelihood function, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\hat{\boldsymbol{\theta}} = argmax_{\boldsymbol{\theta} \in \Theta} \mathcal{L}(\boldsymbol{\theta} \mid \boldsymbol x) = argmax_{\boldsymbol\theta \in \Theta} \ell(\boldsymbol\theta \mid \boldsymbol x)$</math-renderer>.</p>
<p dir="auto"><strong>Definition: Profile likelihood function</strong> (see Pawitan, 2001): Suppose we have some parameters of interest, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol \theta \in \Theta$</math-renderer>, and some nuisance parameters, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol \phi \in \Phi$</math-renderer>, and some data <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol x = (x_1,\ldots,x_n)^{\mathsf T}$</math-renderer>, giving some joint likelihood <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\mathcal L \colon \Theta \cup \Phi \to [0, \infty)$</math-renderer> defined by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\mathcal L(\boldsymbol\theta, \boldsymbol\phi \mid \boldsymbol x)$</math-renderer>. We define the <em>profile likelihood</em> <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\mathcal L_p \colon \Theta \to [0, \infty)$</math-renderer> of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol\theta$</math-renderer> by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\mathcal L_p(\boldsymbol\theta \mid \boldsymbol x) = \sup_{\boldsymbol \phi \in \Phi \mid \boldsymbol \theta} \mathcal L(\boldsymbol \theta, \boldsymbol \phi \mid \boldsymbol x)$</math-renderer>. The <em>profile log-likelihood</em> <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\ell_p \colon \Theta \to \mathbb R$</math-renderer> of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol\theta$</math-renderer> is defined by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\ell_p(\boldsymbol \theta \mid \boldsymbol x) = \log \mathcal L_p(\boldsymbol\theta \mid \boldsymbol x)$</math-renderer>. The <em>normalised profile likelihood</em> is defined by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\hat{\mathcal L}_p(\boldsymbol\theta \mid \boldsymbol x) = \mathcal L_p(\boldsymbol \theta \mid \boldsymbol x) - \mathcal L_p(\hat{\boldsymbol\theta} \mid \boldsymbol x)$</math-renderer>, where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\hat{\boldsymbol\theta}$</math-renderer> is the MLE of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol\theta$</math-renderer>, and similarly for the normalised profile log-likelihood.</p>
<p dir="auto">From Wilk's theorem, we know that <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$2\hat{\ell}_p(\boldsymbol\theta \mid \boldsymbol x) \geq -\chi_{p, 1-\alpha}^2$</math-renderer> is an approximate <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$100(1-\alpha)%$</math-renderer> confidence region for <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol \theta$</math-renderer>, and this enables us to obtain confidence intervals for parameters by considering only their profile likelihood, where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\chi_{p,1-\alpha}^2$</math-renderer> is the <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$1-\alpha$</math-renderer> quantile of the <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\chi_p^2$</math-renderer> distribution and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$p$</math-renderer> is the length of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$\boldsymbol\theta$</math-renderer>. For the case of a scalar parameter of interest, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9513d0ae1284fd83e3c9e419f8298898">$-\chi_{1, 0.95}^2 \approx -1.92$</math-renderer>.</p>
<p dir="auto">We compute the profile log-likelihood in this package by starting at the MLE, and stepping left/right until we reach a given threshold. The code is iterative to not waste time in so much of the parameter space. In the bivariate case, we start at the MLE and expand outwards in layers. This implementation is described in the documentation.</p>
<p dir="auto">More detail about the methods we use in this package are given in the documentation, along with several examples.</p>
</article></div>