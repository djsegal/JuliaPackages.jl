<div id="readme" class="org" data-path="README.org"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-matrixproductstatesjl" class="anchor" aria-hidden="true" href="#matrixproductstatesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MatrixProductStates.jl</h1>
<p>This is a package-in-progress in which I am implementing the <a href="https://en.wikipedia.org/wiki/Density_matrix_renormalization_group" rel="nofollow">DMRG</a>
  algorithm over matrix product states as explained in SchollwÃ¶ckâ€™s <a href="https://www.sciencedirect.com/science/article/pii/S0003491610001752" rel="nofollow">The
  density-matrix renormalization group in the age of matrix product
  states</a>. A similar project has been undertaken in <a href="https://github.com/0/LatticeSweeper.jl">LatticeSweeper.jl</a>.</p>
<p>Iâ€™m not longer actively developthing this library, but I think it still has value as an educational resource for those wanting to learn DMRG.
  Julia made it possible for me to implement this package using syntax which is very close to the math written in the online literature.</p>
<p>To acquire this package, simply open a <code>julia</code> repl (obtained from <a href="https://julialang.org/downloads/" rel="nofollow">https://julialang.org/downloads/</a>) and type</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Pkg; Pkg.add(&quot;https://github.com/MasonProtter/MatrixProductStates.jl.git&quot;)
"><pre><span class="pl-k">using</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/MasonProtter/MatrixProductStates.jl.git<span class="pl-pds">"</span></span>)</pre></div>
<h2><a id="user-content-example-transverse-field-ising-model" class="anchor" aria-hidden="true" href="#example-transverse-field-ising-model"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: Transverse Field Ising Model</h2>
<details><summary>Click me!</summary>
<p>
</p><p>Suppose we didnâ€™t realize the one dimensional transverse field Ising
  model was exactly solvable and we wanted to study it with DMRG.</p>
<p>The TFIM Hamiltonian is written</p>
<pre>H = - âˆ‘áµ¢ Ïƒá¶»áµ¢Ïƒá¶»áµ¢â‚Šâ‚ - âˆ‘áµ¢ g ÏƒË£áµ¢ 
</pre>
<p>which in MPO form can be written as</p>
<pre>H = WÂ¹ WÂ² WÂ³... Wá´¸â»Â¹ Wá´¸
                   [ ğŸ™    ğŸ˜    ğŸ˜] [ ğŸ™    ğŸ˜    ğŸ˜]     [ ğŸ™    ğŸ˜    ğŸ˜] [ ğŸ™  ]
  = [-gÏƒË£  Ïƒá¶»   ğŸ™] | -Ïƒá¶»  ğŸ˜    ğŸ˜| | -Ïƒá¶»  ğŸ˜    ğŸ˜| ... | -Ïƒá¶»  ğŸ˜    ğŸ˜| |-Ïƒá¶» |
                   [-gÏƒË£  Ïƒá¶»   ğŸ™] [-gÏƒË£  Ïƒá¶»   ğŸ™]     [-gÏƒË£  Ïƒá¶»  ğŸ™] [-gÏƒË£]
</pre>
<p>We can study this Hamiltonian using MatrixProductStates.jl as follows:</p>
<p>First, make a function for generating the Hamiltonian given a coupling strength <code>g = h/J</code> and a system length <code>L</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using MatrixProductStates

function H_TFIM(g, L)
    id = [1  0; 
          0  1]
    ÏƒË£ = [0  1; 
          1  0]
    Ïƒá¶» = [1  0; 
          0 -1]
    W_tnsr = zeros(Complex{Float64}, 3, 3, 2, 2)
    W_tnsr[1, 1, :, :] = id    
    W_tnsr[2, 1, :, :] = -Ïƒá¶»  
    W_tnsr[3, 1, :, :] = -g*ÏƒË£
    W_tnsr[3, 2, :, :] = Ïƒá¶»   
    W_tnsr[3, 3, :, :] = id   

    return MPO(W_tnsr, L) # MPO will assume that WÂ¹ = W_tnsr[end:end, :, :, :] and Wá´¸ = W_tnsr[:, 1:1, :, :]
end
"><pre><span class="pl-k">using</span> MatrixProductStates

<span class="pl-k">function</span> <span class="pl-en">H_TFIM</span>(g, L)
    id <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
          <span class="pl-c1">0</span>  <span class="pl-c1">1</span>]
    ÏƒË£ <span class="pl-k">=</span> [<span class="pl-c1">0</span>  <span class="pl-c1">1</span>; 
          <span class="pl-c1">1</span>  <span class="pl-c1">0</span>]
    Ïƒá¶» <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
          <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
    W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
    W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> id    
    W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>Ïƒá¶»  
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>g<span class="pl-k">*</span>ÏƒË£
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span> Ïƒá¶»   
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span> id   

    <span class="pl-k">return</span> <span class="pl-c1">MPO</span>(W_tnsr, L) <span class="pl-c"><span class="pl-c">#</span> MPO will assume that WÂ¹ = W_tnsr[end:end, :, :, :] and Wá´¸ = W_tnsr[:, 1:1, :, :]</span>
<span class="pl-k">end</span></pre></div>
<h3><a id="user-content-ground-state" class="anchor" aria-hidden="true" href="#ground-state"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Ground State</h3>
<p>Suppose we want to know the ground state of this system for
  <code>g=0.8</code> and <code>L=12</code> and we have no idea what the MPS form of the ground
  state looks like a-priori.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="g = 1.1; L = 12;

d    = 2;   # This is the local Hilbert space dimension for each site
Dcut = 100; # This is the maximum bond dimension we'll allow our matrix product state to take

H = H_TFIM(g, L)
Ïˆ = randn(MPS{L, Complex{Float64}}, Dcut, d) # Generate a completely randomized matrix product state

Ï•, Eâ‚€ = ground_state(Ïˆ, H, quiet=true) #Set quiet to false (the deault) to turn off notifications about the algorithm's progress
"><pre>g <span class="pl-k">=</span> <span class="pl-c1">1.1</span>; L <span class="pl-k">=</span> <span class="pl-c1">12</span>;

d    <span class="pl-k">=</span> <span class="pl-c1">2</span>;   <span class="pl-c"><span class="pl-c">#</span> This is the local Hilbert space dimension for each site</span>
Dcut <span class="pl-k">=</span> <span class="pl-c1">100</span>; <span class="pl-c"><span class="pl-c">#</span> This is the maximum bond dimension we'll allow our matrix product state to take</span>

H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)
Ïˆ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, Dcut, d) <span class="pl-c"><span class="pl-c">#</span> Generate a completely randomized matrix product state</span>

Ï•, Eâ‚€ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">#</span>Set quiet to false (the deault) to turn off notifications about the algorithm's progress</span></pre></div>
<p>We now have the ground state <code>Ï•</code>, and an estimate of itâ€™s energy
  eigenvalue <code>Eâ‚€</code>!</p>
<p>Note that 12 sites can be easily studied with far less computational
  cost as an exact diagonalization, but I didnâ€™t want to suggest doing
  something like <code>L=50</code> right off the bat since that took ~90 minutes on
  my machine.</p>
<p>We can make sure that this stateâ€™s energy matches our estimate:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; Ï•' * H * Ï• â‰ˆ Eâ‚€ # computing âŸ¨Ï•|H|Ï•âŸ©
true
"><pre>julia<span class="pl-k">&gt;</span> Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï• <span class="pl-k">â‰ˆ</span> Eâ‚€ <span class="pl-c"><span class="pl-c">#</span> computing âŸ¨Ï•|H|Ï•âŸ©</span>
<span class="pl-c1">true</span></pre></div>
<p>and we can varify that itâ€™s approximately an eigenstate:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; Ï•' * H * H * Ï•  â‰ˆ (Ï•' * H * Ï•)^2 # computing âŸ¨Ï•| H^2 |Ï•âŸ© â‰ˆ (âŸ¨Ï•|H|Ï•âŸ©)^2
true
"><pre>julia<span class="pl-k">&gt;</span> Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï•  <span class="pl-k">â‰ˆ</span> (Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï•)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> computing âŸ¨Ï•| H^2 |Ï•âŸ© â‰ˆ (âŸ¨Ï•|H|Ï•âŸ©)^2</span>
<span class="pl-c1">true</span></pre></div>
<h3><a id="user-content-correlators" class="anchor" aria-hidden="true" href="#correlators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Correlators</h3>
<p>We can take advantage of the <code>two_point_correlator</code> function to study spin-spin correlations in the TFIM</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using UnicodePlots

Ïƒá¶» = [1 0 
      0 -1]

zz(i, j) = two_point_correlator(i=&gt;Ïƒá¶», j=&gt;Ïƒá¶», 12)

js = 2:12

zzs = [realize(Ï•'*zz(1, j)*Ï•) for j in js] #realize will convert complex numbers with a small imaginary part to real.

lineplot(js, zzs, canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, 
         ylabel=&quot;âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©&quot;, xlabel=&quot;lattice site j&quot;, title=&quot;Spin-Spin Correlation for g = $g&quot;)
"><pre><span class="pl-k">using</span> UnicodePlots

Ïƒá¶» <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span> 
      <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]

<span class="pl-en">zz</span>(i, j) <span class="pl-k">=</span> <span class="pl-c1">two_point_correlator</span>(i<span class="pl-k">=&gt;</span>Ïƒá¶», j<span class="pl-k">=&gt;</span>Ïƒá¶», <span class="pl-c1">12</span>)

js <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">12</span>

zzs <span class="pl-k">=</span> [<span class="pl-c1">realize</span>(Ï•<span class="pl-k">'</span><span class="pl-k">*</span><span class="pl-c1">zz</span>(<span class="pl-c1">1</span>, j)<span class="pl-k">*</span>Ï•) <span class="pl-k">for</span> j <span class="pl-k">in</span> js] <span class="pl-c"><span class="pl-c">#</span>realize will convert complex numbers with a small imaginary part to real.</span>

<span class="pl-c1">lineplot</span>(js, zzs, canvas<span class="pl-k">=</span>DotCanvas, ylim<span class="pl-k">=</span>[<span class="pl-c1">0</span>, <span class="pl-c1">1.01</span>], width<span class="pl-k">=</span><span class="pl-c1">80</span>, height<span class="pl-k">=</span><span class="pl-c1">30</span>, 
         ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>lattice site j<span class="pl-pds">"</span></span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Spin-Spin Correlation for g = <span class="pl-v">$g</span><span class="pl-pds">"</span></span>)</pre></div>
<pre>                                      Spin-Spin Correlation for g = 1.1
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 
         1.01 â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©      â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚:                                                                               â”‚ 
              â”‚ '.                                                                             â”‚ 
              â”‚   '.                                                                           â”‚ 
              â”‚     '.                                                                         â”‚ 
              â”‚       '.                                                                       â”‚ 
              â”‚         ''.                                                                    â”‚ 
              â”‚            ''..                                                                â”‚ 
              â”‚                ''...                                                           â”‚ 
              â”‚                     ''....                                                     â”‚ 
              â”‚                           ''''....                                             â”‚ 
              â”‚                                   '''''.......                                 â”‚ 
              â”‚                                               '''''''.........                 â”‚ 
              â”‚                                                               '''''''''........â”‚ 
            0 â”‚                                                                                â”‚ 
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
              2                                                                               12
                                               lattice site j
</pre>
<p>which shows exponentially decaying correlations in the ground state,
  as expected for <code>g &gt; 1</code>. We can also redo our calculation in the
  ordered phase:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="g = 0.8;

H = H_TFIM(g, L)

Ï•, Eâ‚’ = ground_state(Ïˆ, H, quiet=true)

ordered_zzs = [realize(Ï•'*zz(1, j)*Ï•) for j in js]

lineplot(js, realize.(ordered_zzs), canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, 
         ylabel=&quot;âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©&quot;, xlabel=&quot;lattice site j&quot;, title=&quot;Spin-Spin Correlation for g = $g&quot;)
"><pre>g <span class="pl-k">=</span> <span class="pl-c1">0.8</span>;

H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)

Ï•, Eâ‚’ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)

ordered_zzs <span class="pl-k">=</span> [<span class="pl-c1">realize</span>(Ï•<span class="pl-k">'</span><span class="pl-k">*</span><span class="pl-c1">zz</span>(<span class="pl-c1">1</span>, j)<span class="pl-k">*</span>Ï•) <span class="pl-k">for</span> j <span class="pl-k">in</span> js]

<span class="pl-c1">lineplot</span>(js, <span class="pl-c1">realize</span>.(ordered_zzs), canvas<span class="pl-k">=</span>DotCanvas, ylim<span class="pl-k">=</span>[<span class="pl-c1">0</span>, <span class="pl-c1">1.01</span>], width<span class="pl-k">=</span><span class="pl-c1">80</span>, height<span class="pl-k">=</span><span class="pl-c1">30</span>, 
         ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>lattice site j<span class="pl-pds">"</span></span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Spin-Spin Correlation for g = <span class="pl-v">$g</span><span class="pl-pds">"</span></span>)</pre></div>
<pre>                                      Spin-Spin Correlation for g = 0.8
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 
         1.01 â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚.                                                                               â”‚ 
              â”‚ ''.                                                                            â”‚ 
              â”‚    ''..                                                                        â”‚ 
              â”‚        '''....                                                                 â”‚ 
âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©      â”‚               ''''''.........                                                  â”‚ 
              â”‚                              ''''''''''''...........                           â”‚ 
              â”‚                                                     '''''''......              â”‚ 
              â”‚                                                                  '''....       â”‚ 
              â”‚                                                                         '..    â”‚ 
              â”‚                                                                            ''..â”‚ 
              â”‚                                                                               'â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
            0 â”‚                                                                                â”‚ 
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
              2                                                                               12
                                               lattice site j
</pre>
</details>
<p></p>
<h2><a id="user-content-source-code" class="anchor" aria-hidden="true" href="#source-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Source Code</h2>
<p>This readme is a literate document containing all of the source and test code for the package. Check it out, I think itâ€™s surprisingly legible.
  The sections Matrix Product States, Matrix Product Operatiors, Compression and Iterative Ground State Search are based directly on the math
  written in SchollwÃ¶ckâ€™s review.</p>
<h3><a id="user-content-module-definition" class="anchor" aria-hidden="true" href="#module-definition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Module Definition</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="module MatrixProductStates

using LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack, Strided, SparseArrays
#using ProgressMeter

export *, /, ==, â‰ˆ, isequal, adjoint, getindex, randn
export MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
export ground_state, two_point_correlator, realize

include(&quot;utils.jl&quot;)
include(&quot;MPS.jl&quot;)
include(&quot;MPO.jl&quot;)
include(&quot;compression.jl&quot;)
include(&quot;contraction.jl&quot;)
include(&quot;groundstate.jl&quot;)
include(&quot;correlation.jl&quot;)
include(&quot;timeevolution.jl&quot;)

end
"><pre><span class="pl-k">module</span> MatrixProductStates

<span class="pl-k">using</span> LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack, Strided, SparseArrays
<span class="pl-c"><span class="pl-c">#</span>using ProgressMeter</span>

<span class="pl-k">export</span> <span class="pl-k">*</span>, <span class="pl-k">/</span>, <span class="pl-k">==</span>, <span class="pl-k">â‰ˆ</span>, isequal, adjoint, getindex, randn
<span class="pl-k">export</span> MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
<span class="pl-k">export</span> ground_state, two_point_correlator, realize

<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>utils.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>MPS.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>MPO.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>compression.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>contraction.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>groundstate.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>correlation.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>timeevolution.jl<span class="pl-pds">"</span></span>)

<span class="pl-k">end</span></pre></div>
</details>
<p></p>
<h3><a id="user-content-utils" class="anchor" aria-hidden="true" href="#utils"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Utils</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="export âŠ—, realize

abstract type Direction end

struct Left  &lt;: Direction end # Often useful to dispatch on direction an algorithm is going
struct Right &lt;: Direction end

const left  = Left()
const right = Right()

A âŠ— B = kron(A, B)

realize(x::Number) = error(&quot;Unrecognized numerical type&quot;)
realize(x::Real) = x
function realize(x::Complex; Ïµ=1e-10)
    abs(imag(x)) &lt; Ïµ || error(&quot;Non-zero imaginary component, $(imag(x))&quot;)
    real(x)
end

dg(M::Array{T, 4}) where {T} = permutedims(conj.(M), (2, 1, 3, 4))
dg(M::Array{T, 3}) where {T} = permutedims(conj.(M), (2, 1, 3))

not(x) = ~x

"><pre><span class="pl-k">export</span> âŠ—, realize

<span class="pl-k">abstract type</span> Direction <span class="pl-k">end</span>

<span class="pl-k">struct</span> Left  <span class="pl-k">&lt;:</span> <span class="pl-c1">Direction</span> <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> Often useful to dispatch on direction an algorithm is going</span>
<span class="pl-k">struct</span> Right <span class="pl-k">&lt;:</span> <span class="pl-c1">Direction</span> <span class="pl-k">end</span>

<span class="pl-k">const</span> left  <span class="pl-k">=</span> <span class="pl-c1">Left</span>()
<span class="pl-k">const</span> right <span class="pl-k">=</span> <span class="pl-c1">Right</span>()

A âŠ— B <span class="pl-k">=</span> <span class="pl-c1">kron</span>(A, B)

<span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">=</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Unrecognized numerical type<span class="pl-pds">"</span></span>)
<span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Real</span>) <span class="pl-k">=</span> x
<span class="pl-k">function</span> <span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Complex</span>; Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-10</span>)
    <span class="pl-c1">abs</span>(<span class="pl-c1">imag</span>(x)) <span class="pl-k">&lt;</span> Ïµ <span class="pl-k">||</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Non-zero imaginary component, <span class="pl-v">$(<span class="pl-c1">imag</span>(x))</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">real</span>(x)
<span class="pl-k">end</span>

<span class="pl-en">dg</span>(M<span class="pl-k">::</span><span class="pl-c1">Array{T, 4}</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(M), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>))
<span class="pl-en">dg</span>(M<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(M), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>))

<span class="pl-en">not</span>(x) <span class="pl-k">=</span> <span class="pl-k">~</span>x
</pre></div>
</details>
<p></p>
<h3><a id="user-content-matrix-product-states" class="anchor" aria-hidden="true" href="#matrix-product-states"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrix Product States</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="&quot;&quot;&quot;
    MPS{L, T&lt;:Number}

Matrix product state on L sites. 

The `i`th tensor in the state has indices `[aâ±â»Â¹, aâ±, Ïƒâ±]` where
`(aâ±â»Â¹, aâ±)` are bond indices and `Ïƒâ±` is the physical index.

A four site MPS would be diagrammatically represented

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     

Note that `aâ°` and `aá´¸` must be of dimension 1.
&quot;&quot;&quot;
struct MPS{L, T&lt;:Number} 
    tensors::Vector{Array{T,3}}
end

Base.isequal(Ïˆ::MPS, Ï•::MPS)     = (isequal(Ïˆ.tensors, Ï•.tensors))
Base.isapprox(Ïˆ::MPS, Ï•::MPS)   = isapprox(Ïˆ.tensors, Ï•.tensors)

Base.eltype(::Type{MPS{L, T}}) where {L, T} = T

Base.length(::MPS{L, T}) where {L, T} = L

Base.size(::MPS{L, T}) where {L, T} = (L,)
Base.getindex(Ïˆ::MPS, i::Int) = getindex(Ïˆ.tensors, i)

Base.:(*)(Ïˆ::MPS{L, T}, x::Number) where {L, T} = MPS{L,T}(Ïˆ.tensors .* x)
Base.:(*)(x::Number, Ïˆ::MPS) = Ïˆ * x
Base.:(/)(Ïˆ::MPS{L,T}, x::Number) where {L, T} = MPS{L,T}(Ïˆ.tensors ./ x)
Base.copy(Ïˆ::MPS{L, T}) where {L, T} = MPS{L,T}(copy.(Ïˆ.tensors))

function Base.randn(::Type{MPS{L, T}}, D::Int, d::Int) where {L, T}
    tensors = [randn(1, D, d), [randn(D, D, d) for _ in 2:(L-1)]..., randn(D, 1, d)]
    MPS{L, T}(tensors) |&gt; leftcanonical |&gt; rightcanonical
end

&quot;&quot;&quot;
    MPS(vs::Vector{Vector})
Create an `MPS` representing a product state (all bonds have dimension 1),
where each site is described by the corresponding element of `vs`.
&quot;&quot;&quot;
function MPS(vs::Vector{Vector{T}}) where {T}
    L = length(vs)

    tensrs = Vector{Array{T,3}}(undef, L)
    for i in 1:L
        tensrs[i] = reshape(copy(vs[i]), 1, 1, :)
    end

    MPS{L,T}(tensrs)
end

&quot;&quot;&quot;
    MPS(v::Vector, L)
Create an `MPS` for `L` sites representing a uniform product state (all bonds
have dimension 1), where each site is described by `v`.
&quot;&quot;&quot;
MPS(v::Vector, L) = MPS([v for _ in 1:L])

function Base.show(io::IO, ::MIME&quot;text/plain&quot;, Ïˆ::MPS{L, T}) where {L, T}
    d = length(Ïˆ.tensors[2][1, 1, :])
    bonddims = [size(Ïˆ[i][:, :, 1]) for i in 1:L]
    println(io, &quot;Matrix product state on $L sites&quot;)
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(Ïˆ::MPS{L, T}) where {L, T}
    d = length(Ïˆ.tensors[2][1, 1, :])
    bonddims = [size(Ïˆ[i][:, :, 1]) for i in 1:L]
    println(&quot;Matrix product state on $L sites&quot;)
    _show_mps_dims(L, d, bonddims)
end

function _show_mps_dims(io::IO, L, d, bonddims)
    println(io, &quot;  Physical dimension: $d&quot;)
    print(io, &quot;  Bond dimensions:   &quot;)
    if L &gt; 8
        for i in 1:8
            print(io, bonddims[i], &quot; Ã— &quot;)
        end
        print(io, &quot; ... Ã— &quot;, bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], &quot; Ã— &quot;)
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, Ïˆ::MPS{L, T}) where {L, T}
    print(io, &quot;MPS on $L sites&quot;)
end

"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS{L, T&lt;:Number}</span>
<span class="pl-s"></span>
<span class="pl-s">Matrix product state on L sites. </span>
<span class="pl-s"></span>
<span class="pl-s">The `i`th tensor in the state has indices `[aâ±â»Â¹, aâ±, Ïƒâ±]` where</span>
<span class="pl-s">`(aâ±â»Â¹, aâ±)` are bond indices and `Ïƒâ±` is the physical index.</span>
<span class="pl-s"></span>
<span class="pl-s">A four site MPS would be diagrammatically represented</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     </span>
<span class="pl-s"></span>
<span class="pl-s">Note that `aâ°` and `aá´¸` must be of dimension 1.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">struct</span> MPS{L, T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>} 
    tensors<span class="pl-k">::</span><span class="pl-c1">Vector{Array{T,3}}</span>
<span class="pl-k">end</span>

Base<span class="pl-k">.</span><span class="pl-en">isequal</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, Ï•<span class="pl-k">::</span><span class="pl-c1">MPS</span>)     <span class="pl-k">=</span> (<span class="pl-c1">isequal</span>(Ïˆ<span class="pl-k">.</span>tensors, Ï•<span class="pl-k">.</span>tensors))
Base<span class="pl-k">.</span><span class="pl-en">isapprox</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, Ï•<span class="pl-k">::</span><span class="pl-c1">MPS</span>)   <span class="pl-k">=</span> <span class="pl-c1">isapprox</span>(Ïˆ<span class="pl-k">.</span>tensors, Ï•<span class="pl-k">.</span>tensors)

Base<span class="pl-k">.</span><span class="pl-en">eltype</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> T

Base<span class="pl-k">.</span><span class="pl-en">length</span>(<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> L

Base<span class="pl-k">.</span><span class="pl-en">size</span>(<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> (L,)
Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, i<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(Ïˆ<span class="pl-k">.</span>tensors, i)

Base.:(<span class="pl-k">*</span>)(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(Ïˆ<span class="pl-k">.</span>tensors <span class="pl-k">.*</span> x)
Base.:(<span class="pl-k">*</span>)(x<span class="pl-k">::</span><span class="pl-c1">Number</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>) <span class="pl-k">=</span> Ïˆ <span class="pl-k">*</span> x
Base.:(<span class="pl-k">/</span>)(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L,T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(Ïˆ<span class="pl-k">.</span>tensors <span class="pl-k">./</span> x)
Base<span class="pl-k">.</span><span class="pl-en">copy</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(<span class="pl-c1">copy</span>.(Ïˆ<span class="pl-k">.</span>tensors))

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">randn</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MPS{L, T}}</span>, D<span class="pl-k">::</span><span class="pl-c1">Int</span>, d<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> [<span class="pl-c1">randn</span>(<span class="pl-c1">1</span>, D, d), [<span class="pl-c1">randn</span>(D, D, d) <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, <span class="pl-c1">randn</span>(D, <span class="pl-c1">1</span>, d)]
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors) <span class="pl-k">|&gt;</span> leftcanonical <span class="pl-k">|&gt;</span> rightcanonical
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS(vs::Vector{Vector})</span>
<span class="pl-s">Create an `MPS` representing a product state (all bonds have dimension 1),</span>
<span class="pl-s">where each site is described by the corresponding element of `vs`.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">MPS</span>(vs<span class="pl-k">::</span><span class="pl-c1">Vector{Vector{T}}</span>) <span class="pl-k">where</span> {T}
    L <span class="pl-k">=</span> <span class="pl-c1">length</span>(vs)

    tensrs <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Array{T,3}}</span>(undef, L)
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        tensrs[i] <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">copy</span>(vs[i]), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :)
    <span class="pl-k">end</span>

    <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(tensrs)
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS(v::Vector, L)</span>
<span class="pl-s">Create an `MPS` for `L` sites representing a uniform product state (all bonds</span>
<span class="pl-s">have dimension 1), where each site is described by `v`.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-en">MPS</span>(v<span class="pl-k">::</span><span class="pl-c1">Vector</span>, L) <span class="pl-k">=</span> <span class="pl-c1">MPS</span>([v <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L])

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ<span class="pl-k">.</span>tensors[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(Ïˆ[i][:, :, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ<span class="pl-k">.</span>tensors[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(Ïˆ[i][:, :, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_show_mps_dims</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, L, d, bonddims)
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Physical dimension: <span class="pl-v">$d</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Bond dimensions:   <span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> L <span class="pl-k">&gt;</span> <span class="pl-c1">8</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">8</span>
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span> ... Ã— <span class="pl-pds">"</span></span>, bonddims[L])
    <span class="pl-k">else</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, bonddims[L])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>MPS on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
</pre></div>
<details><summary>Adjoint MPS</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function Base.adjoint(Ïˆ::MPS{L, T}) where {L,T}
    Adjoint{T, MPS{L, T}}(Ïˆ)
end

function Base.show(io::IO, ::MIME&quot;text/plain&quot;, Ïˆ::Adjoint{T, MPS{L, T}}) where {L, T}
    d = length(Ïˆ.parent[2][1, 1, :])
    bonddims = reverse([reverse(size(Ïˆ.parent[i][:, :, 1])) for i in 1:L])
    println(io, &quot;Adjoint matrix product state on $L sites&quot;)
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(io::IO, Ïˆ::Adjoint{T, MPS{L, T}}) where {L, T}
    print(io, &quot;Adjoint MPO on $L sites&quot;)t
end

Base.size(::Adjoint{T, MPS{L, T}}) where {L, T} = (1, L)

function Base.getindex(Ïˆ::Adjoint{T, MPS{L, T}}, args...) where {L, T}
    out = getindex(reverse(Ïˆ.parent.tensors), args...)
    permutedims(conj.(out), (2, 1, 3))
end

adjoint_tensors(Ïˆ::MPS) = reverse(conj.(permutedims.(Ïˆ.tensors, [(2, 1, 3)])))
"><pre><span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">adjoint</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L,T}
    <span class="pl-c1">Adjoint</span><span class="pl-c1">{T, MPS{L, T}}</span>(Ïˆ)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ<span class="pl-k">.</span>parent[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> <span class="pl-c1">reverse</span>([<span class="pl-c1">reverse</span>(<span class="pl-c1">size</span>(Ïˆ<span class="pl-k">.</span>parent[i][:, :, <span class="pl-c1">1</span>])) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L])
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Adjoint matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Adjoint MPO on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)t
<span class="pl-k">end</span>

Base<span class="pl-k">.</span><span class="pl-en">size</span>(<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> (<span class="pl-c1">1</span>, L)

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>, args<span class="pl-k">...</span>) <span class="pl-k">where</span> {L, T}
    out <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(<span class="pl-c1">reverse</span>(Ïˆ<span class="pl-k">.</span>parent<span class="pl-k">.</span>tensors), args<span class="pl-k">...</span>)
    <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(out), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>))
<span class="pl-k">end</span>

<span class="pl-en">adjoint_tensors</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>) <span class="pl-k">=</span> <span class="pl-c1">reverse</span>(<span class="pl-c1">conj</span>.(<span class="pl-c1">permutedims</span>.(Ïˆ<span class="pl-k">.</span>tensors, [(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>)])))</pre></div>
<p></p>
</details>
<details><summary>MPS Contraction</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
&quot;&quot;&quot;
    Base.:(*)(Ïˆâ€²::Adjoint{T, MPS{L, T}}, Ï•::MPS{L, T}) where {L, T}
representing
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢       
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢
&quot;&quot;&quot;
function Base.:(*)(Ïˆâ€²::Adjoint{T, MPS{L, T}}, Ï•::MPS{L, T}) where {L, T}
    Ïˆ = Ïˆâ€².parent

    M   = Ï•.tensors[1]
    MÌƒdg = dg(Ïˆ.tensors[1])
    
    @tensor cont[bâ‚, aâ‚] := MÌƒdg[bâ‚, 1, Ïƒâ‚] * M[1, aâ‚, Ïƒâ‚]
    
    for i in 2:L-1
        M   = Ï•.tensors[i]
        MÌƒdg = dg(Ïˆ.tensors[i])

        @tensor cont[báµ¢, aáµ¢] := MÌƒdg[báµ¢, báµ¢â‚‹â‚, Ïƒáµ¢] * cont[báµ¢â‚‹â‚, aáµ¢â‚‹â‚] * M[aáµ¢â‚‹â‚, aáµ¢, Ïƒáµ¢]
    end
    M   = Ï•.tensors[L]
    MÌƒdg = dg(Ïˆ.tensors[L])
    
    @tensor MÌƒdg[1, bá´¸â»Â¹, Ïƒá´¸] * cont[bá´¸â»Â¹, aá´¸â»Â¹] * M[aá´¸â»Â¹, 1, Ïƒá´¸]
end

"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(Ïˆâ€²::Adjoint{T, MPS{L, T}}, Ï•::MPS{L, T}) where {L, T}</span>
<span class="pl-s">representing</span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢       </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(Ïˆâ€²<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>, Ï•<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    Ïˆ <span class="pl-k">=</span> Ïˆâ€²<span class="pl-k">.</span>parent

    M   <span class="pl-k">=</span> Ï•<span class="pl-k">.</span>tensors[<span class="pl-c1">1</span>]
    MÌƒdg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(Ïˆ<span class="pl-k">.</span>tensors[<span class="pl-c1">1</span>])
    
    <span class="pl-c1">@tensor</span> cont[bâ‚, aâ‚] <span class="pl-k">:=</span> MÌƒdg[bâ‚, <span class="pl-c1">1</span>, Ïƒâ‚] <span class="pl-k">*</span> M[<span class="pl-c1">1</span>, aâ‚, Ïƒâ‚]
    
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>L<span class="pl-k">-</span><span class="pl-c1">1</span>
        M   <span class="pl-k">=</span> Ï•<span class="pl-k">.</span>tensors[i]
        MÌƒdg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(Ïˆ<span class="pl-k">.</span>tensors[i])

        <span class="pl-c1">@tensor</span> cont[báµ¢, aáµ¢] <span class="pl-k">:=</span> MÌƒdg[báµ¢, báµ¢â‚‹â‚, Ïƒáµ¢] <span class="pl-k">*</span> cont[báµ¢â‚‹â‚, aáµ¢â‚‹â‚] <span class="pl-k">*</span> M[aáµ¢â‚‹â‚, aáµ¢, Ïƒáµ¢]
    <span class="pl-k">end</span>
    M   <span class="pl-k">=</span> Ï•<span class="pl-k">.</span>tensors[L]
    MÌƒdg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(Ïˆ<span class="pl-k">.</span>tensors[L])
    
    <span class="pl-c1">@tensor</span> MÌƒdg[<span class="pl-c1">1</span>, bá´¸â»Â¹, Ïƒá´¸] <span class="pl-k">*</span> cont[bá´¸â»Â¹, aá´¸â»Â¹] <span class="pl-k">*</span> M[aá´¸â»Â¹, <span class="pl-c1">1</span>, Ïƒá´¸]
<span class="pl-k">end</span>
</pre></div>
<p></p>
</details>
<p></p>
</details>
<h3><a id="user-content-matrix-product-operators" class="anchor" aria-hidden="true" href="#matrix-product-operators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrix Product Operators</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="&quot;&quot;&quot;
    MPO{L, T&lt;:Number}

Matrix product operator on L sites. The `i`th tensor in the operator
has indices `[aâ±â»Â¹, aâ±, Ïƒâ±, Ïƒâ€²â±]` where `(Ïƒâ±, Ïƒâ€²â±)` are the physical
indices and `(aâ±â»Â¹, aâ±)` are bond indices.

A four site MPS would be diagrammatically represented

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´


Note that `aâ°` and `aá´¸` must be of dimension 1.
&quot;&quot;&quot;
struct MPO{L, T&lt;:Number}
    tensors::Vector{Array{T,4}}
end


&quot;&quot;&quot;
    MPO(W::Array{T,4}, L)
Create an `MPO` for `L` sites with all interior sites containing the tensor
`W`. The tensor is assumed to have the usual matrix-of-operators structure,
with the first two indices being the bond (matrix) dimension and the last two
indices being the physical (operator) dimension. The first and last sites only
use the last row and first column of `W`, respectively.

For example, the MPO form of the Hamiltonian for the TFIM is
constructed as with coupling `g` and length `L` is constructed as
follows:

    id = [1 0
          0 1]

    Ïƒá¶» = [1  0 
          0 -1]

    ÏƒË£ = [0 1
          1 0]

    ÏƒÊ¸ = [0  -im
          im   0]

    W = zeros(3, 3, 2, 2)
    W[1, 1, :, :] = id
    W[2, 1, :, :] = Ïƒá¶»
    W[3, 1, :, :] = -g*ÏƒË£
    W[3, 2, :, :] = -Ïƒá¶»
    W[3, 3, :, :] = id

returning 
 
    Ä¤::MPO = Å´Â¹ Å´Â² Å´Â³ â‹…â‹…â‹… Å´á´¸â»Â¹ Wá´¸
&quot;&quot;&quot;
function MPO(W::Array{T,4}, L) where {T}
    L &gt;= 2 || throw(DomainError(L, &quot;At least 2 sites.&quot;))

    tensors = Vector{Array{T,4}}(undef, L)
    
    tensors[1] = W[end:end, :, :, :] # Row vector.
    for i in 2:(L-1)
        tensors[i] = W # Matrix
    end
    tensors[L] = W[:, 1:1, :, :] # Column vector.

    MPO{L,T}(tensors)
end

Base.:(==)(O::MPO, U::MPO) = O.tensors == U.tensors
Base.:(â‰ˆ)(O::MPO, U::MPO)  = O.tensors â‰ˆ U.tensors
Base.getindex(O::MPO, args...) = getindex(O.tensors, args...)

function Base.show(io::IO, ::MIME&quot;text/plain&quot;, O::MPO{L, T}) where {L, T}
    d = length(O[2][1, 1, 1, :])
    bonddims = [size(O[i][:, :, 1, 1]) for i in 1:L]
    println(io, &quot;Matrix product Operator on $L sites&quot;)
    _show_mpo_dims(io, L, d, bonddims)
end

function _show_mpo_dims(io::IO, L, d, bonddims)
    println(io, &quot;  Physical dimension: $d&quot;)
    print(io, &quot;  Bond dimensions:   &quot;)
    if L &gt; 8
        for i in 1:8
            print(io, bonddims[i], &quot; Ã— &quot;)
        end
        print(io, &quot; ... Ã— &quot;, bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], &quot; Ã— &quot;)
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, O::MPO{L, T}) where {L, T}
    print(io, &quot;MPO on $L sites&quot;)
end
"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPO{L, T&lt;:Number}</span>
<span class="pl-s"></span>
<span class="pl-s">Matrix product operator on L sites. The `i`th tensor in the operator</span>
<span class="pl-s">has indices `[aâ±â»Â¹, aâ±, Ïƒâ±, Ïƒâ€²â±]` where `(Ïƒâ±, Ïƒâ€²â±)` are the physical</span>
<span class="pl-s">indices and `(aâ±â»Â¹, aâ±)` are bond indices.</span>
<span class="pl-s"></span>
<span class="pl-s">A four site MPS would be diagrammatically represented</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s"></span>
<span class="pl-s"></span>
<span class="pl-s">Note that `aâ°` and `aá´¸` must be of dimension 1.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">struct</span> MPO{L, T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>}
    tensors<span class="pl-k">::</span><span class="pl-c1">Vector{Array{T,4}}</span>
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPO(W::Array{T,4}, L)</span>
<span class="pl-s">Create an `MPO` for `L` sites with all interior sites containing the tensor</span>
<span class="pl-s">`W`. The tensor is assumed to have the usual matrix-of-operators structure,</span>
<span class="pl-s">with the first two indices being the bond (matrix) dimension and the last two</span>
<span class="pl-s">indices being the physical (operator) dimension. The first and last sites only</span>
<span class="pl-s">use the last row and first column of `W`, respectively.</span>
<span class="pl-s"></span>
<span class="pl-s">For example, the MPO form of the Hamiltonian for the TFIM is</span>
<span class="pl-s">constructed as with coupling `g` and length `L` is constructed as</span>
<span class="pl-s">follows:</span>
<span class="pl-s"></span>
<span class="pl-s">    id = [1 0</span>
<span class="pl-s">          0 1]</span>
<span class="pl-s"></span>
<span class="pl-s">    Ïƒá¶» = [1  0 </span>
<span class="pl-s">          0 -1]</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒË£ = [0 1</span>
<span class="pl-s">          1 0]</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÊ¸ = [0  -im</span>
<span class="pl-s">          im   0]</span>
<span class="pl-s"></span>
<span class="pl-s">    W = zeros(3, 3, 2, 2)</span>
<span class="pl-s">    W[1, 1, :, :] = id</span>
<span class="pl-s">    W[2, 1, :, :] = Ïƒá¶»</span>
<span class="pl-s">    W[3, 1, :, :] = -g*ÏƒË£</span>
<span class="pl-s">    W[3, 2, :, :] = -Ïƒá¶»</span>
<span class="pl-s">    W[3, 3, :, :] = id</span>
<span class="pl-s"></span>
<span class="pl-s">returning </span>
<span class="pl-s"> </span>
<span class="pl-s">    Ä¤::MPO = Å´Â¹ Å´Â² Å´Â³ â‹…â‹…â‹… Å´á´¸â»Â¹ Wá´¸</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">MPO</span>(W<span class="pl-k">::</span><span class="pl-c1">Array{T,4}</span>, L) <span class="pl-k">where</span> {T}
    L <span class="pl-k">&gt;=</span> <span class="pl-c1">2</span> <span class="pl-k">||</span> <span class="pl-c1">throw</span>(<span class="pl-c1">DomainError</span>(L, <span class="pl-s"><span class="pl-pds">"</span>At least 2 sites.<span class="pl-pds">"</span></span>))

    tensors <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Array{T,4}}</span>(undef, L)
    
    tensors[<span class="pl-c1">1</span>] <span class="pl-k">=</span> W[<span class="pl-c1">end</span><span class="pl-k">:</span><span class="pl-c1">end</span>, :, :, :] <span class="pl-c"><span class="pl-c">#</span> Row vector.</span>
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
        tensors[i] <span class="pl-k">=</span> W <span class="pl-c"><span class="pl-c">#</span> Matrix</span>
    <span class="pl-k">end</span>
    tensors[L] <span class="pl-k">=</span> W[:, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, :, :] <span class="pl-c"><span class="pl-c">#</span> Column vector.</span>

    <span class="pl-c1">MPO</span><span class="pl-c1">{L,T}</span>(tensors)
<span class="pl-k">end</span>

Base.:(<span class="pl-k">==</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, U<span class="pl-k">::</span><span class="pl-c1">MPO</span>) <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors <span class="pl-k">==</span> U<span class="pl-k">.</span>tensors
Base.:(<span class="pl-k">â‰ˆ</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, U<span class="pl-k">::</span><span class="pl-c1">MPO</span>)  <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors <span class="pl-k">â‰ˆ</span> U<span class="pl-k">.</span>tensors
Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, args<span class="pl-k">...</span>) <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(O<span class="pl-k">.</span>tensors, args<span class="pl-k">...</span>)

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(O[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(O[i][:, :, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Matrix product Operator on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mpo_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_show_mpo_dims</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, L, d, bonddims)
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Physical dimension: <span class="pl-v">$d</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Bond dimensions:   <span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> L <span class="pl-k">&gt;</span> <span class="pl-c1">8</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">8</span>
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span> ... Ã— <span class="pl-pds">"</span></span>, bonddims[L])
    <span class="pl-k">else</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, bonddims[L])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>MPO on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span></pre></div>
<details><summary>MPO Contraction</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="&quot;&quot;&quot;
    Base.:(*)(O::MPO, Ïˆ::MPS)
representing

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     
&quot;&quot;&quot;
function Base.:(*)(O::MPO{L, T}, Ïˆ::MPS{L, T}) where {L, T}
    tensors = Array{T,3}[]
    for i in 1:L
        W = O.tensors[i]
        M = Ïˆ.tensors[i]

        @reduce N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] :=  sum(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] * M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        
        push!(tensors, N)
    end
    MPS{L, T}(tensors)
end


&quot;&quot;&quot;
    Base.:(*)(O1::MPO, O2::MPO)
representing

    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´
    |           |           |           | 
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     
    |           |           |           | 
    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´
    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´
    |           |           |           | 
    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢ 
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´    
&quot;&quot;&quot;
function Base.:(*)(O1::MPO{L, T}, O2::MPO{L, T}) where {L, T}
    tensors = Array{T,4}[]
    for i in 1:L
        W1 = O1.tensors[i]
        W2 = O2.tensors[i]

        @reduce V[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢, Ïƒâ€²áµ¢] :=  sum(Ïƒâ€²â€²áµ¢) W1[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²â€²áµ¢] * W2[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²â€²áµ¢, Ïƒâ€²áµ¢]
        
        push!(tensors, V)
    end
    MPO{L, T}(tensors)
end

&quot;&quot;&quot;
    Base.:(*)(Ïˆ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}
representing

    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢       
    |           |           |           | 
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´
    |           |           |           | 
    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢
    |           |           |           | 
    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´ 
&quot;&quot;&quot;
function Base.:(*)(Ïˆâ€²::Adjoint{T,MPS{L,T}}, O::MPO{L, T}) where {L,T}
    Ïˆ = Ïˆâ€².parent
    tensors = Array{T,3}[]
    Ws = dg.(reverse(O.tensors))
    for i in 1:L
        W = Ws[i]
        M = Ïˆ.tensors[i]

        @reduce N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] :=  sum(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] * M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        push!(tensors, N)
    end
    adjoint(MPS{L, T}(tensors))
end
"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(O::MPO, Ïˆ::MPS)</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">3</span>}[]
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors[i]
        M <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] <span class="pl-k">*</span> M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        
        <span class="pl-c1">push!</span>(tensors, N)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(O1::MPO, O2::MPO)</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´</span>
<span class="pl-s">    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢ </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´    </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(O1<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, O2<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">4</span>}[]
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W1 <span class="pl-k">=</span> O1<span class="pl-k">.</span>tensors[i]
        W2 <span class="pl-k">=</span> O2<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> V[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢, Ïƒâ€²áµ¢] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(Ïƒâ€²â€²áµ¢) W1[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²â€²áµ¢] <span class="pl-k">*</span> W2[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²â€²áµ¢, Ïƒâ€²áµ¢]
        
        <span class="pl-c1">push!</span>(tensors, V)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPO</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(Ïˆ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢       </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´ </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(Ïˆâ€²<span class="pl-k">::</span><span class="pl-c1">Adjoint{T,MPS{L,T}}</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L,T}
    Ïˆ <span class="pl-k">=</span> Ïˆâ€²<span class="pl-k">.</span>parent
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">3</span>}[]
    Ws <span class="pl-k">=</span> <span class="pl-c1">dg</span>.(<span class="pl-c1">reverse</span>(O<span class="pl-k">.</span>tensors))
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W <span class="pl-k">=</span> Ws[i]
        M <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] <span class="pl-k">*</span> M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        <span class="pl-c1">push!</span>(tensors, N)
    <span class="pl-k">end</span>
    <span class="pl-c1">adjoint</span>(<span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors))
<span class="pl-k">end</span></pre></div>
<p></p>
</details>
<p></p>
</details>
<h3><a id="user-content-compression" class="anchor" aria-hidden="true" href="#compression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Compression</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="

function compress(Ïˆ::MPS{L, T}, to_the::Right; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    B = Ïˆ[1]
    d = length(B[1, 1, :])
    
    @cast Bm[(ÏƒÂ¹, aâ°), aÂ¹] |= B[aâ°, aÂ¹, ÏƒÂ¹]
    U, S, V = psvd(Bm, rank=Dcut)
    #S = S/âˆšsum(S .^ 2)

    @cast A[aâ°, aÂ¹, ÏƒÂ¹] |= U[(ÏƒÂ¹, aâ°), aÂ¹] (ÏƒÂ¹:d)
    push!(tensors, A)
    
    for i âˆˆ 2:L
        B = Ïˆ[i]
        d = length(B[1, 1, :])

        @tensor M[aâ±â»Â¹, aâ±, Ïƒâ±] := (Diagonal(S)*V')[aâ±â»Â¹, aâ±â»Â¹â€²] * B[aâ±â»Â¹â€², aâ±, Ïƒâ±]
        @cast   Mm[(Ïƒâ±, aâ±â»Â¹), aâ±] |= M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/âˆšsum(S .^ 2)

        @cast A[aâ±â»Â¹, aâ±, Ïƒâ±] |= U[(Ïƒâ±, aâ±â»Â¹), aâ±] (Ïƒâ±:d)
        push!(tensors, A)
    end
    MPS{L, T}(tensors), Left()
end

leftcanonical(Ïˆ) = compress(Ïˆ, right)[1]

function compress(Ïˆ::MPS{L, T}, to_the::Left; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    A = Ïˆ[L]
    d = length(A[1, 1, :])
    @cast Am[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] |= A[aá´¸â»Â¹, aá´¸, Ïƒá´¸]
    
    U, S, V = psvd(Am, rank=Dcut)
    #S = S/âˆšsum(S .^ 2)    

    @cast B[aá´¸â»Â¹, aá´¸, Ïƒá´¸] |= V'[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] (Ïƒá´¸:d)
    push!(tensors, B)
    
    for i âˆˆ (L-1):-1:1
        A = Ïˆ[i]
        d = length(A[1, 1, :])
        @tensor M[aâ±â»Â¹, aâ±, Ïƒâ±]    := A[aâ±â»Â¹, aâ±â€², Ïƒâ±] * (U * Diagonal(S))[aâ±â€², aâ±]
        @cast   Mm[aâ±â»Â¹, (Ïƒâ±, aâ±)] |= M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/âˆšsum(S .^ 2)

        @cast B[aâ±â»Â¹, aâ±, Ïƒâ±] |= V'[aâ±â»Â¹, (Ïƒâ±, aâ±)] (Ïƒâ±:d)
        push!(tensors, B)
    end
    MPS{L, T}(reverse(tensors)), Right()
end

rightcanonical(Ïˆ) = compress(Ïˆ, left)[1]

compress(Ïˆ; Dcut) = compress(Ïˆ, left, Dcut=Dcut)[1]

"><pre><span class="pl-k">function</span> <span class="pl-en">compress</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, to_the<span class="pl-k">::</span><span class="pl-c1">Right</span>; Dcut<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span><span class="pl-c1">typemax</span>(Int)) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    
    B <span class="pl-k">=</span> Ïˆ[<span class="pl-c1">1</span>]
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(B[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    
    <span class="pl-c1">@cast</span> Bm[(ÏƒÂ¹, aâ°), aÂ¹] <span class="pl-k">|=</span> B[aâ°, aÂ¹, ÏƒÂ¹]
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Bm, rank<span class="pl-k">=</span>Dcut)
    <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)</span>

    <span class="pl-c1">@cast</span> A[aâ°, aÂ¹, ÏƒÂ¹] <span class="pl-k">|=</span> U[(ÏƒÂ¹, aâ°), aÂ¹] (ÏƒÂ¹<span class="pl-c1">:d</span>)
    <span class="pl-c1">push!</span>(tensors, A)
    
    <span class="pl-k">for</span> i <span class="pl-k">âˆˆ</span> <span class="pl-c1">2</span><span class="pl-k">:</span>L
        B <span class="pl-k">=</span> Ïˆ[i]
        d <span class="pl-k">=</span> <span class="pl-c1">length</span>(B[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])

        <span class="pl-c1">@tensor</span> M[aâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">:=</span> (<span class="pl-c1">Diagonal</span>(S)<span class="pl-k">*</span>V<span class="pl-k">'</span>)[aâ±â»Â¹, aâ±â»Â¹â€²] <span class="pl-k">*</span> B[aâ±â»Â¹â€², aâ±, Ïƒâ±]
        <span class="pl-c1">@cast</span>   Mm[(Ïƒâ±, aâ±â»Â¹), aâ±] <span class="pl-k">|=</span> M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Mm, rank<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)</span>

        <span class="pl-c1">@cast</span> A[aâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">|=</span> U[(Ïƒâ±, aâ±â»Â¹), aâ±] (Ïƒâ±<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, A)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors), <span class="pl-c1">Left</span>()
<span class="pl-k">end</span>

<span class="pl-en">leftcanonical</span>(Ïˆ) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, right)[<span class="pl-c1">1</span>]

<span class="pl-k">function</span> <span class="pl-en">compress</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, to_the<span class="pl-k">::</span><span class="pl-c1">Left</span>; Dcut<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span><span class="pl-c1">typemax</span>(Int)) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    
    A <span class="pl-k">=</span> Ïˆ[L]
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(A[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    <span class="pl-c1">@cast</span> Am[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] <span class="pl-k">|=</span> A[aá´¸â»Â¹, aá´¸, Ïƒá´¸]
    
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Am, rank<span class="pl-k">=</span>Dcut)
    <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)    </span>

    <span class="pl-c1">@cast</span> B[aá´¸â»Â¹, aá´¸, Ïƒá´¸] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] (Ïƒá´¸<span class="pl-c1">:d</span>)
    <span class="pl-c1">push!</span>(tensors, B)
    
    <span class="pl-k">for</span> i <span class="pl-k">âˆˆ</span> (L<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>
        A <span class="pl-k">=</span> Ïˆ[i]
        d <span class="pl-k">=</span> <span class="pl-c1">length</span>(A[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
        <span class="pl-c1">@tensor</span> M[aâ±â»Â¹, aâ±, Ïƒâ±]    <span class="pl-k">:=</span> A[aâ±â»Â¹, aâ±â€², Ïƒâ±] <span class="pl-k">*</span> (U <span class="pl-k">*</span> <span class="pl-c1">Diagonal</span>(S))[aâ±â€², aâ±]
        <span class="pl-c1">@cast</span>   Mm[aâ±â»Â¹, (Ïƒâ±, aâ±)] <span class="pl-k">|=</span> M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Mm, rank<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)</span>

        <span class="pl-c1">@cast</span> B[aâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aâ±â»Â¹, (Ïƒâ±, aâ±)] (Ïƒâ±<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, B)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(<span class="pl-c1">reverse</span>(tensors)), <span class="pl-c1">Right</span>()
<span class="pl-k">end</span>

<span class="pl-en">rightcanonical</span>(Ïˆ) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, left)[<span class="pl-c1">1</span>]

<span class="pl-en">compress</span>(Ïˆ; Dcut) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, left, Dcut<span class="pl-k">=</span>Dcut)[<span class="pl-c1">1</span>]
</pre></div>
<p></p>
</details>
<h3><a id="user-content-iterative-ground-state-search" class="anchor" aria-hidden="true" href="#iterative-ground-state-search"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Iterative Ground State Search</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
function R_exprs(Ïˆ::MPS{L, T}, H::MPO{L, T}) where {L, T}
    R_exs = Array{T, 3}[]
    R_ex = ones(T, 1, 1, 1)
    for l in L:-1:2
        R_ex = iterate_R_ex(Ïˆ[l], H[l], R_ex) 
        push!(R_exs, R_ex)
    end
    reverse(R_exs)
end

# function preallocate_hs(Ïˆ::MPS{L, T}) where {L, T}
#     h_tnsrs = map(Ïˆ.tensors) do M
#         DË¡â»Â¹, DË¡, d = size(M)
#         Array{T, 6}(undef, d, DË¡â»Â¹, DË¡, d, DË¡â»Â¹, DË¡)
#     end
# end


function sweep!(::Right, Ïˆ::MPS{L, T}, H::MPO{L, T}, R_exs) where {L, T}
    L_exs = Array{T, 3}[]
    L_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    for l in 1:(L-1)
        W = H[l]
        
        E, A, SVp = eigenproblem(right, Ïˆ[l], L_ex, W, R_exs[l])
        Ïˆ.tensors[l] = A

        L_ex = iterate_L_ex(A, W, L_ex)
        push!(L_exs, L_ex)

        Bp1 = Ïˆ.tensors[l+1]
        @tensor Mp1[sâ±â»Â¹, aâ±, Ïƒâ±] := SVp[sâ±â»Â¹, aâ±â»Â¹] * Bp1[aâ±â»Â¹, aâ±, Ïƒâ±]
        Ïˆ.tensors[l+1] = Mp1
    end
    L_exs, E
end

function sweep!(::Left, Ïˆ::MPS{L, T}, H::MPO{L, T}, L_exs) where {L, T}
    R_exs = Array{T, 3}[]
    R_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    for l in L:-1:2
        W = H[l]

        E, US, B = eigenproblem(left, Ïˆ[l], L_exs[l-1], W, R_ex)
        Ïˆ.tensors[l] = B

        R_ex = iterate_R_ex(B, W, R_ex) 
        push!(R_exs, R_ex)

        Am1 = Ïˆ.tensors[l-1]
        @tensor Mm1[aË¡â»Â², sË¡â»Â¹, ÏƒË¡â»Â¹] :=  Am1[aË¡â»Â², aË¡â»Â¹â€², ÏƒË¡â»Â¹] * US[aË¡â»Â¹â€², sË¡â»Â¹]
        Ïˆ.tensors[l-1] = Mm1
    end
    R_exs, E
end

function h_matrix(L_ex::Array{T,3}, W::Array{T,4}, R_ex::Array{T,3}) where {T}
    @tensor h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²] := L_ex[bË¡â»Â¹, aË¡â»Â¹, aË¡â»Â¹â€²] * W[bË¡â»Â¹, bË¡, ÏƒË¡, ÏƒË¡â€²] * R_ex[bË¡, aË¡, aË¡â€²]
    @cast h[(ÏƒË¡, aË¡â»Â¹, aË¡), (ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²)] := h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²]
end

function eigenproblem(dir::Direction, M::Array{T, 3}, L_ex::Array{T, 3}, W::Array{T, 4}, R_ex::Array{T, 3}) where {T}
    @cast v[(ÏƒË¡, aË¡â»Â¹, aË¡)] |= M[aË¡â»Â¹, aË¡, ÏƒË¡]
    
    h = h_matrix(L_ex, W, R_ex)
    Î», Î¦ = eigs(h, v0=v, nev=1, which=:SR)
    E  = Î»[1]::T 
    vâ° = (Î¦[:,1])::Vector{T}

    (E, split_tensor(dir, vâ°, size(M))...)
end

function split_tensor(::Right, vâ°::Vector, (DË¡â»Â¹, DË¡, d))
    @cast Mm[(ÏƒË¡, aË¡â»Â¹), aË¡] := vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹:DË¡â»Â¹, aË¡:DË¡, ÏƒË¡:d)
    U, S, V = svd(Mm)
    @cast A[aË¡â»Â¹, aË¡, ÏƒË¡] |= U[(ÏƒË¡, aË¡â»Â¹), aË¡] (ÏƒË¡:d, aË¡â»Â¹:DË¡â»Â¹, aË¡:DË¡)
    A, Diagonal(S)*V'
end

function split_tensor(::Left, vâ°::Vector, (DË¡â»Â¹, DË¡, d))
    @cast Mm[aË¡â»Â¹, (ÏƒË¡, aË¡)] |= vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹:DË¡â»Â¹, aË¡:DË¡, ÏƒË¡:d)
    U, S, V = svd(Mm)
    @cast B[aË¡â»Â¹, aË¡, ÏƒË¡] |= V'[aË¡â»Â¹, (ÏƒË¡, aË¡)] (ÏƒË¡:d)
    U*Diagonal(S), B
end

function iterate_R_ex(B, W, R_ex) where {T}
    @tensoropt R_exâ€²[bâ±â»Â¹, aâ±â»Â¹, aâ±â»Â¹â€²] := (conj.(B))[aâ±â»Â¹,aâ±,Ïƒâ±] * W[bâ±â»Â¹,bâ±,Ïƒâ±,Ïƒâ±â€²] * B[aâ±â»Â¹â€²,aâ±â€²,Ïƒâ±â€²] * R_ex[bâ±,aâ±,aâ±â€²]
end

function iterate_L_ex(A, W, L_ex) where {T}
    @tensoropt L_exâ€²[bË¡, aË¡, aË¡â€²] := L_ex[bË¡â»Â¹,aË¡â»Â¹,aË¡â»Â¹â€²] * (conj.(A))[aË¡â»Â¹,aË¡,ÏƒË¡] * W[bË¡â»Â¹,bË¡,ÏƒË¡,ÏƒË¡â€²] * A[aË¡â»Â¹â€²,aË¡â€²,ÏƒË¡â€²]
end


&quot;&quot;&quot;
    ground_state(Ïˆ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, Ïµ=1e-8) where {L, T}

Perform the finite system density matrix renormalization group
algorithm. First this will build up the R expressions, then do right
and left sweeps until either
 1) The state converges to an eigenstate `Ï•` such that
    Ï•' * H * H * Ï• â‰ˆ (Ï•' * H * Ï•) 
to the requested tolerance `Ïµ`
 2) The energy eigenvalue stops changing (possible signaling the algorithm is 
stuck in a local minimum)
 3) The number of full (right and left) sweeps exceeds `maxiter`. 

Setting `quiet=true` will suppress notifications about the algorithm's
progress but *not* warnings due to non-convergence.
&quot;&quot;&quot;
function ground_state(Ïˆ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, Ïµ=1e-8) where {L, T}
    Ï• = Ïˆ |&gt; copy

    quiet || println(&quot;Computing R expressions&quot;)
    R_exs = R_exprs(Ïˆ, H)

    converged = false
    count     = 0
    Eâ‚€ = zero(T)
    enable_cache(maxsize=5*10^9)
    while not(converged)
        quiet || println(&quot;Performing right sweep&quot;)
        L_exs, Eâ‚€â€² = sweep!(right, Ï•, H, R_exs)

        quiet || println(&quot;Performing left sweep&quot;)
        R_exs, Eâ‚€  = sweep!(left,  Ï•, H, L_exs)

        count += 1
        if iseigenstate(Ï•, H, Ïµ=Ïµ)
            quiet || println(&quot;Converged in $count iterations&quot;)
            converged = true
        elseif count &gt; 1 &amp;&amp; Eâ‚€ â‰ˆ Eâ‚€â€²
                @warn &quot;&quot;&quot;
Energy eigenvalue converged but state is not an eigenstate.
Consider either lowering your requested tolerance or 
implementing a warm-up algorithm to avoid local minima.
&quot;&quot;&quot;
            break
        elseif count &gt;= maxiter
            @warn &quot;Did not converge in $maxiter iterations&quot;
            break
        end
    end
    clear_cache()
    Ï•, Eâ‚€
end


function iseigenstate(Ïˆ::MPS, H::MPO; Ïµ=1e-8)
    Ï• = rightcanonical(Ïˆ)
    isapprox(Ï•' * (H * H * Ï•), (Ï•' * (H * Ï•))^2, rtol=Ïµ)
end

"><pre><span class="pl-k">function</span> <span class="pl-en">R_exprs</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    R_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    R_ex <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> L<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>
        R_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_R_ex</span>(Ïˆ[l], H[l], R_ex) 
        <span class="pl-c1">push!</span>(R_exs, R_ex)
    <span class="pl-k">end</span>
    <span class="pl-c1">reverse</span>(R_exs)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> function preallocate_hs(Ïˆ::MPS{L, T}) where {L, T}</span>
<span class="pl-c"><span class="pl-c">#</span>     h_tnsrs = map(Ïˆ.tensors) do M</span>
<span class="pl-c"><span class="pl-c">#</span>         DË¡â»Â¹, DË¡, d = size(M)</span>
<span class="pl-c"><span class="pl-c">#</span>         Array{T, 6}(undef, d, DË¡â»Â¹, DË¡, d, DË¡â»Â¹, DË¡)</span>
<span class="pl-c"><span class="pl-c">#</span>     end</span>
<span class="pl-c"><span class="pl-c">#</span> end</span>


<span class="pl-k">function</span> <span class="pl-en">sweep!</span>(<span class="pl-k">::</span><span class="pl-c1">Right</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, R_exs) <span class="pl-k">where</span> {L, T}
    L_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    L_ex  <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    E <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
        W <span class="pl-k">=</span> H[l]
        
        E, A, SVp <span class="pl-k">=</span> <span class="pl-c1">eigenproblem</span>(right, Ïˆ[l], L_ex, W, R_exs[l])
        Ïˆ<span class="pl-k">.</span>tensors[l] <span class="pl-k">=</span> A

        L_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_L_ex</span>(A, W, L_ex)
        <span class="pl-c1">push!</span>(L_exs, L_ex)

        Bp1 <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">+</span><span class="pl-c1">1</span>]
        <span class="pl-c1">@tensor</span> Mp1[sâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">:=</span> SVp[sâ±â»Â¹, aâ±â»Â¹] <span class="pl-k">*</span> Bp1[aâ±â»Â¹, aâ±, Ïƒâ±]
        Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> Mp1
    <span class="pl-k">end</span>
    L_exs, E
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">sweep!</span>(<span class="pl-k">::</span><span class="pl-c1">Left</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, L_exs) <span class="pl-k">where</span> {L, T}
    R_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    R_ex  <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    E <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> L<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>
        W <span class="pl-k">=</span> H[l]

        E, US, B <span class="pl-k">=</span> <span class="pl-c1">eigenproblem</span>(left, Ïˆ[l], L_exs[l<span class="pl-k">-</span><span class="pl-c1">1</span>], W, R_ex)
        Ïˆ<span class="pl-k">.</span>tensors[l] <span class="pl-k">=</span> B

        R_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_R_ex</span>(B, W, R_ex) 
        <span class="pl-c1">push!</span>(R_exs, R_ex)

        Am1 <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">-</span><span class="pl-c1">1</span>]
        <span class="pl-c1">@tensor</span> Mm1[aË¡â»Â², sË¡â»Â¹, ÏƒË¡â»Â¹] <span class="pl-k">:=</span>  Am1[aË¡â»Â², aË¡â»Â¹â€², ÏƒË¡â»Â¹] <span class="pl-k">*</span> US[aË¡â»Â¹â€², sË¡â»Â¹]
        Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> Mm1
    <span class="pl-k">end</span>
    R_exs, E
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">h_matrix</span>(L_ex<span class="pl-k">::</span><span class="pl-c1">Array{T,3}</span>, W<span class="pl-k">::</span><span class="pl-c1">Array{T,4}</span>, R_ex<span class="pl-k">::</span><span class="pl-c1">Array{T,3}</span>) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensor</span> h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²] <span class="pl-k">:=</span> L_ex[bË¡â»Â¹, aË¡â»Â¹, aË¡â»Â¹â€²] <span class="pl-k">*</span> W[bË¡â»Â¹, bË¡, ÏƒË¡, ÏƒË¡â€²] <span class="pl-k">*</span> R_ex[bË¡, aË¡, aË¡â€²]
    <span class="pl-c1">@cast</span> h[(ÏƒË¡, aË¡â»Â¹, aË¡), (ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²)] <span class="pl-k">:=</span> h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²]
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">eigenproblem</span>(dir<span class="pl-k">::</span><span class="pl-c1">Direction</span>, M<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>, L_ex<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>, W<span class="pl-k">::</span><span class="pl-c1">Array{T, 4}</span>, R_ex<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@cast</span> v[(ÏƒË¡, aË¡â»Â¹, aË¡)] <span class="pl-k">|=</span> M[aË¡â»Â¹, aË¡, ÏƒË¡]
    
    h <span class="pl-k">=</span> <span class="pl-c1">h_matrix</span>(L_ex, W, R_ex)
    Î», Î¦ <span class="pl-k">=</span> <span class="pl-c1">eigs</span>(h, v0<span class="pl-k">=</span>v, nev<span class="pl-k">=</span><span class="pl-c1">1</span>, which<span class="pl-k">=</span><span class="pl-c1">:SR</span>)
    E  <span class="pl-k">=</span> Î»[<span class="pl-c1">1</span>]<span class="pl-k">::</span><span class="pl-c1">T</span> 
    vâ° <span class="pl-k">=</span> (Î¦[:,<span class="pl-c1">1</span>])<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>

    (E, <span class="pl-c1">split_tensor</span>(dir, vâ°, <span class="pl-c1">size</span>(M))<span class="pl-k">...</span>)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">split_tensor</span>(<span class="pl-k">::</span><span class="pl-c1">Right</span>, vâ°<span class="pl-k">::</span><span class="pl-c1">Vector</span>, (DË¡â»Â¹, DË¡, d))
    <span class="pl-c1">@cast</span> Mm[(ÏƒË¡, aË¡â»Â¹), aË¡] <span class="pl-k">:=</span> vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹<span class="pl-c1">:DË¡â»Â¹</span>, aË¡<span class="pl-c1">:DË¡</span>, ÏƒË¡<span class="pl-c1">:d</span>)
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(Mm)
    <span class="pl-c1">@cast</span> A[aË¡â»Â¹, aË¡, ÏƒË¡] <span class="pl-k">|=</span> U[(ÏƒË¡, aË¡â»Â¹), aË¡] (ÏƒË¡<span class="pl-c1">:d</span>, aË¡â»Â¹<span class="pl-c1">:DË¡â»Â¹</span>, aË¡<span class="pl-c1">:DË¡</span>)
    A, <span class="pl-c1">Diagonal</span>(S)<span class="pl-k">*</span>V<span class="pl-k">'</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">split_tensor</span>(<span class="pl-k">::</span><span class="pl-c1">Left</span>, vâ°<span class="pl-k">::</span><span class="pl-c1">Vector</span>, (DË¡â»Â¹, DË¡, d))
    <span class="pl-c1">@cast</span> Mm[aË¡â»Â¹, (ÏƒË¡, aË¡)] <span class="pl-k">|=</span> vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹<span class="pl-c1">:DË¡â»Â¹</span>, aË¡<span class="pl-c1">:DË¡</span>, ÏƒË¡<span class="pl-c1">:d</span>)
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(Mm)
    <span class="pl-c1">@cast</span> B[aË¡â»Â¹, aË¡, ÏƒË¡] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aË¡â»Â¹, (ÏƒË¡, aË¡)] (ÏƒË¡<span class="pl-c1">:d</span>)
    U<span class="pl-k">*</span><span class="pl-c1">Diagonal</span>(S), B
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">iterate_R_ex</span>(B, W, R_ex) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensoropt</span> R_exâ€²[bâ±â»Â¹, aâ±â»Â¹, aâ±â»Â¹â€²] <span class="pl-k">:=</span> (<span class="pl-c1">conj</span>.(B))[aâ±â»Â¹,aâ±,Ïƒâ±] <span class="pl-k">*</span> W[bâ±â»Â¹,bâ±,Ïƒâ±,Ïƒâ±â€²] <span class="pl-k">*</span> B[aâ±â»Â¹â€²,aâ±â€²,Ïƒâ±â€²] <span class="pl-k">*</span> R_ex[bâ±,aâ±,aâ±â€²]
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">iterate_L_ex</span>(A, W, L_ex) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensoropt</span> L_exâ€²[bË¡, aË¡, aË¡â€²] <span class="pl-k">:=</span> L_ex[bË¡â»Â¹,aË¡â»Â¹,aË¡â»Â¹â€²] <span class="pl-k">*</span> (<span class="pl-c1">conj</span>.(A))[aË¡â»Â¹,aË¡,ÏƒË¡] <span class="pl-k">*</span> W[bË¡â»Â¹,bË¡,ÏƒË¡,ÏƒË¡â€²] <span class="pl-k">*</span> A[aË¡â»Â¹â€²,aË¡â€²,ÏƒË¡â€²]
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    ground_state(Ïˆ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, Ïµ=1e-8) where {L, T}</span>
<span class="pl-s"></span>
<span class="pl-s">Perform the finite system density matrix renormalization group</span>
<span class="pl-s">algorithm. First this will build up the R expressions, then do right</span>
<span class="pl-s">and left sweeps until either</span>
<span class="pl-s"> 1) The state converges to an eigenstate `Ï•` such that</span>
<span class="pl-s">    Ï•' * H * H * Ï• â‰ˆ (Ï•' * H * Ï•) </span>
<span class="pl-s">to the requested tolerance `Ïµ`</span>
<span class="pl-s"> 2) The energy eigenvalue stops changing (possible signaling the algorithm is </span>
<span class="pl-s">stuck in a local minimum)</span>
<span class="pl-s"> 3) The number of full (right and left) sweeps exceeds `maxiter`. </span>
<span class="pl-s"></span>
<span class="pl-s">Setting `quiet=true` will suppress notifications about the algorithm's</span>
<span class="pl-s">progress but *not* warnings due to non-convergence.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">ground_state</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>; maxiter<span class="pl-k">=</span><span class="pl-c1">10</span>, quiet<span class="pl-k">=</span><span class="pl-c1">false</span>, Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-8</span>) <span class="pl-k">where</span> {L, T}
    Ï• <span class="pl-k">=</span> Ïˆ <span class="pl-k">|&gt;</span> copy

    quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computing R expressions<span class="pl-pds">"</span></span>)
    R_exs <span class="pl-k">=</span> <span class="pl-c1">R_exprs</span>(Ïˆ, H)

    converged <span class="pl-k">=</span> <span class="pl-c1">false</span>
    count     <span class="pl-k">=</span> <span class="pl-c1">0</span>
    Eâ‚€ <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-c1">enable_cache</span>(maxsize<span class="pl-k">=</span><span class="pl-c1">5</span><span class="pl-k">*</span><span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">9</span>)
    <span class="pl-k">while</span> <span class="pl-c1">not</span>(converged)
        quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Performing right sweep<span class="pl-pds">"</span></span>)
        L_exs, Eâ‚€â€² <span class="pl-k">=</span> <span class="pl-c1">sweep!</span>(right, Ï•, H, R_exs)

        quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Performing left sweep<span class="pl-pds">"</span></span>)
        R_exs, Eâ‚€  <span class="pl-k">=</span> <span class="pl-c1">sweep!</span>(left,  Ï•, H, L_exs)

        count <span class="pl-k">+=</span> <span class="pl-c1">1</span>
        <span class="pl-k">if</span> <span class="pl-c1">iseigenstate</span>(Ï•, H, Ïµ<span class="pl-k">=</span>Ïµ)
            quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Converged in <span class="pl-v">$count</span> iterations<span class="pl-pds">"</span></span>)
            converged <span class="pl-k">=</span> <span class="pl-c1">true</span>
        <span class="pl-k">elseif</span> count <span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> Eâ‚€ <span class="pl-k">â‰ˆ</span> Eâ‚€â€²
                <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">Energy eigenvalue converged but state is not an eigenstate.</span>
<span class="pl-s">Consider either lowering your requested tolerance or </span>
<span class="pl-s">implementing a warm-up algorithm to avoid local minima.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
            <span class="pl-k">break</span>
        <span class="pl-k">elseif</span> count <span class="pl-k">&gt;=</span> maxiter
            <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"</span>Did not converge in <span class="pl-v">$maxiter</span> iterations<span class="pl-pds">"</span></span>
            <span class="pl-k">break</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-c1">clear_cache</span>()
    Ï•, Eâ‚€
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">iseigenstate</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO</span>; Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-8</span>)
    Ï• <span class="pl-k">=</span> <span class="pl-c1">rightcanonical</span>(Ïˆ)
    <span class="pl-c1">isapprox</span>(Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï•), (Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> Ï•))<span class="pl-k">^</span><span class="pl-c1">2</span>, rtol<span class="pl-k">=</span>Ïµ)
<span class="pl-k">end</span>
</pre></div>
</details>
<p></p>
<h3><a id="user-content-correlation-functions" class="anchor" aria-hidden="true" href="#correlation-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Correlation Functions</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
&quot;&quot;&quot;
    two_point_correlator((i, op_i)::Pair{Int, Matrix}, (j, op_j)::Pair{Int, Matrix}, L)

Create an MPO on `L` sites (with bond dimension 1) representing identity operators everywhere except
sites `i` and `j` where `op_i` and `op_j` are inserted instead. ie.

    ğŸ™ âŠ— ğŸ™ âŠ— ... âŠ— op_i âŠ— ğŸ™ âŠ— ... âŠ— op_j âŠ— ğŸ™ âŠ— ... âŠ— ğŸ™

example: spin-spin correlation function

we can construct âŸ¨Ïƒá¶»áµ¢Ïƒá¶»â±¼âŸ© on a 12 site lattice as
    Ïƒá¶» = [1 0; 0 -1]
    two_point_correlator(i=&gt;Ïƒá¶», j=&gt;Ïƒá¶», 12)  
&quot;&quot;&quot;
function two_point_correlator((i, op_i), (j, op_j), L)
    d = size(op_i)[1]
    @assert (size(op_i) == (d, d)) &amp;&amp; (size(op_j) == (d, d))
    @assert i in 1:L
    @assert j in 1:L
    id = diagm(0 =&gt; ones(Complex{Float64}, d))

    op_i_tnsr = reshape(convert(Matrix{Complex{Float64}}, op_i), 1, 1, d, d) 
    op_j_tnsr = reshape(convert(Matrix{Complex{Float64}}, op_j), 1, 1, d, d)
    id_tnsr   = reshape(id, 1, 1, d, d)

    tensors = map(1:L) do l
        O_tnsr = (l == i ? op_i_tnsr : 
                  l == j ? op_j_tnsr : 
                  id_tnsr)
    end 
    MPO{L,Complex{Float64}}(tensors)
end




"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    two_point_correlator((i, op_i)::Pair{Int, Matrix}, (j, op_j)::Pair{Int, Matrix}, L)</span>
<span class="pl-s"></span>
<span class="pl-s">Create an MPO on `L` sites (with bond dimension 1) representing identity operators everywhere except</span>
<span class="pl-s">sites `i` and `j` where `op_i` and `op_j` are inserted instead. ie.</span>
<span class="pl-s"></span>
<span class="pl-s">    ğŸ™ âŠ— ğŸ™ âŠ— ... âŠ— op_i âŠ— ğŸ™ âŠ— ... âŠ— op_j âŠ— ğŸ™ âŠ— ... âŠ— ğŸ™</span>
<span class="pl-s"></span>
<span class="pl-s">example: spin-spin correlation function</span>
<span class="pl-s"></span>
<span class="pl-s">we can construct âŸ¨Ïƒá¶»áµ¢Ïƒá¶»â±¼âŸ© on a 12 site lattice as</span>
<span class="pl-s">    Ïƒá¶» = [1 0; 0 -1]</span>
<span class="pl-s">    two_point_correlator(i=&gt;Ïƒá¶», j=&gt;Ïƒá¶», 12)  </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">two_point_correlator</span>((i, op_i), (j, op_j), L)
    d <span class="pl-k">=</span> <span class="pl-c1">size</span>(op_i)[<span class="pl-c1">1</span>]
    <span class="pl-c1">@assert</span> (<span class="pl-c1">size</span>(op_i) <span class="pl-k">==</span> (d, d)) <span class="pl-k">&amp;&amp;</span> (<span class="pl-c1">size</span>(op_j) <span class="pl-k">==</span> (d, d))
    <span class="pl-c1">@assert</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
    <span class="pl-c1">@assert</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
    id <span class="pl-k">=</span> <span class="pl-c1">diagm</span>(<span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">ones</span>(Complex{Float64}, d))

    op_i_tnsr <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">convert</span>(Matrix{Complex{Float64}}, op_i), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d) 
    op_j_tnsr <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">convert</span>(Matrix{Complex{Float64}}, op_j), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d)
    id_tnsr   <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(id, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d)

    tensors <span class="pl-k">=</span> <span class="pl-c1">map</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>L) <span class="pl-k">do</span> l
        O_tnsr <span class="pl-k">=</span> (l <span class="pl-k">==</span> i <span class="pl-k">?</span> op_i_tnsr <span class="pl-k">:</span> 
                  l <span class="pl-k">==</span> j <span class="pl-k">?</span> op_j_tnsr <span class="pl-k">:</span> 
                  id_tnsr)
    <span class="pl-k">end</span> 
    <span class="pl-c1">MPO</span><span class="pl-c1">{L,Complex{Float64}}</span>(tensors)
<span class="pl-k">end</span>



</pre></div>
</details>
<p></p>
<h3><a id="user-content-imaginary-time-evolution" class="anchor" aria-hidden="true" href="#imaginary-time-evolution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Imaginary Time Evolution</h3>
<p>I donâ€™t think this works!</p>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
# Fixme! this does not appear to find ground states!

function _MPO_handed_time_evolver(hs::Vector{Matrix{T}}, Ï„, L, d) where {T}
    tensors = Array{T, 4}[]
    for h in hs
        O = exp(-Ï„*h)
        @cast P[(Ïƒâ±, Ïƒâ±â€²), (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] |= O[(Ïƒâ±, Ïƒâ±âºÂ¹), (Ïƒâ±â€², Ïƒâ±âºÂ¹â€²)] (Ïƒâ±:d, Ïƒâ±â€²:d)
        U, S, V = svd(P)

        @cast U[1, k, Ïƒâ±, Ïƒâ±â€²]     := U[(Ïƒâ±, Ïƒâ±â€²), k] * âˆš(S[k])      (Ïƒâ±:d)
        @cast Åª[k, 1, Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²] := âˆš(S[k]) * V'[k, (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] (Ïƒâ±âºÂ¹:d)
        push!(tensors, U, Åª)
    end
    MPO{L, T}(tensors)
end

function MPO_time_evolvers(h1::Matrix, hi::Matrix, hL::Matrix, Ï„, L, d)
    if iseven(L)
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]...]
        even_hs = [[hi for i in 2:2:(L-1)]..., hL]
    else
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]..., hL]
        even_hs = [hi for i in 2:2:(L-1)]
    end
    
    Uodd  = _MPO_handed_time_evolver(odd_hs, Ï„, L, d)
    Ueven = _MPO_handed_time_evolver(even_hs, Ï„, L, d)
    Uodd, Ueven
end

function imag_time_evolution(Ïˆ::MPS{L, T}, h1::Matrix{T}, hi::Matrix{T}, hL::Matrix{T}, 
                             Î², N, Dcut) where {L, T}
    @warn &quot;This probably still doesn't work!&quot;
    Ï„ = Î²/N
    d = length(Ïˆ[1][1, 1, :])
    Ï• = Ïˆ  # Ground state guess
    dir = left
    Uodd, Ueven = MPO_time_evolvers(h1, hi, hL, Ï„, L, d)
    for _ in 1:N
        Ï•1, dir = compress(Uodd  * Ï•,  dir, Dcut=Dcut)
        Ï•,  dir = compress(Ueven * Ï•1, dir, Dcut=Dcut)
        #Ï•,  dir = compress(Uodd  * Ï•2, dir, Dcut=Dcut)
    end
    Ï•
end
"><pre><span class="pl-c"><span class="pl-c">#</span> Fixme! this does not appear to find ground states!</span>

<span class="pl-k">function</span> <span class="pl-en">_MPO_handed_time_evolver</span>(hs<span class="pl-k">::</span><span class="pl-c1">Vector{Matrix{T}}</span>, Ï„, L, d) <span class="pl-k">where</span> {T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">4</span>}[]
    <span class="pl-k">for</span> h <span class="pl-k">in</span> hs
        O <span class="pl-k">=</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span>Ï„<span class="pl-k">*</span>h)
        <span class="pl-c1">@cast</span> P[(Ïƒâ±, Ïƒâ±â€²), (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] <span class="pl-k">|=</span> O[(Ïƒâ±, Ïƒâ±âºÂ¹), (Ïƒâ±â€², Ïƒâ±âºÂ¹â€²)] (Ïƒâ±<span class="pl-c1">:d</span>, Ïƒâ±â€²<span class="pl-k">:</span>d)
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(P)

        <span class="pl-c1">@cast</span> U[<span class="pl-c1">1</span>, k, Ïƒâ±, Ïƒâ±â€²]     <span class="pl-k">:=</span> U[(Ïƒâ±, Ïƒâ±â€²), k] <span class="pl-k">*</span> <span class="pl-k">âˆš</span>(S[k])      (Ïƒâ±<span class="pl-c1">:d</span>)
        <span class="pl-c1">@cast</span> Åª[k, <span class="pl-c1">1</span>, Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²] <span class="pl-k">:=</span> <span class="pl-k">âˆš</span>(S[k]) <span class="pl-k">*</span> V<span class="pl-k">'</span>[k, (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] (Ïƒâ±âºÂ¹<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, U, Åª)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPO</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">MPO_time_evolvers</span>(h1<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, hi<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, hL<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, Ï„, L, d)
    <span class="pl-k">if</span> <span class="pl-c1">iseven</span>(L)
        odd_hs  <span class="pl-k">=</span> [h1, [hi <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>]
        even_hs <span class="pl-k">=</span> [[hi <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, hL]
    <span class="pl-k">else</span>
        odd_hs  <span class="pl-k">=</span> [h1, [hi <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, hL]
        even_hs <span class="pl-k">=</span> [hi <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]
    <span class="pl-k">end</span>
    
    Uodd  <span class="pl-k">=</span> <span class="pl-c1">_MPO_handed_time_evolver</span>(odd_hs, Ï„, L, d)
    Ueven <span class="pl-k">=</span> <span class="pl-c1">_MPO_handed_time_evolver</span>(even_hs, Ï„, L, d)
    Uodd, Ueven
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">imag_time_evolution</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, h1<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, hi<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, hL<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, 
                             Î², N, Dcut) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"</span>This probably still doesn't work!<span class="pl-pds">"</span></span>
    Ï„ <span class="pl-k">=</span> Î²<span class="pl-k">/</span>N
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    Ï• <span class="pl-k">=</span> Ïˆ  <span class="pl-c"><span class="pl-c">#</span> Ground state guess</span>
    dir <span class="pl-k">=</span> left
    Uodd, Ueven <span class="pl-k">=</span> <span class="pl-c1">MPO_time_evolvers</span>(h1, hi, hL, Ï„, L, d)
    <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        Ï•1, dir <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Uodd  <span class="pl-k">*</span> Ï•,  dir, Dcut<span class="pl-k">=</span>Dcut)
        Ï•,  dir <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ueven <span class="pl-k">*</span> Ï•1, dir, Dcut<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>Ï•,  dir = compress(Uodd  * Ï•2, dir, Dcut=Dcut)</span>
    <span class="pl-k">end</span>
    Ï•
<span class="pl-k">end</span></pre></div>
</details>
<p></p>
<h2><a id="user-content-tests" class="anchor" aria-hidden="true" href="#tests"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tests</h2>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Test, MatrixProductStates, SparseArrays, Arpack

@testset &quot;TFIM   &quot; begin
    g = 1.0; L = 7

    function H_TFIM(g, L)
        id = [1  0; 
              0  1]
        ÏƒË£ = [0  1; 
              1  0]
        Ïƒá¶» = [1  0; 
              0 -1]
        W_tnsr = zeros(Complex{Float64}, 3, 3, 2, 2)
        W_tnsr[1, 1, :, :] = id    
        W_tnsr[2, 1, :, :] = -Ïƒá¶»  
        W_tnsr[3, 1, :, :] = -g*ÏƒË£
        W_tnsr[3, 2, :, :] = Ïƒá¶»   
        W_tnsr[3, 3, :, :] = id   

        return MPO(W_tnsr, L)
    end
    H = H_TFIM(g, L)
    Ïˆ = randn(MPS{L, Complex{Float64}}, 100, 2)
    
    ÏˆÌƒ = compress(Ïˆ, left, Dcut=80)[1] # Note: no actual information is lost in this 
    # compression because of the small size of the chain

    @test              ÏˆÌƒ'ÏˆÌƒ â‰ˆ 1
    @test          Ïˆ'Ïˆ/Ïˆ'Ïˆ â‰ˆ ÏˆÌƒ'ÏˆÌƒ
    @test ((Ïˆ'*(H*Ïˆ))/Ïˆ'Ïˆ) â‰ˆ (ÏˆÌƒ' * (H * ÏˆÌƒ))/ÏˆÌƒ'ÏˆÌƒ
    @test ((Ïˆ'*(H*Ïˆ))/Ïˆ'Ïˆ) â‰ˆ (ÏˆÌƒ' * (H * Ïˆ))/ÏˆÌƒ'Ïˆ

    Ï•, Eâ‚€ = ground_state(Ïˆ, H, quiet=true)
    @test Ï•' * H * H * Ï• â‰ˆ (Ï•'*H*Ï•)^2
end

@testset &quot;Hubbard&quot; begin

    id = [1 0
          0 1]
    c  = [0 0
          1 0] #Anti commuting matrix
    c_up = c  âŠ— id
    c_dn = id âŠ— c
    idÂ²  = id âŠ— id
    n_up = c_up' * c_up
    n_dn = c_dn' * c_dn

    P_up = (idÂ² - 2c_up'*c_up) # Spin up parity operator
    P_dn = (idÂ² - 2c_dn'*c_dn) # Spin down parity operator

    function H_hub(U, Î¼, L)
        W_tnsr = zeros(Complex{Float64}, 6, 6, 4, 4)
        W_tnsr[1, 1, :, :] = idÂ²
        W_tnsr[2, 1, :, :] = c_up'
        W_tnsr[3, 1, :, :] = c_dn'
        W_tnsr[4, 1, :, :] = c_up
        W_tnsr[5, 1, :, :] = c_dn
        W_tnsr[6, 1, :, :] = U*(n_up * n_dn) - Î¼*(n_up + n_dn)
        W_tnsr[6, 2, :, :] =  c_up  * P_up  # Must multiply by the parity operator to get 
        W_tnsr[6, 3, :, :] =  c_dn  * P_dn  # correct off-site commutation relations!
        W_tnsr[6, 4, :, :] = -c_up' * P_up
        W_tnsr[6, 5, :, :] = -c_dn' * P_dn
        W_tnsr[6, 6, :, :] = idÂ²
        MPO(W_tnsr, L)
    end

    function solve_hub(U, Î¼, L; retfull=true, quiet=true)
        H = H_hub(U, Î¼, L)
        Ïˆ = randn(MPS{L, Complex{Float64}}, 100, 4)
        (Ï•, Eâ‚€), t, bytes = @timed ground_state(Ïˆ, H, Ïµ=1e-5, quiet=quiet)

        (Ï•=Ï•, Eâ‚€=Eâ‚€, H=H, t=t, Gbytes=bytes/1e9)
    end

    function Hub_ED(U, Î¼, L,)
        UÌ‚ = U*(n_up * n_dn) - Î¼*(n_up + n_dn)
        c_dg_up(i) = foldl(âŠ—, sparse.([i==j ? c_up' : idÂ² for j in 1:L]))
        cup(i)     = foldl(âŠ—, sparse.([i==j ? c_up  : idÂ² for j in 1:L]))
        c_dg_dn(i) = foldl(âŠ—, sparse.([i==j ? c_dn' : idÂ² for j in 1:L]))
        cdn(i)     = foldl(âŠ—, sparse.([i==j ? c_dn  : idÂ² for j in 1:L]))
        UÌ‚f(i)      = foldl(âŠ—, sparse.([i==j ? UÌ‚     : idÂ² for j in 1:L]))
        function c_dg_c(i) 
            out = c_dg_up(i)*cup(i+1) + c_dg_dn(i)*cdn(i+1)
            out + out'
        end
        H = -sum(c_dg_c, 1:(L-1)) + sum(UÌ‚f, 1:L)

        Î», Ï• = eigs(H, nev=1, which=:SR)
        (Ï•'H*Ï•)[]
    end

   
    U = 3.0; Î¼ = -1.0; L = 4
    H = H_hub(U, Î¼, L)

    Ï•, Eâ‚€ = solve_hub(U, Î¼, L, retfull=true, quiet=true)
    @test Ï•' * H * H * Ï• â‰ˆ (Ï•'*H*Ï•)^2  # Make sure energy is eigenvalue
    @test Ï•' * H * Ï• â‰ˆ Eâ‚€              # make sure eigenvalue matches one produced by alogrithm
    @test Ï•' * H * Ï• â‰ˆ Hub_ED(U, Î¼, L) # check against exact diagonalization
end

"><pre><span class="pl-k">using</span> Test, MatrixProductStates, SparseArrays, Arpack

<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>TFIM   <span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
    g <span class="pl-k">=</span> <span class="pl-c1">1.0</span>; L <span class="pl-k">=</span> <span class="pl-c1">7</span>

    <span class="pl-k">function</span> <span class="pl-en">H_TFIM</span>(g, L)
        id <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
              <span class="pl-c1">0</span>  <span class="pl-c1">1</span>]
        ÏƒË£ <span class="pl-k">=</span> [<span class="pl-c1">0</span>  <span class="pl-c1">1</span>; 
              <span class="pl-c1">1</span>  <span class="pl-c1">0</span>]
        Ïƒá¶» <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
              <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
        W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
        W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> id    
        W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>Ïƒá¶»  
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>g<span class="pl-k">*</span>ÏƒË£
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span> Ïƒá¶»   
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span> id   

        <span class="pl-k">return</span> <span class="pl-c1">MPO</span>(W_tnsr, L)
    <span class="pl-k">end</span>
    H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)
    Ïˆ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, <span class="pl-c1">100</span>, <span class="pl-c1">2</span>)
    
    ÏˆÌƒ <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, left, Dcut<span class="pl-k">=</span><span class="pl-c1">80</span>)[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> Note: no actual information is lost in this </span>
    <span class="pl-c"><span class="pl-c">#</span> compression because of the small size of the chain</span>

    <span class="pl-c1">@test</span>              ÏˆÌƒ<span class="pl-k">'</span>ÏˆÌƒ <span class="pl-k">â‰ˆ</span> <span class="pl-c1">1</span>
    <span class="pl-c1">@test</span>          Ïˆ<span class="pl-k">'</span>Ïˆ<span class="pl-k">/</span>Ïˆ<span class="pl-k">'</span>Ïˆ <span class="pl-k">â‰ˆ</span> ÏˆÌƒ<span class="pl-k">'</span>ÏˆÌƒ
    <span class="pl-c1">@test</span> ((Ïˆ<span class="pl-k">'</span><span class="pl-k">*</span>(H<span class="pl-k">*</span>Ïˆ))<span class="pl-k">/</span>Ïˆ<span class="pl-k">'</span>Ïˆ) <span class="pl-k">â‰ˆ</span> (ÏˆÌƒ<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> ÏˆÌƒ))<span class="pl-k">/</span>ÏˆÌƒ<span class="pl-k">'</span>ÏˆÌƒ
    <span class="pl-c1">@test</span> ((Ïˆ<span class="pl-k">'</span><span class="pl-k">*</span>(H<span class="pl-k">*</span>Ïˆ))<span class="pl-k">/</span>Ïˆ<span class="pl-k">'</span>Ïˆ) <span class="pl-k">â‰ˆ</span> (ÏˆÌƒ<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> Ïˆ))<span class="pl-k">/</span>ÏˆÌƒ<span class="pl-k">'</span>Ïˆ

    Ï•, Eâ‚€ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
    <span class="pl-c1">@test</span> Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï• <span class="pl-k">â‰ˆ</span> (Ï•<span class="pl-k">'</span><span class="pl-k">*</span>H<span class="pl-k">*</span>Ï•)<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-k">end</span>

<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>Hubbard<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>

    id <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span>
          <span class="pl-c1">0</span> <span class="pl-c1">1</span>]
    c  <span class="pl-k">=</span> [<span class="pl-c1">0</span> <span class="pl-c1">0</span>
          <span class="pl-c1">1</span> <span class="pl-c1">0</span>] <span class="pl-c"><span class="pl-c">#</span>Anti commuting matrix</span>
    c_up <span class="pl-k">=</span> c  âŠ— id
    c_dn <span class="pl-k">=</span> id âŠ— c
    idÂ²  <span class="pl-k">=</span> id âŠ— id
    n_up <span class="pl-k">=</span> c_up<span class="pl-k">'</span> <span class="pl-k">*</span> c_up
    n_dn <span class="pl-k">=</span> c_dn<span class="pl-k">'</span> <span class="pl-k">*</span> c_dn

    P_up <span class="pl-k">=</span> (idÂ² <span class="pl-k">-</span> <span class="pl-c1">2</span>c_up<span class="pl-k">'</span><span class="pl-k">*</span>c_up) <span class="pl-c"><span class="pl-c">#</span> Spin up parity operator</span>
    P_dn <span class="pl-k">=</span> (idÂ² <span class="pl-k">-</span> <span class="pl-c1">2</span>c_dn<span class="pl-k">'</span><span class="pl-k">*</span>c_dn) <span class="pl-c"><span class="pl-c">#</span> Spin down parity operator</span>

    <span class="pl-k">function</span> <span class="pl-en">H_hub</span>(U, Î¼, L)
        W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">6</span>, <span class="pl-c1">6</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>)
        W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> idÂ²
        W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_up<span class="pl-k">'</span>
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_dn<span class="pl-k">'</span>
        W_tnsr[<span class="pl-c1">4</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_up
        W_tnsr[<span class="pl-c1">5</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_dn
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> U<span class="pl-k">*</span>(n_up <span class="pl-k">*</span> n_dn) <span class="pl-k">-</span> Î¼<span class="pl-k">*</span>(n_up <span class="pl-k">+</span> n_dn)
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span>  c_up  <span class="pl-k">*</span> P_up  <span class="pl-c"><span class="pl-c">#</span> Must multiply by the parity operator to get </span>
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span>  c_dn  <span class="pl-k">*</span> P_dn  <span class="pl-c"><span class="pl-c">#</span> correct off-site commutation relations!</span>
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">4</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>c_up<span class="pl-k">'</span> <span class="pl-k">*</span> P_up
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">5</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>c_dn<span class="pl-k">'</span> <span class="pl-k">*</span> P_dn
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">6</span>, :, :] <span class="pl-k">=</span> idÂ²
        <span class="pl-c1">MPO</span>(W_tnsr, L)
    <span class="pl-k">end</span>

    <span class="pl-k">function</span> <span class="pl-en">solve_hub</span>(U, Î¼, L; retfull<span class="pl-k">=</span><span class="pl-c1">true</span>, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
        H <span class="pl-k">=</span> <span class="pl-c1">H_hub</span>(U, Î¼, L)
        Ïˆ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, <span class="pl-c1">100</span>, <span class="pl-c1">4</span>)
        (Ï•, Eâ‚€), t, bytes <span class="pl-k">=</span> <span class="pl-c1">@timed</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-5</span>, quiet<span class="pl-k">=</span>quiet)

        (Ï•<span class="pl-k">=</span>Ï•, Eâ‚€<span class="pl-k">=</span>Eâ‚€, H<span class="pl-k">=</span>H, t<span class="pl-k">=</span>t, Gbytes<span class="pl-k">=</span>bytes<span class="pl-k">/</span><span class="pl-c1">1e9</span>)
    <span class="pl-k">end</span>

    <span class="pl-k">function</span> <span class="pl-en">Hub_ED</span>(U, Î¼, L,)
        UÌ‚ <span class="pl-k">=</span> U<span class="pl-k">*</span>(n_up <span class="pl-k">*</span> n_dn) <span class="pl-k">-</span> Î¼<span class="pl-k">*</span>(n_up <span class="pl-k">+</span> n_dn)
        <span class="pl-en">c_dg_up</span>(i) <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_up<span class="pl-k">'</span> <span class="pl-k">:</span> idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">cup</span>(i)     <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_up  <span class="pl-k">:</span> idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">c_dg_dn</span>(i) <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_dn<span class="pl-k">'</span> <span class="pl-k">:</span> idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">cdn</span>(i)     <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_dn  <span class="pl-k">:</span> idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">UÌ‚f</span>(i)      <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> UÌ‚     <span class="pl-k">:</span> idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-k">function</span> <span class="pl-en">c_dg_c</span>(i) 
            out <span class="pl-k">=</span> <span class="pl-c1">c_dg_up</span>(i)<span class="pl-k">*</span><span class="pl-c1">cup</span>(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">c_dg_dn</span>(i)<span class="pl-k">*</span><span class="pl-c1">cdn</span>(i<span class="pl-k">+</span><span class="pl-c1">1</span>)
            out <span class="pl-k">+</span> out<span class="pl-k">'</span>
        <span class="pl-k">end</span>
        H <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">sum</span>(c_dg_c, <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">+</span> <span class="pl-c1">sum</span>(UÌ‚f, <span class="pl-c1">1</span><span class="pl-k">:</span>L)

        Î», Ï• <span class="pl-k">=</span> <span class="pl-c1">eigs</span>(H, nev<span class="pl-k">=</span><span class="pl-c1">1</span>, which<span class="pl-k">=</span><span class="pl-c1">:SR</span>)
        (Ï•<span class="pl-k">'</span>H<span class="pl-k">*</span>Ï•)[]
    <span class="pl-k">end</span>

   
    U <span class="pl-k">=</span> <span class="pl-c1">3.0</span>; Î¼ <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1.0</span>; L <span class="pl-k">=</span> <span class="pl-c1">4</span>
    H <span class="pl-k">=</span> <span class="pl-c1">H_hub</span>(U, Î¼, L)

    Ï•, Eâ‚€ <span class="pl-k">=</span> <span class="pl-c1">solve_hub</span>(U, Î¼, L, retfull<span class="pl-k">=</span><span class="pl-c1">true</span>, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
    <span class="pl-c1">@test</span> Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï• <span class="pl-k">â‰ˆ</span> (Ï•<span class="pl-k">'</span><span class="pl-k">*</span>H<span class="pl-k">*</span>Ï•)<span class="pl-k">^</span><span class="pl-c1">2</span>  <span class="pl-c"><span class="pl-c">#</span> Make sure energy is eigenvalue</span>
    <span class="pl-c1">@test</span> Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï• <span class="pl-k">â‰ˆ</span> Eâ‚€              <span class="pl-c"><span class="pl-c">#</span> make sure eigenvalue matches one produced by alogrithm</span>
    <span class="pl-c1">@test</span> Ï•<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï• <span class="pl-k">â‰ˆ</span> <span class="pl-c1">Hub_ED</span>(U, Î¼, L) <span class="pl-c"><span class="pl-c">#</span> check against exact diagonalization</span>
<span class="pl-k">end</span>
</pre></div>
</details>
<p></p>
</article></div>