<div id="readme" class="org" data-path="README.org"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-matrixproductstatesjl" class="anchor" aria-hidden="true" href="#matrixproductstatesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MatrixProductStates.jl</h1>
<p>This is a package-in-progress in which I am implementing the <a href="https://en.wikipedia.org/wiki/Density_matrix_renormalization_group" rel="nofollow">DMRG</a>
  algorithm over matrix product states as explained in Schollwöck’s <a href="https://www.sciencedirect.com/science/article/pii/S0003491610001752" rel="nofollow">The
  density-matrix renormalization group in the age of matrix product
  states</a>. A similar project has been undertaken in <a href="https://github.com/0/LatticeSweeper.jl">LatticeSweeper.jl</a>.</p>
<p>I’m not longer actively developthing this library, but I think it still has value as an educational resource for those wanting to learn DMRG.
  Julia made it possible for me to implement this package using syntax which is very close to the math written in the online literature.</p>
<p>To acquire this package, simply open a <code>julia</code> repl (obtained from <a href="https://julialang.org/downloads/" rel="nofollow">https://julialang.org/downloads/</a>) and type</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Pkg; Pkg.add(&quot;https://github.com/MasonProtter/MatrixProductStates.jl.git&quot;)
"><pre><span class="pl-k">using</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/MasonProtter/MatrixProductStates.jl.git<span class="pl-pds">"</span></span>)</pre></div>
<h2><a id="user-content-example-transverse-field-ising-model" class="anchor" aria-hidden="true" href="#example-transverse-field-ising-model"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: Transverse Field Ising Model</h2>
<details><summary>Click me!</summary>
<p>
</p><p>Suppose we didn’t realize the one dimensional transverse field Ising
  model was exactly solvable and we wanted to study it with DMRG.</p>
<p>The TFIM Hamiltonian is written</p>
<pre>H = - ∑ᵢ σᶻᵢσᶻᵢ₊₁ - ∑ᵢ g σˣᵢ 
</pre>
<p>which in MPO form can be written as</p>
<pre>H = W¹ W² W³... Wᴸ⁻¹ Wᴸ
                   [ 𝟙    𝟘    𝟘] [ 𝟙    𝟘    𝟘]     [ 𝟙    𝟘    𝟘] [ 𝟙  ]
  = [-gσˣ  σᶻ   𝟙] | -σᶻ  𝟘    𝟘| | -σᶻ  𝟘    𝟘| ... | -σᶻ  𝟘    𝟘| |-σᶻ |
                   [-gσˣ  σᶻ   𝟙] [-gσˣ  σᶻ   𝟙]     [-gσˣ  σᶻ  𝟙] [-gσˣ]
</pre>
<p>We can study this Hamiltonian using MatrixProductStates.jl as follows:</p>
<p>First, make a function for generating the Hamiltonian given a coupling strength <code>g = h/J</code> and a system length <code>L</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using MatrixProductStates

function H_TFIM(g, L)
    id = [1  0; 
          0  1]
    σˣ = [0  1; 
          1  0]
    σᶻ = [1  0; 
          0 -1]
    W_tnsr = zeros(Complex{Float64}, 3, 3, 2, 2)
    W_tnsr[1, 1, :, :] = id    
    W_tnsr[2, 1, :, :] = -σᶻ  
    W_tnsr[3, 1, :, :] = -g*σˣ
    W_tnsr[3, 2, :, :] = σᶻ   
    W_tnsr[3, 3, :, :] = id   

    return MPO(W_tnsr, L) # MPO will assume that W¹ = W_tnsr[end:end, :, :, :] and Wᴸ = W_tnsr[:, 1:1, :, :]
end
"><pre><span class="pl-k">using</span> MatrixProductStates

<span class="pl-k">function</span> <span class="pl-en">H_TFIM</span>(g, L)
    id <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
          <span class="pl-c1">0</span>  <span class="pl-c1">1</span>]
    σˣ <span class="pl-k">=</span> [<span class="pl-c1">0</span>  <span class="pl-c1">1</span>; 
          <span class="pl-c1">1</span>  <span class="pl-c1">0</span>]
    σᶻ <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
          <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
    W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
    W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> id    
    W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>σᶻ  
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>g<span class="pl-k">*</span>σˣ
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span> σᶻ   
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span> id   

    <span class="pl-k">return</span> <span class="pl-c1">MPO</span>(W_tnsr, L) <span class="pl-c"><span class="pl-c">#</span> MPO will assume that W¹ = W_tnsr[end:end, :, :, :] and Wᴸ = W_tnsr[:, 1:1, :, :]</span>
<span class="pl-k">end</span></pre></div>
<h3><a id="user-content-ground-state" class="anchor" aria-hidden="true" href="#ground-state"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Ground State</h3>
<p>Suppose we want to know the ground state of this system for
  <code>g=0.8</code> and <code>L=12</code> and we have no idea what the MPS form of the ground
  state looks like a-priori.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="g = 1.1; L = 12;

d    = 2;   # This is the local Hilbert space dimension for each site
Dcut = 100; # This is the maximum bond dimension we'll allow our matrix product state to take

H = H_TFIM(g, L)
ψ = randn(MPS{L, Complex{Float64}}, Dcut, d) # Generate a completely randomized matrix product state

ϕ, E₀ = ground_state(ψ, H, quiet=true) #Set quiet to false (the deault) to turn off notifications about the algorithm's progress
"><pre>g <span class="pl-k">=</span> <span class="pl-c1">1.1</span>; L <span class="pl-k">=</span> <span class="pl-c1">12</span>;

d    <span class="pl-k">=</span> <span class="pl-c1">2</span>;   <span class="pl-c"><span class="pl-c">#</span> This is the local Hilbert space dimension for each site</span>
Dcut <span class="pl-k">=</span> <span class="pl-c1">100</span>; <span class="pl-c"><span class="pl-c">#</span> This is the maximum bond dimension we'll allow our matrix product state to take</span>

H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)
ψ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, Dcut, d) <span class="pl-c"><span class="pl-c">#</span> Generate a completely randomized matrix product state</span>

ϕ, E₀ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(ψ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">#</span>Set quiet to false (the deault) to turn off notifications about the algorithm's progress</span></pre></div>
<p>We now have the ground state <code>ϕ</code>, and an estimate of it’s energy
  eigenvalue <code>E₀</code>!</p>
<p>Note that 12 sites can be easily studied with far less computational
  cost as an exact diagonalization, but I didn’t want to suggest doing
  something like <code>L=50</code> right off the bat since that took ~90 minutes on
  my machine.</p>
<p>We can make sure that this state’s energy matches our estimate:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; ϕ' * H * ϕ ≈ E₀ # computing ⟨ϕ|H|ϕ⟩
true
"><pre>julia<span class="pl-k">&gt;</span> ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ <span class="pl-k">≈</span> E₀ <span class="pl-c"><span class="pl-c">#</span> computing ⟨ϕ|H|ϕ⟩</span>
<span class="pl-c1">true</span></pre></div>
<p>and we can varify that it’s approximately an eigenstate:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; ϕ' * H * H * ϕ  ≈ (ϕ' * H * ϕ)^2 # computing ⟨ϕ| H^2 |ϕ⟩ ≈ (⟨ϕ|H|ϕ⟩)^2
true
"><pre>julia<span class="pl-k">&gt;</span> ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ  <span class="pl-k">≈</span> (ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> computing ⟨ϕ| H^2 |ϕ⟩ ≈ (⟨ϕ|H|ϕ⟩)^2</span>
<span class="pl-c1">true</span></pre></div>
<h3><a id="user-content-correlators" class="anchor" aria-hidden="true" href="#correlators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Correlators</h3>
<p>We can take advantage of the <code>two_point_correlator</code> function to study spin-spin correlations in the TFIM</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using UnicodePlots

σᶻ = [1 0 
      0 -1]

zz(i, j) = two_point_correlator(i=&gt;σᶻ, j=&gt;σᶻ, 12)

js = 2:12

zzs = [realize(ϕ'*zz(1, j)*ϕ) for j in js] #realize will convert complex numbers with a small imaginary part to real.

lineplot(js, zzs, canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, 
         ylabel=&quot;⟨σᶻ₁σᶻⱼ⟩&quot;, xlabel=&quot;lattice site j&quot;, title=&quot;Spin-Spin Correlation for g = $g&quot;)
"><pre><span class="pl-k">using</span> UnicodePlots

σᶻ <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span> 
      <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]

<span class="pl-en">zz</span>(i, j) <span class="pl-k">=</span> <span class="pl-c1">two_point_correlator</span>(i<span class="pl-k">=&gt;</span>σᶻ, j<span class="pl-k">=&gt;</span>σᶻ, <span class="pl-c1">12</span>)

js <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">12</span>

zzs <span class="pl-k">=</span> [<span class="pl-c1">realize</span>(ϕ<span class="pl-k">'</span><span class="pl-k">*</span><span class="pl-c1">zz</span>(<span class="pl-c1">1</span>, j)<span class="pl-k">*</span>ϕ) <span class="pl-k">for</span> j <span class="pl-k">in</span> js] <span class="pl-c"><span class="pl-c">#</span>realize will convert complex numbers with a small imaginary part to real.</span>

<span class="pl-c1">lineplot</span>(js, zzs, canvas<span class="pl-k">=</span>DotCanvas, ylim<span class="pl-k">=</span>[<span class="pl-c1">0</span>, <span class="pl-c1">1.01</span>], width<span class="pl-k">=</span><span class="pl-c1">80</span>, height<span class="pl-k">=</span><span class="pl-c1">30</span>, 
         ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>⟨σᶻ₁σᶻⱼ⟩<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>lattice site j<span class="pl-pds">"</span></span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Spin-Spin Correlation for g = <span class="pl-v">$g</span><span class="pl-pds">"</span></span>)</pre></div>
<pre>                                      Spin-Spin Correlation for g = 1.1
              ┌────────────────────────────────────────────────────────────────────────────────┐ 
         1.01 │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
⟨σᶻ₁σᶻⱼ⟩      │                                                                                │ 
              │                                                                                │ 
              │:                                                                               │ 
              │ '.                                                                             │ 
              │   '.                                                                           │ 
              │     '.                                                                         │ 
              │       '.                                                                       │ 
              │         ''.                                                                    │ 
              │            ''..                                                                │ 
              │                ''...                                                           │ 
              │                     ''....                                                     │ 
              │                           ''''....                                             │ 
              │                                   '''''.......                                 │ 
              │                                               '''''''.........                 │ 
              │                                                               '''''''''........│ 
            0 │                                                                                │ 
              └────────────────────────────────────────────────────────────────────────────────┘ 
              2                                                                               12
                                               lattice site j
</pre>
<p>which shows exponentially decaying correlations in the ground state,
  as expected for <code>g &gt; 1</code>. We can also redo our calculation in the
  ordered phase:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="g = 0.8;

H = H_TFIM(g, L)

ϕ, Eₒ = ground_state(ψ, H, quiet=true)

ordered_zzs = [realize(ϕ'*zz(1, j)*ϕ) for j in js]

lineplot(js, realize.(ordered_zzs), canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, 
         ylabel=&quot;⟨σᶻ₁σᶻⱼ⟩&quot;, xlabel=&quot;lattice site j&quot;, title=&quot;Spin-Spin Correlation for g = $g&quot;)
"><pre>g <span class="pl-k">=</span> <span class="pl-c1">0.8</span>;

H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)

ϕ, Eₒ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(ψ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)

ordered_zzs <span class="pl-k">=</span> [<span class="pl-c1">realize</span>(ϕ<span class="pl-k">'</span><span class="pl-k">*</span><span class="pl-c1">zz</span>(<span class="pl-c1">1</span>, j)<span class="pl-k">*</span>ϕ) <span class="pl-k">for</span> j <span class="pl-k">in</span> js]

<span class="pl-c1">lineplot</span>(js, <span class="pl-c1">realize</span>.(ordered_zzs), canvas<span class="pl-k">=</span>DotCanvas, ylim<span class="pl-k">=</span>[<span class="pl-c1">0</span>, <span class="pl-c1">1.01</span>], width<span class="pl-k">=</span><span class="pl-c1">80</span>, height<span class="pl-k">=</span><span class="pl-c1">30</span>, 
         ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>⟨σᶻ₁σᶻⱼ⟩<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>lattice site j<span class="pl-pds">"</span></span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Spin-Spin Correlation for g = <span class="pl-v">$g</span><span class="pl-pds">"</span></span>)</pre></div>
<pre>                                      Spin-Spin Correlation for g = 0.8
              ┌────────────────────────────────────────────────────────────────────────────────┐ 
         1.01 │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │.                                                                               │ 
              │ ''.                                                                            │ 
              │    ''..                                                                        │ 
              │        '''....                                                                 │ 
⟨σᶻ₁σᶻⱼ⟩      │               ''''''.........                                                  │ 
              │                              ''''''''''''...........                           │ 
              │                                                     '''''''......              │ 
              │                                                                  '''....       │ 
              │                                                                         '..    │ 
              │                                                                            ''..│ 
              │                                                                               '│ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
              │                                                                                │ 
            0 │                                                                                │ 
              └────────────────────────────────────────────────────────────────────────────────┘ 
              2                                                                               12
                                               lattice site j
</pre>
</details>
<p></p>
<h2><a id="user-content-source-code" class="anchor" aria-hidden="true" href="#source-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Source Code</h2>
<p>This readme is a literate document containing all of the source and test code for the package. Check it out, I think it’s surprisingly legible.
  The sections Matrix Product States, Matrix Product Operatiors, Compression and Iterative Ground State Search are based directly on the math
  written in Schollwöck’s review.</p>
<h3><a id="user-content-module-definition" class="anchor" aria-hidden="true" href="#module-definition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Module Definition</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="module MatrixProductStates

using LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack, Strided, SparseArrays
#using ProgressMeter

export *, /, ==, ≈, isequal, adjoint, getindex, randn
export MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
export ground_state, two_point_correlator, realize

include(&quot;utils.jl&quot;)
include(&quot;MPS.jl&quot;)
include(&quot;MPO.jl&quot;)
include(&quot;compression.jl&quot;)
include(&quot;contraction.jl&quot;)
include(&quot;groundstate.jl&quot;)
include(&quot;correlation.jl&quot;)
include(&quot;timeevolution.jl&quot;)

end
"><pre><span class="pl-k">module</span> MatrixProductStates

<span class="pl-k">using</span> LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack, Strided, SparseArrays
<span class="pl-c"><span class="pl-c">#</span>using ProgressMeter</span>

<span class="pl-k">export</span> <span class="pl-k">*</span>, <span class="pl-k">/</span>, <span class="pl-k">==</span>, <span class="pl-k">≈</span>, isequal, adjoint, getindex, randn
<span class="pl-k">export</span> MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
<span class="pl-k">export</span> ground_state, two_point_correlator, realize

<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>utils.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>MPS.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>MPO.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>compression.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>contraction.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>groundstate.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>correlation.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>timeevolution.jl<span class="pl-pds">"</span></span>)

<span class="pl-k">end</span></pre></div>
</details>
<p></p>
<h3><a id="user-content-utils" class="anchor" aria-hidden="true" href="#utils"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Utils</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="export ⊗, realize

abstract type Direction end

struct Left  &lt;: Direction end # Often useful to dispatch on direction an algorithm is going
struct Right &lt;: Direction end

const left  = Left()
const right = Right()

A ⊗ B = kron(A, B)

realize(x::Number) = error(&quot;Unrecognized numerical type&quot;)
realize(x::Real) = x
function realize(x::Complex; ϵ=1e-10)
    abs(imag(x)) &lt; ϵ || error(&quot;Non-zero imaginary component, $(imag(x))&quot;)
    real(x)
end

dg(M::Array{T, 4}) where {T} = permutedims(conj.(M), (2, 1, 3, 4))
dg(M::Array{T, 3}) where {T} = permutedims(conj.(M), (2, 1, 3))

not(x) = ~x

"><pre><span class="pl-k">export</span> ⊗, realize

<span class="pl-k">abstract type</span> Direction <span class="pl-k">end</span>

<span class="pl-k">struct</span> Left  <span class="pl-k">&lt;:</span> <span class="pl-c1">Direction</span> <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> Often useful to dispatch on direction an algorithm is going</span>
<span class="pl-k">struct</span> Right <span class="pl-k">&lt;:</span> <span class="pl-c1">Direction</span> <span class="pl-k">end</span>

<span class="pl-k">const</span> left  <span class="pl-k">=</span> <span class="pl-c1">Left</span>()
<span class="pl-k">const</span> right <span class="pl-k">=</span> <span class="pl-c1">Right</span>()

A ⊗ B <span class="pl-k">=</span> <span class="pl-c1">kron</span>(A, B)

<span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">=</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Unrecognized numerical type<span class="pl-pds">"</span></span>)
<span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Real</span>) <span class="pl-k">=</span> x
<span class="pl-k">function</span> <span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Complex</span>; ϵ<span class="pl-k">=</span><span class="pl-c1">1e-10</span>)
    <span class="pl-c1">abs</span>(<span class="pl-c1">imag</span>(x)) <span class="pl-k">&lt;</span> ϵ <span class="pl-k">||</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Non-zero imaginary component, <span class="pl-v">$(<span class="pl-c1">imag</span>(x))</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">real</span>(x)
<span class="pl-k">end</span>

<span class="pl-en">dg</span>(M<span class="pl-k">::</span><span class="pl-c1">Array{T, 4}</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(M), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>))
<span class="pl-en">dg</span>(M<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(M), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>))

<span class="pl-en">not</span>(x) <span class="pl-k">=</span> <span class="pl-k">~</span>x
</pre></div>
</details>
<p></p>
<h3><a id="user-content-matrix-product-states" class="anchor" aria-hidden="true" href="#matrix-product-states"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrix Product States</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="&quot;&quot;&quot;
    MPS{L, T&lt;:Number}

Matrix product state on L sites. 

The `i`th tensor in the state has indices `[aⁱ⁻¹, aⁱ, σⁱ]` where
`(aⁱ⁻¹, aⁱ)` are bond indices and `σⁱ` is the physical index.

A four site MPS would be diagrammatically represented

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     

Note that `a⁰` and `aᴸ` must be of dimension 1.
&quot;&quot;&quot;
struct MPS{L, T&lt;:Number} 
    tensors::Vector{Array{T,3}}
end

Base.isequal(ψ::MPS, ϕ::MPS)     = (isequal(ψ.tensors, ϕ.tensors))
Base.isapprox(ψ::MPS, ϕ::MPS)   = isapprox(ψ.tensors, ϕ.tensors)

Base.eltype(::Type{MPS{L, T}}) where {L, T} = T

Base.length(::MPS{L, T}) where {L, T} = L

Base.size(::MPS{L, T}) where {L, T} = (L,)
Base.getindex(ψ::MPS, i::Int) = getindex(ψ.tensors, i)

Base.:(*)(ψ::MPS{L, T}, x::Number) where {L, T} = MPS{L,T}(ψ.tensors .* x)
Base.:(*)(x::Number, ψ::MPS) = ψ * x
Base.:(/)(ψ::MPS{L,T}, x::Number) where {L, T} = MPS{L,T}(ψ.tensors ./ x)
Base.copy(ψ::MPS{L, T}) where {L, T} = MPS{L,T}(copy.(ψ.tensors))

function Base.randn(::Type{MPS{L, T}}, D::Int, d::Int) where {L, T}
    tensors = [randn(1, D, d), [randn(D, D, d) for _ in 2:(L-1)]..., randn(D, 1, d)]
    MPS{L, T}(tensors) |&gt; leftcanonical |&gt; rightcanonical
end

&quot;&quot;&quot;
    MPS(vs::Vector{Vector})
Create an `MPS` representing a product state (all bonds have dimension 1),
where each site is described by the corresponding element of `vs`.
&quot;&quot;&quot;
function MPS(vs::Vector{Vector{T}}) where {T}
    L = length(vs)

    tensrs = Vector{Array{T,3}}(undef, L)
    for i in 1:L
        tensrs[i] = reshape(copy(vs[i]), 1, 1, :)
    end

    MPS{L,T}(tensrs)
end

&quot;&quot;&quot;
    MPS(v::Vector, L)
Create an `MPS` for `L` sites representing a uniform product state (all bonds
have dimension 1), where each site is described by `v`.
&quot;&quot;&quot;
MPS(v::Vector, L) = MPS([v for _ in 1:L])

function Base.show(io::IO, ::MIME&quot;text/plain&quot;, ψ::MPS{L, T}) where {L, T}
    d = length(ψ.tensors[2][1, 1, :])
    bonddims = [size(ψ[i][:, :, 1]) for i in 1:L]
    println(io, &quot;Matrix product state on $L sites&quot;)
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(ψ::MPS{L, T}) where {L, T}
    d = length(ψ.tensors[2][1, 1, :])
    bonddims = [size(ψ[i][:, :, 1]) for i in 1:L]
    println(&quot;Matrix product state on $L sites&quot;)
    _show_mps_dims(L, d, bonddims)
end

function _show_mps_dims(io::IO, L, d, bonddims)
    println(io, &quot;  Physical dimension: $d&quot;)
    print(io, &quot;  Bond dimensions:   &quot;)
    if L &gt; 8
        for i in 1:8
            print(io, bonddims[i], &quot; × &quot;)
        end
        print(io, &quot; ... × &quot;, bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], &quot; × &quot;)
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, ψ::MPS{L, T}) where {L, T}
    print(io, &quot;MPS on $L sites&quot;)
end

"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS{L, T&lt;:Number}</span>
<span class="pl-s"></span>
<span class="pl-s">Matrix product state on L sites. </span>
<span class="pl-s"></span>
<span class="pl-s">The `i`th tensor in the state has indices `[aⁱ⁻¹, aⁱ, σⁱ]` where</span>
<span class="pl-s">`(aⁱ⁻¹, aⁱ)` are bond indices and `σⁱ` is the physical index.</span>
<span class="pl-s"></span>
<span class="pl-s">A four site MPS would be diagrammatically represented</span>
<span class="pl-s"></span>
<span class="pl-s">    σ¹          σ²          σ³          σ⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     </span>
<span class="pl-s"></span>
<span class="pl-s">Note that `a⁰` and `aᴸ` must be of dimension 1.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">struct</span> MPS{L, T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>} 
    tensors<span class="pl-k">::</span><span class="pl-c1">Vector{Array{T,3}}</span>
<span class="pl-k">end</span>

Base<span class="pl-k">.</span><span class="pl-en">isequal</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, ϕ<span class="pl-k">::</span><span class="pl-c1">MPS</span>)     <span class="pl-k">=</span> (<span class="pl-c1">isequal</span>(ψ<span class="pl-k">.</span>tensors, ϕ<span class="pl-k">.</span>tensors))
Base<span class="pl-k">.</span><span class="pl-en">isapprox</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, ϕ<span class="pl-k">::</span><span class="pl-c1">MPS</span>)   <span class="pl-k">=</span> <span class="pl-c1">isapprox</span>(ψ<span class="pl-k">.</span>tensors, ϕ<span class="pl-k">.</span>tensors)

Base<span class="pl-k">.</span><span class="pl-en">eltype</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> T

Base<span class="pl-k">.</span><span class="pl-en">length</span>(<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> L

Base<span class="pl-k">.</span><span class="pl-en">size</span>(<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> (L,)
Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, i<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(ψ<span class="pl-k">.</span>tensors, i)

Base.:(<span class="pl-k">*</span>)(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(ψ<span class="pl-k">.</span>tensors <span class="pl-k">.*</span> x)
Base.:(<span class="pl-k">*</span>)(x<span class="pl-k">::</span><span class="pl-c1">Number</span>, ψ<span class="pl-k">::</span><span class="pl-c1">MPS</span>) <span class="pl-k">=</span> ψ <span class="pl-k">*</span> x
Base.:(<span class="pl-k">/</span>)(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L,T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(ψ<span class="pl-k">.</span>tensors <span class="pl-k">./</span> x)
Base<span class="pl-k">.</span><span class="pl-en">copy</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(<span class="pl-c1">copy</span>.(ψ<span class="pl-k">.</span>tensors))

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">randn</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MPS{L, T}}</span>, D<span class="pl-k">::</span><span class="pl-c1">Int</span>, d<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> [<span class="pl-c1">randn</span>(<span class="pl-c1">1</span>, D, d), [<span class="pl-c1">randn</span>(D, D, d) <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, <span class="pl-c1">randn</span>(D, <span class="pl-c1">1</span>, d)]
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors) <span class="pl-k">|&gt;</span> leftcanonical <span class="pl-k">|&gt;</span> rightcanonical
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS(vs::Vector{Vector})</span>
<span class="pl-s">Create an `MPS` representing a product state (all bonds have dimension 1),</span>
<span class="pl-s">where each site is described by the corresponding element of `vs`.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">MPS</span>(vs<span class="pl-k">::</span><span class="pl-c1">Vector{Vector{T}}</span>) <span class="pl-k">where</span> {T}
    L <span class="pl-k">=</span> <span class="pl-c1">length</span>(vs)

    tensrs <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Array{T,3}}</span>(undef, L)
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        tensrs[i] <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">copy</span>(vs[i]), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :)
    <span class="pl-k">end</span>

    <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(tensrs)
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS(v::Vector, L)</span>
<span class="pl-s">Create an `MPS` for `L` sites representing a uniform product state (all bonds</span>
<span class="pl-s">have dimension 1), where each site is described by `v`.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-en">MPS</span>(v<span class="pl-k">::</span><span class="pl-c1">Vector</span>, L) <span class="pl-k">=</span> <span class="pl-c1">MPS</span>([v <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L])

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(ψ<span class="pl-k">.</span>tensors[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(ψ[i][:, :, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(ψ<span class="pl-k">.</span>tensors[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(ψ[i][:, :, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_show_mps_dims</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, L, d, bonddims)
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Physical dimension: <span class="pl-v">$d</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Bond dimensions:   <span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> L <span class="pl-k">&gt;</span> <span class="pl-c1">8</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">8</span>
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> × <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span> ... × <span class="pl-pds">"</span></span>, bonddims[L])
    <span class="pl-k">else</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> × <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, bonddims[L])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>MPS on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
</pre></div>
<details><summary>Adjoint MPS</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function Base.adjoint(ψ::MPS{L, T}) where {L,T}
    Adjoint{T, MPS{L, T}}(ψ)
end

function Base.show(io::IO, ::MIME&quot;text/plain&quot;, ψ::Adjoint{T, MPS{L, T}}) where {L, T}
    d = length(ψ.parent[2][1, 1, :])
    bonddims = reverse([reverse(size(ψ.parent[i][:, :, 1])) for i in 1:L])
    println(io, &quot;Adjoint matrix product state on $L sites&quot;)
    _show_mps_dims(io, L, d, bonddims)
end

function Base.show(io::IO, ψ::Adjoint{T, MPS{L, T}}) where {L, T}
    print(io, &quot;Adjoint MPO on $L sites&quot;)t
end

Base.size(::Adjoint{T, MPS{L, T}}) where {L, T} = (1, L)

function Base.getindex(ψ::Adjoint{T, MPS{L, T}}, args...) where {L, T}
    out = getindex(reverse(ψ.parent.tensors), args...)
    permutedims(conj.(out), (2, 1, 3))
end

adjoint_tensors(ψ::MPS) = reverse(conj.(permutedims.(ψ.tensors, [(2, 1, 3)])))
"><pre><span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">adjoint</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L,T}
    <span class="pl-c1">Adjoint</span><span class="pl-c1">{T, MPS{L, T}}</span>(ψ)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, ψ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(ψ<span class="pl-k">.</span>parent[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> <span class="pl-c1">reverse</span>([<span class="pl-c1">reverse</span>(<span class="pl-c1">size</span>(ψ<span class="pl-k">.</span>parent[i][:, :, <span class="pl-c1">1</span>])) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L])
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Adjoint matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, ψ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Adjoint MPO on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)t
<span class="pl-k">end</span>

Base<span class="pl-k">.</span><span class="pl-en">size</span>(<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> (<span class="pl-c1">1</span>, L)

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(ψ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>, args<span class="pl-k">...</span>) <span class="pl-k">where</span> {L, T}
    out <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(<span class="pl-c1">reverse</span>(ψ<span class="pl-k">.</span>parent<span class="pl-k">.</span>tensors), args<span class="pl-k">...</span>)
    <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(out), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>))
<span class="pl-k">end</span>

<span class="pl-en">adjoint_tensors</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS</span>) <span class="pl-k">=</span> <span class="pl-c1">reverse</span>(<span class="pl-c1">conj</span>.(<span class="pl-c1">permutedims</span>.(ψ<span class="pl-k">.</span>tensors, [(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>)])))</pre></div>
<p></p>
</details>
<details><summary>MPS Contraction</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
&quot;&quot;&quot;
    Base.:(*)(ψ′::Adjoint{T, MPS{L, T}}, ϕ::MPS{L, T}) where {L, T}
representing
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•       
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•
&quot;&quot;&quot;
function Base.:(*)(ψ′::Adjoint{T, MPS{L, T}}, ϕ::MPS{L, T}) where {L, T}
    ψ = ψ′.parent

    M   = ϕ.tensors[1]
    M̃dg = dg(ψ.tensors[1])
    
    @tensor cont[b₁, a₁] := M̃dg[b₁, 1, σ₁] * M[1, a₁, σ₁]
    
    for i in 2:L-1
        M   = ϕ.tensors[i]
        M̃dg = dg(ψ.tensors[i])

        @tensor cont[bᵢ, aᵢ] := M̃dg[bᵢ, bᵢ₋₁, σᵢ] * cont[bᵢ₋₁, aᵢ₋₁] * M[aᵢ₋₁, aᵢ, σᵢ]
    end
    M   = ϕ.tensors[L]
    M̃dg = dg(ψ.tensors[L])
    
    @tensor M̃dg[1, bᴸ⁻¹, σᴸ] * cont[bᴸ⁻¹, aᴸ⁻¹] * M[aᴸ⁻¹, 1, σᴸ]
end

"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(ψ′::Adjoint{T, MPS{L, T}}, ϕ::MPS{L, T}) where {L, T}</span>
<span class="pl-s">representing</span>
<span class="pl-s">    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•       </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴</span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(ψ′<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>, ϕ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    ψ <span class="pl-k">=</span> ψ′<span class="pl-k">.</span>parent

    M   <span class="pl-k">=</span> ϕ<span class="pl-k">.</span>tensors[<span class="pl-c1">1</span>]
    M̃dg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(ψ<span class="pl-k">.</span>tensors[<span class="pl-c1">1</span>])
    
    <span class="pl-c1">@tensor</span> cont[b₁, a₁] <span class="pl-k">:=</span> M̃dg[b₁, <span class="pl-c1">1</span>, σ₁] <span class="pl-k">*</span> M[<span class="pl-c1">1</span>, a₁, σ₁]
    
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>L<span class="pl-k">-</span><span class="pl-c1">1</span>
        M   <span class="pl-k">=</span> ϕ<span class="pl-k">.</span>tensors[i]
        M̃dg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(ψ<span class="pl-k">.</span>tensors[i])

        <span class="pl-c1">@tensor</span> cont[bᵢ, aᵢ] <span class="pl-k">:=</span> M̃dg[bᵢ, bᵢ₋₁, σᵢ] <span class="pl-k">*</span> cont[bᵢ₋₁, aᵢ₋₁] <span class="pl-k">*</span> M[aᵢ₋₁, aᵢ, σᵢ]
    <span class="pl-k">end</span>
    M   <span class="pl-k">=</span> ϕ<span class="pl-k">.</span>tensors[L]
    M̃dg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(ψ<span class="pl-k">.</span>tensors[L])
    
    <span class="pl-c1">@tensor</span> M̃dg[<span class="pl-c1">1</span>, bᴸ⁻¹, σᴸ] <span class="pl-k">*</span> cont[bᴸ⁻¹, aᴸ⁻¹] <span class="pl-k">*</span> M[aᴸ⁻¹, <span class="pl-c1">1</span>, σᴸ]
<span class="pl-k">end</span>
</pre></div>
<p></p>
</details>
<p></p>
</details>
<h3><a id="user-content-matrix-product-operators" class="anchor" aria-hidden="true" href="#matrix-product-operators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrix Product Operators</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="&quot;&quot;&quot;
    MPO{L, T&lt;:Number}

Matrix product operator on L sites. The `i`th tensor in the operator
has indices `[aⁱ⁻¹, aⁱ, σⁱ, σ′ⁱ]` where `(σⁱ, σ′ⁱ)` are the physical
indices and `(aⁱ⁻¹, aⁱ)` are bond indices.

A four site MPS would be diagrammatically represented

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴


Note that `a⁰` and `aᴸ` must be of dimension 1.
&quot;&quot;&quot;
struct MPO{L, T&lt;:Number}
    tensors::Vector{Array{T,4}}
end


&quot;&quot;&quot;
    MPO(W::Array{T,4}, L)
Create an `MPO` for `L` sites with all interior sites containing the tensor
`W`. The tensor is assumed to have the usual matrix-of-operators structure,
with the first two indices being the bond (matrix) dimension and the last two
indices being the physical (operator) dimension. The first and last sites only
use the last row and first column of `W`, respectively.

For example, the MPO form of the Hamiltonian for the TFIM is
constructed as with coupling `g` and length `L` is constructed as
follows:

    id = [1 0
          0 1]

    σᶻ = [1  0 
          0 -1]

    σˣ = [0 1
          1 0]

    σʸ = [0  -im
          im   0]

    W = zeros(3, 3, 2, 2)
    W[1, 1, :, :] = id
    W[2, 1, :, :] = σᶻ
    W[3, 1, :, :] = -g*σˣ
    W[3, 2, :, :] = -σᶻ
    W[3, 3, :, :] = id

returning 
 
    Ĥ::MPO = Ŵ¹ Ŵ² Ŵ³ ⋅⋅⋅ Ŵᴸ⁻¹ Wᴸ
&quot;&quot;&quot;
function MPO(W::Array{T,4}, L) where {T}
    L &gt;= 2 || throw(DomainError(L, &quot;At least 2 sites.&quot;))

    tensors = Vector{Array{T,4}}(undef, L)
    
    tensors[1] = W[end:end, :, :, :] # Row vector.
    for i in 2:(L-1)
        tensors[i] = W # Matrix
    end
    tensors[L] = W[:, 1:1, :, :] # Column vector.

    MPO{L,T}(tensors)
end

Base.:(==)(O::MPO, U::MPO) = O.tensors == U.tensors
Base.:(≈)(O::MPO, U::MPO)  = O.tensors ≈ U.tensors
Base.getindex(O::MPO, args...) = getindex(O.tensors, args...)

function Base.show(io::IO, ::MIME&quot;text/plain&quot;, O::MPO{L, T}) where {L, T}
    d = length(O[2][1, 1, 1, :])
    bonddims = [size(O[i][:, :, 1, 1]) for i in 1:L]
    println(io, &quot;Matrix product Operator on $L sites&quot;)
    _show_mpo_dims(io, L, d, bonddims)
end

function _show_mpo_dims(io::IO, L, d, bonddims)
    println(io, &quot;  Physical dimension: $d&quot;)
    print(io, &quot;  Bond dimensions:   &quot;)
    if L &gt; 8
        for i in 1:8
            print(io, bonddims[i], &quot; × &quot;)
        end
        print(io, &quot; ... × &quot;, bonddims[L])
    else
        for i in 1:(L-1)
            print(io, bonddims[i], &quot; × &quot;)
        end
        print(io, bonddims[L])
    end
end

function Base.show(io::IO, O::MPO{L, T}) where {L, T}
    print(io, &quot;MPO on $L sites&quot;)
end
"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPO{L, T&lt;:Number}</span>
<span class="pl-s"></span>
<span class="pl-s">Matrix product operator on L sites. The `i`th tensor in the operator</span>
<span class="pl-s">has indices `[aⁱ⁻¹, aⁱ, σⁱ, σ′ⁱ]` where `(σⁱ, σ′ⁱ)` are the physical</span>
<span class="pl-s">indices and `(aⁱ⁻¹, aⁱ)` are bond indices.</span>
<span class="pl-s"></span>
<span class="pl-s">A four site MPS would be diagrammatically represented</span>
<span class="pl-s"></span>
<span class="pl-s">    σ¹          σ²          σ³          σ⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴</span>
<span class="pl-s"></span>
<span class="pl-s"></span>
<span class="pl-s">Note that `a⁰` and `aᴸ` must be of dimension 1.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">struct</span> MPO{L, T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>}
    tensors<span class="pl-k">::</span><span class="pl-c1">Vector{Array{T,4}}</span>
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPO(W::Array{T,4}, L)</span>
<span class="pl-s">Create an `MPO` for `L` sites with all interior sites containing the tensor</span>
<span class="pl-s">`W`. The tensor is assumed to have the usual matrix-of-operators structure,</span>
<span class="pl-s">with the first two indices being the bond (matrix) dimension and the last two</span>
<span class="pl-s">indices being the physical (operator) dimension. The first and last sites only</span>
<span class="pl-s">use the last row and first column of `W`, respectively.</span>
<span class="pl-s"></span>
<span class="pl-s">For example, the MPO form of the Hamiltonian for the TFIM is</span>
<span class="pl-s">constructed as with coupling `g` and length `L` is constructed as</span>
<span class="pl-s">follows:</span>
<span class="pl-s"></span>
<span class="pl-s">    id = [1 0</span>
<span class="pl-s">          0 1]</span>
<span class="pl-s"></span>
<span class="pl-s">    σᶻ = [1  0 </span>
<span class="pl-s">          0 -1]</span>
<span class="pl-s"></span>
<span class="pl-s">    σˣ = [0 1</span>
<span class="pl-s">          1 0]</span>
<span class="pl-s"></span>
<span class="pl-s">    σʸ = [0  -im</span>
<span class="pl-s">          im   0]</span>
<span class="pl-s"></span>
<span class="pl-s">    W = zeros(3, 3, 2, 2)</span>
<span class="pl-s">    W[1, 1, :, :] = id</span>
<span class="pl-s">    W[2, 1, :, :] = σᶻ</span>
<span class="pl-s">    W[3, 1, :, :] = -g*σˣ</span>
<span class="pl-s">    W[3, 2, :, :] = -σᶻ</span>
<span class="pl-s">    W[3, 3, :, :] = id</span>
<span class="pl-s"></span>
<span class="pl-s">returning </span>
<span class="pl-s"> </span>
<span class="pl-s">    Ĥ::MPO = Ŵ¹ Ŵ² Ŵ³ ⋅⋅⋅ Ŵᴸ⁻¹ Wᴸ</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">MPO</span>(W<span class="pl-k">::</span><span class="pl-c1">Array{T,4}</span>, L) <span class="pl-k">where</span> {T}
    L <span class="pl-k">&gt;=</span> <span class="pl-c1">2</span> <span class="pl-k">||</span> <span class="pl-c1">throw</span>(<span class="pl-c1">DomainError</span>(L, <span class="pl-s"><span class="pl-pds">"</span>At least 2 sites.<span class="pl-pds">"</span></span>))

    tensors <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Array{T,4}}</span>(undef, L)
    
    tensors[<span class="pl-c1">1</span>] <span class="pl-k">=</span> W[<span class="pl-c1">end</span><span class="pl-k">:</span><span class="pl-c1">end</span>, :, :, :] <span class="pl-c"><span class="pl-c">#</span> Row vector.</span>
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
        tensors[i] <span class="pl-k">=</span> W <span class="pl-c"><span class="pl-c">#</span> Matrix</span>
    <span class="pl-k">end</span>
    tensors[L] <span class="pl-k">=</span> W[:, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, :, :] <span class="pl-c"><span class="pl-c">#</span> Column vector.</span>

    <span class="pl-c1">MPO</span><span class="pl-c1">{L,T}</span>(tensors)
<span class="pl-k">end</span>

Base.:(<span class="pl-k">==</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, U<span class="pl-k">::</span><span class="pl-c1">MPO</span>) <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors <span class="pl-k">==</span> U<span class="pl-k">.</span>tensors
Base.:(<span class="pl-k">≈</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, U<span class="pl-k">::</span><span class="pl-c1">MPO</span>)  <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors <span class="pl-k">≈</span> U<span class="pl-k">.</span>tensors
Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, args<span class="pl-k">...</span>) <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(O<span class="pl-k">.</span>tensors, args<span class="pl-k">...</span>)

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(O[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(O[i][:, :, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Matrix product Operator on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mpo_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_show_mpo_dims</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, L, d, bonddims)
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Physical dimension: <span class="pl-v">$d</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Bond dimensions:   <span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> L <span class="pl-k">&gt;</span> <span class="pl-c1">8</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">8</span>
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> × <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span> ... × <span class="pl-pds">"</span></span>, bonddims[L])
    <span class="pl-k">else</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> × <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, bonddims[L])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>MPO on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span></pre></div>
<details><summary>MPO Contraction</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="&quot;&quot;&quot;
    Base.:(*)(O::MPO, ψ::MPS)
representing

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     
&quot;&quot;&quot;
function Base.:(*)(O::MPO{L, T}, ψ::MPS{L, T}) where {L, T}
    tensors = Array{T,3}[]
    for i in 1:L
        W = O.tensors[i]
        M = ψ.tensors[i]

        @reduce N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] :=  sum(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] * M[aᵢ₋₁, aᵢ, σ′ᵢ]
        
        push!(tensors, N)
    end
    MPS{L, T}(tensors)
end


&quot;&quot;&quot;
    Base.:(*)(O1::MPO, O2::MPO)
representing

    σ¹          σ²          σ³          σ⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     
    |           |           |           | 
    σ′′¹        σ′′²        σ′′³        σ′′⁴
    σ′′¹        σ′′²        σ′′³        σ′′⁴
    |           |           |           | 
    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--• 
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴    
&quot;&quot;&quot;
function Base.:(*)(O1::MPO{L, T}, O2::MPO{L, T}) where {L, T}
    tensors = Array{T,4}[]
    for i in 1:L
        W1 = O1.tensors[i]
        W2 = O2.tensors[i]

        @reduce V[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ, σ′ᵢ] :=  sum(σ′′ᵢ) W1[bᵢ₋₁, bᵢ, σᵢ, σ′′ᵢ] * W2[aᵢ₋₁, aᵢ, σ′′ᵢ, σ′ᵢ]
        
        push!(tensors, V)
    end
    MPO{L, T}(tensors)
end

&quot;&quot;&quot;
    Base.:(*)(ψ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}
representing

    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•       
    |           |           |           | 
    σ′¹         σ′²         σ′³         σ′⁴
    σ′¹         σ′²         σ′³         σ′⁴
    |           |           |           | 
    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•
    |           |           |           | 
    σ¹          σ²          σ³          σ⁴ 
&quot;&quot;&quot;
function Base.:(*)(ψ′::Adjoint{T,MPS{L,T}}, O::MPO{L, T}) where {L,T}
    ψ = ψ′.parent
    tensors = Array{T,3}[]
    Ws = dg.(reverse(O.tensors))
    for i in 1:L
        W = Ws[i]
        M = ψ.tensors[i]

        @reduce N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] :=  sum(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] * M[aᵢ₋₁, aᵢ, σ′ᵢ]
        push!(tensors, N)
    end
    adjoint(MPS{L, T}(tensors))
end
"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(O::MPO, ψ::MPS)</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    σ¹          σ²          σ³          σ⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴</span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•     </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">3</span>}[]
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors[i]
        M <span class="pl-k">=</span> ψ<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] <span class="pl-k">*</span> M[aᵢ₋₁, aᵢ, σ′ᵢ]
        
        <span class="pl-c1">push!</span>(tensors, N)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(O1::MPO, O2::MPO)</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    σ¹          σ²          σ³          σ⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    σ′′¹        σ′′²        σ′′³        σ′′⁴</span>
<span class="pl-s">    σ′′¹        σ′′²        σ′′³        σ′′⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--• </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴    </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(O1<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, O2<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">4</span>}[]
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W1 <span class="pl-k">=</span> O1<span class="pl-k">.</span>tensors[i]
        W2 <span class="pl-k">=</span> O2<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> V[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ, σ′ᵢ] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(σ′′ᵢ) W1[bᵢ₋₁, bᵢ, σᵢ, σ′′ᵢ] <span class="pl-k">*</span> W2[aᵢ₋₁, aᵢ, σ′′ᵢ, σ′ᵢ]
        
        <span class="pl-c1">push!</span>(tensors, V)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPO</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(ψ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    •--(a¹ a¹)--•--(a² a²)--•--(a³ a³)--•       </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴</span>
<span class="pl-s">    σ′¹         σ′²         σ′³         σ′⁴</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    •--(b¹ b¹)--•--(b² b²)--•--(b³ b³)--•</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    σ¹          σ²          σ³          σ⁴ </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(ψ′<span class="pl-k">::</span><span class="pl-c1">Adjoint{T,MPS{L,T}}</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L,T}
    ψ <span class="pl-k">=</span> ψ′<span class="pl-k">.</span>parent
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">3</span>}[]
    Ws <span class="pl-k">=</span> <span class="pl-c1">dg</span>.(<span class="pl-c1">reverse</span>(O<span class="pl-k">.</span>tensors))
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W <span class="pl-k">=</span> Ws[i]
        M <span class="pl-k">=</span> ψ<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> N[(bᵢ₋₁, aᵢ₋₁), (bᵢ, aᵢ), σᵢ] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(σ′ᵢ) W[bᵢ₋₁, bᵢ, σᵢ, σ′ᵢ] <span class="pl-k">*</span> M[aᵢ₋₁, aᵢ, σ′ᵢ]
        <span class="pl-c1">push!</span>(tensors, N)
    <span class="pl-k">end</span>
    <span class="pl-c1">adjoint</span>(<span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors))
<span class="pl-k">end</span></pre></div>
<p></p>
</details>
<p></p>
</details>
<h3><a id="user-content-compression" class="anchor" aria-hidden="true" href="#compression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Compression</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="

function compress(ψ::MPS{L, T}, to_the::Right; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    B = ψ[1]
    d = length(B[1, 1, :])
    
    @cast Bm[(σ¹, a⁰), a¹] |= B[a⁰, a¹, σ¹]
    U, S, V = psvd(Bm, rank=Dcut)
    #S = S/√sum(S .^ 2)

    @cast A[a⁰, a¹, σ¹] |= U[(σ¹, a⁰), a¹] (σ¹:d)
    push!(tensors, A)
    
    for i ∈ 2:L
        B = ψ[i]
        d = length(B[1, 1, :])

        @tensor M[aⁱ⁻¹, aⁱ, σⁱ] := (Diagonal(S)*V')[aⁱ⁻¹, aⁱ⁻¹′] * B[aⁱ⁻¹′, aⁱ, σⁱ]
        @cast   Mm[(σⁱ, aⁱ⁻¹), aⁱ] |= M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/√sum(S .^ 2)

        @cast A[aⁱ⁻¹, aⁱ, σⁱ] |= U[(σⁱ, aⁱ⁻¹), aⁱ] (σⁱ:d)
        push!(tensors, A)
    end
    MPS{L, T}(tensors), Left()
end

leftcanonical(ψ) = compress(ψ, right)[1]

function compress(ψ::MPS{L, T}, to_the::Left; Dcut::Int=typemax(Int)) where {L, T}
    tensors = Array{T, 3}[]
    
    A = ψ[L]
    d = length(A[1, 1, :])
    @cast Am[aᴸ⁻¹, (σᴸ, aᴸ)] |= A[aᴸ⁻¹, aᴸ, σᴸ]
    
    U, S, V = psvd(Am, rank=Dcut)
    #S = S/√sum(S .^ 2)    

    @cast B[aᴸ⁻¹, aᴸ, σᴸ] |= V'[aᴸ⁻¹, (σᴸ, aᴸ)] (σᴸ:d)
    push!(tensors, B)
    
    for i ∈ (L-1):-1:1
        A = ψ[i]
        d = length(A[1, 1, :])
        @tensor M[aⁱ⁻¹, aⁱ, σⁱ]    := A[aⁱ⁻¹, aⁱ′, σⁱ] * (U * Diagonal(S))[aⁱ′, aⁱ]
        @cast   Mm[aⁱ⁻¹, (σⁱ, aⁱ)] |= M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V = psvd(Mm, rank=Dcut)
        #S = S/√sum(S .^ 2)

        @cast B[aⁱ⁻¹, aⁱ, σⁱ] |= V'[aⁱ⁻¹, (σⁱ, aⁱ)] (σⁱ:d)
        push!(tensors, B)
    end
    MPS{L, T}(reverse(tensors)), Right()
end

rightcanonical(ψ) = compress(ψ, left)[1]

compress(ψ; Dcut) = compress(ψ, left, Dcut=Dcut)[1]

"><pre><span class="pl-k">function</span> <span class="pl-en">compress</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, to_the<span class="pl-k">::</span><span class="pl-c1">Right</span>; Dcut<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span><span class="pl-c1">typemax</span>(Int)) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    
    B <span class="pl-k">=</span> ψ[<span class="pl-c1">1</span>]
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(B[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    
    <span class="pl-c1">@cast</span> Bm[(σ¹, a⁰), a¹] <span class="pl-k">|=</span> B[a⁰, a¹, σ¹]
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Bm, rank<span class="pl-k">=</span>Dcut)
    <span class="pl-c"><span class="pl-c">#</span>S = S/√sum(S .^ 2)</span>

    <span class="pl-c1">@cast</span> A[a⁰, a¹, σ¹] <span class="pl-k">|=</span> U[(σ¹, a⁰), a¹] (σ¹<span class="pl-c1">:d</span>)
    <span class="pl-c1">push!</span>(tensors, A)
    
    <span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">2</span><span class="pl-k">:</span>L
        B <span class="pl-k">=</span> ψ[i]
        d <span class="pl-k">=</span> <span class="pl-c1">length</span>(B[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])

        <span class="pl-c1">@tensor</span> M[aⁱ⁻¹, aⁱ, σⁱ] <span class="pl-k">:=</span> (<span class="pl-c1">Diagonal</span>(S)<span class="pl-k">*</span>V<span class="pl-k">'</span>)[aⁱ⁻¹, aⁱ⁻¹′] <span class="pl-k">*</span> B[aⁱ⁻¹′, aⁱ, σⁱ]
        <span class="pl-c1">@cast</span>   Mm[(σⁱ, aⁱ⁻¹), aⁱ] <span class="pl-k">|=</span> M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Mm, rank<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>S = S/√sum(S .^ 2)</span>

        <span class="pl-c1">@cast</span> A[aⁱ⁻¹, aⁱ, σⁱ] <span class="pl-k">|=</span> U[(σⁱ, aⁱ⁻¹), aⁱ] (σⁱ<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, A)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors), <span class="pl-c1">Left</span>()
<span class="pl-k">end</span>

<span class="pl-en">leftcanonical</span>(ψ) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(ψ, right)[<span class="pl-c1">1</span>]

<span class="pl-k">function</span> <span class="pl-en">compress</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, to_the<span class="pl-k">::</span><span class="pl-c1">Left</span>; Dcut<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span><span class="pl-c1">typemax</span>(Int)) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    
    A <span class="pl-k">=</span> ψ[L]
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(A[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    <span class="pl-c1">@cast</span> Am[aᴸ⁻¹, (σᴸ, aᴸ)] <span class="pl-k">|=</span> A[aᴸ⁻¹, aᴸ, σᴸ]
    
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Am, rank<span class="pl-k">=</span>Dcut)
    <span class="pl-c"><span class="pl-c">#</span>S = S/√sum(S .^ 2)    </span>

    <span class="pl-c1">@cast</span> B[aᴸ⁻¹, aᴸ, σᴸ] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aᴸ⁻¹, (σᴸ, aᴸ)] (σᴸ<span class="pl-c1">:d</span>)
    <span class="pl-c1">push!</span>(tensors, B)
    
    <span class="pl-k">for</span> i <span class="pl-k">∈</span> (L<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>
        A <span class="pl-k">=</span> ψ[i]
        d <span class="pl-k">=</span> <span class="pl-c1">length</span>(A[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
        <span class="pl-c1">@tensor</span> M[aⁱ⁻¹, aⁱ, σⁱ]    <span class="pl-k">:=</span> A[aⁱ⁻¹, aⁱ′, σⁱ] <span class="pl-k">*</span> (U <span class="pl-k">*</span> <span class="pl-c1">Diagonal</span>(S))[aⁱ′, aⁱ]
        <span class="pl-c1">@cast</span>   Mm[aⁱ⁻¹, (σⁱ, aⁱ)] <span class="pl-k">|=</span> M[aⁱ⁻¹, aⁱ, σⁱ]
        
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Mm, rank<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>S = S/√sum(S .^ 2)</span>

        <span class="pl-c1">@cast</span> B[aⁱ⁻¹, aⁱ, σⁱ] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aⁱ⁻¹, (σⁱ, aⁱ)] (σⁱ<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, B)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(<span class="pl-c1">reverse</span>(tensors)), <span class="pl-c1">Right</span>()
<span class="pl-k">end</span>

<span class="pl-en">rightcanonical</span>(ψ) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(ψ, left)[<span class="pl-c1">1</span>]

<span class="pl-en">compress</span>(ψ; Dcut) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(ψ, left, Dcut<span class="pl-k">=</span>Dcut)[<span class="pl-c1">1</span>]
</pre></div>
<p></p>
</details>
<h3><a id="user-content-iterative-ground-state-search" class="anchor" aria-hidden="true" href="#iterative-ground-state-search"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Iterative Ground State Search</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
function R_exprs(ψ::MPS{L, T}, H::MPO{L, T}) where {L, T}
    R_exs = Array{T, 3}[]
    R_ex = ones(T, 1, 1, 1)
    for l in L:-1:2
        R_ex = iterate_R_ex(ψ[l], H[l], R_ex) 
        push!(R_exs, R_ex)
    end
    reverse(R_exs)
end

# function preallocate_hs(ψ::MPS{L, T}) where {L, T}
#     h_tnsrs = map(ψ.tensors) do M
#         Dˡ⁻¹, Dˡ, d = size(M)
#         Array{T, 6}(undef, d, Dˡ⁻¹, Dˡ, d, Dˡ⁻¹, Dˡ)
#     end
# end


function sweep!(::Right, ψ::MPS{L, T}, H::MPO{L, T}, R_exs) where {L, T}
    L_exs = Array{T, 3}[]
    L_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    for l in 1:(L-1)
        W = H[l]
        
        E, A, SVp = eigenproblem(right, ψ[l], L_ex, W, R_exs[l])
        ψ.tensors[l] = A

        L_ex = iterate_L_ex(A, W, L_ex)
        push!(L_exs, L_ex)

        Bp1 = ψ.tensors[l+1]
        @tensor Mp1[sⁱ⁻¹, aⁱ, σⁱ] := SVp[sⁱ⁻¹, aⁱ⁻¹] * Bp1[aⁱ⁻¹, aⁱ, σⁱ]
        ψ.tensors[l+1] = Mp1
    end
    L_exs, E
end

function sweep!(::Left, ψ::MPS{L, T}, H::MPO{L, T}, L_exs) where {L, T}
    R_exs = Array{T, 3}[]
    R_ex  = ones(T, 1, 1, 1)
    E = zero(T)
    for l in L:-1:2
        W = H[l]

        E, US, B = eigenproblem(left, ψ[l], L_exs[l-1], W, R_ex)
        ψ.tensors[l] = B

        R_ex = iterate_R_ex(B, W, R_ex) 
        push!(R_exs, R_ex)

        Am1 = ψ.tensors[l-1]
        @tensor Mm1[aˡ⁻², sˡ⁻¹, σˡ⁻¹] :=  Am1[aˡ⁻², aˡ⁻¹′, σˡ⁻¹] * US[aˡ⁻¹′, sˡ⁻¹]
        ψ.tensors[l-1] = Mm1
    end
    R_exs, E
end

function h_matrix(L_ex::Array{T,3}, W::Array{T,4}, R_ex::Array{T,3}) where {T}
    @tensor h[σˡ, aˡ⁻¹, aˡ, σˡ′, aˡ⁻¹′, aˡ′] := L_ex[bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′] * W[bˡ⁻¹, bˡ, σˡ, σˡ′] * R_ex[bˡ, aˡ, aˡ′]
    @cast h[(σˡ, aˡ⁻¹, aˡ), (σˡ′, aˡ⁻¹′, aˡ′)] := h[σˡ, aˡ⁻¹, aˡ, σˡ′, aˡ⁻¹′, aˡ′]
end

function eigenproblem(dir::Direction, M::Array{T, 3}, L_ex::Array{T, 3}, W::Array{T, 4}, R_ex::Array{T, 3}) where {T}
    @cast v[(σˡ, aˡ⁻¹, aˡ)] |= M[aˡ⁻¹, aˡ, σˡ]
    
    h = h_matrix(L_ex, W, R_ex)
    λ, Φ = eigs(h, v0=v, nev=1, which=:SR)
    E  = λ[1]::T 
    v⁰ = (Φ[:,1])::Vector{T}

    (E, split_tensor(dir, v⁰, size(M))...)
end

function split_tensor(::Right, v⁰::Vector, (Dˡ⁻¹, Dˡ, d))
    @cast Mm[(σˡ, aˡ⁻¹), aˡ] := v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ, σˡ:d)
    U, S, V = svd(Mm)
    @cast A[aˡ⁻¹, aˡ, σˡ] |= U[(σˡ, aˡ⁻¹), aˡ] (σˡ:d, aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ)
    A, Diagonal(S)*V'
end

function split_tensor(::Left, v⁰::Vector, (Dˡ⁻¹, Dˡ, d))
    @cast Mm[aˡ⁻¹, (σˡ, aˡ)] |= v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹:Dˡ⁻¹, aˡ:Dˡ, σˡ:d)
    U, S, V = svd(Mm)
    @cast B[aˡ⁻¹, aˡ, σˡ] |= V'[aˡ⁻¹, (σˡ, aˡ)] (σˡ:d)
    U*Diagonal(S), B
end

function iterate_R_ex(B, W, R_ex) where {T}
    @tensoropt R_ex′[bⁱ⁻¹, aⁱ⁻¹, aⁱ⁻¹′] := (conj.(B))[aⁱ⁻¹,aⁱ,σⁱ] * W[bⁱ⁻¹,bⁱ,σⁱ,σⁱ′] * B[aⁱ⁻¹′,aⁱ′,σⁱ′] * R_ex[bⁱ,aⁱ,aⁱ′]
end

function iterate_L_ex(A, W, L_ex) where {T}
    @tensoropt L_ex′[bˡ, aˡ, aˡ′] := L_ex[bˡ⁻¹,aˡ⁻¹,aˡ⁻¹′] * (conj.(A))[aˡ⁻¹,aˡ,σˡ] * W[bˡ⁻¹,bˡ,σˡ,σˡ′] * A[aˡ⁻¹′,aˡ′,σˡ′]
end


&quot;&quot;&quot;
    ground_state(ψ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, ϵ=1e-8) where {L, T}

Perform the finite system density matrix renormalization group
algorithm. First this will build up the R expressions, then do right
and left sweeps until either
 1) The state converges to an eigenstate `ϕ` such that
    ϕ' * H * H * ϕ ≈ (ϕ' * H * ϕ) 
to the requested tolerance `ϵ`
 2) The energy eigenvalue stops changing (possible signaling the algorithm is 
stuck in a local minimum)
 3) The number of full (right and left) sweeps exceeds `maxiter`. 

Setting `quiet=true` will suppress notifications about the algorithm's
progress but *not* warnings due to non-convergence.
&quot;&quot;&quot;
function ground_state(ψ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, ϵ=1e-8) where {L, T}
    ϕ = ψ |&gt; copy

    quiet || println(&quot;Computing R expressions&quot;)
    R_exs = R_exprs(ψ, H)

    converged = false
    count     = 0
    E₀ = zero(T)
    enable_cache(maxsize=5*10^9)
    while not(converged)
        quiet || println(&quot;Performing right sweep&quot;)
        L_exs, E₀′ = sweep!(right, ϕ, H, R_exs)

        quiet || println(&quot;Performing left sweep&quot;)
        R_exs, E₀  = sweep!(left,  ϕ, H, L_exs)

        count += 1
        if iseigenstate(ϕ, H, ϵ=ϵ)
            quiet || println(&quot;Converged in $count iterations&quot;)
            converged = true
        elseif count &gt; 1 &amp;&amp; E₀ ≈ E₀′
                @warn &quot;&quot;&quot;
Energy eigenvalue converged but state is not an eigenstate.
Consider either lowering your requested tolerance or 
implementing a warm-up algorithm to avoid local minima.
&quot;&quot;&quot;
            break
        elseif count &gt;= maxiter
            @warn &quot;Did not converge in $maxiter iterations&quot;
            break
        end
    end
    clear_cache()
    ϕ, E₀
end


function iseigenstate(ψ::MPS, H::MPO; ϵ=1e-8)
    ϕ = rightcanonical(ψ)
    isapprox(ϕ' * (H * H * ϕ), (ϕ' * (H * ϕ))^2, rtol=ϵ)
end

"><pre><span class="pl-k">function</span> <span class="pl-en">R_exprs</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    R_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    R_ex <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> L<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>
        R_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_R_ex</span>(ψ[l], H[l], R_ex) 
        <span class="pl-c1">push!</span>(R_exs, R_ex)
    <span class="pl-k">end</span>
    <span class="pl-c1">reverse</span>(R_exs)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> function preallocate_hs(ψ::MPS{L, T}) where {L, T}</span>
<span class="pl-c"><span class="pl-c">#</span>     h_tnsrs = map(ψ.tensors) do M</span>
<span class="pl-c"><span class="pl-c">#</span>         Dˡ⁻¹, Dˡ, d = size(M)</span>
<span class="pl-c"><span class="pl-c">#</span>         Array{T, 6}(undef, d, Dˡ⁻¹, Dˡ, d, Dˡ⁻¹, Dˡ)</span>
<span class="pl-c"><span class="pl-c">#</span>     end</span>
<span class="pl-c"><span class="pl-c">#</span> end</span>


<span class="pl-k">function</span> <span class="pl-en">sweep!</span>(<span class="pl-k">::</span><span class="pl-c1">Right</span>, ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, R_exs) <span class="pl-k">where</span> {L, T}
    L_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    L_ex  <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    E <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
        W <span class="pl-k">=</span> H[l]
        
        E, A, SVp <span class="pl-k">=</span> <span class="pl-c1">eigenproblem</span>(right, ψ[l], L_ex, W, R_exs[l])
        ψ<span class="pl-k">.</span>tensors[l] <span class="pl-k">=</span> A

        L_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_L_ex</span>(A, W, L_ex)
        <span class="pl-c1">push!</span>(L_exs, L_ex)

        Bp1 <span class="pl-k">=</span> ψ<span class="pl-k">.</span>tensors[l<span class="pl-k">+</span><span class="pl-c1">1</span>]
        <span class="pl-c1">@tensor</span> Mp1[sⁱ⁻¹, aⁱ, σⁱ] <span class="pl-k">:=</span> SVp[sⁱ⁻¹, aⁱ⁻¹] <span class="pl-k">*</span> Bp1[aⁱ⁻¹, aⁱ, σⁱ]
        ψ<span class="pl-k">.</span>tensors[l<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> Mp1
    <span class="pl-k">end</span>
    L_exs, E
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">sweep!</span>(<span class="pl-k">::</span><span class="pl-c1">Left</span>, ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, L_exs) <span class="pl-k">where</span> {L, T}
    R_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    R_ex  <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    E <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> L<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>
        W <span class="pl-k">=</span> H[l]

        E, US, B <span class="pl-k">=</span> <span class="pl-c1">eigenproblem</span>(left, ψ[l], L_exs[l<span class="pl-k">-</span><span class="pl-c1">1</span>], W, R_ex)
        ψ<span class="pl-k">.</span>tensors[l] <span class="pl-k">=</span> B

        R_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_R_ex</span>(B, W, R_ex) 
        <span class="pl-c1">push!</span>(R_exs, R_ex)

        Am1 <span class="pl-k">=</span> ψ<span class="pl-k">.</span>tensors[l<span class="pl-k">-</span><span class="pl-c1">1</span>]
        <span class="pl-c1">@tensor</span> Mm1[aˡ⁻², sˡ⁻¹, σˡ⁻¹] <span class="pl-k">:=</span>  Am1[aˡ⁻², aˡ⁻¹′, σˡ⁻¹] <span class="pl-k">*</span> US[aˡ⁻¹′, sˡ⁻¹]
        ψ<span class="pl-k">.</span>tensors[l<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> Mm1
    <span class="pl-k">end</span>
    R_exs, E
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">h_matrix</span>(L_ex<span class="pl-k">::</span><span class="pl-c1">Array{T,3}</span>, W<span class="pl-k">::</span><span class="pl-c1">Array{T,4}</span>, R_ex<span class="pl-k">::</span><span class="pl-c1">Array{T,3}</span>) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensor</span> h[σˡ, aˡ⁻¹, aˡ, σˡ′, aˡ⁻¹′, aˡ′] <span class="pl-k">:=</span> L_ex[bˡ⁻¹, aˡ⁻¹, aˡ⁻¹′] <span class="pl-k">*</span> W[bˡ⁻¹, bˡ, σˡ, σˡ′] <span class="pl-k">*</span> R_ex[bˡ, aˡ, aˡ′]
    <span class="pl-c1">@cast</span> h[(σˡ, aˡ⁻¹, aˡ), (σˡ′, aˡ⁻¹′, aˡ′)] <span class="pl-k">:=</span> h[σˡ, aˡ⁻¹, aˡ, σˡ′, aˡ⁻¹′, aˡ′]
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">eigenproblem</span>(dir<span class="pl-k">::</span><span class="pl-c1">Direction</span>, M<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>, L_ex<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>, W<span class="pl-k">::</span><span class="pl-c1">Array{T, 4}</span>, R_ex<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@cast</span> v[(σˡ, aˡ⁻¹, aˡ)] <span class="pl-k">|=</span> M[aˡ⁻¹, aˡ, σˡ]
    
    h <span class="pl-k">=</span> <span class="pl-c1">h_matrix</span>(L_ex, W, R_ex)
    λ, Φ <span class="pl-k">=</span> <span class="pl-c1">eigs</span>(h, v0<span class="pl-k">=</span>v, nev<span class="pl-k">=</span><span class="pl-c1">1</span>, which<span class="pl-k">=</span><span class="pl-c1">:SR</span>)
    E  <span class="pl-k">=</span> λ[<span class="pl-c1">1</span>]<span class="pl-k">::</span><span class="pl-c1">T</span> 
    v⁰ <span class="pl-k">=</span> (Φ[:,<span class="pl-c1">1</span>])<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>

    (E, <span class="pl-c1">split_tensor</span>(dir, v⁰, <span class="pl-c1">size</span>(M))<span class="pl-k">...</span>)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">split_tensor</span>(<span class="pl-k">::</span><span class="pl-c1">Right</span>, v⁰<span class="pl-k">::</span><span class="pl-c1">Vector</span>, (Dˡ⁻¹, Dˡ, d))
    <span class="pl-c1">@cast</span> Mm[(σˡ, aˡ⁻¹), aˡ] <span class="pl-k">:=</span> v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹<span class="pl-c1">:Dˡ⁻¹</span>, aˡ<span class="pl-c1">:Dˡ</span>, σˡ<span class="pl-c1">:d</span>)
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(Mm)
    <span class="pl-c1">@cast</span> A[aˡ⁻¹, aˡ, σˡ] <span class="pl-k">|=</span> U[(σˡ, aˡ⁻¹), aˡ] (σˡ<span class="pl-c1">:d</span>, aˡ⁻¹<span class="pl-c1">:Dˡ⁻¹</span>, aˡ<span class="pl-c1">:Dˡ</span>)
    A, <span class="pl-c1">Diagonal</span>(S)<span class="pl-k">*</span>V<span class="pl-k">'</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">split_tensor</span>(<span class="pl-k">::</span><span class="pl-c1">Left</span>, v⁰<span class="pl-k">::</span><span class="pl-c1">Vector</span>, (Dˡ⁻¹, Dˡ, d))
    <span class="pl-c1">@cast</span> Mm[aˡ⁻¹, (σˡ, aˡ)] <span class="pl-k">|=</span> v⁰[(σˡ, aˡ⁻¹, aˡ)] (aˡ⁻¹<span class="pl-c1">:Dˡ⁻¹</span>, aˡ<span class="pl-c1">:Dˡ</span>, σˡ<span class="pl-c1">:d</span>)
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(Mm)
    <span class="pl-c1">@cast</span> B[aˡ⁻¹, aˡ, σˡ] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aˡ⁻¹, (σˡ, aˡ)] (σˡ<span class="pl-c1">:d</span>)
    U<span class="pl-k">*</span><span class="pl-c1">Diagonal</span>(S), B
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">iterate_R_ex</span>(B, W, R_ex) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensoropt</span> R_ex′[bⁱ⁻¹, aⁱ⁻¹, aⁱ⁻¹′] <span class="pl-k">:=</span> (<span class="pl-c1">conj</span>.(B))[aⁱ⁻¹,aⁱ,σⁱ] <span class="pl-k">*</span> W[bⁱ⁻¹,bⁱ,σⁱ,σⁱ′] <span class="pl-k">*</span> B[aⁱ⁻¹′,aⁱ′,σⁱ′] <span class="pl-k">*</span> R_ex[bⁱ,aⁱ,aⁱ′]
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">iterate_L_ex</span>(A, W, L_ex) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensoropt</span> L_ex′[bˡ, aˡ, aˡ′] <span class="pl-k">:=</span> L_ex[bˡ⁻¹,aˡ⁻¹,aˡ⁻¹′] <span class="pl-k">*</span> (<span class="pl-c1">conj</span>.(A))[aˡ⁻¹,aˡ,σˡ] <span class="pl-k">*</span> W[bˡ⁻¹,bˡ,σˡ,σˡ′] <span class="pl-k">*</span> A[aˡ⁻¹′,aˡ′,σˡ′]
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    ground_state(ψ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, ϵ=1e-8) where {L, T}</span>
<span class="pl-s"></span>
<span class="pl-s">Perform the finite system density matrix renormalization group</span>
<span class="pl-s">algorithm. First this will build up the R expressions, then do right</span>
<span class="pl-s">and left sweeps until either</span>
<span class="pl-s"> 1) The state converges to an eigenstate `ϕ` such that</span>
<span class="pl-s">    ϕ' * H * H * ϕ ≈ (ϕ' * H * ϕ) </span>
<span class="pl-s">to the requested tolerance `ϵ`</span>
<span class="pl-s"> 2) The energy eigenvalue stops changing (possible signaling the algorithm is </span>
<span class="pl-s">stuck in a local minimum)</span>
<span class="pl-s"> 3) The number of full (right and left) sweeps exceeds `maxiter`. </span>
<span class="pl-s"></span>
<span class="pl-s">Setting `quiet=true` will suppress notifications about the algorithm's</span>
<span class="pl-s">progress but *not* warnings due to non-convergence.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">ground_state</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>; maxiter<span class="pl-k">=</span><span class="pl-c1">10</span>, quiet<span class="pl-k">=</span><span class="pl-c1">false</span>, ϵ<span class="pl-k">=</span><span class="pl-c1">1e-8</span>) <span class="pl-k">where</span> {L, T}
    ϕ <span class="pl-k">=</span> ψ <span class="pl-k">|&gt;</span> copy

    quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computing R expressions<span class="pl-pds">"</span></span>)
    R_exs <span class="pl-k">=</span> <span class="pl-c1">R_exprs</span>(ψ, H)

    converged <span class="pl-k">=</span> <span class="pl-c1">false</span>
    count     <span class="pl-k">=</span> <span class="pl-c1">0</span>
    E₀ <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-c1">enable_cache</span>(maxsize<span class="pl-k">=</span><span class="pl-c1">5</span><span class="pl-k">*</span><span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">9</span>)
    <span class="pl-k">while</span> <span class="pl-c1">not</span>(converged)
        quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Performing right sweep<span class="pl-pds">"</span></span>)
        L_exs, E₀′ <span class="pl-k">=</span> <span class="pl-c1">sweep!</span>(right, ϕ, H, R_exs)

        quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Performing left sweep<span class="pl-pds">"</span></span>)
        R_exs, E₀  <span class="pl-k">=</span> <span class="pl-c1">sweep!</span>(left,  ϕ, H, L_exs)

        count <span class="pl-k">+=</span> <span class="pl-c1">1</span>
        <span class="pl-k">if</span> <span class="pl-c1">iseigenstate</span>(ϕ, H, ϵ<span class="pl-k">=</span>ϵ)
            quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Converged in <span class="pl-v">$count</span> iterations<span class="pl-pds">"</span></span>)
            converged <span class="pl-k">=</span> <span class="pl-c1">true</span>
        <span class="pl-k">elseif</span> count <span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> E₀ <span class="pl-k">≈</span> E₀′
                <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">Energy eigenvalue converged but state is not an eigenstate.</span>
<span class="pl-s">Consider either lowering your requested tolerance or </span>
<span class="pl-s">implementing a warm-up algorithm to avoid local minima.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
            <span class="pl-k">break</span>
        <span class="pl-k">elseif</span> count <span class="pl-k">&gt;=</span> maxiter
            <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"</span>Did not converge in <span class="pl-v">$maxiter</span> iterations<span class="pl-pds">"</span></span>
            <span class="pl-k">break</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-c1">clear_cache</span>()
    ϕ, E₀
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">iseigenstate</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO</span>; ϵ<span class="pl-k">=</span><span class="pl-c1">1e-8</span>)
    ϕ <span class="pl-k">=</span> <span class="pl-c1">rightcanonical</span>(ψ)
    <span class="pl-c1">isapprox</span>(ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ), (ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> ϕ))<span class="pl-k">^</span><span class="pl-c1">2</span>, rtol<span class="pl-k">=</span>ϵ)
<span class="pl-k">end</span>
</pre></div>
</details>
<p></p>
<h3><a id="user-content-correlation-functions" class="anchor" aria-hidden="true" href="#correlation-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Correlation Functions</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
&quot;&quot;&quot;
    two_point_correlator((i, op_i)::Pair{Int, Matrix}, (j, op_j)::Pair{Int, Matrix}, L)

Create an MPO on `L` sites (with bond dimension 1) representing identity operators everywhere except
sites `i` and `j` where `op_i` and `op_j` are inserted instead. ie.

    𝟙 ⊗ 𝟙 ⊗ ... ⊗ op_i ⊗ 𝟙 ⊗ ... ⊗ op_j ⊗ 𝟙 ⊗ ... ⊗ 𝟙

example: spin-spin correlation function

we can construct ⟨σᶻᵢσᶻⱼ⟩ on a 12 site lattice as
    σᶻ = [1 0; 0 -1]
    two_point_correlator(i=&gt;σᶻ, j=&gt;σᶻ, 12)  
&quot;&quot;&quot;
function two_point_correlator((i, op_i), (j, op_j), L)
    d = size(op_i)[1]
    @assert (size(op_i) == (d, d)) &amp;&amp; (size(op_j) == (d, d))
    @assert i in 1:L
    @assert j in 1:L
    id = diagm(0 =&gt; ones(Complex{Float64}, d))

    op_i_tnsr = reshape(convert(Matrix{Complex{Float64}}, op_i), 1, 1, d, d) 
    op_j_tnsr = reshape(convert(Matrix{Complex{Float64}}, op_j), 1, 1, d, d)
    id_tnsr   = reshape(id, 1, 1, d, d)

    tensors = map(1:L) do l
        O_tnsr = (l == i ? op_i_tnsr : 
                  l == j ? op_j_tnsr : 
                  id_tnsr)
    end 
    MPO{L,Complex{Float64}}(tensors)
end




"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    two_point_correlator((i, op_i)::Pair{Int, Matrix}, (j, op_j)::Pair{Int, Matrix}, L)</span>
<span class="pl-s"></span>
<span class="pl-s">Create an MPO on `L` sites (with bond dimension 1) representing identity operators everywhere except</span>
<span class="pl-s">sites `i` and `j` where `op_i` and `op_j` are inserted instead. ie.</span>
<span class="pl-s"></span>
<span class="pl-s">    𝟙 ⊗ 𝟙 ⊗ ... ⊗ op_i ⊗ 𝟙 ⊗ ... ⊗ op_j ⊗ 𝟙 ⊗ ... ⊗ 𝟙</span>
<span class="pl-s"></span>
<span class="pl-s">example: spin-spin correlation function</span>
<span class="pl-s"></span>
<span class="pl-s">we can construct ⟨σᶻᵢσᶻⱼ⟩ on a 12 site lattice as</span>
<span class="pl-s">    σᶻ = [1 0; 0 -1]</span>
<span class="pl-s">    two_point_correlator(i=&gt;σᶻ, j=&gt;σᶻ, 12)  </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">two_point_correlator</span>((i, op_i), (j, op_j), L)
    d <span class="pl-k">=</span> <span class="pl-c1">size</span>(op_i)[<span class="pl-c1">1</span>]
    <span class="pl-c1">@assert</span> (<span class="pl-c1">size</span>(op_i) <span class="pl-k">==</span> (d, d)) <span class="pl-k">&amp;&amp;</span> (<span class="pl-c1">size</span>(op_j) <span class="pl-k">==</span> (d, d))
    <span class="pl-c1">@assert</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
    <span class="pl-c1">@assert</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
    id <span class="pl-k">=</span> <span class="pl-c1">diagm</span>(<span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">ones</span>(Complex{Float64}, d))

    op_i_tnsr <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">convert</span>(Matrix{Complex{Float64}}, op_i), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d) 
    op_j_tnsr <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">convert</span>(Matrix{Complex{Float64}}, op_j), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d)
    id_tnsr   <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(id, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d)

    tensors <span class="pl-k">=</span> <span class="pl-c1">map</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>L) <span class="pl-k">do</span> l
        O_tnsr <span class="pl-k">=</span> (l <span class="pl-k">==</span> i <span class="pl-k">?</span> op_i_tnsr <span class="pl-k">:</span> 
                  l <span class="pl-k">==</span> j <span class="pl-k">?</span> op_j_tnsr <span class="pl-k">:</span> 
                  id_tnsr)
    <span class="pl-k">end</span> 
    <span class="pl-c1">MPO</span><span class="pl-c1">{L,Complex{Float64}}</span>(tensors)
<span class="pl-k">end</span>



</pre></div>
</details>
<p></p>
<h3><a id="user-content-imaginary-time-evolution" class="anchor" aria-hidden="true" href="#imaginary-time-evolution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Imaginary Time Evolution</h3>
<p>I don’t think this works!</p>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
# Fixme! this does not appear to find ground states!

function _MPO_handed_time_evolver(hs::Vector{Matrix{T}}, τ, L, d) where {T}
    tensors = Array{T, 4}[]
    for h in hs
        O = exp(-τ*h)
        @cast P[(σⁱ, σⁱ′), (σⁱ⁺¹, σⁱ⁺¹′)] |= O[(σⁱ, σⁱ⁺¹), (σⁱ′, σⁱ⁺¹′)] (σⁱ:d, σⁱ′:d)
        U, S, V = svd(P)

        @cast U[1, k, σⁱ, σⁱ′]     := U[(σⁱ, σⁱ′), k] * √(S[k])      (σⁱ:d)
        @cast Ū[k, 1, σⁱ⁺¹, σⁱ⁺¹′] := √(S[k]) * V'[k, (σⁱ⁺¹, σⁱ⁺¹′)] (σⁱ⁺¹:d)
        push!(tensors, U, Ū)
    end
    MPO{L, T}(tensors)
end

function MPO_time_evolvers(h1::Matrix, hi::Matrix, hL::Matrix, τ, L, d)
    if iseven(L)
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]...]
        even_hs = [[hi for i in 2:2:(L-1)]..., hL]
    else
        odd_hs  = [h1, [hi for _ in 3:2:(L-1)]..., hL]
        even_hs = [hi for i in 2:2:(L-1)]
    end
    
    Uodd  = _MPO_handed_time_evolver(odd_hs, τ, L, d)
    Ueven = _MPO_handed_time_evolver(even_hs, τ, L, d)
    Uodd, Ueven
end

function imag_time_evolution(ψ::MPS{L, T}, h1::Matrix{T}, hi::Matrix{T}, hL::Matrix{T}, 
                             β, N, Dcut) where {L, T}
    @warn &quot;This probably still doesn't work!&quot;
    τ = β/N
    d = length(ψ[1][1, 1, :])
    ϕ = ψ  # Ground state guess
    dir = left
    Uodd, Ueven = MPO_time_evolvers(h1, hi, hL, τ, L, d)
    for _ in 1:N
        ϕ1, dir = compress(Uodd  * ϕ,  dir, Dcut=Dcut)
        ϕ,  dir = compress(Ueven * ϕ1, dir, Dcut=Dcut)
        #ϕ,  dir = compress(Uodd  * ϕ2, dir, Dcut=Dcut)
    end
    ϕ
end
"><pre><span class="pl-c"><span class="pl-c">#</span> Fixme! this does not appear to find ground states!</span>

<span class="pl-k">function</span> <span class="pl-en">_MPO_handed_time_evolver</span>(hs<span class="pl-k">::</span><span class="pl-c1">Vector{Matrix{T}}</span>, τ, L, d) <span class="pl-k">where</span> {T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">4</span>}[]
    <span class="pl-k">for</span> h <span class="pl-k">in</span> hs
        O <span class="pl-k">=</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span>τ<span class="pl-k">*</span>h)
        <span class="pl-c1">@cast</span> P[(σⁱ, σⁱ′), (σⁱ⁺¹, σⁱ⁺¹′)] <span class="pl-k">|=</span> O[(σⁱ, σⁱ⁺¹), (σⁱ′, σⁱ⁺¹′)] (σⁱ<span class="pl-c1">:d</span>, σⁱ′<span class="pl-k">:</span>d)
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(P)

        <span class="pl-c1">@cast</span> U[<span class="pl-c1">1</span>, k, σⁱ, σⁱ′]     <span class="pl-k">:=</span> U[(σⁱ, σⁱ′), k] <span class="pl-k">*</span> <span class="pl-k">√</span>(S[k])      (σⁱ<span class="pl-c1">:d</span>)
        <span class="pl-c1">@cast</span> Ū[k, <span class="pl-c1">1</span>, σⁱ⁺¹, σⁱ⁺¹′] <span class="pl-k">:=</span> <span class="pl-k">√</span>(S[k]) <span class="pl-k">*</span> V<span class="pl-k">'</span>[k, (σⁱ⁺¹, σⁱ⁺¹′)] (σⁱ⁺¹<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, U, Ū)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPO</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">MPO_time_evolvers</span>(h1<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, hi<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, hL<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, τ, L, d)
    <span class="pl-k">if</span> <span class="pl-c1">iseven</span>(L)
        odd_hs  <span class="pl-k">=</span> [h1, [hi <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>]
        even_hs <span class="pl-k">=</span> [[hi <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, hL]
    <span class="pl-k">else</span>
        odd_hs  <span class="pl-k">=</span> [h1, [hi <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, hL]
        even_hs <span class="pl-k">=</span> [hi <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]
    <span class="pl-k">end</span>
    
    Uodd  <span class="pl-k">=</span> <span class="pl-c1">_MPO_handed_time_evolver</span>(odd_hs, τ, L, d)
    Ueven <span class="pl-k">=</span> <span class="pl-c1">_MPO_handed_time_evolver</span>(even_hs, τ, L, d)
    Uodd, Ueven
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">imag_time_evolution</span>(ψ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, h1<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, hi<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, hL<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, 
                             β, N, Dcut) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"</span>This probably still doesn't work!<span class="pl-pds">"</span></span>
    τ <span class="pl-k">=</span> β<span class="pl-k">/</span>N
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(ψ[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    ϕ <span class="pl-k">=</span> ψ  <span class="pl-c"><span class="pl-c">#</span> Ground state guess</span>
    dir <span class="pl-k">=</span> left
    Uodd, Ueven <span class="pl-k">=</span> <span class="pl-c1">MPO_time_evolvers</span>(h1, hi, hL, τ, L, d)
    <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        ϕ1, dir <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Uodd  <span class="pl-k">*</span> ϕ,  dir, Dcut<span class="pl-k">=</span>Dcut)
        ϕ,  dir <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ueven <span class="pl-k">*</span> ϕ1, dir, Dcut<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>ϕ,  dir = compress(Uodd  * ϕ2, dir, Dcut=Dcut)</span>
    <span class="pl-k">end</span>
    ϕ
<span class="pl-k">end</span></pre></div>
</details>
<p></p>
<h2><a id="user-content-tests" class="anchor" aria-hidden="true" href="#tests"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tests</h2>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Test, MatrixProductStates, SparseArrays, Arpack

@testset &quot;TFIM   &quot; begin
    g = 1.0; L = 7

    function H_TFIM(g, L)
        id = [1  0; 
              0  1]
        σˣ = [0  1; 
              1  0]
        σᶻ = [1  0; 
              0 -1]
        W_tnsr = zeros(Complex{Float64}, 3, 3, 2, 2)
        W_tnsr[1, 1, :, :] = id    
        W_tnsr[2, 1, :, :] = -σᶻ  
        W_tnsr[3, 1, :, :] = -g*σˣ
        W_tnsr[3, 2, :, :] = σᶻ   
        W_tnsr[3, 3, :, :] = id   

        return MPO(W_tnsr, L)
    end
    H = H_TFIM(g, L)
    ψ = randn(MPS{L, Complex{Float64}}, 100, 2)
    
    ψ̃ = compress(ψ, left, Dcut=80)[1] # Note: no actual information is lost in this 
    # compression because of the small size of the chain

    @test              ψ̃'ψ̃ ≈ 1
    @test          ψ'ψ/ψ'ψ ≈ ψ̃'ψ̃
    @test ((ψ'*(H*ψ))/ψ'ψ) ≈ (ψ̃' * (H * ψ̃))/ψ̃'ψ̃
    @test ((ψ'*(H*ψ))/ψ'ψ) ≈ (ψ̃' * (H * ψ))/ψ̃'ψ

    ϕ, E₀ = ground_state(ψ, H, quiet=true)
    @test ϕ' * H * H * ϕ ≈ (ϕ'*H*ϕ)^2
end

@testset &quot;Hubbard&quot; begin

    id = [1 0
          0 1]
    c  = [0 0
          1 0] #Anti commuting matrix
    c_up = c  ⊗ id
    c_dn = id ⊗ c
    id²  = id ⊗ id
    n_up = c_up' * c_up
    n_dn = c_dn' * c_dn

    P_up = (id² - 2c_up'*c_up) # Spin up parity operator
    P_dn = (id² - 2c_dn'*c_dn) # Spin down parity operator

    function H_hub(U, μ, L)
        W_tnsr = zeros(Complex{Float64}, 6, 6, 4, 4)
        W_tnsr[1, 1, :, :] = id²
        W_tnsr[2, 1, :, :] = c_up'
        W_tnsr[3, 1, :, :] = c_dn'
        W_tnsr[4, 1, :, :] = c_up
        W_tnsr[5, 1, :, :] = c_dn
        W_tnsr[6, 1, :, :] = U*(n_up * n_dn) - μ*(n_up + n_dn)
        W_tnsr[6, 2, :, :] =  c_up  * P_up  # Must multiply by the parity operator to get 
        W_tnsr[6, 3, :, :] =  c_dn  * P_dn  # correct off-site commutation relations!
        W_tnsr[6, 4, :, :] = -c_up' * P_up
        W_tnsr[6, 5, :, :] = -c_dn' * P_dn
        W_tnsr[6, 6, :, :] = id²
        MPO(W_tnsr, L)
    end

    function solve_hub(U, μ, L; retfull=true, quiet=true)
        H = H_hub(U, μ, L)
        ψ = randn(MPS{L, Complex{Float64}}, 100, 4)
        (ϕ, E₀), t, bytes = @timed ground_state(ψ, H, ϵ=1e-5, quiet=quiet)

        (ϕ=ϕ, E₀=E₀, H=H, t=t, Gbytes=bytes/1e9)
    end

    function Hub_ED(U, μ, L,)
        Û = U*(n_up * n_dn) - μ*(n_up + n_dn)
        c_dg_up(i) = foldl(⊗, sparse.([i==j ? c_up' : id² for j in 1:L]))
        cup(i)     = foldl(⊗, sparse.([i==j ? c_up  : id² for j in 1:L]))
        c_dg_dn(i) = foldl(⊗, sparse.([i==j ? c_dn' : id² for j in 1:L]))
        cdn(i)     = foldl(⊗, sparse.([i==j ? c_dn  : id² for j in 1:L]))
        Ûf(i)      = foldl(⊗, sparse.([i==j ? Û     : id² for j in 1:L]))
        function c_dg_c(i) 
            out = c_dg_up(i)*cup(i+1) + c_dg_dn(i)*cdn(i+1)
            out + out'
        end
        H = -sum(c_dg_c, 1:(L-1)) + sum(Ûf, 1:L)

        λ, ϕ = eigs(H, nev=1, which=:SR)
        (ϕ'H*ϕ)[]
    end

   
    U = 3.0; μ = -1.0; L = 4
    H = H_hub(U, μ, L)

    ϕ, E₀ = solve_hub(U, μ, L, retfull=true, quiet=true)
    @test ϕ' * H * H * ϕ ≈ (ϕ'*H*ϕ)^2  # Make sure energy is eigenvalue
    @test ϕ' * H * ϕ ≈ E₀              # make sure eigenvalue matches one produced by alogrithm
    @test ϕ' * H * ϕ ≈ Hub_ED(U, μ, L) # check against exact diagonalization
end

"><pre><span class="pl-k">using</span> Test, MatrixProductStates, SparseArrays, Arpack

<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>TFIM   <span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
    g <span class="pl-k">=</span> <span class="pl-c1">1.0</span>; L <span class="pl-k">=</span> <span class="pl-c1">7</span>

    <span class="pl-k">function</span> <span class="pl-en">H_TFIM</span>(g, L)
        id <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
              <span class="pl-c1">0</span>  <span class="pl-c1">1</span>]
        σˣ <span class="pl-k">=</span> [<span class="pl-c1">0</span>  <span class="pl-c1">1</span>; 
              <span class="pl-c1">1</span>  <span class="pl-c1">0</span>]
        σᶻ <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
              <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
        W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
        W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> id    
        W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>σᶻ  
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>g<span class="pl-k">*</span>σˣ
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span> σᶻ   
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span> id   

        <span class="pl-k">return</span> <span class="pl-c1">MPO</span>(W_tnsr, L)
    <span class="pl-k">end</span>
    H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)
    ψ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, <span class="pl-c1">100</span>, <span class="pl-c1">2</span>)
    
    ψ̃ <span class="pl-k">=</span> <span class="pl-c1">compress</span>(ψ, left, Dcut<span class="pl-k">=</span><span class="pl-c1">80</span>)[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> Note: no actual information is lost in this </span>
    <span class="pl-c"><span class="pl-c">#</span> compression because of the small size of the chain</span>

    <span class="pl-c1">@test</span>              ψ̃<span class="pl-k">'</span>ψ̃ <span class="pl-k">≈</span> <span class="pl-c1">1</span>
    <span class="pl-c1">@test</span>          ψ<span class="pl-k">'</span>ψ<span class="pl-k">/</span>ψ<span class="pl-k">'</span>ψ <span class="pl-k">≈</span> ψ̃<span class="pl-k">'</span>ψ̃
    <span class="pl-c1">@test</span> ((ψ<span class="pl-k">'</span><span class="pl-k">*</span>(H<span class="pl-k">*</span>ψ))<span class="pl-k">/</span>ψ<span class="pl-k">'</span>ψ) <span class="pl-k">≈</span> (ψ̃<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> ψ̃))<span class="pl-k">/</span>ψ̃<span class="pl-k">'</span>ψ̃
    <span class="pl-c1">@test</span> ((ψ<span class="pl-k">'</span><span class="pl-k">*</span>(H<span class="pl-k">*</span>ψ))<span class="pl-k">/</span>ψ<span class="pl-k">'</span>ψ) <span class="pl-k">≈</span> (ψ̃<span class="pl-k">'</span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> ψ))<span class="pl-k">/</span>ψ̃<span class="pl-k">'</span>ψ

    ϕ, E₀ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(ψ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
    <span class="pl-c1">@test</span> ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ <span class="pl-k">≈</span> (ϕ<span class="pl-k">'</span><span class="pl-k">*</span>H<span class="pl-k">*</span>ϕ)<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-k">end</span>

<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>Hubbard<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>

    id <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span>
          <span class="pl-c1">0</span> <span class="pl-c1">1</span>]
    c  <span class="pl-k">=</span> [<span class="pl-c1">0</span> <span class="pl-c1">0</span>
          <span class="pl-c1">1</span> <span class="pl-c1">0</span>] <span class="pl-c"><span class="pl-c">#</span>Anti commuting matrix</span>
    c_up <span class="pl-k">=</span> c  ⊗ id
    c_dn <span class="pl-k">=</span> id ⊗ c
    id²  <span class="pl-k">=</span> id ⊗ id
    n_up <span class="pl-k">=</span> c_up<span class="pl-k">'</span> <span class="pl-k">*</span> c_up
    n_dn <span class="pl-k">=</span> c_dn<span class="pl-k">'</span> <span class="pl-k">*</span> c_dn

    P_up <span class="pl-k">=</span> (id² <span class="pl-k">-</span> <span class="pl-c1">2</span>c_up<span class="pl-k">'</span><span class="pl-k">*</span>c_up) <span class="pl-c"><span class="pl-c">#</span> Spin up parity operator</span>
    P_dn <span class="pl-k">=</span> (id² <span class="pl-k">-</span> <span class="pl-c1">2</span>c_dn<span class="pl-k">'</span><span class="pl-k">*</span>c_dn) <span class="pl-c"><span class="pl-c">#</span> Spin down parity operator</span>

    <span class="pl-k">function</span> <span class="pl-en">H_hub</span>(U, μ, L)
        W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">6</span>, <span class="pl-c1">6</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>)
        W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> id²
        W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_up<span class="pl-k">'</span>
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_dn<span class="pl-k">'</span>
        W_tnsr[<span class="pl-c1">4</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_up
        W_tnsr[<span class="pl-c1">5</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_dn
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> U<span class="pl-k">*</span>(n_up <span class="pl-k">*</span> n_dn) <span class="pl-k">-</span> μ<span class="pl-k">*</span>(n_up <span class="pl-k">+</span> n_dn)
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span>  c_up  <span class="pl-k">*</span> P_up  <span class="pl-c"><span class="pl-c">#</span> Must multiply by the parity operator to get </span>
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span>  c_dn  <span class="pl-k">*</span> P_dn  <span class="pl-c"><span class="pl-c">#</span> correct off-site commutation relations!</span>
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">4</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>c_up<span class="pl-k">'</span> <span class="pl-k">*</span> P_up
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">5</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>c_dn<span class="pl-k">'</span> <span class="pl-k">*</span> P_dn
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">6</span>, :, :] <span class="pl-k">=</span> id²
        <span class="pl-c1">MPO</span>(W_tnsr, L)
    <span class="pl-k">end</span>

    <span class="pl-k">function</span> <span class="pl-en">solve_hub</span>(U, μ, L; retfull<span class="pl-k">=</span><span class="pl-c1">true</span>, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
        H <span class="pl-k">=</span> <span class="pl-c1">H_hub</span>(U, μ, L)
        ψ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, <span class="pl-c1">100</span>, <span class="pl-c1">4</span>)
        (ϕ, E₀), t, bytes <span class="pl-k">=</span> <span class="pl-c1">@timed</span> <span class="pl-c1">ground_state</span>(ψ, H, ϵ<span class="pl-k">=</span><span class="pl-c1">1e-5</span>, quiet<span class="pl-k">=</span>quiet)

        (ϕ<span class="pl-k">=</span>ϕ, E₀<span class="pl-k">=</span>E₀, H<span class="pl-k">=</span>H, t<span class="pl-k">=</span>t, Gbytes<span class="pl-k">=</span>bytes<span class="pl-k">/</span><span class="pl-c1">1e9</span>)
    <span class="pl-k">end</span>

    <span class="pl-k">function</span> <span class="pl-en">Hub_ED</span>(U, μ, L,)
        Û <span class="pl-k">=</span> U<span class="pl-k">*</span>(n_up <span class="pl-k">*</span> n_dn) <span class="pl-k">-</span> μ<span class="pl-k">*</span>(n_up <span class="pl-k">+</span> n_dn)
        <span class="pl-en">c_dg_up</span>(i) <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(⊗, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_up<span class="pl-k">'</span> <span class="pl-k">:</span> id² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">cup</span>(i)     <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(⊗, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_up  <span class="pl-k">:</span> id² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">c_dg_dn</span>(i) <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(⊗, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_dn<span class="pl-k">'</span> <span class="pl-k">:</span> id² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">cdn</span>(i)     <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(⊗, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> c_dn  <span class="pl-k">:</span> id² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">Ûf</span>(i)      <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(⊗, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j <span class="pl-k">?</span> Û     <span class="pl-k">:</span> id² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-k">function</span> <span class="pl-en">c_dg_c</span>(i) 
            out <span class="pl-k">=</span> <span class="pl-c1">c_dg_up</span>(i)<span class="pl-k">*</span><span class="pl-c1">cup</span>(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">c_dg_dn</span>(i)<span class="pl-k">*</span><span class="pl-c1">cdn</span>(i<span class="pl-k">+</span><span class="pl-c1">1</span>)
            out <span class="pl-k">+</span> out<span class="pl-k">'</span>
        <span class="pl-k">end</span>
        H <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">sum</span>(c_dg_c, <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">+</span> <span class="pl-c1">sum</span>(Ûf, <span class="pl-c1">1</span><span class="pl-k">:</span>L)

        λ, ϕ <span class="pl-k">=</span> <span class="pl-c1">eigs</span>(H, nev<span class="pl-k">=</span><span class="pl-c1">1</span>, which<span class="pl-k">=</span><span class="pl-c1">:SR</span>)
        (ϕ<span class="pl-k">'</span>H<span class="pl-k">*</span>ϕ)[]
    <span class="pl-k">end</span>

   
    U <span class="pl-k">=</span> <span class="pl-c1">3.0</span>; μ <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1.0</span>; L <span class="pl-k">=</span> <span class="pl-c1">4</span>
    H <span class="pl-k">=</span> <span class="pl-c1">H_hub</span>(U, μ, L)

    ϕ, E₀ <span class="pl-k">=</span> <span class="pl-c1">solve_hub</span>(U, μ, L, retfull<span class="pl-k">=</span><span class="pl-c1">true</span>, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
    <span class="pl-c1">@test</span> ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ <span class="pl-k">≈</span> (ϕ<span class="pl-k">'</span><span class="pl-k">*</span>H<span class="pl-k">*</span>ϕ)<span class="pl-k">^</span><span class="pl-c1">2</span>  <span class="pl-c"><span class="pl-c">#</span> Make sure energy is eigenvalue</span>
    <span class="pl-c1">@test</span> ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ <span class="pl-k">≈</span> E₀              <span class="pl-c"><span class="pl-c">#</span> make sure eigenvalue matches one produced by alogrithm</span>
    <span class="pl-c1">@test</span> ϕ<span class="pl-k">'</span> <span class="pl-k">*</span> H <span class="pl-k">*</span> ϕ <span class="pl-k">≈</span> <span class="pl-c1">Hub_ED</span>(U, μ, L) <span class="pl-c"><span class="pl-c">#</span> check against exact diagonalization</span>
<span class="pl-k">end</span>
</pre></div>
</details>
<p></p>
</article></div>