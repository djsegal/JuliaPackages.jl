<div id="readme" class="org" data-path="README.org"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-matrixproductstatesjl" class="anchor" aria-hidden="true" href="#matrixproductstatesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>MatrixProductStates.jl</h1>
<p>This is a package-in-progress in which I am implementing the <a href="https://en.wikipedia.org/wiki/Density_matrix_renormalization_group" rel="nofollow">DMRG</a>
  algorithm over matrix product states as explained in SchollwÃ¶ckâ€™s <a href="https://www.sciencedirect.com/science/article/pii/S0003491610001752" rel="nofollow">The
  density-matrix renormalization group in the age of matrix product
  states</a>. A similar project has been undertaken in <a href="https://github.com/0/LatticeSweeper.jl">LatticeSweeper.jl</a>.</p>
<p>To acquire this package, simply open a <code>julia</code> repl and type</p>
<pre>] add https://github.com/MasonProtter/MatrixProductStates.jl.git
</pre>
<h2><a id="user-content-example-transverse-field-ising-model" class="anchor" aria-hidden="true" href="#example-transverse-field-ising-model"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: Transverse Field Ising Model</h2>
<details><summary>Click me!</summary>
<p>
</p><p>Suppose we didnâ€™t realize the one dimensional transverse field Ising
  model was exactly solvable and we wanted to study it with DMRG.</p>
<p>The TFIM Hamiltonian is written</p>
<pre>H = - âˆ‘áµ¢ Ïƒá¶»áµ¢Ïƒá¶»áµ¢â‚Šâ‚ - âˆ‘áµ¢ g ÏƒË£áµ¢ 
</pre>
<p>which in MPO form can be written as</p>
<pre>H = WÂ¹ WÂ² WÂ³... Wá´¸â»Â¹ Wá´¸
                   [ ğŸ™    ğŸ˜    ğŸ˜] [ ğŸ™    ğŸ˜    ğŸ˜]     [ ğŸ™    ğŸ˜    ğŸ˜] [ ğŸ™  ]
  = [-gÏƒË£  Ïƒá¶»   ğŸ™] | -Ïƒá¶»  ğŸ˜    ğŸ˜| | -Ïƒá¶»  ğŸ˜    ğŸ˜| ... | -Ïƒá¶»  ğŸ˜    ğŸ˜| |-Ïƒá¶» |
                   [-gÏƒË£  Ïƒá¶»   ğŸ™] [-gÏƒË£  Ïƒá¶»   ğŸ™]     [-gÏƒË£  Ïƒá¶»  ğŸ™] [-gÏƒË£]
</pre>
<p>We can study this Hamiltonian using MatrixProductStates.jl as follows:</p>
<p>First, make a function for generating the Hamiltonian given a coupling strength <code>g = h/J</code> and a system length <code>L</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> MatrixProductStates

<span class="pl-k">function</span> <span class="pl-en">H_TFIM</span>(g, L)
    id <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
          <span class="pl-c1">0</span>  <span class="pl-c1">1</span>]
    ÏƒË£ <span class="pl-k">=</span> [<span class="pl-c1">0</span>  <span class="pl-c1">1</span>; 
          <span class="pl-c1">1</span>  <span class="pl-c1">0</span>]
    Ïƒá¶» <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
          <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
    W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
    W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> id    
    W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>Ïƒá¶»  
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>g<span class="pl-k">*</span>ÏƒË£
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span> Ïƒá¶»   
    W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span> id   

    <span class="pl-k">return</span> <span class="pl-c1">MPO</span>(W_tnsr, L) <span class="pl-c"><span class="pl-c">#</span> MPO will assume that WÂ¹ = W_tnsr[end:end, :, :, :] and Wá´¸ = W_tnsr[:, 1:1, :, :]</span>
<span class="pl-k">end</span></pre></div>
<h3><a id="user-content-ground-state" class="anchor" aria-hidden="true" href="#ground-state"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Ground State</h3>
<p>Suppose we want to know the ground state of this system for
  <code>g=0.8</code> and <code>L=12</code> and we have no idea what the MPS form of the ground
  state looks like a-priori.</p>
<div class="highlight highlight-source-julia"><pre>g <span class="pl-k">=</span> <span class="pl-c1">1.1</span>; L <span class="pl-k">=</span> <span class="pl-c1">12</span>;

d    <span class="pl-k">=</span> <span class="pl-c1">2</span>;   <span class="pl-c"><span class="pl-c">#</span> This is the local Hilbert space dimension for each site</span>
Dcut <span class="pl-k">=</span> <span class="pl-c1">100</span>; <span class="pl-c"><span class="pl-c">#</span> This is the maximum bond dimension we'll allow our matrix product state to take</span>

H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)
Ïˆ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, Dcut, d) <span class="pl-c"><span class="pl-c">#</span> Generate a completely randomized matrix product state</span>

Ï•, Eâ‚’ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">#</span>Set quiet to false (the deault) to turn off notifications about the algorithm's progress</span></pre></div>
<p>We now have the ground state <code>Ï•</code>, and an estimate of itâ€™s energy
  eigenvalue <code>Eâ‚’</code>!</p>
<p>Note that 12 sites can be easily studied with far less computational
  cost as an exact diagonalization, but I didnâ€™t want to suggest doing
  something like <code>L=50</code> right off the bat since that took ~90 minutes on
  my machine.</p>
<p>We can make sure that this stateâ€™s energy matches our estimate:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> Ï•<span class="pl-s"><span class="pl-pds">'</span> * H * Ï• â‰ˆ Eâ‚€ # computing âŸ¨Ï•|H|Ï•âŸ©</span>
<span class="pl-s">true</span></pre></div>
<p>and we can varify that itâ€™s approximately an eigenstate:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> Ï•<span class="pl-s"><span class="pl-pds">'</span> * H * H * Ï•  â‰ˆ (Ï•<span class="pl-pds">'</span></span> <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï•)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> computing âŸ¨Ï•| H^2 |Ï•âŸ© â‰ˆ (âŸ¨Ï•|H|Ï•âŸ©)^2</span>
<span class="pl-c1">true</span></pre></div>
<h3><a id="user-content-correlators" class="anchor" aria-hidden="true" href="#correlators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Correlators</h3>
<p>We can take advantage of the <code>two_point_correlator</code> function to study spin-spin correlations in the TFIM</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> UnicodePlots

Ïƒá¶» <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span> 
      <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]

<span class="pl-en">zz</span>(i, j) <span class="pl-k">=</span> <span class="pl-c1">two_point_correlator</span>(i<span class="pl-k">=&gt;</span>Ïƒá¶», j<span class="pl-k">=&gt;</span>Ïƒá¶», <span class="pl-c1">12</span>)

js <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">12</span>

zzs <span class="pl-k">=</span> [<span class="pl-c1">realize</span>(Ï•<span class="pl-s"><span class="pl-pds">'</span>*zz(1, j)*Ï•) for j in js] #realize will convert complex numbers with a small imaginary part to real.</span>
<span class="pl-s"></span>
<span class="pl-s">lineplot(js, zzs, canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, </span>
<span class="pl-s">         ylabel="âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©", xlabel="lattice site j", title="Spin-Spin Correlation for g = $g")</span></pre></div>
<pre>                                      Spin-Spin Correlation for g = 1.1
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 
         1.01 â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©      â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚:                                                                               â”‚ 
              â”‚ '.                                                                             â”‚ 
              â”‚   '.                                                                           â”‚ 
              â”‚     '.                                                                         â”‚ 
              â”‚       '.                                                                       â”‚ 
              â”‚         ''.                                                                    â”‚ 
              â”‚            ''..                                                                â”‚ 
              â”‚                ''...                                                           â”‚ 
              â”‚                     ''....                                                     â”‚ 
              â”‚                           ''''....                                             â”‚ 
              â”‚                                   '''''.......                                 â”‚ 
              â”‚                                               '''''''.........                 â”‚ 
              â”‚                                                               '''''''''........â”‚ 
            0 â”‚                                                                                â”‚ 
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
              2                                                                               12
                                               lattice site j
</pre>
<p>which shows exponentially decaying correlations in the ground state,
  as expected for <code>g &gt; 1</code>. We can also redo our calculation in the
  ordered phase:</p>
<div class="highlight highlight-source-julia"><pre>g <span class="pl-k">=</span> <span class="pl-c1">0.8</span>;

H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)

Ï•, Eâ‚’ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)

ordered_zzs <span class="pl-k">=</span> [<span class="pl-c1">realize</span>(Ï•<span class="pl-s"><span class="pl-pds">'</span>*zz(1, j)*Ï•) for j in js]</span>
<span class="pl-s"></span>
<span class="pl-s">lineplot(js, realize.(ordered_zzs), canvas=DotCanvas, ylim=[0, 1.01], width=80, height=30, </span>
<span class="pl-s">         ylabel="âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©", xlabel="lattice site j", title="Spin-Spin Correlation for g = $g")</span></pre></div>
<pre>                                      Spin-Spin Correlation for g = 0.8
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 
         1.01 â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚.                                                                               â”‚ 
              â”‚ ''.                                                                            â”‚ 
              â”‚    ''..                                                                        â”‚ 
              â”‚        '''....                                                                 â”‚ 
âŸ¨Ïƒá¶»â‚Ïƒá¶»â±¼âŸ©      â”‚               ''''''.........                                                  â”‚ 
              â”‚                              ''''''''''''...........                           â”‚ 
              â”‚                                                     '''''''......              â”‚ 
              â”‚                                                                  '''....       â”‚ 
              â”‚                                                                         '..    â”‚ 
              â”‚                                                                            ''..â”‚ 
              â”‚                                                                               'â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
              â”‚                                                                                â”‚ 
            0 â”‚                                                                                â”‚ 
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
              2                                                                               12
                                               lattice site j
</pre>
</details>
<p></p>
<h2><a id="user-content-source-code" class="anchor" aria-hidden="true" href="#source-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Source Code</h2>
<p>This readme is a literate document containing all of the source and
  test code for the package.</p>
<h3><a id="user-content-module-definition" class="anchor" aria-hidden="true" href="#module-definition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Module Definition</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-k">module</span> MatrixProductStates

<span class="pl-k">using</span> LinearAlgebra, TensorOperations, TensorCast, LowRankApprox, Arpack, Strided, SparseArrays
<span class="pl-c"><span class="pl-c">#</span>using ProgressMeter</span>

<span class="pl-k">export</span> <span class="pl-k">*</span>, <span class="pl-k">/</span>, <span class="pl-k">==</span>, <span class="pl-k">â‰ˆ</span>, isequal, adjoint, getindex, randn
<span class="pl-k">export</span> MPS, MPO, left, right, compress, imag_time_evolution, rightcanonical, leftcanonical 
<span class="pl-k">export</span> ground_state, two_point_correlator, realize

<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>utils.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>MPS.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>MPO.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>compression.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>contraction.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>groundstate.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>correlation.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>timeevolution.jl<span class="pl-pds">"</span></span>)

<span class="pl-k">end</span></pre></div>
</details>
<p></p>
<h3><a id="user-content-utils" class="anchor" aria-hidden="true" href="#utils"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Utils</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-k">export</span> âŠ—, realize

<span class="pl-k">abstract type</span> Direction <span class="pl-k">end</span>

<span class="pl-k">struct</span> Left  <span class="pl-k">&lt;:</span> <span class="pl-c1">Direction</span> <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> Often useful to dispatch on direction an algorithm is going</span>
<span class="pl-k">struct</span> Right <span class="pl-k">&lt;:</span> <span class="pl-c1">Direction</span> <span class="pl-k">end</span>

<span class="pl-k">const</span> left  <span class="pl-k">=</span> <span class="pl-c1">Left</span>()
<span class="pl-k">const</span> right <span class="pl-k">=</span> <span class="pl-c1">Right</span>()

A âŠ— B <span class="pl-k">=</span> <span class="pl-c1">kron</span>(A, B)

<span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">=</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Unrecognized numerical type<span class="pl-pds">"</span></span>)
<span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Real</span>) <span class="pl-k">=</span> x
<span class="pl-k">function</span> <span class="pl-en">realize</span>(x<span class="pl-k">::</span><span class="pl-c1">Complex</span>; Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-10</span>)
    <span class="pl-c1">abs</span>(<span class="pl-c1">imag</span>(x)) <span class="pl-k">&lt;</span> Ïµ <span class="pl-k">||</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Non-zero imaginary component, <span class="pl-v">$(<span class="pl-c1">imag</span>(x))</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">real</span>(x)
<span class="pl-k">end</span>

<span class="pl-en">dg</span>(M<span class="pl-k">::</span><span class="pl-c1">Array{T, 4}</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(M), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>))
<span class="pl-en">dg</span>(M<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(M), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>))

<span class="pl-en">not</span>(x) <span class="pl-k">=</span> <span class="pl-k">~</span>x
</pre></div>
</details>
<p></p>
<h3><a id="user-content-matrix-product-states" class="anchor" aria-hidden="true" href="#matrix-product-states"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrix Product States</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS{L, T&lt;:Number}</span>
<span class="pl-s"></span>
<span class="pl-s">Matrix product state on L sites. </span>
<span class="pl-s"></span>
<span class="pl-s">The `i`th tensor in the state has indices `[aâ±â»Â¹, aâ±, Ïƒâ±]` where</span>
<span class="pl-s">`(aâ±â»Â¹, aâ±)` are bond indices and `Ïƒâ±` is the physical index.</span>
<span class="pl-s"></span>
<span class="pl-s">A four site MPS would be diagrammatically represented</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     </span>
<span class="pl-s"></span>
<span class="pl-s">Note that `aâ°` and `aá´¸` must be of dimension 1.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">struct</span> MPS{L, T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>} 
    tensors<span class="pl-k">::</span><span class="pl-c1">Vector{Array{T,3}}</span>
<span class="pl-k">end</span>

Base<span class="pl-k">.</span><span class="pl-en">isequal</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, Ï•<span class="pl-k">::</span><span class="pl-c1">MPS</span>)     <span class="pl-k">=</span> (<span class="pl-c1">isequal</span>(Ïˆ<span class="pl-k">.</span>tensors, Ï•<span class="pl-k">.</span>tensors))
Base<span class="pl-k">.</span><span class="pl-en">isapprox</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, Ï•<span class="pl-k">::</span><span class="pl-c1">MPS</span>)   <span class="pl-k">=</span> <span class="pl-c1">isapprox</span>(Ïˆ<span class="pl-k">.</span>tensors, Ï•<span class="pl-k">.</span>tensors)

Base<span class="pl-k">.</span><span class="pl-en">eltype</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> T

Base<span class="pl-k">.</span><span class="pl-en">length</span>(<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> L

Base<span class="pl-k">.</span><span class="pl-en">size</span>(<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> (L,)
Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, i<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(Ïˆ<span class="pl-k">.</span>tensors, i)

Base.:(<span class="pl-k">*</span>)(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(Ïˆ<span class="pl-k">.</span>tensors <span class="pl-k">.*</span> x)
Base.:(<span class="pl-k">*</span>)(x<span class="pl-k">::</span><span class="pl-c1">Number</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>) <span class="pl-k">=</span> Ïˆ <span class="pl-k">*</span> x
Base.:(<span class="pl-k">/</span>)(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L,T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(Ïˆ<span class="pl-k">.</span>tensors <span class="pl-k">./</span> x)
Base<span class="pl-k">.</span><span class="pl-en">copy</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(<span class="pl-c1">copy</span>.(Ïˆ<span class="pl-k">.</span>tensors))

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">randn</span>(<span class="pl-k">::</span><span class="pl-c1">Type{MPS{L, T}}</span>, D<span class="pl-k">::</span><span class="pl-c1">Int</span>, d<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> [<span class="pl-c1">randn</span>(<span class="pl-c1">1</span>, D, d), [<span class="pl-c1">randn</span>(D, D, d) <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, <span class="pl-c1">randn</span>(D, <span class="pl-c1">1</span>, d)]
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors) <span class="pl-k">|&gt;</span> leftcanonical <span class="pl-k">|&gt;</span> rightcanonical
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS(vs::Vector{Vector})</span>
<span class="pl-s">Create an `MPS` representing a product state (all bonds have dimension 1),</span>
<span class="pl-s">where each site is described by the corresponding element of `vs`.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">MPS</span>(vs<span class="pl-k">::</span><span class="pl-c1">Vector{Vector{T}}</span>) <span class="pl-k">where</span> {T}
    L <span class="pl-k">=</span> <span class="pl-c1">length</span>(vs)

    tensrs <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Array{T,3}}</span>(undef, L)
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        tensrs[i] <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">copy</span>(vs[i]), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :)
    <span class="pl-k">end</span>

    <span class="pl-c1">MPS</span><span class="pl-c1">{L,T}</span>(tensrs)
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPS(v::Vector, L)</span>
<span class="pl-s">Create an `MPS` for `L` sites representing a uniform product state (all bonds</span>
<span class="pl-s">have dimension 1), where each site is described by `v`.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-en">MPS</span>(v<span class="pl-k">::</span><span class="pl-c1">Vector</span>, L) <span class="pl-k">=</span> <span class="pl-c1">MPS</span>([v <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L])

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ<span class="pl-k">.</span>tensors[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(Ïˆ[i][:, :, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ<span class="pl-k">.</span>tensors[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(Ïˆ[i][:, :, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_show_mps_dims</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, L, d, bonddims)
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Physical dimension: <span class="pl-v">$d</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Bond dimensions:   <span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> L <span class="pl-k">&gt;</span> <span class="pl-c1">8</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">8</span>
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span> ... Ã— <span class="pl-pds">"</span></span>, bonddims[L])
    <span class="pl-k">else</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, bonddims[L])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>MPS on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
</pre></div>
<details><summary>Adjoint MPS</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">adjoint</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L,T}
    <span class="pl-c1">Adjoint</span><span class="pl-c1">{T, MPS{L, T}}</span>(Ïˆ)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ<span class="pl-k">.</span>parent[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> <span class="pl-c1">reverse</span>([<span class="pl-c1">reverse</span>(<span class="pl-c1">size</span>(Ïˆ<span class="pl-k">.</span>parent[i][:, :, <span class="pl-c1">1</span>])) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L])
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Adjoint matrix product state on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mps_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Adjoint MPO on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)t
<span class="pl-k">end</span>

Base<span class="pl-k">.</span><span class="pl-en">size</span>(<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>) <span class="pl-k">where</span> {L, T} <span class="pl-k">=</span> (<span class="pl-c1">1</span>, L)

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>, args<span class="pl-k">...</span>) <span class="pl-k">where</span> {L, T}
    out <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(<span class="pl-c1">reverse</span>(Ïˆ<span class="pl-k">.</span>parent<span class="pl-k">.</span>tensors), args<span class="pl-k">...</span>)
    <span class="pl-c1">permutedims</span>(<span class="pl-c1">conj</span>.(out), (<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>))
<span class="pl-k">end</span>

<span class="pl-en">adjoint_tensors</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>) <span class="pl-k">=</span> <span class="pl-c1">reverse</span>(<span class="pl-c1">conj</span>.(<span class="pl-c1">permutedims</span>.(Ïˆ<span class="pl-k">.</span>tensors, [(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>)])))</pre></div>
<p></p>
</details>
<details><summary>MPS Contraction</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(Ïˆâ€²::Adjoint{T, MPS{L, T}}, Ï•::MPS{L, T}) where {L, T}</span>
<span class="pl-s">representing</span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢       </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(Ïˆâ€²<span class="pl-k">::</span><span class="pl-c1">Adjoint{T, MPS{L, T}}</span>, Ï•<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    Ïˆ <span class="pl-k">=</span> Ïˆâ€²<span class="pl-k">.</span>parent

    M   <span class="pl-k">=</span> Ï•<span class="pl-k">.</span>tensors[<span class="pl-c1">1</span>]
    MÌƒdg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(Ïˆ<span class="pl-k">.</span>tensors[<span class="pl-c1">1</span>])
    
    <span class="pl-c1">@tensor</span> cont[bâ‚, aâ‚] <span class="pl-k">:=</span> MÌƒdg[bâ‚, <span class="pl-c1">1</span>, Ïƒâ‚] <span class="pl-k">*</span> M[<span class="pl-c1">1</span>, aâ‚, Ïƒâ‚]
    
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>L<span class="pl-k">-</span><span class="pl-c1">1</span>
        M   <span class="pl-k">=</span> Ï•<span class="pl-k">.</span>tensors[i]
        MÌƒdg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(Ïˆ<span class="pl-k">.</span>tensors[i])

        <span class="pl-c1">@tensor</span> cont[báµ¢, aáµ¢] <span class="pl-k">:=</span> MÌƒdg[báµ¢, báµ¢â‚‹â‚, Ïƒáµ¢] <span class="pl-k">*</span> cont[báµ¢â‚‹â‚, aáµ¢â‚‹â‚] <span class="pl-k">*</span> M[aáµ¢â‚‹â‚, aáµ¢, Ïƒáµ¢]
    <span class="pl-k">end</span>
    M   <span class="pl-k">=</span> Ï•<span class="pl-k">.</span>tensors[L]
    MÌƒdg <span class="pl-k">=</span> <span class="pl-c1">dg</span>(Ïˆ<span class="pl-k">.</span>tensors[L])
    
    <span class="pl-c1">@tensor</span> MÌƒdg[<span class="pl-c1">1</span>, bá´¸â»Â¹, Ïƒá´¸] <span class="pl-k">*</span> cont[bá´¸â»Â¹, aá´¸â»Â¹] <span class="pl-k">*</span> M[aá´¸â»Â¹, <span class="pl-c1">1</span>, Ïƒá´¸]
<span class="pl-k">end</span>
</pre></div>
<p></p>
</details>
<p></p>
</details>
<h3><a id="user-content-matrix-product-operators" class="anchor" aria-hidden="true" href="#matrix-product-operators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrix Product Operators</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPO{L, T&lt;:Number}</span>
<span class="pl-s"></span>
<span class="pl-s">Matrix product operator on L sites. The `i`th tensor in the operator</span>
<span class="pl-s">has indices `[aâ±â»Â¹, aâ±, Ïƒâ±, Ïƒâ€²â±]` where `(Ïƒâ±, Ïƒâ€²â±)` are the physical</span>
<span class="pl-s">indices and `(aâ±â»Â¹, aâ±)` are bond indices.</span>
<span class="pl-s"></span>
<span class="pl-s">A four site MPS would be diagrammatically represented</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s"></span>
<span class="pl-s"></span>
<span class="pl-s">Note that `aâ°` and `aá´¸` must be of dimension 1.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">struct</span> MPO{L, T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>}
    tensors<span class="pl-k">::</span><span class="pl-c1">Vector{Array{T,4}}</span>
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    MPO(W::Array{T,4}, L)</span>
<span class="pl-s">Create an `MPO` for `L` sites with all interior sites containing the tensor</span>
<span class="pl-s">`W`. The tensor is assumed to have the usual matrix-of-operators structure,</span>
<span class="pl-s">with the first two indices being the bond (matrix) dimension and the last two</span>
<span class="pl-s">indices being the physical (operator) dimension. The first and last sites only</span>
<span class="pl-s">use the last row and first column of `W`, respectively.</span>
<span class="pl-s"></span>
<span class="pl-s">For example, the MPO form of the Hamiltonian for the TFIM is</span>
<span class="pl-s">constructed as with coupling `g` and length `L` is constructed as</span>
<span class="pl-s">follows:</span>
<span class="pl-s"></span>
<span class="pl-s">    id = [1 0</span>
<span class="pl-s">          0 1]</span>
<span class="pl-s"></span>
<span class="pl-s">    Ïƒá¶» = [1  0 </span>
<span class="pl-s">          0 -1]</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒË£ = [0 1</span>
<span class="pl-s">          1 0]</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÊ¸ = [0  -im</span>
<span class="pl-s">          im   0]</span>
<span class="pl-s"></span>
<span class="pl-s">    W = zeros(3, 3, 2, 2)</span>
<span class="pl-s">    W[1, 1, :, :] = id</span>
<span class="pl-s">    W[2, 1, :, :] = Ïƒá¶»</span>
<span class="pl-s">    W[3, 1, :, :] = -g*ÏƒË£</span>
<span class="pl-s">    W[3, 2, :, :] = -Ïƒá¶»</span>
<span class="pl-s">    W[3, 3, :, :] = id</span>
<span class="pl-s"></span>
<span class="pl-s">returning </span>
<span class="pl-s"> </span>
<span class="pl-s">    Ä¤::MPO = Å´Â¹ Å´Â² Å´Â³ â‹…â‹…â‹… Å´á´¸â»Â¹ Wá´¸</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">MPO</span>(W<span class="pl-k">::</span><span class="pl-c1">Array{T,4}</span>, L) <span class="pl-k">where</span> {T}
    L <span class="pl-k">&gt;=</span> <span class="pl-c1">2</span> <span class="pl-k">||</span> <span class="pl-c1">throw</span>(<span class="pl-c1">DomainError</span>(L, <span class="pl-s"><span class="pl-pds">"</span>At least 2 sites.<span class="pl-pds">"</span></span>))

    tensors <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Array{T,4}}</span>(undef, L)
    
    tensors[<span class="pl-c1">1</span>] <span class="pl-k">=</span> W[<span class="pl-c1">end</span><span class="pl-k">:</span><span class="pl-c1">end</span>, :, :, :] <span class="pl-c"><span class="pl-c">#</span> Row vector.</span>
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
        tensors[i] <span class="pl-k">=</span> W <span class="pl-c"><span class="pl-c">#</span> Matrix</span>
    <span class="pl-k">end</span>
    tensors[L] <span class="pl-k">=</span> W[:, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, :, :] <span class="pl-c"><span class="pl-c">#</span> Column vector.</span>

    <span class="pl-c1">MPO</span><span class="pl-c1">{L,T}</span>(tensors)
<span class="pl-k">end</span>

Base.:(<span class="pl-k">==</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, U<span class="pl-k">::</span><span class="pl-c1">MPO</span>) <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors <span class="pl-k">==</span> U<span class="pl-k">.</span>tensors
Base.:(<span class="pl-k">â‰ˆ</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, U<span class="pl-k">::</span><span class="pl-c1">MPO</span>)  <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors <span class="pl-k">â‰ˆ</span> U<span class="pl-k">.</span>tensors
Base<span class="pl-k">.</span><span class="pl-en">getindex</span>(O<span class="pl-k">::</span><span class="pl-c1">MPO</span>, args<span class="pl-k">...</span>) <span class="pl-k">=</span> <span class="pl-c1">getindex</span>(O<span class="pl-k">.</span>tensors, args<span class="pl-k">...</span>)

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(O[<span class="pl-c1">2</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    bonddims <span class="pl-k">=</span> [<span class="pl-c1">size</span>(O[i][:, :, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>]) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>Matrix product Operator on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
    <span class="pl-c1">_show_mpo_dims</span>(io, L, d, bonddims)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">_show_mpo_dims</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, L, d, bonddims)
    <span class="pl-c1">println</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Physical dimension: <span class="pl-v">$d</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>  Bond dimensions:   <span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> L <span class="pl-k">&gt;</span> <span class="pl-c1">8</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">8</span>
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span> ... Ã— <span class="pl-pds">"</span></span>, bonddims[L])
    <span class="pl-k">else</span>
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
            <span class="pl-c1">print</span>(io, bonddims[i], <span class="pl-s"><span class="pl-pds">"</span> Ã— <span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        <span class="pl-c1">print</span>(io, bonddims[L])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> Base<span class="pl-k">.</span><span class="pl-en">show</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>MPO on <span class="pl-v">$L</span> sites<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span></pre></div>
<details><summary>MPO Contraction</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(O::MPO, Ïˆ::MPS)</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢     </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">3</span>}[]
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W <span class="pl-k">=</span> O<span class="pl-k">.</span>tensors[i]
        M <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] <span class="pl-k">*</span> M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        
        <span class="pl-c1">push!</span>(tensors, N)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(O1::MPO, O2::MPO)</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢     </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´</span>
<span class="pl-s">    Ïƒâ€²â€²Â¹        Ïƒâ€²â€²Â²        Ïƒâ€²â€²Â³        Ïƒâ€²â€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢ </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´    </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(O1<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, O2<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">4</span>}[]
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W1 <span class="pl-k">=</span> O1<span class="pl-k">.</span>tensors[i]
        W2 <span class="pl-k">=</span> O2<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> V[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢, Ïƒâ€²áµ¢] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(Ïƒâ€²â€²áµ¢) W1[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²â€²áµ¢] <span class="pl-k">*</span> W2[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²â€²áµ¢, Ïƒâ€²áµ¢]
        
        <span class="pl-c1">push!</span>(tensors, V)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPO</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>

<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Base.:(*)(Ïˆ::Adjoint{T,MPS{L,T}}, O::MPO) where {L,T}</span>
<span class="pl-s">representing</span>
<span class="pl-s"></span>
<span class="pl-s">    â€¢--(aÂ¹ aÂ¹)--â€¢--(aÂ² aÂ²)--â€¢--(aÂ³ aÂ³)--â€¢       </span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    Ïƒâ€²Â¹         Ïƒâ€²Â²         Ïƒâ€²Â³         Ïƒâ€²â´</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    â€¢--(bÂ¹ bÂ¹)--â€¢--(bÂ² bÂ²)--â€¢--(bÂ³ bÂ³)--â€¢</span>
<span class="pl-s">    |           |           |           | </span>
<span class="pl-s">    ÏƒÂ¹          ÏƒÂ²          ÏƒÂ³          Ïƒâ´ </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> Base.:(<span class="pl-k">*</span>)(Ïˆâ€²<span class="pl-k">::</span><span class="pl-c1">Adjoint{T,MPS{L,T}}</span>, O<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L,T}
    Ïˆ <span class="pl-k">=</span> Ïˆâ€²<span class="pl-k">.</span>parent
    tensors <span class="pl-k">=</span> Array{T,<span class="pl-c1">3</span>}[]
    Ws <span class="pl-k">=</span> <span class="pl-c1">dg</span>.(<span class="pl-c1">reverse</span>(O<span class="pl-k">.</span>tensors))
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
        W <span class="pl-k">=</span> Ws[i]
        M <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[i]

        <span class="pl-c1">@reduce</span> N[(báµ¢â‚‹â‚, aáµ¢â‚‹â‚), (báµ¢, aáµ¢), Ïƒáµ¢] <span class="pl-k">:=</span>  <span class="pl-c1">sum</span>(Ïƒâ€²áµ¢) W[báµ¢â‚‹â‚, báµ¢, Ïƒáµ¢, Ïƒâ€²áµ¢] <span class="pl-k">*</span> M[aáµ¢â‚‹â‚, aáµ¢, Ïƒâ€²áµ¢]
        <span class="pl-c1">push!</span>(tensors, N)
    <span class="pl-k">end</span>
    <span class="pl-c1">adjoint</span>(<span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors))
<span class="pl-k">end</span></pre></div>
<p></p>
</details>
<p></p>
</details>
<h3><a id="user-content-compression" class="anchor" aria-hidden="true" href="#compression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Compression</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre>
<span class="pl-k">function</span> <span class="pl-en">compress</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, to_the<span class="pl-k">::</span><span class="pl-c1">Right</span>; Dcut<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span><span class="pl-c1">typemax</span>(Int)) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    
    B <span class="pl-k">=</span> Ïˆ[<span class="pl-c1">1</span>]
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(B[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    
    <span class="pl-c1">@cast</span> Bm[(ÏƒÂ¹, aâ°), aÂ¹] <span class="pl-k">|=</span> B[aâ°, aÂ¹, ÏƒÂ¹]
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Bm, rank<span class="pl-k">=</span>Dcut)
    <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)</span>

    <span class="pl-c1">@cast</span> A[aâ°, aÂ¹, ÏƒÂ¹] <span class="pl-k">|=</span> U[(ÏƒÂ¹, aâ°), aÂ¹] (ÏƒÂ¹<span class="pl-c1">:d</span>)
    <span class="pl-c1">push!</span>(tensors, A)
    
    <span class="pl-k">for</span> i <span class="pl-k">âˆˆ</span> <span class="pl-c1">2</span><span class="pl-k">:</span>L
        B <span class="pl-k">=</span> Ïˆ[i]
        d <span class="pl-k">=</span> <span class="pl-c1">length</span>(B[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])

        <span class="pl-c1">@tensor</span> M[aâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">:=</span> (<span class="pl-c1">Diagonal</span>(S)<span class="pl-k">*</span>V<span class="pl-k">'</span>)[aâ±â»Â¹, aâ±â»Â¹â€²] <span class="pl-k">*</span> B[aâ±â»Â¹â€², aâ±, Ïƒâ±]
        <span class="pl-c1">@cast</span>   Mm[(Ïƒâ±, aâ±â»Â¹), aâ±] <span class="pl-k">|=</span> M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Mm, rank<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)</span>

        <span class="pl-c1">@cast</span> A[aâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">|=</span> U[(Ïƒâ±, aâ±â»Â¹), aâ±] (Ïƒâ±<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, A)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(tensors), <span class="pl-c1">Left</span>()
<span class="pl-k">end</span>

<span class="pl-en">leftcanonical</span>(Ïˆ) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, right)[<span class="pl-c1">1</span>]

<span class="pl-k">function</span> <span class="pl-en">compress</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, to_the<span class="pl-k">::</span><span class="pl-c1">Left</span>; Dcut<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span><span class="pl-c1">typemax</span>(Int)) <span class="pl-k">where</span> {L, T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    
    A <span class="pl-k">=</span> Ïˆ[L]
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(A[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    <span class="pl-c1">@cast</span> Am[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] <span class="pl-k">|=</span> A[aá´¸â»Â¹, aá´¸, Ïƒá´¸]
    
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Am, rank<span class="pl-k">=</span>Dcut)
    <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)    </span>

    <span class="pl-c1">@cast</span> B[aá´¸â»Â¹, aá´¸, Ïƒá´¸] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aá´¸â»Â¹, (Ïƒá´¸, aá´¸)] (Ïƒá´¸<span class="pl-c1">:d</span>)
    <span class="pl-c1">push!</span>(tensors, B)
    
    <span class="pl-k">for</span> i <span class="pl-k">âˆˆ</span> (L<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>
        A <span class="pl-k">=</span> Ïˆ[i]
        d <span class="pl-k">=</span> <span class="pl-c1">length</span>(A[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
        <span class="pl-c1">@tensor</span> M[aâ±â»Â¹, aâ±, Ïƒâ±]    <span class="pl-k">:=</span> A[aâ±â»Â¹, aâ±â€², Ïƒâ±] <span class="pl-k">*</span> (U <span class="pl-k">*</span> <span class="pl-c1">Diagonal</span>(S))[aâ±â€², aâ±]
        <span class="pl-c1">@cast</span>   Mm[aâ±â»Â¹, (Ïƒâ±, aâ±)] <span class="pl-k">|=</span> M[aâ±â»Â¹, aâ±, Ïƒâ±]
        
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">psvd</span>(Mm, rank<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>S = S/âˆšsum(S .^ 2)</span>

        <span class="pl-c1">@cast</span> B[aâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aâ±â»Â¹, (Ïƒâ±, aâ±)] (Ïƒâ±<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, B)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPS</span><span class="pl-c1">{L, T}</span>(<span class="pl-c1">reverse</span>(tensors)), <span class="pl-c1">Right</span>()
<span class="pl-k">end</span>

<span class="pl-en">rightcanonical</span>(Ïˆ) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, left)[<span class="pl-c1">1</span>]

<span class="pl-en">compress</span>(Ïˆ; Dcut) <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, left, Dcut<span class="pl-k">=</span>Dcut)[<span class="pl-c1">1</span>]
</pre></div>
<p></p>
</details>
<h3><a id="user-content-iterative-ground-state-search" class="anchor" aria-hidden="true" href="#iterative-ground-state-search"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Iterative Ground State Search</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">R_exprs</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>) <span class="pl-k">where</span> {L, T}
    R_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    R_ex <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> L<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>
        R_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_R_ex</span>(Ïˆ[l], H[l], R_ex) 
        <span class="pl-c1">push!</span>(R_exs, R_ex)
    <span class="pl-k">end</span>
    <span class="pl-c1">reverse</span>(R_exs)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> function preallocate_hs(Ïˆ::MPS{L, T}) where {L, T}</span>
<span class="pl-c"><span class="pl-c">#</span>     h_tnsrs = map(Ïˆ.tensors) do M</span>
<span class="pl-c"><span class="pl-c">#</span>         DË¡â»Â¹, DË¡, d = size(M)</span>
<span class="pl-c"><span class="pl-c">#</span>         Array{T, 6}(undef, d, DË¡â»Â¹, DË¡, d, DË¡â»Â¹, DË¡)</span>
<span class="pl-c"><span class="pl-c">#</span>     end</span>
<span class="pl-c"><span class="pl-c">#</span> end</span>


<span class="pl-k">function</span> <span class="pl-en">sweep!</span>(<span class="pl-k">::</span><span class="pl-c1">Right</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, R_exs) <span class="pl-k">where</span> {L, T}
    L_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    L_ex  <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    E <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)
        W <span class="pl-k">=</span> H[l]
        
        E, A, SVp <span class="pl-k">=</span> <span class="pl-c1">eigenproblem</span>(right, Ïˆ[l], L_ex, W, R_exs[l])
        Ïˆ<span class="pl-k">.</span>tensors[l] <span class="pl-k">=</span> A

        L_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_L_ex</span>(A, W, L_ex)
        <span class="pl-c1">push!</span>(L_exs, L_ex)

        Bp1 <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">+</span><span class="pl-c1">1</span>]
        <span class="pl-c1">@tensor</span> Mp1[sâ±â»Â¹, aâ±, Ïƒâ±] <span class="pl-k">:=</span> SVp[sâ±â»Â¹, aâ±â»Â¹] <span class="pl-k">*</span> Bp1[aâ±â»Â¹, aâ±, Ïƒâ±]
        Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> Mp1
    <span class="pl-k">end</span>
    L_exs, E
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">sweep!</span>(<span class="pl-k">::</span><span class="pl-c1">Left</span>, Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>, L_exs) <span class="pl-k">where</span> {L, T}
    R_exs <span class="pl-k">=</span> Array{T, <span class="pl-c1">3</span>}[]
    R_ex  <span class="pl-k">=</span> <span class="pl-c1">ones</span>(T, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
    E <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> l <span class="pl-k">in</span> L<span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>
        W <span class="pl-k">=</span> H[l]

        E, US, B <span class="pl-k">=</span> <span class="pl-c1">eigenproblem</span>(left, Ïˆ[l], L_exs[l<span class="pl-k">-</span><span class="pl-c1">1</span>], W, R_ex)
        Ïˆ<span class="pl-k">.</span>tensors[l] <span class="pl-k">=</span> B

        R_ex <span class="pl-k">=</span> <span class="pl-c1">iterate_R_ex</span>(B, W, R_ex) 
        <span class="pl-c1">push!</span>(R_exs, R_ex)

        Am1 <span class="pl-k">=</span> Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">-</span><span class="pl-c1">1</span>]
        <span class="pl-c1">@tensor</span> Mm1[aË¡â»Â², sË¡â»Â¹, ÏƒË¡â»Â¹] <span class="pl-k">:=</span>  Am1[aË¡â»Â², aË¡â»Â¹â€², ÏƒË¡â»Â¹] <span class="pl-k">*</span> US[aË¡â»Â¹â€², sË¡â»Â¹]
        Ïˆ<span class="pl-k">.</span>tensors[l<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> Mm1
    <span class="pl-k">end</span>
    R_exs, E
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">h_matrix</span>(L_ex<span class="pl-k">::</span><span class="pl-c1">Array{T,3}</span>, W<span class="pl-k">::</span><span class="pl-c1">Array{T,4}</span>, R_ex<span class="pl-k">::</span><span class="pl-c1">Array{T,3}</span>) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensor</span> h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²] <span class="pl-k">:=</span> L_ex[bË¡â»Â¹, aË¡â»Â¹, aË¡â»Â¹â€²] <span class="pl-k">*</span> W[bË¡â»Â¹, bË¡, ÏƒË¡, ÏƒË¡â€²] <span class="pl-k">*</span> R_ex[bË¡, aË¡, aË¡â€²]
    <span class="pl-c1">@cast</span> h[(ÏƒË¡, aË¡â»Â¹, aË¡), (ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²)] <span class="pl-k">:=</span> h[ÏƒË¡, aË¡â»Â¹, aË¡, ÏƒË¡â€², aË¡â»Â¹â€², aË¡â€²]
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">eigenproblem</span>(dir<span class="pl-k">::</span><span class="pl-c1">Direction</span>, M<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>, L_ex<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>, W<span class="pl-k">::</span><span class="pl-c1">Array{T, 4}</span>, R_ex<span class="pl-k">::</span><span class="pl-c1">Array{T, 3}</span>) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@cast</span> v[(ÏƒË¡, aË¡â»Â¹, aË¡)] <span class="pl-k">|=</span> M[aË¡â»Â¹, aË¡, ÏƒË¡]
    
    h <span class="pl-k">=</span> <span class="pl-c1">h_matrix</span>(L_ex, W, R_ex)
    Î», Î¦ <span class="pl-k">=</span> <span class="pl-c1">eigs</span>(h, v0<span class="pl-k">=</span>v, nev<span class="pl-k">=</span><span class="pl-c1">1</span>, which<span class="pl-k">=</span><span class="pl-c1">:SR</span>)
    E  <span class="pl-k">=</span> Î»[<span class="pl-c1">1</span>]<span class="pl-k">::</span><span class="pl-c1">T</span> 
    vâ° <span class="pl-k">=</span> (Î¦[:,<span class="pl-c1">1</span>])<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>

    (E, <span class="pl-c1">split_tensor</span>(dir, vâ°, <span class="pl-c1">size</span>(M))<span class="pl-k">...</span>)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">split_tensor</span>(<span class="pl-k">::</span><span class="pl-c1">Right</span>, vâ°<span class="pl-k">::</span><span class="pl-c1">Vector</span>, (DË¡â»Â¹, DË¡, d))
    <span class="pl-c1">@cast</span> Mm[(ÏƒË¡, aË¡â»Â¹), aË¡] <span class="pl-k">:=</span> vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹<span class="pl-c1">:D</span>Ë¡â»Â¹, aË¡<span class="pl-c1">:D</span>Ë¡, ÏƒË¡<span class="pl-c1">:d</span>)
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(Mm)
    <span class="pl-c1">@cast</span> A[aË¡â»Â¹, aË¡, ÏƒË¡] <span class="pl-k">|=</span> U[(ÏƒË¡, aË¡â»Â¹), aË¡] (ÏƒË¡<span class="pl-c1">:d</span>, aË¡â»Â¹<span class="pl-c1">:D</span>Ë¡â»Â¹, aË¡<span class="pl-c1">:D</span>Ë¡)
    A, <span class="pl-c1">Diagonal</span>(S)<span class="pl-k">*</span>V<span class="pl-k">'</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">split_tensor</span>(<span class="pl-k">::</span><span class="pl-c1">Left</span>, vâ°<span class="pl-k">::</span><span class="pl-c1">Vector</span>, (DË¡â»Â¹, DË¡, d))
    <span class="pl-c1">@cast</span> Mm[aË¡â»Â¹, (ÏƒË¡, aË¡)] <span class="pl-k">|=</span> vâ°[(ÏƒË¡, aË¡â»Â¹, aË¡)] (aË¡â»Â¹<span class="pl-c1">:D</span>Ë¡â»Â¹, aË¡<span class="pl-c1">:D</span>Ë¡, ÏƒË¡<span class="pl-c1">:d</span>)
    U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(Mm)
    <span class="pl-c1">@cast</span> B[aË¡â»Â¹, aË¡, ÏƒË¡] <span class="pl-k">|=</span> V<span class="pl-k">'</span>[aË¡â»Â¹, (ÏƒË¡, aË¡)] (ÏƒË¡<span class="pl-c1">:d</span>)
    U<span class="pl-k">*</span><span class="pl-c1">Diagonal</span>(S), B
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">iterate_R_ex</span>(B, W, R_ex) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensoropt</span> R_exâ€²[bâ±â»Â¹, aâ±â»Â¹, aâ±â»Â¹â€²] <span class="pl-k">:=</span> (<span class="pl-c1">conj</span>.(B))[aâ±â»Â¹,aâ±,Ïƒâ±] <span class="pl-k">*</span> W[bâ±â»Â¹,bâ±,Ïƒâ±,Ïƒâ±â€²] <span class="pl-k">*</span> B[aâ±â»Â¹â€²,aâ±â€²,Ïƒâ±â€²] <span class="pl-k">*</span> R_ex[bâ±,aâ±,aâ±â€²]
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">iterate_L_ex</span>(A, W, L_ex) <span class="pl-k">where</span> {T}
    <span class="pl-c1">@tensoropt</span> L_exâ€²[bË¡, aË¡, aË¡â€²] <span class="pl-k">:=</span> L_ex[bË¡â»Â¹,aË¡â»Â¹,aË¡â»Â¹â€²] <span class="pl-k">*</span> (<span class="pl-c1">conj</span>.(A))[aË¡â»Â¹,aË¡,ÏƒË¡] <span class="pl-k">*</span> W[bË¡â»Â¹,bË¡,ÏƒË¡,ÏƒË¡â€²] <span class="pl-k">*</span> A[aË¡â»Â¹â€²,aË¡â€²,ÏƒË¡â€²]
<span class="pl-k">end</span>


<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    ground_state(Ïˆ::MPS{L, T}, H::MPO{L, T}; maxiter=10, quiet=false, Ïµ=1e-8) where {L, T}</span>
<span class="pl-s"></span>
<span class="pl-s">Perform the finite system density matrix renormalization group</span>
<span class="pl-s">algorithm. First this will build up the R expressions, then do right</span>
<span class="pl-s">and left sweeps until either</span>
<span class="pl-s"> 1) The state converges to an eigenstate `Ï•` such that</span>
<span class="pl-s">    Ï•' * H * H * Ï• â‰ˆ (Ï•' * H * Ï•) </span>
<span class="pl-s">to the requested tolerance `Ïµ`</span>
<span class="pl-s"> 2) The energy eigenvalue stops changing (possible signaling the algorithm is </span>
<span class="pl-s">stuck in a local minimum)</span>
<span class="pl-s"> 3) The number of full (right and left) sweeps exceeds `maxiter`. </span>
<span class="pl-s"></span>
<span class="pl-s">Setting `quiet=true` will suppress notifications about the algorithm's</span>
<span class="pl-s">progress but *not* warnings due to non-convergence.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">ground_state</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO{L, T}</span>; maxiter<span class="pl-k">=</span><span class="pl-c1">10</span>, quiet<span class="pl-k">=</span><span class="pl-c1">false</span>, Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-8</span>) <span class="pl-k">where</span> {L, T}
    Ï• <span class="pl-k">=</span> Ïˆ <span class="pl-k">|&gt;</span> copy

    quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computing R expressions<span class="pl-pds">"</span></span>)
    R_exs <span class="pl-k">=</span> <span class="pl-c1">R_exprs</span>(Ïˆ, H)

    converged <span class="pl-k">=</span> <span class="pl-c1">false</span>
    count     <span class="pl-k">=</span> <span class="pl-c1">0</span>
    Eâ‚€ <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-c1">enable_cache</span>(maxsize<span class="pl-k">=</span><span class="pl-c1">5</span><span class="pl-k">*</span><span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">9</span>)
    <span class="pl-k">while</span> <span class="pl-c1">not</span>(converged)
        quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Performing right sweep<span class="pl-pds">"</span></span>)
        L_exs, Eâ‚€â€² <span class="pl-k">=</span> <span class="pl-c1">sweep!</span>(right, Ï•, H, R_exs)

        quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Performing left sweep<span class="pl-pds">"</span></span>)
        R_exs, Eâ‚€  <span class="pl-k">=</span> <span class="pl-c1">sweep!</span>(left,  Ï•, H, L_exs)

        count <span class="pl-k">+=</span> <span class="pl-c1">1</span>
        <span class="pl-k">if</span> <span class="pl-c1">iseigenstate</span>(Ï•, H, Ïµ<span class="pl-k">=</span>Ïµ)
            quiet <span class="pl-k">||</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Converged in <span class="pl-v">$count</span> iterations<span class="pl-pds">"</span></span>)
            converged <span class="pl-k">=</span> <span class="pl-c1">true</span>
        <span class="pl-k">elseif</span> count <span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> Eâ‚€ <span class="pl-k">â‰ˆ</span> Eâ‚€â€²
                <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">Energy eigenvalue converged but state is not an eigenstate.</span>
<span class="pl-s">Consider either lowering your requested tolerance or </span>
<span class="pl-s">implementing a warm-up algorithm to avoid local minima.</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
            <span class="pl-k">break</span>
        <span class="pl-k">elseif</span> count <span class="pl-k">&gt;=</span> maxiter
            <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"</span>Did not converge in <span class="pl-v">$maxiter</span> iterations<span class="pl-pds">"</span></span>
            <span class="pl-k">break</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-c1">clear_cache</span>()
    Ï•, Eâ‚€
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">iseigenstate</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS</span>, H<span class="pl-k">::</span><span class="pl-c1">MPO</span>; Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-8</span>)
    Ï• <span class="pl-k">=</span> <span class="pl-c1">rightcanonical</span>(Ïˆ)
    <span class="pl-c1">isapprox</span>(Ï•<span class="pl-s"><span class="pl-pds">'</span> * (H * H * Ï•), (Ï•<span class="pl-pds">'</span></span> <span class="pl-k">*</span> (H <span class="pl-k">*</span> Ï•))<span class="pl-k">^</span><span class="pl-c1">2</span>, rtol<span class="pl-k">=</span>Ïµ)
<span class="pl-k">end</span>
</pre></div>
</details>
<p></p>
<h3><a id="user-content-correlation-functions" class="anchor" aria-hidden="true" href="#correlation-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Correlation Functions</h3>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    two_point_correlator((i, op_i)::Pair{Int, Matrix}, (j, op_j)::Pair{Int, Matrix}, L)</span>
<span class="pl-s"></span>
<span class="pl-s">Create an MPO on `L` sites (with bond dimension 1) representing identity operators everywhere except</span>
<span class="pl-s">sites `i` and `j` where `op_i` and `op_j` are inserted instead. ie.</span>
<span class="pl-s"></span>
<span class="pl-s">    ğŸ™ âŠ— ğŸ™ âŠ— ... âŠ— op_i âŠ— ğŸ™ âŠ— ... âŠ— op_j âŠ— ğŸ™ âŠ— ... âŠ— ğŸ™</span>
<span class="pl-s"></span>
<span class="pl-s">example: spin-spin correlation function</span>
<span class="pl-s"></span>
<span class="pl-s">we can construct âŸ¨Ïƒá¶»áµ¢Ïƒá¶»â±¼âŸ© on a 12 site lattice as</span>
<span class="pl-s">    Ïƒá¶» = [1 0; 0 -1]</span>
<span class="pl-s">    two_point_correlator(i=&gt;Ïƒá¶», j=&gt;Ïƒá¶», 12)  </span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">function</span> <span class="pl-en">two_point_correlator</span>((i, op_i), (j, op_j), L)
    d <span class="pl-k">=</span> <span class="pl-c1">size</span>(op_i)[<span class="pl-c1">1</span>]
    <span class="pl-c1">@assert</span> (<span class="pl-c1">size</span>(op_i) <span class="pl-k">==</span> (d, d)) <span class="pl-k">&amp;&amp;</span> (<span class="pl-c1">size</span>(op_j) <span class="pl-k">==</span> (d, d))
    <span class="pl-c1">@assert</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
    <span class="pl-c1">@assert</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L
    id <span class="pl-k">=</span> <span class="pl-c1">diagm</span>(<span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">ones</span>(Complex{Float64}, d))

    op_i_tnsr <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">convert</span>(Matrix{Complex{Float64}}, op_i), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d) 
    op_j_tnsr <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">convert</span>(Matrix{Complex{Float64}}, op_j), <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d)
    id_tnsr   <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(id, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, d, d)

    tensors <span class="pl-k">=</span> <span class="pl-c1">map</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>L) <span class="pl-k">do</span> l
        O_tnsr <span class="pl-k">=</span> (l <span class="pl-k">==</span> i ? op_i_tnsr : 
                  l <span class="pl-k">==</span> j ? op_j_tnsr : 
                  id_tnsr)
    <span class="pl-k">end</span> 
    <span class="pl-c1">MPO</span><span class="pl-c1">{L,Complex{Float64}}</span>(tensors)
<span class="pl-k">end</span>



</pre></div>
</details>
<p></p>
<h3><a id="user-content-imaginary-time-evolution" class="anchor" aria-hidden="true" href="#imaginary-time-evolution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Imaginary Time Evolution</h3>
<p>I donâ€™t think this works!</p>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Fixme! this does not appear to find ground states!</span>

<span class="pl-k">function</span> <span class="pl-en">_MPO_handed_time_evolver</span>(hs<span class="pl-k">::</span><span class="pl-c1">Vector{Matrix{T}}</span>, Ï„, L, d) <span class="pl-k">where</span> {T}
    tensors <span class="pl-k">=</span> Array{T, <span class="pl-c1">4</span>}[]
    <span class="pl-k">for</span> h <span class="pl-k">in</span> hs
        O <span class="pl-k">=</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span>Ï„<span class="pl-k">*</span>h)
        <span class="pl-c1">@cast</span> P[(Ïƒâ±, Ïƒâ±â€²), (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] <span class="pl-k">|=</span> O[(Ïƒâ±, Ïƒâ±âºÂ¹), (Ïƒâ±â€², Ïƒâ±âºÂ¹â€²)] (Ïƒâ±<span class="pl-c1">:d</span>, Ïƒâ±â€²<span class="pl-k">:</span>d)
        U, S, V <span class="pl-k">=</span> <span class="pl-c1">svd</span>(P)

        <span class="pl-c1">@cast</span> U[<span class="pl-c1">1</span>, k, Ïƒâ±, Ïƒâ±â€²]     <span class="pl-k">:=</span> U[(Ïƒâ±, Ïƒâ±â€²), k] <span class="pl-k">*</span> <span class="pl-k">âˆš</span>(S[k])      (Ïƒâ±<span class="pl-c1">:d</span>)
        <span class="pl-c1">@cast</span> Åª[k, <span class="pl-c1">1</span>, Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²] <span class="pl-k">:=</span> <span class="pl-k">âˆš</span>(S[k]) <span class="pl-k">*</span> V<span class="pl-k">'</span>[k, (Ïƒâ±âºÂ¹, Ïƒâ±âºÂ¹â€²)] (Ïƒâ±âºÂ¹<span class="pl-c1">:d</span>)
        <span class="pl-c1">push!</span>(tensors, U, Åª)
    <span class="pl-k">end</span>
    <span class="pl-c1">MPO</span><span class="pl-c1">{L, T}</span>(tensors)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">MPO_time_evolvers</span>(h1<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, hi<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, hL<span class="pl-k">::</span><span class="pl-c1">Matrix</span>, Ï„, L, d)
    <span class="pl-k">if</span> <span class="pl-c1">iseven</span>(L)
        odd_hs  <span class="pl-k">=</span> [h1, [hi <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>]
        even_hs <span class="pl-k">=</span> [[hi <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, hL]
    <span class="pl-k">else</span>
        odd_hs  <span class="pl-k">=</span> [h1, [hi <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]<span class="pl-k">.</span><span class="pl-k">..</span>, hL]
        even_hs <span class="pl-k">=</span> [hi <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)]
    <span class="pl-k">end</span>
    
    Uodd  <span class="pl-k">=</span> <span class="pl-c1">_MPO_handed_time_evolver</span>(odd_hs, Ï„, L, d)
    Ueven <span class="pl-k">=</span> <span class="pl-c1">_MPO_handed_time_evolver</span>(even_hs, Ï„, L, d)
    Uodd, Ueven
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">imag_time_evolution</span>(Ïˆ<span class="pl-k">::</span><span class="pl-c1">MPS{L, T}</span>, h1<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, hi<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, hL<span class="pl-k">::</span><span class="pl-c1">Matrix{T}</span>, 
                             Î², N, Dcut) <span class="pl-k">where</span> {L, T}
    <span class="pl-c1">@warn</span> <span class="pl-s"><span class="pl-pds">"</span>This probably still doesn't work!<span class="pl-pds">"</span></span>
    Ï„ <span class="pl-k">=</span> Î²<span class="pl-k">/</span>N
    d <span class="pl-k">=</span> <span class="pl-c1">length</span>(Ïˆ[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :])
    Ï• <span class="pl-k">=</span> Ïˆ  <span class="pl-c"><span class="pl-c">#</span> Ground state guess</span>
    dir <span class="pl-k">=</span> left
    Uodd, Ueven <span class="pl-k">=</span> <span class="pl-c1">MPO_time_evolvers</span>(h1, hi, hL, Ï„, L, d)
    <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        Ï•<span class="pl-c1">1</span>, dir <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Uodd  <span class="pl-k">*</span> Ï•,  dir, Dcut<span class="pl-k">=</span>Dcut)
        Ï•,  dir <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ueven <span class="pl-k">*</span> Ï•<span class="pl-c1">1</span>, dir, Dcut<span class="pl-k">=</span>Dcut)
        <span class="pl-c"><span class="pl-c">#</span>Ï•,  dir = compress(Uodd  * Ï•2, dir, Dcut=Dcut)</span>
    <span class="pl-k">end</span>
    Ï•
<span class="pl-k">end</span></pre></div>
</details>
<p></p>
<h2><a id="user-content-tests" class="anchor" aria-hidden="true" href="#tests"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tests</h2>
<details><summary>Source</summary>
<p>
</p><div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Test, MatrixProductStates, SparseArrays, Arpack

<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>TFIM   <span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
    g <span class="pl-k">=</span> <span class="pl-c1">1.0</span>; L <span class="pl-k">=</span> <span class="pl-c1">7</span>

    <span class="pl-k">function</span> <span class="pl-en">H_TFIM</span>(g, L)
        id <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
              <span class="pl-c1">0</span>  <span class="pl-c1">1</span>]
        ÏƒË£ <span class="pl-k">=</span> [<span class="pl-c1">0</span>  <span class="pl-c1">1</span>; 
              <span class="pl-c1">1</span>  <span class="pl-c1">0</span>]
        Ïƒá¶» <span class="pl-k">=</span> [<span class="pl-c1">1</span>  <span class="pl-c1">0</span>; 
              <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
        W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
        W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> id    
        W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>Ïƒá¶»  
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>g<span class="pl-k">*</span>ÏƒË£
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span> Ïƒá¶»   
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span> id   

        <span class="pl-k">return</span> <span class="pl-c1">MPO</span>(W_tnsr, L)
    <span class="pl-k">end</span>
    H <span class="pl-k">=</span> <span class="pl-c1">H_TFIM</span>(g, L)
    Ïˆ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, <span class="pl-c1">100</span>, <span class="pl-c1">2</span>)
    
    ÏˆÌƒ <span class="pl-k">=</span> <span class="pl-c1">compress</span>(Ïˆ, left, Dcut<span class="pl-k">=</span><span class="pl-c1">80</span>)[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> Note: no actual information is lost in this </span>
    <span class="pl-c"><span class="pl-c">#</span> compression because of the small size of the chain</span>

    <span class="pl-c1">@test</span>              ÏˆÌƒ<span class="pl-s"><span class="pl-pds">'</span>ÏˆÌƒ â‰ˆ 1</span>
<span class="pl-s">    @test          Ïˆ<span class="pl-pds">'</span></span>Ïˆ<span class="pl-k">/</span>Ïˆ<span class="pl-s"><span class="pl-pds">'</span>Ïˆ â‰ˆ ÏˆÌƒ<span class="pl-pds">'</span></span>ÏˆÌƒ
    <span class="pl-c1">@test</span> ((Ïˆ<span class="pl-s"><span class="pl-pds">'</span>*(H*Ïˆ))/Ïˆ<span class="pl-pds">'</span></span>Ïˆ) <span class="pl-k">â‰ˆ</span> (ÏˆÌƒ<span class="pl-s"><span class="pl-pds">'</span> * (H * ÏˆÌƒ))/ÏˆÌƒ<span class="pl-pds">'</span></span>ÏˆÌƒ
    <span class="pl-c1">@test</span> ((Ïˆ<span class="pl-s"><span class="pl-pds">'</span>*(H*Ïˆ))/Ïˆ<span class="pl-pds">'</span></span>Ïˆ) <span class="pl-k">â‰ˆ</span> (ÏˆÌƒ<span class="pl-s"><span class="pl-pds">'</span> * (H * Ïˆ))/ÏˆÌƒ<span class="pl-pds">'</span></span>Ïˆ

    Ï•, Eâ‚€ <span class="pl-k">=</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
    <span class="pl-c1">@test</span> Ï•<span class="pl-s"><span class="pl-pds">'</span> * H * H * Ï• â‰ˆ (Ï•<span class="pl-pds">'</span></span><span class="pl-k">*</span>H<span class="pl-k">*</span>Ï•)<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-k">end</span>

<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>Hubbard<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>

    id <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span>
          <span class="pl-c1">0</span> <span class="pl-c1">1</span>]
    c  <span class="pl-k">=</span> [<span class="pl-c1">0</span> <span class="pl-c1">0</span>
          <span class="pl-c1">1</span> <span class="pl-c1">0</span>] <span class="pl-c"><span class="pl-c">#</span>Anti commuting matrix</span>
    c_up <span class="pl-k">=</span> c  âŠ— id
    c_dn <span class="pl-k">=</span> id âŠ— c
    idÂ²  <span class="pl-k">=</span> id âŠ— id
    n_up <span class="pl-k">=</span> c_up<span class="pl-k">'</span> <span class="pl-k">*</span> c_up
    n_dn <span class="pl-k">=</span> c_dn<span class="pl-k">'</span> <span class="pl-k">*</span> c_dn

    P_up <span class="pl-k">=</span> (idÂ² <span class="pl-k">-</span> <span class="pl-c1">2</span>c_up<span class="pl-k">'</span><span class="pl-k">*</span>c_up) <span class="pl-c"><span class="pl-c">#</span> Spin up parity operator</span>
    P_dn <span class="pl-k">=</span> (idÂ² <span class="pl-k">-</span> <span class="pl-c1">2</span>c_dn<span class="pl-k">'</span><span class="pl-k">*</span>c_dn) <span class="pl-c"><span class="pl-c">#</span> Spin down parity operator</span>

    <span class="pl-k">function</span> <span class="pl-en">H_hub</span>(U, Î¼, L)
        W_tnsr <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Complex{Float64}, <span class="pl-c1">6</span>, <span class="pl-c1">6</span>, <span class="pl-c1">4</span>, <span class="pl-c1">4</span>)
        W_tnsr[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> idÂ²
        W_tnsr[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_up<span class="pl-k">'</span>
        W_tnsr[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_dn<span class="pl-k">'</span>
        W_tnsr[<span class="pl-c1">4</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_up
        W_tnsr[<span class="pl-c1">5</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> c_dn
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">1</span>, :, :] <span class="pl-k">=</span> U<span class="pl-k">*</span>(n_up <span class="pl-k">*</span> n_dn) <span class="pl-k">-</span> Î¼<span class="pl-k">*</span>(n_up <span class="pl-k">+</span> n_dn)
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">2</span>, :, :] <span class="pl-k">=</span>  c_up  <span class="pl-k">*</span> P_up  <span class="pl-c"><span class="pl-c">#</span> Must multiply by the parity operator to get </span>
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">3</span>, :, :] <span class="pl-k">=</span>  c_dn  <span class="pl-k">*</span> P_dn  <span class="pl-c"><span class="pl-c">#</span> correct off-site commutation relations!</span>
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">4</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>c_up<span class="pl-k">'</span> <span class="pl-k">*</span> P_up
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">5</span>, :, :] <span class="pl-k">=</span> <span class="pl-k">-</span>c_dn<span class="pl-k">'</span> <span class="pl-k">*</span> P_dn
        W_tnsr[<span class="pl-c1">6</span>, <span class="pl-c1">6</span>, :, :] <span class="pl-k">=</span> idÂ²
        <span class="pl-c1">MPO</span>(W_tnsr, L)
    <span class="pl-k">end</span>

    <span class="pl-k">function</span> <span class="pl-en">solve_hub</span>(U, Î¼, L; retfull<span class="pl-k">=</span><span class="pl-c1">true</span>, quiet<span class="pl-k">=</span><span class="pl-c1">true</span>)
        H <span class="pl-k">=</span> <span class="pl-c1">H_hub</span>(U, Î¼, L)
        Ïˆ <span class="pl-k">=</span> <span class="pl-c1">randn</span>(MPS{L, Complex{Float64}}, <span class="pl-c1">100</span>, <span class="pl-c1">4</span>)
        (Ï•, Eâ‚€), t, bytes <span class="pl-k">=</span> <span class="pl-c1">@timed</span> <span class="pl-c1">ground_state</span>(Ïˆ, H, Ïµ<span class="pl-k">=</span><span class="pl-c1">1e-5</span>, quiet<span class="pl-k">=</span>quiet)

        (Ï•<span class="pl-k">=</span>Ï•, Eâ‚€<span class="pl-k">=</span>Eâ‚€, H<span class="pl-k">=</span>H, t<span class="pl-k">=</span>t, Gbytes<span class="pl-k">=</span>bytes<span class="pl-k">/</span><span class="pl-c1">1e9</span>)
    <span class="pl-k">end</span>

    <span class="pl-k">function</span> <span class="pl-en">Hub_ED</span>(U, Î¼, L,)
        UÌ‚ <span class="pl-k">=</span> U<span class="pl-k">*</span>(n_up <span class="pl-k">*</span> n_dn) <span class="pl-k">-</span> Î¼<span class="pl-k">*</span>(n_up <span class="pl-k">+</span> n_dn)
        <span class="pl-en">c_dg_up</span>(i) <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j ? c_up<span class="pl-k">'</span> : idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">cup</span>(i)     <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j ? c_up  : idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">c_dg_dn</span>(i) <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j ? c_dn<span class="pl-k">'</span> : idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-en">cdn</span>(i)     <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j ? c_dn  : idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        UÌ‚<span class="pl-en">f</span>(i)      <span class="pl-k">=</span> <span class="pl-c1">foldl</span>(âŠ—, <span class="pl-c1">sparse</span>.([i<span class="pl-k">==</span>j ? UÌ‚     : idÂ² <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>L]))
        <span class="pl-k">function</span> <span class="pl-en">c_dg_c</span>(i) 
            out <span class="pl-k">=</span> <span class="pl-c1">c_dg_up</span>(i)<span class="pl-k">*</span><span class="pl-c1">cup</span>(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">c_dg_dn</span>(i)<span class="pl-k">*</span><span class="pl-c1">cdn</span>(i<span class="pl-k">+</span><span class="pl-c1">1</span>)
            out <span class="pl-k">+</span> out<span class="pl-k">'</span>
        <span class="pl-k">end</span>
        H <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">sum</span>(c_dg_c, <span class="pl-c1">1</span><span class="pl-k">:</span>(L<span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">+</span> <span class="pl-c1">sum</span>(UÌ‚f, <span class="pl-c1">1</span><span class="pl-k">:</span>L)

        Î», Ï• <span class="pl-k">=</span> <span class="pl-c1">eigs</span>(H, nev<span class="pl-k">=</span><span class="pl-c1">1</span>, which<span class="pl-k">=</span><span class="pl-c1">:SR</span>)
        (Ï•<span class="pl-s"><span class="pl-pds">'</span>H*Ï•)[]</span>
<span class="pl-s">    end</span>
<span class="pl-s"></span>
<span class="pl-s">   </span>
<span class="pl-s">    U = 3.0; Î¼ = -1.0; L = 4</span>
<span class="pl-s">    H = H_hub(U, Î¼, L)</span>
<span class="pl-s"></span>
<span class="pl-s">    Ï•, Eâ‚€ = solve_hub(U, Î¼, L, retfull=true, quiet=true)</span>
<span class="pl-s">    @test Ï•<span class="pl-pds">'</span></span> <span class="pl-k">*</span> H <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï• <span class="pl-k">â‰ˆ</span> (Ï•<span class="pl-s"><span class="pl-pds">'</span>*H*Ï•)^2  # Make sure energy is eigenvalue</span>
<span class="pl-s">    @test Ï•<span class="pl-pds">'</span></span> <span class="pl-k">*</span> H <span class="pl-k">*</span> Ï• <span class="pl-k">â‰ˆ</span> Eâ‚€              <span class="pl-c"><span class="pl-c">#</span> make sure eigenvalue matches one produced by alogrithm</span>
    <span class="pl-c1">@test</span> Ï•<span class="pl-s"><span class="pl-pds">'</span> * H * Ï• â‰ˆ Hub_ED(U, Î¼, L) # check against exact diagonalization</span>
<span class="pl-s">end</span>
<span class="pl-s"></span></pre></div>
</details>
<p></p>
</article></div>