<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-parameterizedfunctionsjl" class="anchor" aria-hidden="true" href="#parameterizedfunctionsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ParameterizedFunctions.jl</h1>
<p><a href="https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" rel="nofollow"><img src="https://camo.githubusercontent.com/063a520f1733d1b53d1e2fdb37b70a8016dd36f6/68747470733a2f2f6261646765732e6769747465722e696d2f4a756c69614469666645712f4c6f6262792e737667" alt="Join the chat at https://gitter.im/JuliaDiffEq/Lobby" data-canonical-src="https://badges.gitter.im/JuliaDiffEq/Lobby.svg" style="max-width:100%;"></a>
<a href="https://travis-ci.org/JuliaDiffEq/ParameterizedFunctions.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d2b121a8162788c3a6c9aa135bd29ad9e38bc048/68747470733a2f2f7472617669732d63692e6f72672f4a756c69614469666645712f506172616d65746572697a656446756e6374696f6e732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Travis" data-canonical-src="https://travis-ci.org/JuliaDiffEq/ParameterizedFunctions.jl.svg?branch=master" style="max-width:100%;"></a> <a href="https://ci.appveyor.com/project/ChrisRackauckas/parameterizedfunctions-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d8af53a631d52d9f58056fd6cf4a666c9032804e/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6b366237643836646462617331616a6b3f7376673d74727565" alt="AppVeyor" data-canonical-src="https://ci.appveyor.com/api/projects/status/k6b7d86ddbas1ajk?svg=true" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/JuliaDiffEq/ParameterizedFunctions.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c32de3d693f98645e826ed3e6432f7451599c4cc/68747470733a2f2f636f6465636f762e696f2f67682f4a756c69614469666645712f506172616d65746572697a656446756e6374696f6e732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/JuliaDiffEq/ParameterizedFunctions.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<h2><a id="user-content-note-that-this-library-is-deprecated-in-favor-of-modelingtoolkitjl-parameterizedfunctionsjl-will-continue-to-work-but-is-in-maitanance-mode" class="anchor" aria-hidden="true" href="#note-that-this-library-is-deprecated-in-favor-of-modelingtoolkitjl-parameterizedfunctionsjl-will-continue-to-work-but-is-in-maitanance-mode"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Note that this library is deprecated in favor of <a href="https://github.com/JuliaDiffEq/ModelingToolkit.jl">ModelingToolkit.jl</a>. ParameterizedFunctions.jl will continue to work but is in maitanance mode.</h2>
<p>ParameterizedFunctions.jl is a component of the JuliaDiffEq ecosystem which allows
for parameters to be explicitly present within functions. The interface which
ParameterizedFunctions describes allows for functionality which requires parameters,
such as parameter sensitivity analysis and parameter estimation, to be added to
the differential equation solvers of <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a>.
While the interface itself is of importance to ecosystem developers,
ParameterizedFunctions.jl provides user-facing macros which make a
<code>ParameterizedFunction</code> easy to define, and automatically
include optimizations like explicit Jacobian functions and explicit inverse Jacobian
functions for the differential equation solvers to take advantage of. The result
is an easy to use API which allows for more functionality and more performance
optimizations than could traditionally be offered.</p>
<p>test</p>
<h2><a id="user-content-the-basic-idea" class="anchor" aria-hidden="true" href="#the-basic-idea"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Basic Idea</h2>
<p><code>ParameterizedFunction</code> is a type which can be used in various JuliaDiffEq solvers where
the parameters must be accessible by the solver function. These use call overloading
generate a type which acts like a function <code>f(t,u,du)</code> but has access to many more
features. For example, a <code>ParameterizedFunction</code> can contain a function for the Jacobian
or Inverse Jacobian. If such functions exist, the solvers can use them to increase
the speed of computations. If they don't exist, the solvers will ignore them. Since
<code>ParameterizedFunction</code> is a subtype of <code>Function</code>, these can be used anywhere that
a function can be used, just with the extra functionality ignored.</p>
<h2><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basic Usage</h2>
<h3><a id="user-content-ode-macros" class="anchor" aria-hidden="true" href="#ode-macros"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ODE Macros</h3>
<p>A helper macro is provided to make it easier to define a <code>ParameterizedFunction</code>,
and it will symbolically compute a bunch of extra functions to make the differential
equation solvers run faster. For example, to define the previous <code>LotkaVolterra</code>,
you can use the following command:</p>
<div class="highlight highlight-source-julia"><pre>f <span class="pl-k">=</span> <span class="pl-c1">@ode_def</span> LotkaVolterra <span class="pl-k">begin</span>
  dx <span class="pl-k">=</span> a<span class="pl-k">*</span>x <span class="pl-k">-</span> b<span class="pl-k">*</span>x<span class="pl-k">*</span>y
  dy <span class="pl-k">=</span> <span class="pl-k">-</span>c<span class="pl-k">*</span>y <span class="pl-k">+</span> d<span class="pl-k">*</span>x<span class="pl-k">*</span>y
<span class="pl-k">end</span> a b c d</pre></div>
<p>or you can define it anonymously:</p>
<div class="highlight highlight-source-julia"><pre>f <span class="pl-k">=</span> <span class="pl-c1">@ode_def</span> <span class="pl-k">begin</span>
  dx <span class="pl-k">=</span> a<span class="pl-k">*</span>x <span class="pl-k">-</span> b<span class="pl-k">*</span>x<span class="pl-k">*</span>y
  dy <span class="pl-k">=</span> <span class="pl-k">-</span>c<span class="pl-k">*</span>y <span class="pl-k">+</span> d<span class="pl-k">*</span>x<span class="pl-k">*</span>y
<span class="pl-k">end</span> a b c d</pre></div>
<p>The macro also defines the Jacobian <code>f'</code>. This is defined as an in-place Jacobian <code>f(Val{:jac},t,u,J)</code>.
This is calculated using SymEngine.jl automatically, so it's no effort on your part.
The symbolic inverse of the Jacobian is also computed, and an in-place function
for this is available as well as <code>f(Val{:invjac},t,u,iJ)</code>. If the Jacobians cannot be
computed, a warning is thrown and only the function itself is usable. The functions
<code>jac_exists(f)</code> and <code>invjac_exists(f)</code> can be used to see whether the Jacobian
and the function for its inverse exist.</p>
<h4><a id="user-content-extra-options" class="anchor" aria-hidden="true" href="#extra-options"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extra Options</h4>
<p>In most cases the <code>@ode_def</code> macro should be sufficient. This is because by default
the macro will simply calculate each function symbolically, and if it can't it
will simply throw a warning and move on. However, in extreme cases the symbolic
calculations may take a long time, in which case it is necessary to turn them
off. To do this, use the <code>ode_def_opts</code> function. The <code>@ode_def</code> macro simply defines the specifiable options:</p>
<div class="highlight highlight-source-julia"><pre>opts <span class="pl-k">=</span> <span class="pl-c1">Dict</span><span class="pl-c1">{Symbol,Bool}</span>(
      <span class="pl-c1">:build_tgrad</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>,
      <span class="pl-c1">:build_jac</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>,
      <span class="pl-c1">:build_expjac</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>,
      <span class="pl-c1">:build_invjac</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>,
      <span class="pl-c1">:build_invW</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>,
      <span class="pl-c1">:build_invW_t</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>,
      <span class="pl-c1">:build_hes</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>,
      <span class="pl-c1">:build_invhes</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>,
      <span class="pl-c1">:build_dpfuncs</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>)</pre></div>
<p>and calls the function <code>ode_def_opts(name::Symbol,opts,ex::Expr,params)</code>. Note that
params is an iterator holding expressions for the parameters.</p>
<p>In addition, one can also use their own function inside of the macro. For example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">f</span>(x,y,d) <span class="pl-k">=</span> <span class="pl-c1">erf</span>(x<span class="pl-k">*</span>y<span class="pl-k">/</span>d)
NJ <span class="pl-k">=</span> <span class="pl-c1">@ode_def</span> FuncTest <span class="pl-k">begin</span>
  dx <span class="pl-k">=</span> a<span class="pl-k">*</span>x <span class="pl-k">-</span> b<span class="pl-k">*</span>x<span class="pl-k">*</span>y
  dy <span class="pl-k">=</span> <span class="pl-k">-</span>c<span class="pl-k">*</span>y <span class="pl-k">+</span> <span class="pl-c1">f</span>(x,y,d)
<span class="pl-k">end</span> a b c d</pre></div>
<p>will do fine. The symbolic derivatives will not work unless you define a derivative
for <code>f</code>.</p>
<h4><a id="user-content-extra-macros" class="anchor" aria-hidden="true" href="#extra-macros"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extra Macros</h4>
<p>Instead of using <code>ode_def_opts</code> directly, one can use one of the following macros
to be more specific about what to not calculate. In increasing order of calculations:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@ode_def_bare</span>
<span class="pl-c1">@ode_def</span>
<span class="pl-c1">@ode_def_all</span></pre></div>
<h3><a id="user-content-extra-functions" class="anchor" aria-hidden="true" href="#extra-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extra Functions</h3>
<h4><a id="user-content-jacobian-function" class="anchor" aria-hidden="true" href="#jacobian-function"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jacobian Function</h4>
<p>The Jacobian overload is provided by overloading in the following manner:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> (p<span class="pl-k">::</span><span class="pl-c1">LotkaVolterra</span>)(<span class="pl-k">::</span><span class="pl-c1">Type{Val{:jac}}</span>,t,u,J)
  J[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span> p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]
  J[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>(p<span class="pl-k">.</span>b) <span class="pl-k">*</span> u[<span class="pl-c1">1</span>]
  J[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]
  J[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">3</span> <span class="pl-k">+</span> u[<span class="pl-c1">1</span>]
  <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<h4><a id="user-content-inverse-jacobian" class="anchor" aria-hidden="true" href="#inverse-jacobian"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inverse Jacobian</h4>
<p>The Inverse Jacobian overload is provided by overloading in the following manner:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> (p<span class="pl-k">::</span><span class="pl-c1">LotkaVolterra</span>)(<span class="pl-k">::</span><span class="pl-c1">Type{Val{:invjac}}</span>,t,u,J)
  J[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">-</span> (p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">1</span>] <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">/</span> ((p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">*</span> (<span class="pl-k">-</span><span class="pl-c1">3</span> <span class="pl-k">+</span> u[<span class="pl-c1">1</span>] <span class="pl-k">+</span> (p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">1</span>] <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">/</span> (p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>])))) <span class="pl-k">/</span> (p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>])
  J[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> (p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">1</span>]) <span class="pl-k">/</span> ((p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">*</span> (<span class="pl-k">-</span><span class="pl-c1">3</span> <span class="pl-k">+</span> u[<span class="pl-c1">1</span>] <span class="pl-k">+</span> (p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">1</span>] <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">/</span> (p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>])))
  J[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>(u[<span class="pl-c1">2</span>]) <span class="pl-k">/</span> ((p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">*</span> (<span class="pl-k">-</span><span class="pl-c1">3</span> <span class="pl-k">+</span> u[<span class="pl-c1">1</span>] <span class="pl-k">+</span> (p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">1</span>] <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">/</span> (p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>])))
  J[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>] <span class="pl-k">=</span> (<span class="pl-k">-</span><span class="pl-c1">3</span> <span class="pl-k">+</span> u[<span class="pl-c1">1</span>] <span class="pl-k">+</span> (p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">1</span>] <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]) <span class="pl-k">/</span> (p<span class="pl-k">.</span>a <span class="pl-k">-</span> p<span class="pl-k">.</span>b <span class="pl-k">*</span> u[<span class="pl-c1">2</span>])) <span class="pl-k">^</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
  <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<h4><a id="user-content-parameter-jacobian" class="anchor" aria-hidden="true" href="#parameter-jacobian"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parameter Jacobian</h4>
<p>For solvers which need parameters derivatives, specifying the functions can increase
performance. For our example, we allow the solvers to use the explicit derivatives
in the parameters by:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> (p<span class="pl-k">::</span><span class="pl-c1">LotkaVolterra</span>)(<span class="pl-k">::</span><span class="pl-c1">Type{Val{:paramjac}}</span>,J,u,p,t)
    J[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> u[<span class="pl-c1">1</span>] <span class="pl-k">*</span> <span class="pl-c1">1</span>
    J[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>(u[<span class="pl-c1">1</span>]) <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]
    J[<span class="pl-c1">1</span>, <span class="pl-c1">3</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span> <span class="pl-k">*</span> <span class="pl-c1">1</span>
    J[<span class="pl-c1">1</span>, <span class="pl-c1">4</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span> <span class="pl-k">*</span> <span class="pl-c1">1</span>
    J[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span> <span class="pl-k">*</span> <span class="pl-c1">1</span>
    J[<span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span> <span class="pl-k">*</span> <span class="pl-c1">1</span>
    J[<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>(u[<span class="pl-c1">2</span>])
    J[<span class="pl-c1">2</span>, <span class="pl-c1">4</span>] <span class="pl-k">=</span> u[<span class="pl-c1">1</span>] <span class="pl-k">*</span> u[<span class="pl-c1">2</span>]
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
</article></div>