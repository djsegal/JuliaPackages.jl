<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h3><a id="user-content-amlpipelinebasejl" class="anchor" aria-hidden="true" href="#amlpipelinebasejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>AMLPipelineBase.jl</h3>
<hr>
<table>
<thead>
<tr>
<th align="center"><strong>Documentation</strong></th>
<th align="center"><strong>Build Status</strong></th>
<th align="center"><strong>Help</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://ibm.github.io/AutoMLPipeline.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a> <a href="https://ibm.github.io/AutoMLPipeline.jl/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://github.com/IBM/AMLPipelineBase.jl/actions/workflows/ci.yml"><img src="https://github.com/IBM/AMLPipelineBase.jl/actions/workflows/ci.yml/badge.svg" alt="" style="max-width:100%;"></a> <a href="https://codecov.io/gh/IBM/AMLPipelineBase.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/3c706c86e09222879d4a6d9cc86d9c1b2f4ecdb1ee8d0f60422a54c2e19378d4/68747470733a2f2f636f6465636f762e696f2f67682f49424d2f414d4c506970656c696e65426173652e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="" data-canonical-src="https://codecov.io/gh/IBM/AMLPipelineBase.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://julialang.slack.com/" rel="nofollow"><img src="https://camo.githubusercontent.com/c192b6b30d22427a9ad86f7832a70c27f8dcbb028dae7dc2ca07181ef7dd9e13/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636861742d6f6e253230736c61636b2d79656c6c6f772e737667" alt="" data-canonical-src="https://img.shields.io/badge/chat-on%20slack-yellow.svg" style="max-width:100%;"></a> <a href="https://gitter.im/AutoMLPipelineLearning/community" rel="nofollow"><img src="https://camo.githubusercontent.com/6e67a683ed2377edfcc3fe7895b2878789000869c9d9fd6b4a3b3f3ef5e2284f/68747470733a2f2f6261646765732e6769747465722e696d2f7070616c6d65732f54534d4c2e6a6c2e737667" alt="" data-canonical-src="https://badges.gitter.im/ppalmes/TSML.jl.svg" style="max-width:100%;"></a></td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/IBM/AMLPipelineBase.jl">AMLPipelineBase.jl</a>
is the <strong>Base</strong> package of <a href="https://github.com/IBM/TSML.jl">TSML.jl</a>,
<a href="https://github.com/IBM/AutoMLPipeline.jl">AutoMLPipeline.jl</a>, and
<a href="https://github.com/IBM/Lale.jl">Lale.jl</a>.</p>
<p><strong>AMLPipelineBase</strong> is written in pure <strong>Julia</strong>. It exposes the abstract
types commonly shared by <strong>TSML</strong> and <strong>AutoMLPipeline</strong>.
It also contains basic data preprocessing routines and
learners for rapid prototyping. <strong>TSML</strong> extends <strong>AMLPipelineBase</strong> capability
by specializing in Time-Series workflow while <strong>AutoMLPipeline</strong>
focuses in ML pipeline optimization. Since
<strong>AMLPipelineBase</strong> is written in pure <strong>Julia</strong> including its
dependencies, the future target will
be to exploit Julia's native multi-threading
using thread-safe ML <strong>Julia</strong> libraries for scalability and performance.</p>
<p><strong>AMLPipelineBase</strong> declares the following abstract data types:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="abstract type Machine end
abstract type Computer    &lt;: Machine  end
abstract type Workflow    &lt;: Machine  end
abstract type Learner     &lt;: Computer end
abstract type Transformer &lt;: Computer end
"><pre><span class="pl-k">abstract type</span> Machine <span class="pl-k">end</span>
<span class="pl-k">abstract type</span> Computer    <span class="pl-k">&lt;:</span> <span class="pl-c1">Machine</span>  <span class="pl-k">end</span>
<span class="pl-k">abstract type</span> Workflow    <span class="pl-k">&lt;:</span> <span class="pl-c1">Machine</span>  <span class="pl-k">end</span>
<span class="pl-k">abstract type</span> Learner     <span class="pl-k">&lt;:</span> <span class="pl-c1">Computer</span> <span class="pl-k">end</span>
<span class="pl-k">abstract type</span> Transformer <span class="pl-k">&lt;:</span> <span class="pl-c1">Computer</span> <span class="pl-k">end</span></pre></div>
<p><strong>AMLPipelineBase</strong> dynamically dispatches the <strong>fit!</strong> and <strong>transform!</strong>
functions which must be overloaded by different subtypes of <strong>Machine</strong>.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function fit!(mc::Machine, input::DataFrame, output::Vector)
   error(typeof(mc),&quot;not implemented&quot;)
end

function transform!(mc::Machine, input::DataFrame)
   error(typeof(mc),&quot;not implemented&quot;)
end
"><pre><span class="pl-k">function</span> <span class="pl-en">fit!</span>(mc<span class="pl-k">::</span><span class="pl-c1">Machine</span>, input<span class="pl-k">::</span><span class="pl-c1">DataFrame</span>, output<span class="pl-k">::</span><span class="pl-c1">Vector</span>)
   <span class="pl-c1">error</span>(<span class="pl-c1">typeof</span>(mc),<span class="pl-s"><span class="pl-pds">"</span>not implemented<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">transform!</span>(mc<span class="pl-k">::</span><span class="pl-c1">Machine</span>, input<span class="pl-k">::</span><span class="pl-c1">DataFrame</span>)
   <span class="pl-c1">error</span>(<span class="pl-c1">typeof</span>(mc),<span class="pl-s"><span class="pl-pds">"</span>not implemented<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span></pre></div>
<h3><a id="user-content-motivations" class="anchor" aria-hidden="true" href="#motivations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Motivations</h3>
<ul>
<li>To provide a <strong>Base</strong> package for common functions and abstractions shared by:
<ul>
<li><a href="https://github.com/IBM/AutoMLPipeline.jl">AutoMLPipeline</a>: A package for ML Pipeline Optimization</li>
<li><a href="https://github.com/IBM/TSML.jl">TSML</a>: A package for Time-Series ML</li>
<li><a href="https://github.com/IBM/Lale.jl">Lale</a>: A Julia wrapper of python's
<a href="https://github.com/IBM/lale">Lale</a> for semi-automated data science.</li>
</ul>
</li>
<li>To implement efficient multi-threading reduction workflow</li>
</ul>
<h3><a id="user-content-package-features" class="anchor" aria-hidden="true" href="#package-features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Package Features</h3>
<ul>
<li>Symbolic pipeline API for high-level description and
easy expression of complex pipeline structures and workflows</li>
<li>Easily extensible architecture by overloading
just two main interfaces: <strong>fit!</strong> and <strong>transform!</strong></li>
<li>Meta-ensembles that allow composition of
ensembles of ensembles (recursively if needed)
for robust prediction routines</li>
<li>Categorical and numerical feature selectors for
specialized preprocessing routines based on types</li>
<li>Normalizers (zscore, unitrange, pca, fa) and Ensemble learners (voting, stacks, best)</li>
</ul>
<h3><a id="user-content-extending-amlpipelinebase" class="anchor" aria-hidden="true" href="#extending-amlpipelinebase"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Extending AMLPipelineBase</h3>
<p>If you want to add your own filter/transformer/learner, it is trivial.
Just take note that filters and transformers process the first
input features and ignores the target output while learners process both
the input features and target output arguments of the <code>fit!</code> function.
The <code>transform!</code> function always expect one input argument in all cases.</p>
<p>First, import the abstract types and define your own mutable structure
as subtype of either Learner or Transformer. Next, import the <code>fit!</code> and
<code>transform!</code> functions to be overloaded. Also, load the DataFrames package
to be used for data interchange.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using DataFrames
using AMLPipelineBase: AbsTypes

# import fit! and transform! for function overloading 
import AMLPipelineBase.AbsTypes: fit!, transform!  

# export new definitions for dynamic dispatch
export fit!, transform!, MyFilter

# define your filter structure
mutable struct MyFilter &lt;: Transformer
  name::String
  model::Dict

  function MyFilter(args::Dict())
      ....
  end
end

# filters and transformers ignore the target argument. 
# learners process both the input features and target argument.
function fit!(fl::MyFilter, inputfeatures::DataFrame, target::Vector=Vector())
     ....
end

# transform! function expects an input dataframe and outputs a dataframe
function transform!(fl::MyFilter, inputfeatures::DataFrame)::DataFrame
     ....
end
"><pre><span class="pl-k">using</span> DataFrames
<span class="pl-k">using</span> AMLPipelineBase<span class="pl-k">:</span> AbsTypes

<span class="pl-c"><span class="pl-c">#</span> import fit! and transform! for function overloading </span>
<span class="pl-k">import</span> AMLPipelineBase<span class="pl-k">.</span>AbsTypes<span class="pl-k">:</span> fit!, transform!  

<span class="pl-c"><span class="pl-c">#</span> export new definitions for dynamic dispatch</span>
<span class="pl-k">export</span> fit!, transform!, MyFilter

<span class="pl-c"><span class="pl-c">#</span> define your filter structure</span>
<span class="pl-k">mutable struct</span> MyFilter <span class="pl-k">&lt;:</span> <span class="pl-c1">Transformer</span>
  name<span class="pl-k">::</span><span class="pl-c1">String</span>
  model<span class="pl-k">::</span><span class="pl-c1">Dict</span>

  <span class="pl-k">function</span> <span class="pl-en">MyFilter</span>(args<span class="pl-k">::</span><span class="pl-c1">Dict</span>())
      <span class="pl-k">....</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> filters and transformers ignore the target argument. </span>
<span class="pl-c"><span class="pl-c">#</span> learners process both the input features and target argument.</span>
<span class="pl-k">function</span> <span class="pl-en">fit!</span>(fl<span class="pl-k">::</span><span class="pl-c1">MyFilter</span>, inputfeatures<span class="pl-k">::</span><span class="pl-c1">DataFrame</span>, target<span class="pl-k">::</span><span class="pl-c1">Vector</span><span class="pl-k">=</span><span class="pl-c1">Vector</span>())
     <span class="pl-k">....</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> transform! function expects an input dataframe and outputs a dataframe</span>
<span class="pl-k">function</span> <span class="pl-en">transform!</span>(fl<span class="pl-k">::</span><span class="pl-c1">MyFilter</span>, inputfeatures<span class="pl-k">::</span><span class="pl-c1">DataFrame</span>)<span class="pl-k">::</span><span class="pl-c1">DataFrame</span>
     <span class="pl-k">....</span>
<span class="pl-k">end</span></pre></div>
<p>Note that the main data interchange format is a dataframe so transform!
output should always be a dataframe as well as the input for <strong>fit!</strong> and <strong>transform!</strong>.
This is necessary so that the pipeline passes the dataframe format consistently to
its filters or transformers or learners. Once you created a filter, you can use
it as part of the pipeline together with the other learners and filters.</p>
<h3><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h3>
<p>AMLPipelineBase is in the Julia Official package registry.
The latest release can be installed at the Julia
prompt using Julia's package management which is triggered
by pressing <code>]</code> at the julia prompt:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; ]
pkg&gt; update
pkg&gt; add AMLPipelineBase
"><pre>julia<span class="pl-k">&gt;</span> ]
pkg<span class="pl-k">&gt;</span> update
pkg<span class="pl-k">&gt;</span> add AMLPipelineBase</pre></div>
<p>Below outlines some typical way to preprocess and model any dataset.</p>
<h5><a id="user-content-1-load-data-extract-input-x-and-target-y" class="anchor" aria-hidden="true" href="#1-load-data-extract-input-x-and-target-y"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. Load Data, Extract Input (X) and Target (Y)</h5>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Make sure that the input feature is a dataframe and the target output is a 1-D vector.
using AMLPipelineBase
profbdata = getprofb()
X = profbdata[:,2:end] 
Y = profbdata[:,1] |&gt; Vector;
head(x)=first(x,5)
head(profbdata)
"><pre><span class="pl-c"><span class="pl-c">#</span> Make sure that the input feature is a dataframe and the target output is a 1-D vector.</span>
<span class="pl-k">using</span> AMLPipelineBase
profbdata <span class="pl-k">=</span> <span class="pl-c1">getprofb</span>()
X <span class="pl-k">=</span> profbdata[:,<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">end</span>] 
Y <span class="pl-k">=</span> profbdata[:,<span class="pl-c1">1</span>] <span class="pl-k">|&gt;</span> Vector;
<span class="pl-en">head</span>(x)<span class="pl-k">=</span><span class="pl-c1">first</span>(x,<span class="pl-c1">5</span>)
<span class="pl-c1">head</span>(profbdata)</pre></div>
<h4><a id="user-content-2-load-filters-transformers-and-learners" class="anchor" aria-hidden="true" href="#2-load-filters-transformers-and-learners"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. Load Filters, Transformers, and Learners</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="#### categorical preprocessing
ohe = OneHotEncoder()

#### Column selector
catf = CatFeatureSelector() 
numf = NumFeatureSelector()

#### Learners
rf    = RandomForest()
ada   = Adaboost()
pt    = PrunedTree()
stack = StackEnsemble()
best  = BestLearner()
vote  = VoteEnsemble()
"><pre><span class="pl-c"><span class="pl-c">#</span>### categorical preprocessing</span>
ohe <span class="pl-k">=</span> <span class="pl-c1">OneHotEncoder</span>()

<span class="pl-c"><span class="pl-c">#</span>### Column selector</span>
catf <span class="pl-k">=</span> <span class="pl-c1">CatFeatureSelector</span>() 
numf <span class="pl-k">=</span> <span class="pl-c1">NumFeatureSelector</span>()

<span class="pl-c"><span class="pl-c">#</span>### Learners</span>
rf    <span class="pl-k">=</span> <span class="pl-c1">RandomForest</span>()
ada   <span class="pl-k">=</span> <span class="pl-c1">Adaboost</span>()
pt    <span class="pl-k">=</span> <span class="pl-c1">PrunedTree</span>()
stack <span class="pl-k">=</span> <span class="pl-c1">StackEnsemble</span>()
best  <span class="pl-k">=</span> <span class="pl-c1">BestLearner</span>()
vote  <span class="pl-k">=</span> <span class="pl-c1">VoteEnsemble</span>()</pre></div>
<h4><a id="user-content-3-filter-categories-and-hot-encode-them" class="anchor" aria-hidden="true" href="#3-filter-categories-and-hot-encode-them"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. Filter categories and hot-encode them</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="pohe = catf |&gt; ohe
tr   = fit_transform!(pohe,X,Y)
"><pre>pohe <span class="pl-k">=</span> catf <span class="pl-k">|&gt;</span> ohe
tr   <span class="pl-k">=</span> <span class="pl-c1">fit_transform!</span>(pohe,X,Y)</pre></div>
<h4><a id="user-content-4-filter-numeric-features" class="anchor" aria-hidden="true" href="#4-filter-numeric-features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. Filter numeric features</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="pdec = numf
tr   = fit_transform!(pdec,X,Y)
"><pre>pdec <span class="pl-k">=</span> numf
tr   <span class="pl-k">=</span> <span class="pl-c1">fit_transform!</span>(pdec,X,Y)</pre></div>
<h4><a id="user-content-5-a-pipeline-for-the-voting-ensemble-classification" class="anchor" aria-hidden="true" href="#5-a-pipeline-for-the-voting-ensemble-classification"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5. A Pipeline for the Voting Ensemble Classification</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# take all categorical columns and hot-bit encode each, 
# concatenate them to the numerical features,
# and feed them to the voting ensemble
pvote = (catf |&gt; ohe) + (numf) |&gt; vote
pred  = fit_transform!(pvote,X,Y)
sc    = score(:accuracy,pred,Y)
println(sc)
### cross-validate
acc(X,Y) = score(:accuracy,X,Y)
crossvalidate(pvote,X,Y,acc,10,true)
"><pre><span class="pl-c"><span class="pl-c">#</span> take all categorical columns and hot-bit encode each, </span>
<span class="pl-c"><span class="pl-c">#</span> concatenate them to the numerical features,</span>
<span class="pl-c"><span class="pl-c">#</span> and feed them to the voting ensemble</span>
pvote <span class="pl-k">=</span> (catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf) <span class="pl-k">|&gt;</span> vote
pred  <span class="pl-k">=</span> <span class="pl-c1">fit_transform!</span>(pvote,X,Y)
sc    <span class="pl-k">=</span> <span class="pl-c1">score</span>(<span class="pl-c1">:accuracy</span>,pred,Y)
<span class="pl-c1">println</span>(sc)
<span class="pl-c"><span class="pl-c">#</span>## cross-validate</span>
<span class="pl-en">acc</span>(X,Y) <span class="pl-k">=</span> <span class="pl-c1">score</span>(<span class="pl-c1">:accuracy</span>,X,Y)
<span class="pl-c1">crossvalidate</span>(pvote,X,Y,acc,<span class="pl-c1">10</span>,<span class="pl-c1">true</span>)</pre></div>
<h4><a id="user-content-6-use-pipelinex-instead-of-pipeline-to-print-the-corresponding-function-calls-in-6" class="anchor" aria-hidden="true" href="#6-use-pipelinex-instead-of-pipeline-to-print-the-corresponding-function-calls-in-6"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>6. Use <code>@pipelinex</code> instead of <code>@pipeline</code> to print the corresponding function calls in 6</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; @pipelinex (catf |&gt; ohe) + (numf) |&gt; vote
:(Pipeline(ComboPipeline(Pipeline(catf, ohe), numf), vote))

# another way is to use @macroexpand with @pipeline
julia&gt; @macroexpand @pipeline (catf |&gt; ohe) + (numf) |&gt; vote
:(Pipeline(ComboPipeline(Pipeline(catf, ohe), numf), vote))
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@pipelinex</span> (catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf) <span class="pl-k">|&gt;</span> vote
:(<span class="pl-c1">Pipeline</span>(<span class="pl-c1">ComboPipeline</span>(<span class="pl-c1">Pipeline</span>(catf, ohe), numf), vote))

<span class="pl-c"><span class="pl-c">#</span> another way is to use @macroexpand with @pipeline</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@macroexpand</span> <span class="pl-c1">@pipeline</span> (catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf) <span class="pl-k">|&gt;</span> vote
:(<span class="pl-c1">Pipeline</span>(<span class="pl-c1">ComboPipeline</span>(<span class="pl-c1">Pipeline</span>(catf, ohe), numf), vote))</pre></div>
<h4><a id="user-content-7-a-pipeline-for-the-random-forest-rf-classification" class="anchor" aria-hidden="true" href="#7-a-pipeline-for-the-random-forest-rf-classification"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>7. A Pipeline for the Random Forest (RF) Classification</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# compute the pca, ica, fa of the numerical columns,
# combine them with the hot-bit encoded categorical features
# and feed all to the random forest classifier
prf  = (catf|&gt; ohe) + numf   |&gt; rf
pred = fit_transform!(prf,X,Y)
score(:accuracy,pred,Y) |&gt; println
crossvalidate(prf,X,Y,acc,10)
"><pre><span class="pl-c"><span class="pl-c">#</span> compute the pca, ica, fa of the numerical columns,</span>
<span class="pl-c"><span class="pl-c">#</span> combine them with the hot-bit encoded categorical features</span>
<span class="pl-c"><span class="pl-c">#</span> and feed all to the random forest classifier</span>
prf  <span class="pl-k">=</span> (catf<span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> numf   <span class="pl-k">|&gt;</span> rf
pred <span class="pl-k">=</span> <span class="pl-c1">fit_transform!</span>(prf,X,Y)
<span class="pl-c1">score</span>(<span class="pl-c1">:accuracy</span>,pred,Y) <span class="pl-k">|&gt;</span> println
<span class="pl-c1">crossvalidate</span>(prf,X,Y,acc,<span class="pl-c1">10</span>)</pre></div>
<h4><a id="user-content-9-a-pipeline-for-random-forest-regression" class="anchor" aria-hidden="true" href="#9-a-pipeline-for-random-forest-regression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>9. A Pipeline for Random Forest Regression</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Statistics
iris      = getiris()
Xreg      = iris[:,1:3]
Yreg      = iris[:,4] |&gt; Vector
rfreg     = (catf |&gt; ohe) + (numf) |&gt; rf
pred      = fit_transform!(rfreg,Xreg,Yreg)
rmse(X,Y) = mean((X .- Y).^2) |&gt; sqrt
res       = crossvalidate(rfreg,Xreg,Yreg,rmse,10,true)
"><pre><span class="pl-k">using</span> Statistics
iris      <span class="pl-k">=</span> <span class="pl-c1">getiris</span>()
Xreg      <span class="pl-k">=</span> iris[:,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>]
Yreg      <span class="pl-k">=</span> iris[:,<span class="pl-c1">4</span>] <span class="pl-k">|&gt;</span> Vector
rfreg     <span class="pl-k">=</span> (catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf) <span class="pl-k">|&gt;</span> rf
pred      <span class="pl-k">=</span> <span class="pl-c1">fit_transform!</span>(rfreg,Xreg,Yreg)
<span class="pl-en">rmse</span>(X,Y) <span class="pl-k">=</span> <span class="pl-c1">mean</span>((X <span class="pl-k">.-</span> Y)<span class="pl-k">.^</span><span class="pl-c1">2</span>) <span class="pl-k">|&gt;</span> sqrt
res       <span class="pl-k">=</span> <span class="pl-c1">crossvalidate</span>(rfreg,Xreg,Yreg,rmse,<span class="pl-c1">10</span>,<span class="pl-c1">true</span>)</pre></div>
<p>Note: More examples can be found in the <strong>TSML</strong> and <strong>AutoMLPipeline</strong> packages.
Since the code is written in Julia, you are highly encouraged to read the source
code and feel free to extend or adapt the package to your problem. Please
feel free to submit PRs to improve the package features.</p>
<h4><a id="user-content-10-performance-comparison-of-several-learners" class="anchor" aria-hidden="true" href="#10-performance-comparison-of-several-learners"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>10. Performance Comparison of Several Learners</h4>
<h5><a id="user-content-101-sequential-processing" class="anchor" aria-hidden="true" href="#101-sequential-processing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>10.1 Sequential Processing</h5>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Random
using DataFrames
Random.seed!(1)

disc   = CatNumDiscriminator()
catf   = CatFeatureSelector()
numf   = NumFeatureSelector()
ohe    = OneHotEncoder()
rf     = RandomForest()
ada    = Adaboost()
tree   = PrunedTree()
stack  = StackEnsemble()
best   = BestLearner()
vote   = VoteEnsemble()

learners = DataFrame()
for learner in [rf,ada,tree,stack,vote,best]
    pcmc = disc |&gt; ((catf |&gt; ohe) + numf) |&gt; learner
    println(learner.name)
    mean,sd,_ = crossvalidate(pcmc,X,Y,acc,10,true)
    learners  = vcat(learners,DataFrame(name=learner.name,mean=mean,sd=sd))
end;
@show learners;
"><pre><span class="pl-k">using</span> Random
<span class="pl-k">using</span> DataFrames
Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1</span>)

disc   <span class="pl-k">=</span> <span class="pl-c1">CatNumDiscriminator</span>()
catf   <span class="pl-k">=</span> <span class="pl-c1">CatFeatureSelector</span>()
numf   <span class="pl-k">=</span> <span class="pl-c1">NumFeatureSelector</span>()
ohe    <span class="pl-k">=</span> <span class="pl-c1">OneHotEncoder</span>()
rf     <span class="pl-k">=</span> <span class="pl-c1">RandomForest</span>()
ada    <span class="pl-k">=</span> <span class="pl-c1">Adaboost</span>()
tree   <span class="pl-k">=</span> <span class="pl-c1">PrunedTree</span>()
stack  <span class="pl-k">=</span> <span class="pl-c1">StackEnsemble</span>()
best   <span class="pl-k">=</span> <span class="pl-c1">BestLearner</span>()
vote   <span class="pl-k">=</span> <span class="pl-c1">VoteEnsemble</span>()

learners <span class="pl-k">=</span> <span class="pl-c1">DataFrame</span>()
<span class="pl-k">for</span> learner <span class="pl-k">in</span> [rf,ada,tree,stack,vote,best]
    pcmc <span class="pl-k">=</span> disc <span class="pl-k">|&gt;</span> ((catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> numf) <span class="pl-k">|&gt;</span> learner
    <span class="pl-c1">println</span>(learner<span class="pl-k">.</span>name)
    mean,sd,_ <span class="pl-k">=</span> <span class="pl-c1">crossvalidate</span>(pcmc,X,Y,acc,<span class="pl-c1">10</span>,<span class="pl-c1">true</span>)
    learners  <span class="pl-k">=</span> <span class="pl-c1">vcat</span>(learners,<span class="pl-c1">DataFrame</span>(name<span class="pl-k">=</span>learner<span class="pl-k">.</span>name,mean<span class="pl-k">=</span>mean,sd<span class="pl-k">=</span>sd))
<span class="pl-k">end</span>;
<span class="pl-c1">@show</span> learners;</pre></div>
<h5><a id="user-content-102-parallel-processing" class="anchor" aria-hidden="true" href="#102-parallel-processing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>10.2 Parallel Processing</h5>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Random
using DataFrames
using Distributed

nprocs() == 1 &amp;&amp; addprocs()
@everywhere using DataFrames
@everywhere using AMLPipelineBase

rf     = RandomForest()
ada    = Adaboost()
tree   = PrunedTree()
stack  = StackEnsemble()
best   = BestLearner()
vote   = VoteEnsemble()
disc   = CatNumDiscriminator()
catf   = CatFeatureSelector()
numf   = NumFeatureSelector()

@everywhere acc(X,Y) = score(:accuracy,X,Y)

learners = @distributed (vcat) for learner in [rf,ada,tree,stack,vote,best]
    pcmc = disc |&gt; ((catf |&gt; ohe) + (numf)) |&gt; learner
    println(learner.name)
    mean,sd,_ = crossvalidate(pcmc,X,Y,acc,10,true)
    DataFrame(name=learner.name,mean=mean,sd=sd)
end
@show learners;
"><pre><span class="pl-k">using</span> Random
<span class="pl-k">using</span> DataFrames
<span class="pl-k">using</span> Distributed

<span class="pl-c1">nprocs</span>() <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">addprocs</span>()
<span class="pl-c1">@everywhere</span> <span class="pl-k">using</span> DataFrames
<span class="pl-c1">@everywhere</span> <span class="pl-k">using</span> AMLPipelineBase

rf     <span class="pl-k">=</span> <span class="pl-c1">RandomForest</span>()
ada    <span class="pl-k">=</span> <span class="pl-c1">Adaboost</span>()
tree   <span class="pl-k">=</span> <span class="pl-c1">PrunedTree</span>()
stack  <span class="pl-k">=</span> <span class="pl-c1">StackEnsemble</span>()
best   <span class="pl-k">=</span> <span class="pl-c1">BestLearner</span>()
vote   <span class="pl-k">=</span> <span class="pl-c1">VoteEnsemble</span>()
disc   <span class="pl-k">=</span> <span class="pl-c1">CatNumDiscriminator</span>()
catf   <span class="pl-k">=</span> <span class="pl-c1">CatFeatureSelector</span>()
numf   <span class="pl-k">=</span> <span class="pl-c1">NumFeatureSelector</span>()

<span class="pl-c1">@everywhere</span> <span class="pl-en">acc</span>(X,Y) <span class="pl-k">=</span> <span class="pl-c1">score</span>(<span class="pl-c1">:accuracy</span>,X,Y)

learners <span class="pl-k">=</span> <span class="pl-c1">@distributed</span> (vcat) <span class="pl-k">for</span> learner <span class="pl-k">in</span> [rf,ada,tree,stack,vote,best]
    pcmc <span class="pl-k">=</span> disc <span class="pl-k">|&gt;</span> ((catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf)) <span class="pl-k">|&gt;</span> learner
    <span class="pl-c1">println</span>(learner<span class="pl-k">.</span>name)
    mean,sd,_ <span class="pl-k">=</span> <span class="pl-c1">crossvalidate</span>(pcmc,X,Y,acc,<span class="pl-c1">10</span>,<span class="pl-c1">true</span>)
    <span class="pl-c1">DataFrame</span>(name<span class="pl-k">=</span>learner<span class="pl-k">.</span>name,mean<span class="pl-k">=</span>mean,sd<span class="pl-k">=</span>sd)
<span class="pl-k">end</span>
<span class="pl-c1">@show</span> learners;</pre></div>
<h4><a id="user-content-11-automatic-selection-of-best-learner" class="anchor" aria-hidden="true" href="#11-automatic-selection-of-best-learner"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>11. Automatic Selection of Best Learner</h4>
<p>You can use <code>*</code> operation as a selector function which outputs the result of the best learner.
If we use the same pre-processing pipeline in 10, we expect that the average performance of
best learner which is <code>lsvc</code> will be around 73.0.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Random.seed!(1)
pcmc = disc |&gt; ((catf |&gt; ohe) + (numf)) |&gt; (rf * ada * tree)
crossvalidate(pcmc,X,Y,acc,10,true)
"><pre>Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1</span>)
pcmc <span class="pl-k">=</span> disc <span class="pl-k">|&gt;</span> ((catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf)) <span class="pl-k">|&gt;</span> (rf <span class="pl-k">*</span> ada <span class="pl-k">*</span> tree)
<span class="pl-c1">crossvalidate</span>(pcmc,X,Y,acc,<span class="pl-c1">10</span>,<span class="pl-c1">true</span>)</pre></div>
<h4><a id="user-content-12-learners-as-transformers" class="anchor" aria-hidden="true" href="#12-learners-as-transformers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>12. Learners as Transformers</h4>
<p>It is also possible to use learners in the middle of expression to serve
as transformers and their outputs become inputs to the final learner as illustrated
below.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="expr = ( 
         ((numf)+(catf |&gt; ohe) |&gt; rf) +
         ((numf)+(catf |&gt; ohe) |&gt; ada) +
         ((numf)+(catf |&gt; ohe) |&gt; tree) 
       ) |&gt; ohe |&gt; rf;                
crossvalidate(expr,X,Y,acc,10,true)
"><pre>expr <span class="pl-k">=</span> ( 
         ((numf)<span class="pl-k">+</span>(catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">|&gt;</span> rf) <span class="pl-k">+</span>
         ((numf)<span class="pl-k">+</span>(catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">|&gt;</span> ada) <span class="pl-k">+</span>
         ((numf)<span class="pl-k">+</span>(catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">|&gt;</span> tree) 
       ) <span class="pl-k">|&gt;</span> ohe <span class="pl-k">|&gt;</span> rf;                
<span class="pl-c1">crossvalidate</span>(expr,X,Y,acc,<span class="pl-c1">10</span>,<span class="pl-c1">true</span>)</pre></div>
<p>One can even include selector function as part of transformer preprocessing routine:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="pjrf = disc |&gt; ((catf |&gt; ohe) + (numf |&gt; rf)) |&gt; 
               ((rf * ada ) + (rf * tree * vote)) |&gt; ohe |&gt; ada
crossvalidate(pjrf,X,Y,acc,10,true)
"><pre>pjrf <span class="pl-k">=</span> disc <span class="pl-k">|&gt;</span> ((catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf <span class="pl-k">|&gt;</span> rf)) <span class="pl-k">|&gt;</span> 
               ((rf <span class="pl-k">*</span> ada ) <span class="pl-k">+</span> (rf <span class="pl-k">*</span> tree <span class="pl-k">*</span> vote)) <span class="pl-k">|&gt;</span> ohe <span class="pl-k">|&gt;</span> ada
<span class="pl-c1">crossvalidate</span>(pjrf,X,Y,acc,<span class="pl-c1">10</span>,<span class="pl-c1">true</span>)</pre></div>
<p>Note: The <code>ohe</code> is necessary in both examples
because the outputs of the learners and selector function are categorical
values that need to be hot-bit encoded before feeding to the final <code>ada</code> learner.</p>
<h4><a id="user-content-13-tree-visualization-of-the-pipeline-structure" class="anchor" aria-hidden="true" href="#13-tree-visualization-of-the-pipeline-structure"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>13. Tree Visualization of the Pipeline Structure</h4>
<p>You can visualize the pipeline by using AbstractTrees Julia package.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# package installation 
using Pkg
Pkg.update()
Pkg.add(&quot;AbstractTrees&quot;) 

# load the packages
using AbstractTrees
using AMLPipelineBase

julia&gt; expr = @pipelinex (catf |&gt; ohe) + (numf) |&gt; rf
:(Pipeline(ComboPipeline(Pipeline(catf, ohe), numf), rf))

julia&gt; print_tree(stdout, expr)
:(Pipeline(ComboPipeline(Pipeline(catf, ohe), numf), rf))
├─ :Pipeline
├─ :(ComboPipeline(Pipeline(catf, ohe), numf))
│  ├─ :ComboPipeline
│  ├─ :(Pipeline(catf, ohe))
│  │  ├─ :Pipeline
│  │  ├─ :catf
│  │  └─ :ohe
│  └─ :numf
└─ :rf
"><pre><span class="pl-c"><span class="pl-c">#</span> package installation </span>
<span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">update</span>()
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>AbstractTrees<span class="pl-pds">"</span></span>) 

<span class="pl-c"><span class="pl-c">#</span> load the packages</span>
<span class="pl-k">using</span> AbstractTrees
<span class="pl-k">using</span> AMLPipelineBase

julia<span class="pl-k">&gt;</span> expr <span class="pl-k">=</span> <span class="pl-c1">@pipelinex</span> (catf <span class="pl-k">|&gt;</span> ohe) <span class="pl-k">+</span> (numf) <span class="pl-k">|&gt;</span> rf
:(<span class="pl-c1">Pipeline</span>(<span class="pl-c1">ComboPipeline</span>(<span class="pl-c1">Pipeline</span>(catf, ohe), numf), rf))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">print_tree</span>(<span class="pl-c1">stdout</span>, expr)
:(<span class="pl-c1">Pipeline</span>(<span class="pl-c1">ComboPipeline</span>(<span class="pl-c1">Pipeline</span>(catf, ohe), numf), rf))
├─ <span class="pl-c1">:Pipeline</span>
├─ :(<span class="pl-c1">ComboPipeline</span>(<span class="pl-c1">Pipeline</span>(catf, ohe), numf))
│  ├─ <span class="pl-c1">:ComboPipeline</span>
│  ├─ :(<span class="pl-c1">Pipeline</span>(catf, ohe))
│  │  ├─ <span class="pl-c1">:Pipeline</span>
│  │  ├─ <span class="pl-c1">:catf</span>
│  │  └─ <span class="pl-c1">:ohe</span>
│  └─ <span class="pl-c1">:numf</span>
└─ <span class="pl-c1">:rf</span></pre></div>
<h3><a id="user-content-feature-requests-and-contributions" class="anchor" aria-hidden="true" href="#feature-requests-and-contributions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Feature Requests and Contributions</h3>
<p>We welcome contributions, feature requests, and suggestions. Here is the link to open an <a href="https://github.com/IBM/AMLPipelineBase.jl/issues">issue</a> for any problems you encounter. If you want to contribute, please follow the guidelines in <a href="https://github.com/IBM/AMLPipelineBase.jl/blob/master/CONTRIBUTORS.md">contributors page</a>.</p>
<h3><a id="user-content-help-usage" class="anchor" aria-hidden="true" href="#help-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Help usage</h3>
<p>Usage questions can be posted in:</p>
<ul>
<li><a href="https://julialang.org/community/" rel="nofollow">Julia Community</a></li>
<li><a href="https://gitter.im/AutoMLPipelineLearning/community" rel="nofollow">Gitter AutoMLPipeline Community</a></li>
<li><a href="https://discourse.julialang.org/" rel="nofollow">Julia Discourse forum</a></li>
</ul>
</article></div>