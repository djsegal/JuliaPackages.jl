<div id="readme" class="md" data-path="readme.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-symbolic-system-for-quantum-computing" class="anchor" aria-hidden="true" href="#symbolic-system-for-quantum-computing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Symbolic system for Quantum computing</h1>
<h3 dir="auto"><a id="user-content-install" class="anchor" aria-hidden="true" href="#install"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Install</h3>
<p dir="auto">To install, type <code>]</code> in a julia (&gt;=1.5) REPL and then input</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add https://github.com/overshiki/SymbolicCircuit.jl"><pre>pkg<span class="pl-k">&gt;</span> add https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>overshiki<span class="pl-k">/</span>SymbolicCircuit<span class="pl-k">.</span>jl</pre></div>
<h3 dir="auto"><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick start</h3>
<p dir="auto">To define and simplify a quantum circuit, just do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SymbolicCircuit
x1 = UGate(gX(), [Loc(1), ])
h2 = UGate(gH(), [Loc(2), ])
y3 = UGate(gY(), [Loc(3), ])
circ = x1 * x1 * h2 * y3 * x1 * x1 * h2
ncirc = egraph_simplify(circ, Val(:default_rule))"><pre><span class="pl-k">using</span> SymbolicCircuit
x1 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gX</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">1</span>), ])
h2 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gH</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">2</span>), ])
y3 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gY</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">3</span>), ])
circ <span class="pl-k">=</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2 <span class="pl-k">*</span> y3 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2
ncirc <span class="pl-k">=</span> <span class="pl-c1">egraph_simplify</span>(circ, <span class="pl-c1">Val</span>(<span class="pl-c1">:default_rule</span>))</pre></div>
<p dir="auto">It will simplify <code>circ</code> into <code>ncirc</code> according to commute and cancel rules.</p>
<p dir="auto">To test if two circuit are in equivalent according to commute and cancel rules, just do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="SymbolicCircuit.areequal(Val(:default_rule), circ, ncirc)"><pre>SymbolicCircuit<span class="pl-k">.</span><span class="pl-c1">areequal</span>(<span class="pl-c1">Val</span>(<span class="pl-c1">:default_rule</span>), circ, ncirc)</pre></div>
<p dir="auto">It will return <code>true</code> if <code>circ</code> and <code>ncirc</code> are in equivalent, otherwise <code>missing</code>.</p>
<h4 dir="auto"><a id="user-content-working-with-yaojl" class="anchor" aria-hidden="true" href="#working-with-yaojl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Working with Yao.jl</h4>
<p dir="auto"><code>SymbolicCircuit.jl</code> also provides method to turn symbolic circuit defined above to <code>YaoBlock</code> in <code>Yao.jl</code>, so that the full power of <code>Yao.jl</code> would be avaliable</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="yao_circ = to_yao(circ; num_qubits=3)
println(yao_circ)"><pre class="notranslate"><code>yao_circ = to_yao(circ; num_qubits=3)
println(yao_circ)
</code></pre></div>
<p dir="auto">To plot the circuit, just do</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="to_yaoplot(&quot;./test/plot.png&quot;, circ)"><pre class="notranslate"><code>to_yaoplot("./test/plot.png", circ)
</code></pre></div>
<p dir="auto">It will plot the circuit using <code>YaoPlots.jl</code></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="./test/plot.png"><img src="./test/plot.png" alt="image" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-what-does-symboliccircuitjl-provide" class="anchor" aria-hidden="true" href="#what-does-symboliccircuitjl-provide"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What does <code>SymbolicCircuit.jl</code> provide?</h3>
<p dir="auto"><code>SymbolicCircuit.jl</code> provides a symbolic system for representation of Quantum circuit, in which, one can manipulate Quantum circuit using term rewriting &amp; equality saturation techniques. Using this package, one can easily define any syntactic rules of Quantum circuit(for example, mutation between two quantum gates), and apply it to term rewriting and equality saturation Modules provided by<a href="https://github.com/JuliaSymbolics/Metatheory.jl"> <code>Metatheory.jl</code> </a>(Yes, This project is highly dependent on and highly motivated by <a href="https://github.com/JuliaSymbolics/Metatheory.jl"><code>Metatheory.jl</code></a>). Doing so, tasks such as circuit simplification, equivalence detection, code generation become easily achievable.</p>
<h3 dir="auto"><a id="user-content-what-is-the-symbolic-system-of-symboliccircuitjl" class="anchor" aria-hidden="true" href="#what-is-the-symbolic-system-of-symboliccircuitjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What is the symbolic system of <code>SymbolicCircuit.jl</code>?</h3>
<h4 dir="auto"><a id="user-content-quantum-gates" class="anchor" aria-hidden="true" href="#quantum-gates"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quantum gates</h4>
<p dir="auto">In <code>SymbolicCircuit.jl</code>, quantum gates are represented by the instances of <code>Gate</code> struct, for example, the Pauli X gate on 1st Qubit is defined by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SymbolicCircuit
x1 = UGate(gX(), [Loc(1), ])"><pre><span class="pl-k">using</span> SymbolicCircuit
x1 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gX</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">1</span>), ])</pre></div>
<p dir="auto">Where <code>UGate</code> is alias for <code>Gate{Normal}</code>, where the counterpart is <code>Gate{Dagger}</code> which stands for <code>daggered</code> version of <code>UGate</code>.<br>
<code>gX()</code> represents the type of Pauli X(gX is short for gate X), <code>Loc(1)</code> indicates the gate is applied on Qubit 1.
We can also define multi-Qubits gate, for example, CNOT gate on 1st Qubit and controlled by 2nd Qubit</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="cnot_1c2 = UGate(gX(), [Loc(1), cLoc(2)])"><pre>cnot_1c2 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gX</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">1</span>), <span class="pl-c1">cLoc</span>(<span class="pl-c1">2</span>)])</pre></div>
<p dir="auto">Where <code>cLoc(2)</code> indicates the gate is controlled by 2nd Qubit</p>
<p dir="auto">We can also define parametric gate such as rotate X, controlled by parameter <code>:theta</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="rx = UGate(rX([:theta, ]), [Loc(3), ])"><pre>rx <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">rX</span>([<span class="pl-c1">:theta</span>, ]), [<span class="pl-c1">Loc</span>(<span class="pl-c1">3</span>), ])</pre></div>
<p dir="auto">Since simplifying many VQE circuits will often result in rotate gate controlled by multiple parameters(sum of multiple rotate angles), we also allow this</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="rx2 = UGate(rX([:theta1, :theta2, :theta3]), [Loc(3), ])"><pre>rx2 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">rX</span>([<span class="pl-c1">:theta1</span>, <span class="pl-c1">:theta2</span>, <span class="pl-c1">:theta3</span>]), [<span class="pl-c1">Loc</span>(<span class="pl-c1">3</span>), ])</pre></div>
<h4 dir="auto"><a id="user-content-quantum-circuit" class="anchor" aria-hidden="true" href="#quantum-circuit"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quantum circuit</h4>
<p dir="auto">It is wellknown that, symbolically, quantum circuit is just a chain of quantum gate, applied from left to the right. In <code>SymbolicCircuit.jl</code>, we define quantum circuit as expression of gates connected by <code>*</code> operator.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SymbolicCircuit
x1 = UGate(gX(), [Loc(1), ])
h2 = UGate(gH(), [Loc(2), ])
y3 = UGate(gY(), [Loc(3), ])
circ = x1 * x1 * h2 * y3 * x1 * x1 * h2"><pre><span class="pl-k">using</span> SymbolicCircuit
x1 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gX</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">1</span>), ])
h2 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gH</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">2</span>), ])
y3 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gY</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">3</span>), ])
circ <span class="pl-k">=</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2 <span class="pl-k">*</span> y3 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2</pre></div>
<p dir="auto">This allows flexible ways of defining a circuit, for example, we can also</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SymbolicCircuit
let circ = head_circuit()
    for _ in 1:2
        for g in [x1, h2, y3]  
            circ *= g 
        end 
    end
end"><pre><span class="pl-k">using</span> SymbolicCircuit
<span class="pl-k">let</span> circ <span class="pl-k">=</span> <span class="pl-c1">head_circuit</span>()
    <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>
        <span class="pl-k">for</span> g <span class="pl-k">in</span> [x1, h2, y3]  
            circ <span class="pl-k">*=</span> g 
        <span class="pl-k">end</span> 
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<h4 dir="auto"><a id="user-content-syntactic-rules" class="anchor" aria-hidden="true" href="#syntactic-rules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Syntactic rules</h4>
<p dir="auto">The core idea of <code>SymbolicCircuit.jl</code> is that quantum circuit can be represented using symbolic expression and some rules(such as mutation rules) can be represented using syntactic rules of the expressions. Then term rewriting &amp; equality saturation system could be used to manipulate the circuit. In <code>SymbolicCircuit.jl</code>, we provide easy ways to define different type of syntactic rules one may imagine. For example, a simple commute rule and cancel rule can be defined</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SymbolicCircuit
using Metatheory

#commute rules
com_rule = @rule a b a::Gate * b::Gate =&gt; :($(b) * $(a)) where is_commute(a, b)

#cancel rules
can_rule = @rule a b a::Gate * b::Gate =&gt; One() where is_cancel(a, b)
"><pre><span class="pl-k">using</span> SymbolicCircuit
<span class="pl-k">using</span> Metatheory

<span class="pl-c"><span class="pl-c">#</span>commute rules</span>
com_rule <span class="pl-k">=</span> <span class="pl-c1">@rule</span> a b a<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">*</span> b<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">=&gt;</span> :(<span class="pl-k">$</span>(b) <span class="pl-k">*</span> <span class="pl-k">$</span>(a)) <span class="pl-k">where</span> <span class="pl-c1">is_commute</span>(a, b)

<span class="pl-c"><span class="pl-c">#</span>cancel rules</span>
can_rule <span class="pl-k">=</span> <span class="pl-c1">@rule</span> a b a<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">*</span> b<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">One</span>() <span class="pl-k">where</span> <span class="pl-c1">is_cancel</span>(a, b)
</pre></div>
<p dir="auto">Where <code>is_commute</code> and <code>is_cancel</code> are functions provided in <code>src/gate.jl</code> to determine if two gates are commute and if they could be cancelled out.
Currently, <code>is_commute</code> considers two cases:</p>
<ul dir="auto">
<li>gate <code>a</code> and gate <code>b</code> do not have common <code>Loc</code> or <code>cLoc</code></li>
<li>gate <code>a/b</code> is a <code>Z|S|T</code> gate, and gate <code>b/a</code> is a <code>CNOT</code> gate, where <code>cLoc</code> of <code>b/a</code> has the same index with <code>Loc</code> of <code>a/b</code></li>
</ul>
<p dir="auto"><code>is_cancel</code> considers two cases:</p>
<ul dir="auto">
<li>gate <code>a</code> and gate <code>b</code> are identical and they belong to unitary &amp; Hermitian gate</li>
<li>gate <code>a/b</code> is the dagger version of gate <code>b/a</code></li>
</ul>
<p dir="auto">Note that the rule defination process here is just a normal rule defination process in <a href="https://github.com/JuliaSymbolics/Metatheory.jl"><code>Metatheory.jl</code></a>(users can also define rewrite rule using <code>--&gt;</code> and equality rule using <code>==</code>, following the document of <a href="https://github.com/JuliaSymbolics/Metatheory.jl"><code>Metatheory.jl</code></a>), what <code>SymbolicCircuit.jl</code> provides is a system of gate expression and circuit expression where<a href="https://github.com/JuliaSymbolics/Metatheory.jl"> <code>Metatheory.jl</code> </a>could be applied to.</p>
<p dir="auto">Addtionally, <code>SymbolicCircuit.jl</code> also provides some built-in rules for applications including circuit simplification, equivalence detection(and code generation in the next release). They are included in <code>src/rule.jl</code>. Users of <code>SymbolicCircuit.jl</code> could of course define more rules they would like to. For more details, one can refer to the <a href="https://github.com/overshiki/SymbolicCircuit.jl/blob/main/tutorial/define_rules.md">tutorial</a> on how to do this.</p>
<h4 dir="auto"><a id="user-content-term-rewriting--equality-saturation" class="anchor" aria-hidden="true" href="#term-rewriting--equality-saturation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Term rewriting &amp; Equality saturation</h4>
<p dir="auto">The core operation of <code>SymbolicCircuit.jl</code> is to apply a variaty of syntactic rules to term rewriting &amp; equality saturation system provided by <a href="https://github.com/JuliaSymbolics/Metatheory.jl"><code>Metatheory.jl</code></a>, which allows powerful circuit manipulate functions. For example, term rewriting could be used to transform all Pauli Z gates in a circuit into <code>H X H</code> following rewriting rule <code>Z=HXH</code>. This could be easily handled using <code>SymbolicCircuit.jl</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SymbolicCircuit
using SymbolicCircuit: is_Z, is_commute, is_cancel
using Metatheory
using Metatheory: PassThrough, Postwalk

x1 = UGate(gX(), [Loc(1), ])
y3 = UGate(gY(), [Loc(3), ])
z2 = UGate(gZ(), [Loc(2), ])
z3 = UGate(gZ(), [Loc(3), ])

circ = x1 * z2 * y3 * z3 * x1 * z3

function get_HXH(a::Gate)
    h = UGate(gH(), a.loc)
    x = UGate(gX(), a.loc)
    return :($(h) * $(x) * $(h))
end

r = @rule a a::Gate =&gt; get_HXH(a) where is_Z(a)
r = Postwalk(PassThrough(r))
@show Circuit(r(circ.expr))"><pre><span class="pl-k">using</span> SymbolicCircuit
<span class="pl-k">using</span> SymbolicCircuit<span class="pl-k">:</span> is_Z, is_commute, is_cancel
<span class="pl-k">using</span> Metatheory
<span class="pl-k">using</span> Metatheory<span class="pl-k">:</span> PassThrough, Postwalk

x1 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gX</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">1</span>), ])
y3 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gY</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">3</span>), ])
z2 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gZ</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">2</span>), ])
z3 <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gZ</span>(), [<span class="pl-c1">Loc</span>(<span class="pl-c1">3</span>), ])

circ <span class="pl-k">=</span> x1 <span class="pl-k">*</span> z2 <span class="pl-k">*</span> y3 <span class="pl-k">*</span> z3 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> z3

<span class="pl-k">function</span> <span class="pl-en">get_HXH</span>(a<span class="pl-k">::</span><span class="pl-c1">Gate</span>)
    h <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gH</span>(), a<span class="pl-k">.</span>loc)
    x <span class="pl-k">=</span> <span class="pl-c1">UGate</span>(<span class="pl-c1">gX</span>(), a<span class="pl-k">.</span>loc)
    <span class="pl-k">return</span> :(<span class="pl-k">$</span>(h) <span class="pl-k">*</span> <span class="pl-k">$</span>(x) <span class="pl-k">*</span> <span class="pl-k">$</span>(h))
<span class="pl-k">end</span>

r <span class="pl-k">=</span> <span class="pl-c1">@rule</span> a a<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">get_HXH</span>(a) <span class="pl-k">where</span> <span class="pl-c1">is_Z</span>(a)
r <span class="pl-k">=</span> <span class="pl-c1">Postwalk</span>(<span class="pl-c1">PassThrough</span>(r))
<span class="pl-c1">@show</span> <span class="pl-c1">Circuit</span>(<span class="pl-c1">r</span>(circ<span class="pl-k">.</span>expr))</pre></div>
<p dir="auto">Of course, this is just a simple rewriting rule, and could be done using any non-symbolic systems such as direct coding in qiskit|Yao.jl|mindquantum|...(for example, in mindquantum, circuits are represented as object of List class in python, such manipulation could be easily done using pop and insert operations).</p>
<p dir="auto">The full power of <code>SymbolicCircuit.jl</code> comes from the qquality saturation techniques in symbolic &amp; compiler community. In equality saturation(Eqsat), the term rewriting are allowed to be handled without an order. For example, bidirectional rules such as gate commute rule <code>a*b==b*a</code> are allowed. The key point of Eqsat is that it allows all combination of rewriting operations to be stored in memory(usually in efficient EGraph data structure as implemented in <a href="https://github.com/JuliaSymbolics/Metatheory.jl"><code>Metatheory.jl</code></a>), and efficiently traversed. Thus one could set the search goal to search for specific expressions in all equivalent expressions resulted from the rewriting rules, which would be a complex task for non-symbolic systems without Eqsat techniques, such as qiskit|Yao.jl|mindquantum|...</p>
<p dir="auto">To demonstrate, let's consider circuit simplification operation. We consider only a combination of commute rule <code>a*b==b*a where a, b commute</code> and cancel rule <code>a*b-&gt;0 where a, b could be cancelled</code>. These simple rules already provide a strategy to simplify a circuit, i.e. for any pair of gates in a circuit, commute if possible, cancel if possible, and then try more commutation and cancellation, until no progress could be made. In a non-symbolic system without Eqsat, such strategy could only be implemented using a heuristic approach without a saturation guarantee(or it could have saturation guarantee but need a lot of codings). In <code>SymbolicCircuit.jl</code> it would be easily achiveable and has a guarantee that all possible combination are traversed.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SymbolicCircuit
using Metatheory
using Metatheory.Library: @right_associative, @left_associative
v = AbstractRule[]
push!(v, @rule a b a::Gate * b::Gate =&gt; :($(b) * $(a)) where is_commute(a, b))
push!(v, @rule a b a::Gate * b::Gate =&gt; One() where is_cancel(a, b))
push!(v, @rule a b b::One * a::Gate =&gt; :($(a)))
push!(v, @rule a b a::Gate * b::One =&gt; :($(a)))

ra = @right_associative (*)
la = @left_associative (*)
push!(v, ra)
push!(v, la)

function simplify(circuit)
    g = EGraph(circuit)
    params = SaturationParams(timeout=10, eclasslimit=40000)
    report = saturate!(g, v, params)
    circuit = extract!(g, astsize)
    return circuit
end 

circ = x1 * x1 * h2 * y3 * x1 * x1 * h2
ncirc = simplify(circ)"><pre><span class="pl-k">using</span> SymbolicCircuit
<span class="pl-k">using</span> Metatheory
<span class="pl-k">using</span> Metatheory<span class="pl-k">.</span>Library<span class="pl-k">:</span> <span class="pl-c1">@right_associative</span>, <span class="pl-c1">@left_associative</span>
v <span class="pl-k">=</span> AbstractRule[]
<span class="pl-c1">push!</span>(v, <span class="pl-c1">@rule</span> a b a<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">*</span> b<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">=&gt;</span> :(<span class="pl-k">$</span>(b) <span class="pl-k">*</span> <span class="pl-k">$</span>(a)) <span class="pl-k">where</span> <span class="pl-c1">is_commute</span>(a, b))
<span class="pl-c1">push!</span>(v, <span class="pl-c1">@rule</span> a b a<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">*</span> b<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">One</span>() <span class="pl-k">where</span> <span class="pl-c1">is_cancel</span>(a, b))
<span class="pl-c1">push!</span>(v, <span class="pl-c1">@rule</span> a b b<span class="pl-k">::</span><span class="pl-c1">One</span> <span class="pl-k">*</span> a<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">=&gt;</span> :(<span class="pl-k">$</span>(a)))
<span class="pl-c1">push!</span>(v, <span class="pl-c1">@rule</span> a b a<span class="pl-k">::</span><span class="pl-c1">Gate</span> <span class="pl-k">*</span> b<span class="pl-k">::</span><span class="pl-c1">One</span> <span class="pl-k">=&gt;</span> :(<span class="pl-k">$</span>(a)))

ra <span class="pl-k">=</span> <span class="pl-c1">@right_associative</span> (<span class="pl-k">*</span>)
la <span class="pl-k">=</span> <span class="pl-c1">@left_associative</span> (<span class="pl-k">*</span>)
<span class="pl-c1">push!</span>(v, ra)
<span class="pl-c1">push!</span>(v, la)

<span class="pl-k">function</span> <span class="pl-en">simplify</span>(circuit)
    g <span class="pl-k">=</span> <span class="pl-c1">EGraph</span>(circuit)
    params <span class="pl-k">=</span> <span class="pl-c1">SaturationParams</span>(timeout<span class="pl-k">=</span><span class="pl-c1">10</span>, eclasslimit<span class="pl-k">=</span><span class="pl-c1">40000</span>)
    report <span class="pl-k">=</span> <span class="pl-c1">saturate!</span>(g, v, params)
    circuit <span class="pl-k">=</span> <span class="pl-c1">extract!</span>(g, astsize)
    <span class="pl-k">return</span> circuit
<span class="pl-k">end</span> 

circ <span class="pl-k">=</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2 <span class="pl-k">*</span> y3 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2
ncirc <span class="pl-k">=</span> <span class="pl-c1">simplify</span>(circ)</pre></div>
<p dir="auto">result:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="UGate(gY(), Q[Loc(3)])"><pre><span class="pl-c1">UGate</span>(<span class="pl-c1">gY</span>(), Q[<span class="pl-c1">Loc</span>(<span class="pl-c1">3</span>)])</pre></div>
<p dir="auto">Another powerful function provided by the system is that, it allows to detect if two circuit are in equivalence under certain rules. For example, continue from the above circuit simplification task, just do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="areequal(v, circ, ncirc)"><pre><span class="pl-c1">areequal</span>(v, circ, ncirc)</pre></div>
<p dir="auto">results in:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="true"><pre><span class="pl-c1">true</span></pre></div>
<p dir="auto">will tell if <code>circ</code> and <code>ncirc</code> are in equivalent under the rules <code>v</code>.</p>
<h4 dir="auto"><a id="user-content-practical-usage" class="anchor" aria-hidden="true" href="#practical-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Practical usage</h4>
<p dir="auto">For those want to use <code>SymbolicCircuit.jl</code> as openbox toolset for some practical task, <code>SymbolicCircuit.jl</code> currently provides built-in functions including: circuit simplification, equivalence detection, where a default set of syntactic rules is used. (more simplification target and code generation function are on the way)
The list of the functions are:</p>
<p dir="auto"><code>egraph_simplify</code>: circuit simplification using default set of rules</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="circ = x1 * x1 * h2 * y3 * x1 * x1 * h2
circ = egraph_simplify(circ, Val(:default_rule); verbose=false)"><pre>circ <span class="pl-k">=</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2 <span class="pl-k">*</span> y3 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> x1 <span class="pl-k">*</span> h2
circ <span class="pl-k">=</span> <span class="pl-c1">egraph_simplify</span>(circ, <span class="pl-c1">Val</span>(<span class="pl-c1">:default_rule</span>); verbose<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto"><code>areequal</code>: overload of <code>areequal</code> function in <a href="https://github.com/JuliaSymbolics/Metatheory.jl"><code>Metatheory.jl</code></a>, using default set of rules</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="SymbolicCircuit.areequal(Val(:default_rule), circ1, circ2, circ3)"><pre>SymbolicCircuit<span class="pl-k">.</span><span class="pl-c1">areequal</span>(<span class="pl-c1">Val</span>(<span class="pl-c1">:default_rule</span>), circ1, circ2, circ3)</pre></div>
<h4 dir="auto"><a id="user-content-more-information" class="anchor" aria-hidden="true" href="#more-information"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>More information</h4>
<p dir="auto">For more information, please refer to <code>test</code> folder. Issue and PR are welcomed.</p>
<h4 dir="auto"><a id="user-content-next-step" class="anchor" aria-hidden="true" href="#next-step"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Next step:</h4>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="- Some examples in example folder
- More rewriting rules
- T-gate reduction functions
- Codegen for numerical simulation
- Documentations!"><pre class="notranslate"><code>- Some examples in example folder
- More rewriting rules
- T-gate reduction functions
- Codegen for numerical simulation
- Documentations!
</code></pre></div>
</article></div>