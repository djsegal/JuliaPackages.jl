<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-scanbytejl" class="anchor" aria-hidden="true" href="#scanbytejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ScanByte.jl</h1>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/jakobnissen/ScanByte.jl/workflows/CI/badge.svg"><img src="https://github.com/jakobnissen/ScanByte.jl/workflows/CI/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jakobnissen/ScanByte.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f76000c1d5933d1efc2772797459df4609a6f5069de4da6d5df813f10fc8d489/68747470733a2f2f636f6465636f762e696f2f67682f6a616b6f626e697373656e2f5363616e427974652e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/jakobnissen/ScanByte.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><em>Find your bytes. Fast.</em></p>
<p dir="auto">ScanByte is a package to solve a simple problem: Find the first occurrence of a byte or any byte from a set of bytes in a chunk of memory. Think of it like a much faster version of <code>findfirst</code> that only iterates over bytes in memory.</p>
<p dir="auto">ScanByte is micro-optimized for speed. On my laptop it can hit the RAM bandwidth limit of around 20 GB/s. This speed makes it a suitable building block for string search engines, Regex implementations, parsers and similar use cases.</p>
<h3 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h3>
<p dir="auto">The central function of interest in this package is <code>memchr</code>.
The function takes a chunk of memory and some bytes, and returns the first position (1-indexed) in the chunk of memory where any byte from the byte set is found, or <code>nothing</code> if no bytes are found.</p>
<p dir="auto">The chunk of memory can be any type which implements methods for <code>pointer</code> and <code>sizeof</code>, or alternatively you can input a raw pointer and a size.</p>
<p dir="auto">The byte set can be passed in in two different ways:</p>
<ul dir="auto">
<li>As a single <code>UInt8</code>, in which case ScanByte will simply dispatch to libc's memchr function</li>
<li>A <code>Val{bs}</code>, where <code>bs</code> is an instance of the type <code>ByteSet &lt;: AbstractSet{UInt8}</code> from this package.</li>
</ul>
<p dir="auto">In the latter case, ScanByte will, at compile time, pick an efficient SIMD algorithm based on the content of the byteset.
Currently ScanByte only has SIMD algorithms for SSSE3 and AVX2 instruction sets (found in all x86-based PCs), and uses a slow fallback for CPUs without these instructions.</p>
<h3 dir="auto"><a id="user-content-example-usage" class="anchor" aria-hidden="true" href="#example-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example usage</h3>
<p dir="auto">In all these examples, the input data can be a <code>String</code>, a <code>codeunits</code> object, an <code>Array{UInt8}</code>, or a pointer+length.
Any type that implements <code>pointer</code> and <code>sizeof</code> will do.</p>
<p dir="auto">Search for a single byte:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; memchr(&quot;Julia&quot;, UInt8('i'))
4

julia&gt; memchr(codeunits(&quot;Julia&quot;), UInt8('z')) === nothing
true

julia&gt; str = &quot;Julia&quot;;

julia&gt; GC.@preserve str memchr(pointer(str), sizeof(str) % UInt, UInt8('i'))
4"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">memchr</span>(<span class="pl-s"><span class="pl-pds">"</span>Julia<span class="pl-pds">"</span></span>, <span class="pl-c1">UInt8</span>(<span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>))
<span class="pl-c1">4</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">memchr</span>(<span class="pl-c1">codeunits</span>(<span class="pl-s"><span class="pl-pds">"</span>Julia<span class="pl-pds">"</span></span>), <span class="pl-c1">UInt8</span>(<span class="pl-s"><span class="pl-pds">'</span>z<span class="pl-pds">'</span></span>)) <span class="pl-k">===</span> <span class="pl-c1">nothing</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Julia<span class="pl-pds">"</span></span>;

julia<span class="pl-k">&gt;</span> GC<span class="pl-k">.</span><span class="pl-c1">@preserve</span> str <span class="pl-c1">memchr</span>(<span class="pl-c1">pointer</span>(str), <span class="pl-c1">sizeof</span>(str) <span class="pl-k">%</span> UInt, <span class="pl-c1">UInt8</span>(<span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>))
<span class="pl-c1">4</span></pre></div>
<p dir="auto">Search for a byteset. Here, <code>Val</code> must be used to force specialization on the byteset:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; bs = ByteSet([0x01, 0x6a, 0xf1]);

julia&gt; memchr([0x4a, 0xf1], Val(bs))
3"><pre>julia<span class="pl-k">&gt;</span> bs <span class="pl-k">=</span> <span class="pl-c1">ByteSet</span>([<span class="pl-c1">0x01</span>, <span class="pl-c1">0x6a</span>, <span class="pl-c1">0xf1</span>]);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">memchr</span>([<span class="pl-c1">0x4a</span>, <span class="pl-c1">0xf1</span>], <span class="pl-c1">Val</span>(bs))
<span class="pl-c1">3</span></pre></div>
<p dir="auto">Search using a function. To do this, you must construct a <code>ByteSet</code> using the predicate on <code>0x00:0xff</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; f(x) = in(x, 0x1a:0x4c) || in(x, 0xd1:0xf1); # some function

julia&gt; bs = ByteSet(filter(f, 0x00:0xff));

julia&gt; memchr(&quot;hello, Bob&quot;, Val(bs))
6"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">f</span>(x) <span class="pl-k">=</span> <span class="pl-c1">in</span>(x, <span class="pl-c1">0x1a</span><span class="pl-k">:</span><span class="pl-c1">0x4c</span>) <span class="pl-k">||</span> <span class="pl-c1">in</span>(x, <span class="pl-c1">0xd1</span><span class="pl-k">:</span><span class="pl-c1">0xf1</span>); <span class="pl-c"><span class="pl-c">#</span> some function</span>

julia<span class="pl-k">&gt;</span> bs <span class="pl-k">=</span> <span class="pl-c1">ByteSet</span>(<span class="pl-c1">filter</span>(f, <span class="pl-c1">0x00</span><span class="pl-k">:</span><span class="pl-c1">0xff</span>));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">memchr</span>(<span class="pl-s"><span class="pl-pds">"</span>hello, Bob<span class="pl-pds">"</span></span>, <span class="pl-c1">Val</span>(bs))
<span class="pl-c1">6</span></pre></div>
<h2 dir="auto"><a id="user-content-drawbacks" class="anchor" aria-hidden="true" href="#drawbacks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Drawbacks</h2>
<p dir="auto">At the moment, ScanByte has three major drawbacks:</p>
<ul dir="auto">
<li>If you are search for a predicate/byteset and not a single byte, tt relies on generated functions to compute the optimal Julia code to create the scanning function. This means the byte set must be known at compile time.</li>
<li>It relies on explicit SIMD instructions. To be fast, it must run on computers with ideally the <code>AVX2</code> instruction set, or with the <code>SSE2</code> and <code>SSSE3</code> sets. Also, if you create the scanning function on a computer with <code>AVX2</code> but runs it on a computer without, LLVM will probably crash. Currently, the fallback methods are fairly slow.</li>
<li>There is no guaranteed stable version of detecting which SIMD instructions your Julia supports. So this package tries to guess by parsing some output from LLVM.</li>
</ul>
</article></div>