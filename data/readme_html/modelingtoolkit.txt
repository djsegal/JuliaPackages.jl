<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-modelingtoolkitjl" class="anchor" aria-hidden="true" href="#modelingtoolkitjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ModelingToolkit.jl</h1>
<p><a href="https://travis-ci.org/JuliaDiffEq/ModelingToolkit.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/aa770b321c1eb9044a0517d75da97f7f3caf8975/68747470733a2f2f7472617669732d63692e6f72672f4a756c69614469666645712f4d6f64656c696e67546f6f6c6b69742e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaDiffEq/ModelingToolkit.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/JuliaDiffEq/ModelingToolkit.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/0eed8a4eeab7745dd71ed2a540c3894f1ed02648/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f4a756c69614469666645712f4d6f64656c696e67546f6f6c6b69742e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/JuliaDiffEq/ModelingToolkit.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a>
<a href="http://codecov.io/github/JuliaDiffEq/ModelingToolkit.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/6479a22a37e75aed2c735e5e2cf5d6abbd960ed0/687474703a2f2f636f6465636f762e696f2f6769746875622f4a756c69614469666645712f4d6f64656c696e67546f6f6c6b69742e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/JuliaDiffEq/ModelingToolkit.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>ModelingToolkit.jl is an intermediate representation (IR) of computational graphs
for scientific computing problems. Its purpose is to be a common target for
modeling DSLs in order to allow for a common platform for model inspection and
transformation. It uses a tagged variable IR in order to allow specification of
complex models and allow for transformations of models. It has ways to plug into
its function registration and derivative system so that way it can interact
nicely with user-defined routines. Together, this is an abstract form of a
scientific model that is easy for humans to generate but also easy for programs
to manipulate.</p>
<h2><a id="user-content-tutorial" class="anchor" aria-hidden="true" href="#tutorial"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tutorial</h2>
<p>For an introductory tutorial to using ModelingToolkit.jl, please checkout
<a href="https://tutorials.juliadiffeq.org/html/ode_extras/01-ModelingToolkit.html" rel="nofollow">ModelingToolkit.jl, An IR and Compiler for Scientific Models</a>.</p>
<h2><a id="user-content-introduction-by-examples" class="anchor" aria-hidden="true" href="#introduction-by-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction by Examples</h2>
<h3><a id="user-content-example-ode" class="anchor" aria-hidden="true" href="#example-ode"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example: ODE</h3>
<p>Let's build an ODE. First we define some variables. In a differential equation
system, we need to differentiate between our (dependent) variables
and parameters. Therefore we label them as follows:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ModelingToolkit

<span class="pl-c"><span class="pl-c">#</span> Define some variables</span>
<span class="pl-c1">@parameters</span> t σ ρ β
<span class="pl-c1">@variables</span> <span class="pl-c1">x</span>(t) <span class="pl-c1">y</span>(t) <span class="pl-c1">z</span>(t)
<span class="pl-c1">@derivatives</span> D<span class="pl-k">'</span><span class="pl-k">~</span>t</pre></div>
<p>Then we build the system:</p>
<div class="highlight highlight-source-julia"><pre>eqs <span class="pl-k">=</span> [<span class="pl-c1">D</span>(x) <span class="pl-k">~</span> σ<span class="pl-k">*</span>(y<span class="pl-k">-</span>x),
       <span class="pl-c1">D</span>(y) <span class="pl-k">~</span> x<span class="pl-k">*</span>(ρ<span class="pl-k">-</span>z)<span class="pl-k">-</span>y,
       <span class="pl-c1">D</span>(z) <span class="pl-k">~</span> x<span class="pl-k">*</span>y <span class="pl-k">-</span> β<span class="pl-k">*</span>z]</pre></div>
<p>Each operation builds an <code>Operation</code> type, and thus <code>eqs</code> is an array of
<code>Operation</code> and <code>Variable</code>s. This holds a tree of the full system that can be
analyzed by other programs. We can turn this into a <code>ODESystem</code> via:</p>
<div class="highlight highlight-source-julia"><pre>de <span class="pl-k">=</span> <span class="pl-c1">ODESystem</span>(eqs, t, [x,y,z], [σ,ρ,β])</pre></div>
<p>where we tell it the variable types and ordering in the first version, or let it
automatically determine the variable types in the second version.
This can then generate the function. For example, we can see the
generated code via:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> MacroTools
myode_oop <span class="pl-k">=</span> <span class="pl-c1">generate_function</span>(de)[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> first one is the out-of-place function</span>
MacroTools<span class="pl-k">.</span><span class="pl-c1">striplines</span>(myode_oop) <span class="pl-c"><span class="pl-c">#</span> print without line numbers</span>

<span class="pl-c"><span class="pl-c">#=</span></span>
<span class="pl-c">:((u, p, t)-&gt;begin</span>
<span class="pl-c">          if u isa Array</span>
<span class="pl-c">              return @inbounds(begin</span>
<span class="pl-c">                          let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])</span>
<span class="pl-c">                              [σ * (y - x), x * (ρ - z) - y, x * y - β * z]</span>
<span class="pl-c">                          end</span>
<span class="pl-c">                      end)</span>
<span class="pl-c">          else</span>
<span class="pl-c">              X = @inbounds(begin</span>
<span class="pl-c">                          let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])</span>
<span class="pl-c">                              (σ * (y - x), x * (ρ - z) - y, x * y - β * z)</span>
<span class="pl-c">                          end</span>
<span class="pl-c">                      end)</span>
<span class="pl-c">          end</span>
<span class="pl-c">          T = promote_type(map(typeof, X)...)</span>
<span class="pl-c">          map(T, X)</span>
<span class="pl-c">          construct = if u isa ModelingToolkit.StaticArrays.StaticArray</span>
<span class="pl-c">                  ModelingToolkit.StaticArrays.similar_type(typeof(u), eltype(X))</span>
<span class="pl-c">              else</span>
<span class="pl-c">                  x-&gt;begin</span>
<span class="pl-c">                          convert(typeof(u), x)</span>
<span class="pl-c">                      end</span>
<span class="pl-c">              end</span>
<span class="pl-c">          construct(X)</span>
<span class="pl-c">      end)</span>
<span class="pl-c"><span class="pl-c">=#</span></span>

myode_iip <span class="pl-k">=</span> <span class="pl-c1">generate_function</span>(de)[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> second one is the in-place function</span>
MacroTools<span class="pl-k">.</span><span class="pl-c1">striplines</span>(myode_iip) <span class="pl-c"><span class="pl-c">#</span> print without line numbers</span>

<span class="pl-c"><span class="pl-c">#=</span></span>
<span class="pl-c">:((var"##MTIIPVar#793", u, p, t)-&gt;begin</span>
<span class="pl-c">          @inbounds begin</span>
<span class="pl-c">                  @inbounds begin</span>
<span class="pl-c">                          let (x, y, z, σ, ρ, β) = (u[1], u[2], u[3], p[1], p[2], p[3])</span>
<span class="pl-c">                              var"##MTIIPVar#793"[1] = σ * (y - x)</span>
<span class="pl-c">                              var"##MTIIPVar#793"[2] = x * (ρ - z) - y</span>
<span class="pl-c">                              var"##MTIIPVar#793"[3] = x * y - β * z</span>
<span class="pl-c">                          end</span>
<span class="pl-c">                      end</span>
<span class="pl-c">              end</span>
<span class="pl-c">          nothing</span>
<span class="pl-c">      end)</span>
<span class="pl-c"><span class="pl-c">=#</span></span></pre></div>
<p>or directly get the generated ODE function via:</p>
<div class="highlight highlight-source-julia"><pre>f <span class="pl-k">=</span> <span class="pl-c1">ODEFunction</span>(de, [x,y,z], [σ,ρ,β])</pre></div>
<p>Here already you can see some advantages of the ModelingToolkit.jl compilation system. As an
IR to target, this output can compile to multiple different forms, including ones specific
to static arrays and in-place functions. Forms which automatically parallelize the calculations
based on internal cost models are a work-in-progress as well. This means DSLs built on top of
this as a model compiler can write domain-specific languages without having to write complex
optimized Julia function compilers.</p>
<h3><a id="user-content-example-nonlinear-system-with-nlsolvejl" class="anchor" aria-hidden="true" href="#example-nonlinear-system-with-nlsolvejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example: Nonlinear System with NLsolve.jl</h3>
<p>We can also build nonlinear systems. Let's say we wanted to solve for the steady
state of the previous ODE. This is the nonlinear system defined by where the
derivatives are zero. We use (unknown) variables for our nonlinear system.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ModelingToolkit

<span class="pl-c1">@variables</span> x y z
<span class="pl-c1">@parameters</span> σ ρ β

<span class="pl-c"><span class="pl-c">#</span> Define a nonlinear system</span>
eqs <span class="pl-k">=</span> [<span class="pl-c1">0</span> <span class="pl-k">~</span> σ<span class="pl-k">*</span>(y<span class="pl-k">-</span>x),
       <span class="pl-c1">0</span> <span class="pl-k">~</span> x<span class="pl-k">*</span>(ρ<span class="pl-k">-</span>z)<span class="pl-k">-</span>y,
       <span class="pl-c1">0</span> <span class="pl-k">~</span> x<span class="pl-k">*</span>y <span class="pl-k">-</span> β<span class="pl-k">*</span>z]
ns <span class="pl-k">=</span> <span class="pl-c1">NonlinearSystem</span>(eqs, [x,y,z], [σ,ρ,β])
nlsys_func <span class="pl-k">=</span> <span class="pl-c1">generate_function</span>(ns)[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> second is the inplace version</span></pre></div>
<p>which generates:</p>
<div class="highlight highlight-source-julia"><pre>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#405<span class="pl-pds">"</span></span>, u, p)<span class="pl-k">-&gt;</span><span class="pl-k">begin</span>
        <span class="pl-c1">@inbounds</span> <span class="pl-k">begin</span>
                <span class="pl-c1">@inbounds</span> <span class="pl-k">begin</span>
                        <span class="pl-k">let</span> (x, y, z, σ, ρ, β) <span class="pl-k">=</span> (u[<span class="pl-c1">1</span>], u[<span class="pl-c1">2</span>], u[<span class="pl-c1">3</span>], p[<span class="pl-c1">1</span>], p[<span class="pl-c1">2</span>], p[<span class="pl-c1">3</span>])
                            <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#405<span class="pl-pds">"</span></span>[<span class="pl-c1">1</span>] <span class="pl-k">=</span> (<span class="pl-k">*</span>)(σ, (<span class="pl-k">-</span>)(y, x))
                            <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#405<span class="pl-pds">"</span></span>[<span class="pl-c1">2</span>] <span class="pl-k">=</span> (<span class="pl-k">-</span>)((<span class="pl-k">*</span>)(x, (<span class="pl-k">-</span>)(ρ, z)), y)
                            <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#405<span class="pl-pds">"</span></span>[<span class="pl-c1">3</span>] <span class="pl-k">=</span> (<span class="pl-k">-</span>)((<span class="pl-k">*</span>)(x, y), (<span class="pl-k">*</span>)(β, z))
                        <span class="pl-k">end</span>
                    <span class="pl-k">end</span>
            <span class="pl-k">end</span>
        <span class="pl-c1">nothing</span>
    <span class="pl-k">end</span></pre></div>
<p>We can use this to build a nonlinear function for use with NLsolve.jl:</p>
<div class="highlight highlight-source-julia"><pre>f <span class="pl-k">=</span> <span class="pl-c1">eval</span>(nlsys_func)
du <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">3</span>); u <span class="pl-k">=</span> <span class="pl-c1">ones</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">f</span>(du,u,(<span class="pl-c1">10.0</span>,<span class="pl-c1">26.0</span>,<span class="pl-c1">2.33</span>))
du

<span class="pl-c"><span class="pl-c">#=</span></span>
<span class="pl-c">3-element Array{Float64,1}:</span>
<span class="pl-c">  0.0</span>
<span class="pl-c"> 24.0</span>
<span class="pl-c"> -1.33</span>
<span class="pl-c"> <span class="pl-c">=#</span></span></pre></div>
<p>We can similarly ask to generate the in-place Jacobian function:</p>
<div class="highlight highlight-source-julia"><pre>j_func <span class="pl-k">=</span> <span class="pl-c1">generate_jacobian</span>(ns)[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> second is in-place</span>
j! <span class="pl-k">=</span> <span class="pl-c1">eval</span>(j_func)</pre></div>
<p>which gives:</p>
<div class="highlight highlight-source-julia"><pre>:((<span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>, u, p)<span class="pl-k">-&gt;</span><span class="pl-k">begin</span>
          <span class="pl-c"><span class="pl-c">#=</span> C:\Users\accou\.julia\dev\ModelingToolkit\src\utils.jl:70 <span class="pl-c">=#</span></span>
          <span class="pl-c"><span class="pl-c">#=</span> C:\Users\accou\.julia\dev\ModelingToolkit\src\utils.jl:71 <span class="pl-c">=#</span></span>
          <span class="pl-c"><span class="pl-c">#=</span> C:\Users\accou\.julia\dev\ModelingToolkit\src\utils.jl:71 <span class="pl-c">=#</span></span> <span class="pl-c1">@inbounds</span> <span class="pl-k">begin</span>
                  <span class="pl-c"><span class="pl-c">#=</span> C:\Users\accou\.julia\dev\ModelingToolkit\src\utils.jl:72 <span class="pl-c">=#</span></span>
                  <span class="pl-c"><span class="pl-c">#=</span> C:\Users\accou\.julia\dev\ModelingToolkit\src\utils.jl:53 <span class="pl-c">=#</span></span> <span class="pl-c1">@inbounds</span> <span class="pl-k">begin</span>
                          <span class="pl-c"><span class="pl-c">#=</span> C:\Users\accou\.julia\dev\ModelingToolkit\src\utils.jl:53 <span class="pl-c">=#</span></span>
                          <span class="pl-k">let</span> (x, y, z, σ, ρ, β) <span class="pl-k">=</span> (u[<span class="pl-c1">1</span>], u[<span class="pl-c1">2</span>], u[<span class="pl-c1">3</span>], p[<span class="pl-c1">1</span>], p[<span class="pl-c1">2</span>], p[<span class="pl-c1">3</span>])
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">1</span>] <span class="pl-k">=</span> (<span class="pl-k">*</span>)(σ, <span class="pl-k">-</span><span class="pl-c1">1</span>)
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">2</span>] <span class="pl-k">=</span> (<span class="pl-k">-</span>)(ρ, z)
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">3</span>] <span class="pl-k">=</span> y
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">4</span>] <span class="pl-k">=</span> σ
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">5</span>] <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">6</span>] <span class="pl-k">=</span> x
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">7</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span>
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">8</span>] <span class="pl-k">=</span> (<span class="pl-k">*</span>)(x, <span class="pl-k">-</span><span class="pl-c1">1</span>)
                              <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>##MTIIPVar#582<span class="pl-pds">"</span></span>[<span class="pl-c1">9</span>] <span class="pl-k">=</span> (<span class="pl-k">*</span>)(<span class="pl-k">-</span><span class="pl-c1">1</span>, β)
                          <span class="pl-k">end</span>
                      <span class="pl-k">end</span>
              <span class="pl-k">end</span>
          <span class="pl-c"><span class="pl-c">#=</span> C:\Users\accou\.julia\dev\ModelingToolkit\src\utils.jl:74 <span class="pl-c">=#</span></span>
          <span class="pl-c1">nothing</span>
      <span class="pl-k">end</span>)</pre></div>
<p>Now we can call <code>nlsolve</code> by enclosing our parameters into the functions:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">nlsolve</span>((out, x) <span class="pl-k">-&gt;</span> <span class="pl-c1">f</span>(out, x, params), (out, x) <span class="pl-k">-&gt;</span> <span class="pl-c1">j!</span>(out, x, params), <span class="pl-c1">ones</span>(<span class="pl-c1">3</span>))</pre></div>
<p>If one would like the generated function to be a Julia function instead of an expression, and allow this
function to be used from within the same world-age, one simply needs to pass <code>Val{false}</code> to tell it to
generate the function, i.e.:</p>
<div class="highlight highlight-source-julia"><pre>nlsys_func <span class="pl-k">=</span> <span class="pl-c1">generate_function</span>(ns, [x,y,z], [σ,ρ,β], Val{<span class="pl-c1">false</span>})[<span class="pl-c1">2</span>]</pre></div>
<p>which uses GeneralizedGenerated.jl to build a same world-age function on the fly without eval.</p>
<h3><a id="user-content-example-arrays-of-variables" class="anchor" aria-hidden="true" href="#example-arrays-of-variables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example: Arrays of variables</h3>
<p>Sometimes it is convenient to define arrays of variables to model things like <code>x₁,…,x₃</code>.
The <code>@variables</code> and <code>@parameters</code> macros support this with the following syntax:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@variables</span> x[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>];
julia<span class="pl-k">&gt;</span> x
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Operation,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">x₁</span>()
 <span class="pl-c1">x₂</span>()
 <span class="pl-c1">x₃</span>()

<span class="pl-c"><span class="pl-c">#</span> support for arbitrary ranges and tensors</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@variables</span> y[<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">3</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span><span class="pl-k">:</span><span class="pl-c1">6</span>];
julia<span class="pl-k">&gt;</span> y
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Operation,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
    y₂̒₁() y₂̒₆()
    y₃̒₁() y₃̒₆()

<span class="pl-c"><span class="pl-c">#</span> also works for dependent variables</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@parameters</span> t; <span class="pl-c1">@variables</span> z[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>](t);
julia<span class="pl-k">&gt;</span> z
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Operation,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">z₁</span>(<span class="pl-c1">t</span>())
 <span class="pl-c1">z₂</span>(<span class="pl-c1">t</span>())
 <span class="pl-c1">z₃</span>(<span class="pl-c1">t</span>())</pre></div>
<h2><a id="user-content-core-principles" class="anchor" aria-hidden="true" href="#core-principles"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Core Principles</h2>
<p>The core idea behind ModelingToolkit.jl is that mathematical equations require
context, and thus any symbolic manipulations and full model specifications
requires the ability to handle such context. When writing DSLs, this fact
comes to light very quickly. Every DSL seems to lower to some intermediate
representation from which the final result is computed, but this process means
there's a lot of repeated ideas for every DSL that creates scientific computing
objects like differential equations and nonlinear systems. By having a single
common contexualized IR, this gives DSLs a target to write to so that way
lower-level details like computation of system Jacobians can be disconnected
from the DSL and its syntax, allowing for code-reuse between modeling packages
and languages.</p>
<p>In this section we define the core pieces of the IR and what they mean.</p>
<h3><a id="user-content-variables" class="anchor" aria-hidden="true" href="#variables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variables</h3>
<p>The most fundamental part of the IR is the <code>Variable</code>. In order to mirror the
intention of solving for variables and representing function-like parameters,
we treat each instance of <code>Variable</code> as a function which is called on its
arguments using the natural syntax. Rather than having additional mechanisms
for handling constant variables and parameters, we simply represent them as
constant functions.</p>
<p>The <code>Variable</code> is the
context-aware single variable of the IR. Its fields are described as follows:</p>
<ul>
<li><code>name</code>: the name of the <code>Variable</code>. Note that this is not necessarily
the same as the name of the Julia variable. But this symbol itself is considered
the core identifier of the <code>Variable</code> in the sense of equality.</li>
<li><code>known</code>: the main denotation of context, storing whether or not the value of
the variable is known.</li>
</ul>
<p>For example, the following code defines an independent variable <code>t</code>, a parameter
<code>α</code>, a function parameter <code>σ</code>, a variable <code>x</code> which depends on <code>t</code>, a variable
<code>y</code> with no dependents, a variable <code>z</code> which depends on <code>t</code>, <code>α</code>, and <code>x(t)</code>
and a parameters <code>β₁</code> and <code>β₂</code>.</p>
<div class="highlight highlight-source-julia"><pre>t <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:t</span>; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)()  <span class="pl-c"><span class="pl-c">#</span> independent variables are treated as known</span>
α <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(:α; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)()  <span class="pl-c"><span class="pl-c">#</span> parameters are known</span>
σ <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(:σ; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)    <span class="pl-c"><span class="pl-c">#</span> left uncalled, since it is used as a function</span>
w <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:w</span>; known <span class="pl-k">=</span> <span class="pl-c1">false</span>)   <span class="pl-c"><span class="pl-c">#</span> unknown, left uncalled</span>
x <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:x</span>; known <span class="pl-k">=</span> <span class="pl-c1">false</span>)(t)  <span class="pl-c"><span class="pl-c">#</span> unknown, depends on `t`</span>
y <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:y</span>; known <span class="pl-k">=</span> <span class="pl-c1">false</span>)()   <span class="pl-c"><span class="pl-c">#</span> unknown, no dependents</span>
z <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:z</span>; known <span class="pl-k">=</span> <span class="pl-c1">false</span>)(t, α, x)  <span class="pl-c"><span class="pl-c">#</span> unknown, multiple arguments</span>
β₁ <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(:β, <span class="pl-c1">1</span>; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)() <span class="pl-c"><span class="pl-c">#</span> with index 1</span>
β₂ <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(:β, <span class="pl-c1">2</span>; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)() <span class="pl-c"><span class="pl-c">#</span> with index 2</span>

expr <span class="pl-k">=</span> β₁ <span class="pl-k">*</span> x <span class="pl-k">+</span> y<span class="pl-k">^</span>α <span class="pl-k">+</span> σ(<span class="pl-c1">3</span>) <span class="pl-k">*</span> (z <span class="pl-k">-</span> t) <span class="pl-k">-</span> β₂ <span class="pl-k">*</span> <span class="pl-c1">w</span>(t <span class="pl-k">-</span> <span class="pl-c1">1</span>)</pre></div>
<p>We can rewrite this more concisely using macros. Note the difference between
including and excluding empty parentheses. When in call format, variables are
aliased to the given call, allowing implicit use of dependents for convenience.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@parameters</span> t α σ(<span class="pl-k">..</span>) β[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>]
<span class="pl-c1">@variables</span> <span class="pl-c1">w</span>(<span class="pl-k">..</span>) <span class="pl-c1">x</span>(t) <span class="pl-c1">y</span>() <span class="pl-c1">z</span>(t, α, x)

expr <span class="pl-k">=</span> β₁<span class="pl-k">*</span> x <span class="pl-k">+</span> y<span class="pl-k">^</span>α <span class="pl-k">+</span> σ(<span class="pl-c1">3</span>) <span class="pl-k">*</span> (z <span class="pl-k">-</span> t) <span class="pl-k">-</span> β₂ <span class="pl-k">*</span> <span class="pl-c1">w</span>(t <span class="pl-k">-</span> <span class="pl-c1">1</span>)</pre></div>
<p>Note that <code>@parameters</code> and <code>@variables</code> implicitly add <code>()</code> to values that
are not given a call. The former specifies the values as known, while the
latter specifies it as unknown. <code>(..)</code> signifies that the value should be
left uncalled.</p>
<h3><a id="user-content-constants" class="anchor" aria-hidden="true" href="#constants"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constants</h3>
<p><code>Constant</code> is a simple wrapper type to store numerical Julia constants.</p>
<h3><a id="user-content-operations" class="anchor" aria-hidden="true" href="#operations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operations</h3>
<p>Operations are the basic composition of variables and puts together the pieces
with a function.</p>
<h3><a id="user-content-equations" class="anchor" aria-hidden="true" href="#equations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Equations</h3>
<p>Equations are stored using the <code>Equation</code> datatype. Given expressions for the
left-hand and right-hand sides, an equation is constructed as <code>Equation(lhs, rhs)</code>,
or equivalently <code>lhs ~ rhs</code>.</p>
<h3><a id="user-content-differentials" class="anchor" aria-hidden="true" href="#differentials"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Differentials</h3>
<p>A <code>Differential</code> denotes the derivative with respect to a given variable. It can
be expanded via <code>expand_derivatives</code>, which symbolically differentiates
expressions recursively and cancels out appropriate constant variables.</p>
<h3><a id="user-content-systems" class="anchor" aria-hidden="true" href="#systems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Systems</h3>
<p>A system is a collection of operations with expanded context. While different
systems can have different constructors and interpretations, the general
structure is as follows:</p>
<ul>
<li><code>eqs</code> is the first argument which is an array of <code>Operation</code> which describe
the system of equations.</li>
<li>Name to subtype mappings: these describe how variable <code>subtype</code>s are mapped
to the contexts of the system. For example, for a differential equation,
the variable corresponds to given subtypes and then the <code>eqs</code> can
be analyzed knowing what the state variables are.</li>
<li>Variable names which do not fall into one of the system's core subtypes are
treated as intermediates which can be used for holding subcalculations and
other pieces like that.</li>
</ul>
<h3><a id="user-content-transformations" class="anchor" aria-hidden="true" href="#transformations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transformations</h3>
<p>Transformation functions send IR objects to like IR objects. These utilize the
contextual information in a given <code>Operation</code>/<code>System</code> to build another
<code>Operation</code>/<code>System</code>.</p>
<h2><a id="user-content-details" class="anchor" aria-hidden="true" href="#details"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Details</h2>
<h3><a id="user-content-function-registration" class="anchor" aria-hidden="true" href="#function-registration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Function Registration</h3>
<p>A function is registered into the operation system via:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@register</span> <span class="pl-c1">f</span>(x)
<span class="pl-c1">@register</span> <span class="pl-c1">g</span>(x,y)</pre></div>
<p>etc. where each macro call registers the function with the given signature. This
will cause operations to stop recursing at this function, building <code>Operation(g,args)</code>
nodes into the graph instead of tracing calls of <code>g</code> itself into <code>Operation</code>s.</p>
<h3><a id="user-content-adding-derivatives" class="anchor" aria-hidden="true" href="#adding-derivatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding Derivatives</h3>
<p>There is a large amount of derivatives pre-defined by
<a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a>. Note that <code>Expression</code>
types are defined as <code>&lt;:Real</code>, and thus any functions which allow the use of real
numbers can automatically be traced by the derivative mechanism. Thus for example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">f</span>(x,y,z) <span class="pl-k">=</span> x<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">sin</span>(x<span class="pl-k">+</span>y) <span class="pl-k">-</span> z</pre></div>
<p>automatically has the derivatives defined via the tracing mechanism. It will do
this by directly building the operation the internals of your function and
differentiating that.</p>
<p>However, in many cases you may want to define your own derivatives so that way
automatic Jacobian etc. calculations can utilize this information. This can
allow for more succinct versions of the derivatives to be calculated in order
to better scale to larger systems. You can define derivatives for your own
function via the dispatch:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> `N` arguments are accepted by the relevant method of `my_function`</span>
ModelingToolkit<span class="pl-k">.</span><span class="pl-c1">derivative</span>(<span class="pl-k">::</span><span class="pl-c1">typeof</span>(my_function), args<span class="pl-k">::</span><span class="pl-c1">NTuple{N,Any}</span>, <span class="pl-k">::</span><span class="pl-c1">Val{i}</span>)</pre></div>
<p>where <code>i</code> means that it's the derivative of the <code>i</code>th argument. <code>args</code> is the
array of arguments, so for example if your function is <code>f(x,t)</code> then <code>args = [x,t]</code>.
You should return an <code>Operation</code> for the derivative of your function.</p>
<p>For example, <code>sin(t)</code>'s derivative (by <code>t</code>) is given by the following:</p>
<div class="highlight highlight-source-julia"><pre>ModelingToolkit<span class="pl-k">.</span><span class="pl-en">derivative</span>(<span class="pl-k">::</span><span class="pl-c1">typeof</span>(sin), args<span class="pl-k">::</span><span class="pl-c1">NTuple{1,Any}</span>, <span class="pl-k">::</span><span class="pl-c1">Val{1}</span>) <span class="pl-k">=</span> <span class="pl-c1">cos</span>(args[<span class="pl-c1">1</span>])</pre></div>
<h3><a id="user-content-macro-free-usage" class="anchor" aria-hidden="true" href="#macro-free-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Macro-free Usage</h3>
<p>Given the insistence on being programming friendly, all of the functionality
is accessible via a function-based interface. This means that all macros are
syntactic sugar in some form. For example, the variable construction:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@parameters</span> t σ ρ β[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>]
<span class="pl-c1">@variables</span> <span class="pl-c1">x</span>(t) <span class="pl-c1">y</span>(t) <span class="pl-c1">z</span>(t)
<span class="pl-c1">@derivatives</span> D<span class="pl-k">'</span><span class="pl-k">~</span>t</pre></div>
<p>is syntactic sugar for:</p>
<div class="highlight highlight-source-julia"><pre>t <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:t</span>; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)()
σ <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(:σ; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)()
ρ <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(:ρ; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)()
β <span class="pl-k">=</span> [<span class="pl-c1">Variable</span>(:β, i; known <span class="pl-k">=</span> <span class="pl-c1">true</span>)() <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>]
x <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:x</span>)(t)
y <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:y</span>)(t)
z <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">:z</span>)(t)
D <span class="pl-k">=</span> <span class="pl-c1">Differential</span>(t)</pre></div>
<h3><a id="user-content-intermediate-calculations" class="anchor" aria-hidden="true" href="#intermediate-calculations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Intermediate Calculations</h3>
<p>The system building functions can handle intermediate calculations. For example,</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@variables</span> x y z
<span class="pl-c1">@parameters</span> σ ρ β
a <span class="pl-k">=</span> y <span class="pl-k">-</span> x
eqs <span class="pl-k">=</span> [<span class="pl-c1">0</span> <span class="pl-k">~</span> σ<span class="pl-k">*</span>a,
       <span class="pl-c1">0</span> <span class="pl-k">~</span> x<span class="pl-k">*</span>(ρ<span class="pl-k">-</span>z)<span class="pl-k">-</span>y,
       <span class="pl-c1">0</span> <span class="pl-k">~</span> x<span class="pl-k">*</span>y <span class="pl-k">-</span> β<span class="pl-k">*</span>z]
ns <span class="pl-k">=</span> <span class="pl-c1">NonlinearSystem</span>(eqs, [x,y,z])
nlsys_func <span class="pl-k">=</span> <span class="pl-c1">generate_function</span>(ns, [x,y,z], [σ,ρ,β])</pre></div>
<p>expands to:</p>
<div class="highlight highlight-source-julia"><pre>:((<span class="pl-c"><span class="pl-c">#</span>#365, u, p)-&gt;begin</span>
          <span class="pl-k">let</span> (x, y, z, σ, ρ, β) <span class="pl-k">=</span> (u[<span class="pl-c1">1</span>], u[<span class="pl-c1">2</span>], u[<span class="pl-c1">3</span>], p[<span class="pl-c1">1</span>], p[<span class="pl-c1">2</span>], p[<span class="pl-c1">3</span>])
              <span class="pl-c"><span class="pl-c">#</span>#365[1] = σ * (y - x)</span>
              <span class="pl-c"><span class="pl-c">#</span>#365[2] = x * (ρ - z) - y</span>
              <span class="pl-c"><span class="pl-c">#</span>#365[3] = x * y - β * z</span>
          <span class="pl-k">end</span>
      <span class="pl-k">end</span>)</pre></div>
<p>In addition, the Jacobian calculations take into account intermediate variables
to appropriately handle them.</p>
</article></div>