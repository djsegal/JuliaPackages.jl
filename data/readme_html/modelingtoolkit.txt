<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-modelingtoolkitjl" class="anchor" aria-hidden="true" href="#modelingtoolkitjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ModelingToolkit.jl</h1>
<p><a href="https://travis-ci.org/SciML/ModelingToolkit.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/766546bc6d5b942cd97a9923b878bf4cab9060c0/68747470733a2f2f7472617669732d63692e6f72672f5363694d4c2f4d6f64656c696e67546f6f6c6b69742e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/SciML/ModelingToolkit.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/JuliaDiffEq/ModelingToolkit.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/c6ee2f9d9c5cb510f6cb59d588137a8df2849810/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f5363694d4c2f4d6f64656c696e67546f6f6c6b69742e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/SciML/ModelingToolkit.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a>
<a href="http://codecov.io/github/SciML/ModelingToolkit.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/fbb2e5f5945e8551764dfc690357dc268d19f94b/687474703a2f2f636f6465636f762e696f2f6769746875622f5363694d4c2f4d6f64656c696e67546f6f6c6b69742e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/SciML/ModelingToolkit.jl/coverage.svg?branch=master" style="max-width:100%;"></a>
<a href="http://mtk.sciml.ai/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/f7b92a177c912c1cc007fc9b40f17ff3ee3bb414/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a>
<a href="http://mtk.sciml.ai/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/3e353c26ddfe819150acbc732248f4f2a37f5175/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a></p>
<p>ModelingToolkit.jl is an intermediate representation (IR) of computational graphs
for scientific computing problems. Its purpose is to be a common target for
modeling DSLs in order to allow for a common platform for model inspection and
transformation. It uses a tagged variable IR in order to allow specification of
complex models and allow for transformations of models. It has ways to plug into
its function registration and derivative system so that way it can interact
nicely with user-defined routines. Together, this is an abstract form of a
scientific model that is easy for humans to generate but also easy for programs
to manipulate.</p>
<p>For information on using the package,
<a href="https://mtk.sciml.ai/stable/" rel="nofollow">see the stable documentation</a>. Use the
<a href="https://mtk.sciml.ai/dev/" rel="nofollow">in-development documentation</a> for the version of
the documentation which contains the un-released features.</p>
<h2><a id="user-content-high-level-examples" class="anchor" aria-hidden="true" href="#high-level-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>High Level Examples</h2>
<p>First let's define a second order riff on the Lorenz equations, symbolically
lower it to a first order system, symbolically generate the Jacobian function
for the numerical integrator, and solve it.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ModelingToolkit, OrdinaryDiffEq

<span class="pl-c1">@parameters</span> t σ ρ β
<span class="pl-c1">@variables</span> <span class="pl-c1">x</span>(t) <span class="pl-c1">y</span>(t) <span class="pl-c1">z</span>(t)
<span class="pl-c1">@derivatives</span> D<span class="pl-k">'</span><span class="pl-k">~</span>t

eqs <span class="pl-k">=</span> [<span class="pl-c1">D</span>(<span class="pl-c1">D</span>(x)) <span class="pl-k">~</span> σ<span class="pl-k">*</span>(y<span class="pl-k">-</span>x),
       <span class="pl-c1">D</span>(y) <span class="pl-k">~</span> x<span class="pl-k">*</span>(ρ<span class="pl-k">-</span>z)<span class="pl-k">-</span>y,
       <span class="pl-c1">D</span>(z) <span class="pl-k">~</span> x<span class="pl-k">*</span>y <span class="pl-k">-</span> β<span class="pl-k">*</span>z]

sys <span class="pl-k">=</span> <span class="pl-c1">ODESystem</span>(eqs)
sys <span class="pl-k">=</span> <span class="pl-c1">ode_order_lowering</span>(sys)

u0 <span class="pl-k">=</span> [<span class="pl-c1">D</span>(x) <span class="pl-k">=&gt;</span> <span class="pl-c1">2.0</span>,
      x <span class="pl-k">=&gt;</span> <span class="pl-c1">1.0</span>,
      y <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>,
      z <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>]

p  <span class="pl-k">=</span> [σ <span class="pl-k">=&gt;</span> <span class="pl-c1">28.0</span>,
      ρ <span class="pl-k">=&gt;</span> <span class="pl-c1">10.0</span>,
      β <span class="pl-k">=&gt;</span> <span class="pl-c1">8</span><span class="pl-k">/</span><span class="pl-c1">3</span>]

tspan <span class="pl-k">=</span> (<span class="pl-c1">0.0</span>,<span class="pl-c1">100.0</span>)
prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(sys,u0,tspan,p,jac<span class="pl-k">=</span><span class="pl-c1">true</span>)
sol <span class="pl-k">=</span> <span class="pl-c1">solve</span>(prob,<span class="pl-c1">Tsit5</span>())
<span class="pl-k">using</span> Plots; <span class="pl-c1">plot</span>(sol,vars<span class="pl-k">=</span>(<span class="pl-c1">:x</span>,<span class="pl-c1">:y</span>))</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/1814174/79118645-744eb580-7d5c-11ea-9c37-13c4efd585ca.png"><img src="https://user-images.githubusercontent.com/1814174/79118645-744eb580-7d5c-11ea-9c37-13c4efd585ca.png" alt="Lorenz2" style="max-width:100%;"></a></p>
<p>This automatically will have generated fast Jacobian functions, making
it more optimized than directly building a function. In addition, we can then
use ModelingToolkit to compose multiple ODE subsystems. Now let's define two
interacting Lorenz equations and simulate the resulting Differential-Algebriac
Equation (DAE):</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@parameters</span> t σ ρ β
<span class="pl-c1">@variables</span> <span class="pl-c1">x</span>(t) <span class="pl-c1">y</span>(t) <span class="pl-c1">z</span>(t)
<span class="pl-c1">@derivatives</span> D<span class="pl-k">'</span><span class="pl-k">~</span>t

eqs <span class="pl-k">=</span> [<span class="pl-c1">D</span>(x) <span class="pl-k">~</span> σ<span class="pl-k">*</span>(y<span class="pl-k">-</span>x),
       <span class="pl-c1">D</span>(y) <span class="pl-k">~</span> x<span class="pl-k">*</span>(ρ<span class="pl-k">-</span>z)<span class="pl-k">-</span>y,
       <span class="pl-c1">D</span>(z) <span class="pl-k">~</span> x<span class="pl-k">*</span>y <span class="pl-k">-</span> β<span class="pl-k">*</span>z]

lorenz1 <span class="pl-k">=</span> <span class="pl-c1">ODESystem</span>(eqs,name<span class="pl-k">=</span><span class="pl-c1">:lorenz1</span>)
lorenz2 <span class="pl-k">=</span> <span class="pl-c1">ODESystem</span>(eqs,name<span class="pl-k">=</span><span class="pl-c1">:lorenz2</span>)

<span class="pl-c1">@variables</span> α
<span class="pl-c1">@parameters</span> γ
connections <span class="pl-k">=</span> [<span class="pl-c1">0</span> <span class="pl-k">~</span> lorenz1<span class="pl-k">.</span>x <span class="pl-k">+</span> lorenz2<span class="pl-k">.</span>y <span class="pl-k">+</span> α<span class="pl-k">*</span>γ]
connected <span class="pl-k">=</span> <span class="pl-c1">ODESystem</span>(connections,t,[α],[γ],systems<span class="pl-k">=</span>[lorenz1,lorenz2])

u0 <span class="pl-k">=</span> [lorenz1<span class="pl-k">.</span>x <span class="pl-k">=&gt;</span> <span class="pl-c1">1.0</span>,
      lorenz1<span class="pl-k">.</span>y <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>,
      lorenz1<span class="pl-k">.</span>z <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>,
      lorenz2<span class="pl-k">.</span>x <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>,
      lorenz2<span class="pl-k">.</span>y <span class="pl-k">=&gt;</span> <span class="pl-c1">1.0</span>,
      lorenz2<span class="pl-k">.</span>z <span class="pl-k">=&gt;</span> <span class="pl-c1">0.0</span>,
      α <span class="pl-k">=&gt;</span> <span class="pl-c1">2.0</span>]

p  <span class="pl-k">=</span> [lorenz1<span class="pl-k">.</span>σ <span class="pl-k">=&gt;</span> <span class="pl-c1">10.0</span>,
      lorenz1<span class="pl-k">.</span>ρ <span class="pl-k">=&gt;</span> <span class="pl-c1">28.0</span>,
      lorenz1<span class="pl-k">.</span>β <span class="pl-k">=&gt;</span> <span class="pl-c1">8</span><span class="pl-k">/</span><span class="pl-c1">3</span>,
      lorenz2<span class="pl-k">.</span>σ <span class="pl-k">=&gt;</span> <span class="pl-c1">10.0</span>,
      lorenz2<span class="pl-k">.</span>ρ <span class="pl-k">=&gt;</span> <span class="pl-c1">28.0</span>,
      lorenz2<span class="pl-k">.</span>β <span class="pl-k">=&gt;</span> <span class="pl-c1">8</span><span class="pl-k">/</span><span class="pl-c1">3</span>,
      γ <span class="pl-k">=&gt;</span> <span class="pl-c1">2.0</span>]

tspan <span class="pl-k">=</span> (<span class="pl-c1">0.0</span>,<span class="pl-c1">100.0</span>)
prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(connected,u0,tspan,p)
sol <span class="pl-k">=</span> <span class="pl-c1">solve</span>(prob,<span class="pl-c1">Rodas5</span>())

<span class="pl-k">using</span> Plots; <span class="pl-c1">plot</span>(sol,vars<span class="pl-k">=</span>(:α,<span class="pl-c1">Symbol</span>(lorenz1<span class="pl-k">.</span>x),<span class="pl-c1">Symbol</span>(lorenz2<span class="pl-k">.</span>y)))</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/1814174/79122361-6fdaca80-7d65-11ea-87fd-0f6c4a85cd0d.png"><img src="https://user-images.githubusercontent.com/1814174/79122361-6fdaca80-7d65-11ea-87fd-0f6c4a85cd0d.png" alt="" style="max-width:100%;"></a></p>
</article></div>