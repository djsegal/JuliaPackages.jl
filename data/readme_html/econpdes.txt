<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a href="https://github.com/matthieugomez/EconPDEs.jl/actions"><img src="https://github.com/matthieugomez/EconPDEs.jl/workflows/CI/badge.svg" alt="Build status" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/matthieugomez/EconPDEs.jl/?branch=main" rel="nofollow"><img src="https://camo.githubusercontent.com/84d51ef49c2e50faf0e470c133e64a54b4e78d5bd6face54ddf949d6bf238107/687474703a2f2f636f6465636f762e696f2f6769746875622f6d61747468696575676f6d657a2f45636f6e504445732e6a6c2f636f7665726167652e7376673f6272616e63683d6d61696e" alt="Coverage Status" data-canonical-src="http://codecov.io/github/matthieugomez/EconPDEs.jl/coverage.svg?branch=main" style="max-width: 100%;"></a></p>
<p dir="auto">This package provides the function <code>pdesolve</code> that solves (system of) nonlinear ODEs/PDEs arising in economic models (i.e. parabolic/elliptic PDEs arising from HJB equations). It is:</p>
<ul dir="auto">
<li>robust: upwinding + fully implicit time stepping (see <a href="https://github.com/matthieugomez/EconPDEs.jl/blob/master/examples/details.pdf">here</a>)</li>
<li>fast: sparse matrices + Newton acceleration</li>
<li>simple-to-use</li>
</ul>
<h1 dir="auto"><a id="user-content-a-simple-example" class="anchor" aria-hidden="true" href="#a-simple-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A Simple Example</h1>
<p dir="auto">Let us solve the PDE for the price-dividend ratio in the Long Run Risk model with time-varying drift:</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="img/by.png"><img src="img/by.png" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using EconPDEs

# Define a discretized state space
# An OrderedDict in which each key corresponds to a state variable
# Grids can be non-homogeneous
stategrid = OrderedDict(:μ =&gt; range(-0.05, 0.1, length = 500))

# Define an initial guess for the value functions
# An OrderedDict in which each key corresponds to a value function to solve for, 
# specified as an array with as many dimensions as there are state variables
solend = OrderedDict(:V =&gt; ones(500))

# Define a function that encodes the PDE. 
# The function takes three arguments:
# 1. A named tuple giving the current value of the state. 
# 2. A named tuple giving the value function(s) (as well as its derivatives)
# at the current value of the state. 
# 3. (Optional) Current time t
# It must return a named tuple with the time derivatives
function f(state::NamedTuple, sol::NamedTuple)
           μbar = 0.018 ; ϑ = 0.00073 ; θμ = 0.252 ; νμ = 0.528 ; ρ = 0.025 ; ψ = 1.5 ; γ = 7.5
           μ = state.μ
           V, Vμ_up, Vμ_down, Vμμ = sol.V, sol.Vμ_up, sol.Vμ_down, sol.Vμμ
           # note that pdesolve will directly compute the derivatives of the valuefunction.
           # up and down correspond to the upward and downard derivative obtained by first difference
           Vμ = (μ &lt;= μbar) ? Vμ_up : Vμ_down
           Vt = - (1  - ρ * V + (1 - 1 / ψ) * (μ - 0.5 * γ * ϑ) * V + θμ * (μbar - μ) * Vμ +
           0.5 * νμ^2 * ϑ * Vμμ  + 0.5 * (1 / ψ - γ) / (1- 1 / ψ) * νμ^2 *  ϑ * Vμ^2/V)
           (Vt = Vt,)
end

# The function `pdesolve` takes four arguments:
# 1. the function encoding the PDE
# 2. the discretized state space
# 3. the terminal value function
# 4. (Optional) a time grid
ys, residual_norms = pdesolve(f, stategrid, solend, range(0, 1000, length = 100))

# To solve directly for the stationary solution, 
# i.e. the solution of the PDE with ∂tV = 0,
# simply omit the time grid
y, residual_norm =  pdesolve(f, stategrid, solend)"><pre><span class="pl-k">using</span> EconPDEs

<span class="pl-c"><span class="pl-c">#</span> Define a discretized state space</span>
<span class="pl-c"><span class="pl-c">#</span> An OrderedDict in which each key corresponds to a state variable</span>
<span class="pl-c"><span class="pl-c">#</span> Grids can be non-homogeneous</span>
stategrid <span class="pl-k">=</span> <span class="pl-c1">OrderedDict</span>(<span class="pl-c1">:μ</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">0.05</span>, <span class="pl-c1">0.1</span>, length <span class="pl-k">=</span> <span class="pl-c1">500</span>))

<span class="pl-c"><span class="pl-c">#</span> Define an initial guess for the value functions</span>
<span class="pl-c"><span class="pl-c">#</span> An OrderedDict in which each key corresponds to a value function to solve for, </span>
<span class="pl-c"><span class="pl-c">#</span> specified as an array with as many dimensions as there are state variables</span>
solend <span class="pl-k">=</span> <span class="pl-c1">OrderedDict</span>(<span class="pl-c1">:V</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">ones</span>(<span class="pl-c1">500</span>))

<span class="pl-c"><span class="pl-c">#</span> Define a function that encodes the PDE. </span>
<span class="pl-c"><span class="pl-c">#</span> The function takes three arguments:</span>
<span class="pl-c"><span class="pl-c">#</span> 1. A named tuple giving the current value of the state. </span>
<span class="pl-c"><span class="pl-c">#</span> 2. A named tuple giving the value function(s) (as well as its derivatives)</span>
<span class="pl-c"><span class="pl-c">#</span> at the current value of the state. </span>
<span class="pl-c"><span class="pl-c">#</span> 3. (Optional) Current time t</span>
<span class="pl-c"><span class="pl-c">#</span> It must return a named tuple with the time derivatives</span>
<span class="pl-k">function</span> <span class="pl-en">f</span>(state<span class="pl-k">::</span><span class="pl-c1">NamedTuple</span>, sol<span class="pl-k">::</span><span class="pl-c1">NamedTuple</span>)
           μbar <span class="pl-k">=</span> <span class="pl-c1">0.018</span> ; ϑ <span class="pl-k">=</span> <span class="pl-c1">0.00073</span> ; θμ <span class="pl-k">=</span> <span class="pl-c1">0.252</span> ; νμ <span class="pl-k">=</span> <span class="pl-c1">0.528</span> ; ρ <span class="pl-k">=</span> <span class="pl-c1">0.025</span> ; ψ <span class="pl-k">=</span> <span class="pl-c1">1.5</span> ; γ <span class="pl-k">=</span> <span class="pl-c1">7.5</span>
           μ <span class="pl-k">=</span> state<span class="pl-k">.</span>μ
           V, Vμ_up, Vμ_down, Vμμ <span class="pl-k">=</span> sol<span class="pl-k">.</span>V, sol<span class="pl-k">.</span>Vμ_up, sol<span class="pl-k">.</span>Vμ_down, sol<span class="pl-k">.</span>Vμμ
           <span class="pl-c"><span class="pl-c">#</span> note that pdesolve will directly compute the derivatives of the valuefunction.</span>
           <span class="pl-c"><span class="pl-c">#</span> up and down correspond to the upward and downard derivative obtained by first difference</span>
           Vμ <span class="pl-k">=</span> (μ <span class="pl-k">&lt;=</span> μbar) <span class="pl-k">?</span> Vμ_up <span class="pl-k">:</span> Vμ_down
           Vt <span class="pl-k">=</span> <span class="pl-k">-</span> (<span class="pl-c1">1</span>  <span class="pl-k">-</span> ρ <span class="pl-k">*</span> V <span class="pl-k">+</span> (<span class="pl-c1">1</span> <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">/</span> ψ) <span class="pl-k">*</span> (μ <span class="pl-k">-</span> <span class="pl-c1">0.5</span> <span class="pl-k">*</span> γ <span class="pl-k">*</span> ϑ) <span class="pl-k">*</span> V <span class="pl-k">+</span> θμ <span class="pl-k">*</span> (μbar <span class="pl-k">-</span> μ) <span class="pl-k">*</span> Vμ <span class="pl-k">+</span>
           <span class="pl-c1">0.5</span> <span class="pl-k">*</span> νμ<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">*</span> ϑ <span class="pl-k">*</span> Vμμ  <span class="pl-k">+</span> <span class="pl-c1">0.5</span> <span class="pl-k">*</span> (<span class="pl-c1">1</span> <span class="pl-k">/</span> ψ <span class="pl-k">-</span> γ) <span class="pl-k">/</span> (<span class="pl-c1">1</span><span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">/</span> ψ) <span class="pl-k">*</span> νμ<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">*</span>  ϑ <span class="pl-k">*</span> Vμ<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">/</span>V)
           (Vt <span class="pl-k">=</span> Vt,)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> The function `pdesolve` takes four arguments:</span>
<span class="pl-c"><span class="pl-c">#</span> 1. the function encoding the PDE</span>
<span class="pl-c"><span class="pl-c">#</span> 2. the discretized state space</span>
<span class="pl-c"><span class="pl-c">#</span> 3. the terminal value function</span>
<span class="pl-c"><span class="pl-c">#</span> 4. (Optional) a time grid</span>
ys, residual_norms <span class="pl-k">=</span> <span class="pl-c1">pdesolve</span>(f, stategrid, solend, <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1000</span>, length <span class="pl-k">=</span> <span class="pl-c1">100</span>))

<span class="pl-c"><span class="pl-c">#</span> To solve directly for the stationary solution, </span>
<span class="pl-c"><span class="pl-c">#</span> i.e. the solution of the PDE with ∂tV = 0,</span>
<span class="pl-c"><span class="pl-c">#</span> simply omit the time grid</span>
y, residual_norm <span class="pl-k">=</span>  <span class="pl-c1">pdesolve</span>(f, stategrid, solend)</pre></div>
<p dir="auto">More complicated ODEs / PDES (including PDE with two state variables or systems of multiple PDEs) can be found in the <code>examples</code> folder.</p>
<h1 dir="auto"><a id="user-content-boundary-conditions" class="anchor" aria-hidden="true" href="#boundary-conditions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Boundary Conditions</h1>
<p dir="auto">When solving a PDE using a finite scheme approach, one needs to specify the value of the solution <em>outside</em> the grid ("ghost node") to construct the second derivative and, in some cases, the first derivative <em>at</em> the boundary.</p>
<p dir="auto">By default, the values at the ghost node is assumed to equal the value at the boundary node (reflecting boundaries). Specify different values for values at the ghost node using the option <code>bc</code> (see <a href="https://github.com/matthieugomez/EconPDEs.jl/blob/master/examples/InvestmentProblem/BoltonChenWang.jl">BoltonChenWang.jl</a> for an example).</p>
<h2 dir="auto"><a id="user-content-econpdes-v100" class="anchor" aria-hidden="true" href="#econpdes-v100"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>EconPDEs v1.0.0</h2>
<p dir="auto">The 1.0 release has the following set of breaking changes:</p>
<ol dir="auto">
<li>The first argument of pdesolve (the function encoding the PDE) must accept directional first derivatives and it must return a named tuple of time derivatives</li>
<li>The fourth argument of pdesolve (the time grid) must be in increasing order</li>
<li>pdesolve now returns a type with fieldnames zero (for the solution) and residual_norm (for the norm of residuals)</li>
</ol>
<p dir="auto">See the updated examples for the new syntax.</p>
<h2 dir="auto"><a id="user-content-optimal-stopping" class="anchor" aria-hidden="true" href="#optimal-stopping"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Optimal Stopping</h2>
<p dir="auto">Optimal stopping problems are also supported, as exemplified in <a href="examples/OptimalStoppingTime/Leland.jl">Leland.jl</a>. These problems are solved with "HJB variational inequality" (HJBVI), i.e.:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="img/hjbvi.png"><img src="img/hjbvi.png" style="max-width: 100%;"></a></p>
<p dir="auto">where <code>S(x)</code> is the value of exercising the option. Notice the traditional "value matching" (<code>S(x̲)=v(x̲)</code>) and "smooth pasting" (<code>S'(x̲)=v'(x̲)</code>) conditions are implied in the HJBVI formulation. See <a href="https://benjaminmoll.com/codes/" rel="nofollow">the deck of notes from Ben Moll on stopping time problems</a> for more details. The <code>S(x)</code> can be provided to the solver as a vector defined on the grid via the keyword <code>y̲</code> (or <code>ȳ</code> as the upper bound for cost minimization problems).</p>
<h1 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h1>
<p dir="auto">The <a href="https://github.com/matthieugomez/EconPDEs.jl/tree/master/examples">examples folder</a>  solves a variety of models:</p>
<ul dir="auto">
<li><em>Habit Model</em> (Campbell Cochrane (1999) and Wachter (2005))</li>
<li><em>Long Run Risk Model</em> (Bansal Yaron (2004))</li>
<li><em>Disaster Model</em> (Wachter (2013))</li>
<li><em>Heterogeneous Agent Models</em> (Garleanu Panageas (2015), Di Tella (2017), Haddad (2015))</li>
<li><em>Consumption with Borrowing Constraint</em> (Wang Wang Yang (2016), Achdou Han Lasry Lions Moll (2018))</li>
<li><em>Investment with Borrowing Constraint</em> (Bolton Chen Wang (2009))</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">The package is registered in the <a href="https://github.com/JuliaRegistries/General"><code>General</code></a> registry and so can be installed at the REPL with <code>] add EconPDEs</code>.</p>
</article></div>