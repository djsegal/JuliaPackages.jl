<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-linkcuttreesjl" class="anchor" aria-hidden="true" href="#linkcuttreesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LinkCutTrees.jl</h1>
<p dir="auto">This is a simple Julia implementation of Sleator and Tarjan's link/cut tree data structure.
This data structure is used for representing a collection of rooted trees and supports the operations:</p>
<ul dir="auto">
<li><code>link!(v, w, i, c)</code>, join two trees by making <code>v</code> (a root node) a child of <code>w</code> (an arbitrary node), set edge label <code>i</code> and (non-negative) edge cost <code>c</code>,</li>
<li><code>cut!(v)</code>, split a tree by disconnecting <code>v</code> from its parent,</li>
<li><code>find_root(v)</code>, return the root of the tree that contains <code>v</code>,</li>
<li><code>find_mincost(v)</code>, return <code>(w, c)</code>, with <code>w</code> as close to the root as possible, such that the edge from <code>w</code> to its parent is of minimum cost and <code>c</code> is this cost,</li>
<li><code>add_cost!(v, x)</code>, add <code>x</code> to the cost of each vertex on the path from <code>v</code> to the root.</li>
</ul>
<p dir="auto">The operations all run in <code>O(log n)</code> amortized time.</p>
<p dir="auto">These operations are also supported:</p>
<ul dir="auto">
<li><code>cost(v)</code>, return the cost of the edge from <code>v</code> to its parent,</li>
<li><code>parent(v)</code>, get the parent of <code>v</code>,</li>
<li><code>label(v)</code>, get the label of <code>v</code>,</li>
<li><code>edge_label(v)</code>, return the label of the edge from <code>v</code> to its parent,</li>
<li><code>make_tree(T, U, V, i)</code>, create a tree with one node labeled <code>i</code>.</li>
</ul>
<p dir="auto">The operations <code>cost(v)</code> and <code>parent(v)</code> run in <code>O(log n)</code> amortized time, the other in <code>O(1)</code> time.</p>
<p dir="auto">There are different ways to implement link/cut trees.
This implementation follows the version from Tarjan's book "Data Structures and Network Algorithms" (<a href="https://doi.org/10.1137/1.9781611970265" rel="nofollow">10.1137/1.9781611970265</a>).</p>
<p dir="auto">Examples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using LinkCutTrees

julia&gt; n1 = make_tree(Int, Nothing, Int, 1);

julia&gt; n2 = make_tree(Int, Nothing, Int, 2);

julia&gt; n3 = make_tree(Int, Nothing, Int, 3);

julia&gt; link!(n2, n1, nothing, 1)

julia&gt; link!(n3, n1, nothing, 2)

julia&gt; find_root(n2) === find_root(n3) === n1
true

julia&gt; cut!(n3)

julia&gt; n3 === find_root(n3)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> LinkCutTrees

julia<span class="pl-k">&gt;</span> n1 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Nothing, Int, <span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> n2 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Nothing, Int, <span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> n3 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Nothing, Int, <span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">link!</span>(n2, n1, <span class="pl-c1">nothing</span>, <span class="pl-c1">1</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">link!</span>(n3, n1, <span class="pl-c1">nothing</span>, <span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">find_root</span>(n2) <span class="pl-k">===</span> <span class="pl-c1">find_root</span>(n3) <span class="pl-k">===</span> n1
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">cut!</span>(n3)

julia<span class="pl-k">&gt;</span> n3 <span class="pl-k">===</span> <span class="pl-c1">find_root</span>(n3)
<span class="pl-c1">true</span></pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using LinkCutTrees

julia&gt; n1 = make_tree(Int, Int, Int, 1);

julia&gt; n2 = make_tree(Int, Int, Int, 2);

julia&gt; n3 = make_tree(Int, Int, Int, 3);

julia&gt; n4 = make_tree(Int, Int, Int, 4);

julia&gt; n5 = make_tree(Int, Int, Int, 5);

julia&gt; link!(n2, n1, 1, 100)

julia&gt; link!(n3, n2, 2, 10)

julia&gt; link!(n4, n3, 3, 10)

julia&gt; link!(n5, n4, 4, 50)

julia&gt; (n, c) = find_mincost(n5);

julia&gt; (n === n3, c)
(true, 10)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> LinkCutTrees

julia<span class="pl-k">&gt;</span> n1 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Int, Int, <span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> n2 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Int, Int, <span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> n3 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Int, Int, <span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> n4 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Int, Int, <span class="pl-c1">4</span>);

julia<span class="pl-k">&gt;</span> n5 <span class="pl-k">=</span> <span class="pl-c1">make_tree</span>(Int, Int, Int, <span class="pl-c1">5</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">link!</span>(n2, n1, <span class="pl-c1">1</span>, <span class="pl-c1">100</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">link!</span>(n3, n2, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">link!</span>(n4, n3, <span class="pl-c1">3</span>, <span class="pl-c1">10</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">link!</span>(n5, n4, <span class="pl-c1">4</span>, <span class="pl-c1">50</span>)

julia<span class="pl-k">&gt;</span> (n, c) <span class="pl-k">=</span> <span class="pl-c1">find_mincost</span>(n5);

julia<span class="pl-k">&gt;</span> (n <span class="pl-k">===</span> n3, c)
(<span class="pl-c1">true</span>, <span class="pl-c1">10</span>)</pre></div>
</article></div>