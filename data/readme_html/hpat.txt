<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><blockquote>
<p dir="auto"><g-emoji class="g-emoji" alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">⚠️</g-emoji> <strong>DISCONTINUATION OF PROJECT</strong> -
<em>This project will no longer be maintained by Intel.
Intel has ceased development and contributions including, but not limited to, maintenance, bug fixes, new releases, or updates, to this project.</em>
<strong>Intel no longer accepts patches to this project.</strong>
<em>If you have an ongoing need to use this project, are interested in independently developing it, or would like to maintain patches for the open source software community, please create your own fork of this project.</em></p>
</blockquote>
<h1 dir="auto"><a id="user-content-hpat" class="anchor" aria-hidden="true" href="#hpat"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>HPAT</h1>
<h2 dir="auto"><a id="user-content-this-repository-is-no-longer-maintained" class="anchor" aria-hidden="true" href="#this-repository-is-no-longer-maintained"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>This repository is no longer maintained</h2>
<p dir="auto">We are currently developing the <a href="https://github.com/IntelLabs/hpat">Python version</a>.</p>
<p dir="auto"><a href="https://travis-ci.org/IntelLabs/HPAT.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/bca78c583e9d0fc41d0ae4341a5a0b48b122d270472fe20488eac8a553ca1acd/68747470733a2f2f7472617669732d63692e6f72672f496e74656c4c6162732f485041542e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/IntelLabs/HPAT.jl.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto"><em>High Performance Analytics Toolkit (HPAT)</em> is a Julia-based framework for big data analytics on clusters that
is both easy to use and extremely fast; it is orders of magnitude faster than alternatives
like <a href="http://spark.apache.org/" rel="nofollow">Apache Spark*</a>.</p>
<p dir="auto">HPAT automatically parallelizes analytics tasks written in Julia, generates efficient MPI/C++ code,
and uses existing high performance libraries such as <a href="https://www.hdfgroup.org/HDF5/" rel="nofollow">HDF5</a>
and <a href="https://software.intel.com/en-us/daal" rel="nofollow">Intel® Data Analytics Acceleration Library (Intel® DAAL)</a>.
HPAT is based on <a href="https://github.com/IntelLabs/ParallelAccelerator.jl">ParallelAccelerator</a>
and <a href="https://github.com/IntelLabs/CompilerTools.jl">CompilerTools</a> packages.</p>
<p dir="auto">HPAT is in early development and therefore feedback is highly appreciated.</p>
<p dir="auto">Presentation at <a href="http://juliacon.org/" rel="nofollow">JuliaCon 2016</a>:</p>
<ul dir="auto">
<li><a href="http://www.slideshare.net/EhsanTotoni/hpat-presentation-at-juliacon-2016" rel="nofollow">Slides (Slideshare)</a></li>
<li><a href="https://www.youtube.com/watch?v=Qa7nfaDacII" rel="nofollow">Video (YouTube)</a></li>
</ul>
<h2 dir="auto"><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick Start</h2>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ julia -e 'Pkg.add(&quot;HPAT&quot;)'
$ mpirun -np 2 julia ~/.julia/v0.4/HPAT/examples/pi.jl --points=1000000"><pre>$ julia -e <span class="pl-s"><span class="pl-pds">'</span>Pkg.add("HPAT")<span class="pl-pds">'</span></span>
$ mpirun -np 2 julia <span class="pl-k">~</span>/.julia/v0.4/HPAT/examples/pi.jl --points=1000000</pre></div>
<p dir="auto">If there were any issues, make sure <a href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a>
and <a href="https://github.com/IntelLabs/ParallelAccelerator.jl">ParallelAccelerator.jl</a>
are installed correctly.</p>
<p dir="auto">On Ubuntu, these commands resolve some MPI.jl issues:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ sudo apt-get install -y g++ gcc gfortran cmake openmpi-bin openmpi-common libopenmpi-dev libhdf5-openmpi-dev
$ julia ~/.julia/v0.4/MPI/deps/build.jl"><pre>$ sudo apt-get install -y g++ gcc gfortran cmake openmpi-bin openmpi-common libopenmpi-dev libhdf5-openmpi-dev
$ julia <span class="pl-k">~</span>/.julia/v0.4/MPI/deps/build.jl</pre></div>
<h2 dir="auto"><a id="user-content-performance-comparison-with-spark" class="anchor" aria-hidden="true" href="#performance-comparison-with-spark"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance Comparison with Spark*</h2>
<h3 dir="auto"><a id="user-content-logistic-regression" class="anchor" aria-hidden="true" href="#logistic-regression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Logistic Regression</h3>
<p dir="auto">Front page of <a href="http://spark.apache.org/" rel="nofollow">Spark* website</a> demonstrates over two orders of magnitude
speedup compared to Hadoop* on <a href="https://github.com/apache/spark/blob/master/examples/src/main/python/logistic_regression.py">Logistic Regression</a> example. Simply put, Spark* keeps data
in memory while Hadoop* reads and writes to disks frequently.</p>
<p dir="auto">HPAT is two orders of magnitude faster than Spark*!
Data is kept in processor registers as much as possible with HPAT, which is necessary for best performance.
In addition, HPAT doesn't have Spark*'s TCP/IP and Java Virtual Machine (JVM) overheads since it generates "bare-metal" MPI/C++ code.</p>
<p dir="auto">Here is how one can compare the performance of HPAT and Spark* for Logistic Regression example on a local Ubuntu machine.
Note that <a href="https://www.hdfgroup.org/HDF5/PHDF5/" rel="nofollow">parallel HDF5</a> is required.</p>
<p dir="auto">Install Julia and dependencies:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ sudo add-apt-repository ppa:staticfloat/juliareleases
$ sudo add-apt-repository ppa:staticfloat/julia-deps
$ sudo apt-get update
$ sudo apt-get install -y gcc g++ gfortran cmake openmpi-bin openmpi-common libopenmpi-dev libhdf5-openmpi-dev julia libblas-dev libopenblas-dev
$ julia -e 'Pkg.add(&quot;HPAT&quot;)'"><pre>$ sudo add-apt-repository ppa:staticfloat/juliareleases
$ sudo add-apt-repository ppa:staticfloat/julia-deps
$ sudo apt-get update
$ sudo apt-get install -y gcc g++ gfortran cmake openmpi-bin openmpi-common libopenmpi-dev libhdf5-openmpi-dev julia libblas-dev libopenblas-dev
$ julia -e <span class="pl-s"><span class="pl-pds">'</span>Pkg.add("HPAT")<span class="pl-pds">'</span></span></pre></div>
<p dir="auto">Generate input data:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# generate data with 100 million labeled instances
$ julia -e 'Pkg.add(&quot;HDF5&quot;)'
$ julia $HOME/.julia/v0.4/HPAT/generate_data/generate_logistic_regression.jl --instances=100000000 --path=/tmp/"><pre><span class="pl-c"><span class="pl-c">#</span> generate data with 100 million labeled instances</span>
$ julia -e <span class="pl-s"><span class="pl-pds">'</span>Pkg.add("HDF5")<span class="pl-pds">'</span></span>
$ julia <span class="pl-smi">$HOME</span>/.julia/v0.4/HPAT/generate_data/generate_logistic_regression.jl --instances=100000000 --path=/tmp/</pre></div>
<p dir="auto">Run Logistic Regression example of HPAT:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# run on 64 MPI processes
$ mpirun -np 8 julia $HOME/.julia/v0.4/HPAT/examples/logistic_regression.jl --iterations=200 --file=/tmp/logistic_regression.hdf5 &amp;&gt; lr_hpat.out"><pre><span class="pl-c"><span class="pl-c">#</span> run on 64 MPI processes</span>
$ mpirun -np 8 julia <span class="pl-smi">$HOME</span>/.julia/v0.4/HPAT/examples/logistic_regression.jl --iterations=200 --file=/tmp/logistic_regression.hdf5 <span class="pl-k">&amp;</span><span class="pl-k">&gt;</span> lr_hpat.out</pre></div>
<p dir="auto">Run Logistic Regression example of Spark*:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# assuming spark is configured properly (with driver and executor memory set)
$ spark-submit $SPARK_HOME/examples/src/main/python/logistic_regression.py /tmp/logistic_regression.csv 200 &amp;&gt; lr_spark.out"><pre><span class="pl-c"><span class="pl-c">#</span> assuming spark is configured properly (with driver and executor memory set)</span>
$ spark-submit <span class="pl-smi">$SPARK_HOME</span>/examples/src/main/python/logistic_regression.py /tmp/logistic_regression.csv 200 <span class="pl-k">&amp;</span><span class="pl-k">&gt;</span> lr_spark.out</pre></div>
<h3 dir="auto"><a id="user-content-monte-carlo-pi-estimation" class="anchor" aria-hidden="true" href="#monte-carlo-pi-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Monte Carlo Pi Estimation</h3>
<p dir="auto">Monte Carlo Pi estimation is another interesting <a href="https://github.com/apache/spark/blob/master/examples/src/main/python/pi.py">example of Spark*</a>.
HPAT is over 1000 times faster for this case for various reasons!
First, HPAT can divide computation statically since it generates code rather than executing the program operation-by-operation.
Spark* uses a dynamic scheduler with high overhead. But more importantly, Spark* generates an enormous
array for the <em>map</em> operation, then executes the <em>reduce</em> operation. However, HPAT uses ParallelAccelerator
which removes unnecessary arrays. Therefore, HPAT doesn't create any arrays and the generated code is just a simple loop.
Hence, the computation is performed in registers and there is no extra memory access.</p>
<p dir="auto">Run Pi example of HPAT:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ mpirun -np 64 julia ~/.julia/v0.4/HPAT/examples/pi.jl --points=10000000"><pre>$ mpirun -np 64 julia <span class="pl-k">~</span>/.julia/v0.4/HPAT/examples/pi.jl --points=10000000</pre></div>
<p dir="auto">Run Pi example of Spark*:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ spark-submit $SPARK_HOME/examples/src/main/python/pi.py 100 &amp;&gt; pi_spark.out"><pre>$ spark-submit <span class="pl-smi">$SPARK_HOME</span>/examples/src/main/python/pi.py 100 <span class="pl-k">&amp;</span><span class="pl-k">&gt;</span> pi_spark.out</pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">Programmers need to follow these directions in order to use HPAT effectively:</p>
<ul dir="auto">
<li>The analytics task should be written in a self-contained function
which is annotated with <code>@acc hpat</code>.</li>
<li>Reading the input samples should be done using the <code>DataSource</code> syntax.</li>
<li>The computation should be in the form of high-level matrix/vector computations or comprehensions
since HPAT does not parallelize sequential loops.</li>
<li>Julia's column-major order should be followed for matrices since HPAT divides the data across columns.
This means that features of a sample are in a column of the samples matrix.</li>
</ul>
<h2 dir="auto"><a id="user-content-initialization-time-issue" class="anchor" aria-hidden="true" href="#initialization-time-issue"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Initialization Time Issue</h2>
<p dir="auto">Currently, there is a high initialization cost (e.g. 25s) the first time HPAT is
used within a Julia runtime since package precompilation
of Julia v0.4 is very limited. We are working on various solutions.</p>
</article></div>