<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-flexiblefunctorsjl" class="anchor" aria-hidden="true" href="#flexiblefunctorsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FlexibleFunctors.jl</h1>
<p dir="auto"><code>FlexibleFunctors.jl</code> allows you to convert struct fields to a flat vector representation, and it also provides a function to transform similar vectors back into structs. However, <code>FlexibleFunctors.jl</code> also provides a <code>parameters(x)</code> function which can be extended to dynamically determine which fields make it into the vector and which fields are fixed.</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FlexibleFunctors, Zygote
import FlexibleFunctors: parameters

struct Model
    elements
    params
end
parameters(m::Model) = m.params

struct Square
    w
    params
end
parameters(s::Square) = s.params
area(s::Square) = s.w^2

s1 = Square(1.0, (:w,))
s2 = Square(2.0, ())
s3 = Square(3.0, (:w,))
m1 = Model([s1, s2, s3], (:elements,))
m2 = Model([s1, s2, s3], ())

p1, re1 = destructure(m1)
p2, re2 = destructure(m2)

julia&gt; println(p1)
# [1.0, 3.0]

julia&gt; println(p2)
# Any[]

# Replace first and third widths with vector values
julia&gt; mapreduce((s)-&gt;area(s), +, re1([3.0, 4.0]).elements)
# 29

# Uses original widths since `m2` has no parameters
julia&gt; mapreduce((s)-&gt;area(s), +, re2([3.0, 4.0]).elements)
# 14

# Map vector of parameters to an object for optimization
grad = Zygote.gradient((x) -&gt; mapreduce(area, +, x.elements), re1([3.0, 4.0]));

julia&gt; getfield.(grad[1].elements, :w)
# [6.0, 4.0, 8.0]"><pre><span class="pl-k">using</span> FlexibleFunctors, Zygote
<span class="pl-k">import</span> FlexibleFunctors<span class="pl-k">:</span> parameters

<span class="pl-k">struct</span> Model
    elements
    params
<span class="pl-k">end</span>
<span class="pl-en">parameters</span>(m<span class="pl-k">::</span><span class="pl-c1">Model</span>) <span class="pl-k">=</span> m<span class="pl-k">.</span>params

<span class="pl-k">struct</span> Square
    w
    params
<span class="pl-k">end</span>
<span class="pl-en">parameters</span>(s<span class="pl-k">::</span><span class="pl-c1">Square</span>) <span class="pl-k">=</span> s<span class="pl-k">.</span>params
<span class="pl-en">area</span>(s<span class="pl-k">::</span><span class="pl-c1">Square</span>) <span class="pl-k">=</span> s<span class="pl-k">.</span>w<span class="pl-k">^</span><span class="pl-c1">2</span>

s1 <span class="pl-k">=</span> <span class="pl-c1">Square</span>(<span class="pl-c1">1.0</span>, (<span class="pl-c1">:w</span>,))
s2 <span class="pl-k">=</span> <span class="pl-c1">Square</span>(<span class="pl-c1">2.0</span>, ())
s3 <span class="pl-k">=</span> <span class="pl-c1">Square</span>(<span class="pl-c1">3.0</span>, (<span class="pl-c1">:w</span>,))
m1 <span class="pl-k">=</span> <span class="pl-c1">Model</span>([s1, s2, s3], (<span class="pl-c1">:elements</span>,))
m2 <span class="pl-k">=</span> <span class="pl-c1">Model</span>([s1, s2, s3], ())

p1, re1 <span class="pl-k">=</span> <span class="pl-c1">destructure</span>(m1)
p2, re2 <span class="pl-k">=</span> <span class="pl-c1">destructure</span>(m2)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">println</span>(p1)
<span class="pl-c"><span class="pl-c">#</span> [1.0, 3.0]</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">println</span>(p2)
<span class="pl-c"><span class="pl-c">#</span> Any[]</span>

<span class="pl-c"><span class="pl-c">#</span> Replace first and third widths with vector values</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">mapreduce</span>((s)<span class="pl-k">-&gt;</span><span class="pl-c1">area</span>(s), <span class="pl-k">+</span>, <span class="pl-c1">re1</span>([<span class="pl-c1">3.0</span>, <span class="pl-c1">4.0</span>])<span class="pl-k">.</span>elements)
<span class="pl-c"><span class="pl-c">#</span> 29</span>

<span class="pl-c"><span class="pl-c">#</span> Uses original widths since `m2` has no parameters</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">mapreduce</span>((s)<span class="pl-k">-&gt;</span><span class="pl-c1">area</span>(s), <span class="pl-k">+</span>, <span class="pl-c1">re2</span>([<span class="pl-c1">3.0</span>, <span class="pl-c1">4.0</span>])<span class="pl-k">.</span>elements)
<span class="pl-c"><span class="pl-c">#</span> 14</span>

<span class="pl-c"><span class="pl-c">#</span> Map vector of parameters to an object for optimization</span>
grad <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">gradient</span>((x) <span class="pl-k">-&gt;</span> <span class="pl-c1">mapreduce</span>(area, <span class="pl-k">+</span>, x<span class="pl-k">.</span>elements), <span class="pl-c1">re1</span>([<span class="pl-c1">3.0</span>, <span class="pl-c1">4.0</span>]));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getfield</span>.(grad[<span class="pl-c1">1</span>]<span class="pl-k">.</span>elements, <span class="pl-c1">:w</span>)
<span class="pl-c"><span class="pl-c">#</span> [6.0, 4.0, 8.0]</span></pre></div>
<h2 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h2>
<p dir="auto"><code>FlexibleFunctors.jl</code> adds the ability to specify individual fields of a type as parameters. These parameters indicate fields which can be retrieved to obtain a flat vector representation of the struct parameters through <code>destructure</code>. <code>destructure</code> also returns a function, <code>re</code>, which reconstructs an instance of the original type. <code>re</code> operates as a function of the flat vector representation, but the reconstructed values of parameter fields are drawn from this vector while non-parameter fields are left unchanged.</p>
<p dir="auto">Parameters are determined recursively. If a tagged field contains a struct with parameters of its own, those parameters are also included in the resulting vector and reconstruction.</p>
<p dir="auto"><code>ffunctor</code> takes a struct instance with a <code>parameters</code> method and returns a <code>NamedTuple</code> representation of the parameters. <code>ffunctor</code> also returns a <code>re</code> function for reconstructing the <code>struct</code> from the <code>NamedTuple</code> representation.</p>
<p dir="auto">In either case, you must provide a <code>FlexibleFunctors.parameters(::YourType)</code> method which return the parameters of <code>YourType</code> in a <code>Tuple</code> of <code>Symbol</code>s. This is accomplished by <code>import</code>ing <code>FlexibleFunctors.jl</code> and adding additional methods directly to <code>parameters</code>.</p>
<h2 dir="auto"><a id="user-content-whats-flexible-about-flexiblefunctors" class="anchor" aria-hidden="true" href="#whats-flexible-about-flexiblefunctors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What's Flexible about FlexibleFunctors?</h2>
<p dir="auto">The functionality provided by <code>FlexibleFunctors.jl</code> is similar to <code>Functors.jl</code>. Both projects annotate types with special fields to convert in between flat vector representations of structs and a <code>re</code>constructed instance. However, <code>Functors.jl</code> stores this information at the type-level for all instances of a type, forcing all instances to use identical fields as (what we call) parameters.</p>
<p dir="auto"><code>FlexibleFunctors.jl</code> can store these parameter fields at the instance-level. For example, instead of hard-coding the returned parameters, we could add a <code>parameters</code> field to a <code>struct</code>, and then specify these <code>parameters</code> at run-time as a tuple of <code>Symbol</code>s. In this way, we can use the same types but specialize which fields are actually parameterized and liable to be changed during a <code>re</code>construction.</p>
<p dir="auto">If parameter fields are stored within a struct instance, re-parameterizing the type instance is possible. For this, we recommend <a href="https://github.com/jw3126/Setfield.jl">Setfield.jl</a> and the <code>@set</code> macro which can easily update nested fields.</p>
<p dir="auto">Further, note that <code>FlexibleFunctors.jl</code> can reproduce similar behavior to <code>Functors.jl</code>. If <code>parameters(m::M) = (:some, :fixed, :tuple)</code>, then all instances of <code>M</code> will have the same parameters.</p>
</article></div>