<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-sparsitytracingjl" class="anchor" aria-hidden="true" href="#sparsitytracingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SparsityTracing.jl</h1>
<p dir="auto">Automatic Jacobian sparsity detection using minimal scalar tracing and autodifferentiation.</p>
<h2 dir="auto"><a id="user-content-limitations-and-alternatives" class="anchor" aria-hidden="true" href="#limitations-and-alternatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Limitations and alternatives</h2>
<p dir="auto">The detected sparsity pattern is that for the code path that is followed with the specified variable and parameter values.
Any conditional logic that generates different code paths which result in different sparsity patterns is therefore not handled. As a workaround, either choose values that generate the least sparsity, or add <code>0.0*an_omitted_variable</code> to conditional paths (relying on the fact that <code>SparsityTracing</code> includes structural zeros in the generated Jacobian), or call multiple times and merge the sparsity patterns (ie add the sparse Jacobians).</p>
<p dir="auto"><strong>This package should be considered an interim solution until <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a> Jacobian tracing is fully implemented.</strong>  Currently <code>Symbolics v1.4.2</code> requires awkward workarounds for conditional logic (which will error), and is relatively slow (which may not be an issue for smaller models).  See <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="955768128" data-permission-text="Title is private" data-url="https://github.com/JuliaSymbolics/Symbolics.jl/issues/326" data-hovercard-type="issue" data-hovercard-url="/JuliaSymbolics/Symbolics.jl/issues/326/hovercard" href="https://github.com/JuliaSymbolics/Symbolics.jl/issues/326">JuliaSymbolics/Symbolics.jl#326</a> for benchmark results showing that <code>SparsityTracing</code> is ~40x faster, and also demonstrating that the usage is very similar hence it is easy to just swap.</p>
<p dir="auto">The earlier <a href="https://github.com/SciML/SparsityDetection.jl">SparsityDetection.jl</a> package is marked as deprecated.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ] add SparsityTracing"><pre>julia<span class="pl-k">&gt;</span> ] add SparsityTracing</pre></div>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; import SparsityTracing as AD

julia&gt; function rober(du,u,p)
                   y₁,y₂,y₃ = u
                   k₁,k₂,k₃ = p
                   du[1] = -k₁*y₁+k₃*y₂*y₃
                   du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃
                   du[3] =  k₂*y₂^2
                   nothing
               end;

julia&gt; u = [1.0, 2.0, 3.0];

julia&gt; p = (0.04,3e7,1e4);

julia&gt; u_ad = AD.create_advec(u);

julia&gt; du_ad = similar(u_ad);

julia&gt; rober(du_ad, u_ad, p)

julia&gt; AD.deriv(du_ad[3])
2-element SparseArrays.SparseVector{Float64, Int64} with 1 stored entry:
  [2]  =  1.2e8

julia&gt; Jad = AD.jacobian(du_ad, length(du_ad))
3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
 -0.04  30000.0        20000.0
  0.04     -1.2003e8  -20000.0
   ⋅        1.2e8           ⋅ 
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">import</span> SparsityTracing <span class="pl-k">as</span> AD

julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">rober</span>(du,u,p)
                   y₁,y₂,y₃ <span class="pl-k">=</span> u
                   k₁,k₂,k₃ <span class="pl-k">=</span> p
                   du[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>k₁<span class="pl-k">*</span>y₁<span class="pl-k">+</span>k₃<span class="pl-k">*</span>y₂<span class="pl-k">*</span>y₃
                   du[<span class="pl-c1">2</span>] <span class="pl-k">=</span>  k₁<span class="pl-k">*</span>y₁<span class="pl-k">-</span>k₂<span class="pl-k">*</span>y₂<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>k₃<span class="pl-k">*</span>y₂<span class="pl-k">*</span>y₃
                   du[<span class="pl-c1">3</span>] <span class="pl-k">=</span>  k₂<span class="pl-k">*</span>y₂<span class="pl-k">^</span><span class="pl-c1">2</span>
                   <span class="pl-c1">nothing</span>
               <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> u <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>];

julia<span class="pl-k">&gt;</span> p <span class="pl-k">=</span> (<span class="pl-c1">0.04</span>,<span class="pl-c1">3e7</span>,<span class="pl-c1">1e4</span>);

julia<span class="pl-k">&gt;</span> u_ad <span class="pl-k">=</span> AD<span class="pl-k">.</span><span class="pl-c1">create_advec</span>(u);

julia<span class="pl-k">&gt;</span> du_ad <span class="pl-k">=</span> <span class="pl-c1">similar</span>(u_ad);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rober</span>(du_ad, u_ad, p)

julia<span class="pl-k">&gt;</span> AD<span class="pl-k">.</span><span class="pl-c1">deriv</span>(du_ad[<span class="pl-c1">3</span>])
<span class="pl-c1">2</span><span class="pl-k">-</span>element SparseArrays<span class="pl-k">.</span>SparseVector{Float64, Int64} with <span class="pl-c1">1</span> stored entry<span class="pl-k">:</span>
  [<span class="pl-c1">2</span>]  <span class="pl-k">=</span>  <span class="pl-c1">1.2e8</span>

julia<span class="pl-k">&gt;</span> Jad <span class="pl-k">=</span> AD<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(du_ad, <span class="pl-c1">length</span>(du_ad))
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> SparseArrays<span class="pl-k">.</span>SparseMatrixCSC{Float64, Int64} with <span class="pl-c1">7</span> stored entries<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">0.04</span>  <span class="pl-c1">30000.0</span>        <span class="pl-c1">20000.0</span>
  <span class="pl-c1">0.04</span>     <span class="pl-k">-</span><span class="pl-c1">1.2003e8</span>  <span class="pl-k">-</span><span class="pl-c1">20000.0</span>
   <span class="pl-k">⋅</span>        <span class="pl-c1">1.2e8</span>           <span class="pl-k">⋅</span> 
</pre></div>
<h2 dir="auto"><a id="user-content-implementation" class="anchor" aria-hidden="true" href="#implementation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementation</h2>
<p dir="auto">The algorithm is essentially that of SparsLinC described in Bischof etal (1996), except with a simpler but less efficient data structure. Implements a scalar type <code>SparsityTracing.ADval{T&lt;:Real}</code> that holds a value, and a binary tree of scalar derivatives including the element indices as leaf nodes. The tree is initialised to a <code>Vector</code> of leaf nodes by <code>SparsityTracing.create_advec</code>.  It is populated with derivatives calculated by <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a> when a Julia function is called (eg a function <code>y = f(x)</code> calculating the RHS of an ODE). <code>SparsityTracing.jacobian</code> then walks the tree and calculates the Jacobian as a sparse matrix.  This provides a robust way of detecting Jacobian sparsity (and for test purposes only, a very slow way of calculating the actual derivative).  The sparsity pattern may then be used to generate matrix colouring for a fast AD package eg <a href="https://github.com/JuliaDiff/SparseDiffTools.jl">SparseDiffTools.jl</a>.</p>
<p dir="auto">Time taken increases approximately linearly with the number of scalar operations. Speed is approx 10 M scalar op/s (on a ~4Ghz laptop core) so 100 - 1000x slower than <code>y = f(x)</code> with primitive types (as each scalar operation generates a memory allocation to add a tree node).</p>
<h1 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h1>
<p dir="auto">Christian H. Bischof , Peyvand M. Khademi , Ali Buaricha &amp; Carle Alan (1996) Efficient computation of gradients and Jacobians by dynamic exploitation of sparsity in automatic differentiation, Optimization Methods and Software, 7:1, 1-39, DOI: 10.1080/10556789608805642</p>
</article></div>