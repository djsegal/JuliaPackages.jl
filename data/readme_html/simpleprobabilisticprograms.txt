<div id="readme" class="md" data-path="readme.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-simple-probabilistic-programs" class="anchor" aria-hidden="true" href="#simple-probabilistic-programs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simple Probabilistic Programs</h1>
<p dir="auto">Simple implementation of probabilistic programs for the Julia programming language with support for traces allocated on the stack.</p>
<h2 dir="auto"><a id="user-content-status" class="anchor" aria-hidden="true" href="#status"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Status</h2>
<p dir="auto">This package is very much work in progress and it is likely to change in the future. Comments, suggestions, and pull requests are welcome!</p>
<h2 dir="auto"><a id="user-content-quickstart" class="anchor" aria-hidden="true" href="#quickstart"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quickstart</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using SimpleProbabilisticPrograms

julia&gt; using Distributions: Beta, Bernoulli

julia&gt; @probprog function beta_bernoulli_model(a, b, n)
         bias ~ Beta(a, b)       # sample a number between 0 and 1
         coin = Bernoulli(bias)  # create biased coin as Bernoulli distribution
         throws ~ iid(coin, n)   # throw the coin n times
         return (; bias, throws) # return the trace of the program execution
       end
beta_bernoulli_model (generic function with 1 method)

julia&gt; model = beta_bernoulli_model(3, 4, 10)
ProbProg(...)

julia&gt; trace = rand(model)
(bias = 0.15035879436791896, throws = Bool[0, 1, 0, 0, 0, 0, 0, 0, 0, 0])

julia&gt; logpdf(model, trace)
-3.5451416292361504"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> SimpleProbabilisticPrograms

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Distributions<span class="pl-k">:</span> Beta, Bernoulli

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@probprog</span> <span class="pl-k">function</span> <span class="pl-en">beta_bernoulli_model</span>(a, b, n)
         bias <span class="pl-k">~</span> <span class="pl-c1">Beta</span>(a, b)       <span class="pl-c"><span class="pl-c">#</span> sample a number between 0 and 1</span>
         coin <span class="pl-k">=</span> <span class="pl-c1">Bernoulli</span>(bias)  <span class="pl-c"><span class="pl-c">#</span> create biased coin as Bernoulli distribution</span>
         throws <span class="pl-k">~</span> <span class="pl-c1">iid</span>(coin, n)   <span class="pl-c"><span class="pl-c">#</span> throw the coin n times</span>
         <span class="pl-k">return</span> (; bias, throws) <span class="pl-c"><span class="pl-c">#</span> return the trace of the program execution</span>
       <span class="pl-k">end</span>
beta_bernoulli_model (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> model <span class="pl-k">=</span> <span class="pl-c1">beta_bernoulli_model</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">10</span>)
<span class="pl-c1">ProbProg</span>(<span class="pl-k">...</span>)

julia<span class="pl-k">&gt;</span> trace <span class="pl-k">=</span> <span class="pl-c1">rand</span>(model)
(bias <span class="pl-k">=</span> <span class="pl-c1">0.15035879436791896</span>, throws <span class="pl-k">=</span> Bool[<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>])

julia<span class="pl-k">&gt;</span> <span class="pl-c1">logpdf</span>(model, trace)
<span class="pl-k">-</span><span class="pl-c1">3.5451416292361504</span></pre></div>
<h2 dir="auto"><a id="user-content-introduction-and-motivation" class="anchor" aria-hidden="true" href="#introduction-and-motivation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction and Motivation</h2>
<p dir="auto">Probabilistic programming is a great way of making the power of Bayesian statistics more accessible by drawing from research in programming languages.
A probabilistic program represents a distribution over the random choices that are made in a standard execution of the program. The collection of all such choices is called a <em>trace</em> of the probabilistic program.
While probabilistic programming systems like <a href="https://github.com/probcomp/Gen.jl">Gen.jl</a> and <a href="https://github.com/TuringLang/Turing.jl">Turing.jl</a> (also <a href="https://github.com/pyro-ppl/pyro">Pyro</a> and <a href="https://github.com/pymc-devs/pymc">PyMC3</a> in python) focus on the implementation and integration of inference methods, the motivation of this package is to provide a minimal implementation of probabilistic programs with a simple API, full compositionality, and fast performance through type stability.
This can be helpful, for example, for applications that go beyond the use cases of established probabilistic programming systems, if such systems seem to be too complex for your use case, or if you want to learn/teach how probabilistic programming works.
In particular, if you want to write down a distribution that is just a bit more complicated than the ones provided by <code>Distributions.jl</code>, this package might help you.</p>
<p dir="auto">Implementing an extensive library of inference methods that work out of the box is not the goal of this package.</p>
<h2 dir="auto"><a id="user-content-high-level-api" class="anchor" aria-hidden="true" href="#high-level-api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>High-Level API</h2>
<p dir="auto">This package builds on the fact that all you need to get started with using probabilistic programs are 3 things:</p>
<ol dir="auto">
<li>a way to define them</li>
<li>a function for drawing a trace randomly, and</li>
<li>a function for evaluating the log probability of a trace.</li>
</ol>
<p dir="auto">The specification of this high-level API is:</p>
<ol dir="auto">
<li>Macro <code>@probprog function_definition</code>: Define functions that construct probabilistic programs. This macro transforms sample statements indicated by the binary operator <code>~</code> into calls to a more low-level <code>sample</code> method (see the source code). Call the function generated by this macro to create a probabilistic program object (see example in Quickstart above).</li>
<li>Function <code>rand([rng,] prog)</code>: draw a random sample</li>
<li>Function <code>logpdf(prog, x)</code>: evaluate log probability (density) of a random sample. If the return values of <code>prog</code> are its execution traces, then <code>logpdf(prog, trace)</code> works out of the box. Otherwise, the function <code>recover_trace(prog, x)</code> needs to be implemented.</li>
</ol>
</article></div>