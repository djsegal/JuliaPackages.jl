<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-simpletraits" class="anchor" aria-hidden="true" href="#simpletraits"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SimpleTraits</h1>
<p><a href="https://travis-ci.com/mauro3/SimpleTraits.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/820f84e366d3aff0cb8190f21383c0cf672aaf20/68747470733a2f2f7472617669732d63692e636f6d2f6d6175726f332f53696d706c655472616974732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/mauro3/SimpleTraits.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/mauro3/simpletraits-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/81bcdde40f3da3f8b982f10f866c9494b0df85ec/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f6d6175726f332f53696d706c655472616974732e6a6c3f6272616e63683d6d6173746572267376673d74727565" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/mauro3/SimpleTraits.jl?branch=master&amp;svg=true" style="max-width:100%;"></a>
<a href="NEWS.md">NEWS</a></p>

<p><a href="http://pkg.julialang.org/?pkg=SimpleTraits" rel="nofollow"><img src="https://camo.githubusercontent.com/2af3435e2a3387ee1a62bc1c9ff73dd104eadbd6/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f53696d706c655472616974735f302e362e737667" alt="SimpleTraits" data-canonical-src="http://pkg.julialang.org/badges/SimpleTraits_0.6.svg" style="max-width:100%;"></a>
<a href="http://pkg.julialang.org/detail/SimpleTraits" rel="nofollow"><img src="https://camo.githubusercontent.com/ff751a06b7f8dd4a9168b074e901c0d5b6c17f4c/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f53696d706c655472616974735f302e372e737667" alt="SimpleTraits" data-canonical-src="http://pkg.julialang.org/badges/SimpleTraits_0.7.svg" style="max-width:100%;"></a></p>
<p>This package provides a macro-based implementation of traits, using
<a href="https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633">Tim Holy's trait trick</a>.
The main idea behind traits is to group types outside the
type-hierarchy and to make dispatch work with that grouping.  The
difference to Union-types is that types can be added to a trait after
the creation of the trait, whereas Union types are fixed after
creation.  The cool thing about Tim's trick is that there is no
performance impact compared to using ordinary dispatch.  For a bit of
background and a quick introduction to traits watch my 10min
<a href="https://youtu.be/j9w8oHfG1Ic" rel="nofollow">JuliaCon 2015</a> talk.</p>
<p>One good example of the use of traits is the
<a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array-1" rel="nofollow">abstract array interface</a>
in Julia-Base.  An abstract array either belongs to the
<code>Base.IndexLinear</code> or <code>Base.IndexCartesian</code> trait, depending on how its
internal indexing works.  The advantage to use a trait there is that
one is free to create a type hierarchy independent of this particular
"trait" of the array(s).</p>
<p>Tim Holy
<a href="https://github.com/mauro3/SimpleTraits.jl/pull/6#issuecomment-236886253">endorses</a>
SimpleTraits, a bit: "I'd say that compared to manually writing out
the trait-dispatch, the "win" is not enormous, but it is a little
nicer."  I suspect that — if you don't write Holy-traits before
breakfast — your "win" should be greater ;-)</p>
<h1><a id="user-content-manual" class="anchor" aria-hidden="true" href="#manual"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Manual</h1>
<p><strong>Note for Julia-0.6:</strong>  Below examples for <code>@traitfn</code> (using <code>where</code>-function
syntax) only work on Julia-0.7 or higher, for Julia-0.6 this syntax cannot be
not supported.
For Julia-0.6, see the README of the
SimpleTraits version
<a href="https://github.com/mauro3/SimpleTraits.jl/tree/v0.6.0">v0.6.0</a> instead.</p>
<p>Traits are defined with <code>@traitdef</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> SimpleTraits
<span class="pl-c1">@traitdef</span> IsNice{X}
<span class="pl-c1">@traitdef</span> BelongTogether{X,Y} <span class="pl-c"><span class="pl-c">#</span> traits can have several parameters</span></pre></div>
<p>All traits have one or more (type-)parameters to specify the type to
which the trait is applied.  For instance <code>IsNice{Int}</code> signifies that
<code>Int</code> is a member of <code>IsNice</code> (although whether that is true needs to be
checked with the <code>istrait</code> function).  Most traits will be
one-parameter traits, however, several parameters are useful when
there is a "contract" between several types.</p>
<p>As a <em>style convention</em>, I suggest to use trait names which start with
a verb, as above two traits.  This makes distinguishing between traits
and types easier as type names are usually nouns.</p>
<p>Add types to a trait-group with <code>@traitimpl</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitimpl</span> IsNice{Int}
<span class="pl-c1">@traitimpl</span> BelongTogether{Int,String}</pre></div>
<p>If there is a function which tests whether a trait is fulfilled then
it can be used like so:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitimpl</span> IsNice{X} <span class="pl-k">&lt;-</span> <span class="pl-c1">isnice</span>(X)
<span class="pl-en">isnice</span>(X) <span class="pl-k">=</span> <span class="pl-c1">false</span> <span class="pl-c"><span class="pl-c">#</span> set default</span></pre></div>
<p>i.e. any type <code>X</code> for which <code>isnice(X)==true</code> belongs to <code>IsNice</code>.
Notes:</p>
<ul>
<li>overhead-less  (static) dispatch
is only possible if <code>isnice</code> is <em>pure</em>: "[A pure method]
promises that the result will always be the same constant regardless
of when the method is called [for the same input arguments]."
(<a href="https://github.com/mauro3/SimpleTraits.jl/pull/39#issuecomment-293629338">ref</a>).</li>
<li>Last note that in above example the <code>@traitimpl IsNice{Int}</code> "wins" over the <code>@traitimpl IsNice{X} &lt;- isnice(X)</code>, thus
this can be used to define exceptions to a rule.</li>
</ul>
<p>It can be checked whether a type belongs to a trait with <code>istrait</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Test
<span class="pl-c1">@test</span> <span class="pl-c1">istrait</span>(IsNice{Int})
<span class="pl-c1">@test</span> <span class="pl-k">!</span><span class="pl-c1">istrait</span>(BelongTogether{Int,Int}) <span class="pl-c"><span class="pl-c">#</span> only BelongTogether{Int,String} was added above</span></pre></div>
<p>Functions which dispatch on traits are constructed like:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitfn</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X; IsNice{X}} <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Very nice!<span class="pl-pds">"</span></span>
<span class="pl-c1">@traitfn</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X; <span class="pl-k">!</span>IsNice{X}} <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Not so nice!<span class="pl-pds">"</span></span></pre></div>
<p>This means that a type <code>X</code> which is part of the trait <code>IsNice</code> will
dispatch to the method returning <code>"Very nice!"</code>, otherwise to the one
returning <code>"Not so nice!"</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@test</span> <span class="pl-c1">f</span>(<span class="pl-c1">5</span>)<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>Very nice!<span class="pl-pds">"</span></span>
<span class="pl-c1">@test</span> <span class="pl-c1">f</span>(<span class="pl-c1">5.</span>)<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>Not so nice!<span class="pl-pds">"</span></span></pre></div>
<p>Note that calling a trait-function is just like calling any other
function.  Thus there is no extra mental gymnastics required for a
"user" of a trait-based package.</p>
<p>Similarly for <code>BelongTogether</code> which has two parameters:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitfn</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>,y<span class="pl-k">::</span><span class="pl-c1">Y</span>) <span class="pl-k">where</span> {X,Y; BelongTogether{X,Y}} <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$x</span> and <span class="pl-v">$y</span> forever!<span class="pl-pds">"</span></span>
<span class="pl-c1">@test</span> <span class="pl-c1">f</span>(<span class="pl-c1">5</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>5 and b forever!<span class="pl-pds">"</span></span>
<span class="pl-c1">@test_throws</span> MethodError <span class="pl-c1">f</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>)

<span class="pl-c1">@traitfn</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>,y<span class="pl-k">::</span><span class="pl-c1">Y</span>) <span class="pl-k">where</span> {X,Y; <span class="pl-k">!</span>BelongTogether{X,Y}} <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$x</span> and <span class="pl-v">$y</span> cannot stand each other!<span class="pl-pds">"</span></span>
<span class="pl-c1">@test</span> <span class="pl-c1">f</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>)<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>5 and 5 cannot stand each other!<span class="pl-pds">"</span></span></pre></div>
<h2><a id="user-content-traitorjl-like-syntax" class="anchor" aria-hidden="true" href="#traitorjl-like-syntax"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><a href="https://github.com/andyferris/Traitor.jl">Traitor.jl</a>-like syntax</h2>
<p>At JuliaCon 2016 folks suggested an alternate, more compact syntax for
trait-functions.  However, it only works for single parameter traits.
SimpleTraits now supports this.  Above function <code>f</code> can be written as:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitfn</span> <span class="pl-en">ft</span>(x<span class="pl-k">:</span><span class="pl-k">::</span><span class="pl-c1">:IsNice</span>) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Very nice!<span class="pl-pds">"</span></span>
<span class="pl-c1">@traitfn</span> <span class="pl-en">ft</span>(x<span class="pl-k">:</span><span class="pl-k">::</span>:(<span class="pl-k">!</span>IsNice)) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Not so nice!<span class="pl-pds">"</span></span></pre></div>
<p>Note that the parenthesis are needed with negated traits, otherwise a
parser error is thrown.</p>
<h2><a id="user-content-vararg-default-argument-and-keyword-argument-trait-functions" class="anchor" aria-hidden="true" href="#vararg-default-argument-and-keyword-argument-trait-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vararg, default argument and keyword argument trait functions</h2>
<p>Vararg, default argument and keyword argument trait functions work.
However, with keyword arguments the trait function and negated trait
function need both have the same keywords (however different values
are allowed). Example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitfn</span> <span class="pl-en">kwfn</span>(x<span class="pl-k">:</span><span class="pl-k">::</span><span class="pl-c1">:Tr1</span>, y<span class="pl-k">...</span>; kw<span class="pl-k">=</span><span class="pl-c1">1</span>) <span class="pl-k">=</span> x<span class="pl-k">+</span>y[<span class="pl-c1">1</span>]<span class="pl-k">+</span>kw
<span class="pl-c1">@traitfn</span> <span class="pl-en">kwfn</span>(x<span class="pl-k">:</span><span class="pl-k">::</span>:(<span class="pl-k">!</span>Tr1), y<span class="pl-k">...</span>; kw<span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-k">=</span> x<span class="pl-k">+</span>y[<span class="pl-c1">1</span>]<span class="pl-k">+</span>kw</pre></div>
<p>For default arguments the rule is slightly different: with default
arguments the trait function and negated trait function need both have
the same default-argument with the <em>same values</em>.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitfn</span> <span class="pl-en">deff</span>(x<span class="pl-k">:</span><span class="pl-k">::</span><span class="pl-c1">:Tr1</span>, y<span class="pl-k">=</span><span class="pl-c1">1</span>) <span class="pl-k">=</span> x<span class="pl-k">+</span>y
<span class="pl-c1">@traitfn</span> <span class="pl-en">deff</span>(x<span class="pl-k">:</span><span class="pl-k">::</span>:(<span class="pl-k">!</span>Tr1), y<span class="pl-k">=</span><span class="pl-c1">1</span>) <span class="pl-k">=</span> x<span class="pl-k">+</span>y</pre></div>
<h2><a id="user-content-method-overwritten-warnings" class="anchor" aria-hidden="true" href="#method-overwritten-warnings"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Method overwritten warnings</h2>
<p>Warnings are issued when methods are overwritten.  Due
to Tim's trick the <code>@traitfn</code> needs to create two functions the first
time it is used for a particular method (see next section for an
explanation).  But when defining the opposite trait, then better only
one method is created or else the warning appears.  Some heuristics to
avoid the warnings are in-place to check whether a method is defined
yet or not but they fail at times (see issue
<a href="https://github.com/mauro3/SimpleTraits.jl/issues/7">#7</a>).  Long story
short: define the two methods of a trait and its negation using the
same argument names and no warning should be issued.  Although note
that the warnings are harmless.</p>
<h1><a id="user-content-details-of-method-dispatch" class="anchor" aria-hidden="true" href="#details-of-method-dispatch"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Details of method dispatch</h1>
<p>Defining a trait function adds: one new method (or overwrites one) to
the generic function, which contains the logic; and one helper
method to do the dispatch (Tim's trick), if it has not been defined
before.</p>
<p>When calling a generic function which has some <em>trait-methods</em>,
dispatch will first work on the types as normal.  If the selected
method is a trait-method then trait dispatch will kick in too.
Example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitdef</span> Tr{X}

<span class="pl-en">fn</span>(x<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">#</span> a normal method</span>
<span class="pl-c1">@traitfn</span> <span class="pl-en">fn</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractFloat</span>;  Tr{X}} <span class="pl-k">=</span> <span class="pl-c1">2</span>
<span class="pl-c1">@traitfn</span> <span class="pl-en">fn</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractFloat</span>; <span class="pl-k">!</span>Tr{X}} <span class="pl-k">=</span> <span class="pl-c1">3</span>

<span class="pl-c1">@traitimpl</span> Tr{Float32}
<span class="pl-c1">@traitimpl</span> Tr{Int} <span class="pl-c"><span class="pl-c">#</span> this does not impact dispatch of `fn`</span>

<span class="pl-c1">fn</span>(<span class="pl-c1">5</span>) <span class="pl-c"><span class="pl-c">#</span> -&gt; 1; dispatch only happens on the type</span>
<span class="pl-c1">fn</span>(<span class="pl-c1">Float32</span>(<span class="pl-c1">5</span>)) <span class="pl-c"><span class="pl-c">#</span> -&gt; 2; dispatch through traits</span>
<span class="pl-c1">fn</span>(<span class="pl-c1">Float64</span>(<span class="pl-c1">5</span>)) <span class="pl-c"><span class="pl-c">#</span> -&gt; 3; dispatch through traits</span></pre></div>
<p>Further note that for a particular trait-method dispatch only works on
one trait.  Continuing above example, this <em>does not work</em> as one may
expect:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitdef</span> Tr2{X}
<span class="pl-c1">@traitfn</span> <span class="pl-en">fn</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractFloat</span>; Tr2{X}} <span class="pl-k">=</span> <span class="pl-c1">4</span>

<span class="pl-c1">@traitimpl</span> Tr2{Float16}
<span class="pl-c1">fn</span>(<span class="pl-c1">Float16</span>(<span class="pl-c1">5</span>)) <span class="pl-c"><span class="pl-c">#</span> -&gt; 4; dispatch through traits</span>
<span class="pl-c1">fn</span>(<span class="pl-c1">Float32</span>(<span class="pl-c1">5</span>)) <span class="pl-c"><span class="pl-c">#</span> -&gt; MethodError; method defined in previous example</span>
               <span class="pl-c"><span class="pl-c">#</span>    was overwritten above</span></pre></div>
<p>This last definition of <code>fn</code> just overwrites the definition <code>@traitfn f(x::X) where {X; Tr{X}} = 2</code> from above.</p>
<p>If you need to dispatch on several traits in a single trait-method,
then you're out of luck.  But please voice your grievance over in pull
request <a href="https://github.com/mauro3/SimpleTraits.jl/pull/2">#2</a>.</p>
<h3><a id="user-content-performance" class="anchor" aria-hidden="true" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Performance</h3>
<p>There is no performance impact compared to normal functions thanks to
Julia's clever design. Continuing the example from above and looking
at the native code</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@code_native</span> <span class="pl-c1">fn</span>(<span class="pl-c1">5</span>)
        <span class="pl-k">.</span>text
Filename<span class="pl-k">:</span> REPL[<span class="pl-c1">3</span>]
        pushq   <span class="pl-k">%</span>rbp
        movq    <span class="pl-k">%</span>rsp, <span class="pl-k">%</span>rbp
Source line<span class="pl-k">:</span> <span class="pl-c1">1</span>
        movl    <span class="pl-k">$</span><span class="pl-c1">1</span>, <span class="pl-k">%</span>eax
        popq    <span class="pl-k">%</span>rbp
        retq
        nopl    (<span class="pl-k">%</span>rax,<span class="pl-k">%</span>rax)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@code_native</span> <span class="pl-c1">fn</span>(<span class="pl-c1">Float16</span>(<span class="pl-c1">5</span>))
        <span class="pl-k">.</span>text
Filename<span class="pl-k">:</span> SimpleTraits<span class="pl-k">.</span>jl
        pushq   <span class="pl-k">%</span>rbp
        movq    <span class="pl-k">%</span>rsp, <span class="pl-k">%</span>rbp
Source line<span class="pl-k">:</span> <span class="pl-c1">185</span>
        movl    <span class="pl-k">$</span><span class="pl-c1">4</span>, <span class="pl-k">%</span>eax
        popq    <span class="pl-k">%</span>rbp
        retq
        nopl    (<span class="pl-k">%</span>rax,<span class="pl-k">%</span>rax)</pre></div>
<p>shows that the normal method and the trait-method compile down to the
same machine instructions.</p>
<p>However, if the trait-grouping function is not constant or a generated
function then dispatch may be dynamic.  This can be checked with
<code>@check_fast_traitdispatch</code>, which checks whether the number of lines
of LLVM code is the same for a trait function than a normal one:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> julia 0.6</span>
<span class="pl-en">checkfn</span>(x) <span class="pl-k">=</span> <span class="pl-c1">rand</span>()<span class="pl-k">&gt;</span><span class="pl-c1">0.5</span> ? <span class="pl-c1">true</span> : <span class="pl-c1">false</span> <span class="pl-c"><span class="pl-c">#</span> a bit crazy!</span>
<span class="pl-c1">@traitdef</span> TestTr{X}
<span class="pl-c1">@traitimpl</span> TestTr{X} <span class="pl-k">&lt;-</span> <span class="pl-c1">checkfn</span>(X)
<span class="pl-c"><span class="pl-c">#</span> this tests a trait-function with TestTr{Int}:</span>
<span class="pl-c1">@check_fast_traitdispatch</span> TestTr
<span class="pl-c"><span class="pl-c">#</span> this tests a trait-function with TestTr{String} and will</span>
<span class="pl-c"><span class="pl-c">#</span> also prints number of LLCM-IR lines of trait vs normal function:</span>
<span class="pl-c1">@check_fast_traitdispatch</span> TestTr String <span class="pl-c1">true</span>

<span class="pl-c"><span class="pl-c">#</span> Now this is fast:</span>
<span class="pl-c1">@traitimpl</span> TestTr{String}
<span class="pl-c1">@check_fast_traitdispatch</span> TestTr String <span class="pl-c1">true</span></pre></div>
<h2><a id="user-content-advanced-features" class="anchor" aria-hidden="true" href="#advanced-features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced features</h2>
<p>The macros of the previous section are the official API of the package
and should be reasonably stable.  What follows in this section is
"under the hood" and may well be updated (but still signalled with
minor version changes).</p>
<p>Instead of using <code>@traitimpl</code> to add types to traits, it can be
programmed.  Running <code>@traitimpl IsNice{Int}</code> essentially expands to</p>
<div class="highlight highlight-source-julia"><pre>SimpleTraits<span class="pl-k">.</span><span class="pl-en">trait</span>(<span class="pl-k">::</span><span class="pl-c1">Type{IsNice{X1}}</span>) <span class="pl-k">where</span> {X1 <span class="pl-k">&lt;:</span> <span class="pl-c1">Int</span>} <span class="pl-k">=</span> IsNice{X1}</pre></div>
<p>I.e. <code>trait</code> is the identity function for a fulfilled trait and
returns <code>Not{TraitInQuestion{...}}</code> otherwise (this is the fall-back
for <code>&lt;:Any</code>).  So instead of using <code>@traitimpl</code> this can be coded
directly.  Note that anything but a constant function will probably
not be inlined away by the JIT and will lead to slower dynamic
dispatch (see <code>@check_fast_traitdispatch</code> for a helper to check).</p>
<p>Example leading to static dispatch (since Julia 0.6):</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitdef</span> IsBits{X}
SimpleTraits<span class="pl-k">.</span><span class="pl-en">trait</span>(<span class="pl-k">::</span><span class="pl-c1">Type{IsBits{X1}}</span>) <span class="pl-k">where</span> {X1} <span class="pl-k">=</span> <span class="pl-c1">isbits</span>(X1) ? IsBits{X1} : Not{IsBits{X1}}
<span class="pl-c1">istrait</span>(IsBits{Int}) <span class="pl-c"><span class="pl-c">#</span> true</span>
<span class="pl-c1">istrait</span>(IsBits{Array{Int,<span class="pl-c1">1</span>}}) <span class="pl-c"><span class="pl-c">#</span> false</span>
<span class="pl-k">struct</span> A
    a<span class="pl-k">::</span><span class="pl-c1">Int</span>
<span class="pl-k">end</span>
<span class="pl-c1">istrait</span>(IsBits{A}) <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<p>Dynamic dispatch can be avoided using a generated
function or <em>pure</em> functions (sometimes they need to be
annotated with <code>Base.@pure</code>):</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitdef</span> IsBits{X}
<span class="pl-c1">@generated</span> <span class="pl-k">function</span> SimpleTraits<span class="pl-k">.</span><span class="pl-en">trait</span>(<span class="pl-k">::</span><span class="pl-c1">Type{IsBits{X1}}</span>) <span class="pl-k">where</span> X1
    <span class="pl-c1">isbits</span>(X1) ? :(IsBits{X1}) : :(Not{IsBits{X1}})
<span class="pl-k">end</span></pre></div>
<p>What is allowed in generated functions is heavily restricted, see
<a href="https://docs.julialang.org/en/latest/manual/metaprogramming.html#Generated-functions-1" rel="nofollow">Julia manual</a>.
In particular (in Julia 0.6), no methods which are defined after the
generated function are allowed to be called inside the generated
function, otherwise
<a href="https://github.com/JuliaLang/julia/issues/21356">this</a> issue is
encountered.  Generally, try pure functions first and only in a pinch
generated functions.</p>
<p>Note that these programmed-traits can be combined with <code>@traitimpl IsBits{XYZ}</code>,
i.e. program the general case and add exceptions with <code>@traitimpl IsBits{XYZ}</code>.</p>
<p>Trait-inheritance can also be hand-coded with above trick.  For
instance, the trait given by (in pseudo syntax) <code>BeautyAndBeast{X,Y} &lt;: IsNice{X}, !IsNice{Y}, BelongTogether{X,Y}</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitdef</span> BeautyAndBeast{X,Y}
<span class="pl-k">function</span> SimpleTraits<span class="pl-k">.</span><span class="pl-en">trait</span>(<span class="pl-k">::</span><span class="pl-c1">Type{BeautyAndBeast{X,Y}}</span>) <span class="pl-k">where</span> {X,Y}
    <span class="pl-k">if</span> <span class="pl-c1">istrait</span>(IsNice{X}) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span><span class="pl-c1">istrait</span>(IsNice{Y}) <span class="pl-k">&amp;&amp;</span> BelongTogether{X,Y}
        BeautyAndBeast{X,Y}
    <span class="pl-k">else</span>
        Not{BeautyAndBeast{X,Y}}
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p>Note that this will lead to slower, dynamic dispatch, as
the function is not pure (it depends on the global state of
which types belong to the traits <code>IsNice</code> and <code>BelongTogether</code>).  (In
Julia 0.5 one could use a generated function but not anymore in Julia 0.6.)</p>
<p>Note also that trait functions can be generated functions:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitfn</span> <span class="pl-c1">@generated</span> <span class="pl-en">fg</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X; IsNice{X}} <span class="pl-k">=</span> (<span class="pl-c1">println</span>(x); <span class="pl-c1">:x</span>)</pre></div>
<h1><a id="user-content-innards" class="anchor" aria-hidden="true" href="#innards"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Innards</h1>
<p>The function <code>macroexpand</code> shows the syntax transformations a macro
does. Here the edited output of running it for the macros of this package:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">macroexpand</span>(:(<span class="pl-c1">@traitdef</span> Tr{X}))

<span class="pl-k">struct</span> Tr{X} <span class="pl-k">&lt;:</span> <span class="pl-c1">SimpleTraits.Trait</span>
<span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">macroexpand</span>(:(<span class="pl-c1">@traitimpl</span> Tr{Int}))

<span class="pl-c"><span class="pl-c">#</span> this function does the grouping of types into traits:</span>
SimpleTraits<span class="pl-k">.</span><span class="pl-en">trait</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Tr{X1}}</span>) <span class="pl-k">where</span> X1 <span class="pl-k">&lt;:</span> <span class="pl-c1">Int</span> <span class="pl-k">=</span> Tr{X1}
SimpleTraits<span class="pl-k">.</span><span class="pl-en">istrait</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Tr{X1}}</span>) <span class="pl-k">where</span> X1 <span class="pl-k">&lt;:</span> <span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">true</span> <span class="pl-c"><span class="pl-c">#</span> for convenience, really</span>

julia<span class="pl-k">&gt;</span> <span class="pl-en">macroexpand</span>(:(<span class="pl-c1">@traitfn</span> <span class="pl-en">g</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X; Tr{X}}<span class="pl-k">=</span> x<span class="pl-k">+</span><span class="pl-c1">1</span>))

<span class="pl-c1">@inline</span> <span class="pl-en">g</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X} <span class="pl-k">=</span> <span class="pl-c1">g</span>(<span class="pl-c1">trait</span>(Tr{X}), x) <span class="pl-c"><span class="pl-c">#</span> this is Tim's trick, using above grouping-function</span>
<span class="pl-en">g</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Tr{X}}</span>,x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X} <span class="pl-k">=</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">#</span> this is the logic</span>

julia<span class="pl-k">&gt;</span> <span class="pl-en">macroexpand</span>(:(<span class="pl-c1">@traitfn</span> <span class="pl-en">g</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X; <span class="pl-k">!</span>Tr{X}}<span class="pl-k">=</span> x<span class="pl-k">+</span><span class="pl-c1">1000</span>))

<span class="pl-c"><span class="pl-c">#</span> the trait dispatch helper function needn't be defined twice,</span>
<span class="pl-c"><span class="pl-c">#</span> only the logic:</span>
<span class="pl-en">g</span>(<span class="pl-k">::</span><span class="pl-c1">Type{ Not{Tr{X}} }</span>, x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X} <span class="pl-k">=</span> x <span class="pl-k">+</span> <span class="pl-c1">1000</span></pre></div>
<p>For a detailed explanation of how Tim's trick works, see
<a href="https://github.com/mauro3/Traits.jl#dispatch-on-traits">Traits.jl: Dispatch on traits</a>.
The difference here is I make the methods containing the logic part of
the same generic function (there it's in <code>_f</code>).</p>
<h1><a id="user-content-base-traits" class="anchor" aria-hidden="true" href="#base-traits"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Base Traits</h1>
<p>I started putting some Julia-Base traits together which can be loaded
with <code>using SimpleTraits.BaseTraits</code>, see the source for all
definitions.</p>
<p>Example, dispatch on whether an argument is immutable or not:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@traitfn</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X; IsImmutable{X}} <span class="pl-k">=</span> <span class="pl-c1">X</span>(x<span class="pl-k">.</span>fld<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> make a new instance</span>
<span class="pl-c1">@traitfn</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">X</span>) <span class="pl-k">where</span> {X; <span class="pl-k">!</span>IsImmutable{X}} <span class="pl-k">=</span> (x<span class="pl-k">.</span>fld <span class="pl-k">+=</span> <span class="pl-c1">1</span>; x) <span class="pl-c"><span class="pl-c">#</span> update in-place</span>

<span class="pl-c"><span class="pl-c">#</span> use</span>
<span class="pl-k">mutable struct</span> A; fld <span class="pl-k">end</span>
<span class="pl-k">struct</span> B; fld <span class="pl-k">end</span>
a<span class="pl-k">=</span><span class="pl-c1">A</span>(<span class="pl-c1">1</span>)
<span class="pl-c1">f</span>(a) <span class="pl-c"><span class="pl-c">#</span> in-place</span>
<span class="pl-c1">@assert</span> a<span class="pl-k">.</span>fld <span class="pl-k">==</span> <span class="pl-c1">A</span>(<span class="pl-c1">2</span>)<span class="pl-k">.</span>fld

b<span class="pl-k">=</span><span class="pl-c1">B</span>(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> out of place</span>
b2 <span class="pl-k">=</span> <span class="pl-c1">f</span>(b)
<span class="pl-c1">@assert</span> b<span class="pl-k">==</span><span class="pl-c1">B</span>(<span class="pl-c1">1</span>)
<span class="pl-c1">@assert</span> b2<span class="pl-k">==</span><span class="pl-c1">B</span>(<span class="pl-c1">2</span>)</pre></div>
<h1><a id="user-content-background" class="anchor" aria-hidden="true" href="#background"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Background</h1>
<p>This package grew out of an attempt to reduce the complexity of
<a href="https://github.com/mauro3/Traits.jl">Traits.jl</a>, but at the same time
staying compatible (but which it isn't).  Compared to Traits.jl, it
drops support for:</p>
<ul>
<li>Trait definition in terms of methods and constraints.  Instead the
user needs to assign types to traits manually.  This removes the
most complex part of Traits.jl: the checking whether a type
satisfies a trait definition.</li>
<li>trait functions which dispatch on more than one trait.  This allows
to remove the need for generated functions, as well as removing the
rules for trait-dispatch.</li>
</ul>
<p>The reason for splitting this away from Traits.jl are:</p>
<ul>
<li>creating a more reliable and easier to maintain package than
Traits.jl</li>
<li>exploring inclusion in Base (see
<a href="https://github.com/JuliaLang/julia/pull/13222">#13222</a>).</li>
</ul>
<p>My <a href="https://youtu.be/j9w8oHfG1Ic" rel="nofollow"><em>JuliaCon 2015</em></a> talk gives a 10
minute introduction to Traits.jl and SimpleTraits.jl.</p>
<h1><a id="user-content-the-future" class="anchor" aria-hidden="true" href="#the-future"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Future</h1>
<p>The future of traits in Julia-Base: According to Stefan Karpinski's
JuliaCon 2016 talk, <a href="https://youtu.be/5gXMpbY1kJY" rel="nofollow">Julia 1.0</a>, traits
are scheduled to land after Julia 1.0.  Although, if someone gets
cracking, they may well happen pre-1.0.  My crystal ball tells me that
all or most of the functionality of this package will be supported in
the future trait system (multiparameter-traits may not be). Thus I
expect the transition will be mostly a matter of a syntax update and
less of a semantic update.  Also, an advantage to using this package
versus hand-coding Holy-traits will be that all occurrences of trait
usage are clearly marked and thus easier to update.</p>
<p>The future of this package: I see it as light-weight package focusing
on letting functions use dispatch based on traits.  This dispatch is
currently fairly limited, see section "Gotcha" above, but may be
expanded in the future: either through something like in PR
<a href="https://github.com/mauro3/SimpleTraits.jl/pull/2">m3/multitraits</a> or
through a more general generated-function approach (definitely not
valid anymore in Julia 0.6).</p>
<p>In the unlikely event that I find myself with too much time on my
hands, I may try to develop a companion package to allow the
specification of a trait in terms of interfaces.  The combination of
the two packages would then have similar functionality to my
experimental package <a href="https://github.com/mauro3/Traits.jl">Traits.jl</a>.
If anyone fancies a go at writing this companion package, I would be
very happy to help and contribute.  After the
<a href="https://github.com/JuliaLang/julia/pull/18457">type-system overhaul</a>
lands, this should be much less hackish than what's in Traits.jl.</p>
<h1><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>References</h1>
<ul>
<li><a href="https://github.com/mauro3/Traits.jl">Traits.jl</a> and its references.
In particular
<a href="https://github.com/mauro3/Traits.jl#dispatch-on-traits">here</a> is an
in-depth discussion on limitations of Holy-Traits, which this
package implements.</li>
</ul>
<h1><a id="user-content-to-ponder" class="anchor" aria-hidden="true" href="#to-ponder"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>To ponder</h1>
<ul>
<li>There is a big update sitting in the branch
<a href="https://github.com/mauro3/SimpleTraits.jl/pull/2">m3/multitraits</a>;
but I never quite finished it.  It would also address the next point:</li>
<li>Could type inheritance be used for sub-traits
(<a href="https://github.com/JuliaLang/julia/issues/10889#issuecomment-94317470">Jutho's idea</a>)?
In particular could it be used in such a way that it is compatible
with the multiple inheritance used in Traits.jl?</li>
</ul>
</article></div>