<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-multiscalearrays" class="anchor" aria-hidden="true" href="#multiscalearrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MultiScaleArrays</h1>
<p dir="auto"><a href="https://julialang.zulipchat.com/#narrow/stream/279055-sciml-bridged" rel="nofollow"><img src="https://camo.githubusercontent.com/667867fc71b8b3c9ed350ce154a04d38adca002ecfa38edf519284e0365ee553/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d5a756c6970266d6573736167653d6368617426636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="Join the chat at https://julialang.zulipchat.com #sciml-bridged" data-canonical-src="https://img.shields.io/static/v1?label=Zulip&amp;message=chat&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a>
<a href="https://docs.sciml.ai/MultiScaleArrays/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/88037a523f970520933771e764f5abff55de9382efc91cd89dd43ef0bb49a85f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d5363694d4c2d626c75652e737667" alt="Global Docs" data-canonical-src="https://img.shields.io/badge/docs-SciML-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://codecov.io/gh/SciML/MultiScaleArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f785a4f7bd8a859d2f21e5dde982fa9d88d00bca91b48f1a3090d84d3edb729a/68747470733a2f2f636f6465636f762e696f2f67682f5363694d4c2f4d756c74695363616c654172726179732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d467758614b424e573637" alt="codecov" data-canonical-src="https://codecov.io/gh/SciML/MultiScaleArrays.jl/branch/master/graph/badge.svg?token=FwXaKBNW67" style="max-width: 100%;"></a>
<a href="https://github.com/SciML/MultiScaleArrays.jl/actions?query=workflow%3ACI"><img src="https://github.com/SciML/MultiScaleArrays.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/SciML/ColPrac"><img src="https://camo.githubusercontent.com/2496bdc13cbc9c458dfa19a108b1f333353f62917355a4cdee582bbdf8be43cf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436f6c507261632d436f6e7472696275746f722532377325323047756964652d626c756576696f6c6574" alt="ColPrac: Contributor's Guide on Collaborative Practices for Community Packages" data-canonical-src="https://img.shields.io/badge/ColPrac-Contributor%27s%20Guide-blueviolet" style="max-width: 100%;"></a>
<a href="https://github.com/SciML/SciMLStyle"><img src="https://camo.githubusercontent.com/3e16f03bad047817fbc07f49307817ed7919ef79c339dc75ad4ce813012c3e0b/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d636f64652532307374796c65266d6573736167653d5363694d4c26636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="SciML Code Style" data-canonical-src="https://img.shields.io/static/v1?label=code%20style&amp;message=SciML&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a></p>
<p dir="auto">MultiScaleArrays.jl allows you to easily build multiple scale models which are
fully compatible with native Julia scientific computing packages like
DifferentialEquations.jl or Optim.jl. These models utilize
a tree structure to describe phenomena of multiple scales, but the interface allows
you to describe equations on different levels, using aggregations from lower
levels to describe complex systems. Their structure allows for complex and dynamic
models to be developed with only a small performance difference. In the end, they present
themselves as an <code>AbstractArray</code> to standard solvers, allowing them to be used
in place of a <code>Vector</code> in any appropriately made Julia package.</p>
<h2 dir="auto"><a id="user-content-tutorials-and-documentation" class="anchor" aria-hidden="true" href="#tutorials-and-documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorials and Documentation</h2>
<p dir="auto">For information on using the package,
<a href="https://docs.sciml.ai/MultiScaleArrays/stable/" rel="nofollow">see the stable documentation</a>. Use the
<a href="https://docs.sciml.ai/MultiScaleArrays/dev/" rel="nofollow">in-development documentation</a> for the version of
the documentation, which contains the unreleased features.</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<p dir="auto">The usage is best described by an example. Here we build a hierarchy where
Embryos contain Tissues which contain Populations which contain Cells, and the
cells contain proteins whose concentrations are modeled as simply a vector
of numbers (it can be anything linearly indexable).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MultiScaleArrays
struct Cell{B} &lt;: AbstractMultiScaleArrayLeaf{B}
    values::Vector{B}
end
struct Population{T &lt;: AbstractMultiScaleArray, B &lt;: Number} &lt;: AbstractMultiScaleArray{B}
    nodes::Vector{T}
    values::Vector{B}
    end_idxs::Vector{Int}
end
struct Tissue{T &lt;: AbstractMultiScaleArray, B &lt;: Number} &lt;: AbstractMultiScaleArray{B}
    nodes::Vector{T}
    values::Vector{B}
    end_idxs::Vector{Int}
end
struct Embryo{T &lt;: AbstractMultiScaleArray, B &lt;: Number} &lt;: AbstractMultiScaleArrayHead{B}
    nodes::Vector{T}
    values::Vector{B}
    end_idxs::Vector{Int}
end"><pre><span class="pl-k">using</span> MultiScaleArrays
<span class="pl-k">struct</span> Cell{B} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractMultiScaleArrayLeaf{B}</span>
    values<span class="pl-k">::</span><span class="pl-c1">Vector{B}</span>
<span class="pl-k">end</span>
<span class="pl-k">struct</span> Population{T <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractMultiScaleArray</span>, B <span class="pl-k">&lt;:</span> <span class="pl-c1">Number</span>} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractMultiScaleArray{B}</span>
    nodes<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>
    values<span class="pl-k">::</span><span class="pl-c1">Vector{B}</span>
    end_idxs<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>
<span class="pl-k">end</span>
<span class="pl-k">struct</span> Tissue{T <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractMultiScaleArray</span>, B <span class="pl-k">&lt;:</span> <span class="pl-c1">Number</span>} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractMultiScaleArray{B}</span>
    nodes<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>
    values<span class="pl-k">::</span><span class="pl-c1">Vector{B}</span>
    end_idxs<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>
<span class="pl-k">end</span>
<span class="pl-k">struct</span> Embryo{T <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractMultiScaleArray</span>, B <span class="pl-k">&lt;:</span> <span class="pl-c1">Number</span>} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractMultiScaleArrayHead{B}</span>
    nodes<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>
    values<span class="pl-k">::</span><span class="pl-c1">Vector{B}</span>
    end_idxs<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">This setup defines a type structure which is both a tree and an array. A picture of a possible
version is the following:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/1814174/27211626-79fe1b9a-520f-11e7-87f1-1cb33da91609.PNG"><img src="https://user-images.githubusercontent.com/1814174/27211626-79fe1b9a-520f-11e7-87f1-1cb33da91609.PNG" style="max-width: 100%;"></a></p>
Let's build a version of this. Using the constructors we can directly construct leaf types:
```julia
cell1 = Cell([1.0; 2.0; 3.0])
cell2 = Cell([4.0; 5.0])
```
and build types higher up in the hierarchy by using the `constuct` method. The method
is `construct(T::AbstractMultiScaleArray, nodes, values)`, though if `values` is not given it's
taken to be empty.
```julia
cell3 = Cell([3.0; 2.0; 5.0])
cell4 = Cell([4.0; 6.0])
population = construct(Population, deepcopy([cell1, cell3, cell4]))
population2 = construct(Population, deepcopy([cell1, cell3, cell4]))
population3 = construct(Population, deepcopy([cell1, cell3, cell4]))
tissue1 = construct(Tissue, deepcopy([population, population2, population3])) # Make a Tissue from Populations
tissue2 = construct(Tissue, deepcopy([population2, population, population3]))
embryo = construct(Embryo, deepcopy([tissue1, tissue2])) # Make an embryo from Tissues
```
</article></div>