<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-thermostatejl" class="anchor" aria-hidden="true" href="#thermostatejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ThermoState.jl</h1>
<p><a href="https://travis-ci.com/longemen3000/ThermoState.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/49684deb69e99257101751be0314bee4b59f012d43f19205b5ce67804a4384fc/68747470733a2f2f7472617669732d63692e636f6d2f6c6f6e67656d656e333030302f546865726d6f53746174652e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/longemen3000/ThermoState.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://github.com/longemen3000/ThermoState.jl/actions"><img src="https://github.com/longemen3000/ThermoState.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/longemen3000/ThermoState.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/5ffa1171a8bab4c275a08d37ecc9a284e77494645ae2f6e1a27747eccd23af24/68747470733a2f2f636f6465636f762e696f2f67682f6c6f6e67656d656e333030302f546865726d6f53746174652e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/longemen3000/ThermoState.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a>
<a href="https://longemen3000.github.io/ThermoState.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a>
<a href="https://longemen3000.github.io/ThermoState.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a></p>
<p>ThermoState.jl is a basic block for interfacing and specifying thermodynamic models. this package proposes and provides tools to create a common property interface of the form:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="property(model,state,unit)
"><pre><span class="pl-c1">property</span>(model,state,unit)</pre></div>
<h2><a id="user-content-basics" class="anchor" aria-hidden="true" href="#basics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basics</h2>
<p>This package proposes the following conventions for naming properties:</p>
<ul>
<li>
<p><code>mol_$PROPERTY</code> is a property of units U/mol (molar volume, molar Helmholtz energy, molar enthalpy, etc)</p>
</li>
<li>
<p><code>mass_$PROPERTY</code> is a property of units U/kg.</p>
</li>
<li>
<p><code>total_$PROPERTY</code> is a property of units U. (total Helmholtz energy has joule units)</p>
</li>
</ul>
<p>The following properties are accepted by an state and have an accesor function:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Units</th>
<th>Accessor function</th>
<th>Keywords for <code>spec</code> and <code>state</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Molar volume</td>
<td>m3/mol</td>
<td><code>mol_volume</code></td>
<td><code>v</code>, <code>mol_v</code></td>
</tr>
<tr>
<td>Mass volume</td>
<td>m3/kg</td>
<td><code>mass_volume</code></td>
<td><code>mass_v</code></td>
</tr>
<tr>
<td>Total volume</td>
<td>m3</td>
<td><code>total_volume</code></td>
<td><code>total_v</code>, <code>V</code></td>
</tr>
<tr>
<td>Molar density</td>
<td>mol/m3</td>
<td><code>mol_density</code></td>
<td><code>ρ</code>, <code>mol_ρ</code>, <code>rho</code>, <code>mol_rho</code></td>
</tr>
<tr>
<td>Mass density</td>
<td>mol/kg</td>
<td><code>mass_density</code></td>
<td><code>mass_ρ</code>, <code>mass_rho</code></td>
</tr>
<tr>
<td>Temperature</td>
<td>K</td>
<td><code>temperature</code></td>
<td><code>t</code>, <code>T</code></td>
</tr>
<tr>
<td>Pressure</td>
<td>Pa</td>
<td><code>pressure</code></td>
<td><code>p</code>, <code>P</code></td>
</tr>
<tr>
<td>Molar enthalpy</td>
<td>J/mol</td>
<td><code>mol_enthalpy</code></td>
<td><code>h</code>, <code>mol_h</code></td>
</tr>
<tr>
<td>Mass enthalpy</td>
<td>J/kg</td>
<td><code>mass_enthalpy</code></td>
<td><code>mass_h</code></td>
</tr>
<tr>
<td>Total enthalpy</td>
<td>J</td>
<td><code>total_enthalpy</code></td>
<td><code>total_h</code></td>
</tr>
<tr>
<td>Molar Gibbs</td>
<td>J/mol</td>
<td><code>mol_gibbs</code></td>
<td><code>g</code>, <code>mol_g</code></td>
</tr>
<tr>
<td>Mass Gibbs</td>
<td>J/kg</td>
<td><code>mass_gibbs</code></td>
<td><code>mass_g</code></td>
</tr>
<tr>
<td>Total Gibbs</td>
<td>J</td>
<td><code>total_gibbs</code></td>
<td><code>total_g</code></td>
</tr>
<tr>
<td>Molar Helmholtz</td>
<td>J/mol</td>
<td><code>mol_helmholtz</code></td>
<td><code>a</code>, <code>mol_a</code></td>
</tr>
<tr>
<td>Mass Helmholtz</td>
<td>J/kg</td>
<td><code>mass_helmholtz</code></td>
<td><code>mass_a</code></td>
</tr>
<tr>
<td>Total Helmholtz</td>
<td>J</td>
<td><code>total_helmholtz</code></td>
<td><code>total_a</code></td>
</tr>
<tr>
<td>Molar Internal Energy</td>
<td>J/mol</td>
<td><code>mol_internal_energy</code></td>
<td><code>a</code>, <code>mol_a</code></td>
</tr>
<tr>
<td>Mass Internal Energy</td>
<td>J/kg</td>
<td><code>mass_internal_energy</code></td>
<td><code>mass_a</code></td>
</tr>
<tr>
<td>Total Internal Energy</td>
<td>J</td>
<td><code>total_internal_energy</code></td>
<td><code>total_a</code></td>
</tr>
<tr>
<td>Molar entropy</td>
<td>J/(mol K)</td>
<td><code>mol_entropy</code></td>
<td><code>s</code>, <code>mol_s</code></td>
</tr>
<tr>
<td>Mass entropy</td>
<td>J/(kg K)</td>
<td><code>mass_entropy</code></td>
<td><code>mass_s</code></td>
</tr>
<tr>
<td>Total entropy</td>
<td>J/K</td>
<td><code>total_entropy</code></td>
<td><code>total_s</code></td>
</tr>
<tr>
<td>Amount of Moles</td>
<td>mol</td>
<td><code>moles</code></td>
<td><code>moles</code></td>
</tr>
<tr>
<td>Amount of Mass</td>
<td>kg</td>
<td><code>mass</code></td>
<td><code>mass</code></td>
</tr>
<tr>
<td>Molar Fraction</td>
<td>no units</td>
<td><code>mol_fraction</code></td>
<td><code>xn</code></td>
</tr>
<tr>
<td>Mass Fraction</td>
<td>no units</td>
<td><code>mass_fraction</code></td>
<td><code>xm</code></td>
</tr>
<tr>
<td>Molar Numbers</td>
<td>mol</td>
<td><code>mol_number</code></td>
<td><code>n</code></td>
</tr>
<tr>
<td>Mass Numbers</td>
<td>kg</td>
<td><code>mass_number</code></td>
<td><code>m</code></td>
</tr>
<tr>
<td>Molar Vapor Fraction</td>
<td>no units</td>
<td><code>mol_vapor_fraction</code></td>
<td><code>vfrac</code></td>
</tr>
<tr>
<td>Mass Vapor Fraction</td>
<td>no units</td>
<td><code>mass_vapor_fraction</code></td>
<td><code>quality</code></td>
</tr>
<tr>
<td>Current Phase</td>
<td>no units</td>
<td><code>phase</code></td>
<td><code>phase</code>, <code>sat</code></td>
</tr>
<tr>
<td>Aditional Options</td>
<td>no units</td>
<td><code>options</code></td>
<td><code>options</code></td>
</tr>
</tbody>
</table>
<hr>
<p>You can view the keywords in the <code>KW_TO_SPEC</code> constant.</p>
<p>The Following functions aren't accepted as a keyword to <code>state</code> or <code>spec</code>, but are defined on the package:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Units</th>
<th>Accessor function</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Molar Mass</td>
<td>kg/mol</td>
<td><code>molar_mass</code></td>
<td>molecular weight ponderated by material amounts</td>
</tr>
<tr>
<td>Molar Cₚ</td>
<td>J/(mol K)</td>
<td><code>mol_cp</code></td>
<td>no impl, for interop use</td>
</tr>
<tr>
<td>Mass Cₚ</td>
<td>J/(kg K)</td>
<td><code>mass_cp</code></td>
<td>no impl, for interop use</td>
</tr>
<tr>
<td>Molar Cᵥ</td>
<td>J/(mol K)</td>
<td><code>mol_cv</code></td>
<td>no impl, for interop use</td>
</tr>
<tr>
<td>Mass Cᵥ</td>
<td>J/(kg K)</td>
<td><code>mass_cv</code></td>
<td>no impl, for interop use</td>
</tr>
<tr>
<td>Speed of sound</td>
<td>m/s</td>
<td><code>sound_speed</code></td>
<td>no impl, for interop use</td>
</tr>
</tbody>
</table>
<hr>
<p>For defining property specifications, the package defines the <code>AbstractSpec</code> types and the <code>Spec</code> container. an individual specification can be defined by:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Unitful, ThermoState
h0 = spec(mol_h=&quot;kg/mol&quot;)
"><pre><span class="pl-k">using</span> Unitful, ThermoState
h0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(mol_h<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>kg/mol<span class="pl-pds">"</span></span>)</pre></div>
<p>You can create various specifications with the <code>state</code> function:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="st = state(v=990u&quot;m^3/mol&quot;,T=350u&quot;K&quot;,mass=3u&quot;mg&quot;)
"><pre>st <span class="pl-k">=</span> <span class="pl-c1">state</span>(v<span class="pl-k">=</span><span class="pl-c1">990</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3/mol<span class="pl-pds">"</span></span>,T<span class="pl-k">=</span><span class="pl-c1">350</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>K<span class="pl-pds">"</span></span>,mass<span class="pl-k">=</span><span class="pl-c1">3</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>mg<span class="pl-pds">"</span></span>)</pre></div>
<p>And extract values for the use of property models:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="mass_rho0=mass_density(FromState(),st,&quot;kg/L&quot;,18.0u&quot;g/mol&quot;)
"><pre>mass_rho0<span class="pl-k">=</span><span class="pl-c1">mass_density</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds">"</span>kg/L<span class="pl-pds">"</span></span>,<span class="pl-c1">18.0</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>g/mol<span class="pl-pds">"</span></span>)</pre></div>
<h2><a id="user-content-specification-object-spec" class="anchor" aria-hidden="true" href="#specification-object-spec"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Specification object (<code>Spec</code>)</h2>
<p>A <code>Spec</code> is just a tagged value. it can be constructed by two ways:</p>
<ul>
<li>
<p>type-value constructor:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content=" t0 = spec(Types.Temperature(),300.15)
 t0 = spec(Types.Temperature(),30u&quot;°C&quot;) #normalized
 t0 = spec(Types.Temperature(),30u&quot;°C&quot;,false) #not normalized
"><pre> t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(Types<span class="pl-k">.</span><span class="pl-c1">Temperature</span>(),<span class="pl-c1">300.15</span>)
 t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(Types<span class="pl-k">.</span><span class="pl-c1">Temperature</span>(),<span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span>normalized</span>
 t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(Types<span class="pl-k">.</span><span class="pl-c1">Temperature</span>(),<span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>,<span class="pl-c1">false</span>) <span class="pl-c"><span class="pl-c">#</span>not normalized</span></pre></div>
</li>
<li>
<p>type-value constructor (using <code>@spec_str</code> macro):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content=" t0 = spec(spec&quot;t&quot;,300.15)
 t0 = spec(spec&quot;t&quot;,30u&quot;°C&quot;) #normalized
 t0 = spec(spec&quot;t&quot;,30u&quot;°C&quot;,false) #not normalized
"><pre> t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">spec</span>"</span>t<span class="pl-pds">"</span></span>,<span class="pl-c1">300.15</span>)
 t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">spec</span>"</span>t<span class="pl-pds">"</span></span>,<span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span>normalized</span>
 t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">spec</span>"</span>t<span class="pl-pds">"</span></span>,<span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>,<span class="pl-c1">false</span>) <span class="pl-c"><span class="pl-c">#</span>not normalized</span></pre></div>
<p>by default, unitful quantities are unit stripped and normalized to SI units, you can use the argument <code>normalize_units</code> to change that default.</p>
</li>
<li>
<p>keyword constructor:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="t0 = spec(t= 300.15)
t0 = spec(T= 30u&quot;°C&quot;) 
t0 = spec(T = 30u&quot;°C&quot;,normalize_units= false) 
"><pre>t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(t<span class="pl-k">=</span> <span class="pl-c1">300.15</span>)
t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(T<span class="pl-k">=</span> <span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>) 
t0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(T <span class="pl-k">=</span> <span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>,normalize_units<span class="pl-k">=</span> <span class="pl-c1">false</span>) </pre></div>
</li>
</ul>
<p>All keyword arguments are stored in the <code>KW_TO_SPEC</code> dict keys.
The Main difference between the type-value constructor and the keyword constructor is that the first can be resolved at compile time, where as the second has a runtime cost.</p>
<p>The result of those operations is a <code>Spec</code> struct:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; t0 = spec(T = 30.0u&quot;°C&quot;)     
spec(t = 303.15[K])

julia&gt; typeof(t0)
Spec{ThermoState.Types.Temperature,Float64}

julia&gt; val_t0 = value(t0) #extracting value
303.15

julia&gt; spec_t0 = specification(t0) #specification of t0 
Temperature()
"><pre lang="julia-repl"><code>julia&gt; t0 = spec(T = 30.0u"°C")     
spec(t = 303.15[K])

julia&gt; typeof(t0)
Spec{ThermoState.Types.Temperature,Float64}

julia&gt; val_t0 = value(t0) #extracting value
303.15

julia&gt; spec_t0 = specification(t0) #specification of t0 
Temperature()
</code></pre></div>
<p>an example of a enthalpy specification:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; h0 = spec(mol_h = 3000.0)
spec(mol_h = 3000.0[J mol^-1])

julia&gt; specification(h0)
Enthalpy{MOLAR}()

julia&gt; typeof(h0)
Spec{ThermoState.Types.Enthalpy{ThermoState.Types.MOLAR},Float64} ##?
"><pre lang="julia-repl"><code>julia&gt; h0 = spec(mol_h = 3000.0)
spec(mol_h = 3000.0[J mol^-1])

julia&gt; specification(h0)
Enthalpy{MOLAR}()

julia&gt; typeof(h0)
Spec{ThermoState.Types.Enthalpy{ThermoState.Types.MOLAR},Float64} ##?
</code></pre></div>
<p>In this case, the specification type is a parametric singleton struct: <code>Enthalpy{MOLAR}</code>. the <code>MOLAR</code> parameter is known as a <em>spec modifier</em> , and is used for dispatch in unit transformations and conversions (from molar to mass units, for example).</p>
<p>There are two special cases with two parameters: volume amounts (molar, total and specific volume, mass and molar density) and material compound proportions (mass numbers, mol numbers, mass fractions and mol fractions). volume amounts are tagged with the specification <code>VolumeAmount{&lt;:SpecModifier,&lt;:SpecModifier}</code> and material compounds tagged with the specification <code>MaterialCompounds{&lt;:SpecModifier,&lt;:SpecModifier}</code>. lets see some examples:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; using ThermoState.Types #importing the spec types for shorter printing


julia&gt; typeof(specification(spec(mol_v = 0.005)))
VolumeAmount{MOLAR,VOLUME}

julia&gt; typeof(spec&quot;mol_v&quot;)
VolumeAmount{MOLAR,VOLUME}

julia&gt; typeof(specification(spec(mass_rho = 875.2)))
VolumeAmount{TOTAL,DENSITY}

julia&gt; typeof(specification(spec(xn = [0.5,0.5])))
MaterialCompounds{MOLAR,FRACTION}

julia&gt; typeof(specification(spec(m = [40.2,35.3])))
MaterialCompounds{MASS,TOTAL_AMOUNT}
"><pre lang="julia-repl"><code>julia&gt; using ThermoState.Types #importing the spec types for shorter printing


julia&gt; typeof(specification(spec(mol_v = 0.005)))
VolumeAmount{MOLAR,VOLUME}

julia&gt; typeof(spec"mol_v")
VolumeAmount{MOLAR,VOLUME}

julia&gt; typeof(specification(spec(mass_rho = 875.2)))
VolumeAmount{TOTAL,DENSITY}

julia&gt; typeof(specification(spec(xn = [0.5,0.5])))
MaterialCompounds{MOLAR,FRACTION}

julia&gt; typeof(specification(spec(m = [40.2,35.3])))
MaterialCompounds{MASS,TOTAL_AMOUNT}
</code></pre></div>
<p>There are two special types: <code>PhaseTag</code> (keyword = <code>phase</code>) and <code>Options</code> (keyword = <code>options</code>). the first is useful to signal an underlying model to calculate just one phase (for example, in cubic equations, the root calculation gives the vapor and liquid volumes). <code>Options</code> accepts a named tuple that can be passed to any underlying model to specify numerical options (choice of differentiation method, maximum iterations,etc).</p>
<h2><a id="user-content-thermodynamicstate" class="anchor" aria-hidden="true" href="#thermodynamicstate"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>ThermodynamicState</code></h2>
<p>A specification is not sufficient to define a system. The <a href="https://en.wikipedia.org/wiki/Phase_rule" rel="nofollow">Gibbs' Phase Rule</a> specifies that a system in equilibrium has <code>F</code> degrees of freedom, where <code>F = NumberOfComponents - NumberOfPhases + 2 </code>.</p>
<p>The <code>ThermodynamicState</code> struct is a collection of <code>Spec</code>s. When creating this object, the Gibbs' Phase Rule is evaluated on the specification arguments to check its validity. lets see one example:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; a = state(t=300.0,ρ=5u&quot;mol/m^3&quot;)
ThermodynamicState with 2 properties:
  Temperature : 300.0[K]
  Molar density : 5[mol m^-3]
"><pre lang="julia-repl"><code>julia&gt; a = state(t=300.0,ρ=5u"mol/m^3")
ThermodynamicState with 2 properties:
  Temperature : 300.0[K]
  Molar density : 5[mol m^-3]
</code></pre></div>
<p>In this case, neither a phase nor any amount of compounds was specified. In those cases, the function assumes when the system has one mol, one phase, and/or a single component.</p>
<p>Another way to build a <code>ThermodynamicState</code> struct is by directly passing <code>Spec</code>s as arguments:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content=" julia&gt;
 h0 = spec(mol_h = 3000.0)
 t0 = spec(t=401.0)
 st = state(h0,t0)
julia&gt;  st = state(h0,t0)
ThermodynamicState with 2 properties:
  Molar enthalpy : 3000.0[J mol^-1]
  Temperature : 401.0[K]
"><pre lang="julia-repl"><code> julia&gt;
 h0 = spec(mol_h = 3000.0)
 t0 = spec(t=401.0)
 st = state(h0,t0)
julia&gt;  st = state(h0,t0)
ThermodynamicState with 2 properties:
  Molar enthalpy : 3000.0[J mol^-1]
  Temperature : 401.0[K]
</code></pre></div>
<p>You can skip the check of the Gibbs' Phase Rule using the <code>check = false</code> keyword, or, in the case of building the state using keywords, decide to not normalize units via the
<code>normalize_units= false</code> keyword.</p>
<h2><a id="user-content-obtaining-properties-from-a-thermodynamicstate-struct" class="anchor" aria-hidden="true" href="#obtaining-properties-from-a-thermodynamicstate-struct"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Obtaining properties from a <code>ThermodynamicState</code> struct</h2>
<p>As said in the Basics section, you can query properties from the created <code>ThermodynamicState</code> struct. the way of obtaining those properties is by calling a property function. The interface proposed by this package is the following:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="prop = property(model::MyModel,state::ThermodynamicState,unit::Unitful.unit=[default],args...)

"><pre>prop <span class="pl-k">=</span> <span class="pl-c1">property</span>(model<span class="pl-k">::</span><span class="pl-c1">MyModel</span>,state<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">::</span><span class="pl-c1">Unitful.unit</span><span class="pl-k">=</span>[default],args<span class="pl-k">...</span>)
</pre></div>
<p>Dispatching on the model type, you can calculate properties from the specifications contained in <code>state</code>.
This package exports one single model: <code>FromState</code>, that doesn't calculate (almost) anything, just checks if the selected property is in the argument, and if it is, it returns its numerical (unit stripped) value.
By default, the units of the number returned correspond to SI units, you can obtain a number with appropiate units by passing a corresponding <code>unit</code> argument.
the <code>FromState</code> model, given a corresponding molecular weight <code>mw</code> argument, can calculate derived properties, for example:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="mw = 50
a = state(t=300.0,ρ=5.0u&quot;mol/L&quot;)
v = mass_volume(FromSpecs(),a,u&quot;cm^3/g&quot;,mw)
4.0
"><pre lang="julia-repl"><code>mw = 50
a = state(t=300.0,ρ=5.0u"mol/L")
v = mass_volume(FromSpecs(),a,u"cm^3/g",mw)
4.0
</code></pre></div>
<p>The <code>mw</code> argument can be, depending of the situation, a number of vector of number. if not units are provided, a default units of <code>g/mol</code> are assumed. this conversion can be done on any unit that accepts molar, total and mass specifications, mass and moles themselves, molar and mass fractions,and molar and mass numbers.</p>
<h2><a id="user-content-variable-thermodynamicstates" class="anchor" aria-hidden="true" href="#variable-thermodynamicstates"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Variable <code>ThermodynamicState</code>s</h2>
<p>Sometimes a more direct approach is needed when properties.For example, you may want to create a function that accepts only temperature to pass it to an ODE system or an optimization system. for this purpose, the Singleton <code>VariableSpec</code> is provided. if you pass it to a <code>Spec</code> or create a <code>ThermodynamicState</code> object, the resulting <code>state</code> or <code>spec</code> will be callable:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; a_t = state(t=VariableSpec(),ρ=5.0u&quot;mol/L&quot;)
ThermodynamicState(x₁) with 2 properties:
  Temperature : x₁
  Molar density : 5000.0[mol m^-3]
 
julia&gt; a_t(300.15)
ThermodynamicState with 2 properties:
  Temperature : 300.15[K]
  Molar density : 5000.0[mol m^-3]

"><pre lang="julia-repl"><code>julia&gt; a_t = state(t=VariableSpec(),ρ=5.0u"mol/L")
ThermodynamicState(x₁) with 2 properties:
  Temperature : x₁
  Molar density : 5000.0[mol m^-3]
 
julia&gt; a_t(300.15)
ThermodynamicState with 2 properties:
  Temperature : 300.15[K]
  Molar density : 5000.0[mol m^-3]

</code></pre></div>
<p>up to 3 <code>VariableSpec</code> can be added to each <code>ThermodynamicState</code>. a spec can only have one <code>VariableSpec</code></p>
<p>Its important to note that the functor created accepts the arguments in the same order as the arguments passed to the state function. for example,  <code>st = state(t=VariableSpec(),P=VariableSpec())</code> will return a functor of the form <code>st(t,p)</code> whereas <code>st = state(P=VariableSpec(),t=VariableSpec())</code> will create a functor with reversed order: <code>st(p,t)</code></p>
<h2><a id="user-content-dispatching-on-the-state-type-with-state_type" class="anchor" aria-hidden="true" href="#dispatching-on-the-state-type-with-state_type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dispatching on the state type with <code>state_type</code></h2>
<p>Good. we now have a struct designed to store thermodynamic properties. now we can create functions that dispatch on a specific combination of thermodynamic specifications, using the function <code>state_type(st::ThermodynamicState)</code>:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="julia&gt; st = state(t=373.15,ρ=5.0u&quot;mol/L&quot;);state_type(st)
(VolumeAmount{MOLAR,DENSITY}(), Temperature(), SingleComponent())        
"><pre lang="julia-repl"><code>julia&gt; st = state(t=373.15,ρ=5.0u"mol/L");state_type(st)
(VolumeAmount{MOLAR,DENSITY}(), Temperature(), SingleComponent())        
</code></pre></div>
<p>This tuple of thermodynamic specifications are an ordered representation of the specifications contained:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="st1 = state(t=373.15,ρ=5.0u&quot;mol/L&quot;)
st2 = state(ρ=5.0u&quot;mol/m^3&quot;,t=373.15,normalize_units=false)
state_type(s1) === state_type(s2) #true
"><pre lang="julia-repl"><code>st1 = state(t=373.15,ρ=5.0u"mol/L")
st2 = state(ρ=5.0u"mol/m^3",t=373.15,normalize_units=false)
state_type(s1) === state_type(s2) #true
</code></pre></div>
<p>Some abstract tuple types are saved on <code>ThermoState.QuickStates</code>. the tuple types exported are:</p>
<ul>
<li><code>SinglePT,MultiPT</code></li>
<li><code>SingleVT,MultiVT</code></li>
<li><code>SinglePV,MultiPV</code></li>
<li><code>SinglePS,MultiPS</code></li>
<li><code>SinglePH,MultiPH</code></li>
<li><code>SingleSatT,MultiSatT</code> (Two phase equilibrium)</li>
<li><code>SingleSatP,MultiSatP</code></li>
<li><code>SingleΦT,MultiΦT</code>  (vapor fraction, general)</li>
<li><code>SingleΦP,MultiΦP</code></li>
<li><code>SingleΦmT,MultiΦmT</code> (mass vapor fraction, or quality)</li>
<li><code>SingleΦmP,MultiΦmP</code></li>
<li><code>SingleΦnT,MultiΦnT</code>(molar vapor fraction)</li>
<li><code>SingleΦnP,MultiΦnP</code></li>
<li><code>SingleT,MultiT</code> (a state that has a temperature)</li>
</ul>
<h2><a id="user-content-exported-utilities" class="anchor" aria-hidden="true" href="#exported-utilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Exported utilities</h2>
<h2><a id="user-content-to_units" class="anchor" aria-hidden="true" href="#to_units"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>@to_units</code></h2>
<p>Sometimes, <code>Unitful</code> quantities are needed. by default (and convention) all property accessors return a number without units, in SI system. You can automatically prefix the correct unit to the accessor function adding the <code>@to_units</code> macro at the start of the expression</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="st = state(t=1.0u&quot;K&quot;,p=2.0u&quot;Pa&quot;)
t0 = temperature(FromState(),st) #returns 1.0
t1 = @to_units temperature(FromState(),st) #returns 1.0 K
t1 = @to_units temperature(FromState(),st)
"><pre>st <span class="pl-k">=</span> <span class="pl-c1">state</span>(t<span class="pl-k">=</span><span class="pl-c1">1.0</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>K<span class="pl-pds">"</span></span>,p<span class="pl-k">=</span><span class="pl-c1">2.0</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>Pa<span class="pl-pds">"</span></span>)
t0 <span class="pl-k">=</span> <span class="pl-c1">temperature</span>(<span class="pl-c1">FromState</span>(),st) <span class="pl-c"><span class="pl-c">#</span>returns 1.0</span>
t1 <span class="pl-k">=</span> <span class="pl-c1">@to_units</span> <span class="pl-c1">temperature</span>(<span class="pl-c1">FromState</span>(),st) <span class="pl-c"><span class="pl-c">#</span>returns 1.0 K</span>
t1 <span class="pl-k">=</span> <span class="pl-c1">@to_units</span> <span class="pl-c1">temperature</span>(<span class="pl-c1">FromState</span>(),st)</pre></div>
<h2><a id="user-content-spec_str" class="anchor" aria-hidden="true" href="#spec_str"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>@spec_str</code></h2>
<p>Calling <code>spec(;key = value,normalize_units=true)</code> is simple, but it has a runtime cost. on the other part, <code>spec(sp::AbstractSpec,value,normalize_units::Bool=true)</code> can be determined at compile time. A problem with this interface is that writing the correct type can be cumbersome, for example, for some molar numbers:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n0 = spec(MaterialCompounds{MOLAR,TOTAL_AMOUNT}(),[0.1,0.3]) #very long type declaration
"><pre>n0 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(<span class="pl-c1">MaterialCompounds</span><span class="pl-c1">{MOLAR,TOTAL_AMOUNT}</span>(),[<span class="pl-c1">0.1</span>,<span class="pl-c1">0.3</span>]) <span class="pl-c"><span class="pl-c">#</span>very long type declaration</span></pre></div>
<p>The <code>@spec_str</code> helps in this situation, creating the <code>AbstractSpec</code> type corresponding to the input keyword:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n1 = spec(spec&quot;n&quot;,[0.1,0.3]) #shorter
n0 == n1 #true
"><pre>n1 <span class="pl-k">=</span> <span class="pl-c1">spec</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">spec</span>"</span>n<span class="pl-pds">"</span></span>,[<span class="pl-c1">0.1</span>,<span class="pl-c1">0.3</span>]) <span class="pl-c"><span class="pl-c">#</span>shorter</span>
n0 <span class="pl-k">==</span> n1 <span class="pl-c"><span class="pl-c">#</span>true</span></pre></div>
<p>The statement <code>spec(spec"n",[0.1,0.3])</code> can be defined at compile time.</p>
<h3><a id="user-content-normalize_unitsval" class="anchor" aria-hidden="true" href="#normalize_unitsval"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>normalize_units(val)</code></h3>
<p>On normal numbers, it is the identity, but on numbers or vectors of <code>Unitful.Quantity</code>,it converts the unit to an equivalent SI unit and strips the unit information.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="x = 0.0u&quot;°C&quot;
normalize_units(x) #273.15
"><pre>x <span class="pl-k">=</span> <span class="pl-c1">0.0</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>
<span class="pl-c1">normalize_units</span>(x) <span class="pl-c"><span class="pl-c">#</span>273.15</span></pre></div>
<h3><a id="user-content-convert_unitfromtoval" class="anchor" aria-hidden="true" href="#convert_unitfromtoval"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>convert_unit(from,to,val)</code></h3>
<p>Converts an unit from the unit stored in <code>from</code> to the unit stored in <code>to</code>. when both units are equal, it justs returns <code>val</code>. if <code>val</code> itself is an <code>unit</code>, then it convert the from the unit in <code>val</code> to the unit in <code>to</code>.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="convert_unit(u&quot;Pa&quot;,u&quot;kPa&quot;,1000.0) #1.0
convert_unit(u&quot;Pa&quot;,u&quot;kPa&quot;,1u&quot;atm&quot;) #101.325
"><pre><span class="pl-c1">convert_unit</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>Pa<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>kPa<span class="pl-pds">"</span></span>,<span class="pl-c1">1000.0</span>) <span class="pl-c"><span class="pl-c">#</span>1.0</span>
<span class="pl-c1">convert_unit</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>Pa<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>kPa<span class="pl-pds">"</span></span>,<span class="pl-c1">1</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>atm<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span>101.325</span></pre></div>
<h3><a id="user-content-default_unitsval" class="anchor" aria-hidden="true" href="#default_unitsval"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>default_units(val)</code></h3>
<p>Returns the SI unit of a thermodynamic specification type or a function name corresponding to those types:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="#from a function
default_units(mol_density) #u&quot;mol/m^3&quot;

#from a thermodynamic specification type
default_units(Pressure()) #u&quot;Pa&quot;
"><pre><span class="pl-c"><span class="pl-c">#</span>from a function</span>
<span class="pl-c1">default_units</span>(mol_density) <span class="pl-c"><span class="pl-c">#</span>u"mol/m^3"</span>

<span class="pl-c"><span class="pl-c">#</span>from a thermodynamic specification type</span>
<span class="pl-c1">default_units</span>(<span class="pl-c1">Pressure</span>()) <span class="pl-c"><span class="pl-c">#</span>u"Pa"</span></pre></div>
<h2><a id="user-content-implementing-a-model-using-the-thermostate-interface" class="anchor" aria-hidden="true" href="#implementing-a-model-using-the-thermostate-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implementing a model using the <code>ThermoState</code> interface</h2>
<p>Using this package, we can implement a basic ideal gas model that only calculates the pressure, given a temperature and molar volume, using the relation <code>pvₙ=Rt</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using ThermoState, Unitful, 
using ThermoState.QuickStates #provides SingleVT for dispatch on state_type
import ThermoState: pressure #import all functions to overload, if you have a custom property, this is not necessary.

import ThermoState: molecular_weight #you can use your own name in your files, but it is recommended to use this to better interop between packages.

struct MyIdealGas
    mw::Float64
end
#t
molecular_weight(model::MyIdealGas) = model.mw

#your implementation of pressure, with v and t. 
#pass a state type to dispatch on the available properties.
function pressure_impl(mt::SingleVT,model::MyIdealGas,v,t)
    return 8.314*t/v
end

function pressure(model::MyIdealGas,st::ThermodynamicState,unit=u&quot;Pa&quot;)
return pressure(state_type(st),model,st,unit)
end

function pressure(mt::SingleVT,model::MyIdealGas,st::ThermodynamicState,unit)
    v = mol_volume(FromState(),st,u&quot;m^3/mol&quot;,mw)
    t = temperature(FromState(),st,u&quot;K&quot;) 
    val = pressure_impl(mt,model,v,t)
    return convert_unit(u&quot;Pa&quot;,unit,val)
end

a = state(mass = 3u&quot;kg&quot;,total_v = 30u&quot;m^3&quot;,t=30u&quot;°C&quot;)
model = MyIdealGas(18.01)
p = pressure(model,a)

"><pre><span class="pl-k">using</span> ThermoState, Unitful, 
<span class="pl-k">using</span> ThermoState<span class="pl-k">.</span>QuickStates <span class="pl-c"><span class="pl-c">#</span>provides SingleVT for dispatch on state_type</span>
<span class="pl-k">import</span> ThermoState<span class="pl-k">:</span> pressure <span class="pl-c"><span class="pl-c">#</span>import all functions to overload, if you have a custom property, this is not necessary.</span>

<span class="pl-k">import</span> ThermoState<span class="pl-k">:</span> molecular_weight <span class="pl-c"><span class="pl-c">#</span>you can use your own name in your files, but it is recommended to use this to better interop between packages.</span>

<span class="pl-k">struct</span> MyIdealGas
    mw<span class="pl-k">::</span><span class="pl-c1">Float64</span>
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span>t</span>
<span class="pl-en">molecular_weight</span>(model<span class="pl-k">::</span><span class="pl-c1">MyIdealGas</span>) <span class="pl-k">=</span> model<span class="pl-k">.</span>mw

<span class="pl-c"><span class="pl-c">#</span>your implementation of pressure, with v and t. </span>
<span class="pl-c"><span class="pl-c">#</span>pass a state type to dispatch on the available properties.</span>
<span class="pl-k">function</span> <span class="pl-en">pressure_impl</span>(mt<span class="pl-k">::</span><span class="pl-c1">SingleVT</span>,model<span class="pl-k">::</span><span class="pl-c1">MyIdealGas</span>,v,t)
    <span class="pl-k">return</span> <span class="pl-c1">8.314</span><span class="pl-k">*</span>t<span class="pl-k">/</span>v
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">pressure</span>(model<span class="pl-k">::</span><span class="pl-c1">MyIdealGas</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>Pa<span class="pl-pds">"</span></span>)
<span class="pl-k">return</span> <span class="pl-c1">pressure</span>(<span class="pl-c1">state_type</span>(st),model,st,unit)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">pressure</span>(mt<span class="pl-k">::</span><span class="pl-c1">SingleVT</span>,model<span class="pl-k">::</span><span class="pl-c1">MyIdealGas</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit)
    v <span class="pl-k">=</span> <span class="pl-c1">mol_volume</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3/mol<span class="pl-pds">"</span></span>,mw)
    t <span class="pl-k">=</span> <span class="pl-c1">temperature</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>K<span class="pl-pds">"</span></span>) 
    val <span class="pl-k">=</span> <span class="pl-c1">pressure_impl</span>(mt,model,v,t)
    <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>Pa<span class="pl-pds">"</span></span>,unit,val)
<span class="pl-k">end</span>

a <span class="pl-k">=</span> <span class="pl-c1">state</span>(mass <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>kg<span class="pl-pds">"</span></span>,total_v <span class="pl-k">=</span> <span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3<span class="pl-pds">"</span></span>,t<span class="pl-k">=</span><span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>)
model <span class="pl-k">=</span> <span class="pl-c1">MyIdealGas</span>(<span class="pl-c1">18.01</span>)
p <span class="pl-k">=</span> <span class="pl-c1">pressure</span>(model,a)
</pre></div>
<p>Using a variable state:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="tx = state(mass = 3u&quot;kg&quot;,total_v = 30u&quot;m^3&quot;,t=var) #one free variable
p = pressure(model,tx(30u&quot;°C&quot;))
p_list = map(t-&gt; pressure(model,tx(t)),273.0:373.0)
"><pre>tx <span class="pl-k">=</span> <span class="pl-c1">state</span>(mass <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>kg<span class="pl-pds">"</span></span>,total_v <span class="pl-k">=</span> <span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3<span class="pl-pds">"</span></span>,t<span class="pl-k">=</span>var) <span class="pl-c"><span class="pl-c">#</span>one free variable</span>
p <span class="pl-k">=</span> <span class="pl-c1">pressure</span>(model,<span class="pl-c1">tx</span>(<span class="pl-c1">30</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>°C<span class="pl-pds">"</span></span>))
p_list <span class="pl-k">=</span> <span class="pl-c1">map</span>(t<span class="pl-k">-&gt;</span> <span class="pl-c1">pressure</span>(model,<span class="pl-c1">tx</span>(t)),<span class="pl-c1">273.0</span><span class="pl-k">:</span><span class="pl-c1">373.0</span>)</pre></div>
<p>Here the actual function that does the work has the form <code>$property_impl(mt,model,args...)</code>, that accepts positional arguments of the form indicated by the result obtained by <code>state_type(st)</code>. in this example, it doesnt seem too useful, as there is only one posible implementation: <code>SingleVT</code>. However, this  helps when there is more than one posible pair of input to the function. For example, with this dispatch, you can do this:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
struct WaterModel end

...

#Enthalpy from  Pressure - Temperature 
function mol_enthalpy_impl(::SinglePT,::WaterModel,p,t)
...
end

#Enthalpy from  Volume - Temperature 
function mol_enthalpy_impl(::SingleVT,::WaterModel,v,t)
...
end

#Enthalpy from  Entropy - Temperature 
function mol_enthalpy_impl(::SingleST,::WaterModel,s,t)
...
end


#Enthalpy from  Pressure - Entropy 
function mol_enthalpy_impl(::SinglePS,::WaterModel,p,s)
...
end

#ThermoState interface, only needed once
function mol_enthalpy(model::WaterModel,st::ThermodynamicState,unit=&quot;J/mol&quot;)
  return mol_enthalpy(state_type(st),model,st,unit)
end

#dispatch on the apropiate implementation, extracting the args from st
function mol_enthalpy(mt::SingleVT,model::WaterModel,st::ThermodynamicState,unit)
    v = mol_volume(FromState(),st,u&quot;m^3/mol&quot;,mw)
    t = temperature(FromState(),st,u&quot;K&quot;) 
    val = mol_enthalpy(mt,model,v,t)
    return convert_unit(u&quot;J/mol&quot;,unit,val)
end

"><pre><span class="pl-k">struct</span> WaterModel <span class="pl-k">end</span>

<span class="pl-k">...</span>

<span class="pl-c"><span class="pl-c">#</span>Enthalpy from  Pressure - Temperature </span>
<span class="pl-k">function</span> <span class="pl-en">mol_enthalpy_impl</span>(<span class="pl-k">::</span><span class="pl-c1">SinglePT</span>,<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,p,t)
<span class="pl-k">...</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span>Enthalpy from  Volume - Temperature </span>
<span class="pl-k">function</span> <span class="pl-en">mol_enthalpy_impl</span>(<span class="pl-k">::</span><span class="pl-c1">SingleVT</span>,<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,v,t)
<span class="pl-k">...</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span>Enthalpy from  Entropy - Temperature </span>
<span class="pl-k">function</span> <span class="pl-en">mol_enthalpy_impl</span>(<span class="pl-k">::</span><span class="pl-c1">SingleST</span>,<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,s,t)
<span class="pl-k">...</span>
<span class="pl-k">end</span>


<span class="pl-c"><span class="pl-c">#</span>Enthalpy from  Pressure - Entropy </span>
<span class="pl-k">function</span> <span class="pl-en">mol_enthalpy_impl</span>(<span class="pl-k">::</span><span class="pl-c1">SinglePS</span>,<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,p,s)
<span class="pl-k">...</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span>ThermoState interface, only needed once</span>
<span class="pl-k">function</span> <span class="pl-en">mol_enthalpy</span>(model<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>J/mol<span class="pl-pds">"</span></span>)
  <span class="pl-k">return</span> <span class="pl-c1">mol_enthalpy</span>(<span class="pl-c1">state_type</span>(st),model,st,unit)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span>dispatch on the apropiate implementation, extracting the args from st</span>
<span class="pl-k">function</span> <span class="pl-en">mol_enthalpy</span>(mt<span class="pl-k">::</span><span class="pl-c1">SingleVT</span>,model<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit)
    v <span class="pl-k">=</span> <span class="pl-c1">mol_volume</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3/mol<span class="pl-pds">"</span></span>,mw)
    t <span class="pl-k">=</span> <span class="pl-c1">temperature</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>K<span class="pl-pds">"</span></span>) 
    val <span class="pl-k">=</span> <span class="pl-c1">mol_enthalpy</span>(mt,model,v,t)
    <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/mol<span class="pl-pds">"</span></span>,unit,val)
<span class="pl-k">end</span>
</pre></div>
<p>You can also provide automatic conversion to mass an total units, defining the following functions:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
function mass_enthalpy(model::WaterModel,st::ThermodynamicState,unit=&quot;J/kg&quot;)
  mol_h = mol_enthalpy(model,st) #we dont care about state_type, just the result
  #to obtain mass_h, we need to divide by kg/mol
  kg_per_mol = molar_mass(FromState(),st,u&quot;kg/mol&quot;,molecular_weight(model)) #we can do this or overload molar_mass(WaterModel,st)

  mass_h = mol_h/kg_per_mol
  return convert_unit(u&quot;J/kg&quot;,unit,mass_h)
end

function total_enthalpy(model::WaterModel,st::ThermodynamicState,unit=&quot;J&quot;)
  mol_h = mol_enthalpy(model,st) 
  #to obtain total_h, we need to divide by moles
  mol = moles(FromState(),st,u&quot;mol&quot;,molecular_weight(model)) #we can do this or overload moles(WaterModel,st)
  total_h = mol_h*mol
  return convert_unit(u&quot;J/kg&quot;,unit,total_h)
end
"><pre><span class="pl-k">function</span> <span class="pl-en">mass_enthalpy</span>(model<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>J/kg<span class="pl-pds">"</span></span>)
  mol_h <span class="pl-k">=</span> <span class="pl-c1">mol_enthalpy</span>(model,st) <span class="pl-c"><span class="pl-c">#</span>we dont care about state_type, just the result</span>
  <span class="pl-c"><span class="pl-c">#</span>to obtain mass_h, we need to divide by kg/mol</span>
  kg_per_mol <span class="pl-k">=</span> <span class="pl-c1">molar_mass</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>kg/mol<span class="pl-pds">"</span></span>,<span class="pl-c1">molecular_weight</span>(model)) <span class="pl-c"><span class="pl-c">#</span>we can do this or overload molar_mass(WaterModel,st)</span>

  mass_h <span class="pl-k">=</span> mol_h<span class="pl-k">/</span>kg_per_mol
  <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/kg<span class="pl-pds">"</span></span>,unit,mass_h)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">total_enthalpy</span>(model<span class="pl-k">::</span><span class="pl-c1">WaterModel</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>J<span class="pl-pds">"</span></span>)
  mol_h <span class="pl-k">=</span> <span class="pl-c1">mol_enthalpy</span>(model,st) 
  <span class="pl-c"><span class="pl-c">#</span>to obtain total_h, we need to divide by moles</span>
  mol <span class="pl-k">=</span> <span class="pl-c1">moles</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>mol<span class="pl-pds">"</span></span>,<span class="pl-c1">molecular_weight</span>(model)) <span class="pl-c"><span class="pl-c">#</span>we can do this or overload moles(WaterModel,st)</span>
  total_h <span class="pl-k">=</span> mol_h<span class="pl-k">*</span>mol
  <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/kg<span class="pl-pds">"</span></span>,unit,total_h)
<span class="pl-k">end</span></pre></div>
<p>As seen here, this is an easy, but repetitive and boring task. Thankfully, julia metaprogramming helps a lot here. if you have a lot of properties, you can evaluate all those functions at once this <code>@eval</code>. This is an actual piece of code used on WaterIF97.jl (not published yet). the implementation functions where defined before hand, whereas the <code>ThermoState</code> interface is mostly defined in this <code>@eval</code> loop</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="for op in [:helmholtz, :gibbs, :internal_energy, :enthalpy,:cp,:cv,:volume,:entropy]
        mol_op_impl = Symbol(:mol_,op,:_impl)
        mass_op_impl = Symbol(:mass_,op,:_impl)
        total_op_impl = Symbol(:total_,op,:_impl)
        mol_op = Symbol(:mol_,op)
        mass_op = Symbol(:mass_,op)
        total_op = Symbol(:total_,op)
        if op == :volume
            _unit = u&quot;m^3/kg&quot;
            mol_unit = u&quot;m^3/mol&quot;
            total_unit = u&quot;m^3&quot;

        elseif op in (:cv,:cp,:entropy)
            _unit = u&quot;J/(kg*K)&quot;
            mol_unit = u&quot;J/(mol*K)&quot;
            total_unit = u&quot;J/(K)&quot;
        else
            _unit = u&quot;J/(kg)&quot;
            mol_unit = u&quot;J/(mol)&quot;
            total_unit = u&quot;J&quot;
        end
     
        @eval begin

            #dispatch basic mass impl to the correct region, P,T
            function $mass_op_impl(mt::SinglePT,model::IndustrialWater,p,t)
                id = region_id(mt,model,p,t)
                return $mass_op_impl(mt,IF97Region{id}(),p,t)
            end


            function $mass_op(model::IndustrialWater,st::ThermodynamicState,unit=$_unit)
                return $mass_op(state_type(st),model,st,unit)
            end
            # P T impl
            function $mass_op(mt::SinglePT,model::IndustrialWater,st::ThermodynamicState,unit)
                p = pressure(FromState(),st)
                t = temperature(FromState(),st)
                res = $mass_op_impl(mt,model,p,t)
                return convert_unit($_unit,unit,res)
            end

            #mol op
            function $mol_op(model::IndustrialWater,st::ThermodynamicState,unit=$mol_unit)
                prod = molar_mass(FromState(),st,u&quot;kg/mol&quot;,molecular_weight(model))
                res =  $mass_op(state_type(st),model,st,$_unit)*prod
                return convert_unit($mol_unit,unit,res)
            end 
        end

        if !(op in (:cv,:cp))
            #total ops, cv and cp dont have total operations
            @eval begin
                function $total_op(model::IndustrialWater,st::ThermodynamicState,unit=$total_unit)
                    prod = mass(FromState(),st,u&quot;kg&quot;,molecular_weight(model))
                    res =  $mass_op(mt,model,st,unit)*prod
                    return convert_unit($total_unit,unit,res)
                end
            end
        end

    if op != :enthalpy
        @eval begin
            #if not enthalpy, define PH impl
            function $mass_op_impl(mt::SinglePH,model::IndustrialWater,p,h)
                id = region_id(mt,model,p,h)
                return $mass_op_impl(mt,IF97Region{id}(),p,h)
            end

            function $mass_op(mt::SinglePH,model::IndustrialWater,st::ThermodynamicState,unit)
                p = pressure(FromState(),st)
                h = mass_enthalpy(FromState(),st)
                res = $mass_op_impl(mt,model,p,h)
                return convert_unit($_unit,unit,res)
            end
        end   
    end

    if op != :entropy
        @eval begin
            #if not entropy, define PS impl
            function $mass_op_impl(mt::SinglePS,model::IndustrialWater,p,s)
                id = region_id(mt,model,p,h)
                t = temperature_impl(mt,IF97Region{id}(),p,s) #transform to SinglePT
                _mt = QuickStates.pt()
                return $mass_op_impl(_mt,model,p,t)
            end

            function $mass_op(mt::SinglePS,model::IndustrialWater,st::ThermodynamicState,unit)
                p = pressure(FromState(),st)
                s = mass_entropy(FromState(),st)
                res = $mass_op_impl(mt,model,p,s)
                return convert_unit($_unit,unit,res)
            end
        end   
    end
end
"><pre><span class="pl-k">for</span> op <span class="pl-k">in</span> [<span class="pl-c1">:helmholtz</span>, <span class="pl-c1">:gibbs</span>, <span class="pl-c1">:internal_energy</span>, <span class="pl-c1">:enthalpy</span>,<span class="pl-c1">:cp</span>,<span class="pl-c1">:cv</span>,<span class="pl-c1">:volume</span>,<span class="pl-c1">:entropy</span>]
        mol_op_impl <span class="pl-k">=</span> <span class="pl-c1">Symbol</span>(<span class="pl-c1">:mol_</span>,op,<span class="pl-c1">:_impl</span>)
        mass_op_impl <span class="pl-k">=</span> <span class="pl-c1">Symbol</span>(<span class="pl-c1">:mass_</span>,op,<span class="pl-c1">:_impl</span>)
        total_op_impl <span class="pl-k">=</span> <span class="pl-c1">Symbol</span>(<span class="pl-c1">:total_</span>,op,<span class="pl-c1">:_impl</span>)
        mol_op <span class="pl-k">=</span> <span class="pl-c1">Symbol</span>(<span class="pl-c1">:mol_</span>,op)
        mass_op <span class="pl-k">=</span> <span class="pl-c1">Symbol</span>(<span class="pl-c1">:mass_</span>,op)
        total_op <span class="pl-k">=</span> <span class="pl-c1">Symbol</span>(<span class="pl-c1">:total_</span>,op)
        <span class="pl-k">if</span> op <span class="pl-k">==</span> <span class="pl-c1">:volume</span>
            _unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3/kg<span class="pl-pds">"</span></span>
            mol_unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3/mol<span class="pl-pds">"</span></span>
            total_unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>m^3<span class="pl-pds">"</span></span>

        <span class="pl-k">elseif</span> op <span class="pl-k">in</span> (<span class="pl-c1">:cv</span>,<span class="pl-c1">:cp</span>,<span class="pl-c1">:entropy</span>)
            _unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/(kg*K)<span class="pl-pds">"</span></span>
            mol_unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/(mol*K)<span class="pl-pds">"</span></span>
            total_unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/(K)<span class="pl-pds">"</span></span>
        <span class="pl-k">else</span>
            _unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/(kg)<span class="pl-pds">"</span></span>
            mol_unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J/(mol)<span class="pl-pds">"</span></span>
            total_unit <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>J<span class="pl-pds">"</span></span>
        <span class="pl-k">end</span>
     
        <span class="pl-c1">@eval</span> <span class="pl-k">begin</span>

            <span class="pl-c"><span class="pl-c">#</span>dispatch basic mass impl to the correct region, P,T</span>
            <span class="pl-k">function</span> <span class="pl-en">$mass_op_impl</span>(mt<span class="pl-k">::</span><span class="pl-c1">SinglePT</span>,model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,p,t)
                id <span class="pl-k">=</span> <span class="pl-c1">region_id</span>(mt,model,p,t)
                <span class="pl-k">return</span> <span class="pl-k">$</span><span class="pl-c1">mass_op_impl</span>(mt,<span class="pl-c1">IF97Region</span><span class="pl-c1">{id}</span>(),p,t)
            <span class="pl-k">end</span>


            <span class="pl-k">function</span> <span class="pl-en">$mass_op</span>(model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">=</span><span class="pl-k">$</span>_unit)
                <span class="pl-k">return</span> <span class="pl-k">$</span><span class="pl-c1">mass_op</span>(<span class="pl-c1">state_type</span>(st),model,st,unit)
            <span class="pl-k">end</span>
            <span class="pl-c"><span class="pl-c">#</span> P T impl</span>
            <span class="pl-k">function</span> <span class="pl-en">$mass_op</span>(mt<span class="pl-k">::</span><span class="pl-c1">SinglePT</span>,model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit)
                p <span class="pl-k">=</span> <span class="pl-c1">pressure</span>(<span class="pl-c1">FromState</span>(),st)
                t <span class="pl-k">=</span> <span class="pl-c1">temperature</span>(<span class="pl-c1">FromState</span>(),st)
                res <span class="pl-k">=</span> <span class="pl-k">$</span><span class="pl-c1">mass_op_impl</span>(mt,model,p,t)
                <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-k">$</span>_unit,unit,res)
            <span class="pl-k">end</span>

            <span class="pl-c"><span class="pl-c">#</span>mol op</span>
            <span class="pl-k">function</span> <span class="pl-en">$mol_op</span>(model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">=</span><span class="pl-k">$</span>mol_unit)
                prod <span class="pl-k">=</span> <span class="pl-c1">molar_mass</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>kg/mol<span class="pl-pds">"</span></span>,<span class="pl-c1">molecular_weight</span>(model))
                res <span class="pl-k">=</span>  <span class="pl-k">$</span><span class="pl-c1">mass_op</span>(<span class="pl-c1">state_type</span>(st),model,st,<span class="pl-k">$</span>_unit)<span class="pl-k">*</span>prod
                <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-k">$</span>mol_unit,unit,res)
            <span class="pl-k">end</span> 
        <span class="pl-k">end</span>

        <span class="pl-k">if</span> <span class="pl-k">!</span>(op <span class="pl-k">in</span> (<span class="pl-c1">:cv</span>,<span class="pl-c1">:cp</span>))
            <span class="pl-c"><span class="pl-c">#</span>total ops, cv and cp dont have total operations</span>
            <span class="pl-c1">@eval</span> <span class="pl-k">begin</span>
                <span class="pl-k">function</span> <span class="pl-en">$total_op</span>(model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit<span class="pl-k">=</span><span class="pl-k">$</span>total_unit)
                    prod <span class="pl-k">=</span> <span class="pl-c1">mass</span>(<span class="pl-c1">FromState</span>(),st,<span class="pl-s"><span class="pl-pds"><span class="pl-c1">u</span>"</span>kg<span class="pl-pds">"</span></span>,<span class="pl-c1">molecular_weight</span>(model))
                    res <span class="pl-k">=</span>  <span class="pl-k">$</span><span class="pl-c1">mass_op</span>(mt,model,st,unit)<span class="pl-k">*</span>prod
                    <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-k">$</span>total_unit,unit,res)
                <span class="pl-k">end</span>
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>

    <span class="pl-k">if</span> op <span class="pl-k">!=</span> <span class="pl-c1">:enthalpy</span>
        <span class="pl-c1">@eval</span> <span class="pl-k">begin</span>
            <span class="pl-c"><span class="pl-c">#</span>if not enthalpy, define PH impl</span>
            <span class="pl-k">function</span> <span class="pl-en">$mass_op_impl</span>(mt<span class="pl-k">::</span><span class="pl-c1">SinglePH</span>,model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,p,h)
                id <span class="pl-k">=</span> <span class="pl-c1">region_id</span>(mt,model,p,h)
                <span class="pl-k">return</span> <span class="pl-k">$</span><span class="pl-c1">mass_op_impl</span>(mt,<span class="pl-c1">IF97Region</span><span class="pl-c1">{id}</span>(),p,h)
            <span class="pl-k">end</span>

            <span class="pl-k">function</span> <span class="pl-en">$mass_op</span>(mt<span class="pl-k">::</span><span class="pl-c1">SinglePH</span>,model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit)
                p <span class="pl-k">=</span> <span class="pl-c1">pressure</span>(<span class="pl-c1">FromState</span>(),st)
                h <span class="pl-k">=</span> <span class="pl-c1">mass_enthalpy</span>(<span class="pl-c1">FromState</span>(),st)
                res <span class="pl-k">=</span> <span class="pl-k">$</span><span class="pl-c1">mass_op_impl</span>(mt,model,p,h)
                <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-k">$</span>_unit,unit,res)
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>   
    <span class="pl-k">end</span>

    <span class="pl-k">if</span> op <span class="pl-k">!=</span> <span class="pl-c1">:entropy</span>
        <span class="pl-c1">@eval</span> <span class="pl-k">begin</span>
            <span class="pl-c"><span class="pl-c">#</span>if not entropy, define PS impl</span>
            <span class="pl-k">function</span> <span class="pl-en">$mass_op_impl</span>(mt<span class="pl-k">::</span><span class="pl-c1">SinglePS</span>,model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,p,s)
                id <span class="pl-k">=</span> <span class="pl-c1">region_id</span>(mt,model,p,h)
                t <span class="pl-k">=</span> <span class="pl-c1">temperature_impl</span>(mt,<span class="pl-c1">IF97Region</span><span class="pl-c1">{id}</span>(),p,s) <span class="pl-c"><span class="pl-c">#</span>transform to SinglePT</span>
                _mt <span class="pl-k">=</span> QuickStates<span class="pl-k">.</span><span class="pl-c1">pt</span>()
                <span class="pl-k">return</span> <span class="pl-k">$</span><span class="pl-c1">mass_op_impl</span>(_mt,model,p,t)
            <span class="pl-k">end</span>

            <span class="pl-k">function</span> <span class="pl-en">$mass_op</span>(mt<span class="pl-k">::</span><span class="pl-c1">SinglePS</span>,model<span class="pl-k">::</span><span class="pl-c1">IndustrialWater</span>,st<span class="pl-k">::</span><span class="pl-c1">ThermodynamicState</span>,unit)
                p <span class="pl-k">=</span> <span class="pl-c1">pressure</span>(<span class="pl-c1">FromState</span>(),st)
                s <span class="pl-k">=</span> <span class="pl-c1">mass_entropy</span>(<span class="pl-c1">FromState</span>(),st)
                res <span class="pl-k">=</span> <span class="pl-k">$</span><span class="pl-c1">mass_op_impl</span>(mt,model,p,s)
                <span class="pl-k">return</span> <span class="pl-c1">convert_unit</span>(<span class="pl-k">$</span>_unit,unit,res)
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>   
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p>With this loop, we defined at 22 property accessor functions, in molar, mass an total units, with 3 implementations each (except enthalpy and entropy, with 2 implementations).</p>
</article></div>