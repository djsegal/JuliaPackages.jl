<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-the-julia-devito-inversion-framework-judi" class="anchor" aria-hidden="true" href="#the-julia-devito-inversion-framework-judi"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The Julia Devito Inversion framework (JUDI)</h1>
<table>
<thead>
<tr>
<th align="center"><strong>Documentation</strong></th>
<th align="center"><strong>Build Status</strong></th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://slimgroup.github.io/JUDI.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/1a6ff99d9301a7dc45fd13351daa209ddbeaa6961383467d763da7904e236bea/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e7376673f7374796c653d706c6173746963" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg?style=plastic" style="max-width: 100%;"></a> <a href="https://slimgroup.github.io/JUDI.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></td>
<td align="center"><a href="https://github.com/slimgroup/JUDI.jl/actions?query=workflow%3ACI-tests"><img src="https://github.com/slimgroup/JUDI.jl/workflows/CI-tests/badge.svg?style=plastic" alt="" style="max-width: 100%;"></a> <a href="https://codecov.io/gh/slimgroup/JUDI.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/0fd305b1817388299205ee26cd1cf6072cb3d8645935207b2d738e46f9af51c6/68747470733a2f2f636f6465636f762e696f2f67682f736c696d67726f75702f4a5544492e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f7374796c653d706c6173746963" alt="" data-canonical-src="https://codecov.io/gh/slimgroup/JUDI.jl/branch/master/graph/badge.svg?style=plastic" style="max-width: 100%;"></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg?style=plastic" alt="" style="max-width: 100%;"></a></td>
<td align="center"><a href="LICENSE.md"><img src="https://camo.githubusercontent.com/b5e097cd18f023b1711d03ddd05b648b838bac983c1c79081b5220387bdb72cc/687474703a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d627269676874677265656e2e7376673f7374796c653d666c61743f7374796c653d706c6173746963" alt="" data-canonical-src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat?style=plastic" style="max-width: 100%;"></a> <a href="https://doi.org/10.5281/zenodo.3878711" rel="nofollow"><img src="https://camo.githubusercontent.com/2b4d614ca35b5d138734b6f9248ac3cd3e80d9996ee22471d942a4c51af978d4/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f444f492f31302e353238312f7a656e6f646f2e333837383731312e7376673f7374796c653d706c6173746963" alt="" data-canonical-src="https://zenodo.org/badge/DOI/10.5281/zenodo.3878711.svg?style=plastic" style="max-width: 100%;"></a> <a href="https://hub.docker.com/r/mloubout/judi" rel="nofollow"><img src="https://camo.githubusercontent.com/ea13babf821cb11939cf01685377b375e67077300ec6ad4f252f3eec09adacb5/68747470733a2f2f696d672e736869656c64732e696f2f646f636b65722f762f6d6c6f75626f75742f6a7564693f636f6c6f723d626c756576696f6c6574266c6162656c3d646f636b657226736f72743d73656d766572" alt="" data-canonical-src="https://img.shields.io/docker/v/mloubout/judi?color=blueviolet&amp;label=docker&amp;sort=semver" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table>
<h2 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h2>
<p dir="auto"><a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> is a framework for large-scale seismic modeling and inversion and is designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. The focus of the package lies on seismic modeling as well as PDE-constrained optimization such as full-waveform inversion (FWI) and imaging (LS-RTM). Wave equations in <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> are solved with <a href="https://github.com/devitocodes/devito">Devito</a>, a Python domain-specific language for automated finite-difference (FD) computations. JUDI's modeling operators can also be used as layers in (convolutional) neural networks to implement physics-augmented deep learning algorithms thanks to its implementation of <a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules</a>'s <code>rrule</code> for the linear operators representing the discre wave equation.</p>
<h2 dir="auto"><a id="user-content-interact-and-contribute" class="anchor" aria-hidden="true" href="#interact-and-contribute"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interact and contribute</h2>
<p dir="auto">We gladly welcome and encourage contributions from the community to improve our software and its usability. Feel free to:</p>
<ul dir="auto">
<li>Open <a href="https://github.com/slimgroup/JUDI.jl/issues">issues</a> for bugs</li>
<li>Start <a href="https://github.com/slimgroup/JUDI.jl/discussions">discussions</a> to interact with the developer and ask any questions</li>
<li>Open <a href="https://github.com/slimgroup/JUDI.jl/pulls">PR</a> for bug fixes and improvements</li>
</ul>
<h2 dir="auto"><a id="user-content-faq" class="anchor" aria-hidden="true" href="#faq"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FAQ</h2>
<p dir="auto">You can find an FAQ with answers to issues at <a href="https://github.com/slimgroup/JUDI.jl/wiki/FAQ">FAQ</a></p>
<h2 dir="auto"><a id="user-content-installation-and-prerequisites" class="anchor" aria-hidden="true" href="#installation-and-prerequisites"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation and prerequisites</h2>
<p dir="auto">You can find installation instructions in our Wiki at <a href="https://github.com/slimgroup/JUDI.jl/wiki/Installation">Installation</a></p>
<h2 dir="auto"><a id="user-content-gpu" class="anchor" aria-hidden="true" href="#gpu"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GPU</h2>
<p dir="auto"><a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> supports the computation of the wave equation on GPU via <a href="https://www.devitoproject.org" rel="nofollow">Devito</a>'s GPU offloading support.</p>
<p dir="auto"><strong>NOTE</strong>: Only the wave equation part will be computed on GPU, the Julia arrays will still be CPU arrays and <code>CUDA.jl</code> is not supported.</p>
<h3 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h3>
<p dir="auto">To enable gpu support in JUDI, you will need to install one of <a href="https://www.devitoproject.org" rel="nofollow">Devito</a>'s supported offloading compilers. We strongly recommend checking the <a href="https://github.com/devitocodes/devito/wiki">Wiki</a> for installation steps and to reach out to the Devito community for GPU compiler related issues.</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> <code>nvc/pgcc</code>. This is recommended and the simplest installation. You can install the compiler following Nvidia's installation instruction at <a href="https://developer.nvidia.com/hpc-sdk" rel="nofollow">HPC-sdk</a></li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> <code>aompcc</code>. This is the AMD compiler that is necessary for running on AMD GPUs. This installation is not tested with <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> and we recommend to reach out to Devito's team for installation guidelines.</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> <code>openmp5/clang</code>. This installation requires the compilation from source <code>openmp</code>, <code>clang</code> and <code>llvm</code> to install the latest version of <code>openmp5</code> enabling gpu offloading. You can find instructions on this installation in Devito's <a href="https://github.com/devitocodes/devito/wiki">Wiki</a></li>
</ul>
<h3 dir="auto"><a id="user-content-setup" class="anchor" aria-hidden="true" href="#setup"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Setup</h3>
<p dir="auto">The only required setup for GPU support are the environment variables for <a href="https://github.com/devitocodes/devito">Devito</a>. For the currently supported <code>nvc+openacc</code> setup these are:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="export DEVITO_LANGUAGE=openacc
export DEVITO_ARCH=nvc
export DEVITO_PLATFORM=nvidiaX"><pre class="notranslate"><code>export DEVITO_LANGUAGE=openacc
export DEVITO_ARCH=nvc
export DEVITO_PLATFORM=nvidiaX
</code></pre></div>
<h2 dir="auto"><a id="user-content-running-with-docker" class="anchor" aria-hidden="true" href="#running-with-docker"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Running with Docker</h2>
<p dir="auto">If you do not want to install JUDI, you can run <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> as a <a href="https://hub.docker.com/repository/docker/mloubout/judi" rel="nofollow">docker image</a>. The first possibility is to run the docker container as a Jupyter notebook. <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> provides two docker images for the latest <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> release for Julia versions <code>1.6</code> (LTS) and <code>1.7</code> (latest stable version). The images names are <code>mloubout/judi:JVER-latest</code> where <code>JVER</code> is the Julia version. This docker images contain pre-installed compilers for CPUs (gcc-10) and Nvidia GPUs (nvc) via the nvidia HPC sdk. The environment is automatically set for <a href="https://github.com/devitocodes/devito">Devito</a> based on the hardware available.</p>
<p dir="auto"><strong>Note</strong>: If you wish to use your gpu, you will need to install <a href="https://docs.nvidia.com/ai-enterprise/deployment-guide/dg-docker.html" rel="nofollow">nvidia-docker</a> and run <code>docker run --gpus all</code> in order to make the GPUs available at runtime from within the image.</p>
<p dir="auto">To run <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> via docker execute the following command in your terminal:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="docker run -p 8888:8888 mloubout/judi:1.7-latest"><pre>docker run -p 8888:8888 mloubout/judi:1.7-latest</pre></div>
<p dir="auto">This command downloads the image and launches a container. You will see a link that you can copy-paste to your browser to access the notebooks. Alternatively, you can run a bash session, in which you can start a regular interactive Julia session and run the example scripts. Download/start the container as a bash session with:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="docker run -it mloubout/judi:1.7-latest /bin/bash"><pre>docker run -it mloubout/judi:1.7-latest /bin/bash</pre></div>
<p dir="auto">Inside the container, all examples are located in the directory <code>/app/judi/examples/scripts</code>.</p>
<p dir="auto"><strong>Previous versions</strong>: As of version <code>v2.6.7</code> of JUDI, we also ship version-tagged images as <code>mloubout/judi:JVER-ver</code> where <code>ver</code> is the version of <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> wanted, for example the current <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> version with Julia 1.7 is <code>mloubout/judi:1.7-v2.6.7</code></p>
<p dir="auto"><strong>Development version</strong>: Additionally, we provide two images corresponding to the latest development version of <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> (latest state of the master branch). These images are called <code>mloubout/judi:JVER-dev</code> and can be used in a similar way.</p>
<h2 dir="auto"><a id="user-content-testing" class="anchor" aria-hidden="true" href="#testing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Testing</h2>
<p dir="auto">A complete test suite is included with <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> and is tested via GitHub Actions. You can also run the test locally
via:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="    Julia --project -e 'using Pkg;Pkg.test(coverage=false)'"><pre>    Julia <span class="pl-k">--</span>project <span class="pl-k">-</span>e <span class="pl-s"><span class="pl-pds">'</span>using Pkg;Pkg.test(coverage=false)<span class="pl-pds">'</span></span></pre></div>
<p dir="auto">By default, only the <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> base API will be tested. However, the testing suite supports other modes controlled via the environment variable <code>GROUP</code> such as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="	GROUP=JUDI Julia --project -e 'using Pkg;Pkg.test(coverage=false)'"><pre>	GROUP<span class="pl-k">=</span>JUDI Julia <span class="pl-k">--</span>project <span class="pl-k">-</span>e <span class="pl-s"><span class="pl-pds">'</span>using Pkg;Pkg.test(coverage=false)<span class="pl-pds">'</span></span></pre></div>
<p dir="auto">The supported modes are:</p>
<ul dir="auto">
<li>JUDI : Only the base API (linear operators, vectors, ...)</li>
<li>BASICS: Generic modeling and inversion tests such as out of core behavior</li>
<li>ISO_OP : Isotropic acoustic operators</li>
<li>ISO_OP_FS : Isotropic acoustic operators with free surface</li>
<li>TTI_OP : Transverse tilted isotropic operators</li>
<li>TTI_OP_FS : Transverse tilted isotropic operators with free surface</li>
<li>filename : you can also provide just a filename (i.e <code>GROUP=test_judiVector.jl</code>) and only this one test file will be run. Single files with TTI or free surface are not currently supported as it relies on <code>Base.ARGS</code> for the setup.</li>
</ul>
<h2 dir="auto"><a id="user-content-configure-compiler-and-openmp" class="anchor" aria-hidden="true" href="#configure-compiler-and-openmp"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Configure compiler and OpenMP</h2>
<p dir="auto">Devito uses just-in-time compilation for the underlying wave equation solves. The default compiler is intel, but can be changed to any other specified compiler such as <code>gnu</code>. Either run the following command from the command line or add it to your ~/.bashrc file:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="export DEVITO_ARCH=gnu"><pre><span class="pl-k">export</span> DEVITO_ARCH=gnu</pre></div>
<p dir="auto">Devito uses shared memory OpenMP parallelism for solving PDEs. OpenMP is disabled by default, but you can enable OpenMP and define the number of threads (per PDE solve) as follows:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="export DEVITO_LANGUAGE=openmp  # Enable OpenMP. 
export OMP_NUM_THREADS=4    # Number of OpenMP threads"><pre><span class="pl-k">export</span> DEVITO_LANGUAGE=openmp  <span class="pl-c"><span class="pl-c">#</span> Enable OpenMP. </span>
<span class="pl-k">export</span> OMP_NUM_THREADS=4    <span class="pl-c"><span class="pl-c">#</span> Number of OpenMP threads</span></pre></div>
<h2 dir="auto"><a id="user-content-full-waveform-inversion" class="anchor" aria-hidden="true" href="#full-waveform-inversion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Full-waveform inversion</h2>
<p dir="auto"><a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> is designed to let you set up objective functions that can be passed to standard packages for (gradient-based) optimization. The following example demonstrates how to perform FWI on the 2D Overthrust model using a spectral projected gradient algorithm from the minConf library, which is included in the software. A small test dataset (62 MB) and the model can be downloaded from this FTP server:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/WaveformInversion.jl/2DFWI/overthrust_2D.segy`)
run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/WaveformInversion.jl/2DFWI/overthrust_2D_initial_model.h5`)"><pre><span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>wget ftp://slim.gatech.edu/data/SoftwareRelease/WaveformInversion.jl/2DFWI/overthrust_2D.segy<span class="pl-pds">`</span></span>)
<span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>wget ftp://slim.gatech.edu/data/SoftwareRelease/WaveformInversion.jl/2DFWI/overthrust_2D_initial_model.h5<span class="pl-pds">`</span></span>)</pre></div>
<p dir="auto">The first step is to load the velocity model and the observed data into Julia, as well as setting up bound constraints for the inversion, which prevent too high or low velocities in the final result. Furthermore, we define an 8 Hertz Ricker wavelet as the source function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PyPlot, HDF5, SegyIO, JUDI, SlimOptim, Statistics, Random

# Load starting model
n, d, o, m0 = read(h5open(&quot;overthrust_2D_initial_model.h5&quot;, &quot;r&quot;), &quot;n&quot;, &quot;d&quot;, &quot;o&quot;, &quot;m0&quot;)
model0 = Model((n[1], n[2]), (d[1], d[2]), (o[1], o[2]), m0)	# need n, d, o as tuples and m0 as array

# Bound constraints
vmin = ones(Float32, model0.n) .+ 0.3f0
vmax = ones(Float32, model0.n) .+ 5.5f0
mmin = vec((1f0 ./ vmax).^2)	# convert to slowness squared [s^2/km^2]
mmax = vec((1f0 ./ vmin).^2)

# Load segy data
block = segy_read(&quot;overthrust_2D.segy&quot;)
dobs = judiVector(block)

# Set up wavelet
src_geometry = Geometry(block; key=&quot;source&quot;, segy_depth_key=&quot;SourceDepth&quot;)	# read source position geometry
wavelet = ricker_wavelet(src_geometry.t[1], src_geometry.dt[1], 0.008f0)	# 8 Hz wavelet
q = judiVector(src_geometry, wavelet)
"><pre><span class="pl-k">using</span> PyPlot, HDF5, SegyIO, JUDI, SlimOptim, Statistics, Random

<span class="pl-c"><span class="pl-c">#</span> Load starting model</span>
n, d, o, m0 <span class="pl-k">=</span> <span class="pl-c1">read</span>(<span class="pl-c1">h5open</span>(<span class="pl-s"><span class="pl-pds">"</span>overthrust_2D_initial_model.h5<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">"</span>n<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>o<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>m0<span class="pl-pds">"</span></span>)
model0 <span class="pl-k">=</span> <span class="pl-c1">Model</span>((n[<span class="pl-c1">1</span>], n[<span class="pl-c1">2</span>]), (d[<span class="pl-c1">1</span>], d[<span class="pl-c1">2</span>]), (o[<span class="pl-c1">1</span>], o[<span class="pl-c1">2</span>]), m0)	<span class="pl-c"><span class="pl-c">#</span> need n, d, o as tuples and m0 as array</span>

<span class="pl-c"><span class="pl-c">#</span> Bound constraints</span>
vmin <span class="pl-k">=</span> <span class="pl-c1">ones</span>(Float32, model0<span class="pl-k">.</span>n) <span class="pl-k">.+</span> <span class="pl-c1">0.3f0</span>
vmax <span class="pl-k">=</span> <span class="pl-c1">ones</span>(Float32, model0<span class="pl-k">.</span>n) <span class="pl-k">.+</span> <span class="pl-c1">5.5f0</span>
mmin <span class="pl-k">=</span> <span class="pl-c1">vec</span>((<span class="pl-c1">1f0</span> <span class="pl-k">./</span> vmax)<span class="pl-k">.</span><span class="pl-k">^</span><span class="pl-c1">2</span>)	<span class="pl-c"><span class="pl-c">#</span> convert to slowness squared [s^2/km^2]</span>
mmax <span class="pl-k">=</span> <span class="pl-c1">vec</span>((<span class="pl-c1">1f0</span> <span class="pl-k">./</span> vmin)<span class="pl-k">.</span><span class="pl-k">^</span><span class="pl-c1">2</span>)

<span class="pl-c"><span class="pl-c">#</span> Load segy data</span>
block <span class="pl-k">=</span> <span class="pl-c1">segy_read</span>(<span class="pl-s"><span class="pl-pds">"</span>overthrust_2D.segy<span class="pl-pds">"</span></span>)
dobs <span class="pl-k">=</span> <span class="pl-c1">judiVector</span>(block)

<span class="pl-c"><span class="pl-c">#</span> Set up wavelet</span>
src_geometry <span class="pl-k">=</span> <span class="pl-c1">Geometry</span>(block; key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>source<span class="pl-pds">"</span></span>, segy_depth_key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>SourceDepth<span class="pl-pds">"</span></span>)	<span class="pl-c"><span class="pl-c">#</span> read source position geometry</span>
wavelet <span class="pl-k">=</span> <span class="pl-c1">ricker_wavelet</span>(src_geometry<span class="pl-k">.</span>t[<span class="pl-c1">1</span>], src_geometry<span class="pl-k">.</span>dt[<span class="pl-c1">1</span>], <span class="pl-c1">0.008f0</span>)	<span class="pl-c"><span class="pl-c">#</span> 8 Hz wavelet</span>
q <span class="pl-k">=</span> <span class="pl-c1">judiVector</span>(src_geometry, wavelet)
</pre></div>
<p dir="auto">For this FWI example, we define an objective function that can be passed to the minConf optimization library, which is included in the Julia Devito software package. We allow a maximum of 20 function evaluations using a spectral-projected gradient (SPG) algorithm. To save computational cost, each function evaluation uses a randomized subset of 20 shot records, instead of all 97 shots:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Optimization parameters
fevals = 20	# number of function evaluations
batchsize = 20	# number of sources per iteration
fvals = zeros(21)
opt = Options(optimal_checkpointing = false)    # set to true to enable checkpointing

# Objective function for minConf library
count = 0
function objective_function(x)
	model0.m = reshape(x, model0.n);

	# fwi function value and gradient
	i = randperm(dobs.nsrc)[1:batchsize]
	fval, grad = fwi_objective(model0, q[i], dobs[i]; options=opt)
	grad = reshape(grad, model0.n); grad[:, 1:21] .= 0f0	# reset gradient in water column to 0.
	grad = .1f0*grad/maximum(abs.(grad))	# scale gradient for line search

	global count; count += 1; fvals[count] = fval
    return fval, vec(grad.data)
end

# FWI with SPG
ProjBound(x) = median([mmin x mmax], dims=2)	# Bound projection
options = spg_options(verbose=3, maxIter=fevals, memory=3)
x, fsave, funEvals= minConf_SPG(objective_function, vec(m0), ProjBound, options)"><pre><span class="pl-c"><span class="pl-c">#</span> Optimization parameters</span>
fevals <span class="pl-k">=</span> <span class="pl-c1">20</span>	<span class="pl-c"><span class="pl-c">#</span> number of function evaluations</span>
batchsize <span class="pl-k">=</span> <span class="pl-c1">20</span>	<span class="pl-c"><span class="pl-c">#</span> number of sources per iteration</span>
fvals <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">21</span>)
opt <span class="pl-k">=</span> <span class="pl-c1">Options</span>(optimal_checkpointing <span class="pl-k">=</span> <span class="pl-c1">false</span>)    <span class="pl-c"><span class="pl-c">#</span> set to true to enable checkpointing</span>

<span class="pl-c"><span class="pl-c">#</span> Objective function for minConf library</span>
count <span class="pl-k">=</span> <span class="pl-c1">0</span>
<span class="pl-k">function</span> <span class="pl-en">objective_function</span>(x)
	model0<span class="pl-k">.</span>m <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(x, model0<span class="pl-k">.</span>n);

	<span class="pl-c"><span class="pl-c">#</span> fwi function value and gradient</span>
	i <span class="pl-k">=</span> <span class="pl-c1">randperm</span>(dobs<span class="pl-k">.</span>nsrc)[<span class="pl-c1">1</span><span class="pl-k">:</span>batchsize]
	fval, grad <span class="pl-k">=</span> <span class="pl-c1">fwi_objective</span>(model0, q[i], dobs[i]; options<span class="pl-k">=</span>opt)
	grad <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(grad, model0<span class="pl-k">.</span>n); grad[:, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">21</span>] <span class="pl-k">.=</span> <span class="pl-c1">0f0</span>	<span class="pl-c"><span class="pl-c">#</span> reset gradient in water column to 0.</span>
	grad <span class="pl-k">=</span> .<span class="pl-c1">1f0</span><span class="pl-k">*</span>grad<span class="pl-k">/</span><span class="pl-c1">maximum</span>(<span class="pl-c1">abs</span>.(grad))	<span class="pl-c"><span class="pl-c">#</span> scale gradient for line search</span>

	<span class="pl-k">global</span> count; count <span class="pl-k">+=</span> <span class="pl-c1">1</span>; fvals[count] <span class="pl-k">=</span> fval
    <span class="pl-k">return</span> fval, <span class="pl-c1">vec</span>(grad<span class="pl-k">.</span>data)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> FWI with SPG</span>
<span class="pl-en">ProjBound</span>(x) <span class="pl-k">=</span> <span class="pl-c1">median</span>([mmin x mmax], dims<span class="pl-k">=</span><span class="pl-c1">2</span>)	<span class="pl-c"><span class="pl-c">#</span> Bound projection</span>
options <span class="pl-k">=</span> <span class="pl-c1">spg_options</span>(verbose<span class="pl-k">=</span><span class="pl-c1">3</span>, maxIter<span class="pl-k">=</span>fevals, memory<span class="pl-k">=</span><span class="pl-c1">3</span>)
x, fsave, funEvals<span class="pl-k">=</span> <span class="pl-c1">minConf_SPG</span>(objective_function, <span class="pl-c1">vec</span>(m0), ProjBound, options)</pre></div>
<p dir="auto">This example script can be run in parallel and requires roughly 220 MB of memory per source location. Execute the following code to generate figures of the initial model and the result, as well as the function values:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="figure(); imshow(sqrt.(1./adjoint(m0))); title(&quot;Initial model&quot;)
figure(); imshow(sqrt.(1./adjoint(reshape(x, model0.n)))); title(&quot;FWI&quot;)
figure(); plot(fvals); title(&quot;Function value&quot;)"><pre><span class="pl-c1">figure</span>(); <span class="pl-c1">imshow</span>(<span class="pl-c1">sqrt</span>.(<span class="pl-c1">1.</span><span class="pl-k">/</span><span class="pl-c1">adjoint</span>(m0))); <span class="pl-c1">title</span>(<span class="pl-s"><span class="pl-pds">"</span>Initial model<span class="pl-pds">"</span></span>)
<span class="pl-c1">figure</span>(); <span class="pl-c1">imshow</span>(<span class="pl-c1">sqrt</span>.(<span class="pl-c1">1.</span><span class="pl-k">/</span><span class="pl-c1">adjoint</span>(<span class="pl-c1">reshape</span>(x, model0<span class="pl-k">.</span>n)))); <span class="pl-c1">title</span>(<span class="pl-s"><span class="pl-pds">"</span>FWI<span class="pl-pds">"</span></span>)
<span class="pl-c1">figure</span>(); <span class="pl-c1">plot</span>(fvals); <span class="pl-c1">title</span>(<span class="pl-s"><span class="pl-pds">"</span>Function value<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/figures/fwi.png"><img src="docs/src/figures/fwi.png" alt="fwi" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-least-squares-reverse-time-migration" class="anchor" aria-hidden="true" href="#least-squares-reverse-time-migration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Least squares reverse-time migration</h2>
<p dir="auto"><a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> includes matrix-free linear operators for modeling and linearized (Born) modeling, that let you write algorithms for migration that follow the mathematical notation of standard least squares problems. This example demonstrates how to use Julia Devito to perform least-squares reverse-time migration on the 2D Marmousi model. Start by downloading the test data set (1.1 GB) and the model:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/Imaging.jl/2DLSRTM/marmousi_2D.segy`)
run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/Imaging.jl/2DLSRTM/marmousi_migration_velocity.h5`)"><pre><span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>wget ftp://slim.gatech.edu/data/SoftwareRelease/Imaging.jl/2DLSRTM/marmousi_2D.segy<span class="pl-pds">`</span></span>)
<span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>wget ftp://slim.gatech.edu/data/SoftwareRelease/Imaging.jl/2DLSRTM/marmousi_migration_velocity.h5<span class="pl-pds">`</span></span>)</pre></div>
<p dir="auto">Once again, load the starting model and the data and set up the source wavelet. For this example, we use a Ricker wavelet with 30 Hertz peak frequency. For setting up matrix-free linear operators, an <code>info</code> structure with the dimensions of the problem is required:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PyPlot, HDF5, JUDI, SegyIO, Random

# Load smooth migration velocity model
n,d,o,m0 = read(h5open(&quot;marmousi_migration_velocity.h5&quot;,&quot;r&quot;), &quot;n&quot;, &quot;d&quot;, &quot;o&quot;, &quot;m0&quot;)
model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0)

# Load data
block = segy_read(&quot;marmousi_2D.segy&quot;)
dD = judiVector(block)

# Set up wavelet
src_geometry = Geometry(block; key=&quot;source&quot;, segy_depth_key=&quot;SourceDepth&quot;)
wavelet = ricker_wavelet(src_geometry.t[1],src_geometry.dt[1],0.03)	# 30 Hz wavelet
q = judiVector(src_geometry,wavelet)

# Set up info structure
ntComp = get_computational_nt(q.geometry,dD.geometry,model0)	# no. of computational time steps
info = Info(prod(model0.n),dD.nsrc,ntComp)"><pre><span class="pl-k">using</span> PyPlot, HDF5, JUDI, SegyIO, Random

<span class="pl-c"><span class="pl-c">#</span> Load smooth migration velocity model</span>
n,d,o,m0 <span class="pl-k">=</span> <span class="pl-c1">read</span>(<span class="pl-c1">h5open</span>(<span class="pl-s"><span class="pl-pds">"</span>marmousi_migration_velocity.h5<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">"</span>n<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>o<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>m0<span class="pl-pds">"</span></span>)
model0 <span class="pl-k">=</span> <span class="pl-c1">Model</span>((n[<span class="pl-c1">1</span>],n[<span class="pl-c1">2</span>]), (d[<span class="pl-c1">1</span>],d[<span class="pl-c1">2</span>]), (o[<span class="pl-c1">1</span>],o[<span class="pl-c1">2</span>]), m0)

<span class="pl-c"><span class="pl-c">#</span> Load data</span>
block <span class="pl-k">=</span> <span class="pl-c1">segy_read</span>(<span class="pl-s"><span class="pl-pds">"</span>marmousi_2D.segy<span class="pl-pds">"</span></span>)
dD <span class="pl-k">=</span> <span class="pl-c1">judiVector</span>(block)

<span class="pl-c"><span class="pl-c">#</span> Set up wavelet</span>
src_geometry <span class="pl-k">=</span> <span class="pl-c1">Geometry</span>(block; key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>source<span class="pl-pds">"</span></span>, segy_depth_key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>SourceDepth<span class="pl-pds">"</span></span>)
wavelet <span class="pl-k">=</span> <span class="pl-c1">ricker_wavelet</span>(src_geometry<span class="pl-k">.</span>t[<span class="pl-c1">1</span>],src_geometry<span class="pl-k">.</span>dt[<span class="pl-c1">1</span>],<span class="pl-c1">0.03</span>)	<span class="pl-c"><span class="pl-c">#</span> 30 Hz wavelet</span>
q <span class="pl-k">=</span> <span class="pl-c1">judiVector</span>(src_geometry,wavelet)

<span class="pl-c"><span class="pl-c">#</span> Set up info structure</span>
ntComp <span class="pl-k">=</span> <span class="pl-c1">get_computational_nt</span>(q<span class="pl-k">.</span>geometry,dD<span class="pl-k">.</span>geometry,model0)	<span class="pl-c"><span class="pl-c">#</span> no. of computational time steps</span>
info <span class="pl-k">=</span> <span class="pl-c1">Info</span>(<span class="pl-c1">prod</span>(model0<span class="pl-k">.</span>n),dD<span class="pl-k">.</span>nsrc,ntComp)</pre></div>
<p dir="auto">To speed up the convergence of our imaging example, we set up a basic preconditioner for each the model- and the data space, consisting of mutes to suppress the ocean-bottom reflection in the data and the source/receiver imprint in the image. The operator <code>J</code> represents the linearized modeling operator and its adjoint <code>J'</code> corresponds to the migration (RTM) operator. The forward and adjoint pair can be used for a basic LS-RTM example with (stochastic) gradient descent:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Set up matrix-free linear operators
opt = Options(optimal_checkpointing = true)    # set to false to disable optimal checkpointing
F = judiModeling(model0, q.geometry, dD.geometry; options=opt)
J = judiJacobian(F, q)

# Right-hand preconditioners (model topmute)
Mr = judiTopmute(model0.n, 52, 10)	# mute up to grid point 52, with 10 point taper

# Left-hand preconditioners
Ml = judiDataMute(q.geometry, dD.geometry; t0=.120)	# data topmute starting at 120ms (30 samples)

# Stochastic gradient
x = zeros(Float32, info.n)	# zero initial guess
batchsize = 10	# use subset of 10 shots per iteration
niter = 32
fval = zeros(Float32, niter)

for j=1:niter
	println(&quot;Iteration: &quot;, j)

	# Select batch and set up left-hand preconditioner
	i = randperm(dD.nsrc)[1:batchsize]

	# Compute residual and gradient
	r = Ml[i]*J[i]*Mr*x - Ml[i]*dD[i]
	g = adjoint(Mr)*adjoint(J[i])*adjoint(Ml[i])*r

	# Step size and update variable
	fval[j] = .5f0*norm(r)^2
	t = norm(r)^2/norm(g)^2
	global x -= t*g
end"><pre><span class="pl-c"><span class="pl-c">#</span> Set up matrix-free linear operators</span>
opt <span class="pl-k">=</span> <span class="pl-c1">Options</span>(optimal_checkpointing <span class="pl-k">=</span> <span class="pl-c1">true</span>)    <span class="pl-c"><span class="pl-c">#</span> set to false to disable optimal checkpointing</span>
F <span class="pl-k">=</span> <span class="pl-c1">judiModeling</span>(model0, q<span class="pl-k">.</span>geometry, dD<span class="pl-k">.</span>geometry; options<span class="pl-k">=</span>opt)
J <span class="pl-k">=</span> <span class="pl-c1">judiJacobian</span>(F, q)

<span class="pl-c"><span class="pl-c">#</span> Right-hand preconditioners (model topmute)</span>
Mr <span class="pl-k">=</span> <span class="pl-c1">judiTopmute</span>(model0<span class="pl-k">.</span>n, <span class="pl-c1">52</span>, <span class="pl-c1">10</span>)	<span class="pl-c"><span class="pl-c">#</span> mute up to grid point 52, with 10 point taper</span>

<span class="pl-c"><span class="pl-c">#</span> Left-hand preconditioners</span>
Ml <span class="pl-k">=</span> <span class="pl-c1">judiDataMute</span>(q<span class="pl-k">.</span>geometry, dD<span class="pl-k">.</span>geometry; t0<span class="pl-k">=</span>.<span class="pl-c1">120</span>)	<span class="pl-c"><span class="pl-c">#</span> data topmute starting at 120ms (30 samples)</span>

<span class="pl-c"><span class="pl-c">#</span> Stochastic gradient</span>
x <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Float32, info<span class="pl-k">.</span>n)	<span class="pl-c"><span class="pl-c">#</span> zero initial guess</span>
batchsize <span class="pl-k">=</span> <span class="pl-c1">10</span>	<span class="pl-c"><span class="pl-c">#</span> use subset of 10 shots per iteration</span>
niter <span class="pl-k">=</span> <span class="pl-c1">32</span>
fval <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Float32, niter)

<span class="pl-k">for</span> j<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>niter
	<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Iteration: <span class="pl-pds">"</span></span>, j)

	<span class="pl-c"><span class="pl-c">#</span> Select batch and set up left-hand preconditioner</span>
	i <span class="pl-k">=</span> <span class="pl-c1">randperm</span>(dD<span class="pl-k">.</span>nsrc)[<span class="pl-c1">1</span><span class="pl-k">:</span>batchsize]

	<span class="pl-c"><span class="pl-c">#</span> Compute residual and gradient</span>
	r <span class="pl-k">=</span> Ml[i]<span class="pl-k">*</span>J[i]<span class="pl-k">*</span>Mr<span class="pl-k">*</span>x <span class="pl-k">-</span> Ml[i]<span class="pl-k">*</span>dD[i]
	g <span class="pl-k">=</span> <span class="pl-c1">adjoint</span>(Mr)<span class="pl-k">*</span><span class="pl-c1">adjoint</span>(J[i])<span class="pl-k">*</span><span class="pl-c1">adjoint</span>(Ml[i])<span class="pl-k">*</span>r

	<span class="pl-c"><span class="pl-c">#</span> Step size and update variable</span>
	fval[j] <span class="pl-k">=</span> .<span class="pl-c1">5f0</span><span class="pl-k">*</span><span class="pl-c1">norm</span>(r)<span class="pl-k">^</span><span class="pl-c1">2</span>
	t <span class="pl-k">=</span> <span class="pl-c1">norm</span>(r)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">/</span><span class="pl-c1">norm</span>(g)<span class="pl-k">^</span><span class="pl-c1">2</span>
	<span class="pl-k">global</span> x <span class="pl-k">-=</span> t<span class="pl-k">*</span>g
<span class="pl-k">end</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/figures/lsrtm.png"><img src="docs/src/figures/lsrtm.png" alt="lsrtm" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-machine-learning" class="anchor" aria-hidden="true" href="#machine-learning"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Machine Learning</h2>
<p dir="auto"><a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> implements <a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore</a> reverse rules to integrate the modeling operators into convolutional neural networks for deep learning. For example, the following code snippet shows how to create a shallow CNN consisting of two convolutional layers with a nonlinear forward modeling layer in-between them. <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> enables backpropagation through <a href="https://github.com/FluxML/Flux.jl">Flux</a>' automatic differentiation tools, but calls the corresponding adjoint <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> operators under the hood.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Jacobian
W1 = judiJacobian(F0, q)
b1 = randn(Float32, num_samples)

# Fully connected layer
W2 = randn(Float32, n_out, num_samples)
b2 = randn(Float32, n_out)

# Network and loss
network(x) = W2*(W1*x .+ b1) .+ b2
loss(x, y) = Flux.mse(network(x), y)

# Compute gradient w/ Flux
p = params(x, y, W1, b1, b2)
gs = Tracker.gradient(() -&gt; loss(x, y), p)
gs[x]	# gradient w.r.t. to x"><pre><span class="pl-c"><span class="pl-c">#</span> Jacobian</span>
W1 <span class="pl-k">=</span> <span class="pl-c1">judiJacobian</span>(F0, q)
b1 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(Float32, num_samples)

<span class="pl-c"><span class="pl-c">#</span> Fully connected layer</span>
W2 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(Float32, n_out, num_samples)
b2 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(Float32, n_out)

<span class="pl-c"><span class="pl-c">#</span> Network and loss</span>
<span class="pl-en">network</span>(x) <span class="pl-k">=</span> W2<span class="pl-k">*</span>(W1<span class="pl-k">*</span>x <span class="pl-k">.+</span> b1) <span class="pl-k">.+</span> b2
<span class="pl-en">loss</span>(x, y) <span class="pl-k">=</span> Flux<span class="pl-k">.</span><span class="pl-c1">mse</span>(<span class="pl-c1">network</span>(x), y)

<span class="pl-c"><span class="pl-c">#</span> Compute gradient w/ Flux</span>
p <span class="pl-k">=</span> <span class="pl-c1">params</span>(x, y, W1, b1, b2)
gs <span class="pl-k">=</span> Tracker<span class="pl-k">.</span><span class="pl-c1">gradient</span>(() <span class="pl-k">-&gt;</span> <span class="pl-c1">loss</span>(x, y), p)
gs[x]	<span class="pl-c"><span class="pl-c">#</span> gradient w.r.t. to x</span></pre></div>
<p dir="auto"><a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> allows implementing physics-augmented neural networks for seismic inversion, such as loop-unrolled seismic imaging algorithms. For example, the following results are a conventional RTM image, an LS-RTM image and a loop-unrolled LS-RTM image for a single simultaneous shot record.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/figures/figure1.png"><img src="docs/src/figures/figure1.png" alt="flux" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-authors" class="anchor" aria-hidden="true" href="#authors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Authors</h2>
<p dir="auto">This package was written by <a href="https://www.linkedin.com/in/philipp-witte/" rel="nofollow">Philipp Witte</a> and <a href="https://mloubout.github.io/" rel="nofollow">Mathias Louboutin</a> from the Seismic Laboratory for Imaging and Modeling (SLIM) at the Georgia Institute of Technology.</p>
<p dir="auto">If you use our software for your research, please cite our <a href="https://library.seg.org/doi/abs/10.1190/geo2018-0174.1#" rel="nofollow">Geophysics paper</a>:</p>
<div class="highlight highlight-text-bibtex notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@article{witteJUDI2019,
author = {Philipp A. Witte and Mathias Louboutin and Navjot Kukreja and Fabio Luporini and Michael Lange and Gerard J. Gorman and Felix J. Herrmann},
title = {A large-scale framework for symbolic implementations of seismic inversion algorithms in Julia},
journal = {GEOPHYSICS},
volume = {84},
number = {3},
pages = {F57-F71},
year = {2019},
doi = {10.1190/geo2018-0174.1},
URL = {https://doi.org/10.1190/geo2018-0174.1},
eprint = {https://doi.org/10.1190/geo2018-0174.1}
}"><pre><span class="pl-k">@article</span>{<span class="pl-en">witteJUDI2019</span>,
<span class="pl-s">author</span> = <span class="pl-s"><span class="pl-pds">{</span>Philipp A. Witte and Mathias Louboutin and Navjot Kukreja and Fabio Luporini and Michael Lange and Gerard J. Gorman and Felix J. Herrmann<span class="pl-pds">}</span></span>,
<span class="pl-s">title</span> = <span class="pl-s"><span class="pl-pds">{</span>A large-scale framework for symbolic implementations of seismic inversion algorithms in Julia<span class="pl-pds">}</span></span>,
<span class="pl-s">journal</span> = <span class="pl-s"><span class="pl-pds">{</span>GEOPHYSICS<span class="pl-pds">}</span></span>,
<span class="pl-s">volume</span> = <span class="pl-s"><span class="pl-pds">{</span>84<span class="pl-pds">}</span></span>,
<span class="pl-s">number</span> = <span class="pl-s"><span class="pl-pds">{</span>3<span class="pl-pds">}</span></span>,
<span class="pl-s">pages</span> = <span class="pl-s"><span class="pl-pds">{</span>F57-F71<span class="pl-pds">}</span></span>,
<span class="pl-s">year</span> = <span class="pl-s"><span class="pl-pds">{</span>2019<span class="pl-pds">}</span></span>,
<span class="pl-s">doi</span> = <span class="pl-s"><span class="pl-pds">{</span>10.1190/geo2018-0174.1<span class="pl-pds">}</span></span>,
<span class="pl-s">URL</span> = <span class="pl-s"><span class="pl-pds">{</span>https://doi.org/10.1190/geo2018-0174.1<span class="pl-pds">}</span></span>,
<span class="pl-s">eprint</span> = <span class="pl-s"><span class="pl-pds">{</span>https://doi.org/10.1190/geo2018-0174.1<span class="pl-pds">}</span></span>
}</pre></div>
<p dir="auto">Also visit the Devito homepage at <a href="https://www.devitoproject.org/publications" rel="nofollow">https://www.devitoproject.org/publications</a> for more information and references.</p>
<p dir="auto">Contact authors via: <a href="mailto:mlouboutin3@gatech.edu">mlouboutin3@gatech.edu</a>.</p>
</article></div>