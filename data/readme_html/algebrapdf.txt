<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-algebrapdf" class="anchor" aria-hidden="true" href="#algebrapdf"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>AlgebraPDF</h1>
<p dir="auto"><a href="https://github.com/mmikhasenko/AlgebraPDF.jl/actions"><img src="https://github.com/mmikhasenko/AlgebraPDF.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/mmikhasenko/AlgebraPDF.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/62b73f6b99fd2ba122e2343c2d450d2ce5f1c7f164959f49d2c0b85d3845a694/68747470733a2f2f636f6465636f762e696f2f67682f6d6d696b686173656e6b6f2f416c67656272615044462e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/mmikhasenko/AlgebraPDF.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Basic functionality:</p>
<ul dir="auto">
<li>Attach default values of parameters to a function</li>
<li>Update, fix, release parameters</li>
<li>constructing a complex model object from set of function:
<ul dir="auto">
<li>algebra of functions with parameters, e.g. <code>f₁ + f₂</code>, <code>abs2(f)</code>, or <code>log(f)</code>.</li>
</ul>
</li>
<li>On-fly normalization</li>
<li>construction of mixed models in the form <code>f₁ PDF₁ + f₂ PDF₂ + f₃ PDF₃</code>.</li>
<li>construction of likelihood function and extended likelihood function</li>
<li>plotting recipes</li>
</ul>
<p dir="auto">Current implementation is limited to immutable operations.</p>
<h2 dir="auto"><a id="user-content-an-example" class="anchor" aria-hidden="true" href="#an-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h2>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="plots/sixcompfit.png"><img src="plots/sixcompfit.png" alt="plots/sixcompfit.png" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-model-construction-and-extended-mle-fit" class="anchor" aria-hidden="true" href="#model-construction-and-extended-mle-fit"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Model construction and Extended MLE fit</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using AlgebraPDF
using DelimitedFiles


const xth = 2.95
const support = xth .+ (0, 0.22)

data = readdlm(&quot;data.txt&quot;)[:,1]
# Nev = size(data,1)

# amplitude for the signal
Φ2(x) = sqrt(x-xth)
Γ(x,m,Γ₀) = Γ₀*Φ2(x)/Φ2(m)
breitwigner(x,m,Γ₀) = 1/(m^2-x^2-1im*m*Γ(x,m,Γ₀)) 

# I) phase space function, also the background
phasespace = FunctionWithParameters((x;p)-&gt;Φ2(x), ∅) # pass λ-function
backgrpdf = Normalized(phasespace, support) # get PDF

# II) define a type SimpleBW and the method `func` for dispatch
struct SimpleBW{P} &lt;: AbstractFunctionWithParameters
    p::P
end
import AlgebraPDF:func
function func(bw::SimpleBW, x::NumberOrTuple; p=pars(bw))
    m,Γ = (getproperty(p,s) for s in keys(bw.p))
    breitwigner(x, m, Γ)
end

# Signal1-4: |A|^2 * phase_space
signalpdfs = 
    [Normalized(abs2(A)*phasespace, support)
        for A in [
            SimpleBW((m1=3.00, Γ1=6.5e-3)),
            SimpleBW((m2=3.05, Γ2=2.3e-3)),
            SimpleBW((m3=3.06, Γ3=4.0e-3)),
            SimpleBW((m4=3.09, Γ4=9.9e-3))]
        ]

# III) The threshold function, also |Ath|^2 * phase_space
@makefuntype SimpleBWg(x;p) =
    1/(p.m0^2 - x^2 - 1im*p.g^2*Φ2(x))
#
signalpdf0 = Normalized(
        abs2(SimpleBWg((m0=2.95, g=0.01)))*phasespace,
        support)

# the full model - sum of components
model0 = 
    signalpdf0 * (f0=0.05Nev,) +
    signalpdfs[1] * (f1=0.25Nev,) + signalpdfs[2] * (f2=0.15Nev,) + 
    signalpdfs[3] * (f3=0.15Nev,) + signalpdfs[4] * (f4=0.55Nev,) +
    backgrpdf * Ext(fb=0.3Nev,) # Ext - to be able to fix
# 
model1 = fixpar(model0, :fb, 17.2)
# 
# fit with your favorite package"><pre><span class="pl-k">using</span> AlgebraPDF
<span class="pl-k">using</span> DelimitedFiles


<span class="pl-k">const</span> xth <span class="pl-k">=</span> <span class="pl-c1">2.95</span>
<span class="pl-k">const</span> support <span class="pl-k">=</span> xth <span class="pl-k">.+</span> (<span class="pl-c1">0</span>, <span class="pl-c1">0.22</span>)

data <span class="pl-k">=</span> <span class="pl-c1">readdlm</span>(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>)[:,<span class="pl-c1">1</span>]
<span class="pl-c"><span class="pl-c">#</span> Nev = size(data,1)</span>

<span class="pl-c"><span class="pl-c">#</span> amplitude for the signal</span>
<span class="pl-en">Φ2</span>(x) <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(x<span class="pl-k">-</span>xth)
<span class="pl-en">Γ</span>(x,m,Γ₀) <span class="pl-k">=</span> Γ₀<span class="pl-k">*</span><span class="pl-c1">Φ2</span>(x)<span class="pl-k">/</span><span class="pl-c1">Φ2</span>(m)
<span class="pl-en">breitwigner</span>(x,m,Γ₀) <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(m<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1im</span><span class="pl-k">*</span>m<span class="pl-k">*</span><span class="pl-c1">Γ</span>(x,m,Γ₀)) 

<span class="pl-c"><span class="pl-c">#</span> I) phase space function, also the background</span>
phasespace <span class="pl-k">=</span> <span class="pl-c1">FunctionWithParameters</span>((x;p)<span class="pl-k">-&gt;</span><span class="pl-c1">Φ2</span>(x), ∅) <span class="pl-c"><span class="pl-c">#</span> pass λ-function</span>
backgrpdf <span class="pl-k">=</span> <span class="pl-c1">Normalized</span>(phasespace, support) <span class="pl-c"><span class="pl-c">#</span> get PDF</span>

<span class="pl-c"><span class="pl-c">#</span> II) define a type SimpleBW and the method `func` for dispatch</span>
<span class="pl-k">struct</span> SimpleBW{P} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractFunctionWithParameters</span>
    p<span class="pl-k">::</span><span class="pl-c1">P</span>
<span class="pl-k">end</span>
<span class="pl-k">import</span> AlgebraPDF<span class="pl-k">:</span>func
<span class="pl-k">function</span> <span class="pl-en">func</span>(bw<span class="pl-k">::</span><span class="pl-c1">SimpleBW</span>, x<span class="pl-k">::</span><span class="pl-c1">NumberOrTuple</span>; p<span class="pl-k">=</span><span class="pl-c1">pars</span>(bw))
    m,Γ <span class="pl-k">=</span> (<span class="pl-c1">getproperty</span>(p,s) <span class="pl-k">for</span> s <span class="pl-k">in</span> <span class="pl-c1">keys</span>(bw<span class="pl-k">.</span>p))
    <span class="pl-c1">breitwigner</span>(x, m, Γ)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Signal1-4: |A|^2 * phase_space</span>
signalpdfs <span class="pl-k">=</span> 
    [<span class="pl-c1">Normalized</span>(<span class="pl-c1">abs2</span>(A)<span class="pl-k">*</span>phasespace, support)
        <span class="pl-k">for</span> A <span class="pl-k">in</span> [
            <span class="pl-c1">SimpleBW</span>((m1<span class="pl-k">=</span><span class="pl-c1">3.00</span>, Γ1<span class="pl-k">=</span><span class="pl-c1">6.5e-3</span>)),
            <span class="pl-c1">SimpleBW</span>((m2<span class="pl-k">=</span><span class="pl-c1">3.05</span>, Γ2<span class="pl-k">=</span><span class="pl-c1">2.3e-3</span>)),
            <span class="pl-c1">SimpleBW</span>((m3<span class="pl-k">=</span><span class="pl-c1">3.06</span>, Γ3<span class="pl-k">=</span><span class="pl-c1">4.0e-3</span>)),
            <span class="pl-c1">SimpleBW</span>((m4<span class="pl-k">=</span><span class="pl-c1">3.09</span>, Γ4<span class="pl-k">=</span><span class="pl-c1">9.9e-3</span>))]
        ]

<span class="pl-c"><span class="pl-c">#</span> III) The threshold function, also |Ath|^2 * phase_space</span>
<span class="pl-c1">@makefuntype</span> <span class="pl-en">SimpleBWg</span>(x;p) <span class="pl-k">=</span>
    <span class="pl-c1">1</span><span class="pl-k">/</span>(p<span class="pl-k">.</span>m0<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">1im</span><span class="pl-k">*</span>p<span class="pl-k">.</span>g<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">Φ2</span>(x))
<span class="pl-c"><span class="pl-c">#</span></span>
signalpdf0 <span class="pl-k">=</span> <span class="pl-c1">Normalized</span>(
        <span class="pl-c1">abs2</span>(<span class="pl-c1">SimpleBWg</span>((m0<span class="pl-k">=</span><span class="pl-c1">2.95</span>, g<span class="pl-k">=</span><span class="pl-c1">0.01</span>)))<span class="pl-k">*</span>phasespace,
        support)

<span class="pl-c"><span class="pl-c">#</span> the full model - sum of components</span>
model0 <span class="pl-k">=</span> 
    signalpdf0 <span class="pl-k">*</span> (f0<span class="pl-k">=</span><span class="pl-c1">0.05</span>Nev,) <span class="pl-k">+</span>
    signalpdfs[<span class="pl-c1">1</span>] <span class="pl-k">*</span> (f1<span class="pl-k">=</span><span class="pl-c1">0.25</span>Nev,) <span class="pl-k">+</span> signalpdfs[<span class="pl-c1">2</span>] <span class="pl-k">*</span> (f2<span class="pl-k">=</span><span class="pl-c1">0.15</span>Nev,) <span class="pl-k">+</span> 
    signalpdfs[<span class="pl-c1">3</span>] <span class="pl-k">*</span> (f3<span class="pl-k">=</span><span class="pl-c1">0.15</span>Nev,) <span class="pl-k">+</span> signalpdfs[<span class="pl-c1">4</span>] <span class="pl-k">*</span> (f4<span class="pl-k">=</span><span class="pl-c1">0.55</span>Nev,) <span class="pl-k">+</span>
    backgrpdf <span class="pl-k">*</span> <span class="pl-c1">Ext</span>(fb<span class="pl-k">=</span><span class="pl-c1">0.3</span>Nev,) <span class="pl-c"><span class="pl-c">#</span> Ext - to be able to fix</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
model1 <span class="pl-k">=</span> <span class="pl-c1">fixpar</span>(model0, <span class="pl-c1">:fb</span>, <span class="pl-c1">17.2</span>)
<span class="pl-c"><span class="pl-c">#</span> </span>
<span class="pl-c"><span class="pl-c">#</span> fit with your favorite package</span></pre></div>
<p dir="auto">The plotting commands see in <a href="plots/example.jl">plots/example.jl</a>. Detailed description of the methods follows.</p>
<h2 dir="auto"><a id="user-content-call-the-function" class="anchor" aria-hidden="true" href="#call-the-function"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Call the function</h2>
<p dir="auto">The object behave similar to a regular function with a keyword argument <code>p</code> set to <code>freepars(d)</code> by default.
Once <code>p</code> is used a full set of parameters needs to be provided.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g = FGauss((μ=1.2, σ=0.1))
# call on a single argument
g(0.7) # use default parameters
g(0.7; p=(μ=1.6, σ=0.2)) # use provided parameters
g(0.7, [1.6, 0.2]) # same as before, see `NamedTuple{keys(freepars(g))}`
# incorrect calls
g(0.7; p=(μ=1.6,)) # error: no σ is given
g(0.7; p=(σ=0.2,)) # error: no μ is given
# broadcasting
g(rand(10))
g(rand(10); p=(μ=1.6, σ=0.2))"><pre>g <span class="pl-k">=</span> <span class="pl-c1">FGauss</span>((μ<span class="pl-k">=</span><span class="pl-c1">1.2</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.1</span>))
<span class="pl-c"><span class="pl-c">#</span> call on a single argument</span>
<span class="pl-c1">g</span>(<span class="pl-c1">0.7</span>) <span class="pl-c"><span class="pl-c">#</span> use default parameters</span>
<span class="pl-c1">g</span>(<span class="pl-c1">0.7</span>; p<span class="pl-k">=</span>(μ<span class="pl-k">=</span><span class="pl-c1">1.6</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>)) <span class="pl-c"><span class="pl-c">#</span> use provided parameters</span>
<span class="pl-c1">g</span>(<span class="pl-c1">0.7</span>, [<span class="pl-c1">1.6</span>, <span class="pl-c1">0.2</span>]) <span class="pl-c"><span class="pl-c">#</span> same as before, see `NamedTuple{keys(freepars(g))}`</span>
<span class="pl-c"><span class="pl-c">#</span> incorrect calls</span>
<span class="pl-c1">g</span>(<span class="pl-c1">0.7</span>; p<span class="pl-k">=</span>(μ<span class="pl-k">=</span><span class="pl-c1">1.6</span>,)) <span class="pl-c"><span class="pl-c">#</span> error: no σ is given</span>
<span class="pl-c1">g</span>(<span class="pl-c1">0.7</span>; p<span class="pl-k">=</span>(σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>,)) <span class="pl-c"><span class="pl-c">#</span> error: no μ is given</span>
<span class="pl-c"><span class="pl-c">#</span> broadcasting</span>
<span class="pl-c1">g</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">10</span>))
<span class="pl-c1">g</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">10</span>); p<span class="pl-k">=</span>(μ<span class="pl-k">=</span><span class="pl-c1">1.6</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>))</pre></div>
<h2 dir="auto"><a id="user-content-update-parameter-values" class="anchor" aria-hidden="true" href="#update-parameter-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Update parameter values</h2>
<p dir="auto">The function structure immutable, therefore, the method on modification of parameters returns a new object</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d = FunctionWithParameters((x;p)-&gt;x^2+p.a, (a=1.0,))
# 
d′ = updatepar(d, :a, 2.0)
d′′ = updatepars(d, (a=2.0,))"><pre>d <span class="pl-k">=</span> <span class="pl-c1">FunctionWithParameters</span>((x;p)<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>p<span class="pl-k">.</span>a, (a<span class="pl-k">=</span><span class="pl-c1">1.0</span>,))
<span class="pl-c"><span class="pl-c">#</span> </span>
d′ <span class="pl-k">=</span> <span class="pl-c1">updatepar</span>(d, <span class="pl-c1">:a</span>, <span class="pl-c1">2.0</span>)
d′′ <span class="pl-k">=</span> <span class="pl-c1">updatepars</span>(d, (a<span class="pl-k">=</span><span class="pl-c1">2.0</span>,))</pre></div>
<h2 dir="auto"><a id="user-content-fixrelease-parameter-values" class="anchor" aria-hidden="true" href="#fixrelease-parameter-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Fix/release parameter values</h2>
<p dir="auto">By extending the parameter structure, one gets a possibility to fix/release the parameters.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g = FGauss(Ext(μ=1.2, σ=0.1)) # Ext for extended
# 
g′ = fixpar(g, :μ)
g′ = fixpar(g, :μ, 1.3)
# 
freepars(g′) # (σ=0.1,)
fixedpars(g′) # (μ=1.3,)
#
g′(0.7; p=(σ=0.2,)) # now works since μ is fixed
g′(0.7; p=(σ=0.2, μ=1.6)) # will use the fixed value of μ=1.2
g′′ = updatepar(g′, :μ, 1.2) # however, the update fill do
# 
g′′′ = releasepar(g′′, :μ)
g′′′ == g # true"><pre>g <span class="pl-k">=</span> <span class="pl-c1">FGauss</span>(<span class="pl-c1">Ext</span>(μ<span class="pl-k">=</span><span class="pl-c1">1.2</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.1</span>)) <span class="pl-c"><span class="pl-c">#</span> Ext for extended</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
g′ <span class="pl-k">=</span> <span class="pl-c1">fixpar</span>(g, <span class="pl-c1">:μ</span>)
g′ <span class="pl-k">=</span> <span class="pl-c1">fixpar</span>(g, <span class="pl-c1">:μ</span>, <span class="pl-c1">1.3</span>)
<span class="pl-c"><span class="pl-c">#</span> </span>
<span class="pl-c1">freepars</span>(g′) <span class="pl-c"><span class="pl-c">#</span> (σ=0.1,)</span>
<span class="pl-c1">fixedpars</span>(g′) <span class="pl-c"><span class="pl-c">#</span> (μ=1.3,)</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c1">g′</span>(<span class="pl-c1">0.7</span>; p<span class="pl-k">=</span>(σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>,)) <span class="pl-c"><span class="pl-c">#</span> now works since μ is fixed</span>
<span class="pl-c1">g′</span>(<span class="pl-c1">0.7</span>; p<span class="pl-k">=</span>(σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>, μ<span class="pl-k">=</span><span class="pl-c1">1.6</span>)) <span class="pl-c"><span class="pl-c">#</span> will use the fixed value of μ=1.2</span>
g′′ <span class="pl-k">=</span> <span class="pl-c1">updatepar</span>(g′, <span class="pl-c1">:μ</span>, <span class="pl-c1">1.2</span>) <span class="pl-c"><span class="pl-c">#</span> however, the update fill do</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
g′′′ <span class="pl-k">=</span> <span class="pl-c1">releasepar</span>(g′′, <span class="pl-c1">:μ</span>)
g′′′ <span class="pl-k">==</span> g <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<h2 dir="auto"><a id="user-content-algebra-of-functions" class="anchor" aria-hidden="true" href="#algebra-of-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Algebra of functions</h2>
<p dir="auto">Several operations on a function are implemented, as <code>abs2</code> and <code>log</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# an example of complex-valued function
f = FunctionWithParameters((x;p)-&gt;1/(p.m^2-x^2-1im*p.m*p.Γ), (m=0.77,Γ=0.15))

fabs2 = abs2(f1)
flog = log(fabs2)"><pre><span class="pl-c"><span class="pl-c">#</span> an example of complex-valued function</span>
f <span class="pl-k">=</span> <span class="pl-c1">FunctionWithParameters</span>((x;p)<span class="pl-k">-&gt;</span><span class="pl-c1">1</span><span class="pl-k">/</span>(p<span class="pl-k">.</span>m<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1im</span><span class="pl-k">*</span>p<span class="pl-k">.</span>m<span class="pl-k">*</span>p<span class="pl-k">.</span>Γ), (m<span class="pl-k">=</span><span class="pl-c1">0.77</span>,Γ<span class="pl-k">=</span><span class="pl-c1">0.15</span>))

fabs2 <span class="pl-k">=</span> <span class="pl-c1">abs2</span>(f1)
flog <span class="pl-k">=</span> <span class="pl-c1">log</span>(fabs2)</pre></div>
<p dir="auto">A simple arithmetics on a pair of function also works.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# operations with two functions
f1 = FunctionWithParameters((x;p)-&gt;abs(x)&lt;1 ? 1-(2x)^2 : -3, ∅)
f2 = FunctionWithParameters((x;p)-&gt;p.a*exp(-x)+p.b, (a=0.1,b=0.1))
#
fprod = f1*f2
# 
fsum = f1+f2
fsub = f1-f2"><pre><span class="pl-c"><span class="pl-c">#</span> operations with two functions</span>
f1 <span class="pl-k">=</span> <span class="pl-c1">FunctionWithParameters</span>((x;p)<span class="pl-k">-&gt;</span><span class="pl-c1">abs</span>(x)<span class="pl-k">&lt;</span><span class="pl-c1">1</span> <span class="pl-k">?</span> <span class="pl-c1">1</span><span class="pl-k">-</span>(<span class="pl-c1">2</span>x)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">3</span>, ∅)
f2 <span class="pl-k">=</span> <span class="pl-c1">FunctionWithParameters</span>((x;p)<span class="pl-k">-&gt;</span>p<span class="pl-k">.</span>a<span class="pl-k">*</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span>x)<span class="pl-k">+</span>p<span class="pl-k">.</span>b, (a<span class="pl-k">=</span><span class="pl-c1">0.1</span>,b<span class="pl-k">=</span><span class="pl-c1">0.1</span>))
<span class="pl-c"><span class="pl-c">#</span></span>
fprod <span class="pl-k">=</span> f1<span class="pl-k">*</span>f2
<span class="pl-c"><span class="pl-c">#</span> </span>
fsum <span class="pl-k">=</span> f1<span class="pl-k">+</span>f2
fsub <span class="pl-k">=</span> f1<span class="pl-k">-</span>f2</pre></div>
<p dir="auto">The summation and subtraction adds a new parameter for the coefficient of the functions, <code>p.α1*f1+p.α2*f2</code>.
The parameter can be passed with</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="+(f1,f2; p=(c1=1.1,c2=2.2))
+(f1,f2; p=Ext(c1=1.1,c2=2.2)) # the coefficients can be fixed 
# using explicit constructor:
FSum([f1,f2], (c1=1.1,c2=2.2))
FSum([f1,f2], Ext(c1=1.1,c2=2.2))
# subtraction is an addition
f1-f2 == +(f1,f2; p=(α1=1.0,α2=-1.0)) # true"><pre><span class="pl-k">+</span>(f1,f2; p<span class="pl-k">=</span>(c1<span class="pl-k">=</span><span class="pl-c1">1.1</span>,c2<span class="pl-k">=</span><span class="pl-c1">2.2</span>))
<span class="pl-k">+</span>(f1,f2; p<span class="pl-k">=</span><span class="pl-c1">Ext</span>(c1<span class="pl-k">=</span><span class="pl-c1">1.1</span>,c2<span class="pl-k">=</span><span class="pl-c1">2.2</span>)) <span class="pl-c"><span class="pl-c">#</span> the coefficients can be fixed </span>
<span class="pl-c"><span class="pl-c">#</span> using explicit constructor:</span>
<span class="pl-c1">FSum</span>([f1,f2], (c1<span class="pl-k">=</span><span class="pl-c1">1.1</span>,c2<span class="pl-k">=</span><span class="pl-c1">2.2</span>))
<span class="pl-c1">FSum</span>([f1,f2], <span class="pl-c1">Ext</span>(c1<span class="pl-k">=</span><span class="pl-c1">1.1</span>,c2<span class="pl-k">=</span><span class="pl-c1">2.2</span>))
<span class="pl-c"><span class="pl-c">#</span> subtraction is an addition</span>
f1<span class="pl-k">-</span>f2 <span class="pl-k">==</span> <span class="pl-k">+</span>(f1,f2; p<span class="pl-k">=</span>(α1<span class="pl-k">=</span><span class="pl-c1">1.0</span>,α2<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">1.0</span>)) <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<p dir="auto">Perhaps, a more transparent constuction of the same sum can be done using a linear decomposition:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(c1=1.1,) * f1 + (c2=2.2,) * f2"><pre>(c1<span class="pl-k">=</span><span class="pl-c1">1.1</span>,) <span class="pl-k">*</span> f1 <span class="pl-k">+</span> (c2<span class="pl-k">=</span><span class="pl-c1">2.2</span>,) <span class="pl-k">*</span> f2</pre></div>
<p dir="auto">Where a multiplication of a function to a parameter type returns a sum with a single term.
A special method on the addition on the sum is called.</p>
<h2 dir="auto"><a id="user-content-createimplement-the-functions-with-parameters" class="anchor" aria-hidden="true" href="#createimplement-the-functions-with-parameters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Create/implement the functions with parameters</h2>
<p dir="auto">It is just a function to which a container with parameters (default values) is attached.
The container can be static <code>NamedTuple</code>, or extended which can flag parameters as <code>free</code> and <code>fixed</code>.</p>
<p dir="auto">There are three main constructors:</p>
<ol dir="auto">
<li>lambda-function is explicitly given</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FunctionWithParameters(f::F, p::P)"><pre><span class="pl-c1">FunctionWithParameters</span>(f<span class="pl-k">::</span><span class="pl-c1">F</span>, p<span class="pl-k">::</span><span class="pl-c1">P</span>)</pre></div>
<ol start="2" dir="auto">
<li>user-defined stucture which is subtype of <code>AbstractFunctionWithParameters</code>:</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct myAmazingF{P} &lt;: AbstractFunctionWithParameters
    p::P
end
func(d::myAmazingF, x::NumberOrTuple; p=pars(d)) = ... # expression"><pre><span class="pl-k">struct</span> myAmazingF{P} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractFunctionWithParameters</span>
    p<span class="pl-k">::</span><span class="pl-c1">P</span>
<span class="pl-k">end</span>
<span class="pl-en">func</span>(d<span class="pl-k">::</span><span class="pl-c1">myAmazingF</span>, x<span class="pl-k">::</span><span class="pl-c1">NumberOrTuple</span>; p<span class="pl-k">=</span><span class="pl-en">pars</span>(d)) <span class="pl-k">=</span> <span class="pl-k">...</span> <span class="pl-c"><span class="pl-c">#</span> expression</span></pre></div>
<ol start="3" dir="auto">
<li>using a macro <code>@makefuntype</code>:</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@makefuntype myAmazingF(x;p) = ... # expression"><pre><span class="pl-c1">@makefuntype</span> <span class="pl-en">myAmazingF</span>(x;p) <span class="pl-k">=</span> <span class="pl-k">...</span> <span class="pl-c"><span class="pl-c">#</span> expression</span></pre></div>
<h2 dir="auto"><a id="user-content-createimplement-normalized-functions" class="anchor" aria-hidden="true" href="#createimplement-normalized-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Create/implement normalized functions</h2>
<p dir="auto">The idea is to attach also the limit to the function and compute the integral of it for the given parameter on-fly.
To make the normalization efficient, a call of the function on the <code>AbstractVector</code> implements a broadcasting with a single computation of normalization.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="myNormalized(1.1) # use default values of parameters, calls normalization once
myNormalized(rand(100)) # use default values of parameters, also calls normalization once
myNormalized(rand(100); p = (a=1.2, b=3.3)) # ignors defalt parameters"><pre><span class="pl-c1">myNormalized</span>(<span class="pl-c1">1.1</span>) <span class="pl-c"><span class="pl-c">#</span> use default values of parameters, calls normalization once</span>
<span class="pl-c1">myNormalized</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">100</span>)) <span class="pl-c"><span class="pl-c">#</span> use default values of parameters, also calls normalization once</span>
<span class="pl-c1">myNormalized</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">100</span>); p <span class="pl-k">=</span> (a<span class="pl-k">=</span><span class="pl-c1">1.2</span>, b<span class="pl-k">=</span><span class="pl-c1">3.3</span>)) <span class="pl-c"><span class="pl-c">#</span> ignors defalt parameters</span></pre></div>
<p dir="auto">The PDF has two main representations (the ways to define):</p>
<ol dir="auto">
<li>A struct with the reference to the <code>unnormdensity&lt;:AbstractFunctionWithParameters</code>.</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct Normalized{T&lt;:AbstractFunctionWithParameters,L} &lt;: AbstractPDF{1}
    unnormdensity::T
    lims::L
end"><pre><span class="pl-k">struct</span> Normalized{T<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractFunctionWithParameters</span>,L} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractPDF{1}</span>
    unnormdensity<span class="pl-k">::</span><span class="pl-c1">T</span>
    lims<span class="pl-k">::</span><span class="pl-c1">L</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">A regular function can be wrapper to FunctionWithParameters: <code>FunctionWithParameters((x;p)-&gt;p.c0+p.c1*x, (c0=1.0, c1=2.0))</code></p>
<ol start="2" dir="auto">
<li>Alternativerly, the density can be defined using a dispatch on a <code>customaty_type &lt;: AbstractPDF{1}</code>. E.g.,</li>
</ol>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct Pol1SinSq{T,N} &lt;: AbstractPDF{1}
    p::T
    lims::N
end
func(d::Pol1SinSq, x::NumberOrTuple; p=pars(d)) = p.a*sin(x+p.b)^2+1  # an example of the function"><pre><span class="pl-k">struct</span> Pol1SinSq{T,N} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractPDF{1}</span>
    p<span class="pl-k">::</span><span class="pl-c1">T</span>
    lims<span class="pl-k">::</span><span class="pl-c1">N</span>
<span class="pl-k">end</span>
<span class="pl-en">func</span>(d<span class="pl-k">::</span><span class="pl-c1">Pol1SinSq</span>, x<span class="pl-k">::</span><span class="pl-c1">NumberOrTuple</span>; p<span class="pl-k">=</span><span class="pl-en">pars</span>(d)) <span class="pl-k">=</span> p<span class="pl-k">.</span>a<span class="pl-k">*</span><span class="pl-c1">sin</span>(x<span class="pl-k">+</span>p<span class="pl-k">.</span>b)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span><span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> an example of the function</span></pre></div>
<p dir="auto">The limits can be checked with <code>lims(d)</code>.</p>
<h2 dir="auto"><a id="user-content-defined-parameter-names-or-defined-parameter-order" class="anchor" aria-hidden="true" href="#defined-parameter-names-or-defined-parameter-order"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Defined parameter names or defined parameter order</h2>
<p dir="auto">Creating a function or pdf can be conveniently done with macro</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# for BW1 &lt;: AbstractPDF{1}
@makepdftype BW1(x, p) = p.m*p.Γ/(p.m^2-x^2-1im*p.m*p.Γ)"><pre><span class="pl-c"><span class="pl-c">#</span> for BW1 &lt;: AbstractPDF{1}</span>
<span class="pl-c1">@makepdftype</span> <span class="pl-en">BW1</span>(x, p) <span class="pl-k">=</span> p<span class="pl-k">.</span>m<span class="pl-k">*</span>p<span class="pl-k">.</span>Γ<span class="pl-k">/</span>(p<span class="pl-k">.</span>m<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1im</span><span class="pl-k">*</span>p<span class="pl-k">.</span>m<span class="pl-k">*</span>p<span class="pl-k">.</span>Γ)</pre></div>
<p dir="auto">which expands into</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# implementation with NAMES of parameters build into the funciton call
struct BW1{P} &lt;: AbstractFunctionWithParameters
    p::P
end
import AlgebraPDF:func
func(bw::BW1, x::NumberOrTuple; p=pars(bw)) = p.m*p.Γ/(p.m^2-x^2-1im*p.m*p.Γ)"><pre><span class="pl-c"><span class="pl-c">#</span> implementation with NAMES of parameters build into the funciton call</span>
<span class="pl-k">struct</span> BW1{P} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractFunctionWithParameters</span>
    p<span class="pl-k">::</span><span class="pl-c1">P</span>
<span class="pl-k">end</span>
<span class="pl-k">import</span> AlgebraPDF<span class="pl-k">:</span>func
<span class="pl-en">func</span>(bw<span class="pl-k">::</span><span class="pl-c1">BW1</span>, x<span class="pl-k">::</span><span class="pl-c1">NumberOrTuple</span>; p<span class="pl-k">=</span><span class="pl-en">pars</span>(bw)) <span class="pl-k">=</span> p<span class="pl-k">.</span>m<span class="pl-k">*</span>p<span class="pl-k">.</span>Γ<span class="pl-k">/</span>(p<span class="pl-k">.</span>m<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1im</span><span class="pl-k">*</span>p<span class="pl-k">.</span>m<span class="pl-k">*</span>p<span class="pl-k">.</span>Γ)</pre></div>
<p dir="auto">Slightly better implementation where only the order of the arguments are fixed, while the names are determined when the instance is created.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# implementation with ORDER of parameters build into the funciton call
struct BW2{P} &lt;: AbstractFunctionWithParameters
    p::P
end
import AlgebraPDF:func
function func(bw::BW2, x::NumberOrTuple; p=pars(bw))
    m,Γ = (getproperty(p,s) for s in keys(bw.p))
    m*Γ/(m^2-x^2-1im*m*Γ)
end

# same function with different names
bw_i = BW2((m_i=1.1, Γ_i=0.2))
bw_j = BW2((m_j=1.1, Γ_j=0.2))
bw_k = BW2((m_k=1.1, Γ_k=0.2))"><pre><span class="pl-c"><span class="pl-c">#</span> implementation with ORDER of parameters build into the funciton call</span>
<span class="pl-k">struct</span> BW2{P} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractFunctionWithParameters</span>
    p<span class="pl-k">::</span><span class="pl-c1">P</span>
<span class="pl-k">end</span>
<span class="pl-k">import</span> AlgebraPDF<span class="pl-k">:</span>func
<span class="pl-k">function</span> <span class="pl-en">func</span>(bw<span class="pl-k">::</span><span class="pl-c1">BW2</span>, x<span class="pl-k">::</span><span class="pl-c1">NumberOrTuple</span>; p<span class="pl-k">=</span><span class="pl-c1">pars</span>(bw))
    m,Γ <span class="pl-k">=</span> (<span class="pl-c1">getproperty</span>(p,s) <span class="pl-k">for</span> s <span class="pl-k">in</span> <span class="pl-c1">keys</span>(bw<span class="pl-k">.</span>p))
    m<span class="pl-k">*</span>Γ<span class="pl-k">/</span>(m<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1im</span><span class="pl-k">*</span>m<span class="pl-k">*</span>Γ)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> same function with different names</span>
bw_i <span class="pl-k">=</span> <span class="pl-c1">BW2</span>((m_i<span class="pl-k">=</span><span class="pl-c1">1.1</span>, Γ_i<span class="pl-k">=</span><span class="pl-c1">0.2</span>))
bw_j <span class="pl-k">=</span> <span class="pl-c1">BW2</span>((m_j<span class="pl-k">=</span><span class="pl-c1">1.1</span>, Γ_j<span class="pl-k">=</span><span class="pl-c1">0.2</span>))
bw_k <span class="pl-k">=</span> <span class="pl-c1">BW2</span>((m_k<span class="pl-k">=</span><span class="pl-c1">1.1</span>, Γ_k<span class="pl-k">=</span><span class="pl-c1">0.2</span>))</pre></div>
<h2 dir="auto"><a id="user-content-convolution" class="anchor" aria-hidden="true" href="#convolution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Convolution</h2>
<p dir="auto">The most common case of smearing a function with gaussian denisity is implemented.
The convolved function is created with</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f_conv = convGauss(f::F, σ::T) where F &lt;: AbstractFunctionWithParameters"><pre>f_conv <span class="pl-k">=</span> <span class="pl-c1">convGauss</span>(f<span class="pl-k">::</span><span class="pl-c1">F</span>, σ<span class="pl-k">::</span><span class="pl-c1">T</span>) <span class="pl-k">where</span> F <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractFunctionWithParameters</span></pre></div>
<p dir="auto">σ can be a number, but can also be a function <code>&lt;: AbstractFunctionWithParameters</code>.</p>
<p dir="auto">A customary confolved function or pdf can be defined the same was as e.g. <a href="src/densities.jl"><code>FBreitWignerConvGauss</code></a>.</p>
<h2 dir="auto"><a id="user-content-some-defined-functions" class="anchor" aria-hidden="true" href="#some-defined-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Some defined functions</h2>
<p dir="auto">For convenience, some standard functions are predefined.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FGauss((μ=1.2, σ=0.2))
FDoubleGaussFixedRatio((μ=1.2, σ=0.2, r=0.2, n=5))
FBreitWigner((m=0.77, Γ=0.15))
FExp((τ=-0.1,))
FPowExp((n=1.2,τ=-0.1))
FPol((a0=1, a1=2, a2=3, a3=5))
FBreitWignerConvGauss((μ=0.77, Γ=0.15, σ=2.2))
# 
xv = -π/2:0.1:π/2
yv = sin.(xv)
FTabulated(xv,yv)"><pre><span class="pl-c1">FGauss</span>((μ<span class="pl-k">=</span><span class="pl-c1">1.2</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>))
<span class="pl-c1">FDoubleGaussFixedRatio</span>((μ<span class="pl-k">=</span><span class="pl-c1">1.2</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>, r<span class="pl-k">=</span><span class="pl-c1">0.2</span>, n<span class="pl-k">=</span><span class="pl-c1">5</span>))
<span class="pl-c1">FBreitWigner</span>((m<span class="pl-k">=</span><span class="pl-c1">0.77</span>, Γ<span class="pl-k">=</span><span class="pl-c1">0.15</span>))
<span class="pl-c1">FExp</span>((τ<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">0.1</span>,))
<span class="pl-c1">FPowExp</span>((n<span class="pl-k">=</span><span class="pl-c1">1.2</span>,τ<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">0.1</span>))
<span class="pl-c1">FPol</span>((a0<span class="pl-k">=</span><span class="pl-c1">1</span>, a1<span class="pl-k">=</span><span class="pl-c1">2</span>, a2<span class="pl-k">=</span><span class="pl-c1">3</span>, a3<span class="pl-k">=</span><span class="pl-c1">5</span>))
<span class="pl-c1">FBreitWignerConvGauss</span>((μ<span class="pl-k">=</span><span class="pl-c1">0.77</span>, Γ<span class="pl-k">=</span><span class="pl-c1">0.15</span>, σ<span class="pl-k">=</span><span class="pl-c1">2.2</span>))
<span class="pl-c"><span class="pl-c">#</span> </span>
xv <span class="pl-k">=</span> <span class="pl-k">-</span>π<span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span>π<span class="pl-k">/</span><span class="pl-c1">2</span>
yv <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(xv)
<span class="pl-c1">FTabulated</span>(xv,yv)</pre></div>
<p dir="auto">The corresponding pdf can be defined with <code>Normalized</code> by adding a limits. E.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d = Normalized(FGauss((μ=1.2, σ=0.2)), (-1,4))"><pre>d <span class="pl-k">=</span> <span class="pl-c1">Normalized</span>(<span class="pl-c1">FGauss</span>((μ<span class="pl-k">=</span><span class="pl-c1">1.2</span>, σ<span class="pl-k">=</span><span class="pl-c1">0.2</span>)), (<span class="pl-k">-</span><span class="pl-c1">1</span>,<span class="pl-c1">4</span>))</pre></div>
<h2 dir="auto"><a id="user-content-higher-dimensions" class="anchor" aria-hidden="true" href="#higher-dimensions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Higher dimensions</h2>
<p dir="auto">Function with higher dimensions expect the variable provided as a <code>Tuple</code>, i.e. <code>(x,y)</code>, otherwise,
the construction and usage are analogous to the one dimensional case.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@makefuntype Amazing2D(x;p) = (x[1]-p.x0)^2+(x[2]-p.y0)^2-p.R0^2
a = Amazing2D((x0=1.1, y0=2.1, R0=0.0))
a((1.1,2.1)) # returns 0
# 
data = collect(zip(rand(10), rand(10)))
a(data) # return a vector of 10 elements

@makefuntype Amazing3D(x;p) = (x[1]-p.x0)^2+(x[2]-p.y0)^2+(x[3]-p.z0)^2-p.R0^2
b = Amazing3D((x0=1.1, y0=2.1, z0=3.1, R0=-1.0))
b((1.1,2.1,3.1)) == -1
# 
data3d = collect(zip(rand(10), rand(10), rand(10)))
b(data3d; p=(x0=1, y0=2, z0=3, R0=-1) )  # return a vector of 10 elements"><pre><span class="pl-c1">@makefuntype</span> <span class="pl-en">Amazing2D</span>(x;p) <span class="pl-k">=</span> (x[<span class="pl-c1">1</span>]<span class="pl-k">-</span>p<span class="pl-k">.</span>x0)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">-</span>p<span class="pl-k">.</span>y0)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>p<span class="pl-k">.</span>R0<span class="pl-k">^</span><span class="pl-c1">2</span>
a <span class="pl-k">=</span> <span class="pl-c1">Amazing2D</span>((x0<span class="pl-k">=</span><span class="pl-c1">1.1</span>, y0<span class="pl-k">=</span><span class="pl-c1">2.1</span>, R0<span class="pl-k">=</span><span class="pl-c1">0.0</span>))
<span class="pl-c1">a</span>((<span class="pl-c1">1.1</span>,<span class="pl-c1">2.1</span>)) <span class="pl-c"><span class="pl-c">#</span> returns 0</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
data <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">zip</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">10</span>), <span class="pl-c1">rand</span>(<span class="pl-c1">10</span>)))
<span class="pl-c1">a</span>(data) <span class="pl-c"><span class="pl-c">#</span> return a vector of 10 elements</span>

<span class="pl-c1">@makefuntype</span> <span class="pl-en">Amazing3D</span>(x;p) <span class="pl-k">=</span> (x[<span class="pl-c1">1</span>]<span class="pl-k">-</span>p<span class="pl-k">.</span>x0)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">-</span>p<span class="pl-k">.</span>y0)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>(x[<span class="pl-c1">3</span>]<span class="pl-k">-</span>p<span class="pl-k">.</span>z0)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>p<span class="pl-k">.</span>R0<span class="pl-k">^</span><span class="pl-c1">2</span>
b <span class="pl-k">=</span> <span class="pl-c1">Amazing3D</span>((x0<span class="pl-k">=</span><span class="pl-c1">1.1</span>, y0<span class="pl-k">=</span><span class="pl-c1">2.1</span>, z0<span class="pl-k">=</span><span class="pl-c1">3.1</span>, R0<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">1.0</span>))
<span class="pl-c1">b</span>((<span class="pl-c1">1.1</span>,<span class="pl-c1">2.1</span>,<span class="pl-c1">3.1</span>)) <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
data3d <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">zip</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">10</span>), <span class="pl-c1">rand</span>(<span class="pl-c1">10</span>), <span class="pl-c1">rand</span>(<span class="pl-c1">10</span>)))
<span class="pl-c1">b</span>(data3d; p<span class="pl-k">=</span>(x0<span class="pl-k">=</span><span class="pl-c1">1</span>, y0<span class="pl-k">=</span><span class="pl-c1">2</span>, z0<span class="pl-k">=</span><span class="pl-c1">3</span>, R0<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">1</span>) )  <span class="pl-c"><span class="pl-c">#</span> return a vector of 10 elements</span></pre></div>
<h2 dir="auto"><a id="user-content-plotting" class="anchor" aria-hidden="true" href="#plotting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Plotting</h2>
<p dir="auto">The function object can be plotted as a regular function,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f1 = FGauss((μ1=1.2, σ1=0.2))
plot(f1, 0, 5)"><pre>f1 <span class="pl-k">=</span> <span class="pl-c1">FGauss</span>((μ1<span class="pl-k">=</span><span class="pl-c1">1.2</span>, σ1<span class="pl-k">=</span><span class="pl-c1">0.2</span>))
<span class="pl-c1">plot</span>(f1, <span class="pl-c1">0</span>, <span class="pl-c1">5</span>)</pre></div>
<p dir="auto">It is replaced to a lambda function by the type recipe.</p>
<p dir="auto">For a PDF that has the limits, the plotting command will just work</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d1 = Normalized(FGauss((μ1=1.2, σ1=0.2)), (0,4))
plot(d1, l=(:orange,3),
    lab=&quot;FGauss(μ1=1.2, σ1=0.2)&quot;,
    title=&quot;Gaussian normalized in (0,4)&quot;)"><pre>d1 <span class="pl-k">=</span> <span class="pl-c1">Normalized</span>(<span class="pl-c1">FGauss</span>((μ1<span class="pl-k">=</span><span class="pl-c1">1.2</span>, σ1<span class="pl-k">=</span><span class="pl-c1">0.2</span>)), (<span class="pl-c1">0</span>,<span class="pl-c1">4</span>))
<span class="pl-c1">plot</span>(d1, l<span class="pl-k">=</span>(<span class="pl-c1">:orange</span>,<span class="pl-c1">3</span>),
    lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>FGauss(μ1=1.2, σ1=0.2)<span class="pl-pds">"</span></span>,
    title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Gaussian normalized in (0,4)<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">The <code>normalization</code> value other than unit can be passed with the plotting method</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="plot(d1, normalization=1.0, Nsample=100)"><pre><span class="pl-c1">plot</span>(d1, normalization<span class="pl-k">=</span><span class="pl-c1">1.0</span>, Nsample<span class="pl-k">=</span><span class="pl-c1">100</span>)</pre></div>
<p dir="auto">where <code>Nsample</code> is the number of points at which the function is sampled.</p>
<p dir="auto">Plotting recipe for 2d functions is defined.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@makefuntype Amazing2D(x;p) = (x[1]-p.x0)^2+(x[2]-p.y0)^2-p.R0^2
a = Amazing2D((x0=0.1, y0=-0.1, R0=0.0))
xv, yv = -1:0.1:2, -2:0.1:1
heatmap(xv, yv, updatepar(a, :x0, -0.5))
contour(xv, yv, log(abs2(a)))
surface(xv, yv, abs2(a))"><pre><span class="pl-c1">@makefuntype</span> <span class="pl-en">Amazing2D</span>(x;p) <span class="pl-k">=</span> (x[<span class="pl-c1">1</span>]<span class="pl-k">-</span>p<span class="pl-k">.</span>x0)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">-</span>p<span class="pl-k">.</span>y0)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span>p<span class="pl-k">.</span>R0<span class="pl-k">^</span><span class="pl-c1">2</span>
a <span class="pl-k">=</span> <span class="pl-c1">Amazing2D</span>((x0<span class="pl-k">=</span><span class="pl-c1">0.1</span>, y0<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">0.1</span>, R0<span class="pl-k">=</span><span class="pl-c1">0.0</span>))
xv, yv <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">1</span>
<span class="pl-c1">heatmap</span>(xv, yv, <span class="pl-c1">updatepar</span>(a, <span class="pl-c1">:x0</span>, <span class="pl-k">-</span><span class="pl-c1">0.5</span>))
<span class="pl-c1">contour</span>(xv, yv, <span class="pl-c1">log</span>(<span class="pl-c1">abs2</span>(a)))
<span class="pl-c1">surface</span>(xv, yv, <span class="pl-c1">abs2</span>(a))</pre></div>
<h2 dir="auto"><a id="user-content-sample-data-from-pdf" class="anchor" aria-hidden="true" href="#sample-data-from-pdf"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sample data from PDF</h2>
<p dir="auto">A data set distributed according a given model (<code>&lt;:AbstractFunctionWithParameter</code>, and defined limits)
can be generated using
a function <code>generate(model, N)</code> with <code>N</code> being the required number of events</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@makepdftype ExpAbs(x;p) = exp(-abs(x)/p.σ)
model = ExpAbs((σ=2.1,), (-3,2))
# 
data1 = generate(model, 1000)
data2 = generate(model, 1000; p=(σ=0.3,), Nbins=1000)"><pre><span class="pl-c1">@makepdftype</span> <span class="pl-en">ExpAbs</span>(x;p) <span class="pl-k">=</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">abs</span>(x)<span class="pl-k">/</span>p<span class="pl-k">.</span>σ)
model <span class="pl-k">=</span> <span class="pl-c1">ExpAbs</span>((σ<span class="pl-k">=</span><span class="pl-c1">2.1</span>,), (<span class="pl-k">-</span><span class="pl-c1">3</span>,<span class="pl-c1">2</span>))
<span class="pl-c"><span class="pl-c">#</span> </span>
data1 <span class="pl-k">=</span> <span class="pl-c1">generate</span>(model, <span class="pl-c1">1000</span>)
data2 <span class="pl-k">=</span> <span class="pl-c1">generate</span>(model, <span class="pl-c1">1000</span>; p<span class="pl-k">=</span>(σ<span class="pl-k">=</span><span class="pl-c1">0.3</span>,), Nbins<span class="pl-k">=</span><span class="pl-c1">1000</span>)</pre></div>
<p dir="auto">The inversion of the cdf is done numerically using the binning controlled by <code>Nbins</code> variable.
A set of parameters to be used can be passed as a key argument.
The function <code>rand</code> will also work:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="value = rand(model) # not efficient
data3 = rand(model, 1000) # same as generate(model, 1000)"><pre>value <span class="pl-k">=</span> <span class="pl-c1">rand</span>(model) <span class="pl-c"><span class="pl-c">#</span> not efficient</span>
data3 <span class="pl-k">=</span> <span class="pl-c1">rand</span>(model, <span class="pl-c1">1000</span>) <span class="pl-c"><span class="pl-c">#</span> same as generate(model, 1000)</span></pre></div>
<p dir="auto">however, a call for a single number in inefficient (the integral is not stored but computed every time),
the call with a set size does the same <code>generate</code> and does not take key arguments.
Currently, <code>generate</code> works only in one dimension.</p>
</article></div>