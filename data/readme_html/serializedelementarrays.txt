<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-serializedelementarrays" class="anchor" aria-hidden="true" href="#serializedelementarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SerializedElementArrays</h1>
<p dir="auto"><a href="https://mtfishman.github.io/SerializedElementArrays.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://mtfishman.github.io/SerializedElementArrays.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/mtfishman/SerializedElementArrays.jl/actions"><img src="https://github.com/mtfishman/SerializedElementArrays.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/mtfishman/SerializedElementArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/10f48497331f43f7f1a3fcf07951197b25acb3ad002778ad3bfc0cd0827bb0fa/68747470733a2f2f636f6465636f762e696f2f67682f6d74666973686d616e2f53657269616c697a6564456c656d656e744172726179732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/mtfishman/SerializedElementArrays.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://github.com/invenia/BlueStyle"><img src="https://camo.githubusercontent.com/c18fbaa52d94d16b90b19701fc90d289b8a5bb920c74c79bab200b14e75420a4/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c75652d3434393564312e737667" alt="Code Style: Blue" data-canonical-src="https://img.shields.io/badge/code%20style-blue-4495d1.svg" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Install with the Julia package manager with <code>import Pkg; Pkg.add("SerializedElementArrays")</code>.</p>
<h2 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h2>
<p dir="auto">This package introduces a function <code>disk</code> which transfers an <code>AbstractArray</code> in memory to one stored on disk, called a <code>SerializedElementArray</code>. The elements of the original array are serialized and by default are saved into individual files in a randomly generated directory inside the system's temporary directory. The aim of this package is to make it easier to perform calculations with collections of very large objects which collectively might not fit in memory and are not read and written very often during the calculation, and which are not necessarily needed long term after the calculation finishes. For more stable reading and writing across different versions of Julia, we recommend using packages like <code>HDF5</code>, <code>JLD</code>, or <code>JLD2</code>.</p>
<p dir="auto">For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SerializedElementArrays: disk, pathname

a = reshape(1:6, 2, 3)
d = disk(a)
@show d isa SerializedElementArrays.SerializedElementArray
@show a[1, 2]
@show d[1, 2]
@show readdir(pathname(d))
d[2, 2] = 3"><pre><span class="pl-k">using</span> SerializedElementArrays<span class="pl-k">:</span> disk, pathname

a <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">6</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
d <span class="pl-k">=</span> <span class="pl-c1">disk</span>(a)
<span class="pl-c1">@show</span> d <span class="pl-k">isa</span> SerializedElementArrays<span class="pl-k">.</span>SerializedElementArray
<span class="pl-c1">@show</span> a[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>]
<span class="pl-c1">@show</span> d[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>]
<span class="pl-c1">@show</span> <span class="pl-c1">readdir</span>(<span class="pl-c1">pathname</span>(d))
d[<span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">3</span></pre></div>
<p dir="auto">Normal array operations like <code>getindex</code> and <code>setindex!</code> work on <code>SerializedElementArray</code>s, but note that they involve reading from and writing to disk so will be much slower than the same operations for <code>Array</code>. Keep this in mind when using a <code>SerializedElementArray</code> and organize your code to minimizing accessing individual elements.</p>
<p dir="auto">To create an array stored on disk with undefined elements, <code>disk</code> accepts undefined <code>Array</code>s:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SerializedElementArrays: disk, pathname

a = Array{Matrix{Float64}}(undef, 2, 3)
d = disk(a)
@show isassigned(a, 1, 2)
@show isassigned(d, 1, 2)
@show readdir(pathname(d))
x = randn(5, 5)
d[1, 2] = x
@show x == d[1, 2]
@show readdir(pathname(d))"><pre><span class="pl-k">using</span> SerializedElementArrays<span class="pl-k">:</span> disk, pathname

a <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{Matrix{Float64}}</span>(undef, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
d <span class="pl-k">=</span> <span class="pl-c1">disk</span>(a)
<span class="pl-c1">@show</span> <span class="pl-c1">isassigned</span>(a, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">@show</span> <span class="pl-c1">isassigned</span>(d, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">@show</span> <span class="pl-c1">readdir</span>(<span class="pl-c1">pathname</span>(d))
x <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>)
d[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> x
<span class="pl-c1">@show</span> x <span class="pl-k">==</span> d[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>]
<span class="pl-c1">@show</span> <span class="pl-c1">readdir</span>(<span class="pl-c1">pathname</span>(d))</pre></div>
<p dir="auto">When initialized from undefined <code>Array</code>s, no files are created, but elements can be set which are then written to disk.</p>
<h2 dir="auto"><a id="user-content-memory-management" class="anchor" aria-hidden="true" href="#memory-management"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Memory management</h2>
<p dir="auto">Note that currently this package does not clear data from memory when it is stored on disk (such as in the above example, where an Array is first allocated in memory and then stored on disk). Freeing memory is handled by Julia's garbage collector. For memory to be cleared, it must become unreachable and then garbage collected. You can force this manually by assigning the Array (and any objects stored in the Array, as well as references to those objects) to an empty object such as <code>nothing</code> and then call <code>GC.gc()</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n = 1000
a11 = randn(n, n)
a12 = randn(n, n)
a21 = randn(n, n)
a22 = randn(n, n)
a = [a11 a12; a21 a22]
d = disk(a)
a11, a12, a21, a22 = nothing, nothing, nothing, nothing
a = nothing
GC.gc()"><pre>n <span class="pl-k">=</span> <span class="pl-c1">1000</span>
a11 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
a12 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
a21 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
a22 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
a <span class="pl-k">=</span> [a11 a12; a21 a22]
d <span class="pl-k">=</span> <span class="pl-c1">disk</span>(a)
a11, a12, a21, a22 <span class="pl-k">=</span> <span class="pl-c1">nothing</span>, <span class="pl-c1">nothing</span>, <span class="pl-c1">nothing</span>, <span class="pl-c1">nothing</span>
a <span class="pl-k">=</span> <span class="pl-c1">nothing</span>
GC<span class="pl-k">.</span><span class="pl-c1">gc</span>()</pre></div>
<p dir="auto">or wrap the assignment in a function (or some other local scope) such that there is no reference to the intermediate data being moved to disk outside of the function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function make_disk_array(n)
  a11 = randn(n, n)
  a12 = randn(n, n)
  a21 = randn(n, n)
  a22 = randn(n, n)
  a = [a11 a12; a21 a22]
  return disk(a)
end

make_disk_array(10^2)
GC.gc()"><pre><span class="pl-k">function</span> <span class="pl-en">make_disk_array</span>(n)
  a11 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a12 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a21 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a22 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a <span class="pl-k">=</span> [a11 a12; a21 a22]
  <span class="pl-k">return</span> <span class="pl-c1">disk</span>(a)
<span class="pl-k">end</span>

<span class="pl-c1">make_disk_array</span>(<span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">2</span>)
GC<span class="pl-k">.</span><span class="pl-c1">gc</span>()</pre></div>
<p dir="auto">Note that the explicit call to <code>GC.gc()</code> will be performed by Julia eventually and so is not strictly necessary, however it may be useful in situations where you are running out of memory and you want to force Julia to free memory to make more space for new allocations.</p>
<h3 dir="auto"><a id="user-content-experimental-automatic-memory-management" class="anchor" aria-hidden="true" href="#experimental-automatic-memory-management"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Experimental automatic memory management</h3>
<p dir="auto">Passing a function to <code>disk</code> which returns an <code>Array</code> will allow the memory to be automatically freed, for example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function big_array(n) 
  a11 = randn(n, n)
  a12 = randn(n, n)
  a21 = randn(n, n)
  a22 = randn(n, n)
  return [a11 a12; a21 a22]
end

n = 10^2
disk(() -&gt; big_array(n))

# Equivalently, the first argument
# is the function that returns the Array
# to be transferred to disk
# and the remaining arguments
# are the inputs to the function:
disk(big_array, n)"><pre><span class="pl-k">function</span> <span class="pl-en">big_array</span>(n) 
  a11 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a12 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a21 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a22 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  <span class="pl-k">return</span> [a11 a12; a21 a22]
<span class="pl-k">end</span>

n <span class="pl-k">=</span> <span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-c1">disk</span>(() <span class="pl-k">-&gt;</span> <span class="pl-c1">big_array</span>(n))

<span class="pl-c"><span class="pl-c">#</span> Equivalently, the first argument</span>
<span class="pl-c"><span class="pl-c">#</span> is the function that returns the Array</span>
<span class="pl-c"><span class="pl-c">#</span> to be transferred to disk</span>
<span class="pl-c"><span class="pl-c">#</span> and the remaining arguments</span>
<span class="pl-c"><span class="pl-c">#</span> are the inputs to the function:</span>
<span class="pl-c1">disk</span>(big_array, n)</pre></div>
<p dir="auto">By default this version of the function <code>disk</code> will call <code>GC.gc(false)</code> internally, which performs an incremental collection of only the "young" objects in memory.</p>
<p dir="auto">You can specify a full GC sweep with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="disk(big_array, n; full=true)"><pre><span class="pl-c1">disk</span>(big_array, n; full<span class="pl-k">=</span><span class="pl-c1">true</span>)</pre></div>
<p dir="auto">or turn off the call to <code>GC.gc</code> with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="disk(big_array, n; force_gc=false)"><pre><span class="pl-c1">disk</span>(big_array, n; force_gc<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto">in which case memory will be freed automatically by Julia at some later time instead of internally in the <code>disk</code> function.</p>
<p dir="auto">The version of <code>disk</code> described above, which takes a function as input, allows usage of the do-block syntax:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n = 10^2
disk(n) do n
  a11 = randn(n, n)
  a12 = randn(n, n)
  a21 = randn(n, n)
  a22 = randn(n, n)
  return [a11 a12; a21 a22]
end"><pre>n <span class="pl-k">=</span> <span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-c1">disk</span>(n) <span class="pl-k">do</span> n
  a11 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a12 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a21 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  a22 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, n)
  <span class="pl-k">return</span> [a11 a12; a21 a22]
<span class="pl-k">end</span></pre></div>
<p dir="auto">where the anonymous function defined by the <code>do...end</code> block is implicitly passed as the first argument to <code>disk</code>.</p>
<h2 dir="auto"><a id="user-content-file-locations" class="anchor" aria-hidden="true" href="#file-locations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File locations</h2>
<p dir="auto">Internally, files are written to a path in the system's temporary directory created by <code>tempname()</code>. In Julia 1.4 and later, the files are cleaned up once the Julia process finishes (see the Julia documentation for <a href="https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.tempname" rel="nofollow">tempname</a>). You can use <code>disk(a; cleanup=false)</code> to keep the files after the process ends. However, note that because serialization is used (with the standard library module <a href="https://docs.julialang.org/en/v1/stdlib/Serialization/" rel="nofollow">Serialization</a>), in general it is not guaranteed that the files can be read and written by different versions of Julia, or an instance of Julia with a different system image.</p>
<h2 dir="auto"><a id="user-content-future-plans" class="anchor" aria-hidden="true" href="#future-plans"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Future plans</h2>
<ul dir="auto">
<li>Automate caching of recently accessed elements to speed up repeated access of the same elements. This could use something like <a href="https://github.com/JuliaCollections/LRUCache.jl">LRUCache.jl</a>.</li>
<li>Make a dictionary interface through a type <code>SerializedElementDict</code>. A design question would be if the file structure should be "nested" or "shallow", i.e. when saving nested dictionaries, should the dictionaries themselves be serialized and saved to files or should the individual elements of the nested dictionaries be saved to files?</li>
</ul>
<h2 dir="auto"><a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related packages:</h2>
<ul dir="auto">
<li><a href="https://github.com/beacon-biosignals/SerializationCaches.jl">SerializationCaches.jl</a></li>
</ul>
</article></div>