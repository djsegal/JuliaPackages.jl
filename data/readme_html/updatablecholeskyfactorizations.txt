<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-updatablecholeskyfactorizationsjl" class="anchor" aria-hidden="true" href="#updatablecholeskyfactorizationsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>UpdatableCholeskyFactorizations.jl</h1>
<p dir="auto"><a href="https://github.com/SebastianAment/UpdatableCholeskyFactorizations.jl/actions/workflows/CI.yml"><img src="https://github.com/SebastianAment/UpdatableCholeskyFactorizations.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/SebastianAment/UpdatableCholeskyFactorizations.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/baf77644ce9d775508be353c749b09a15da5c2b67f1acde425eef1a6d09a7f97/68747470733a2f2f636f6465636f762e696f2f67682f53656261737469616e416d656e742f557064617461626c6543686f6c65736b79466163746f72697a6174696f6e732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d384c3439493238493733" alt="codecov" data-canonical-src="https://codecov.io/gh/SebastianAment/UpdatableCholeskyFactorizations.jl/branch/main/graph/badge.svg?token=8L49I28I73" style="max-width: 100%;"></a></p>
<p dir="auto">This package contains implementations of efficient representations and updating algorithms for Cholesky factorizations.
Compared to constructing Cholesky factorizations from scratch, this package can lead to significant speed improvements, see the benchmarks below.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">To install the package, type <code>]</code> and subsequently, <code>add UpdatableCholeskyFactorizations</code> in the Julia REPL.</p>
<h2 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic Usage</h2>
<p dir="auto">The package exports the <code>UpdatableCholesky</code> type, which can also be referenced as <code>UCholesky</code>.
A structure of this type can be computed using the function</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="updatable_cholesky(A::AbstractMatrix, m::Int = 2size(A, 1); check::Bool = true),"><pre><span class="pl-c1">updatable_cholesky</span>(A<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix</span>, m<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-c1">size</span>(A, <span class="pl-c1">1</span>); check<span class="pl-k">::</span><span class="pl-c1">Bool</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>),</pre></div>
<p dir="auto">which computes an updatable Cholesky factorization starting with the <code>n x n</code> matrix <code>A</code>,
and pre-allocates an <code>m x m</code> matrix for future additions to the matrix (defaults to twice the size <code>2n</code>).
Given an <code>UpdatableCholesky</code> structure,
we can use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add_column!(C::UpdatableCholesky, A::AbstractMatrix)"><pre><span class="pl-c1">add_column!</span>(C<span class="pl-k">::</span><span class="pl-c1">UpdatableCholesky</span>, A<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix</span>)</pre></div>
<p dir="auto">to append columns in A - and their corresponding rows A' - to <code>UpdatableCholesky</code> factorization <code>C</code>. Complexity is <code>O(m³ + n²m)</code> where <code>n = size(C, 1)</code> and <code>m = size(A, 2)</code>.
To remove a column from <code>C</code>,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="remove_column!(C::UpdatableCholesky, i::Int)"><pre><span class="pl-c1">remove_column!</span>(C<span class="pl-k">::</span><span class="pl-c1">UpdatableCholesky</span>, i<span class="pl-k">::</span><span class="pl-c1">Int</span>)</pre></div>
<p dir="auto">updates the <code>UpdatableCholesky</code> factorization <code>C</code> corresponding to removal of the
<code>i</code>th row and column of the original matrix. Complexity is <code>O(n²)</code>, where <code>n = size(C, 1)</code>.
See the following example.</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra
using UpdatableCholeskyFactorizations

# setting up
n = 128
m = 16
A_full = randn(2n, 2n)
A_full = A_full'A_full
A = A_full[1:n, 1:n]
a = A_full[1:n+1, n+1]
Bm = A_full[1:n+m, n+1:n+m] # m columns

C = updatable_cholesky(A) # computing a factorization of A

add_column!(C, a) # appends the column a to the factorization, C is now a factorization of A_full[1:n+1, 1:n+1]

remove_column!(C, n+1) # removes the (n+1)st column from the factorization, C is now a factorization of A_full[1:n, 1:n]

add_column!(C, Bm) # appends the m columns in Bm to the factorization, C is now a factorization of A_full[1:n+m, 1:n+m]
"><pre><span class="pl-k">using</span> LinearAlgebra
<span class="pl-k">using</span> UpdatableCholeskyFactorizations

<span class="pl-c"><span class="pl-c">#</span> setting up</span>
n <span class="pl-k">=</span> <span class="pl-c1">128</span>
m <span class="pl-k">=</span> <span class="pl-c1">16</span>
A_full <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">2</span>n, <span class="pl-c1">2</span>n)
A_full <span class="pl-k">=</span> A_full<span class="pl-k">'</span>A_full
A <span class="pl-k">=</span> A_full[<span class="pl-c1">1</span><span class="pl-k">:</span>n, <span class="pl-c1">1</span><span class="pl-k">:</span>n]
a <span class="pl-k">=</span> A_full[<span class="pl-c1">1</span><span class="pl-k">:</span>n<span class="pl-k">+</span><span class="pl-c1">1</span>, n<span class="pl-k">+</span><span class="pl-c1">1</span>]
Bm <span class="pl-k">=</span> A_full[<span class="pl-c1">1</span><span class="pl-k">:</span>n<span class="pl-k">+</span>m, n<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span>n<span class="pl-k">+</span>m] <span class="pl-c"><span class="pl-c">#</span> m columns</span>

C <span class="pl-k">=</span> <span class="pl-c1">updatable_cholesky</span>(A) <span class="pl-c"><span class="pl-c">#</span> computing a factorization of A</span>

<span class="pl-c1">add_column!</span>(C, a) <span class="pl-c"><span class="pl-c">#</span> appends the column a to the factorization, C is now a factorization of A_full[1:n+1, 1:n+1]</span>

<span class="pl-c1">remove_column!</span>(C, n<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> removes the (n+1)st column from the factorization, C is now a factorization of A_full[1:n, 1:n]</span>

<span class="pl-c1">add_column!</span>(C, Bm) <span class="pl-c"><span class="pl-c">#</span> appends the m columns in Bm to the factorization, C is now a factorization of A_full[1:n+m, 1:n+m]</span>
</pre></div>
<h2 dir="auto"><a id="user-content-efficiency" class="anchor" aria-hidden="true" href="#efficiency"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Efficiency</h2>
<p dir="auto">The following benchmarks highlight the performance benefits that updating a Cholesky factorization can have over constructing a new factorization from scratch.
First, we report the performance of <code>LinearAlgebra</code>'s <code>cholesky</code> on two matrix sizes.
The code for the following benchmarks can be found in examples/benchmarks.jl.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="128 by 128 cholesky
BenchmarkTools.TrialEstimate:
  time:             49.125 μs
  gctime:           0.000 ns (0.00%)
  memory:           128.05 KiB
  allocs:           2

256 by 256 cholesky
BenchmarkTools.TrialEstimate:
  time:             188.875 μs
  gctime:           0.000 ns (0.00%)
  memory:           512.05 KiB
  allocs:           2"><pre><span class="pl-c1">128</span> by <span class="pl-c1">128</span> cholesky
BenchmarkTools<span class="pl-k">.</span>TrialEstimate<span class="pl-k">:</span>
  time<span class="pl-k">:</span>             <span class="pl-c1">49.125</span> μs
  gctime<span class="pl-k">:</span>           <span class="pl-c1">0.000</span> ns (<span class="pl-c1">0.00</span><span class="pl-k">%</span>)
  memory<span class="pl-k">:</span>           <span class="pl-c1">128.05</span> KiB
  allocs<span class="pl-k">:</span>           <span class="pl-c1">2</span>

<span class="pl-c1">256</span> by <span class="pl-c1">256</span> cholesky
BenchmarkTools<span class="pl-k">.</span>TrialEstimate<span class="pl-k">:</span>
  time<span class="pl-k">:</span>             <span class="pl-c1">188.875</span> μs
  gctime<span class="pl-k">:</span>           <span class="pl-c1">0.000</span> ns (<span class="pl-c1">0.00</span><span class="pl-k">%</span>)
  memory<span class="pl-k">:</span>           <span class="pl-c1">512.05</span> KiB
  allocs<span class="pl-k">:</span>           <span class="pl-c1">2</span></pre></div>
<p dir="auto">Now, compare this to this package's <code>updatable_cholesky</code> and <code>add_column!</code> functions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="128 by 128 updatable_cholesky
BenchmarkTools.TrialEstimate:
  time:             66.500 μs
  gctime:           0.000 ns (0.00%)
  memory:           512.08 KiB
  allocs:           3

adding vector to 128 by 128 UpdatableCholesky
BenchmarkTools.TrialEstimate:
  time:             3.000 μs
  gctime:           0.000 ns (0.00%)
  memory:           96 bytes
  allocs:           2

adding 16 vectors to 128 by 128 UpdatableCholesky
BenchmarkTools.TrialEstimate:
  time:             25.375 μs
  gctime:           0.000 ns (0.00%)
  memory:           0 bytes
  allocs:           0"><pre><span class="pl-c1">128</span> by <span class="pl-c1">128</span> updatable_cholesky
BenchmarkTools<span class="pl-k">.</span>TrialEstimate<span class="pl-k">:</span>
  time<span class="pl-k">:</span>             <span class="pl-c1">66.500</span> μs
  gctime<span class="pl-k">:</span>           <span class="pl-c1">0.000</span> ns (<span class="pl-c1">0.00</span><span class="pl-k">%</span>)
  memory<span class="pl-k">:</span>           <span class="pl-c1">512.08</span> KiB
  allocs<span class="pl-k">:</span>           <span class="pl-c1">3</span>

adding vector to <span class="pl-c1">128</span> by <span class="pl-c1">128</span> UpdatableCholesky
BenchmarkTools<span class="pl-k">.</span>TrialEstimate<span class="pl-k">:</span>
  time<span class="pl-k">:</span>             <span class="pl-c1">3.000</span> μs
  gctime<span class="pl-k">:</span>           <span class="pl-c1">0.000</span> ns (<span class="pl-c1">0.00</span><span class="pl-k">%</span>)
  memory<span class="pl-k">:</span>           <span class="pl-c1">96</span> bytes
  allocs<span class="pl-k">:</span>           <span class="pl-c1">2</span>

adding <span class="pl-c1">16</span> vectors to <span class="pl-c1">128</span> by <span class="pl-c1">128</span> UpdatableCholesky
BenchmarkTools<span class="pl-k">.</span>TrialEstimate<span class="pl-k">:</span>
  time<span class="pl-k">:</span>             <span class="pl-c1">25.375</span> μs
  gctime<span class="pl-k">:</span>           <span class="pl-c1">0.000</span> ns (<span class="pl-c1">0.00</span><span class="pl-k">%</span>)
  memory<span class="pl-k">:</span>           <span class="pl-c1">0</span> bytes
  allocs<span class="pl-k">:</span>           <span class="pl-c1">0</span></pre></div>
<p dir="auto">The construction of the <code>UpdatableCholesky</code> structure tends to be slightly slower - 30% in the example above - than <code>cholesky</code> for a given size,
and by default, consumes as much memory as a cholesky factorization of twice the size, in order to accomodate future column additions without requiring additional memory allocations.
However, subsequently updating a factorization is then much faster than computing another factorization from scratch and does not require additional allocations.
In the benchmarks above, adding a vector to the 128 by 128 factorization is ~<strong>16 times faster</strong>,
and adding 16 vectors is ~<strong>2 times faster</strong> than calling <code>cholesky</code>.
The time advantage grows with increasing <code>n</code>.
The benchmarks were computed on a 2021 MacBook Pro with an M1 Pro and 32 GB of RAM.</p>
<h2 dir="auto"><a id="user-content-future-work" class="anchor" aria-hidden="true" href="#future-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Future Work</h2>
<p dir="auto">Currently, the package only supports appending columns. Future work could add support for adding columns at arbitrary indices.</p>
</article></div>