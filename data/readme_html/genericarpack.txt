<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-genericarpackjl" class="anchor" aria-hidden="true" href="#genericarpackjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GenericArpack.jl</h1>
<p dir="auto"><a href="https://dgleich.github.io/GenericArpack.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/dgleich/GenericArpack.jl/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/dgleich/GenericArpack.jl/actions/workflows/test.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/dgleich/GenericArpack.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/aab2b1e20af8006d39107a7f1146bfcecdd7a60d1b412fceb532617dd0dfa2b4/68747470733a2f2f636f6465636f762e696f2f67682f64676c656963682f47656e6572696341727061636b2e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d36524359435739354658" alt="codecov" data-canonical-src="https://codecov.io/gh/dgleich/GenericArpack.jl/branch/main/graph/badge.svg?token=6RCYCW95FX" style="max-width: 100%;"></a></p>
<p dir="auto">This is a pure-Julia translation of the Arpack library. As such, it works
with generic real-valued types in Julia. It's only dependency is <code>LinearAlgebra.jl</code>
in the standard library and includes self-contained BLAS routines for the generic
tools it requires. <strong>Currently, only the symmetric Arpack solver is implemented.</strong></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using GenericArpack
using DoubleFloats
A = Symmetric(sprand(Double64, 100000, 100000, 5/100000) |&gt; A -&gt; A + A')
... 
julia&gt; eigs(A, 2; ncv=12)
GenericArpack.ArpackEigen{...}
eigenspace: LM
values:
2-element Vector{Double64}:
 -4.156547290415474
  5.757828927650802
..."><pre class="notranslate"><code>using GenericArpack
using DoubleFloats
A = Symmetric(sprand(Double64, 100000, 100000, 5/100000) |&gt; A -&gt; A + A')
... 
julia&gt; eigs(A, 2; ncv=12)
GenericArpack.ArpackEigen{...}
eigenspace: LM
values:
2-element Vector{Double64}:
 -4.156547290415474
  5.757828927650802
...
</code></pre></div>
<p dir="auto">The library also supports mixed precision, although, this needs to be used carefully.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; eigs(Float16, Float64, A, 2; ncv=12) # use Float16 for vectors, Float64 for Arnoldi info, Double64 for A
values:
2-element Vector{Float64}:
 -5.043265045062479
  6.522275837391058"><pre class="notranslate"><code>julia&gt; eigs(Float16, Float64, A, 2; ncv=12) # use Float16 for vectors, Float64 for Arnoldi info, Double64 for A
values:
2-element Vector{Float64}:
 -5.043265045062479
  6.522275837391058
</code></pre></div>
<p dir="auto">The library is better used with use higher precision types, like Double64, although Float32 work okay.
See below for some notes on using higher-precision types.</p>
<p dir="auto">Because it was fairly trivial to do in Julia, <code>GenericArpack.jl</code> also has a specialized Hermitian eigensolver.
This has had more limited testing, but should work for many cases. This is useful because it gives a
complex-valued SVD without using the non-symmetric solver as in <code>Arpack.jl</code>.</p>
<p dir="auto">See also the packages</p>
<ul dir="auto">
<li><a href="https://github.com/JuliaLinearAlgebra/Arpack.jl">Arpack.jl</a></li>
<li><a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit.jl</a></li>
<li><a href="https://github.com/haampie/ArnoldiMethod.jl">ArnoldiMethod.jl</a></li>
</ul>
<h1 dir="auto"><a id="user-content-rationale" class="anchor" aria-hidden="true" href="#rationale"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Rationale</h1>
<p dir="auto">The compiled Arpack library has been wrapped in Julia for a long time. Why do we need this <em>translation</em>
of the library into Julia? Here's the rationale:</p>
<ul dir="auto">
<li>available with minimal dependencies; no need for a Fortran compiler on a new platform</li>
<li>multithread safe (the Fortran Arpack code will segfault if called from multiple threads because
it uses static variables that are not allocated to each thread )</li>
</ul>
<p dir="auto">Of course, the downside at the moment is that the non-symmetric and non-Hermitian cases aren't yet translated.
This will require a fair amount of dedicated effort, although everything has been prototyped and there is
a path do it.</p>
<h1 dir="auto"><a id="user-content-key-functionality" class="anchor" aria-hidden="true" href="#key-functionality"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Key Functionality</h1>
<p dir="auto">Arpack has a tremendous amount of functionality. Right now, only the symmetric (and by Julia magic, the new Hermitian)
solvers are implemented. See below for more on the list of functionality. Not everything has been testing, but</p>
<ul dir="auto">
<li>Real Symmetric, Generalized Symmetric, Shift and Invert, with mixed/high precision</li>
<li>Complex Hermitian, Generalized Symmetric, Shift and Invert, with mixed/high precision</li>
<li>Real and Complex SVD via the Normal equations with mixed/high precision.</li>
<li>Smallest singular subspace estimation.</li>
</ul>
<h2 dir="auto"><a id="user-content-more-details-on-functionality" class="anchor" aria-hidden="true" href="#more-details-on-functionality"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>More details on functionality</h2>
<p dir="auto">The Arpack symmetric eigensolver functionality is all here and this is ported
in its entirety. No work has yet been done on the non-symmetric eigensolver (yet).
Right now,</p>
<table>
<thead>
<tr>
<th>Status</th>
<th>Information</th>
</tr>
</thead>
<tbody>
<tr>
<td>post-beta</td>
<td>Most cases should work, there may be edge cases</td>
</tr>
<tr>
<td>beta</td>
<td>A few edges cases are likely to appear</td>
</tr>
<tr>
<td>alpha</td>
<td>Limited testing, simple things will probably work</td>
</tr>
<tr>
<td>pre-alpha</td>
<td>Limited or virtually no testing, likely to have issues</td>
</tr>
<tr>
<td>coded</td>
<td>No idea, but the code is there.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Functionality</th>
<th>Types</th>
<th>Status</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>simple real symmetric eigenvalues</td>
<td>Float64</td>
<td>post-beta</td>
<td>Bitwise matches arpack_jll</td>
</tr>
<tr>
<td>generalized real symmetric eigenvalues</td>
<td>Float64</td>
<td>beta</td>
<td>Bitwise matches arpack_jll</td>
</tr>
<tr>
<td>singular value decomposition</td>
<td>Float64</td>
<td>beta</td>
<td>Uses normal equations, sorry Gene</td>
</tr>
<tr>
<td>simple shift-invert symmetric eigenvalues</td>
<td>Float64</td>
<td>pre-alpha</td>
<td>not yet tested</td>
</tr>
<tr>
<td>generalized shift-invert symmetric eigenvalues</td>
<td>Float64</td>
<td>pre-alpha</td>
<td>not yet tested</td>
</tr>
<tr>
<td>generalized buckle symmetric eigenvalues</td>
<td>Float64</td>
<td>pre-alpha</td>
<td>not yet tested</td>
</tr>
<tr>
<td>generalized cayley symmetric eigenvalues</td>
<td>Float64</td>
<td>pre-alpha</td>
<td>not yet tested</td>
</tr>
<tr>
<td><strong>Complex</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>simple complex hermitian eigenvalues</td>
<td>ComplexF64</td>
<td>alpha</td>
<td>no specialized solver in Arpack.jl</td>
</tr>
<tr>
<td>generalized complex hermitian eigenvalues</td>
<td>ComplexF64</td>
<td>alpha</td>
<td></td>
</tr>
<tr>
<td>complex singular value decomposition</td>
<td>ComplexF64</td>
<td>alpha</td>
<td></td>
</tr>
<tr>
<td><strong>High precision</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>simple real symmetric eigenvalues</td>
<td>Double64, Float64x2, etc</td>
<td>alpha</td>
<td>no specialized solver in Arpack.jl</td>
</tr>
<tr>
<td>generalized real symmetric eigenvalues</td>
<td>Double64, Float64x2, etc</td>
<td>alpha</td>
<td></td>
</tr>
<tr>
<td>singular value decomposition</td>
<td>Double64, Float64x2, etc</td>
<td>alpha</td>
<td></td>
</tr>
<tr>
<td><strong>Mixed type</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>all previous cases</td>
<td>Allows Mixed Types</td>
<td>alpha</td>
<td>no specialized solver in Arpack.jl</td>
</tr>
<tr>
<td><strong>Exotic features</strong></td>
<td></td>
<td>--------</td>
<td></td>
</tr>
<tr>
<td>user-computed shifts</td>
<td></td>
<td>coded</td>
<td></td>
</tr>
<tr>
<td>shift invert, buckling, cayley</td>
<td>ComplexF64, Float64</td>
<td>coded</td>
<td></td>
</tr>
<tr>
<td>shift invert, buckling, cayley</td>
<td>high-precision</td>
<td>coded</td>
<td></td>
</tr>
</tbody>
</table>
<h2 dir="auto"><a id="user-content-using-high-precision-types" class="anchor" aria-hidden="true" href="#using-high-precision-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using high-precision types</h2>
<p dir="auto"><code>GenericArpack.jl</code> is taxing in the extensive use of floating point thresholds. Sometimes these
are not always perfectly supported by auxilary packages.</p>
<h3 dir="auto"><a id="user-content-quadmathjl" class="anchor" aria-hidden="true" href="#quadmathjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>Quadmath.jl</code></h3>
<p dir="auto">This works directly without modification for <code>Quadmath.jl</code>, although note that
many operations in <code>Quadmath.jl</code> allocate whereas those in the libraries below
do not. For instance, <code>generic_matvecmul!</code> on a matrix with <code>Float128</code> will allocate in some
calls.</p>
<h3 dir="auto"><a id="user-content-doublefloatsjl" class="anchor" aria-hidden="true" href="#doublefloatsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>DoubleFloats.jl</code></h3>
<p dir="auto">You can make using <code>Double64</code> types about 1.5x faster by giving it two constants. This is what our fix does.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using DoubleFloats
GenericArpack.@fix_doublefloats"><pre class="notranslate"><code>using DoubleFloats
GenericArpack.@fix_doublefloats
</code></pre></div>
<p dir="auto">To see what is executed, run <code>@macroexpand GenericArpack.@fix_doublefloats</code>. This defines:</p>
<ul dir="auto">
<li><code>LinearAlgebra.floatmin2</code> and</li>
<li><code>maxit</code> for the eigenvalue computation</li>
</ul>
<h3 dir="auto"><a id="user-content-multifloatsjl" class="anchor" aria-hidden="true" href="#multifloatsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>MultiFloats.jl</code></h3>
<p dir="auto">Make sure to execute</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using MultiFloats
GenericArpack.@fix_multifloats"><pre class="notranslate"><code>using MultiFloats
GenericArpack.@fix_multifloats
</code></pre></div>
<p dir="auto">To see what is executed, run <code>@macroexpand GenericArpack.@fix_multifloats</code>. This defines:</p>
<ul dir="auto">
<li><code>_eps23</code> for each <code>MultiFloat</code> type.</li>
<li><code>maxit</code> for the eigenvalue computation</li>
<li><code>Int(x::MultiFloat)</code></li>
</ul>
<h2 dir="auto"><a id="user-content-history" class="anchor" aria-hidden="true" href="#history"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>History</h2>
<p dir="auto">This started as a "me-project" to work on to I can learn something and see how various ideas work.</p>
<p dir="auto">The goal of this exercise is to port the double-precision ARPACK
for symmetric matrices in Julia. Including all ARPACK stuff. So this should
give "exactly" what ARPACK does but be a pure Julia implementation.
(Where exactly is ... it should be executing roughly the same sequence of
floating point operations and can differ on levels that would be expected
for different compilers compiling the same code.)</p>
<ul dir="auto">
<li>not a goal to "Julia-ize" the package; I want to keep as close to the FORTRAN
as possible so that I might be able to replace calls to Julia's Arpack.saupd /
Arpack.seupd (which call the Fortran library) with this code;
while this is possible, it was easier to use new features from <code>GenericArpack.jl</code>
to implement superior interfaces.</li>
<li>small internal function changes are okay, e.g. ARPACK has various debugging
and timing stuff that would need to be done differently in Julia.</li>
<li>small simplifications, e.g. if a function computes a single Int, we can
rewrite that to return the Int rather than writing it into an array like in
FORTRAN.</li>
<li>Why? Why not implement my own ImplicitRestart/Eigensolver/Etc.? Simple: I trust
ARPACK. Also, I want to understand exactly what the symmetric ARPACK solver is doing.</li>
<li>Why not use a Fortran-&gt;Julia compiler? Well, I could. But I could also do
this and learn intimate details of how it works to help out in teaching :)</li>
<li>I want to document some of the cool stuff in ARPACK!</li>
</ul>
<p dir="auto">Along the way, it seemed like in many cases it was possible to get
<em>bitwise equivalent floating point</em> results for Float64 types. So
we seek to do that or understand why it is not possible.</p>
</article></div>