<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-differentiablefactorizations" class="anchor" aria-hidden="true" href="#differentiablefactorizations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DifferentiableFactorizations</h1>
<p dir="auto"><a href="https://github.com/mohamed82008/DifferentiableFactorizations.jl/actions"><img src="https://github.com/mohamed82008/DifferentiableFactorizations.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/mohamed82008/DifferentiableFactorizations.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c3b438a1d8dafb00182e5ff4647ea66d9d87ad8834aceab08c5d035170b0aa5c/68747470733a2f2f636f6465636f762e696f2f67682f6d6f68616d656438323030382f446966666572656e746961626c65466163746f72697a6174696f6e732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/mohamed82008/DifferentiableFactorizations.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package contains a bunch of differentiable matrix factorizations differentiated using the implicit function theorem as implemented in <a href="https://github.com/gdalle/ImplicitDifferentiation.jl"><code>ImplicitDifferentiation.jl</code></a>. The derivatives computed are only correct if the <strong>computed</strong> factorization of the matrix is unique and differentiable. If the implementation does not guarantee uniqueness and differentiability, the solution reported cannot be trusted. Theoretically in some cases, the factorization may only be unique up to a permutation or a sign flip. In those cases if the implementation guarantees a unique and differentiable output, the derivatives reported are still valid. This can be experimentally tested by comparing against finite difference.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(url=&quot;https://github.com/mohamed82008/DifferentiableFactorizations.jl&quot;)
Pkg.add(&quot;Zygote&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(url<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>https://github.com/mohamed82008/DifferentiableFactorizations.jl<span class="pl-pds">"</span></span>)
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>Zygote<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-loading" class="anchor" aria-hidden="true" href="#loading"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Loading</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DifferentiableFactorizations, Zygote, LinearAlgebra"><pre><span class="pl-k">using</span> DifferentiableFactorizations, Zygote, LinearAlgebra</pre></div>
<h2 dir="auto"><a id="user-content-cholesky-factorization" class="anchor" aria-hidden="true" href="#cholesky-factorization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Cholesky factorization</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 3)

# Forward pass: A = L * L' or A = U' * U (i.e. L' == U)
(; L, U) = diff_cholesky(A' * A + 2I)

# Differentiation
f(A) = diff_cholesky(A' * A + 2I).L
zjac = Zygote.jacobian(f, A)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: A = L * L' or A = U' * U (i.e. L' == U)</span>
(; L, U) <span class="pl-k">=</span> <span class="pl-c1">diff_cholesky</span>(A<span class="pl-k">'</span> <span class="pl-k">*</span> A <span class="pl-k">+</span> <span class="pl-c1">2</span>I)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(A) <span class="pl-k">=</span> <span class="pl-c1">diff_cholesky</span>(A<span class="pl-k">'</span> <span class="pl-k">*</span> A <span class="pl-k">+</span> <span class="pl-c1">2</span>I)<span class="pl-k">.</span>L
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, A)[<span class="pl-c1">1</span>]</pre></div>
<h2 dir="auto"><a id="user-content-lu-factorization" class="anchor" aria-hidden="true" href="#lu-factorization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LU factorization</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 3)

# Forward pass: A[p, :] = L * U for a permutation vector p
(; L, U, p) = diff_lu(A)

# Differentiation
f(A) = vec(diff_lu(A).U)
zjac = Zygote.jacobian(f, A)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: A[p, :] = L * U for a permutation vector p</span>
(; L, U, p) <span class="pl-k">=</span> <span class="pl-c1">diff_lu</span>(A)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(A) <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">diff_lu</span>(A)<span class="pl-k">.</span>U)
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, A)[<span class="pl-c1">1</span>]</pre></div>
<h2 dir="auto"><a id="user-content-qr-factorization" class="anchor" aria-hidden="true" href="#qr-factorization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>QR factorization</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 2)

# Forward pass: A = Q * R
(; Q, R) = diff_qr(A)

# Differentiation
f(A) = vec(diff_qr(A).Q)
zjac = Zygote.jacobian(f, A)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">2</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: A = Q * R</span>
(; Q, R) <span class="pl-k">=</span> <span class="pl-c1">diff_qr</span>(A)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(A) <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">diff_qr</span>(A)<span class="pl-k">.</span>Q)
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, A)[<span class="pl-c1">1</span>]</pre></div>
<h2 dir="auto"><a id="user-content-singular-value-decomposition-svd" class="anchor" aria-hidden="true" href="#singular-value-decomposition-svd"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Singular value decomposition (SVD)</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 2)

# Forward pass: A = U * Diagonal(S) * V'
(; U, S, V) = diff_svd(A)

# Differentiation
f(A) = vec(diff_svd(A).U)
zjac = Zygote.jacobian(f, A)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">2</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: A = U * Diagonal(S) * V'</span>
(; U, S, V) <span class="pl-k">=</span> <span class="pl-c1">diff_svd</span>(A)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(A) <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">diff_svd</span>(A)<span class="pl-k">.</span>U)
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, A)[<span class="pl-c1">1</span>]</pre></div>
<h2 dir="auto"><a id="user-content-eigenvalue-decomposition" class="anchor" aria-hidden="true" href="#eigenvalue-decomposition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Eigenvalue decomposition</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 3)

# Forward pass: `s` are the eigenvalues and `V` are the eigenvectors
(; s, V) = diff_eigen(A' * A)

# Differentiation
f(A) = vec(diff_eigen(A' * A).s)
zjac = Zygote.jacobian(f, A)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: `s` are the eigenvalues and `V` are the eigenvectors</span>
(; s, V) <span class="pl-k">=</span> <span class="pl-c1">diff_eigen</span>(A<span class="pl-k">'</span> <span class="pl-k">*</span> A)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(A) <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">diff_eigen</span>(A<span class="pl-k">'</span> <span class="pl-k">*</span> A)<span class="pl-k">.</span>s)
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, A)[<span class="pl-c1">1</span>]</pre></div>
<h2 dir="auto"><a id="user-content-generalized-eigenvalue-decomposition" class="anchor" aria-hidden="true" href="#generalized-eigenvalue-decomposition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Generalized eigenvalue decomposition</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 3)
B = rand(3, 3)

# Forward pass: `s` are the eigenvalues and `V` are the eigenvectors
(; s, V) = diff_eigen(A' * A, B' * B + 2I)

# Differentiation
f(B) = vec(diff_eigen(A' * A, B' * B + 2I).V)
zjac = Zygote.jacobian(f, B)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)
B <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: `s` are the eigenvalues and `V` are the eigenvectors</span>
(; s, V) <span class="pl-k">=</span> <span class="pl-c1">diff_eigen</span>(A<span class="pl-k">'</span> <span class="pl-k">*</span> A, B<span class="pl-k">'</span> <span class="pl-k">*</span> B <span class="pl-k">+</span> <span class="pl-c1">2</span>I)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(B) <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">diff_eigen</span>(A<span class="pl-k">'</span> <span class="pl-k">*</span> A, B<span class="pl-k">'</span> <span class="pl-k">*</span> B <span class="pl-k">+</span> <span class="pl-c1">2</span>I)<span class="pl-k">.</span>V)
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, B)[<span class="pl-c1">1</span>]</pre></div>
<h2 dir="auto"><a id="user-content-schur-decomposition" class="anchor" aria-hidden="true" href="#schur-decomposition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Schur decomposition</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 3)

# Forward pass: Z * T * Z' ≈ A + A'
(; Z, T) = diff_schur(A + A')

# Differentiation
f(A) = vec(diff_schur(A + A').T)
zjac = Zygote.jacobian(f, A)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: Z * T * Z' ≈ A + A'</span>
(; Z, T) <span class="pl-k">=</span> <span class="pl-c1">diff_schur</span>(A <span class="pl-k">+</span> A<span class="pl-k">'</span>)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(A) <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">diff_schur</span>(A <span class="pl-k">+</span> A<span class="pl-k">'</span>)<span class="pl-k">.</span>T)
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, A)[<span class="pl-c1">1</span>]</pre></div>
<h2 dir="auto"><a id="user-content-generalized-schur-decomposition" class="anchor" aria-hidden="true" href="#generalized-schur-decomposition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Generalized Schur decomposition</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = rand(3, 3)
B = rand(3, 3)

# Forward pass: left * S * right' ≈ A + A' and left * T * right' ≈ B + B'
(; left, right, S, T) = diff_schur(A + A', B + B')

# Differentiation
f(B) = vec(diff_schur(A + A', B + B').T)
zjac = Zygote.jacobian(f, B)[1]"><pre>A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)
B <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> Forward pass: left * S * right' ≈ A + A' and left * T * right' ≈ B + B'</span>
(; left, right, S, T) <span class="pl-k">=</span> <span class="pl-c1">diff_schur</span>(A <span class="pl-k">+</span> A<span class="pl-k">'</span>, B <span class="pl-k">+</span> B<span class="pl-k">'</span>)

<span class="pl-c"><span class="pl-c">#</span> Differentiation</span>
<span class="pl-en">f</span>(B) <span class="pl-k">=</span> <span class="pl-c1">vec</span>(<span class="pl-c1">diff_schur</span>(A <span class="pl-k">+</span> A<span class="pl-k">'</span>, B <span class="pl-k">+</span> B<span class="pl-k">'</span>)<span class="pl-k">.</span>T)
zjac <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(f, B)[<span class="pl-c1">1</span>]</pre></div>
</article></div>