<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-stochasticsemidiscretizationmethodjl" class="anchor" aria-hidden="true" href="#stochasticsemidiscretizationmethodjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>StochasticSemiDiscretizationMethod.jl</h1>
<p dir="auto">Julia package to investigate the behaviour of the first and second moments of stochastic linear delay differential equations based on the paper
[1] <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/nme.6076" rel="nofollow">Stochastic semi‐discretization for linear stochastic delay differential equations</a> and the book
[2] <a href="http://link.springer.com/10.1007/978-1-4614-0335-7" rel="nofollow">Semi-Discretization for Time-Delay Systems (by Insperger and Stepan)</a>.</p>
<p dir="auto">This package provides a tool to approximate the stability properties and stationary behaviour of linear periodic delay systems of the forms:</p>

<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\mathrm{d} \mathbf{x}(t) = \left(\mathbf{A}(t) \mathbf{x}(t) + \sum_{j=1}^g \mathbf{B}(t) \mathbf{x}(t-\tau_j(t))+\mathbf{c}(t)\right)\mathrm{d}t +
\sum_{k=1}^w\left(\boldsymbol{\alpha}^k(t) +  \sum_{j=1}^g \boldsymbol{\beta}^k_j(t) \mathbf{x}(t-\tau_j(t)) + \boldsymbol{\sigma}^k(t) \right)\mathrm{d}W^k(t)$$</math-renderer></p>
<p dir="auto">by transforming the underlying differential equation into the stochastic mapping:</p>
<p dir="auto">$$\mathbf{y}_{n+1} = \left(\mathbf{F}<em>n+\sum</em>{k=1}^w\mathbf{G}^k_n\right)\mathbf{y}_n + \left(\mathbf{f}<em>n + \sum</em>{k=1}^w\mathbf{g}^k_n\right),$$</p>
<p dir="auto">where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$n$</math-renderer> refers to the discrete time <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$t_n = n \Delta t$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{F}_n$</math-renderer> is the deterministic mapping matrix constructed using <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{A}$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{B}$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\tau_j$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{G}^k_n$</math-renderer> are the stochastic mapping matrices constructed using <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\boldsymbol{\alpha}(t)$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\boldsymbol{\beta}(t)$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\tau_j$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{f}_n$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{g}^k_n$</math-renderer> are the deterministic and stochastic additive vectors, constructed using <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{c}$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{\sigma}^k$</math-renderer>, respectively.
The vector <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{y}_n$</math-renderer> is the discretized state space vector:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\mathbf y_{n} = \left(\mathbf{x}(t_n)^\top, \mathbf{x}(t_{n-1})^\top,\ldots,\mathbf{x}(t_{n-r})\right)^\top!.$$</math-renderer></p>
<p dir="auto">The first moment dynamics is described by the expected value of the stochastic mapping, leading to a deterministic mapping:</p>
<p dir="auto"><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\mathbb{E}\left(\mathbf{y}_{n+1}\right) = \mathbf{F}_n\left(\mathbf{y}_n\right)+\mathbf{f}_n,$$</math-renderer>
while the second moment dynamics is described by the expected value of the outer product of the mapping:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\mathbf M_n = \mathbb{E}\left(\mathbf y_n \mathbf y_n^\top\right),
\quad \Rightarrow \quad \mathbf m_n = \mathrm{vec}\left(\mathbf M_n\right) :=
\left[ M_{n,11}, M_{n,22},\dots , M_{n,12}, M_{n,23},\dots, M_{n,1,\left(r+1\right)d} \right]^\top,$$</math-renderer></p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\mathbf m_{n+1} =\mathbf H_n \, \mathbf m_n + \mathbf h_{1,n}\mathbb{E}\left(\mathbf y_n\right)+\mathbf h_n,$$</math-renderer></p>
<p dir="auto">where coefficient matrices $\mathbf{H}<em>n$, $\mathbf{h}</em>{1,n}$ and additive vector <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{h}_n$</math-renderer> are constructed using the mapping matrices <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{F}_n$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{G}^k_n$</math-renderer> and vectors <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{f}_n$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{g}^k_n$</math-renderer>, respectively.
Note, that since the coefficient matrices of the original system are constant, the statistical properties of the coefficient matrices and additive vectors, hence the matrices $\mathbf{F}<em>n$, $\mathbf H_n$, $\mathbf{h}</em>{1,n}$ and vectors <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{f}_n$</math-renderer>, $\mathbf{h}<em>n$ are also constant.
The integer $r$ is chosen in a way, that $r \Delta t \geq \max</em>{t \in \left[ 0, P \right], j = 1 \ldots g}\tau_j(t)$ (the discretized "history function" contains all possible delayed values) and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$d$</math-renderer> is the dimension of the state space <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\left(\mathbf{x}(t) \in \mathbb{R}^d\right)$</math-renderer>..</p>






<p dir="auto">With the use of the discrete mappings, the moment stability of the original system can be investigated (approximately), by the spectral radius <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\rho$</math-renderer> of the coefficient matrices <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$\mathbf{F}_n$</math-renderer> over a period:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\rho\left(\prod_{i=0}^{p-1}{F}_{n+i}\right): \quad
\begin{matrix}
&lt;1 &amp; \Rightarrow &amp; \text{the mapping is stable}\\
&gt;1 &amp; \Rightarrow &amp; \text{the mapping is unstable}
\end{matrix}
$$</math-renderer></p>
<p dir="auto">Furthermore, the steady-state first and second moments can be determined as the fix points of corresponding moment mappings.</p>
<h1 dir="auto">
<a id="user-content-citing" class="anchor" aria-hidden="true" href="#citing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citing</h1>
<p dir="auto">If you use this package as part of your research, teaching, or other activities, we would be grateful if you could cite the paper [1] and the book it is based on (BibTeX entries):</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@article{Sykora2019,
author = {Sykora, Henrik T and Bachrathy, Daniel and Stepan, Gabor},
doi = {10.1002/nme.6076},
journal = {International Journal for Numerical Methods in Engineering},
keywords = { stability, stochastic problems, time delay,differential equations},
number = {ja},
title = {{Stochastic semi-discretization for linear stochastic delay differential equations}},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/nme.6076},
volume = {0}
}

@book{Insperger2011,
address = {New York, NY},
author = {Insperger, Tam{\'{a}}s and St{\'{e}}p{\'{a}}n, G{\'{a}}bor},
doi = {10.1007/978-1-4614-0335-7},
isbn = {978-1-4614-0334-0},
publisher = {Springer New York},
series = {Applied Mathematical Sciences},
title = {{Semi-Discretization for Time-Delay Systems}},
url = {http://link.springer.com/10.1007/978-1-4614-0335-7},
volume = {178},
year = {2011}
}"><pre class="notranslate"><code>@article{Sykora2019,
author = {Sykora, Henrik T and Bachrathy, Daniel and Stepan, Gabor},
doi = {10.1002/nme.6076},
journal = {International Journal for Numerical Methods in Engineering},
keywords = { stability, stochastic problems, time delay,differential equations},
number = {ja},
title = {{Stochastic semi-discretization for linear stochastic delay differential equations}},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/nme.6076},
volume = {0}
}

@book{Insperger2011,
address = {New York, NY},
author = {Insperger, Tam{\'{a}}s and St{\'{e}}p{\'{a}}n, G{\'{a}}bor},
doi = {10.1007/978-1-4614-0335-7},
isbn = {978-1-4614-0334-0},
publisher = {Springer New York},
series = {Applied Mathematical Sciences},
title = {{Semi-Discretization for Time-Delay Systems}},
url = {http://link.springer.com/10.1007/978-1-4614-0335-7},
volume = {178},
year = {2011}
}
</code></pre></div>
<h1 dir="auto">
<a id="user-content-usage-with-examples" class="anchor" aria-hidden="true" href="#usage-with-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage with examples</h1>
<h2 dir="auto">
<a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ] add StochasticSemiDiscretizationMethod"><pre>julia<span class="pl-k">&gt;</span> ] add StochasticSemiDiscretizationMethod</pre></div>
<h2 dir="auto">
<a id="user-content-stochastic-hayes-equations" class="anchor" aria-hidden="true" href="#stochastic-hayes-equations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stochastic Hayes equations</h2>
<p dir="auto"><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\mathrm{d}{x}(t) = a ,x(t)\mathrm{d}t + \left(\beta ,x(t-1) + 1\right) \mathrm{d}W(t),$$</math-renderer>
Here</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$ \mathbf{A}(t) \equiv \begin{bmatrix} a \end{bmatrix},
\quad \mathbf{B}_1(t) \equiv \begin{bmatrix}0\end{bmatrix},
\quad \mathbf{c}(t) \equiv \begin{bmatrix} 0 \end{bmatrix},$$
$$ \boldsymbol{\alpha}^1(t) \equiv \begin{bmatrix} 0 \end{bmatrix},
\quad \boldsymbol{\beta}^1_1(t) \equiv \begin{bmatrix}\beta\end{bmatrix},
\quad \tau^1_1(t) \equiv 1
\quad \mathrm{and} \quad \boldsymbol{\sigma}^1(t) \equiv \begin{bmatrix} 1 \end{bmatrix}.$$</math-renderer></p>
<p dir="auto">(First example in paper [1])</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using StochasticSemiDiscretizationMethod"><pre><span class="pl-k">using</span> StochasticSemiDiscretizationMethod</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function createHayesProblem(a,β)
    AMx =  ProportionalMX(a*ones(1,1));
    τ1=1. 
    BMx1 = DelayMX(τ1,zeros(1,1));
    cVec = Additive(1)
    noiseID = 1
    αMx1 = stCoeffMX(noiseID,ProportionalMX(zeros(1,1)))
    βMx11 = stCoeffMX(noiseID,DelayMX(τ1,β*ones(1,1)))
    σ = stAdditive(1,Additive(ones(1)))
    LDDEProblem(AMx,[BMx1],[αMx1],[βMx11],cVec,[σ])
end"><pre><span class="pl-k">function</span> <span class="pl-en">createHayesProblem</span>(a,β)
    AMx <span class="pl-k">=</span>  <span class="pl-c1">ProportionalMX</span>(a<span class="pl-k">*</span><span class="pl-c1">ones</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>));
    τ1<span class="pl-k">=</span><span class="pl-c1">1.</span> 
    BMx1 <span class="pl-k">=</span> <span class="pl-c1">DelayMX</span>(τ1,<span class="pl-c1">zeros</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>));
    cVec <span class="pl-k">=</span> <span class="pl-c1">Additive</span>(<span class="pl-c1">1</span>)
    noiseID <span class="pl-k">=</span> <span class="pl-c1">1</span>
    αMx1 <span class="pl-k">=</span> <span class="pl-c1">stCoeffMX</span>(noiseID,<span class="pl-c1">ProportionalMX</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>)))
    βMx11 <span class="pl-k">=</span> <span class="pl-c1">stCoeffMX</span>(noiseID,<span class="pl-c1">DelayMX</span>(τ1,β<span class="pl-k">*</span><span class="pl-c1">ones</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>)))
    σ <span class="pl-k">=</span> <span class="pl-c1">stAdditive</span>(<span class="pl-c1">1</span>,<span class="pl-c1">Additive</span>(<span class="pl-c1">ones</span>(<span class="pl-c1">1</span>)))
    <span class="pl-c1">LDDEProblem</span>(AMx,[BMx1],[αMx1],[βMx11],cVec,[σ])
<span class="pl-k">end</span></pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="hayes_lddep=createHayesProblem(-6.,2.); # LDDE problem for Hayes equation
method=SemiDiscretization(0,0.1) # 0th order semi discretization with Δt=0.1
τmax=1. # the largest τ of the system
# Second Moment mapping
mapping=DiscreteMapping_M2(hayes_lddep,method,τmax,n_steps=10,calculate_additive=true); #The discrete mapping of the system"><pre>hayes_lddep<span class="pl-k">=</span><span class="pl-c1">createHayesProblem</span>(<span class="pl-k">-</span><span class="pl-c1">6.</span>,<span class="pl-c1">2.</span>); <span class="pl-c"><span class="pl-c">#</span> LDDE problem for Hayes equation</span>
method<span class="pl-k">=</span><span class="pl-c1">SemiDiscretization</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0.1</span>) <span class="pl-c"><span class="pl-c">#</span> 0th order semi discretization with Δt=0.1</span>
τmax<span class="pl-k">=</span><span class="pl-c1">1.</span> <span class="pl-c"><span class="pl-c">#</span> the largest τ of the system</span>
<span class="pl-c"><span class="pl-c">#</span> Second Moment mapping</span>
mapping<span class="pl-k">=</span><span class="pl-c1">DiscreteMapping_M2</span>(hayes_lddep,method,τmax,n_steps<span class="pl-k">=</span><span class="pl-c1">10</span>,calculate_additive<span class="pl-k">=</span><span class="pl-c1">true</span>); <span class="pl-c"><span class="pl-c">#</span>The discrete mapping of the system</span></pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@show spectralRadiusOfMapping(mapping); # spectral radius ρ of the mapping matrix (ρ&gt;1 unstable, ρ&lt;1 stable)
statM2=VecToCovMx(fixPointOfMapping(mapping), length(mapping.M1_Vs[1])); # stationary second moment matrix of the hayes equation (equilibrium position)
@show statM2[1,1]

# spectralRadiusOfMapping(mapping) = 0.3835887415448961
# statM2[1,1] = 0.12505625506304247"><pre><span class="pl-c1">@show</span> <span class="pl-c1">spectralRadiusOfMapping</span>(mapping); <span class="pl-c"><span class="pl-c">#</span> spectral radius ρ of the mapping matrix (ρ&gt;1 unstable, ρ&lt;1 stable)</span>
statM2<span class="pl-k">=</span><span class="pl-c1">VecToCovMx</span>(<span class="pl-c1">fixPointOfMapping</span>(mapping), <span class="pl-c1">length</span>(mapping<span class="pl-k">.</span>M1_Vs[<span class="pl-c1">1</span>])); <span class="pl-c"><span class="pl-c">#</span> stationary second moment matrix of the hayes equation (equilibrium position)</span>
<span class="pl-c1">@show</span> statM2[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]

<span class="pl-c"><span class="pl-c">#</span> spectralRadiusOfMapping(mapping) = 0.3835887415448961</span>
<span class="pl-c"><span class="pl-c">#</span> statM2[1,1] = 0.12505625506304247</span></pre></div>
<h3 dir="auto">
<a id="user-content-stability-borders-of-the-hayes-equation" class="anchor" aria-hidden="true" href="#stability-borders-of-the-hayes-equation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stability borders of the Hayes Equation</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MDBM
using Plots
gr();
using LaTeXStrings"><pre><span class="pl-k">using</span> MDBM
<span class="pl-k">using</span> Plots
<span class="pl-c1">gr</span>();
<span class="pl-k">using</span> LaTeXStrings</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="method=SemiDiscretization(0,0.1);
τmax=1.

foo(a,b) = log(spectralRadiusOfMapping(DiscreteMapping_M2(createHayesProblem(a,b),method,τmax,
    n_steps=10))); # No additive term calculated

axis=[Axis(-9.0:1.0,:a),
    Axis(-5.0:5.0,:β)]

iteration=4;
stab_border_points=getinterpolatedsolution(solve!(MDBM_Problem(foo,axis),iteration));

scatter(stab_border_points...,xlim=(-9.,1.),ylim=(-5.,5.),
    label=&quot;&quot;,title=&quot;2nd moment stability border of the Hayes equation&quot;,xlabel=L&quot;A&quot;,ylabel=L&quot;$\beta$&quot;,
    guidefontsize=14,tickfont = font(10),markersize=2,markerstrokewidth=0)"><pre>method<span class="pl-k">=</span><span class="pl-c1">SemiDiscretization</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0.1</span>);
τmax<span class="pl-k">=</span><span class="pl-c1">1.</span>

<span class="pl-en">foo</span>(a,b) <span class="pl-k">=</span> <span class="pl-c1">log</span>(<span class="pl-c1">spectralRadiusOfMapping</span>(<span class="pl-c1">DiscreteMapping_M2</span>(<span class="pl-c1">createHayesProblem</span>(a,b),method,τmax,
    n_steps<span class="pl-k">=</span><span class="pl-c1">10</span>))); <span class="pl-c"><span class="pl-c">#</span> No additive term calculated</span>

axis<span class="pl-k">=</span>[<span class="pl-c1">Axis</span>(<span class="pl-k">-</span><span class="pl-c1">9.0</span><span class="pl-k">:</span><span class="pl-c1">1.0</span>,<span class="pl-c1">:a</span>),
    <span class="pl-c1">Axis</span>(<span class="pl-k">-</span><span class="pl-c1">5.0</span><span class="pl-k">:</span><span class="pl-c1">5.0</span>,<span class="pl-c1">:β</span>)]

iteration<span class="pl-k">=</span><span class="pl-c1">4</span>;
stab_border_points<span class="pl-k">=</span><span class="pl-c1">getinterpolatedsolution</span>(<span class="pl-c1">solve!</span>(<span class="pl-c1">MDBM_Problem</span>(foo,axis),iteration));

<span class="pl-c1">scatter</span>(stab_border_points<span class="pl-k">...</span>,xlim<span class="pl-k">=</span>(<span class="pl-k">-</span><span class="pl-c1">9.</span>,<span class="pl-c1">1.</span>),ylim<span class="pl-k">=</span>(<span class="pl-k">-</span><span class="pl-c1">5.</span>,<span class="pl-c1">5.</span>),
    label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>2nd moment stability border of the Hayes equation<span class="pl-pds">"</span></span>,xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">L</span>"</span>A<span class="pl-pds">"</span></span>,ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">L</span>"</span>$<span class="pl-cce">\b</span>eta$<span class="pl-pds">"</span></span>,
    guidefontsize<span class="pl-k">=</span><span class="pl-c1">14</span>,tickfont <span class="pl-k">=</span> <span class="pl-c1">font</span>(<span class="pl-c1">10</span>),markersize<span class="pl-k">=</span><span class="pl-c1">2</span>,markerstrokewidth<span class="pl-k">=</span><span class="pl-c1">0</span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="./assets/StochHayesM2.png"><img src="./assets/StochHayesM2.png" alt="" style="max-width: 100%;"></a></p>
<h2 dir="auto">
<a id="user-content-stochastic-linear-delay-oscillator" class="anchor" aria-hidden="true" href="#stochastic-linear-delay-oscillator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stochastic Linear Delay Oscillator</h2>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\dot{x}(t) = v(t)$$</math-renderer></p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="92f4e725446bafa6da071847ed22f077">$$\dot{v}(t) + 2\zeta v(t) + A x(t) = B x(t-2\pi) + \left(\alpha x(t) + \beta x(t-2\pi) + \sigma\right)\Gamma(t)$$</math-renderer></p>

<p dir="auto">(Second example in paper [1])</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function createSLDOProblem(A,B,ζ,α,β,σ)
    AMx =  ProportionalMX(@SMatrix [0. 1.;-A -2ζ]);
    τ1=2π 
    BMx1 = DelayMX(τ1,@SMatrix [0. 0.; B 0.]);
    cVec = Additive(2)
    noiseID = 1
    αMx1 = stCoeffMX(noiseID,ProportionalMX(@SMatrix [0. 0.; α 0.]))
    βMx11 = stCoeffMX(noiseID,DelayMX(τ1,@SMatrix [0. 0.; β 0.]))
    σVec = stAdditive(1,Additive(@SVector [0., σ]))
    LDDEProblem(AMx,[BMx1],[αMx1],[βMx11],cVec,[σVec])
end"><pre><span class="pl-k">function</span> <span class="pl-en">createSLDOProblem</span>(A,B,ζ,α,β,σ)
    AMx <span class="pl-k">=</span>  <span class="pl-c1">ProportionalMX</span>(<span class="pl-c1">@SMatrix</span> [<span class="pl-c1">0.</span> <span class="pl-c1">1.</span>;<span class="pl-k">-</span>A <span class="pl-k">-</span><span class="pl-c1">2</span>ζ]);
    τ1<span class="pl-k">=</span><span class="pl-c1">2</span>π 
    BMx1 <span class="pl-k">=</span> <span class="pl-c1">DelayMX</span>(τ1,<span class="pl-c1">@SMatrix</span> [<span class="pl-c1">0.</span> <span class="pl-c1">0.</span>; B <span class="pl-c1">0.</span>]);
    cVec <span class="pl-k">=</span> <span class="pl-c1">Additive</span>(<span class="pl-c1">2</span>)
    noiseID <span class="pl-k">=</span> <span class="pl-c1">1</span>
    αMx1 <span class="pl-k">=</span> <span class="pl-c1">stCoeffMX</span>(noiseID,<span class="pl-c1">ProportionalMX</span>(<span class="pl-c1">@SMatrix</span> [<span class="pl-c1">0.</span> <span class="pl-c1">0.</span>; α <span class="pl-c1">0.</span>]))
    βMx11 <span class="pl-k">=</span> <span class="pl-c1">stCoeffMX</span>(noiseID,<span class="pl-c1">DelayMX</span>(τ1,<span class="pl-c1">@SMatrix</span> [<span class="pl-c1">0.</span> <span class="pl-c1">0.</span>; β <span class="pl-c1">0.</span>]))
    σVec <span class="pl-k">=</span> <span class="pl-c1">stAdditive</span>(<span class="pl-c1">1</span>,<span class="pl-c1">Additive</span>(<span class="pl-c1">@SVector</span> [<span class="pl-c1">0.</span>, σ]))
    <span class="pl-c1">LDDEProblem</span>(AMx,[BMx1],[αMx1],[βMx11],cVec,[σVec])
<span class="pl-k">end</span></pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="SLDOP_lddep=createSLDOProblem(1.,0.1,0.1,0.1,0.1,0.5); # LDDE problem for Hayes equation
method=SemiDiscretization(5,(2π+100eps())/10) # 5th order semi discretization with Δt=2π/10
τmax=2π # the largest τ of the system
# Second Moment mapping
mapping=DiscreteMapping_M2(SLDOP_lddep,method,τmax,n_steps=10,calculate_additive=true); #The discrete mapping of the system

@show spectralRadiusOfMapping(mapping); # spectral radius ρ of the mapping matrix (ρ&gt;1 unstable, ρ&lt;1 stable)
statM2=VecToCovMx(fixPointOfMapping(mapping), length(mapping.M1_Vs[1])); # stationary second moment matrix of the hayes equation (equilibrium position)
@show statM2[1,1] |&gt; sqrt;

# spectralRadiusOfMapping(mapping) = 0.5059591707964441
# statM2[1, 1] |&gt; sqrt = 0.9042071549857947"><pre>SLDOP_lddep<span class="pl-k">=</span><span class="pl-c1">createSLDOProblem</span>(<span class="pl-c1">1.</span>,<span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>,<span class="pl-c1">0.5</span>); <span class="pl-c"><span class="pl-c">#</span> LDDE problem for Hayes equation</span>
method<span class="pl-k">=</span><span class="pl-c1">SemiDiscretization</span>(<span class="pl-c1">5</span>,(<span class="pl-c1">2</span>π<span class="pl-k">+</span><span class="pl-c1">100</span><span class="pl-c1">eps</span>())<span class="pl-k">/</span><span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> 5th order semi discretization with Δt=2π/10</span>
τmax<span class="pl-k">=</span><span class="pl-c1">2</span>π <span class="pl-c"><span class="pl-c">#</span> the largest τ of the system</span>
<span class="pl-c"><span class="pl-c">#</span> Second Moment mapping</span>
mapping<span class="pl-k">=</span><span class="pl-c1">DiscreteMapping_M2</span>(SLDOP_lddep,method,τmax,n_steps<span class="pl-k">=</span><span class="pl-c1">10</span>,calculate_additive<span class="pl-k">=</span><span class="pl-c1">true</span>); <span class="pl-c"><span class="pl-c">#</span>The discrete mapping of the system</span>

<span class="pl-c1">@show</span> <span class="pl-c1">spectralRadiusOfMapping</span>(mapping); <span class="pl-c"><span class="pl-c">#</span> spectral radius ρ of the mapping matrix (ρ&gt;1 unstable, ρ&lt;1 stable)</span>
statM2<span class="pl-k">=</span><span class="pl-c1">VecToCovMx</span>(<span class="pl-c1">fixPointOfMapping</span>(mapping), <span class="pl-c1">length</span>(mapping<span class="pl-k">.</span>M1_Vs[<span class="pl-c1">1</span>])); <span class="pl-c"><span class="pl-c">#</span> stationary second moment matrix of the hayes equation (equilibrium position)</span>
<span class="pl-c1">@show</span> statM2[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">|&gt;</span> sqrt;

<span class="pl-c"><span class="pl-c">#</span> spectralRadiusOfMapping(mapping) = 0.5059591707964441</span>
<span class="pl-c"><span class="pl-c">#</span> statM2[1, 1] |&gt; sqrt = 0.9042071549857947</span></pre></div>
<h3 dir="auto">
<a id="user-content-stability-borders-of-the-delay-oscillator" class="anchor" aria-hidden="true" href="#stability-borders-of-the-delay-oscillator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stability borders of the Delay Oscillator</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="method=SemiDiscretization(5,2π/30);
τmax=2π+100eps()
idxs=[1,2,3:2:(StochasticSemiDiscretizationMethod.rOfDelay(τmax,method)+1)*2...]

# ζ=0.05, α=0.3*A, β=0.3*B
foo(A,B) = log(spectralRadiusOfMapping(DiscreteMapping_M2(createSLDOProblem(A,B,0.05,0.3*A,0.3*B,0.),method,τmax,idxs,
    n_steps=30),nev=8)); # No additive term calculated

axis=[Axis(-1.0:0.6:5.0,:A),
    Axis(LinRange(-1.5,1.5,12),:B)]

iteration=4;
stab_border_points=getinterpolatedsolution(solve!(MDBM_Problem(foo,axis),iteration));

scatter(stab_border_points...,xlim=(-1.,5.),ylim=(-1.5,1.4),
    label=&quot;&quot;,title=&quot;2nd moment stability border of the Delay Oscillator&quot;,xlabel=L&quot;A&quot;,ylabel=L&quot;$B$&quot;,
    guidefontsize=14,tickfont = font(10),markersize=2,markerstrokewidth=0)"><pre>method<span class="pl-k">=</span><span class="pl-c1">SemiDiscretization</span>(<span class="pl-c1">5</span>,<span class="pl-c1">2</span>π<span class="pl-k">/</span><span class="pl-c1">30</span>);
τmax<span class="pl-k">=</span><span class="pl-c1">2</span>π<span class="pl-k">+</span><span class="pl-c1">100</span><span class="pl-c1">eps</span>()
idxs<span class="pl-k">=</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(StochasticSemiDiscretizationMethod<span class="pl-k">.</span><span class="pl-c1">rOfDelay</span>(τmax,method)<span class="pl-k">+</span><span class="pl-c1">1</span>)<span class="pl-k">*</span><span class="pl-c1">2</span><span class="pl-k">...</span>]

<span class="pl-c"><span class="pl-c">#</span> ζ=0.05, α=0.3*A, β=0.3*B</span>
<span class="pl-en">foo</span>(A,B) <span class="pl-k">=</span> <span class="pl-c1">log</span>(<span class="pl-c1">spectralRadiusOfMapping</span>(<span class="pl-c1">DiscreteMapping_M2</span>(<span class="pl-c1">createSLDOProblem</span>(A,B,<span class="pl-c1">0.05</span>,<span class="pl-c1">0.3</span><span class="pl-k">*</span>A,<span class="pl-c1">0.3</span><span class="pl-k">*</span>B,<span class="pl-c1">0.</span>),method,τmax,idxs,
    n_steps<span class="pl-k">=</span><span class="pl-c1">30</span>),nev<span class="pl-k">=</span><span class="pl-c1">8</span>)); <span class="pl-c"><span class="pl-c">#</span> No additive term calculated</span>

axis<span class="pl-k">=</span>[<span class="pl-c1">Axis</span>(<span class="pl-k">-</span><span class="pl-c1">1.0</span><span class="pl-k">:</span><span class="pl-c1">0.6</span><span class="pl-k">:</span><span class="pl-c1">5.0</span>,<span class="pl-c1">:A</span>),
    <span class="pl-c1">Axis</span>(<span class="pl-c1">LinRange</span>(<span class="pl-k">-</span><span class="pl-c1">1.5</span>,<span class="pl-c1">1.5</span>,<span class="pl-c1">12</span>),<span class="pl-c1">:B</span>)]

iteration<span class="pl-k">=</span><span class="pl-c1">4</span>;
stab_border_points<span class="pl-k">=</span><span class="pl-c1">getinterpolatedsolution</span>(<span class="pl-c1">solve!</span>(<span class="pl-c1">MDBM_Problem</span>(foo,axis),iteration));

<span class="pl-c1">scatter</span>(stab_border_points<span class="pl-k">...</span>,xlim<span class="pl-k">=</span>(<span class="pl-k">-</span><span class="pl-c1">1.</span>,<span class="pl-c1">5.</span>),ylim<span class="pl-k">=</span>(<span class="pl-k">-</span><span class="pl-c1">1.5</span>,<span class="pl-c1">1.4</span>),
    label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>2nd moment stability border of the Delay Oscillator<span class="pl-pds">"</span></span>,xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">L</span>"</span>A<span class="pl-pds">"</span></span>,ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds"><span class="pl-c1">L</span>"</span>$B$<span class="pl-pds">"</span></span>,
    guidefontsize<span class="pl-k">=</span><span class="pl-c1">14</span>,tickfont <span class="pl-k">=</span> <span class="pl-c1">font</span>(<span class="pl-c1">10</span>),markersize<span class="pl-k">=</span><span class="pl-c1">2</span>,markerstrokewidth<span class="pl-k">=</span><span class="pl-c1">0</span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="./assets/StochLDOM2.png"><img src="./assets/StochLDOM2.png" alt="" style="max-width: 100%;"></a></p>
</article></div>