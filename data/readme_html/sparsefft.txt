<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-sparsefft" class="anchor" aria-hidden="true" href="#sparsefft"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SparseFFT</h1>
<p><a href="https://travis-ci.org/klho/SparseFFT.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d3c216bb0730144b846819417f21b08f18fefa00/68747470733a2f2f7472617669732d63692e6f72672f6b6c686f2f5370617273654646542e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/klho/SparseFFT.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/klho/SparseFFT.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/5753d0358ba4b0e347fbc2bc73930bc36452abc4/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6b6c686f2f5370617273654646542e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/klho/SparseFFT.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a>
<a href="http://codecov.io/github/klho/SparseFFT.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/d6edacf4a6695a18b0c369559430ed08f83f1c32/687474703a2f2f636f6465636f762e696f2f6769746875622f6b6c686f2f5370617273654646542e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/klho/SparseFFT.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>This Julia package provides functions for computing sparse (or "pruned") fast Fourier transforms (FFTs) in one (1D) and two (2D) dimensions. We say that an FFT is sparse if:</p>
<ul>
<li>it maps from a full input domain to a sparse output domain, i.e., only a subset of output indices are required; or</li>
<li>it maps from a sparse input domain to a full output domain, i.e., only a subset of input indices are nonzero.</li>
</ul>
<p>Sparse FFTs can be efficiently computed by, taking the first case for concreteness, essentially hand-unrolling a standard FFT decimation then selectively recombining to form only the required outputs. More specifically, write a 1D <code>n</code>-point transform as:</p>
<div class="highlight highlight-source-julia"><pre>y[i] <span class="pl-k">=</span> <span class="pl-c1">sum</span>([<span class="pl-c1">w</span>(n)<span class="pl-k">^</span>((i<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>(j<span class="pl-k">-</span><span class="pl-c1">1</span>))<span class="pl-k">*</span>x[j] <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n])</pre></div>
<p>where <code>w(p) = exp(-2im*pi/p)</code> or <code>exp(2im*pi/p)</code> depending on the transform direction. Then to compute any set of <code>k</code> entries, assuming for simplicity that <code>m = n/k</code> is integral, use the identity:</p>
<div class="highlight highlight-source-julia"><pre>y[k<span class="pl-k">*</span>(i1<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">+</span>i2] <span class="pl-k">=</span>
    <span class="pl-c1">sum</span>([<span class="pl-c1">w</span>(m)<span class="pl-k">^</span>((i1<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>(j2<span class="pl-k">-</span><span class="pl-c1">1</span>))
             <span class="pl-k">*</span> <span class="pl-c1">w</span>(n)<span class="pl-k">^</span>((i2<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>(j2<span class="pl-k">-</span><span class="pl-c1">1</span>))
             <span class="pl-k">*</span> <span class="pl-c1">sum</span>([<span class="pl-c1">w</span>(k)<span class="pl-k">^</span>((i2<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>(j1<span class="pl-k">-</span><span class="pl-c1">1</span>))<span class="pl-k">*</span>x[m<span class="pl-k">*</span>(j1<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">+</span>j2] <span class="pl-k">for</span> j1 <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>k])
         <span class="pl-k">for</span> j2 <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>m])</pre></div>
<p>for <code>i1 in 1:m</code> and <code>i2 in 1:k</code>, i.e., do <code>m</code> FFTs of size <code>k</code> (over <code>j1</code>) then sum <code>m</code> terms (over <code>j2</code>) for each entry. If <code>k</code> does not divide <code>n</code>, then we replace it in the above with a divisor <code>l &lt; k</code>. The dual sparse-to-full problem is similar, with both algorithms having <code>O(n*log(l))</code> complexity. Sparse FFTs in 2D (and higher dimensions) can be handled via tensor 1D transforms.</p>
<p>For further details, see:</p>
<ul>
<li><a href="http://dx.doi.org/10.1016/j.acha.2007.12.002" rel="nofollow">F. Woolfe, E. Liberty, V. Rokhlin, M. Tygert. A fast randomized algorithm for the approximation of matrices. Appl. Comput. Harmon. Anal. 25: 335-366, 2008</a></li>
<li><a href="http://www.fftw.org/pruned.html" rel="nofollow">http://www.fftw.org/pruned.html</a></li>
</ul>
<p><strong>Note</strong>: An obvious optimization that we have not implemented here is to simply do the full FFT then subsample for transforms that are too small or not sufficiently sparse. This is especially important in higher dimensions where each individual dimension may not directly permit much savings.</p>
<p><strong>Warning</strong>: This package is no longer actively maintained (nor is it really all that useful). Last updated for Julia 1.0.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>SparseFFT follows the same organizational principle as FFTW, with separate planning and execution routines. The primary planning functions in 1D are:</p>
<ul>
<li><code>plan_spfft (T, n, idx; plan_fft_args)</code></li>
<li><code>plan_spbfft(T, n, idx; plan_fft_args)</code></li>
</ul>
<p>which produce, respectively, plans for forward and backward transforms, with arguments:</p>
<ul>
<li><code>T</code>: underlying FFT <code>Complex</code> type (e.g., <code>Complex128</code>)</li>
<li><code>n</code>: full domain size</li>
<li><code>idx</code>: sparse domain indices</li>
<li><code>plan_fft_args</code>: optional arguments for underlying FFT planner</li>
</ul>
<p>Corresponding execution functions include:</p>
<ul>
<li><code>spfft_f2s! (y, plan, x; nb)</code></li>
<li><code>spfft_s2f! (y, plan, x; nb)</code></li>
<li><code>spbfft_f2s!(y, plan, x; nb)</code></li>
<li><code>spbfft_s2f!(y, plan, x; nb)</code></li>
</ul>
<p>which perform full-to-sparse (<code>f2s</code>) or sparse-to-full (<code>s2f</code>) transforms, as appropriate, using a precomputed plan. The arguments <code>x</code> and <code>y</code> are nominally complex but can also be real; real input <code>x</code> is simply upcasted to <code>Complex</code> type <code>T</code> for the underlying FFT, while real output <code>y</code> just takes the real part. The optional argument <code>nb</code> specifies a block size for handling a required transpose in a cache-friendly way.</p>
<p>Optimizations using real FFTs are available for the real-to-complex full-to-sparse and complex-to-full sparse-to-real cases. Planning routines:</p>
<ul>
<li><code>plan_sprfft (T, n, idx; plan_fft_args)</code></li>
<li><code>plan_spbrfft(T, n, idx; plan_fft_args)</code></li>
</ul>
<p>where now <code>T &lt;: Real</code> and <code>idx</code> for the backward transform must contain only nonredundant frequencies, i.e., up to index <code>div(n,2) + 1</code>. Execution routines:</p>
<ul>
<li><code>sprfft_f2s! (y, plan, x; nb)</code></li>
<li><code>spbrfft_s2f!(y, plan, x; nb)</code></li>
</ul>
<p>In 2D, we have essentially the essentially the same interface, with the following exceptions:</p>
<ul>
<li>
<p>The generic planner now takes the form <code>plan_sp*fft(T, n1, n2, idx1, idx2; plan_fft_args)</code>, where the full domain has size <code>n1 x n2</code> and the sparse domain is defined as the tensor-product grid between <code>idx1</code> and <code>idx2</code>.</p>
</li>
<li>
<p>For <code>plan_spbrfft</code>, <code>idx1</code> can only contain indices up to <code>div(n1,2) + 1</code>.</p>
</li>
</ul>
<h2><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h2>
<p>The following example computes a random 100 x 100 subset of the spectrum of a 1000 x 1000 field and compares it to naively computing the full FFT:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> SparseFFT
<span class="pl-k">using</span> FFTW, LinearAlgebra, Random

T <span class="pl-k">=</span> ComplexF64
n1 <span class="pl-k">=</span> <span class="pl-c1">1000</span>
n2 <span class="pl-k">=</span> <span class="pl-c1">1000</span>
k1 <span class="pl-k">=</span> <span class="pl-c1">100</span>
k2 <span class="pl-k">=</span> <span class="pl-c1">100</span>
idx1 <span class="pl-k">=</span> <span class="pl-c1">randperm</span>(n1)[<span class="pl-c1">1</span><span class="pl-k">:</span>k1]
idx2 <span class="pl-k">=</span> <span class="pl-c1">randperm</span>(n2)[<span class="pl-c1">1</span><span class="pl-k">:</span>k2]
x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(T, n1, n2)
y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(T, k1, k2)

<span class="pl-c1">@time</span> f <span class="pl-k">=</span> <span class="pl-c1">fft</span>(x)[idx1,idx2]
<span class="pl-c1">@time</span> P <span class="pl-k">=</span> <span class="pl-c1">plan_spfft</span>(T, n1, n2, idx1, idx2)
<span class="pl-c1">@time</span> <span class="pl-c1">spfft_f2s!</span>(y, P, x)

<span class="pl-c1">norm</span>(f <span class="pl-k">-</span> y)<span class="pl-k">/</span><span class="pl-c1">norm</span>(f)</pre></div>
<p>Sample output (with annotations):</p>
<div class="highlight highlight-source-julia"><pre>  <span class="pl-c1">0.043323</span> seconds (<span class="pl-c1">72</span> allocations<span class="pl-k">:</span> <span class="pl-c1">15.415</span> MB)     <span class="pl-c"><span class="pl-c">#</span> fft</span>
  <span class="pl-c1">0.000529</span> seconds (<span class="pl-c1">124</span> allocations<span class="pl-k">:</span> <span class="pl-c1">3.252</span> MB)     <span class="pl-c"><span class="pl-c">#</span> plan_spfft</span>
  <span class="pl-c1">0.020511</span> seconds (<span class="pl-c1">6.61</span> k allocations<span class="pl-k">:</span> <span class="pl-c1">4.012</span> MB)  <span class="pl-c"><span class="pl-c">#</span> spfft_f2s!</span>
<span class="pl-c1">2.568551894989442e-15</span>                              <span class="pl-c"><span class="pl-c">#</span> vecnorm</span></pre></div>
</article></div>