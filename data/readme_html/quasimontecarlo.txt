<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-quasimontecarlojl" class="anchor" aria-hidden="true" href="#quasimontecarlojl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>QuasiMonteCarlo.jl</h1>
<p dir="auto"><a href="https://julialang.zulipchat.com/#narrow/stream/279055-sciml-bridged" rel="nofollow"><img src="https://camo.githubusercontent.com/667867fc71b8b3c9ed350ce154a04d38adca002ecfa38edf519284e0365ee553/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d5a756c6970266d6573736167653d6368617426636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="Join the chat at https://julialang.zulipchat.com #sciml-bridged" data-canonical-src="https://img.shields.io/static/v1?label=Zulip&amp;message=chat&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a>
<a href="https://docs.sciml.ai/QuasiMonteCarlo/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/88037a523f970520933771e764f5abff55de9382efc91cd89dd43ef0bb49a85f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d5363694d4c2d626c75652e737667" alt="Global Docs" data-canonical-src="https://img.shields.io/badge/docs-SciML-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://codecov.io/gh/SciML/QuasiMonteCarlo.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/af711065acac68686dc5f488b5259b8735716ff97efac2a7ab92dd66cc7a898a/68747470733a2f2f636f6465636f762e696f2f67682f5363694d4c2f51756173694d6f6e74654361726c6f2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/SciML/QuasiMonteCarlo.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://github.com/SciML/QuasiMonteCarlo.jl/actions?query=workflow%3ACI"><img src="https://github.com/SciML/QuasiMonteCarlo.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/SciML/ColPrac"><img src="https://camo.githubusercontent.com/a6c1efcb19a957860ecb25966a730260b03d6e05380d0c27992ee7f9e3b1feb3/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436f6c507261632d436f6e7472696275746f72277325323047756964652d626c756576696f6c6574" alt="ColPrac: Contributor's Guide on Collaborative Practices for Community Packages" data-canonical-src="https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet" style="max-width: 100%;"></a>
<a href="https://github.com/SciML/SciMLStyle"><img src="https://camo.githubusercontent.com/3e16f03bad047817fbc07f49307817ed7919ef79c339dc75ad4ce813012c3e0b/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d636f64652532307374796c65266d6573736167653d5363694d4c26636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="SciML Code Style" data-canonical-src="https://img.shields.io/static/v1?label=code%20style&amp;message=SciML&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a></p>
<p dir="auto">This is a lightweight package for generating Quasi-Monte Carlo (QMC) samples
using various different methods.</p>
<h2 dir="auto"><a id="user-content-tutorials-and-documentation" class="anchor" aria-hidden="true" href="#tutorials-and-documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorials and Documentation</h2>
<p dir="auto">For information on using the package,
<a href="https://docs.sciml.ai/QuasiMonteCarlo/stable/" rel="nofollow">see the stable documentation</a>. Use the
<a href="https://docs.sciml.ai/QuasiMonteCarlo/dev/" rel="nofollow">in-development documentation</a> for the version of
the documentation, which contains the unreleased features.</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using QuasiMonteCarlo, Distributions
lb = [0.1,-0.5]
ub = [1.0,20.0]
n = 5
d = 2

s = QuasiMonteCarlo.sample(n,lb,ub,GridSample([0.1,0.5]))
s = QuasiMonteCarlo.sample(n,lb,ub,UniformSample())
s = QuasiMonteCarlo.sample(n,lb,ub,SobolSample())
s = QuasiMonteCarlo.sample(n,lb,ub,LatinHypercubeSample())
s = QuasiMonteCarlo.sample(n,lb,ub,LatticeRuleSample())
s = QuasiMonteCarlo.sample(n,lb,ub,HaltonSample([10,3], false))"><pre><span class="pl-k">using</span> QuasiMonteCarlo, Distributions
lb <span class="pl-k">=</span> [<span class="pl-c1">0.1</span>,<span class="pl-k">-</span><span class="pl-c1">0.5</span>]
ub <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>,<span class="pl-c1">20.0</span>]
n <span class="pl-k">=</span> <span class="pl-c1">5</span>
d <span class="pl-k">=</span> <span class="pl-c1">2</span>

s <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(n,lb,ub,<span class="pl-c1">GridSample</span>([<span class="pl-c1">0.1</span>,<span class="pl-c1">0.5</span>]))
s <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(n,lb,ub,<span class="pl-c1">UniformSample</span>())
s <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(n,lb,ub,<span class="pl-c1">SobolSample</span>())
s <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(n,lb,ub,<span class="pl-c1">LatinHypercubeSample</span>())
s <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(n,lb,ub,<span class="pl-c1">LatticeRuleSample</span>())
s <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(n,lb,ub,<span class="pl-c1">HaltonSample</span>([<span class="pl-c1">10</span>,<span class="pl-c1">3</span>], <span class="pl-c1">false</span>))</pre></div>
<p dir="auto">The output <code>s</code> is a matrix, so one can use things like <code>@uview</code> from
<a href="https://github.com/oschulz/UnsafeArrays.jl">UnsafeArrays.jl</a> for a stack-allocated
view of the <code>i</code>th point:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using UnsafeArrays
@uview s[:,i]"><pre><span class="pl-k">using</span> UnsafeArrays
<span class="pl-c1">@uview</span> s[:,i]</pre></div>
<h2 dir="auto"><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>API</h2>
<p dir="auto">Everything has the same interface:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = QuasiMonteCarlo.sample(n,lb,ub,sample_method)"><pre>A <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(n,lb,ub,sample_method)</pre></div>
<p dir="auto">where:</p>
<ul dir="auto">
<li><code>n</code> is the number of points to sample.</li>
<li><code>lb</code> is the lower bound for each variable. The length determines the dimensionality.</li>
<li><code>ub</code> is the upper bound.</li>
<li><code>sample_method</code> is the quasi-Monte Carlo sampling strategy.</li>
</ul>
<p dir="auto">Additionally, there is a helper function for generating design matrices:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="k=2
As = QuasiMonteCarlo.generate_design_matrices(n,lb,ub,sample_method,k)"><pre>k<span class="pl-k">=</span><span class="pl-c1">2</span>
As <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">generate_design_matrices</span>(n,lb,ub,sample_method,k)</pre></div>
<p dir="auto">which returns <code>As</code> which is an array of <code>k</code> design matrices <code>A[i]</code> that are
all sampled from the same low-discrepancy sequence.</p>
<h2 dir="auto"><a id="user-content-available-sampling-methods" class="anchor" aria-hidden="true" href="#available-sampling-methods"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Available Sampling Methods</h2>
<p dir="auto">Sampling methods <code>SamplingAlgorithm</code> are divided into two subtypes</p>
<ul dir="auto">
<li><code>DeterministicSamplingAlgorithm</code>
<ul dir="auto">
<li><code>GridSample(dx)</code> where the grid is given by <code>lb:dx[i]:ub</code> in the ith direction.</li>
<li><code>SobolSample</code> for the Sobol' sequence.</li>
<li><code>FaureSample</code> for the Faure sequence.</li>
<li><code>LatticeRuleSample</code> for a randomly-shifted rank-1 lattice rule.</li>
<li><code>HaltonSample(base)</code> where <code>base[i]</code> is the base in the ith direction.</li>
<li><code>GoldenSample</code> for a Golden Ratio sequence.</li>
<li><code>KroneckerSample(alpha, s0)</code> for a Kronecker sequence, where alpha is an length-<code>d</code> vector of irrational numbers (often <code>sqrt(d</code>)) and <code>s0</code> is a length-<code>d</code> seed vector (often <code>0</code>).</li>
</ul>
</li>
<li><code>RandomSamplingAlgorithm</code>
<ul dir="auto">
<li><code>UniformSample</code> for uniformly distributed random numbers.</li>
<li><code>LatinHypercubeSample</code> for a Latin Hypercube.</li>
<li>Additionally, any <code>Distribution</code> can be used, and it will be sampled from.</li>
</ul>

</li>
</ul>
<h2 dir="auto"><a id="user-content-adding-a-new-sampling-method" class="anchor" aria-hidden="true" href="#adding-a-new-sampling-method"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Adding a new sampling method</h2>
<p dir="auto">Adding a new sampling method is a two-step process:</p>
<ol dir="auto">
<li>Add a new SamplingAlgorithm type.</li>
<li>Overload the sample function with the new type.</li>
</ol>
<p dir="auto">All sampling methods are expected to return a matrix with dimension <code>d</code> by <code>n</code>, where <code>d</code> is the dimension of the sample space and <code>n</code> is the number of samples.</p>
<p dir="auto"><strong>Example</strong></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct NewAmazingSamplingAlgorithm{OPTIONAL} &lt;: SamplingAlgorithm end

function sample(n,lb,ub,::NewAmazingSamplingAlgorithm)
    if lb isa Number
        ...
        return x
    else
        ...
        return reduce(hcat, x)
    end
end"><pre><span class="pl-k">struct</span> NewAmazingSamplingAlgorithm{OPTIONAL} <span class="pl-k">&lt;:</span> <span class="pl-c1">SamplingAlgorithm</span> <span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">sample</span>(n,lb,ub,<span class="pl-k">::</span><span class="pl-c1">NewAmazingSamplingAlgorithm</span>)
    <span class="pl-k">if</span> lb <span class="pl-k">isa</span> Number
        <span class="pl-k">...</span>
        <span class="pl-k">return</span> x
    <span class="pl-k">else</span>
        <span class="pl-k">...</span>
        <span class="pl-k">return</span> <span class="pl-c1">reduce</span>(hcat, x)
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-randomization-of-qmc-sequences" class="anchor" aria-hidden="true" href="#randomization-of-qmc-sequences"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Randomization of QMC sequences</h2>
<p dir="auto">Most of the previous methods are deterministic i.e. <code>sample(n, d, Sampler()::DeterministicSamplingAlgorithm)</code> always produces the same sequence <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="72fe4cc4cd125a4bb4dfa62307b575c2">$X = (X_1, \dots, X_n)$</math-renderer>.
The API to randomize sequence is either</p>
<ul dir="auto">
<li>Directly use <code>QuasiMonteCarlo.sample(n, d, DeterministicSamplingAlgorithm(R = RandomizationMethod()))</code> or <code>sample(n, lb, up, DeterministicSamplingAlgorithm(R = RandomizationMethod()))</code>
</li>
<li>Or given any matrix <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="72fe4cc4cd125a4bb4dfa62307b575c2">$X$</math-renderer> (<math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="72fe4cc4cd125a4bb4dfa62307b575c2">$d\times n$</math-renderer>) of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="72fe4cc4cd125a4bb4dfa62307b575c2">$n$</math-renderer> points all in dimension <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="72fe4cc4cd125a4bb4dfa62307b575c2">$d$</math-renderer> in <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="72fe4cc4cd125a4bb4dfa62307b575c2">$[0,1]^d$</math-renderer> one can do <code>randomize(x, ::RandomizationMethod())</code>
</li>
</ul>
<p dir="auto">There are the following randomization methods:</p>
<ul dir="auto">
<li>Scrambling methods <code>ScramblingMethods(base, pad, rng)</code> where <code>base</code> is the base used to scramble and <code>pad</code> the number of bits in <code>b</code>-ary decomposition.
<code>pad</code> is generally chosen as <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="72fe4cc4cd125a4bb4dfa62307b575c2">$\gtrsim \log_b(n)$</math-renderer>.
The implemented <code>ScramblingMethods</code> are
<ul dir="auto">
<li><code>DigitalShift</code></li>
<li>
<code>MatousekScramble</code> a.k.a Linear Matrix Scramble.</li>
<li>
<code>OwenScramble</code> a.k.a Nested Uniform Scramble is the most understood theoretically but is more costly to operate.</li>
</ul>
</li>
<li>
<code>Shift(rng)</code> a.k.a. Cranley Patterson Rotation.</li>
</ul>
<p dir="auto">For numerous independent randomization, use <code>generate_design_matrices(n, d, ::DeterministicSamplingAlgorithm), ::RandomizationMethod, num_mats)</code> where <code>num_mats</code> is the number of independent <code>X</code> generated.</p>
<h3 dir="auto">
<a id="user-content-example-1" class="anchor" aria-hidden="true" href="#example-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h3>
<p dir="auto">Randomization of a Faure sequence with various methods.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using QuasiMonteCarlo
m = 4
d = 3
b = QuasiMonteCarlo.nextprime(d)
N = b^m # Number of points
pad = m # Length of the b-ary decomposition number = sum(y[k]/b^k for k in 1:pad)

# Unrandomized low discrepency sequence
x_faure = QuasiMonteCarlo.sample(N, d, FaureSample())

# Randomized version
x_nus = randomize(x_faure, OwenScramble(base = b, pad = pad)) # equivalent to sample(N, d, FaureSample(R = OwenScramble(base = b, pad = pad)))
x_lms = randomize(x_faure, MatousekScramble(base = b, pad = pad))
x_digital_shift = randomize(x_faure, DigitalShift(base = b, pad = pad))
x_shift = randomize(x_faure, Shift())
x_uniform = rand(d, N) # plain i.i.d. uniform"><pre><span class="pl-k">using</span> QuasiMonteCarlo
m <span class="pl-k">=</span> <span class="pl-c1">4</span>
d <span class="pl-k">=</span> <span class="pl-c1">3</span>
b <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">nextprime</span>(d)
N <span class="pl-k">=</span> b<span class="pl-k">^</span>m <span class="pl-c"><span class="pl-c">#</span> Number of points</span>
pad <span class="pl-k">=</span> m <span class="pl-c"><span class="pl-c">#</span> Length of the b-ary decomposition number = sum(y[k]/b^k for k in 1:pad)</span>

<span class="pl-c"><span class="pl-c">#</span> Unrandomized low discrepency sequence</span>
x_faure <span class="pl-k">=</span> QuasiMonteCarlo<span class="pl-k">.</span><span class="pl-c1">sample</span>(N, d, <span class="pl-c1">FaureSample</span>())

<span class="pl-c"><span class="pl-c">#</span> Randomized version</span>
x_nus <span class="pl-k">=</span> <span class="pl-c1">randomize</span>(x_faure, <span class="pl-c1">OwenScramble</span>(base <span class="pl-k">=</span> b, pad <span class="pl-k">=</span> pad)) <span class="pl-c"><span class="pl-c">#</span> equivalent to sample(N, d, FaureSample(R = OwenScramble(base = b, pad = pad)))</span>
x_lms <span class="pl-k">=</span> <span class="pl-c1">randomize</span>(x_faure, <span class="pl-c1">MatousekScramble</span>(base <span class="pl-k">=</span> b, pad <span class="pl-k">=</span> pad))
x_digital_shift <span class="pl-k">=</span> <span class="pl-c1">randomize</span>(x_faure, <span class="pl-c1">DigitalShift</span>(base <span class="pl-k">=</span> b, pad <span class="pl-k">=</span> pad))
x_shift <span class="pl-k">=</span> <span class="pl-c1">randomize</span>(x_faure, <span class="pl-c1">Shift</span>())
x_uniform <span class="pl-k">=</span> <span class="pl-c1">rand</span>(d, N) <span class="pl-c"><span class="pl-c">#</span> plain i.i.d. uniform</span></pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Plots
# Setting I like for plotting
default(fontfamily=&quot;Computer Modern&quot;, linewidth=1, label=nothing, grid=true, framestyle=:default)"><pre><span class="pl-k">using</span> Plots
<span class="pl-c"><span class="pl-c">#</span> Setting I like for plotting</span>
<span class="pl-c1">default</span>(fontfamily<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Computer Modern<span class="pl-pds">"</span></span>, linewidth<span class="pl-k">=</span><span class="pl-c1">1</span>, label<span class="pl-k">=</span><span class="pl-c1">nothing</span>, grid<span class="pl-k">=</span><span class="pl-c1">true</span>, framestyle<span class="pl-k">=</span><span class="pl-c1">:default</span>)</pre></div>
<p dir="auto">Plot the resulting sequences along dimensions <code>1</code> and <code>3</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d1 = 1
d2 = 3 # you can try every combination of dimension (d1, d2)
sequences = [x_uniform, x_faure, x_shift, x_digital_shift, x_lms, x_nus]
names = [&quot;Uniform&quot;, &quot;Faure (deterministic)&quot;, &quot;Shift&quot;, &quot;Digital Shift&quot;, &quot;Matousek Scramble&quot;, &quot;Owen Scramble&quot;]
p = [plot(thickness_scaling=1.5, aspect_ratio=:equal) for i in sequences]
for (i, x) in enumerate(sequences)
    scatter!(p[i], x[d1, :], x[d2, :], ms=0.9, c=1, grid=false)
    title!(names[i])
    xlims!(p[i], (0, 1))
    ylims!(p[i], (0, 1))
    yticks!(p[i], [0, 1])
    xticks!(p[i], [0, 1])
    hline!(p[i], range(0, 1, step=1 / 4), c=:gray, alpha=0.2)
    vline!(p[i], range(0, 1, step=1 / 4), c=:gray, alpha=0.2)
    hline!(p[i], range(0, 1, step=1 / 2), c=:gray, alpha=0.8)
    vline!(p[i], range(0, 1, step=1 / 2), c=:gray, alpha=0.8)
end
plot(p..., size=(1500, 900))"><pre>d1 <span class="pl-k">=</span> <span class="pl-c1">1</span>
d2 <span class="pl-k">=</span> <span class="pl-c1">3</span> <span class="pl-c"><span class="pl-c">#</span> you can try every combination of dimension (d1, d2)</span>
sequences <span class="pl-k">=</span> [x_uniform, x_faure, x_shift, x_digital_shift, x_lms, x_nus]
names <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>Uniform<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Faure (deterministic)<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Shift<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Digital Shift<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Matousek Scramble<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Owen Scramble<span class="pl-pds">"</span></span>]
p <span class="pl-k">=</span> [<span class="pl-c1">plot</span>(thickness_scaling<span class="pl-k">=</span><span class="pl-c1">1.5</span>, aspect_ratio<span class="pl-k">=</span><span class="pl-c1">:equal</span>) <span class="pl-k">for</span> i <span class="pl-k">in</span> sequences]
<span class="pl-k">for</span> (i, x) <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(sequences)
    <span class="pl-c1">scatter!</span>(p[i], x[d1, :], x[d2, :], ms<span class="pl-k">=</span><span class="pl-c1">0.9</span>, c<span class="pl-k">=</span><span class="pl-c1">1</span>, grid<span class="pl-k">=</span><span class="pl-c1">false</span>)
    <span class="pl-c1">title!</span>(names[i])
    <span class="pl-c1">xlims!</span>(p[i], (<span class="pl-c1">0</span>, <span class="pl-c1">1</span>))
    <span class="pl-c1">ylims!</span>(p[i], (<span class="pl-c1">0</span>, <span class="pl-c1">1</span>))
    <span class="pl-c1">yticks!</span>(p[i], [<span class="pl-c1">0</span>, <span class="pl-c1">1</span>])
    <span class="pl-c1">xticks!</span>(p[i], [<span class="pl-c1">0</span>, <span class="pl-c1">1</span>])
    <span class="pl-c1">hline!</span>(p[i], <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, step<span class="pl-k">=</span><span class="pl-c1">1</span> <span class="pl-k">/</span> <span class="pl-c1">4</span>), c<span class="pl-k">=</span><span class="pl-c1">:gray</span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.2</span>)
    <span class="pl-c1">vline!</span>(p[i], <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, step<span class="pl-k">=</span><span class="pl-c1">1</span> <span class="pl-k">/</span> <span class="pl-c1">4</span>), c<span class="pl-k">=</span><span class="pl-c1">:gray</span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.2</span>)
    <span class="pl-c1">hline!</span>(p[i], <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, step<span class="pl-k">=</span><span class="pl-c1">1</span> <span class="pl-k">/</span> <span class="pl-c1">2</span>), c<span class="pl-k">=</span><span class="pl-c1">:gray</span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.8</span>)
    <span class="pl-c1">vline!</span>(p[i], <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, step<span class="pl-k">=</span><span class="pl-c1">1</span> <span class="pl-k">/</span> <span class="pl-c1">2</span>), c<span class="pl-k">=</span><span class="pl-c1">:gray</span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.8</span>)
<span class="pl-k">end</span>
<span class="pl-c1">plot</span>(p<span class="pl-k">...</span>, size<span class="pl-k">=</span>(<span class="pl-c1">1500</span>, <span class="pl-c1">900</span>))</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="img/various_randomization.svg"><img src="img/various_randomization.svg" alt="Different randomize methods of the same initial set of points" style="max-width: 100%;"></a></p>
</article></div>