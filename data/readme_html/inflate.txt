<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-inflatejl" class="anchor" aria-hidden="true" href="#inflatejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Inflate.jl</h1>
<p dir="auto">Inflate provides a pure Julia implementation of
<a href="https://zlib.net" rel="nofollow">zlib</a> <em>de</em>compression functionality, with both in-
memory and streaming interfaces. This covers decompression of the
Deflate algorithm and the Zlib and Gzip wrapper formats, as specified
in <a href="https://www.ietf.org/rfc/rfc1950.txt" rel="nofollow">RFC 1950</a>,
<a href="https://www.ietf.org/rfc/rfc1951.txt" rel="nofollow">RFC 1951</a>, and
<a href="https://www.ietf.org/rfc/rfc1952.txt" rel="nofollow">RFC 1952</a>.</p>
<p dir="auto">The main reasons to choose Inflate over
<a href="https://github.com/bicycle1885/CodecZlib.jl">CodecZlib</a> are:</p>
<ul dir="auto">
<li>100% Julia code - great for Julia purists.</li>
<li>No binary dependencies.</li>
<li>Actually no dependencies at all.</li>
<li>Can read gzip headers.</li>
</ul>
<p dir="auto">You should choose CodecZlib over Inflate if the points above are not
compelling or one or more of the following applies to you:</p>
<ul dir="auto">
<li>Need to compress, not only decompress.</li>
<li>Want higher speed.</li>
<li>Want a full-featured streaming interface.</li>
<li>Want a battle-proven library.</li>
</ul>
<h2 dir="auto"><a id="user-content-in-memory-decompression" class="anchor" aria-hidden="true" href="#in-memory-decompression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>In-Memory Decompression</h2>
<p dir="auto">In-memory decompression is done by the following functions:</p>
<table>
<thead>
<tr>
<th>function</th>
<th>decompresses</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inflate(data::Vector{UInt8})</code></td>
<td>raw Deflate data</td>
</tr>
<tr>
<td><code>inflate_zlib(data::Vector{UInt8})</code></td>
<td>Zlib data</td>
</tr>
<tr>
<td><code>inflate_gzip(data::Vector{UInt8})</code></td>
<td>Gzip data</td>
</tr>
</tbody>
</table>
<p dir="auto">They all take a <code>Vector{UInt8}</code> with compressed data as input and
return a <code>Vector{UInt8}</code> of decompressed data. Additionally</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="gzip_headers = Dict{String, Any}()
out = inflate_gzip(data, headers = gzip_headers)"><pre class="notranslate"><code>gzip_headers = Dict{String, Any}()
out = inflate_gzip(data, headers = gzip_headers)
</code></pre></div>
<p dir="auto">fills in <code>gzip_headers</code> with the Gzip headers present in <code>data</code>.</p>
<p dir="auto">Both <code>inflate_zlib</code> and <code>inflate_gzip</code> accept the keyword argument
<code>ignore_checksum</code>, which if set to true skips consistency checking by
means of Adler and CRC checksums respectively. This disables the
computation of the checksums, saving time.</p>
<p dir="auto">Finally,
there is also a convenience function to read a compressed text file in
gzip format</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="out = inflate_gzip(filename::String)"><pre class="notranslate"><code>out = inflate_gzip(filename::String)
</code></pre></div>
<p dir="auto">This returns the decompressed file as a string.</p>
<h2 dir="auto"><a id="user-content-streaming-decompression" class="anchor" aria-hidden="true" href="#streaming-decompression"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Streaming Decompression</h2>
<p dir="auto">Streaming decompression is done using the following types:</p>
<table>
<thead>
<tr>
<th>stream</th>
<th>decompresses</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>InflateStream(stream::IO)</code></td>
<td>raw Deflate stream</td>
</tr>
<tr>
<td><code>InflateZlibStream(stream::IO)</code></td>
<td>Zlib stream</td>
</tr>
<tr>
<td><code>InflateGzipStream(stream::IO)</code></td>
<td>Gzip stream</td>
</tr>
</tbody>
</table>
<p dir="auto">The stream types are subtypes of <code>IO</code> and decompression is done by
reading from instances of the types.</p>
<p dir="auto">Example:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="f = open(&quot;compressed_file.gz&quot;, &quot;r&quot;)
gz = InflateGzipStream(f)
for line in readlines(gz)
    println(line)
end
close(f)"><pre class="notranslate"><code>f = open("compressed_file.gz", "r")
gz = InflateGzipStream(f)
for line in readlines(gz)
    println(line)
end
close(f)
</code></pre></div>
<p dir="auto">The streaming interface is minimalistic. If you need a full-featured
interface, the CodecZlib package is likely to be a better fit.</p>
<p dir="auto">Reading of Gzip headers can be done from the streaming interface too.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="gzip_headers = Dict{String, Any}()
gz = InflateGzipStream(stream, headers = gzip_headers)"><pre class="notranslate"><code>gzip_headers = Dict{String, Any}()
gz = InflateGzipStream(stream, headers = gzip_headers)
</code></pre></div>
<p dir="auto">The retrieved headers will be available immediately upon construction
of the <code>InflateGzipStream</code>. It is not necessary to read any data
first.</p>
<p dir="auto">Likewise both <code>InflateZlibStream</code> and <code>InflateGzipStream</code> accept the
keyword argument <code>ignore_checksum</code> in the same way as the
non-streaming functions <code>inflate_zlib</code> and <code>inflate_gzip</code>.</p>
</article></div>