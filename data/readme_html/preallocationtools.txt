<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-preallocationtoolsjl" class="anchor" aria-hidden="true" href="#preallocationtoolsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PreallocationTools.jl</h1>
<p dir="auto"><a href="https://julialang.zulipchat.com/#narrow/stream/279055-sciml-bridged" rel="nofollow"><img src="https://camo.githubusercontent.com/667867fc71b8b3c9ed350ce154a04d38adca002ecfa38edf519284e0365ee553/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d5a756c6970266d6573736167653d6368617426636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="Join the chat at https://julialang.zulipchat.com #sciml-bridged" data-canonical-src="https://img.shields.io/static/v1?label=Zulip&amp;message=chat&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a>
<a href="https://docs.sciml.ai/PreallocationTools/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/88037a523f970520933771e764f5abff55de9382efc91cd89dd43ef0bb49a85f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d5363694d4c2d626c75652e737667" alt="Global Docs" data-canonical-src="https://img.shields.io/badge/docs-SciML-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://codecov.io/gh/SciML/PreallocationTools.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d9d3899d826eaec1f5edcebfc6b5a4b0d291ddee2ca9bf922fdd02a0ab1e4bb2/68747470733a2f2f636f6465636f762e696f2f67682f5363694d4c2f507265616c6c6f636174696f6e546f6f6c732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/SciML/PreallocationTools.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://github.com/SciML/PreallocationTools.jl/actions?query=workflow%3ACI"><img src="https://github.com/SciML/PreallocationTools.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://buildkite.com/julialang/preallocationtools-dot-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/064904751dbdfb481b9b7eabecd747094c2b29e2897d97d188d655b4055df34a/68747470733a2f2f62616467652e6275696c646b6974652e636f6d2f38653632666632363232373231626637613832616135656666623436366433313164353366653633646338396266326633342e737667" alt="Build status" data-canonical-src="https://badge.buildkite.com/8e62ff2622721bf7a82aa5effb466d311d53fe63dc89bf2f34.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/SciML/ColPrac"><img src="https://camo.githubusercontent.com/a6c1efcb19a957860ecb25966a730260b03d6e05380d0c27992ee7f9e3b1feb3/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436f6c507261632d436f6e7472696275746f72277325323047756964652d626c756576696f6c6574" alt="ColPrac: Contributor's Guide on Collaborative Practices for Community Packages" data-canonical-src="https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet" style="max-width: 100%;"></a>
<a href="https://github.com/SciML/SciMLStyle"><img src="https://camo.githubusercontent.com/3e16f03bad047817fbc07f49307817ed7919ef79c339dc75ad4ce813012c3e0b/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d636f64652532307374796c65266d6573736167653d5363694d4c26636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="SciML Code Style" data-canonical-src="https://img.shields.io/static/v1?label=code%20style&amp;message=SciML&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a></p>
<p dir="auto">PreallocationTools.jl is a set of tools for helping build non-allocating
pre-cached functions for high-performance computing in Julia. Its tools handle
edge cases of automatic differentiation to make it easier for users to get
high performance even in the cases where code generation may change the
function that is being called.</p>
<h2 dir="auto"><a id="user-content-diffcache" class="anchor" aria-hidden="true" href="#diffcache"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DiffCache</h2>
<p dir="auto"><code>DiffCache</code> is a type for doubly-preallocated vectors which are
compatible with non-allocating forward-mode automatic differentiation by
ForwardDiff.jl. Since ForwardDiff uses chunked duals in its forward pass, two
vector sizes are required in order for the arrays to be properly defined.
<code>DiffCache</code> creates a dispatching type to solve this, so that by passing a
qualifier it can automatically switch between the required cache. This method
is fully type-stable and non-dynamic, made for when the highest performance is
needed.</p>
<h3 dir="auto"><a id="user-content-using-diffcache" class="anchor" aria-hidden="true" href="#using-diffcache"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using DiffCache</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="DiffCache(u::AbstractArray, N::Int=ForwardDiff.pickchunksize(length(u)); levels::Int = 1)
DiffCache(u::AbstractArray, N::AbstractArray{&lt;:Int})"><pre><span class="pl-c1">DiffCache</span>(u<span class="pl-k">::</span><span class="pl-c1">AbstractArray</span>, N<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span>ForwardDiff<span class="pl-k">.</span><span class="pl-c1">pickchunksize</span>(<span class="pl-c1">length</span>(u)); levels<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)
<span class="pl-c1">DiffCache</span>(u<span class="pl-k">::</span><span class="pl-c1">AbstractArray</span>, N<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Int}</span>)</pre></div>
<p dir="auto">The <code>DiffCache</code> function builds a <code>DiffCache</code> object that stores both a version
of the cache for <code>u</code> and for the <code>Dual</code> version of <code>u</code>, allowing use of
pre-cached vectors with forward-mode automatic differentiation. Note that
<code>DiffCache</code>, due to its design, is only compatible with arrays that contain concretely
typed elements.</p>
<p dir="auto">To access the caches, one uses:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="get_tmp(tmp::DiffCache, u)"><pre><span class="pl-c1">get_tmp</span>(tmp<span class="pl-k">::</span><span class="pl-c1">DiffCache</span>, u)</pre></div>
<p dir="auto">When <code>u</code> has an element subtype of <code>Dual</code> numbers, then it returns the <code>Dual</code>
version of the cache. Otherwise it returns the standard cache (for use in the
calls without automatic differentiation).</p>
<p dir="auto">In order to preallocate to the right size, the <code>DiffCache</code> needs to be specified
to have the correct <code>N</code> matching the chunk size of the dual numbers or larger.
If the chunk size <code>N</code> specified is too large, <code>get_tmp</code> will automatically resize
when dispatching; this remains type-stable and non-allocating, but comes at the
expense of additional memory.</p>
<p dir="auto">In a differential equation, optimization, etc., the default chunk size is computed
from the state vector <code>u</code>, and thus if one creates the <code>DiffCache</code> via
<code>DiffCache(u)</code> it will match the default chunking of the solver libraries.</p>
<p dir="auto"><code>DiffCache</code> is also compatible with nested automatic differentiation calls through
the <code>levels</code> keyword (<code>N</code> for each level computed using based on the size of the
state vector) or by specifying <code>N</code> as an array of integers of chunk sizes, which
enables full control of chunk sizes on all differentation levels.</p>
<h3 dir="auto"><a id="user-content-diffcache-example-1-direct-usage" class="anchor" aria-hidden="true" href="#diffcache-example-1-direct-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DiffCache Example 1: Direct Usage</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ForwardDiff, PreallocationTools
randmat = rand(5, 3)
sto = similar(randmat)
stod = DiffCache(sto)

function claytonsample!(sto, τ, α; randmat=randmat)
    sto = get_tmp(sto, τ)
    sto .= randmat
    τ == 0 &amp;&amp; return sto

    n = size(sto, 1)
    for i in 1:n
        v = sto[i, 2]
        u = sto[i, 1]
        sto[i, 1] = (1 - u^(-τ) + u^(-τ)*v^(-(τ/(1 + τ))))^(-1/τ)*α
        sto[i, 2] = (1 - u^(-τ) + u^(-τ)*v^(-(τ/(1 + τ))))^(-1/τ)
    end
    return sto
end

ForwardDiff.derivative(τ -&gt; claytonsample!(stod, τ, 0.0), 0.3)
ForwardDiff.jacobian(x -&gt; claytonsample!(stod, x[1], x[2]), [0.3; 0.0])"><pre><span class="pl-k">using</span> ForwardDiff, PreallocationTools
randmat <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">5</span>, <span class="pl-c1">3</span>)
sto <span class="pl-k">=</span> <span class="pl-c1">similar</span>(randmat)
stod <span class="pl-k">=</span> <span class="pl-c1">DiffCache</span>(sto)

<span class="pl-k">function</span> <span class="pl-en">claytonsample!</span>(sto, τ, α; randmat<span class="pl-k">=</span>randmat)
    sto <span class="pl-k">=</span> <span class="pl-c1">get_tmp</span>(sto, τ)
    sto <span class="pl-k">.=</span> randmat
    τ <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">return</span> sto

    n <span class="pl-k">=</span> <span class="pl-c1">size</span>(sto, <span class="pl-c1">1</span>)
    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n
        v <span class="pl-k">=</span> sto[i, <span class="pl-c1">2</span>]
        u <span class="pl-k">=</span> sto[i, <span class="pl-c1">1</span>]
        sto[i, <span class="pl-c1">1</span>] <span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">-</span> u<span class="pl-k">^</span>(<span class="pl-k">-</span>τ) <span class="pl-k">+</span> u<span class="pl-k">^</span>(<span class="pl-k">-</span>τ)<span class="pl-k">*</span>v<span class="pl-k">^</span>(<span class="pl-k">-</span>(τ<span class="pl-k">/</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> τ))))<span class="pl-k">^</span>(<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span>τ)<span class="pl-k">*</span>α
        sto[i, <span class="pl-c1">2</span>] <span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">-</span> u<span class="pl-k">^</span>(<span class="pl-k">-</span>τ) <span class="pl-k">+</span> u<span class="pl-k">^</span>(<span class="pl-k">-</span>τ)<span class="pl-k">*</span>v<span class="pl-k">^</span>(<span class="pl-k">-</span>(τ<span class="pl-k">/</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> τ))))<span class="pl-k">^</span>(<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span>τ)
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> sto
<span class="pl-k">end</span>

ForwardDiff<span class="pl-k">.</span><span class="pl-c1">derivative</span>(τ <span class="pl-k">-&gt;</span> <span class="pl-c1">claytonsample!</span>(stod, τ, <span class="pl-c1">0.0</span>), <span class="pl-c1">0.3</span>)
ForwardDiff<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">claytonsample!</span>(stod, x[<span class="pl-c1">1</span>], x[<span class="pl-c1">2</span>]), [<span class="pl-c1">0.3</span>; <span class="pl-c1">0.0</span>])</pre></div>
<p dir="auto">In the above, the chunk size of the dual numbers has been selected based on the size
of <code>randmat</code>, resulting in a chunk size of 8 in this case. However, since the derivative
is calculated with respect to τ and the Jacobian is calculated with respect to τ and α,
specifying the <code>DiffCache</code> with <code>stod = DiffCache(sto, 1)</code> or <code>stod = DiffCache(sto, 2)</code>,
respectively, would have been the most memory efficient way of performing these calculations
(only really relevant for much larger problems).</p>
<h3 dir="auto"><a id="user-content-diffcache-example-2-odes" class="anchor" aria-hidden="true" href="#diffcache-example-2-odes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DiffCache Example 2: ODEs</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra, OrdinaryDiffEq
function foo(du, u, (A, tmp), t)
    mul!(tmp, A, u)
    @. du = u + tmp
    nothing
end
prob = ODEProblem(foo, ones(5, 5), (0., 1.0), (ones(5,5), zeros(5,5)))
solve(prob, TRBDF2())"><pre><span class="pl-k">using</span> LinearAlgebra, OrdinaryDiffEq
<span class="pl-k">function</span> <span class="pl-en">foo</span>(du, u, (A, tmp), t)
    <span class="pl-c1">mul!</span>(tmp, A, u)
    <span class="pl-c1">@.</span> du <span class="pl-k">=</span> u <span class="pl-k">+</span> tmp
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>
prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(foo, <span class="pl-c1">ones</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">0.</span>, <span class="pl-c1">1.0</span>), (<span class="pl-c1">ones</span>(<span class="pl-c1">5</span>,<span class="pl-c1">5</span>), <span class="pl-c1">zeros</span>(<span class="pl-c1">5</span>,<span class="pl-c1">5</span>)))
<span class="pl-c1">solve</span>(prob, <span class="pl-c1">TRBDF2</span>())</pre></div>
<p dir="auto">fails because <code>tmp</code> is only real numbers, but during automatic differentiation
we need <code>tmp</code> to be a cache of dual numbers. Since <code>u</code> is the value that will
have the dual numbers, we dispatch based on that:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra, OrdinaryDiffEq, PreallocationTools
function foo(du, u, (A, tmp), t)
    tmp = get_tmp(tmp, u)
    mul!(tmp, A, u)
    @. du = u + tmp
    nothing
end
chunk_size = 5
prob = ODEProblem(foo, ones(5, 5), (0., 1.0), (ones(5,5), DiffCache(zeros(5,5), chunk_size)))
solve(prob, TRBDF2(chunk_size=chunk_size))"><pre><span class="pl-k">using</span> LinearAlgebra, OrdinaryDiffEq, PreallocationTools
<span class="pl-k">function</span> <span class="pl-en">foo</span>(du, u, (A, tmp), t)
    tmp <span class="pl-k">=</span> <span class="pl-c1">get_tmp</span>(tmp, u)
    <span class="pl-c1">mul!</span>(tmp, A, u)
    <span class="pl-c1">@.</span> du <span class="pl-k">=</span> u <span class="pl-k">+</span> tmp
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>
chunk_size <span class="pl-k">=</span> <span class="pl-c1">5</span>
prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(foo, <span class="pl-c1">ones</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">0.</span>, <span class="pl-c1">1.0</span>), (<span class="pl-c1">ones</span>(<span class="pl-c1">5</span>,<span class="pl-c1">5</span>), <span class="pl-c1">DiffCache</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">5</span>,<span class="pl-c1">5</span>), chunk_size)))
<span class="pl-c1">solve</span>(prob, <span class="pl-c1">TRBDF2</span>(chunk_size<span class="pl-k">=</span>chunk_size))</pre></div>
<p dir="auto">or just using the default chunking:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra, OrdinaryDiffEq, PreallocationTools
function foo(du, u, (A, tmp), t)
    tmp = get_tmp(tmp, u)
    mul!(tmp, A, u)
    @. du = u + tmp
    nothing
end
chunk_size = 5
prob = ODEProblem(foo, ones(5, 5), (0., 1.0), (ones(5,5), DiffCache(zeros(5,5))))
solve(prob, TRBDF2())"><pre><span class="pl-k">using</span> LinearAlgebra, OrdinaryDiffEq, PreallocationTools
<span class="pl-k">function</span> <span class="pl-en">foo</span>(du, u, (A, tmp), t)
    tmp <span class="pl-k">=</span> <span class="pl-c1">get_tmp</span>(tmp, u)
    <span class="pl-c1">mul!</span>(tmp, A, u)
    <span class="pl-c1">@.</span> du <span class="pl-k">=</span> u <span class="pl-k">+</span> tmp
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>
chunk_size <span class="pl-k">=</span> <span class="pl-c1">5</span>
prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(foo, <span class="pl-c1">ones</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">0.</span>, <span class="pl-c1">1.0</span>), (<span class="pl-c1">ones</span>(<span class="pl-c1">5</span>,<span class="pl-c1">5</span>), <span class="pl-c1">DiffCache</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">5</span>,<span class="pl-c1">5</span>))))
<span class="pl-c1">solve</span>(prob, <span class="pl-c1">TRBDF2</span>())</pre></div>
<h3 dir="auto"><a id="user-content-diffcache-example-3-nested-ad-calls-in-an-optimization-problem-involving-a-hessian-matrix" class="anchor" aria-hidden="true" href="#diffcache-example-3-nested-ad-calls-in-an-optimization-problem-involving-a-hessian-matrix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DiffCache Example 3: Nested AD calls in an optimization problem involving a Hessian matrix</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra, OrdinaryDiffEq, PreallocationTools, Optimization, OptimizationOptimJL
function foo(du, u, p, t)
    tmp = p[2]
    A = reshape(p[1], size(tmp.du))
    tmp = get_tmp(tmp, u)
    mul!(tmp, A, u)
    @. du = u + tmp
    nothing
end

coeffs = -collect(0.1:0.1:0.4)
cache = DiffCache(zeros(2,2), levels = 3)
prob = ODEProblem(foo, ones(2, 2), (0., 1.0), (coeffs, cache))
realsol = solve(prob, TRBDF2(), saveat = 0.0:0.1:10.0, reltol = 1e-8)

function objfun(x, prob, realsol, cache)
    prob = remake(prob, u0 = eltype(x).(prob.u0), p = (x, cache))
    sol = solve(prob, TRBDF2(), saveat = 0.0:0.1:10.0, reltol = 1e-8)

    ofv = 0.0
    if any((s.retcode != :Success for s in sol))
        ofv = 1e12
    else
        ofv = sum((sol.-realsol).^2)
    end
    return ofv
end
fn(x,p) = objfun(x, p[1], p[2], p[3])
optfun = OptimizationFunction(fn, Optimization.AutoForwardDiff())
optprob = OptimizationProblem(optfun, zeros(length(coeffs)), (prob, realsol, cache))
solve(optprob, Newton())"><pre><span class="pl-k">using</span> LinearAlgebra, OrdinaryDiffEq, PreallocationTools, Optimization, OptimizationOptimJL
<span class="pl-k">function</span> <span class="pl-en">foo</span>(du, u, p, t)
    tmp <span class="pl-k">=</span> p[<span class="pl-c1">2</span>]
    A <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(p[<span class="pl-c1">1</span>], <span class="pl-c1">size</span>(tmp<span class="pl-k">.</span>du))
    tmp <span class="pl-k">=</span> <span class="pl-c1">get_tmp</span>(tmp, u)
    <span class="pl-c1">mul!</span>(tmp, A, u)
    <span class="pl-c1">@.</span> du <span class="pl-k">=</span> u <span class="pl-k">+</span> tmp
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>

coeffs <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">collect</span>(<span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">0.4</span>)
cache <span class="pl-k">=</span> <span class="pl-c1">DiffCache</span>(<span class="pl-c1">zeros</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), levels <span class="pl-k">=</span> <span class="pl-c1">3</span>)
prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(foo, <span class="pl-c1">ones</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>), (<span class="pl-c1">0.</span>, <span class="pl-c1">1.0</span>), (coeffs, cache))
realsol <span class="pl-k">=</span> <span class="pl-c1">solve</span>(prob, <span class="pl-c1">TRBDF2</span>(), saveat <span class="pl-k">=</span> <span class="pl-c1">0.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>, reltol <span class="pl-k">=</span> <span class="pl-c1">1e-8</span>)

<span class="pl-k">function</span> <span class="pl-en">objfun</span>(x, prob, realsol, cache)
    prob <span class="pl-k">=</span> <span class="pl-c1">remake</span>(prob, u0 <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(x).(prob<span class="pl-k">.</span>u0), p <span class="pl-k">=</span> (x, cache))
    sol <span class="pl-k">=</span> <span class="pl-c1">solve</span>(prob, <span class="pl-c1">TRBDF2</span>(), saveat <span class="pl-k">=</span> <span class="pl-c1">0.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>, reltol <span class="pl-k">=</span> <span class="pl-c1">1e-8</span>)

    ofv <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
    <span class="pl-k">if</span> <span class="pl-c1">any</span>((s<span class="pl-k">.</span>retcode <span class="pl-k">!=</span> <span class="pl-c1">:Success</span> <span class="pl-k">for</span> s <span class="pl-k">in</span> sol))
        ofv <span class="pl-k">=</span> <span class="pl-c1">1e12</span>
    <span class="pl-k">else</span>
        ofv <span class="pl-k">=</span> <span class="pl-c1">sum</span>((sol<span class="pl-k">.-</span>realsol)<span class="pl-k">.</span><span class="pl-k">^</span><span class="pl-c1">2</span>)
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> ofv
<span class="pl-k">end</span>
<span class="pl-en">fn</span>(x,p) <span class="pl-k">=</span> <span class="pl-c1">objfun</span>(x, p[<span class="pl-c1">1</span>], p[<span class="pl-c1">2</span>], p[<span class="pl-c1">3</span>])
optfun <span class="pl-k">=</span> <span class="pl-c1">OptimizationFunction</span>(fn, Optimization<span class="pl-k">.</span><span class="pl-c1">AutoForwardDiff</span>())
optprob <span class="pl-k">=</span> <span class="pl-c1">OptimizationProblem</span>(optfun, <span class="pl-c1">zeros</span>(<span class="pl-c1">length</span>(coeffs)), (prob, realsol, cache))
<span class="pl-c1">solve</span>(optprob, <span class="pl-c1">Newton</span>())</pre></div>
<p dir="auto">Solves an optimization problem for the coefficients, <code>coeffs</code>, appearing in a differential equation.
The optimization is done with <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>'s <code>Newton()</code>
algorithm. Since this involves automatic differentiation in the ODE solver and the calculation
of Hessians, three automatic differentiations are nested within each other. Therefore, the <code>DiffCache</code>
is specified with <code>levels = 3</code>.</p>
<h2 dir="auto"><a id="user-content-fixedsizediffcache" class="anchor" aria-hidden="true" href="#fixedsizediffcache"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FixedSizeDiffCache</h2>
<p dir="auto"><code>FixedSizeDiffCache</code> is a lot like <code>DiffCache</code>, but it stores dual numbers in its caches
instead of a flat array. Because of this, it can avoid a view, making it a little bit
more performant for generating caches of non-<code>Array</code> types. However, it is a lot less
flexible than <code>DiffCache</code>, and is thus only recommended for cases where the chunk size
is known in advance (for example, ODE solvers) and where <code>u</code> is not an <code>Array</code>.</p>
<p dir="auto">The interface is almost exactly the same, except with the constructor:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FixedSizeDiffCache(u::AbstractArray, chunk_size = Val{ForwardDiff.pickchunksize(length(u))})
FixedSizeDiffCache(u::AbstractArray, chunk_size::Integer)"><pre><span class="pl-c1">FixedSizeDiffCache</span>(u<span class="pl-k">::</span><span class="pl-c1">AbstractArray</span>, chunk_size <span class="pl-k">=</span> Val{ForwardDiff<span class="pl-k">.</span><span class="pl-c1">pickchunksize</span>(<span class="pl-c1">length</span>(u))})
<span class="pl-c1">FixedSizeDiffCache</span>(u<span class="pl-k">::</span><span class="pl-c1">AbstractArray</span>, chunk_size<span class="pl-k">::</span><span class="pl-c1">Integer</span>)</pre></div>
<p dir="auto">Note that the <code>FixedSizeDiffCache</code> can support duals that are of a smaller chunk size than
the preallocated ones, but not a larger size. Nested duals are not supported with this
construct.</p>
<h2 dir="auto"><a id="user-content-lazybuffercache" class="anchor" aria-hidden="true" href="#lazybuffercache"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LazyBufferCache</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="LazyBufferCache(f::F=identity)"><pre><span class="pl-c1">LazyBufferCache</span>(f<span class="pl-k">::</span><span class="pl-c1">F</span><span class="pl-k">=</span>identity)</pre></div>
<p dir="auto">A <code>LazyBufferCache</code> is a <code>Dict</code>-like type for the caches which automatically defines
new cache arrays on demand when they are required. The function <code>f</code> maps
<code>size_of_cache = f(size(u))</code>, which by default creates cache arrays of the same size.</p>
<p dir="auto">Note that <code>LazyBufferCache</code> does cause a dynamic dispatch, though it is type-stable.
This gives it a ~100ns overhead, and thus on very small problems it can reduce
performance, but for any sufficiently sized calculation (e.g. &gt;20 ODEs) this
may not be even measurable. The upside of <code>LazyBufferCache</code> is that the user does
not have to worry about potential issues with chunk sizes and such: <code>LazyBufferCache</code>
is much easier!</p>
<h3 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra, OrdinaryDiffEq, PreallocationTools
function foo(du, u, (A, lbc), t)
    tmp = lbc[u]
    mul!(tmp, A, u)
    @. du = u + tmp
    nothing
end
prob = ODEProblem(foo, ones(5, 5), (0., 1.0), (ones(5,5), LazyBufferCache()))
solve(prob, TRBDF2())"><pre><span class="pl-k">using</span> LinearAlgebra, OrdinaryDiffEq, PreallocationTools
<span class="pl-k">function</span> <span class="pl-en">foo</span>(du, u, (A, lbc), t)
    tmp <span class="pl-k">=</span> lbc[u]
    <span class="pl-c1">mul!</span>(tmp, A, u)
    <span class="pl-c1">@.</span> du <span class="pl-k">=</span> u <span class="pl-k">+</span> tmp
    <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>
prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(foo, <span class="pl-c1">ones</span>(<span class="pl-c1">5</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">0.</span>, <span class="pl-c1">1.0</span>), (<span class="pl-c1">ones</span>(<span class="pl-c1">5</span>,<span class="pl-c1">5</span>), <span class="pl-c1">LazyBufferCache</span>()))
<span class="pl-c1">solve</span>(prob, <span class="pl-c1">TRBDF2</span>())</pre></div>
<h2 dir="auto"><a id="user-content-generallazybuffercache" class="anchor" aria-hidden="true" href="#generallazybuffercache"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GeneralLazyBufferCache</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="GeneralLazyBufferCache(f=identity)"><pre><span class="pl-c1">GeneralLazyBufferCache</span>(f<span class="pl-k">=</span>identity)</pre></div>
<p dir="auto">A <code>GeneralLazyBufferCache</code> is a <code>Dict</code>-like type for the caches which automatically defines
new caches on demand when they are required. The function <code>f</code> generates the cache matching
for the type of <code>u</code>, and subsequent indexing reuses that cache if that type of <code>u</code> has
already ben seen.</p>
<p dir="auto">Note that <code>LazyBufferCache</code> does cause a dynamic dispatch and its return is not type-inferred.
This means it's the slowest of the preallocation methods, but it's the most general.</p>
<h3 dir="auto"><a id="user-content-example-1" class="anchor" aria-hidden="true" href="#example-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h3>
<p dir="auto">In all of the previous cases our cache was an array. However, in this case we want to preallocate
a DifferentialEquations <code>ODEIntegrator</code> object. This object is the one created via
<code>DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t)</code>, and we
want to optimize <code>p</code> in a way that changes its type to ForwardDiff. Thus what we can do is make a
GeneralLazyBufferCache which holds these integrator objects, defined by <code>p</code>, and indexing it with
<code>p</code> in order to retrieve the cache. The first time it's called it will build the integrator, and
in subsequent calls it will reuse the cache.</p>
<p dir="auto">Defining the cache as a function of <code>p</code> to build an integrator thus looks like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="lbc = GeneralLazyBufferCache(function (p)
    DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t)
end)"><pre>lbc <span class="pl-k">=</span> <span class="pl-c1">GeneralLazyBufferCache</span>(<span class="pl-k">function</span> (p)
    DifferentialEquations<span class="pl-k">.</span><span class="pl-c1">init</span>(<span class="pl-c1">ODEProblem</span>(ode_fnc, y₀, (<span class="pl-c1">0.0</span>, T), p), <span class="pl-c1">Tsit5</span>(); saveat <span class="pl-k">=</span> t)
<span class="pl-k">end</span>)</pre></div>
<p dir="auto">then <code>lbc[p]</code> will be smart and reuse the caches. A full example looks like the following:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Random, DifferentialEquations, LinearAlgebra, Optimization, OptimizationNLopt, OptimizationOptimJL, PreallocationTools

lbc = GeneralLazyBufferCache(function (p)
    DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t)
end)

Random.seed!(2992999)
λ, y₀, σ = -0.5, 15.0, 0.1
T, n = 5.0, 200
Δt = T / n
t = [j * Δt for j in 0:n]
y = y₀ * exp.(λ * t)
yᵒ = y .+ [0.0, σ * randn(n)...]
ode_fnc(u, p, t) = p * u
function loglik(θ, data, integrator)
    yᵒ, n, ε = data
    λ, σ, u0 = θ
    integrator.p = λ
    reinit!(integrator, u0)
    solve!(integrator)
    ε = yᵒ .- integrator.sol.u
    ℓ = -0.5n * log(2π * σ^2) - 0.5 / σ^2 * sum(ε.^2)
end
θ₀ = [-1.0, 0.5, 19.73]
negloglik = (θ, p) -&gt; -loglik(θ, p, lbc[θ[1]])
fnc = OptimizationFunction(negloglik, Optimization.AutoForwardDiff())
ε = zeros(n)
prob = OptimizationProblem(fnc, θ₀, (yᵒ, n, ε), lb=[-10.0, 1e-6, 0.5], ub=[10.0, 10.0, 25.0])
solve(prob, LBFGS())"><pre><span class="pl-k">using</span> Random, DifferentialEquations, LinearAlgebra, Optimization, OptimizationNLopt, OptimizationOptimJL, PreallocationTools

lbc <span class="pl-k">=</span> <span class="pl-c1">GeneralLazyBufferCache</span>(<span class="pl-k">function</span> (p)
    DifferentialEquations<span class="pl-k">.</span><span class="pl-c1">init</span>(<span class="pl-c1">ODEProblem</span>(ode_fnc, y₀, (<span class="pl-c1">0.0</span>, T), p), <span class="pl-c1">Tsit5</span>(); saveat <span class="pl-k">=</span> t)
<span class="pl-k">end</span>)

Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">2992999</span>)
λ, y₀, σ <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0.5</span>, <span class="pl-c1">15.0</span>, <span class="pl-c1">0.1</span>
T, n <span class="pl-k">=</span> <span class="pl-c1">5.0</span>, <span class="pl-c1">200</span>
Δt <span class="pl-k">=</span> T <span class="pl-k">/</span> n
t <span class="pl-k">=</span> [j <span class="pl-k">*</span> Δt <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">:</span>n]
y <span class="pl-k">=</span> y₀ <span class="pl-k">*</span> <span class="pl-c1">exp</span>.(λ <span class="pl-k">*</span> t)
yᵒ <span class="pl-k">=</span> y <span class="pl-k">.+</span> [<span class="pl-c1">0.0</span>, σ <span class="pl-k">*</span> <span class="pl-c1">randn</span>(n)<span class="pl-k">...</span>]
<span class="pl-en">ode_fnc</span>(u, p, t) <span class="pl-k">=</span> p <span class="pl-k">*</span> u
<span class="pl-k">function</span> <span class="pl-en">loglik</span>(θ, data, integrator)
    yᵒ, n, ε <span class="pl-k">=</span> data
    λ, σ, u0 <span class="pl-k">=</span> θ
    integrator<span class="pl-k">.</span>p <span class="pl-k">=</span> λ
    <span class="pl-c1">reinit!</span>(integrator, u0)
    <span class="pl-c1">solve!</span>(integrator)
    ε <span class="pl-k">=</span> yᵒ <span class="pl-k">.-</span> integrator<span class="pl-k">.</span>sol<span class="pl-k">.</span>u
    ℓ <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0.5</span>n <span class="pl-k">*</span> <span class="pl-c1">log</span>(<span class="pl-c1">2</span>π <span class="pl-k">*</span> σ<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">-</span> <span class="pl-c1">0.5</span> <span class="pl-k">/</span> σ<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">sum</span>(ε<span class="pl-k">.^</span><span class="pl-c1">2</span>)
<span class="pl-k">end</span>
θ₀ <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">1.0</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">19.73</span>]
negloglik <span class="pl-k">=</span> (θ, p) <span class="pl-k">-&gt;</span> <span class="pl-k">-</span><span class="pl-c1">loglik</span>(θ, p, lbc[θ[<span class="pl-c1">1</span>]])
fnc <span class="pl-k">=</span> <span class="pl-c1">OptimizationFunction</span>(negloglik, Optimization<span class="pl-k">.</span><span class="pl-c1">AutoForwardDiff</span>())
ε <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(n)
prob <span class="pl-k">=</span> <span class="pl-c1">OptimizationProblem</span>(fnc, θ₀, (yᵒ, n, ε), lb<span class="pl-k">=</span>[<span class="pl-k">-</span><span class="pl-c1">10.0</span>, <span class="pl-c1">1e-6</span>, <span class="pl-c1">0.5</span>], ub<span class="pl-k">=</span>[<span class="pl-c1">10.0</span>, <span class="pl-c1">10.0</span>, <span class="pl-c1">25.0</span>])
<span class="pl-c1">solve</span>(prob, <span class="pl-c1">LBFGS</span>())</pre></div>
<h2 dir="auto"><a id="user-content-similar-projects" class="anchor" aria-hidden="true" href="#similar-projects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Similar Projects</h2>
<p dir="auto"><a href="https://github.com/oxinabox/AutoPreallocation.jl">AutoPreallocation.jl</a> tries
to do this automatically at the compiler level. <a href="https://github.com/FluxML/Alloc.jl">Alloc.jl</a>
tries to do this with a bump allocator.</p>
</article></div>