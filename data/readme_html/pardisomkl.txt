<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-pardisomkl" class="anchor" aria-hidden="true" href="#pardisomkl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PardisoMKL</h1>
<p>This package provides Julia bindings to the low level routines provided by the <a href="https://software.intel.com/en-us/mkl-developer-reference-fortran-intel-mkl-pardiso-parallel-direct-sparse-solver-interface" rel="nofollow">Intel (R) MKL Pardiso direct sparse solver interface</a>. This package can only be used if a licensed installation of the Intel (R) MKL Pardiso is available in the system.  This package is available free of charge and in no way replaces or alters any functionality of the linked libraries.</p>
<h2><a id="user-content-why" class="anchor" aria-hidden="true" href="#why"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why?</h2>
<p>The goal of this package is to provide very thin wrappers to the low level Pardiso FORTRAN routines. The signatures of the Julia wrappers use only built-in types and are almost one-to-one to the signatures of the wrapped FORTRAN subroutines. This allows advanced users to have fine control over the Pardiso solver. If you are looking for a more user-friendly way to interface with Pardiso, then use the <a href="https://github.com/JuliaSparse/Pardiso.jl">Pardiso.jl</a> package.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<ul>
<li>Set the <code>MKLROOT</code> environment variable. See the <a href="https://software.intel.com/en-us/articles/intel-mkl-103-getting-started" rel="nofollow">MKL getting started manual</a> for a thorough guide how to set this variable correctly, typically done by executing something like <code>source /opt/intel/bin/compilervars.sh intel64</code>.</li>
<li>Make sure that <code>gcc</code> is installed and that can be found via the <code>$PATH</code> environment variable.</li>
<li>Install <code>PardisoMKL</code> as any other Julia package.</li>
</ul>
<h2><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API</h2>
<ul>
<li>Most of the functions exported by <code>PardisoMKL</code> have the names of the underlying FORTRAN routines appended with an exclamation sign (!).</li>
<li>The Julia wrappers return an integer error code if the underlying FORTRAN subroutine accept an integer error code in the last argument.</li>
<li>The arguments in the Julia bindings are named as in the FORTRAN subroutines.  See the <a href="https://software.intel.com/en-us/mkl-developer-reference-fortran-intel-mkl-pardiso-parallel-direct-sparse-solver-interface" rel="nofollow">Intel (R) MKL Pardiso manual</a> for the particular details.</li>
</ul>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pardisoinit!</span>(pt<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>,mtype<span class="pl-k">::</span><span class="pl-c1">Integer</span>,iparm<span class="pl-k">::</span><span class="pl-c1">Vector{Int32}</span>)</pre></div>
<p>Initializes Intel MKL PARDISO with default parameters depending on the matrix type.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pardiso!</span>( pt<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>, maxfct<span class="pl-k">::</span><span class="pl-c1">Integer</span>, mnum<span class="pl-k">::</span><span class="pl-c1">Integer</span>, mtype<span class="pl-k">::</span><span class="pl-c1">Integer</span>,
  phase<span class="pl-k">::</span><span class="pl-c1">Integer</span>, n<span class="pl-k">::</span><span class="pl-c1">Integer</span>, a<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, ia<span class="pl-k">::</span><span class="pl-c1">Vector{Int32}</span>,
  ja<span class="pl-k">::</span><span class="pl-c1">Vector{Int32}</span>, perm<span class="pl-k">::</span><span class="pl-c1">Vector{Int32}</span>, nrhs<span class="pl-k">::</span><span class="pl-c1">Integer</span>, iparm<span class="pl-k">::</span><span class="pl-c1">Vector{Int32}</span>,
  msglvl<span class="pl-k">::</span><span class="pl-c1">Integer</span>, b<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>)<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">where</span> T</pre></div>
<p>Calculates the solution of a set of sparse linear equations with single or multiple right-hand sides and returns an integer error code. The type <code>T</code> has to match the chosen matrix type <code>mtype</code> and the provided options <code>iparm</code>. The valid type <code>T</code> can be retrieved with the <code>pardiso_data_type</code> function (see below).</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pardiso_64!</span>(pt<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>, maxfct<span class="pl-k">::</span><span class="pl-c1">Integer</span>, mnum<span class="pl-k">::</span><span class="pl-c1">Integer</span>, mtype<span class="pl-k">::</span><span class="pl-c1">Integer</span>,
  phase<span class="pl-k">::</span><span class="pl-c1">Integer</span>, n<span class="pl-k">::</span><span class="pl-c1">Integer</span>, a<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, ia<span class="pl-k">::</span><span class="pl-c1">Vector{Int64}</span>,
  ja<span class="pl-k">::</span><span class="pl-c1">Vector{Int64}</span>, perm<span class="pl-k">::</span><span class="pl-c1">Vector{Int64}</span>, nrhs<span class="pl-k">::</span><span class="pl-c1">Integer</span>, iparm<span class="pl-k">::</span><span class="pl-c1">Vector{Int64}</span>,
  msglvl<span class="pl-k">::</span><span class="pl-c1">Integer</span>, b<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, x<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>)<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">where</span> T</pre></div>
<p>64-bit integer version of <code>pardiso!</code></p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pardiso_getdiag!</span>(pt<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>, df<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, da<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, mnum<span class="pl-k">::</span><span class="pl-c1">Integer</span>)<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">where</span> T</pre></div>
<p>Writes the diagonal elements of initial and factorized matrix in the provided vectors and returns an integer error code. The type <code>T</code> is as previously detailed for <code>pardiso!</code>.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pardiso_getdiag!</span>(pt<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span>, df<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, da<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, mnum<span class="pl-k">::</span><span class="pl-c1">Integer</span>,
  mtype<span class="pl-k">::</span><span class="pl-c1">Integer</span>, iparm<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Integer}</span>)<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">where</span> T</pre></div>
<p>Safer version of <code>pardiso_getdiag!</code> that checks if the type <code>T</code> matches the given <code>mtype</code> and <code>iparm</code>.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">new_pardiso_handle</span>()<span class="pl-k">::</span><span class="pl-c1">Vector{Int}</span></pre></div>
<p>Allocates and returns a vector of zeros that can be used as the <code>pt</code> argument in previous functions.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">new_iparm</span>()<span class="pl-k">::</span><span class="pl-c1">Vector{Int32}</span></pre></div>
<p>Allocates and returns a vector of zeros that can be used as the <code>iparm</code> argument in previous functions.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">new_iparm_64</span>()<span class="pl-k">::</span><span class="pl-c1">Vector{Int64}</span></pre></div>
<p>64-bit version of <code>new_iparm</code>. To be used in <code>pardiso_64!</code></p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pardiso_data_type</span>(mtype<span class="pl-k">::</span><span class="pl-c1">Integer</span>,iparm<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Integer}</span>)<span class="pl-k">::</span><span class="pl-c1">DataType</span></pre></div>
<p>Returns the data type associated with the  matrix type <code>mtype</code> and the options in <code>iparm</code>.</p>
</article></div>