<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-legolasflux" class="anchor" aria-hidden="true" href="#legolasflux"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LegolasFlux</h1>
<p dir="auto"><a href="https://github.com/beacon-biosignals/LegolasFlux.jl/actions/workflows/CI.yml"><img src="https://github.com/beacon-biosignals/LegolasFlux.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/beacon-biosignals/LegolasFlux.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e4dcad98bc535852f543ad18dd1fb2257f906778758396cbec126944ea79686f/68747470733a2f2f636f6465636f762e696f2f67682f626561636f6e2d62696f7369676e616c732f4c65676f6c6173466c75782e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d4e4859554c3232484343" alt="codecov" data-canonical-src="https://codecov.io/gh/beacon-biosignals/LegolasFlux.jl/branch/main/graph/badge.svg?token=NHYUL22HCC" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-note-upgrading-from-legolasflux-v01x-to-v02" class="anchor" aria-hidden="true" href="#note-upgrading-from-legolasflux-v01x-to-v02"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Note: Upgrading from LegolasFlux v0.1.x to v0.2?</h3>
<p dir="auto">The only change is an update to Legolas v0.5. Be sure to check out the <a href="https://beacon-biosignals.github.io/Legolas.jl/dev/upgrade/" rel="nofollow">guidance for updating Legolas to v0.5</a> along with the rest of Legolas's documentation and tour.</p>
<hr>
<p dir="auto">LegolasFlux provides some simple functionality to use <a href="https://github.com/beacon-biosignals/Legolas.jl/">Legolas.jl</a>'s
extensible Arrow schemas as means to serialize Flux models similarly to using Flux's <code>params</code> and <code>loadparams!</code>
(instead, we export similar functions <code>fetch_weights</code> and <code>load_weights!</code> which handle layers like <code>BatchNorm</code> correctly for this purpose).</p>
<p dir="auto">The aim is to serialize only the numeric weights, <em>not</em> the code defining the model. This is a very different approach
from e.g. BSON.jl, and hopefully much more robust. Note that in this package, we use <code>weights</code> to refer to the numeric arrays that are modified over the course of training a model; that includes biases as well as means and variances in e.g. BatchNorms (but not e.g. configuration settings).</p>
<p dir="auto">With this approach, however, if you change the code such that the weights are no longer valid (e.g. add a layer),
you will not be able to load back the same model.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Flux

function make_my_model()
    return Chain(Dense(1,10), Dense(10, 10), Dense(10, 1))
end

my_model = make_my_model()
# train it? that part is optional ;)

# Now, let's save it!
using LegolasFlux

model_row = LegolasFlux.ModelV1(; weights = fetch_weights(cpu(my_model)),
                                architecture_version=1)
write_model_row(&quot;my_model.model.arrow&quot;, model_row)

# Great! Later on, we want to re-load our model weights.
fresh_model = make_my_model()

model_row = read_model_row(&quot;my_model.model.arrow&quot;)
load_weights!(fresh_model, model_row.weights)
# Now our weights have been loaded back into `fresh_model`.
"><pre><span class="pl-k">using</span> Flux

<span class="pl-k">function</span> <span class="pl-en">make_my_model</span>()
    <span class="pl-k">return</span> <span class="pl-c1">Chain</span>(<span class="pl-c1">Dense</span>(<span class="pl-c1">1</span>,<span class="pl-c1">10</span>), <span class="pl-c1">Dense</span>(<span class="pl-c1">10</span>, <span class="pl-c1">10</span>), <span class="pl-c1">Dense</span>(<span class="pl-c1">10</span>, <span class="pl-c1">1</span>))
<span class="pl-k">end</span>

my_model <span class="pl-k">=</span> <span class="pl-c1">make_my_model</span>()
<span class="pl-c"><span class="pl-c">#</span> train it? that part is optional ;)</span>

<span class="pl-c"><span class="pl-c">#</span> Now, let's save it!</span>
<span class="pl-k">using</span> LegolasFlux

model_row <span class="pl-k">=</span> LegolasFlux<span class="pl-k">.</span><span class="pl-c1">ModelV1</span>(; weights <span class="pl-k">=</span> <span class="pl-c1">fetch_weights</span>(<span class="pl-c1">cpu</span>(my_model)),
                                architecture_version<span class="pl-k">=</span><span class="pl-c1">1</span>)
<span class="pl-c1">write_model_row</span>(<span class="pl-s"><span class="pl-pds">"</span>my_model.model.arrow<span class="pl-pds">"</span></span>, model_row)

<span class="pl-c"><span class="pl-c">#</span> Great! Later on, we want to re-load our model weights.</span>
fresh_model <span class="pl-k">=</span> <span class="pl-c1">make_my_model</span>()

model_row <span class="pl-k">=</span> <span class="pl-c1">read_model_row</span>(<span class="pl-s"><span class="pl-pds">"</span>my_model.model.arrow<span class="pl-pds">"</span></span>)
<span class="pl-c1">load_weights!</span>(fresh_model, model_row<span class="pl-k">.</span>weights)
<span class="pl-c"><span class="pl-c">#</span> Now our weights have been loaded back into `fresh_model`.</span>
</pre></div>
<p dir="auto">We can make use of the <code>architecture_version</code> column to specify a version number for the architectures, in order
to keep track of for which architectures the weights are valid for.</p>
<p dir="auto">See <a href="examples/digits.jl">examples/digits.jl</a> for a larger example, which also saves out extra metadata with the model,
by using a Legolas schema extension.</p>
<h2 dir="auto"><a id="user-content-legolasfluxmodelv1" class="anchor" aria-hidden="true" href="#legolasfluxmodelv1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>LegolasFlux.ModelV1</code></h2>
<p dir="auto">A <code>LegolasFlux.ModelV1</code> is a central object of LegolasFlux. It acts as a Tables.jl-compatible row that can store the weights
of a Flux model in the <code>weights</code> column, optionally an <code>architecture_version</code> (defaults to <code>missing</code>).</p>
<p dir="auto"><code>ModelV1</code> is not exported because downstream models likely want to define their own rows which extend the schema provided by LegolasFlux
that might end up being called something similar. See the next section for more on extensibility.</p>
<h2 dir="auto"><a id="user-content-extensibility" class="anchor" aria-hidden="true" href="#extensibility"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Extensibility</h2>
<p dir="auto">As a Legolas.jl schema, it is meant to be extended. For example, let's say I had an MNIST classification model
that I call <code>Digits</code>. I am very committed to reproducibility, so I store the <code>commit_sha</code> of my model's repo
with every training run, and I also wish to save the accuracy and epoch. I might create a <code>DigitsRow</code> which is
a schema extension of the <code>legolas-flux.model</code> schema:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Legolas, LegolasFlux
using Legolas: @schema, @version
@schema &quot;digits-model&quot; DigitsRow
@version DigitsRowV1 &gt; ModelV1 begin
    # re-declare this ModelV1 field as parametric for this schema as well
    weights::(&lt;:Union{Missing,Weights})
    epoch::Union{Missing, Int}
    accuracy::Union{Missing, Float32}
    commit_sha::Union{Missing, String}
end"><pre><span class="pl-k">using</span> Legolas, LegolasFlux
<span class="pl-k">using</span> Legolas<span class="pl-k">:</span> <span class="pl-c1">@schema</span>, <span class="pl-c1">@version</span>
<span class="pl-c1">@schema</span> <span class="pl-s"><span class="pl-pds">"</span>digits-model<span class="pl-pds">"</span></span> DigitsRow
<span class="pl-c1">@version</span> DigitsRowV1 <span class="pl-k">&gt;</span> ModelV1 <span class="pl-k">begin</span>
    <span class="pl-c"><span class="pl-c">#</span> re-declare this ModelV1 field as parametric for this schema as well</span>
    weights<span class="pl-k">::</span><span class="pl-c1">(&lt;:Union{Missing,Weights})</span>
    epoch<span class="pl-k">::</span><span class="pl-c1">Union{Missing, Int}</span>
    accuracy<span class="pl-k">::</span><span class="pl-c1">Union{Missing, Float32}</span>
    commit_sha<span class="pl-k">::</span><span class="pl-c1">Union{Missing, String}</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Now I can use a <code>DigitsRowV1</code> much like LegolasFlux's <code>ModelV1</code>. It has the same required <code>weights</code> column and optional <code>architecture_version</code> column, as well as the additional <code>epoch</code>, <code>accuracy</code>, and <code>commit_sha</code> columns. As a naming convention,
one might name files produced by this row as e.g. <code>training_run.digits.model.arrow</code>.</p>
<p dir="auto">When writing out a <code>DigitsRowV1</code>, I'll pass the schema version like so</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="write_model_row(path, my_digits_row, DigitsRowV1SchemaVersion())"><pre><span class="pl-c1">write_model_row</span>(path, my_digits_row, <span class="pl-c1">DigitsRowV1SchemaVersion</span>())</pre></div>
<p dir="auto">so that later, when I call <code>read_model_row</code> on this path, I'll get back a <code>DigitsRowV1</code> instance.</p>
<p dir="auto">Note in this example the schema is called <code>digits.model</code> instead of just say <code>digits</code>, since the package Digits might want to
create other Legolas schemas as well at some point.</p>
<p dir="auto">Check out the <a href="https://github.com/beacon-biosignals/Legolas.jl/">Legolas.jl</a> repo to see more about how its extensible schema system works,
and the example at <a href="examples/digits.jl">examples/digits.jl</a>.</p>
</article></div>