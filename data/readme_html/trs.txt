<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-trsjl-solving-the-trust-region-subproblem" class="anchor" aria-hidden="true" href="#trsjl-solving-the-trust-region-subproblem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TRS.jl: Solving the Trust Region Subproblem</h1>
<p>This package solves the Trust-Region Subproblem:</p>
<pre><code>minimize    ½x'Px + q'x
subject to  ‖x‖ ≤ r
</code></pre>
<p>where <code>x</code> in the <code>n-</code>dimensional variable. This is a <strong>matrix-free</strong> method returning highly accurate solutions efficiently by solving a <strong>single</strong> eigenproblem. It accesses <code>P</code> <em>only</em> via matrix multiplications (i.e. via <code>mul!</code>), so it can take full advantage of <code>P</code>'s structure/sparsity.</p>
<p>Furthermore, the following extensions are supported:</p>
<ul>
<li><a href="#ellipsoidal-norms">Ellipsoidal Norms</a></li>
<li><a href="#equality-constraints">Linear Equality constraints</a></li>
<li><a href="#finding-local-no-global-minimizers">Finding local-no-global minimizers</a></li>
<li><a href="#solving-constant-norm-problems">Solving constant-norm problems</a></li>
<li><a href="#solving-small-problems">Solving small problems efficiently</a></li>
</ul>
<p>This package has been specifically designed for large scale problems. Separate, efficient <a href="#solving-small-problems">functions for small problems</a> are also provided.</p>
<p>If you are interested for support of linear inequality constraints <code>Ax ≤ b</code> check <a href="https://github.com/oxfordcontrol/QPnorm.jl">this</a> package.</p>
<p>The main reference for this package is</p>
<pre><code>Adachi, S., Iwata, S., Nakatsukasa, Y., &amp; Takeda, A.
Solving the trust-region subproblem by a generalized eigenvalue problem.
SIAM Journal on Optimization 27.1 (2017): 269-291.
</code></pre>
<p>Additionally, the cases of local-no-global minimizers and linear equality constraints are covered in</p>
<pre><code>Rontsis N., Goulart P.J., &amp; Nakatsukasa, Y.
An active-set algorithm for norm constrained quadratic problems
arXiv:1906.04022
</code></pre>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>This package can be installed by running</p>
<pre><code>add https://github.com/oxfordcontrol/TRS.jl
</code></pre>
<p>in <a href="https://docs.julialang.org/en/v1/stdlib/Pkg/index.html#Getting-Started-1" rel="nofollow">Julia's Pkg REPL mode</a>.</p>
<h2><a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Documentation</h2>
<h3><a id="user-content-standard-trs" class="anchor" aria-hidden="true" href="#standard-trs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Standard TRS</h3>
<p>The global solution of the standard TRS</p>
<pre><code>minimize    ½x'Px + q'x
subject to  ‖x‖ ≤ r,
</code></pre>
<p>where ‖·‖ is the 2-norm, can be obtained with:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">trs</span>(P, q, r; kwargs<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> x, info</pre></div>
<p><strong>Arguments</strong> (<code>T</code> is any real numerical type):</p>
<ul>
<li><code>P</code>: The quadratic cost represented as any linear operator implementing <code>mul!</code>, <code>issymmetric</code> and <code>size</code>.</li>
<li><code>q::AbstractVector{T}</code>: the linear cost.</li>
<li><code>r::T</code>: the radius.</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><code>X::Matrix{T}</code>: Array with each column containing a global solution to the TRS</li>
<li><code>info::TRSInfo{T}</code>: Info structure. See <a href="#the-trsinfo-struct">below</a> for details.</li>
</ul>
<p><strong>Keywords (optional)</strong></p>
<ul>
<li><code>tol</code>, <code>maxiter</code>, <code>ncv</code> and <code>v0</code> that are passed to <code>eigs</code> used to solve the underlying eigenproblem. Refer to <code>Arpack.jl</code>'s <a href="https://julialinearalgebra.github.io/Arpack.jl/stable/" rel="nofollow">documentation</a> for these arguments. Of particular importance is <strong><code>tol::T</code></strong> which essentially controls the <strong>accuracy</strong> of the returned solutions.</li>
<li><code>tol_hard=2e-7</code>: Threshold for switching to the hard-case. Refer to <a href="https://epubs.siam.org/doi/pdf/10.1137/16M1058200" rel="nofollow">Adachi et al.</a>, Section 4.2 for an explanation.</li>
<li><code>compute_local::Bool=False</code>: Whether the local-no-global solution should be calculated. More details <a href="#finding-local-no-global-minimizers">below</a>.</li>
</ul>
<p><strong>Note that if <code>v0</code> is not set, then <code>Arpack</code> starts from a random initial vector and thus the results will not be completely deterministic.</strong></p>
<h3><a id="user-content-ellipsoidal-norms" class="anchor" aria-hidden="true" href="#ellipsoidal-norms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ellipsoidal Norms</h3>
<p>Results for ellipsoidal norms <code>‖x‖ := sqrt(x'Cx)</code> can be obtained with</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">trs</span>(P, q, r, C; kwargs<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> x, info</pre></div>
<p>which is the same as <code>trs(P, q, r)</code> except for the input argument</p>
<ul>
<li><code>C::AbstractMatrix{T}</code>: a positive definite, symmetric, matrix that defines the ellipsoidal norm <code>‖x‖ := sqrt(x'Cx)</code>.</li>
</ul>
<p>Note that if <code>C</code> is known to be well conditioned it might be preferable to perform a change of variables <code>y = cholesky(C)\x</code> and use the standard <code>trs(P, q, r)</code> instead.</p>
<h3><a id="user-content-equality-constraints" class="anchor" aria-hidden="true" href="#equality-constraints"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Equality constraints</h3>
<p>The problem</p>
<pre><code>minimize    ½x'Px + q'x
subject to  ‖x‖ ≤ r
            Ax = b,
</code></pre>
<p>where <code>A</code> is a "fat", full row-rank matrix, can be solved as</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">trs</span>(P, q, r, A, b; kwargs<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> x, info</pre></div>
<p>which is the same as <code>trs(P, q, r)</code> except for the input arguments <code>A::AbstractMatrix{T}</code> and <code>b::AbstractVector{T}</code></p>
<h3><a id="user-content-finding-local-no-global-minimizers" class="anchor" aria-hidden="true" href="#finding-local-no-global-minimizers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Finding local-no-global minimizers</h3>
<p>Due to non-convexity, a TRS can exhibit at most one local minimizer with objective value less than the one of the global. The local-no-global minimizer can be obtained (if it exists) via:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">trs</span>(···; compute_local<span class="pl-k">=</span><span class="pl-c1">true</span>, kwargs<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> X info</pre></div>
<p>Similarly to the cases above, <code>X::Matrix{T}</code> contains the global solution(s), but in this case, local minimizers are also included. The global minimizers(s) proceed the local one.</p>
<h3><a id="user-content-solving-constant-norm-problems" class="anchor" aria-hidden="true" href="#solving-constant-norm-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solving constant-norm problems</h3>
<p>Simply use <code>trs_boundary</code> instead of <code>trs</code>.</p>
<h3><a id="user-content-solving-small-problems" class="anchor" aria-hidden="true" href="#solving-small-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solving small problems</h3>
<p>Small problems (say for <code>n &lt; 20</code>) should be solved with <code>trs_small</code> and <code>trs_boundary_small</code>, which have identical definitions with <code>trs</code> and <code>trs_boundary</code> described above, except for <code>P</code> which is constrained to be a subtype of <code>AbstractMatrix{T}</code>.</p>
<p>Internally <code>trs_small</code>/<code>trs_boundary_small</code> use direct eigensolvers (i.e. <code>eigen</code>) providing better accuracy, reliability, and speed for small problems.</p>
<h3><a id="user-content-the-trsinfo-struct" class="anchor" aria-hidden="true" href="#the-trsinfo-struct"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>TRSInfo</code> struct</h3>
<p>The returned info structure contains the following fields:</p>
<ul>
<li><code>hard_case::Bool</code> Flag indicating if the problem was detected to be in the hard-case.</li>
<li><code>niter::Int</code>:  Number of iterations of the eigensolver</li>
<li><code>nmul::Int</code>:   Number of multiplications with <code>P</code> requested by the eigensolver.</li>
<li><code>λ::Vector</code> Lagrange Multiplier(s) of the solution(s).</li>
</ul>
</article></div>