<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-abbaj" class="anchor" aria-hidden="true" href="#abbaj"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ABBAj</h1>
<p dir="auto"><a href="https://app.travis-ci.com/github/nla-group/ABBAj.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/0eaa0f7a3f5bcc18fbefe1c40e2aa033e55540baf24dabe0ff99758e453a21ec/68747470733a2f2f6170702e7472617669732d63692e636f6d2f6e6c612d67726f75702f414242416a2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://app.travis-ci.com/nla-group/ABBAj.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="https://github.com/nla-group/ABBAj.jl/actions"><img src="https://github.com/nla-group/ABBAj.jl/actions/workflows/ci.yml/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/nla-group/ABBAj.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/652f51ce60e7a16ca4576c0b8561244a86364ee44353de26c7a7ab6861cb2a06/68747470733a2f2f636f6465636f762e696f2f67682f6e6c612d67726f75702f414242416a2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d31394133313236574258" alt="codecov" data-canonical-src="https://codecov.io/gh/nla-group/ABBAj.jl/branch/master/graph/badge.svg?token=19A3126WBX" style="max-width: 100%;"></a>
<a href="https://opensource.org/licenses/BSD-3-Clause" rel="nofollow"><img src="https://camo.githubusercontent.com/8ccf186e7288af6d88a1f6a930c0fcc4e7a8a9936b34e07629d815d1eab4d977/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d425344253230332d2d436c617573652d626c75652e737667" alt="License" data-canonical-src="https://img.shields.io/badge/License-BSD%203--Clause-blue.svg" style="max-width: 100%;"></a>
<a href="https://mybinder.org/v2/gh/nla-group/jlABBA/HEAD" rel="nofollow"><img src="https://camo.githubusercontent.com/581c077bdbc6ca6899c86d0acc6145ae85e9d80e6f805a1071793dbe48917982/68747470733a2f2f6d7962696e6465722e6f72672f62616467655f6c6f676f2e737667" alt="Binder" data-canonical-src="https://mybinder.org/badge_logo.svg" style="max-width: 100%;"></a>
<a href="https://doi.org/10.5281/zenodo.6286546" rel="nofollow"><img src="https://camo.githubusercontent.com/3acd78cf978cf21bfc4a5583ead6f46269610e214f2653015871f53c4033658e/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f444f492f31302e353238312f7a656e6f646f2e363238363534362e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/DOI/10.5281/zenodo.6286546.svg" style="max-width: 100%;"></a></p>
<p dir="auto">A Julia version of ABBA with parallel k-means implementation</p>
<blockquote>
<ul dir="auto">
<li>Documentation: <a href="https://nla-group.github.io/ABBAj.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a></li>
</ul>
</blockquote>
<p dir="auto">ABBA (Adaptive Brownian bridge-based aggregation) is a symbolic time series representation method introduced by Elsworth Steven and Stefan Güttel, which archives time-series compression and discretization by transforming time series into a symbolic representation. Compared to raw data, symbolic representation enjoys numerous benefits including dimensionality reduction, noises reduction, features discretization, and so on. The software <code>fABBA</code> (<a href="https://github.com/nla-group/fABBA">https://github.com/nla-group/fABBA</a>) already provided ABBA transformation with appealing speed and tolerance-oriented digitization. Now our application of interest focus on that is it possible to accelerate ABBA by preserving k-means clustering? The package provides lightweight Julia implementation of the ABBA method, using ParallelKMeans.jl to achieve speedup in the digitization.</p>
<p dir="auto"><code>ABBAj</code> is a Julia module for time series transformation with ABBA. With <code>ABBAj</code>, you can employ ABBA in an efficient way to symbolize time series and applied the symbolic representation to the downstream time series task such as classification and forecasting. Compared to the ABBA module, <code>ABBAj</code> enjoys significantly faster speed while retaining the consistent reconstruction error of representation.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">You can simply install the stable version of this package by running in Julia (Work in progress):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add ABBAj"><pre>pkg<span class="pl-k">&gt;</span> add ABBAj</pre></div>
<p dir="auto">or download the repository via:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="git clone https://github.com/nla-group/ABBAj.jl"><pre class="notranslate"><code>git clone https://github.com/nla-group/ABBAj.jl
</code></pre></div>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; time_series = load_sample(); # load time series samples 
julia&gt; symbols, model = fit_transform(time_series, 4, 0.1); # use 4 symbols with compressed tolerance of 0.1
julia&gt; r_time_series = inverse_transform(symbols, model, time_series[1]); # inverse transform time series"><pre>julia<span class="pl-k">&gt;</span> time_series <span class="pl-k">=</span> <span class="pl-c1">load_sample</span>(); <span class="pl-c"><span class="pl-c">#</span> load time series samples </span>
julia<span class="pl-k">&gt;</span> symbols, model <span class="pl-k">=</span> <span class="pl-c1">fit_transform</span>(time_series, <span class="pl-c1">4</span>, <span class="pl-c1">0.1</span>); <span class="pl-c"><span class="pl-c">#</span> use 4 symbols with compressed tolerance of 0.1</span>
julia<span class="pl-k">&gt;</span> r_time_series <span class="pl-k">=</span> <span class="pl-c1">inverse_transform</span>(symbols, model, time_series[<span class="pl-c1">1</span>]); <span class="pl-c"><span class="pl-c">#</span> inverse transform time series</span></pre></div>
<p dir="auto">The reconstruction is shown below.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/demo.png"><img src="docs/src/demo.png" alt="Reconstruction" width="360" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-julia-abba-vs-python-abba" class="anchor" aria-hidden="true" href="#julia-abba-vs-python-abba"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Julia ABBA VS Python ABBA</h2>
<p dir="auto">We run <code>ABBAj</code> and Python ABBA in 100 random samples and each sample with 5000 noises generated from normal distribution by specifying the number of symbols at 100, 1000, respectively.</p>
<p dir="auto">The comparison of root-mean-square deviation :</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/MSE.png"><img src="docs/src/MSE.png" alt="mse" width="430" style="max-width: 100%;"></a></p>
<p dir="auto">The comparison of runtime:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/src/RUNTIME.png"><img src="docs/src/RUNTIME.png" alt="runtime" width="430" style="max-width: 100%;"></a></p>
<p dir="auto">The two figures shown in above demonstrate that by using Julia, <code>ABBAj</code> runs much faster than ABBA while the reconstruction accuracy is preserved. The difference results from the k-means implementation.</p>
<h3 dir="auto"><a id="user-content-referece" class="anchor" aria-hidden="true" href="#referece"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Referece</h3>
<p dir="auto">Elsworth, S., Güttel, S. ABBA: adaptive Brownian bridge-based symbolic aggregation of time series. Data Min Knowl Disc 34, 1175–1200 (2020). <a href="https://doi.org/10.1007/s10618-020-00689-6" rel="nofollow">https://doi.org/10.1007/s10618-020-00689-6</a></p>
</article></div>