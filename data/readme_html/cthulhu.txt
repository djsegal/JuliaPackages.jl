<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-cthulhujl-" class="anchor" aria-hidden="true" href="#cthulhujl-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Cthulhu.jl <a href="https://github.com/JuliaDebug/Cthulhu.jl/actions?query=workflow%3A%22CI%22+branch%3Amaster"><img src="https://github.com/JuliaDebug/Cthulhu.jl/workflows/CI/badge.svg" style="max-width: 100%;"></a></h1>
<p dir="auto"><em>The slow descent into madness</em></p>


<p dir="auto"><g-emoji class="g-emoji" alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">⚠️</g-emoji> The latest stable version is only compatible with Julia v1.7 and higher.</p>
<p dir="auto">Cthulhu can help you debug type inference issues by recursively showing the
type-inferred code until you find the exact point where inference gave up,
messed up, or did something unexpected. Using the Cthulhu interface, you can
debug type inference problems faster.</p>
<p dir="auto">Cthulhu's main tool, <code>descend</code>, can be invoked like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="descend(f, tt)     # function `f` and Tuple `tt` of argument types
@descend f(args)   # normal call"><pre><span class="pl-c1">descend</span>(f, tt)     <span class="pl-c"><span class="pl-c">#</span> function `f` and Tuple `tt` of argument types</span>
<span class="pl-c1">@descend</span> <span class="pl-c1">f</span>(args)   <span class="pl-c"><span class="pl-c">#</span> normal call</span></pre></div>
<p dir="auto"><code>descend</code> allows you to interactively explore the type-annotated source
code by descending into the callees of <code>f</code>.
Press enter to select a call to descend into, select <g-emoji class="g-emoji" alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji>  to ascend,
and press q or control-c to quit.
You can also toggle various aspect of the view, for example to suppress
"type-stable" (concretely inferred) annotations or view non-concrete
types in red.
Currently-active options are highlighted with color; press the corresponding
key to toggle these options. Below we walk through a simple example of
these interactive features; you can also see Cthulhu v2.8 in action in
<a href="https://youtu.be/pvduxLowpPY" rel="nofollow">this video</a>.</p>
<h2 dir="auto"><a id="user-content-usage-descend" class="anchor" aria-hidden="true" href="#usage-descend"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage: descend</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function foo()
    T = rand() &gt; 0.5 ? Int64 : Float64
    sum(rand(T, 100))
end

descend(foo, Tuple{})     # option 1: specify by function name and argument types
@descend foo()            # option 2: apply `@descend` to a working execution of the function"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>()
    T <span class="pl-k">=</span> <span class="pl-c1">rand</span>() <span class="pl-k">&gt;</span> <span class="pl-c1">0.5</span> <span class="pl-k">?</span> Int64 <span class="pl-k">:</span> Float64
    <span class="pl-c1">sum</span>(<span class="pl-c1">rand</span>(T, <span class="pl-c1">100</span>))
<span class="pl-k">end</span>

<span class="pl-c1">descend</span>(foo, Tuple{})     <span class="pl-c"><span class="pl-c">#</span> option 1: specify by function name and argument types</span>
<span class="pl-c1">@descend</span> <span class="pl-c1">foo</span>()            <span class="pl-c"><span class="pl-c">#</span> option 2: apply `@descend` to a working execution of the function</span></pre></div>
<p dir="auto">If you do this, you'll see quite a bit of text output. Let's break it down and
see it section-by-section. At the top, you may see something like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="images_readme/descend_source_show_all.png"><img src="images_readme/descend_source_show_all.png" alt="source-section-all" style="max-width: 100%;"></a></p>
<p dir="auto">This shows your original source code (together with line numbers, which here were in the REPL).
The cyan annotations are the types of the variables: <code>Union{Float64, Int64}</code> means "either a <code>Float64</code>
or an <code>Int64</code>".
Small <em>concrete</em> unions (where all the possibilities are known exactly) are generally are not a problem
for type inference, unless there are so many that Julia stops trying to work
out all the different combinations (see <a href="https://julialang.org/blog/2018/08/union-splitting/" rel="nofollow">this blog post</a>
for more information).</p>
<p dir="auto"><strong>Note</strong>: if the function has default positional or keyword arguments, you may see only the signature
of the function. Internally, Julia creates additional methods to fill in default arguments, which in turn call the "body" method that appears in the source text. If you're descending into one of these "default-filling" functions,
you won't be able to see types on variables that appear in the body method, so to reduce confusing the entire body is eliminated. You'll have an opportunity to descend further into the "body" method in the "call menu" described below.</p>
<p dir="auto">In the next section you may see something like</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="images_readme/descend_toggles.png"><img src="images_readme/descend_toggles.png" alt="toggles" style="max-width: 100%;"></a></p>
<p dir="auto">This section shows you some interactive options you have for controlling the display.
Normal text inside <code>[]</code> generally indicates "off", and color is used for "on" or specific options.
For example, if you hit <code>w</code> to turn on warnings, now you should see something like this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="images_readme/descend_source_toggles_warn.png"><img src="images_readme/descend_source_toggles_warn.png" alt="warn" style="max-width: 100%;"></a></p>
<p dir="auto">Note that the <code>w</code> in the <code>[w]arn</code> toggle is now shown in cyan, indicating that it is "on."
Now you can see small concrete unions in yellow, and concretely inferred code in cyan.
Serious forms of poor inferrability are colored in red (of which there are none in this example);
these generally hurt runtime performance and may make compiled code more vulnerable to being invalidated.</p>
<p dir="auto">In the final section, you see:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="images_readme/descend_calls.png"><img src="images_readme/descend_calls.png" alt="calls" style="max-width: 100%;"></a></p>
<p dir="auto">This is a menu of calls that you can further descend into. Move the dot <code>•</code> with the up and down
arrow keys, and hit Enter to descend into a particular call. Note that the naming of calls can sometimes
vary from what you see in the source-text; for example, if you're descending into kwarg-function <code>foo</code>,
then the "body" function might be called something like <code>#foo#123</code>.</p>
<p dir="auto">Any calls that are made at runtime (<a href="https://en.wikipedia.org/wiki/Dynamic_dispatch" rel="nofollow">dynamic dispatch</a>) cannot be descended into;
if you select one, you'll see</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="[ Info: This is a runtime call. You cannot descend into it."><pre class="notranslate"><code>[ Info: This is a runtime call. You cannot descend into it.
</code></pre></div>
<p dir="auto">and the call menu will be printed again.</p>
<p dir="auto">Calls that start with <code>%nn = ...</code> are in Julia's internal
<a href="https://docs.julialang.org/en/v1/devdocs/ast/" rel="nofollow">Abstract Syntax Tree (AST)</a> form;
for these calls, Cthulhu and/or <a href="TypedSyntax/README.md">TypedSyntax</a> (a sub-package living inside the Cthulhu repository) failed to "map" the call back to the original source code.</p>
<h2 dir="auto"><a id="user-content-caveats" class="anchor" aria-hidden="true" href="#caveats"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Caveats</h2>
<p dir="auto">As a word of warning, <strong>mapping type inference results back to the source is hard, and there may be errors or omissions in this mapping</strong>. See the <a href="TypedSyntax/README.md">TypedSyntax README</a> for further details about the challenges. When you think there are reasons to doubt what you're seeing, a reliable but harder-to-interpret strategy is to directly view the <a href="#viewing-the-internal-representation-of-julia-code"><code>[T]yped code</code></a> rather than the <code>[S]ource code</code>.</p>
<p dir="auto">For problems you encounter, please consider filing issues for (and/or making pull requests to fix) any failures you observe. See <a href="CONTRIBUTING.md">CONTRIBUTING.md</a> for tips on filing effective bug reports.</p>
<h2 dir="auto"><a id="user-content-methods-descend" class="anchor" aria-hidden="true" href="#methods-descend"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Methods: descend</h2>
<ul dir="auto">
<li><code>@descend_code_typed</code></li>
<li><code>descend_code_typed</code></li>
<li><code>@descend_code_warntype</code></li>
<li><code>descend_code_warntype</code></li>
<li><code>@descend</code>: Shortcut for <code>@descend_code_typed</code></li>
<li><code>descend</code>: Shortcut for <code>descend_code_typed</code></li>
</ul>
<h2 dir="auto"><a id="user-content-usage-ascend" class="anchor" aria-hidden="true" href="#usage-ascend"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage: ascend</h2>
<p dir="auto">Cthulhu also provides the "upwards-looking" <code>ascend</code>. While <code>descend</code> allows
you to explore a call tree starting from the outermost caller, <code>ascend</code>
allows you to explore a call chain or tree starting from the innermost
callee. Its primary purpose is to support analysis of invalidation and inference
triggers in conjunction with <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile</a>,
but you can use it as a standalone tool.
There is a <a href="https://www.youtube.com/watch?v=7VbXbI6OmYo" rel="nofollow">video using ascend to fix invalidations</a>,
where the part on <code>ascend</code> starts at minute 4:55.</p>
<p dir="auto">For example, you can use it to examine all the inferred callers of a method instance:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; m = which(length, (Set{Symbol},))
length(s::Set) in Base at set.jl:55

julia&gt; mi = m.specializations[1]      # or `mi = first(Base.specializations(m))` on Julia 1.10+
MethodInstance for length(::Set{Symbol})

julia&gt; ascend(mi)
Choose a call for analysis (q to quit):
 &gt;   length(::Set{Symbol})
       union!(::Set{Symbol}, ::Vector{Symbol})
         Set{Symbol}(::Vector{Symbol})
         intersect!(::Set{Union{Int64, Symbol}}, ::Vector{Symbol})
           _shrink(::typeof(intersect!), ::Vector{Union{Int64, Symbol}}, ::Tuple{Vector{Symbol}})
             intersect(::Vector{Union{Int64, Symbol}}, ::Vector{Symbol})
       union!(::Set{Symbol}, ::Set{Symbol})
         union!(::Set{Symbol}, ::Set{Symbol}, ::Set{Symbol})
           union(::Set{Symbol}, ::Set{Symbol})"><pre>julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> <span class="pl-c1">which</span>(length, (Set{Symbol},))
<span class="pl-c1">length</span>(s<span class="pl-k">::</span><span class="pl-c1">Set</span>) <span class="pl-k">in</span> Base at set<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">55</span>

julia<span class="pl-k">&gt;</span> mi <span class="pl-k">=</span> m<span class="pl-k">.</span>specializations[<span class="pl-c1">1</span>]      <span class="pl-c"><span class="pl-c">#</span> or `mi = first(Base.specializations(m))` on Julia 1.10+</span>
MethodInstance <span class="pl-k">for</span> <span class="pl-c1">length</span>(<span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ascend</span>(mi)
Choose a call <span class="pl-k">for</span> analysis (q to quit)<span class="pl-k">:</span>
 <span class="pl-k">&gt;</span>   <span class="pl-c1">length</span>(<span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>)
       <span class="pl-c1">union!</span>(<span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>, <span class="pl-k">::</span><span class="pl-c1">Vector{Symbol}</span>)
         <span class="pl-c1">Set</span><span class="pl-c1">{Symbol}</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Symbol}</span>)
         <span class="pl-c1">intersect!</span>(<span class="pl-k">::</span><span class="pl-c1">Set{Union{Int64, Symbol}}</span>, <span class="pl-k">::</span><span class="pl-c1">Vector{Symbol}</span>)
           <span class="pl-c1">_shrink</span>(<span class="pl-k">::</span><span class="pl-c1">typeof</span>(intersect!), <span class="pl-k">::</span><span class="pl-c1">Vector{Union{Int64, Symbol}}</span>, <span class="pl-k">::</span><span class="pl-c1">Tuple{Vector{Symbol}}</span>)
             <span class="pl-c1">intersect</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Union{Int64, Symbol}}</span>, <span class="pl-k">::</span><span class="pl-c1">Vector{Symbol}</span>)
       <span class="pl-c1">union!</span>(<span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>, <span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>)
         <span class="pl-c1">union!</span>(<span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>, <span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>, <span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>)
           <span class="pl-c1">union</span>(<span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>, <span class="pl-k">::</span><span class="pl-c1">Set{Symbol}</span>)</pre></div>
<p dir="auto">You use the up/down arrows to navigate this menu, enter to select a call to <code>descend</code> into,
and your space bar to toggle branch-folding.</p>
<p dir="auto">It also works on stacktraces. If your version of Julia stores the most recent error in the global <code>err</code> variable, you can use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Cthulhu

julia&gt; sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(f::Symbol, x::Float64)
   @ Base.Math ./math.jl:33
 [2] sqrt
   @ ./math.jl:677 [inlined]
 [3] sqrt(x::Int64)
   @ Base.Math ./math.jl:1491
 [4] top-level scope
   @ REPL[1]:1

julia&gt; ascend(err)
Choose a call for analysis (q to quit):
 &gt;   throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:33
       sqrt(::Int64) at ./math.jl:1491"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Cthulhu

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sqrt</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>)
ERROR<span class="pl-k">:</span> DomainError with <span class="pl-k">-</span><span class="pl-c1">1.0</span><span class="pl-k">:</span>
sqrt will only <span class="pl-k">return</span> a complex result <span class="pl-k">if</span> called with a complex argument. Try <span class="pl-c1">sqrt</span>(<span class="pl-c1">Complex</span>(x)).
Stacktrace<span class="pl-k">:</span>
 [<span class="pl-c1">1</span>] <span class="pl-c1">throw_complex_domainerror</span>(f<span class="pl-k">::</span><span class="pl-c1">Symbol</span>, x<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
   @ Base<span class="pl-k">.</span>Math <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">33</span>
 [<span class="pl-c1">2</span>] sqrt
   @ <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">677</span> [inlined]
 [<span class="pl-c1">3</span>] <span class="pl-c1">sqrt</span>(x<span class="pl-k">::</span><span class="pl-c1">Int64</span>)
   @ Base<span class="pl-k">.</span>Math <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">1491</span>
 [<span class="pl-c1">4</span>] top<span class="pl-k">-</span>level scope
   @ REPL[<span class="pl-c1">1</span>]<span class="pl-k">:</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ascend</span>(err)
Choose a call <span class="pl-k">for</span> analysis (q to quit)<span class="pl-k">:</span>
 <span class="pl-k">&gt;</span>   <span class="pl-c1">throw_complex_domainerror</span>(<span class="pl-k">::</span><span class="pl-c1">Symbol</span>, <span class="pl-k">::</span><span class="pl-c1">Float64</span>) at <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">33</span>
       <span class="pl-c1">sqrt</span>(<span class="pl-k">::</span><span class="pl-c1">Int64</span>) at <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">1491</span></pre></div>
<p dir="auto">If this isn't available to you, a more "manual" approach is:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; bt = try
           [sqrt(x) for x in [1, -1]]
       catch
           catch_backtrace()
       end;

julia&gt; ascend(bt)
Choose a call for analysis (q to quit):
 &gt;   throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:33
       sqrt at ./math.jl:582 =&gt; sqrt at ./math.jl:608 =&gt; iterate at ./generator.jl:47 =&gt; collect_to! at ./array.jl:710 =&gt; collect_to_with_first!(::Vector{Float64}, ::Float64, ::Base.Generator{Vector{Int64}, typeof(sqrt)}, ::Int64) at ./array.jl:688
         collect(::Base.Generator{Vector{Int64}, typeof(sqrt)}) at ./array.jl:669
           eval(::Module, ::Any) at ./boot.jl:360
             eval_user_input(::Any, ::REPL.REPLBackend) at /home/tim/src/julia-master/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:139
..."><pre>julia<span class="pl-k">&gt;</span> bt <span class="pl-k">=</span> <span class="pl-k">try</span>
           [<span class="pl-c1">sqrt</span>(x) <span class="pl-k">for</span> x <span class="pl-k">in</span> [<span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>]]
       <span class="pl-k">catch</span>
           <span class="pl-c1">catch_backtrace</span>()
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ascend</span>(bt)
Choose a call <span class="pl-k">for</span> analysis (q to quit)<span class="pl-k">:</span>
 <span class="pl-k">&gt;</span>   <span class="pl-c1">throw_complex_domainerror</span>(<span class="pl-k">::</span><span class="pl-c1">Symbol</span>, <span class="pl-k">::</span><span class="pl-c1">Float64</span>) at <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">33</span>
       sqrt at <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">582</span> <span class="pl-k">=&gt;</span> sqrt at <span class="pl-k">./</span>math<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">608</span> <span class="pl-k">=&gt;</span> iterate at <span class="pl-k">./</span>generator<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">47</span> <span class="pl-k">=&gt;</span> collect_to! at <span class="pl-k">./</span>array<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">710</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">collect_to_with_first!</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, <span class="pl-k">::</span><span class="pl-c1">Float64</span>, <span class="pl-k">::</span><span class="pl-c1">Base.Generator{Vector{Int64}, typeof(sqrt)}</span>, <span class="pl-k">::</span><span class="pl-c1">Int64</span>) at <span class="pl-k">./</span>array<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">688</span>
         <span class="pl-c1">collect</span>(<span class="pl-k">::</span><span class="pl-c1">Base.Generator{Vector{Int64}, typeof(sqrt)}</span>) at <span class="pl-k">./</span>array<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">669</span>
           <span class="pl-c1">eval</span>(<span class="pl-k">::</span><span class="pl-c1">Module</span>, <span class="pl-k">::</span><span class="pl-c1">Any</span>) at <span class="pl-k">./</span>boot<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">360</span>
             <span class="pl-c1">eval_user_input</span>(<span class="pl-k">::</span><span class="pl-c1">Any</span>, <span class="pl-k">::</span><span class="pl-c1">REPL.REPLBackend</span>) at <span class="pl-k">/</span>home<span class="pl-k">/</span>tim<span class="pl-k">/</span>src<span class="pl-k">/</span>julia<span class="pl-k">-</span>master<span class="pl-k">/</span>usr<span class="pl-k">/</span>share<span class="pl-k">/</span>julia<span class="pl-k">/</span>stdlib<span class="pl-k">/</span>v1.<span class="pl-c1">6</span><span class="pl-k">/</span>REPL<span class="pl-k">/</span>src<span class="pl-k">/</span>REPL<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">139</span>
<span class="pl-k">...</span></pre></div>
<p dir="auto">The calls that appear on the same line separated by <code>=&gt;</code> represent inlined methods; when you select such a line,
you enter at the final (topmost) call on that line.</p>
<p dir="auto">Using Cthulhu may be particularly useful for <code>MethodError</code>s, since those exist purely in the type-domain.</p>
<p dir="auto">By default,</p>
<ul dir="auto">
<li><code>descend</code> views non-optimized code without "warn" coloration of types</li>
<li><code>ascend</code> views non-optimized code with "warn" coloration</li>
</ul>
<p dir="auto">You can toggle between these with <code>o</code> and <code>w</code>.</p>
<h2 dir="auto"><a id="user-content-combine-static-and-runtime-information" class="anchor" aria-hidden="true" href="#combine-static-and-runtime-information"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Combine static and runtime information</h2>
<p dir="auto">Cthulhu has access only to "static" type information, the same information available to the Julia compiler and type inference.
In some situations, this will lead to incomplete or misleading information about type instabilities.</p>
<p dir="auto">Take for example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Infiltrator: @infiltrate
using Cthulhu: @descend
using Base: @noinline # already exported, but be explcit

function foo(n)
    x = n &lt; 2 ? 2 * n : 2.5 * n
    y = n &lt; 4 ? 3 * n : 3.5 * n
    z = n &lt; 5 ? 4 * n : 4.5 * n
    # on Julia v1.6, there is no union splitting for this number of cases.
    bar(x, y, z)
end

@noinline function bar(x, y, z)
    string(x + y + z)
end"><pre><span class="pl-k">using</span> Infiltrator<span class="pl-k">:</span> <span class="pl-c1">@infiltrate</span>
<span class="pl-k">using</span> Cthulhu<span class="pl-k">:</span> <span class="pl-c1">@descend</span>
<span class="pl-k">using</span> Base<span class="pl-k">:</span> <span class="pl-c1">@noinline</span> <span class="pl-c"><span class="pl-c">#</span> already exported, but be explcit</span>

<span class="pl-k">function</span> <span class="pl-en">foo</span>(n)
    x <span class="pl-k">=</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">2</span> <span class="pl-k">?</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> n <span class="pl-k">:</span> <span class="pl-c1">2.5</span> <span class="pl-k">*</span> n
    y <span class="pl-k">=</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">4</span> <span class="pl-k">?</span> <span class="pl-c1">3</span> <span class="pl-k">*</span> n <span class="pl-k">:</span> <span class="pl-c1">3.5</span> <span class="pl-k">*</span> n
    z <span class="pl-k">=</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">5</span> <span class="pl-k">?</span> <span class="pl-c1">4</span> <span class="pl-k">*</span> n <span class="pl-k">:</span> <span class="pl-c1">4.5</span> <span class="pl-k">*</span> n
    <span class="pl-c"><span class="pl-c">#</span> on Julia v1.6, there is no union splitting for this number of cases.</span>
    <span class="pl-c1">bar</span>(x, y, z)
<span class="pl-k">end</span>

<span class="pl-c1">@noinline</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>(x, y, z)
    <span class="pl-c1">string</span>(x <span class="pl-k">+</span> y <span class="pl-k">+</span> z)
<span class="pl-k">end</span></pre></div>
<p dir="auto">Then invoke:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Cthulhu.@descend foo(5)"><pre>Cthulhu<span class="pl-k">.</span><span class="pl-c1">@descend</span> <span class="pl-c1">foo</span>(<span class="pl-c1">5</span>)</pre></div>
<p dir="auto">Now, descend into <code>bar</code>: move the cursor down (or wrap around by hitting the up arrow) until
the dot is next to the <code>bar</code> call:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content=" ⋮
   4  (4.5 * n::Int64)::Float64
 • 6 bar(x, y, z)
   ↩"><pre class="notranslate"><code> ⋮
   4  (4.5 * n::Int64)::Float64
 • 6 bar(x, y, z)
   ↩
</code></pre></div>
<p dir="auto">and then hit Enter. Then you will see the code for <code>bar</code> with its type annotations.</p>
<p dir="auto">Notice that many variables are annotated as <code>Union</code>.
To give Cthulhu more complete type information, we have to actually run some Julia code. There are many ways to do this. In this example, we use <a href="https://github.com/JuliaDebug/Infiltrator.jl"><code>Infiltrator.jl</code></a>.</p>
<p dir="auto">Add an <code>@infiltrate</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function foo(n)
    x = n &lt; 2 ? 2 * n : 2.5 * n
    y = n &lt; 4 ? 3 * n : 3.5 * n
    z = n &lt; 5 ? 4 * n : 4.5 * n
    # on Julia v1.6, there is no union splitting for this number of cases.
    @infiltrate
    bar(x, y, z)
end

@noinline function bar(x, y, z)
    string(x + y + z)
end"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(n)
    x <span class="pl-k">=</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">2</span> <span class="pl-k">?</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> n <span class="pl-k">:</span> <span class="pl-c1">2.5</span> <span class="pl-k">*</span> n
    y <span class="pl-k">=</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">4</span> <span class="pl-k">?</span> <span class="pl-c1">3</span> <span class="pl-k">*</span> n <span class="pl-k">:</span> <span class="pl-c1">3.5</span> <span class="pl-k">*</span> n
    z <span class="pl-k">=</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">5</span> <span class="pl-k">?</span> <span class="pl-c1">4</span> <span class="pl-k">*</span> n <span class="pl-k">:</span> <span class="pl-c1">4.5</span> <span class="pl-k">*</span> n
    <span class="pl-c"><span class="pl-c">#</span> on Julia v1.6, there is no union splitting for this number of cases.</span>
    <span class="pl-c1">@infiltrate</span>
    <span class="pl-c1">bar</span>(x, y, z)
<span class="pl-k">end</span>

<span class="pl-c1">@noinline</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>(x, y, z)
    <span class="pl-c1">string</span>(x <span class="pl-k">+</span> y <span class="pl-k">+</span> z)
<span class="pl-k">end</span></pre></div>
<p dir="auto">Now invoke <code>foo</code> to get REPL in the scope just before <code>bar</code> gets called:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; foo(4)
Infiltrating foo(n::Int64) at ex.jl:10:

infil&gt;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo</span>(<span class="pl-c1">4</span>)
Infiltrating <span class="pl-c1">foo</span>(n<span class="pl-k">::</span><span class="pl-c1">Int64</span>) at ex<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">10</span><span class="pl-k">:</span>

infil<span class="pl-k">&gt;</span></pre></div>
<p dir="auto">Enter <code>@descend bar(x, y, z)</code> you can see that, for <code>foo(4)</code>, the types within <code>bar</code> are fully inferred.</p>
<h2 dir="auto"><a id="user-content-viewing-the-internal-representation-of-julia-code" class="anchor" aria-hidden="true" href="#viewing-the-internal-representation-of-julia-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Viewing the internal representation of Julia code</h2>
<p dir="auto">Anyone using Cthulhu to investigate the behavior of Julia's compiler will
prefer to examine the
While Cthulhu tries to place type-annotations on the source code, this obscures
detail and can occassionally go awry (see details <a href="TypedSyntax/README.md">here</a>).
For anyone who needs more direct insight, it can be better to look directly at Julia's
internal representations of type-inferred code.
Looking at type-inferred code can be a bit daunting initially, but you grow more
comfortable with practice. Consider starting with a
<a href="https://juliadebug.github.io/JuliaInterpreter.jl/stable/ast/" rel="nofollow">tutorial on "lowered" representation</a>,
which introduces most of the new concepts. Type-inferrred code differs from
lowered representation by having additional type annotation.
Moreover, <code>call</code> statements that can be inferred are converted to <code>invoke</code>s
(these correspond to static dispatch), whereas dynamic dispatch is indicated by the
remaining <code>call</code> statements.
Depending on whether you're looking at optimized or non-optimized code,
it may also incorporate inlining and other fairly significant transformations
of the original code as written by the programmer.</p>
<p dir="auto">This video demonstrates Cthulhu for viewing "raw" type-inferred code:
<a href="https://www.youtube.com/watch?v=qf9oA09wxXY" rel="nofollow">Watch on YouTube</a>
<a href="https://www.youtube.com/watch?v=qf9oA09wxXY" rel="nofollow"><img src="https://camo.githubusercontent.com/bd5cf77f33b7b5ae78789025d8a73776292a20cdbe4bc06e97957a8b8ec6273e/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f7166396f413039777858592f302e6a7067" alt="Click to watch video" data-canonical-src="https://img.youtube.com/vi/qf9oA09wxXY/0.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">The version of Cthulhu in the demo is a little outdated, without the newest features,
but may still be relevant for users who want to view code at this level of detail.</p>
<h2 dir="auto"><a id="user-content-customization" class="anchor" aria-hidden="true" href="#customization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Customization</h2>
<p dir="auto">The default configuration of toggles in the <code>@descend</code> menu can be customized
with <code>Cthulhu.CONFIG</code> and persistently saved (via Preferences.jl) using
<code>Cthulhu.save_config!()</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Cthulhu.CONFIG.enable_highlighter = true # Change default
true

julia&gt; Cthulhu.save_config!(Cthulhu.CONFIG) # Will be automatically read next time you `using Cthulhu`"><pre>julia<span class="pl-k">&gt;</span> Cthulhu<span class="pl-k">.</span>CONFIG<span class="pl-k">.</span>enable_highlighter <span class="pl-k">=</span> <span class="pl-c1">true</span> <span class="pl-c"><span class="pl-c">#</span> Change default</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> Cthulhu<span class="pl-k">.</span><span class="pl-c1">save_config!</span>(Cthulhu<span class="pl-k">.</span>CONFIG) <span class="pl-c"><span class="pl-c">#</span> Will be automatically read next time you `using Cthulhu`</span></pre></div>
</article></div>