<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-hmatricesjl" class="anchor" aria-hidden="true" href="#hmatricesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>HMatrices.jl</h1>
<p dir="auto"><em>A package for assembling and factoring hierarchical matrices</em></p>
<p dir="auto"><a href="https://WaveProp.github.io/HMatrices.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://WaveProp.github.io/HMatrices.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/WaveProp/HMatrices.jl/actions"><img src="https://github.com/WaveProp/HMatrices.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/WaveProp/HMatrices.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/022ef4231d08d0c8fa53dfc07b4baa7d82a86e9492ccef493ad7c0a222270692/68747470733a2f2f636f6465636f762e696f2f67682f5761766550726f702f484d617472696365732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d44525437355752375632" alt="codecov" data-canonical-src="https://codecov.io/gh/WaveProp/HMatrices.jl/branch/main/graph/badge.svg?token=DRT75WR7V2" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/84b0d27f8df4fc6c45103c6f951fdaaac5171efe4c4a633c3912085fc078d95d/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d626c75652e737667"><img src="https://camo.githubusercontent.com/84b0d27f8df4fc6c45103c6f951fdaaac5171efe4c4a633c3912085fc078d95d/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d626c75652e737667" alt="Lifecycle" data-canonical-src="https://img.shields.io/badge/lifecycle-experimental-blue.svg" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Install from the Pkg REPL:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="pkg&gt; add HMatrices"><pre class="notranslate"><code>pkg&gt; add HMatrices
</code></pre></div>
<h2 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h2>
<p dir="auto">This package provides some functionality for assembling as well as for doing
linear algebra with <a href="https://en.wikipedia.org/wiki/Hierarchical_matrix" rel="nofollow">hierarchical
matrices</a> with a strong focus
in applications arising in <strong>boundary integral equation</strong> methods.</p>
<p dir="auto">For the purpose of illustration, let us consider an abstract matrix <code>K</code> with
entry <code>i,j</code> given by the evaluation of some <em>kernel function</em> <code>G</code> on points
<code>X[i]</code> and <code>Y[j]</code>, where <code>X</code> and <code>Y</code> are vector of points (in 3D here); that is,
<code>K[i,j]=G(X[i],Y[j])</code>. This object can be constructed as follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using HMatrices, LinearAlgebra, StaticArrays
const Point3D = SVector{3,Float64}
# sample some points on a sphere
m = 100_000
X = Y = [Point3D(sin(θ)cos(ϕ),sin(θ)*sin(ϕ),cos(θ)) for (θ,ϕ) in zip(π*rand(m),2π*rand(m))]
function G(x,y) 
  d = norm(x-y) + 1e-8
  1/(4π*d)
end
K = KernelMatrix(G,X,Y)"><pre><span class="pl-k">using</span> HMatrices, LinearAlgebra, StaticArrays
<span class="pl-k">const</span> Point3D <span class="pl-k">=</span> SVector{<span class="pl-c1">3</span>,Float64}
<span class="pl-c"><span class="pl-c">#</span> sample some points on a sphere</span>
m <span class="pl-k">=</span> <span class="pl-c1">100_000</span>
X <span class="pl-k">=</span> Y <span class="pl-k">=</span> [<span class="pl-c1">Point3D</span>(<span class="pl-c1">sin</span>(θ)<span class="pl-c1">cos</span>(ϕ),<span class="pl-c1">sin</span>(θ)<span class="pl-k">*</span><span class="pl-c1">sin</span>(ϕ),<span class="pl-c1">cos</span>(θ)) <span class="pl-k">for</span> (θ,ϕ) <span class="pl-k">in</span> <span class="pl-c1">zip</span>(π<span class="pl-k">*</span><span class="pl-c1">rand</span>(m),<span class="pl-c1">2</span>π<span class="pl-k">*</span><span class="pl-c1">rand</span>(m))]
<span class="pl-k">function</span> <span class="pl-en">G</span>(x,y) 
  d <span class="pl-k">=</span> <span class="pl-c1">norm</span>(x<span class="pl-k">-</span>y) <span class="pl-k">+</span> <span class="pl-c1">1e-8</span>
  <span class="pl-c1">1</span><span class="pl-k">/</span>(<span class="pl-c1">4</span>π<span class="pl-k">*</span>d)
<span class="pl-k">end</span>
K <span class="pl-k">=</span> <span class="pl-c1">KernelMatrix</span>(G,X,Y)</pre></div>
<p dir="auto">where we took <code>G</code> to be the free-space Greens function of Laplace's
equation in 3D (to avoid division-by-zero we added <code>1e-8</code> to the distance
between points).</p>
<p dir="auto">The object <code>K</code> corresponds to a dense matrix, so converting it to a matrix can
be costly both in terms of memory and flops. Instead, we can construct an
approximation to <code>K</code> as a hierarchical matrix using:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="H = assemble_hmat(K;atol=1e-6)"><pre>H <span class="pl-k">=</span> <span class="pl-c1">assemble_hmat</span>(K;atol<span class="pl-k">=</span><span class="pl-c1">1e-6</span>)</pre></div>
<blockquote>
<p dir="auto"><strong>Tip</strong>: For a smaller problem size (say <code>m=10_000</code>), you may try</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Plots
plot(H)"><pre><span class="pl-k">using</span> Plots
<span class="pl-c1">plot</span>(H)</pre></div>
<p dir="auto">to visualize the underlying block-structure. You should see something similar
to the figure below:
<a target="_blank" rel="noopener noreferrer" href="docs/src/assets/hmatrix.png"><img src="docs/src/assets/hmatrix.png" alt="HMatrix" title="HMatrix" style="max-width: 100%;"></a></p>
</blockquote>
<p dir="auto">Calling <code>HMatrices.compression_ratio(H)</code> reveals that storing a dense version of
<code>K</code> would take roughly <code>25</code> times as much space (and probably would not fit in
most laptops). We can now use <code>H</code> as an approximation to <code>K</code> for some linear
algebra operations, such as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = rand(m)
y = H*x"><pre>x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(m)
y <span class="pl-k">=</span> H<span class="pl-k">*</span>x</pre></div>
<p dir="auto">To check that this is indeed an approximation, we can compare against the exact
value at a given entry:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y[42] - sum(K[42,j]*x[j] for j in 1:m)
# about 2e-7"><pre>y[<span class="pl-c1">42</span>] <span class="pl-k">-</span> <span class="pl-c1">sum</span>(K[<span class="pl-c1">42</span>,j]<span class="pl-k">*</span>x[j] <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>m)
<span class="pl-c"><span class="pl-c">#</span> about 2e-7</span></pre></div>
<p dir="auto">It is also possibly to factor <code>H</code> by calling e.g. <code>lu(H;atol=1e-6)</code> (this may
take a few minutes on a reasonable machine for the <code>100_000 × 100_000</code> problem
size and specified tolerance). The result is an <code>LU</code> factorization object with a
hierarchical low-rank structure, and the factored object can be used both in a
direct solver or as a preconditioner for <code>H</code> in an iterative solver.</p>
<p dir="auto">For more information, see the <a href="https://waveprop.github.io/HMatrices.jl/dev/" rel="nofollow">documentation</a>.</p>
<h2 dir="auto"><a id="user-content-references-and-related-packages" class="anchor" aria-hidden="true" href="#references-and-related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References and related packages</h2>
<p dir="auto">Below are some good references on hierarchical matrices and their application to
boundary integral equations:</p>
<p dir="auto">[1] Hackbusch, Wolfgang. Hierarchical matrices: algorithms and analysis. Vol. 49. Heidelberg: Springer, 2015.</p>
<p dir="auto">[2] Bebendorf, Mario. Hierarchical matrices. Springer Berlin Heidelberg, 2008.</p>
<p dir="auto">If you are interested in hierarchical matrices and Julia, check out also the
following packages:</p>
<ul dir="auto">
<li><a href="https://github.com/JuliaMatrices/HierarchicalMatrices.jl">HierarchicalMatrices.jl</a>:
a flexible framework for hierarchical matrices implementing an abstract
infrastructure.</li>
<li><a href="https://bitbucket.org/cgeoga/kernelmatrices.jl" rel="nofollow">KernelMatrices.jl</a>: a library
implementing the <em>Hierarchically Off-Diagonal Low-Rank</em> structure (HODLR).</li>
<li><a href="https://github.com/bonevbs/HssMatrices.jl">HSSMatrices.jl</a>: an implementation
of the <em>Hierarchically semi-separable</em> structure (HSS).</li>
</ul>
</article></div>