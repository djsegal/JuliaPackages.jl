<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-metaljl" class="anchor" aria-hidden="true" href="#metaljl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Metal.jl</h1>
<p dir="auto"><em>Metal programming in Julia</em></p>
<p dir="auto"><a href="https://zenodo.org/badge/latestdoi/262279120" rel="nofollow"><img src="https://camo.githubusercontent.com/3cb71e3cc7e7a0cfdae556f49266288af059f91f17b1ca6e19961217bd24f601/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3236323237393132302e737667" alt="" data-canonical-src="https://zenodo.org/badge/262279120.svg" style="max-width: 100%;"></a> <a href="https://metal.juliagpu.org/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a> <a href="https://metal.juliagpu.org/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a> <a href="https://buildkite.com/julialang/metal-dot-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c654af67cc63231f09c1713d9bb23e1eb2518058bc56ddec8eb3e3072cc47834/68747470733a2f2f62616467652e6275696c646b6974652e636f6d2f61396233333562376435643464376561393062303331303537373238646539643165396137336435626364396438393635352e7376673f6272616e63683d6d61696e" alt="" data-canonical-src="https://badge.buildkite.com/a9b335b7d5d4d7ea90b031057728de9d1e9a73d5bcd9d89655.svg?branch=main" style="max-width: 100%;"></a> <a href="https://codecov.io/gh/JuliaGPU/Metal.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c571c78dd511582837eb07c2db047ee22f05afb1513f8601540be8897a774c37/68747470733a2f2f636f6465636f762e696f2f67682f4a756c69614750552f4d6574616c2e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="" data-canonical-src="https://codecov.io/gh/JuliaGPU/Metal.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">With Metal.jl it's possible to program GPUs on macOS using the Metal programming
framework.</p>
<p dir="auto"><strong>The package is a work-in-progress.</strong> There are bugs, functionality is missing,
and performance hasn't been optimized. Expect to have to make changes to this package
if you want to use it. PRs are very welcome!</p>
<h2 dir="auto"><a id="user-content-requirements" class="anchor" aria-hidden="true" href="#requirements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Requirements</h2>
<ul dir="auto">
<li>Mac device with M-series chip</li>
<li>Julia 1.8</li>
<li>macOS 13 (Ventura)</li>
</ul>
<p dir="auto">These requirements are fairly strict, and are due to our limited development
resources (manpower, hardware). Technically, they can be relaxed. If you are
interested in contributing to this, see <a href="https://github.com/JuliaGPU/Metal.jl/issues/22" data-hovercard-type="issue" data-hovercard-url="/JuliaGPU/Metal.jl/issues/22/hovercard">this
issue</a> for more details.
In practice, Metal.jl will probably work on any macOS 10.15+, and other
GPUs that are supported by Metal might also function (if only partially),
but such combinations are unsupported for now.</p>
<h2 dir="auto"><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick start</h2>
<p dir="auto">Metal.jl can be installed with the Julia package manager. From the Julia REPL, type <code>]</code> to
enter the Pkg REPL mode and run:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="pkg&gt; add Metal"><pre class="notranslate"><code>pkg&gt; add Metal
</code></pre></div>
<p dir="auto">Or, equivalently, via the <code>Pkg</code> API:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; import Pkg; Pkg.add(&quot;Metal&quot;)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">import</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>Metal<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">For an overview of the toolchain in use, you can run the following command after
importing the package:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Metal

julia&gt; Metal.versioninfo()
macOS 12.2.0, Darwin 21.3.0

Toolchain:
- Julia: 1.8.0-beta3
- LLVM: 13.0.1

1 device:
- Apple M1 Pro (64.000 KiB allocated)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Metal

julia<span class="pl-k">&gt;</span> Metal<span class="pl-k">.</span><span class="pl-c1">versioninfo</span>()
macOS <span class="pl-c1">12.2</span>.<span class="pl-c1">0</span>, Darwin <span class="pl-c1">21.3</span>.<span class="pl-c1">0</span>

Toolchain<span class="pl-k">:</span>
<span class="pl-k">-</span> Julia<span class="pl-k">:</span> <span class="pl-c1">1.8</span>.<span class="pl-c1">0</span><span class="pl-k">-</span>beta3
<span class="pl-k">-</span> LLVM<span class="pl-k">:</span> <span class="pl-c1">13.0</span>.<span class="pl-c1">1</span>

<span class="pl-c1">1</span> device<span class="pl-k">:</span>
<span class="pl-k">-</span> Apple M1 Pro (<span class="pl-c1">64.000</span> KiB allocated)</pre></div>
<h2 dir="auto"><a id="user-content-array-abstraction" class="anchor" aria-hidden="true" href="#array-abstraction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Array abstraction</h2>
<p dir="auto">The easiest way to work with Metal.jl, is by using its array abstraction.
The <code>MtlArray</code> type is both meant to be a convenient container for device
memory, as well as provide a data-parallel abstraction for using the GPU
without writing your own kernels:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; a = MtlArray([1])
1-element MtlArray{Int64, 1}:
 1

julia&gt; a .+ 1
1-element MtlArray{Int64, 1}:
 2"><pre>julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">MtlArray</span>([<span class="pl-c1">1</span>])
<span class="pl-c1">1</span><span class="pl-k">-</span>element MtlArray{Int64, <span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> a <span class="pl-k">.+</span> <span class="pl-c1">1</span>
<span class="pl-c1">1</span><span class="pl-k">-</span>element MtlArray{Int64, <span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2</span></pre></div>
<h2 dir="auto"><a id="user-content-kernel-programming" class="anchor" aria-hidden="true" href="#kernel-programming"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Kernel programming</h2>
<p dir="auto">The above array abstractions are all implemented using Metal kernels written
in Julia. These kernels follow a similar programming style to Julia's other
GPU back-ends, and with that deviate from how kernels are implemented in Metal C
(i.e., indexing intrinsics are functions not arguments, arbitrary aggregate arguments
are supported, etc):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; function vadd(a, b, c)
           i = thread_position_in_grid_1d()
           c[i] = a[i] + b[i]
           return
       end
vadd (generic function with 1 method)

julia&gt; a = MtlArray([1,1,1,1]); b = MtlArray([2,2,2,2]); c = similar(a);

julia&gt; @metal threads=2 groups=2 vadd(a, b, c)

julia&gt; Array(c)
4-element Vector{Int64}:
 3
 3
 3
 3"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">vadd</span>(a, b, c)
           i <span class="pl-k">=</span> <span class="pl-c1">thread_position_in_grid_1d</span>()
           c[i] <span class="pl-k">=</span> a[i] <span class="pl-k">+</span> b[i]
           <span class="pl-k">return</span>
       <span class="pl-k">end</span>
vadd (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">MtlArray</span>([<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]); b <span class="pl-k">=</span> <span class="pl-c1">MtlArray</span>([<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]); c <span class="pl-k">=</span> <span class="pl-c1">similar</span>(a);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@metal</span> threads<span class="pl-k">=</span><span class="pl-c1">2</span> groups<span class="pl-k">=</span><span class="pl-c1">2</span> <span class="pl-c1">vadd</span>(a, b, c)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Array</span>(c)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Vector{Int64}<span class="pl-k">:</span>
 <span class="pl-c1">3</span>
 <span class="pl-c1">3</span>
 <span class="pl-c1">3</span>
 <span class="pl-c1">3</span></pre></div>
<h2 dir="auto"><a id="user-content-profiling" class="anchor" aria-hidden="true" href="#profiling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Profiling</h2>
<p dir="auto">This package also supports profiling GPU execution for later visualization with Apple's
Xcode tools. The easiest way to generate a GPU report is to use the <code>Metal.@profile</code> macro
as seen below. To profile GPU code from a Julia process, you must set the
<code>METAL_CAPTURE_ENABLED</code> environment variable before importing Metal.jl. On the first Metal
command detected, you should get a message stating "Metal GPU Frame Capture Enabled" if the
variable was set correctly:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ENV[&quot;METAL_CAPTURE_ENABLED&quot;] = 1
julia&gt; using Metal

julia&gt; function vadd(a, b, c)
           i = thread_position_in_grid_1d()
           c[i] = a[i] + b[i]
           return
       end

julia&gt; a = MtlArray([1]); b = MtlArray([2]); c = similar(a);
... Metal GPU Frame Capture Enabled

julia&gt; Metal.@profile @metal threads=length(c) vadd(a, b, c);
[ Info: GPU frame capture saved to julia_capture_1.gputrace"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>METAL_CAPTURE_ENABLED<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>
julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Metal

julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">vadd</span>(a, b, c)
           i <span class="pl-k">=</span> <span class="pl-c1">thread_position_in_grid_1d</span>()
           c[i] <span class="pl-k">=</span> a[i] <span class="pl-k">+</span> b[i]
           <span class="pl-k">return</span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">MtlArray</span>([<span class="pl-c1">1</span>]); b <span class="pl-k">=</span> <span class="pl-c1">MtlArray</span>([<span class="pl-c1">2</span>]); c <span class="pl-k">=</span> <span class="pl-c1">similar</span>(a);
<span class="pl-k">...</span> Metal GPU Frame Capture Enabled

julia<span class="pl-k">&gt;</span> Metal<span class="pl-k">.</span><span class="pl-c1">@profile</span> <span class="pl-c1">@metal</span> threads<span class="pl-k">=</span><span class="pl-c1">length</span>(c) <span class="pl-c1">vadd</span>(a, b, c);
[ Info<span class="pl-k">:</span> GPU frame capture saved to julia_capture_1<span class="pl-k">.</span>gputrace</pre></div>
<p dir="auto">This will generate a <code>.gputrace</code> folder in the current directory. To view the profile, open
the folder with Xcode.</p>
<p dir="auto">Note: Xcode is a large install, and there are some peculiarities with viewing Julia-created
GPU traces. It's recommended to only have one trace open at a time, and the shader profiler
may fail to start.</p>
<h2 dir="auto"><a id="user-content-metal-api-wrapper" class="anchor" aria-hidden="true" href="#metal-api-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Metal API wrapper</h2>
<p dir="auto">Finally, all of the above functionality is made possible by interfacing with the Metal
libraries through <a href="https://github.com/JuliaInterop/ObjectiveC.jl">ObjectiveC.jl</a>. We provide low-level objects and functions that map  These
low-level API wrappers, along with some slightly higher-level Julia wrappers, are available
in the <code>MTL</code> submodule exported by Metal.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; dev = MTLDevice(1)
&lt;AGXG13XDevice: 0x14c17f200&gt;
    name = Apple M1 Pro

julia&gt; dev.name
NSString(&quot;Apple M1 Pro&quot;)"><pre>julia<span class="pl-k">&gt;</span> dev <span class="pl-k">=</span> <span class="pl-c1">MTLDevice</span>(<span class="pl-c1">1</span>)
<span class="pl-k">&lt;</span>AGXG13XDevice<span class="pl-k">:</span> <span class="pl-c1">0x14c17f200</span><span class="pl-k">&gt;</span>
    name <span class="pl-k">=</span> Apple M1 Pro

julia<span class="pl-k">&gt;</span> dev<span class="pl-k">.</span>name
<span class="pl-c1">NSString</span>(<span class="pl-s"><span class="pl-pds">"</span>Apple M1 Pro<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-hacking" class="anchor" aria-hidden="true" href="#hacking"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hacking</h2>
<p dir="auto">Metal.jl relies on a custom <a href="https://github.com/JuliaGPU/llvm-metal">LLVM with an AIR
back-end</a>, provided as a JLL. Normally, this JLLis
built on <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/master/M/Metal_LLVM_Tools/build_tarballs.jl">Yggdrasil</a>.
If you need to make changes to the LLVM back-end, have a look at the <code>build_llvm.jl</code> in the <code>deps/</code> folder. This
scripts builds a local version of the LLVM back-end, and configures a local preference such
that any environment depending on the corresponding JLLs will pick-up the modified version
(i.e., do <code>julia --project</code> in a clone of <code>Metal.jl</code>).</p>
<h2 dir="auto"><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgements</h2>
<p dir="auto">This package builds upon the experience of several
Julia contributors to CUDA.jl, AMDGPU.jl and oneAPI.jl.</p>
</article></div>