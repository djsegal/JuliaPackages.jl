<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-basinsjl" class="anchor" aria-hidden="true" href="#basinsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basins.jl</h1>
<p>This Julia package computes basins of attraction of dynamical systems in the phase plane and also
several metrics over the basins. The algorithm computes the basin without prior knowledge of the attractors.</p>
<p>This package depends heavily on the package DynamicalSystems and DifferentialEquations for the definitions of the dynamical systems. However it is possible to define custom integrators.</p>
<p>The package provides the following metrics:</p>
<ol>
<li>Basins of attraction</li>
<li>Basin entropy</li>
<li>Uncertainty exponent</li>
<li>Wada detection</li>
<li>Basin saddles</li>
<li>Basin stability</li>
<li>Examples</li>
</ol>
<h2><a id="user-content-1---computing-the-basins-of-attraction" class="anchor" aria-hidden="true" href="#1---computing-the-basins-of-attraction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1 - Computing the basins of attraction</h2>
<p>The technique used to compute the basin of attraction is described in ref. [1]. It consists in tracking the trajectory on the plane and coloring the points of according to the attractor it leads to. This technique is very efficient for 2D basins.</p>
<p>The algorithm gives back a matrix with the attractor numbered from 1 to N. If an attractor exists outside the defined grid of if the trajectory escapes, this initial condition is labelled -1. It may happens for example if there is a fixed point not on the Poincaré map.</p>
<h3><a id="user-content-11---stroboscopic-maps" class="anchor" aria-hidden="true" href="#11---stroboscopic-maps"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.1 - Stroboscopic Maps</h3>
<p>First define a dynamical system on the plane, for example with a <em>stroboscopic</em> map or Poincaré section. For example we can set up an dynamical system with a stroboscopic map defined:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Basins, DynamicalSystems, DifferentialEquations
ω=1.; F=0.2
ds =Systems.duffing([0.1, 0.25]; ω = ω, f = F, d = 0.15, β = -1)
integ  = integrator(ds; alg=Tsit5(),  reltol=1e-8, save_everystep=false)
"><pre><span class="pl-k">using</span> Basins, DynamicalSystems, DifferentialEquations
ω<span class="pl-k">=</span><span class="pl-c1">1.</span>; F<span class="pl-k">=</span><span class="pl-c1">0.2</span>
ds <span class="pl-k">=</span>Systems<span class="pl-k">.</span><span class="pl-c1">duffing</span>([<span class="pl-c1">0.1</span>, <span class="pl-c1">0.25</span>]; ω <span class="pl-k">=</span> ω, f <span class="pl-k">=</span> F, d <span class="pl-k">=</span> <span class="pl-c1">0.15</span>, β <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>)
integ  <span class="pl-k">=</span> <span class="pl-c1">integrator</span>(ds; alg<span class="pl-k">=</span><span class="pl-c1">Tsit5</span>(),  reltol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p>Now we define the grid of ICs that we want to analyze and launch the procedure:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="xg = range(-2.2,2.2,length=200)
yg = range(-2.2,2.2,length=200)
bsn=basins_map2D(xg, yg, integ; T=2π/ω)
"><pre>xg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
yg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
bsn<span class="pl-k">=</span><span class="pl-c1">basins_map2D</span>(xg, yg, integ; T<span class="pl-k">=</span><span class="pl-c1">2</span>π<span class="pl-k">/</span>ω)</pre></div>
<p>The keyword arguments are:</p>
<ul>
<li><code>T</code> : the period of the stroboscopic map.</li>
<li><code>idxs</code> : the indices of the variable to track on the plane. By default the initial conditions of other variables are set to zero.</li>
</ul>
<p>The function returns a structure <code>bsn</code> with several fields of interests:</p>
<ul>
<li><code>bsn.basin</code> is a matrix that contains the information of the basins of attraction. The attractors are numbered from 1 to N and each element
correspond to an initial condition on the grid.</li>
<li><code>bsn.xg</code> and <code>bsn.yg</code> are the grid vectors.</li>
<li><code>bsn.attractors</code> is a collection of vectors with the location of the attractors found.</li>
</ul>
<p>Now we can plot the nice result of the computation:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Plots
plot(xg,yg,bsn.basin', seriestype=:heatmap)

"><pre><span class="pl-k">using</span> Plots
<span class="pl-c1">plot</span>(xg,yg,bsn<span class="pl-k">.</span>basin<span class="pl-k">'</span>, seriestype<span class="pl-k">=</span><span class="pl-c1">:heatmap</span>)
</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/a92b033f78e6096a74e67910915a541b01c511a63a2abd851bbf8369ed4f4f1d/68747470733a2f2f692e696d6775722e636f6d2f523276656235746c2e706e67"><img src="https://camo.githubusercontent.com/a92b033f78e6096a74e67910915a541b01c511a63a2abd851bbf8369ed4f4f1d/68747470733a2f2f692e696d6775722e636f6d2f523276656235746c2e706e67" alt="image" data-canonical-src="https://i.imgur.com/R2veb5tl.png" style="max-width:100%;"></a></p>
<h3><a id="user-content-12---poincaré-maps" class="anchor" aria-hidden="true" href="#12---poincaré-maps"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.2 - Poincaré Maps</h3>
<p>Another example with a Poincaré map:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Plots
using DynamicalSystems
using Basins

ds = Systems.rikitake(μ = 0.47, α = 1.0)
integ=integrator(ds)
"><pre><span class="pl-k">using</span> Plots
<span class="pl-k">using</span> DynamicalSystems
<span class="pl-k">using</span> Basins

ds <span class="pl-k">=</span> Systems<span class="pl-k">.</span><span class="pl-c1">rikitake</span>(μ <span class="pl-k">=</span> <span class="pl-c1">0.47</span>, α <span class="pl-k">=</span> <span class="pl-c1">1.0</span>)
integ<span class="pl-k">=</span><span class="pl-c1">integrator</span>(ds)</pre></div>
<p>Once the integrator has been set, the Poincaré map can defined on a plane:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="xg=range(-6.,6.,length=200)
yg=range(-6.,6.,length=200)
pmap = poincaremap(ds, (3, 0.), Tmax=1e6; idxs = 1:2, rootkw = (xrtol = 1e-8, atol = 1e-8), reltol=1e-9)

@time bsn = basin_poincare_map(xg, yg, pmap)

plot(xg,yg,bsn.basin',seriestype=:heatmap)
"><pre>xg<span class="pl-k">=</span><span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">6.</span>,<span class="pl-c1">6.</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
yg<span class="pl-k">=</span><span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">6.</span>,<span class="pl-c1">6.</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
pmap <span class="pl-k">=</span> <span class="pl-c1">poincaremap</span>(ds, (<span class="pl-c1">3</span>, <span class="pl-c1">0.</span>), Tmax<span class="pl-k">=</span><span class="pl-c1">1e6</span>; idxs <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, rootkw <span class="pl-k">=</span> (xrtol <span class="pl-k">=</span> <span class="pl-c1">1e-8</span>, atol <span class="pl-k">=</span> <span class="pl-c1">1e-8</span>), reltol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>)

<span class="pl-c1">@time</span> bsn <span class="pl-k">=</span> <span class="pl-c1">basin_poincare_map</span>(xg, yg, pmap)

<span class="pl-c1">plot</span>(xg,yg,bsn<span class="pl-k">.</span>basin<span class="pl-k">'</span>,seriestype<span class="pl-k">=</span><span class="pl-c1">:heatmap</span>)</pre></div>
<p>The arguments are:</p>
<ul>
<li><code>pmap</code> : A Poincaré map as defined in <a href="https://github.com/JuliaDynamics/ChaosTools.jl">ChaosTools.jl</a></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/54566873f0cbacdf2a203365361adf80fdeddc884ee2b11724947887c45f2f23/68747470733a2f2f692e696d6775722e636f6d2f684b634f6977546c2e706e67"><img src="https://camo.githubusercontent.com/54566873f0cbacdf2a203365361adf80fdeddc884ee2b11724947887c45f2f23/68747470733a2f2f692e696d6775722e636f6d2f684b634f6977546c2e706e67" alt="image" data-canonical-src="https://i.imgur.com/hKcOiwTl.png" style="max-width:100%;"></a></p>
<h3><a id="user-content-13---discrete-maps" class="anchor" aria-hidden="true" href="#13---discrete-maps"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.3 - Discrete Maps</h3>
<p>The process to compute the basin of a discrete map is very similar:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function newton_map(dz,z, p, n)
    f(x) = x^p[1]-1
    df(x)= p[1]*x^(p[1]-1)
    z1 = z[1] + im*z[2]
    dz1 = f(z1)/df(z1)
    z1 = z1 - dz1
    dz[1]=real(z1)
    dz[2]=imag(z1)
    return
end

# dummy Jacobian function to keep the initializator happy
function newton_map_J(J,z0, p, n)
   return
end

ds = DiscreteDynamicalSystem(newton_map,[0.1, 0.2], [3] , newton_map_J)
integ  = integrator(ds)

xg=range(-1.5,1.5,length=200)
yg=range(-1.5,1.5,length=200)

bsn=basin_discrete_map(xg, yg, integ)
"><pre><span class="pl-k">function</span> <span class="pl-en">newton_map</span>(dz,z, p, n)
    <span class="pl-en">f</span>(x) <span class="pl-k">=</span> x<span class="pl-k">^</span>p[<span class="pl-c1">1</span>]<span class="pl-k">-</span><span class="pl-c1">1</span>
    <span class="pl-en">df</span>(x)<span class="pl-k">=</span> p[<span class="pl-c1">1</span>]<span class="pl-k">*</span>x<span class="pl-k">^</span>(p[<span class="pl-c1">1</span>]<span class="pl-k">-</span><span class="pl-c1">1</span>)
    z1 <span class="pl-k">=</span> z[<span class="pl-c1">1</span>] <span class="pl-k">+</span> im<span class="pl-k">*</span>z[<span class="pl-c1">2</span>]
    dz1 <span class="pl-k">=</span> <span class="pl-c1">f</span>(z1)<span class="pl-k">/</span><span class="pl-c1">df</span>(z1)
    z1 <span class="pl-k">=</span> z1 <span class="pl-k">-</span> dz1
    dz[<span class="pl-c1">1</span>]<span class="pl-k">=</span><span class="pl-c1">real</span>(z1)
    dz[<span class="pl-c1">2</span>]<span class="pl-k">=</span><span class="pl-c1">imag</span>(z1)
    <span class="pl-k">return</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> dummy Jacobian function to keep the initializator happy</span>
<span class="pl-k">function</span> <span class="pl-en">newton_map_J</span>(J,z0, p, n)
   <span class="pl-k">return</span>
<span class="pl-k">end</span>

ds <span class="pl-k">=</span> <span class="pl-c1">DiscreteDynamicalSystem</span>(newton_map,[<span class="pl-c1">0.1</span>, <span class="pl-c1">0.2</span>], [<span class="pl-c1">3</span>] , newton_map_J)
integ  <span class="pl-k">=</span> <span class="pl-c1">integrator</span>(ds)

xg<span class="pl-k">=</span><span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">1.5</span>,<span class="pl-c1">1.5</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
yg<span class="pl-k">=</span><span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">1.5</span>,<span class="pl-c1">1.5</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)

bsn<span class="pl-k">=</span><span class="pl-c1">basin_discrete_map</span>(xg, yg, integ)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/c774f601d20a348ca3de38f26067201f0b102884416b4a70699d98cb872d4731/68747470733a2f2f692e696d6775722e636f6d2f7070486c4750626c2e706e67"><img src="https://camo.githubusercontent.com/c774f601d20a348ca3de38f26067201f0b102884416b4a70699d98cb872d4731/68747470733a2f2f692e696d6775722e636f6d2f7070486c4750626c2e706e67" alt="image" data-canonical-src="https://i.imgur.com/ppHlGPbl.png" style="max-width:100%;"></a></p>
<h3><a id="user-content-14---custom-differential-equations-and-low-level-functions" class="anchor" aria-hidden="true" href="#14---custom-differential-equations-and-low-level-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.4 - Custom differential equations and low level functions.</h3>
<p>Supose we want to define a custom ODE and compute the basin of attraction on a defined
Poincaré map:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using DifferentialEquations
using Basins

@inline @inbounds function duffing(u, p, t)
    d = p[1]; F = p[2]; omega = p[3]
    du1 = u[2]
    du2 = -d*u[2] + u[1] - u[1]^3 + F*sin(omega*t)
    return SVector{2}(du1, du2)
end

d=0.15; F=0.2; ω = 0.5848
ds = ContinuousDynamicalSystem(duffing, rand(2), [d, F, ω])
integ = integrator(ds; alg=Tsit5(),  reltol=1e-8, save_everystep=false)
xg = range(-2.2,2.2,length=200)
yg = range(-2.2,2.2,length=200)

iter_f! = (integ) -&gt; step!(integ, 2π/ω, true)
reinit_f! =  (integ,y) -&gt;  reinit!(integ, [y...])
get_u = (integ) -&gt; integ.u[1:2]

bsn = draw_basin(xg, yg, integ, iter_f!, reinit_f!, get_u)
"><pre><span class="pl-k">using</span> DifferentialEquations
<span class="pl-k">using</span> Basins

<span class="pl-c1">@inline</span> <span class="pl-c1">@inbounds</span> <span class="pl-k">function</span> <span class="pl-en">duffing</span>(u, p, t)
    d <span class="pl-k">=</span> p[<span class="pl-c1">1</span>]; F <span class="pl-k">=</span> p[<span class="pl-c1">2</span>]; omega <span class="pl-k">=</span> p[<span class="pl-c1">3</span>]
    du1 <span class="pl-k">=</span> u[<span class="pl-c1">2</span>]
    du2 <span class="pl-k">=</span> <span class="pl-k">-</span>d<span class="pl-k">*</span>u[<span class="pl-c1">2</span>] <span class="pl-k">+</span> u[<span class="pl-c1">1</span>] <span class="pl-k">-</span> u[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">+</span> F<span class="pl-k">*</span><span class="pl-c1">sin</span>(omega<span class="pl-k">*</span>t)
    <span class="pl-k">return</span> <span class="pl-c1">SVector</span><span class="pl-c1">{2}</span>(du1, du2)
<span class="pl-k">end</span>

d<span class="pl-k">=</span><span class="pl-c1">0.15</span>; F<span class="pl-k">=</span><span class="pl-c1">0.2</span>; ω <span class="pl-k">=</span> <span class="pl-c1">0.5848</span>
ds <span class="pl-k">=</span> <span class="pl-c1">ContinuousDynamicalSystem</span>(duffing, <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>), [d, F, ω])
integ <span class="pl-k">=</span> <span class="pl-c1">integrator</span>(ds; alg<span class="pl-k">=</span><span class="pl-c1">Tsit5</span>(),  reltol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>)
xg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
yg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)

iter_f! <span class="pl-k">=</span> (integ) <span class="pl-k">-&gt;</span> <span class="pl-c1">step!</span>(integ, <span class="pl-c1">2</span>π<span class="pl-k">/</span>ω, <span class="pl-c1">true</span>)
reinit_f! <span class="pl-k">=</span>  (integ,y) <span class="pl-k">-&gt;</span>  <span class="pl-c1">reinit!</span>(integ, [y<span class="pl-k">...</span>])
get_u <span class="pl-k">=</span> (integ) <span class="pl-k">-&gt;</span> integ<span class="pl-k">.</span>u[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>]

bsn <span class="pl-k">=</span> <span class="pl-c1">draw_basin</span>(xg, yg, integ, iter_f!, reinit_f!, get_u)</pre></div>
<p>The following anonymous functions are important:</p>
<ul>
<li>iter_f! : defines a function that iterates the system one step on the map.</li>
<li>reinit_f! : sets the initial conditions on the map. Remember that only the
initial conditions on the map must be set.</li>
<li>get_u : it is a custom function to get the state of the integrator only for the variables
defined on the plane</li>
</ul>
<h3><a id="user-content-16-basins-in-higher-dimensions" class="anchor" aria-hidden="true" href="#16-basins-in-higher-dimensions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.6 Basins in Higher Dimensions</h3>
<p>When you cannot define a Stroboscopic map or a well defined Poincaré map you can always try
the general method for higher dimensions. It is slower and may requires some tuning. The algorithm
looks for atractors on a 2D grid. The initial conditions are set on this grid and all others variables
are set to zero by default.</p>
<h3><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ds = Systems.magnetic_pendulum(γ=1, d=0.2, α=0.2, ω=0.8, N=3)
integ = integrator(ds, u0=[0,0,0,0], reltol=1e-9)
xg=range(-4,4,length=150)
yg=range(-4,4,length=150)
@time bsn = basins_general(xg, yg, integ; dt=1., idxs=1:2)
"><pre>ds <span class="pl-k">=</span> Systems<span class="pl-k">.</span><span class="pl-c1">magnetic_pendulum</span>(γ<span class="pl-k">=</span><span class="pl-c1">1</span>, d<span class="pl-k">=</span><span class="pl-c1">0.2</span>, α<span class="pl-k">=</span><span class="pl-c1">0.2</span>, ω<span class="pl-k">=</span><span class="pl-c1">0.8</span>, N<span class="pl-k">=</span><span class="pl-c1">3</span>)
integ <span class="pl-k">=</span> <span class="pl-c1">integrator</span>(ds, u0<span class="pl-k">=</span>[<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>], reltol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>)
xg<span class="pl-k">=</span><span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">4</span>,<span class="pl-c1">4</span>,length<span class="pl-k">=</span><span class="pl-c1">150</span>)
yg<span class="pl-k">=</span><span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">4</span>,<span class="pl-c1">4</span>,length<span class="pl-k">=</span><span class="pl-c1">150</span>)
<span class="pl-c1">@time</span> bsn <span class="pl-k">=</span> <span class="pl-c1">basins_general</span>(xg, yg, integ; dt<span class="pl-k">=</span><span class="pl-c1">1.</span>, idxs<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)</pre></div>
<p>Keyword parameters are:</p>
<ul>
<li><code>dt</code> : this is the time step. It is recomended to use a value above 1. The result may vary a little
depending on this time step.</li>
<li><code>idxs</code> : Indices of the variables defined on the plane.</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/146f20aa878c93eb7a4550887ac465ef7c8a2f3e85712586e32973676efc0128/68747470733a2f2f696d6775722e636f6d2f716742485a384d6c2e706e67"><img src="https://camo.githubusercontent.com/146f20aa878c93eb7a4550887ac465ef7c8a2f3e85712586e32973676efc0128/68747470733a2f2f696d6775722e636f6d2f716742485a384d6c2e706e67" alt="image" data-canonical-src="https://imgur.com/qgBHZ8Ml.png" style="max-width:100%;"></a></p>
<h3><a id="user-content-15---notes-about-the-method" class="anchor" aria-hidden="true" href="#15---notes-about-the-method"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.5 - Notes about the method</h3>
<p>This method identifies the attractors and their basins of attraction on the grid without prior knowledge about the
system. At the end of a successfull computation the function returns a structure BasinInfo with usefull information
on the basin defined by the grid (<code>xg</code>,<code>yg</code>). There is an important member named <code>basin</code> that contains the estimation
of the basins and also of the attractors. For its content see the following section <code>Structure of the basin</code>.</p>
<p>From now on we will refer to the final attractor or an initial condition to its <em>number</em>, <em>odd numbers</em> are assigned
to basins and <em>even numbers</em> are assigned to attractors. The method starts by picking the first available initial
condition not yet numbered. The dynamical system is then iterated until one of the following condition happens:</p>
<ul>
<li>The trajectory hits a known attractor already numbered: the initial condition is collored with corresponding odd number.</li>
<li>The trajectory diverges or hits an attractor outside the defined grid: the initial condition is set to -1</li>
<li>The trajectory hits a known basins 10 times in a row: the initial condition belongs to that basin and is numbered accordingly.</li>
<li>The trajectory hits 60 times in a row an unnumbered cell: it is considered an attractor and is labelled with a even number.</li>
</ul>
<p>Regarding performace, this method is at worst as fast as tracking the attractors. In most cases there is a signicative improvement
in speed.</p>
<h3><a id="user-content-structure-of-the-basin" class="anchor" aria-hidden="true" href="#structure-of-the-basin"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Structure of the basin:</h3>
<p>The basin of attraction is organized in the followin way:</p>
<ul>
<li>The atractors points are <em>even numbers</em> in the matrix. For example, 2 and 4 refer to distinct attractors.</li>
<li>The basins are collored with <em>odd numbers</em>, <code>2n+1</code> corresponding the attractor <code>2n</code>.</li>
<li>If the trajectory diverges or converge to an atractor outside the defined grid it is numbered -1</li>
</ul>
<h2><a id="user-content-2---computataion-of-the-basin-entropy" class="anchor" aria-hidden="true" href="#2---computataion-of-the-basin-entropy"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2 - Computataion of the Basin Entropy</h2>
<p>The <a href="https://doi.org/10.1007/978-3-319-68109-2_2" rel="nofollow">Basin Entropy</a> is a measure of the impredictability of the basin of attraction of a dynamical system. An important feature of the basins of attraction is that for a value above log(2) we can say that the basin is fractalized.</p>
<h3><a id="user-content-usage-1" class="anchor" aria-hidden="true" href="#usage-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h3>
<p>Once the basin of attraction has been computed, the computing the Basin Entropy is easy:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Basins, DynamicalSystems, DifferentialEquations
ω=1.; F = 0.2
ds =Systems.duffing([0.1, 0.25]; ω = ω, f = F, d = 0.15, β = -1)
integ_df  = integrator(ds; alg=Tsit5(),  reltol=1e-8, save_everystep=false)
xg = range(-2.2,2.2,length=200); yg = range(-2.2,2.2,length=200)
bsn = basins_map2D(xg, yg, integ_df; T=2*pi/ω)

Sb,Sbb = basin_entropy(bsn; eps_x=20, eps_y=20)
"><pre><span class="pl-k">using</span> Basins, DynamicalSystems, DifferentialEquations
ω<span class="pl-k">=</span><span class="pl-c1">1.</span>; F <span class="pl-k">=</span> <span class="pl-c1">0.2</span>
ds <span class="pl-k">=</span>Systems<span class="pl-k">.</span><span class="pl-c1">duffing</span>([<span class="pl-c1">0.1</span>, <span class="pl-c1">0.25</span>]; ω <span class="pl-k">=</span> ω, f <span class="pl-k">=</span> F, d <span class="pl-k">=</span> <span class="pl-c1">0.15</span>, β <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>)
integ_df  <span class="pl-k">=</span> <span class="pl-c1">integrator</span>(ds; alg<span class="pl-k">=</span><span class="pl-c1">Tsit5</span>(),  reltol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>)
xg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>); yg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
bsn <span class="pl-k">=</span> <span class="pl-c1">basins_map2D</span>(xg, yg, integ_df; T<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span><span class="pl-k">/</span>ω)

Sb,Sbb <span class="pl-k">=</span> <span class="pl-c1">basin_entropy</span>(bsn; eps_x<span class="pl-k">=</span><span class="pl-c1">20</span>, eps_y<span class="pl-k">=</span><span class="pl-c1">20</span>)</pre></div>
<p>The arguments of <code>basin_entropy</code> are:</p>
<ul>
<li><code>basin</code> : The basin computed on a grid.</li>
<li><code>eps_x</code>, <code>eps_y</code> : size of the window that samples the basin to compute the entropy.</li>
</ul>
<h2><a id="user-content-3---computation-of-the-uncertainty-exponent-of-a-basin-of-attraction" class="anchor" aria-hidden="true" href="#3---computation-of-the-uncertainty-exponent-of-a-basin-of-attraction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3 - Computation of the uncertainty exponent of a basin of attraction</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Uncertainty_exponent" rel="nofollow">uncertainty exponent</a> is conected to the <a href="https://en.wikipedia.org/wiki/Box-counting_dimension" rel="nofollow">box-counting dimension</a>. For a given resolution of the original basin, a sampling of the basin is done until the the fraction of uncertain boxes converges. The process is repeated for different box sizes and then the exponent is estimated.</p>
<h3><a id="user-content-usage-2" class="anchor" aria-hidden="true" href="#usage-2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Basins, DynamicalSystems, DifferentialEquations
ω=1.; F = 0.2
ds =Systems.duffing([0.1, 0.25]; ω = ω, f = F, d = 0.15, β = -1)
integ_df  = integrator(ds; alg=Tsit5(),  reltol=1e-8, save_everystep=false)
xg = range(-2.2,2.2,length=200); yg = range(-2.2,2.2,length=200)
bsn = basins_map2D(xg, yg, integ_df; T=2*pi/ω)

bd = box_counting_dim(xg, yg, bsn)

# uncertainty exponent is the dimension of the plane minus the box-couting dimension
ue = 2-bd
"><pre><span class="pl-k">using</span> Basins, DynamicalSystems, DifferentialEquations
ω<span class="pl-k">=</span><span class="pl-c1">1.</span>; F <span class="pl-k">=</span> <span class="pl-c1">0.2</span>
ds <span class="pl-k">=</span>Systems<span class="pl-k">.</span><span class="pl-c1">duffing</span>([<span class="pl-c1">0.1</span>, <span class="pl-c1">0.25</span>]; ω <span class="pl-k">=</span> ω, f <span class="pl-k">=</span> F, d <span class="pl-k">=</span> <span class="pl-c1">0.15</span>, β <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>)
integ_df  <span class="pl-k">=</span> <span class="pl-c1">integrator</span>(ds; alg<span class="pl-k">=</span><span class="pl-c1">Tsit5</span>(),  reltol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>)
xg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>); yg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
bsn <span class="pl-k">=</span> <span class="pl-c1">basins_map2D</span>(xg, yg, integ_df; T<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span><span class="pl-k">/</span>ω)

bd <span class="pl-k">=</span> <span class="pl-c1">box_counting_dim</span>(xg, yg, bsn)

<span class="pl-c"><span class="pl-c">#</span> uncertainty exponent is the dimension of the plane minus the box-couting dimension</span>
ue <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">-</span>bd</pre></div>
<h2><a id="user-content-4---detection-of-the-property-of-wada" class="anchor" aria-hidden="true" href="#4---detection-of-the-property-of-wada"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4 - Detection of the property of Wada</h2>
<h3><a id="user-content-41---merge-method" class="anchor" aria-hidden="true" href="#41---merge-method"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.1 - Merge Method</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Lakes_of_Wada" rel="nofollow">Wada property</a> in basins of attraction is an amazing feature of some basins. It is not trivial at all to demonstrate rigurously this property. There are however computational approaches that gives hints about the presence of this property in a basin of attraction. One of the fastest approach is the <a href="https://doi.org/10.1038/s41598-018-28119-0" rel="nofollow">Merging Method</a>. The algorithm gives the maximum and minimum Haussdorff distances between merged basins. A good rule of thumb to discard the Wada property is to check if the maximum distance is large in comparison to the resolution of the basin, i.e., if the number of pixel is large.</p>
<p>Notice that the algorithm gives an answer for a particular choice of the grid. It is not an accurate method.</p>
<h3><a id="user-content-usage-3" class="anchor" aria-hidden="true" href="#usage-3"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Basins, DynamicalSystems, DifferentialEquations

# Equations of motion:
function forced_pendulum!(du, u, p, t)
    d = p[1]; F = p[2]; omega = p[3]
    du[1] = u[2]
    du[2] = -d*u[2] - sin(u[1])+ F*cos(omega*t)
end

# We have to define a callback to wrap the phase in [-π,π]
function affect!(integrator)
    if integrator.u[1] &lt; 0
        integrator.u[1] += 2*π
    else
        integrator.u[1] -= 2*π
    end
end

condition(u,t,integrator) = (integrator.u[1] &lt; -π  || integrator.u[1] &gt; π)
cb = DiscreteCallback(condition,affect!)
F = 1.66; ω = 1.; d=0.2
df = ODEProblem(forced_pendulum!,rand(2),(0.0,20.0), [d, F, ω])
integ = init(df, alg=AutoTsit5(Rosenbrock23()); reltol=1e-9, abstol=1e-9, save_everystep=false, callback=cb)
bsn = basins_map2D(range(-pi,pi,length=100), range(-2.,4.,length=100), integ; T=2*pi/ω)

max_dist,min_dist = detect_wada_merge_method(xg, yg, bsn)
# grid resolution
epsilon = xg[2]-xg[1]
# if dmax is large then this is not Wada
@show dmax = max_dist/epsilon
@show dmin = min_dist/epsilon
"><pre><span class="pl-k">using</span> Basins, DynamicalSystems, DifferentialEquations

<span class="pl-c"><span class="pl-c">#</span> Equations of motion:</span>
<span class="pl-k">function</span> <span class="pl-en">forced_pendulum!</span>(du, u, p, t)
    d <span class="pl-k">=</span> p[<span class="pl-c1">1</span>]; F <span class="pl-k">=</span> p[<span class="pl-c1">2</span>]; omega <span class="pl-k">=</span> p[<span class="pl-c1">3</span>]
    du[<span class="pl-c1">1</span>] <span class="pl-k">=</span> u[<span class="pl-c1">2</span>]
    du[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>d<span class="pl-k">*</span>u[<span class="pl-c1">2</span>] <span class="pl-k">-</span> <span class="pl-c1">sin</span>(u[<span class="pl-c1">1</span>])<span class="pl-k">+</span> F<span class="pl-k">*</span><span class="pl-c1">cos</span>(omega<span class="pl-k">*</span>t)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> We have to define a callback to wrap the phase in [-π,π]</span>
<span class="pl-k">function</span> <span class="pl-en">affect!</span>(integrator)
    <span class="pl-k">if</span> integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>
        integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">+=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>π
    <span class="pl-k">else</span>
        integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">-=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>π
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-en">condition</span>(u,t,integrator) <span class="pl-k">=</span> (integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> <span class="pl-k">-</span>π  <span class="pl-k">||</span> integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&gt;</span> π)
cb <span class="pl-k">=</span> <span class="pl-c1">DiscreteCallback</span>(condition,affect!)
F <span class="pl-k">=</span> <span class="pl-c1">1.66</span>; ω <span class="pl-k">=</span> <span class="pl-c1">1.</span>; d<span class="pl-k">=</span><span class="pl-c1">0.2</span>
df <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(forced_pendulum!,<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>),(<span class="pl-c1">0.0</span>,<span class="pl-c1">20.0</span>), [d, F, ω])
integ <span class="pl-k">=</span> <span class="pl-c1">init</span>(df, alg<span class="pl-k">=</span><span class="pl-c1">AutoTsit5</span>(<span class="pl-c1">Rosenbrock23</span>()); reltol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>, abstol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>, callback<span class="pl-k">=</span>cb)
bsn <span class="pl-k">=</span> <span class="pl-c1">basins_map2D</span>(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">pi</span>,<span class="pl-c1">pi</span>,length<span class="pl-k">=</span><span class="pl-c1">100</span>), <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.</span>,<span class="pl-c1">4.</span>,length<span class="pl-k">=</span><span class="pl-c1">100</span>), integ; T<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span><span class="pl-k">/</span>ω)

max_dist,min_dist <span class="pl-k">=</span> <span class="pl-c1">detect_wada_merge_method</span>(xg, yg, bsn)
<span class="pl-c"><span class="pl-c">#</span> grid resolution</span>
epsilon <span class="pl-k">=</span> xg[<span class="pl-c1">2</span>]<span class="pl-k">-</span>xg[<span class="pl-c1">1</span>]
<span class="pl-c"><span class="pl-c">#</span> if dmax is large then this is not Wada</span>
<span class="pl-c1">@show</span> dmax <span class="pl-k">=</span> max_dist<span class="pl-k">/</span>epsilon
<span class="pl-c1">@show</span> dmin <span class="pl-k">=</span> min_dist<span class="pl-k">/</span>epsilon</pre></div>
<h3><a id="user-content-42---grid-method" class="anchor" aria-hidden="true" href="#42---grid-method"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.2 - Grid Method</h3>
<p>Another method available and much more accurate is the <a href="https://doi.org/10.1038/srep16579" rel="nofollow">Grid Method</a>. It divides the grid and scrutinize the boundary to test if all the attractors are present in every point of the boundary. It may be very long to get an answer since the number of points to test duplicates at each step. The algorithm returns a vector with the proportion of boxes with 1 to N attractor. For example if the vector W[N] is above 0.95 we have all the initial boxes in the boundary on the grid with N attractors. It is therefore a strong evidence that we have a Wada boundary.</p>
<h3><a id="user-content-usage-4" class="anchor" aria-hidden="true" href="#usage-4"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Basins, DynamicalSystems, DifferentialEquations

# Equations of motion:
function forced_pendulum!(du, u, p, t)
    d = p[1]; F = p[2]; omega = p[3]
    du[1] = u[2]
    du[2] = -d*u[2] - sin(u[1])+ F*cos(omega*t)
end

# We have to define a callback to wrap the phase in [-π,π]
function affect!(integrator)
    if integrator.u[1] &lt; 0
        integrator.u[1] += 2*π
    else
        integrator.u[1] -= 2*π
    end
end

condition(u,t,integrator) = (integrator.u[1] &lt; -π  || integrator.u[1] &gt; π)
cb = DiscreteCallback(condition,affect!)
F = 1.66; ω = 1.; d=0.2
df = ODEProblem(forced_pendulum!,rand(2),(0.0,20.0), [d, F, ω])
integ = init(df, alg=AutoTsit5(Rosenbrock23()); reltol=1e-9, abstol=1e-9, save_everystep=false, callback=cb)
bsn = basins_map2D(range(-pi,pi,length=100), range(-2.,4.,length=100), integ; T=2*pi/ω)

@show W = detect_wada_grid_method(integ, bsn; max_iter=10)
"><pre><span class="pl-k">using</span> Basins, DynamicalSystems, DifferentialEquations

<span class="pl-c"><span class="pl-c">#</span> Equations of motion:</span>
<span class="pl-k">function</span> <span class="pl-en">forced_pendulum!</span>(du, u, p, t)
    d <span class="pl-k">=</span> p[<span class="pl-c1">1</span>]; F <span class="pl-k">=</span> p[<span class="pl-c1">2</span>]; omega <span class="pl-k">=</span> p[<span class="pl-c1">3</span>]
    du[<span class="pl-c1">1</span>] <span class="pl-k">=</span> u[<span class="pl-c1">2</span>]
    du[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>d<span class="pl-k">*</span>u[<span class="pl-c1">2</span>] <span class="pl-k">-</span> <span class="pl-c1">sin</span>(u[<span class="pl-c1">1</span>])<span class="pl-k">+</span> F<span class="pl-k">*</span><span class="pl-c1">cos</span>(omega<span class="pl-k">*</span>t)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> We have to define a callback to wrap the phase in [-π,π]</span>
<span class="pl-k">function</span> <span class="pl-en">affect!</span>(integrator)
    <span class="pl-k">if</span> integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>
        integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">+=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>π
    <span class="pl-k">else</span>
        integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">-=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>π
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-en">condition</span>(u,t,integrator) <span class="pl-k">=</span> (integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> <span class="pl-k">-</span>π  <span class="pl-k">||</span> integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&gt;</span> π)
cb <span class="pl-k">=</span> <span class="pl-c1">DiscreteCallback</span>(condition,affect!)
F <span class="pl-k">=</span> <span class="pl-c1">1.66</span>; ω <span class="pl-k">=</span> <span class="pl-c1">1.</span>; d<span class="pl-k">=</span><span class="pl-c1">0.2</span>
df <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(forced_pendulum!,<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>),(<span class="pl-c1">0.0</span>,<span class="pl-c1">20.0</span>), [d, F, ω])
integ <span class="pl-k">=</span> <span class="pl-c1">init</span>(df, alg<span class="pl-k">=</span><span class="pl-c1">AutoTsit5</span>(<span class="pl-c1">Rosenbrock23</span>()); reltol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>, abstol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>, callback<span class="pl-k">=</span>cb)
bsn <span class="pl-k">=</span> <span class="pl-c1">basins_map2D</span>(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">pi</span>,<span class="pl-c1">pi</span>,length<span class="pl-k">=</span><span class="pl-c1">100</span>), <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.</span>,<span class="pl-c1">4.</span>,length<span class="pl-k">=</span><span class="pl-c1">100</span>), integ; T<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span><span class="pl-k">/</span>ω)

<span class="pl-c1">@show</span> W <span class="pl-k">=</span> <span class="pl-c1">detect_wada_grid_method</span>(integ, bsn; max_iter<span class="pl-k">=</span><span class="pl-c1">10</span>)</pre></div>
<p>The algorithm returns:</p>
<ul>
<li><code>W</code> contains a vector with the proportion of boxes in the boundary of <code>k</code> attractor. A good criterion to decide if the boundary is Wada is to look at <code>W[N]</code> with N the number of attractors. If this number is above 0.95 we can conclude that the boundary is Wada.</li>
</ul>
<h2><a id="user-content-5---computation-of-the-saddle-embedded-in-the-boundary-experimental-feature" class="anchor" aria-hidden="true" href="#5---computation-of-the-saddle-embedded-in-the-boundary-experimental-feature"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5 - Computation of the saddle embedded in the boundary [EXPERIMENTAL FEATURE]</h2>
<p>There is an invariant subset of the boundary which is invariant under the forward iteration of the dynamical system. This set is called the chaotic set, chaotic saddle or simply saddle set. It is possible to compute an approximation arbitrarily close to the saddle with the saddle straddle method. For a detailed description of the method see [1]. This method requires two <code>generalized basins</code> such that the algorithm focus on the boundary between these two sets. We divide the basins in two class such that  <code>bas_A ∪ bas_B = [1:N]</code> and <code>bas_A ∩ bas_B = ∅</code> with <code>N</code> the number of attractors.</p>
<h3><a id="user-content-usage-5" class="anchor" aria-hidden="true" href="#usage-5"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Basins, DynamicalSystems, DifferentialEquations

# Equations of motion:
function forced_pendulum!(du, u, p, t)
    d = p[1]; F = p[2]; omega = p[3]
    du[1] = u[2]
    du[2] = -d*u[2] - sin(u[1])+ F*cos(omega*t)
end

# We have to define a callback to wrap the phase in [-π,π]
function affect!(integrator)
    if integrator.u[1] &lt; 0
        integrator.u[1] += 2*π
    else
        integrator.u[1] -= 2*π
    end
end

condition(u,t,integrator) = (integrator.u[1] &lt; -π  || integrator.u[1] &gt; π)
cb = DiscreteCallback(condition,affect!)
F = 1.66; ω = 1.; d=0.2
df = ODEProblem(forced_pendulum!,rand(2),(0.0,20.0), [d, F, ω])
integ = init(df, alg=AutoTsit5(Rosenbrock23()); reltol=1e-9, abstol=1e-9, save_everystep=false, callback=cb)
bsn = basins_map2D(range(-pi,pi,length=200), range(-2.,4.,length=200), integ; T=2*pi/ω)

# sa is the left set and sb is the right set.
sa,sb = compute_saddle(integ, bsn, [1], [2,3], 1000)
s = Dataset(sa) # convert to a dataset for ploting
plot(xg,yg,bsn.basin', seriestype=:heatmap)
plot!(s[:,1],s[:,2],seriestype=:scatter, markercolor=:blue)
"><pre><span class="pl-k">using</span> Basins, DynamicalSystems, DifferentialEquations

<span class="pl-c"><span class="pl-c">#</span> Equations of motion:</span>
<span class="pl-k">function</span> <span class="pl-en">forced_pendulum!</span>(du, u, p, t)
    d <span class="pl-k">=</span> p[<span class="pl-c1">1</span>]; F <span class="pl-k">=</span> p[<span class="pl-c1">2</span>]; omega <span class="pl-k">=</span> p[<span class="pl-c1">3</span>]
    du[<span class="pl-c1">1</span>] <span class="pl-k">=</span> u[<span class="pl-c1">2</span>]
    du[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span>d<span class="pl-k">*</span>u[<span class="pl-c1">2</span>] <span class="pl-k">-</span> <span class="pl-c1">sin</span>(u[<span class="pl-c1">1</span>])<span class="pl-k">+</span> F<span class="pl-k">*</span><span class="pl-c1">cos</span>(omega<span class="pl-k">*</span>t)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> We have to define a callback to wrap the phase in [-π,π]</span>
<span class="pl-k">function</span> <span class="pl-en">affect!</span>(integrator)
    <span class="pl-k">if</span> integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>
        integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">+=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>π
    <span class="pl-k">else</span>
        integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">-=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>π
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-en">condition</span>(u,t,integrator) <span class="pl-k">=</span> (integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> <span class="pl-k">-</span>π  <span class="pl-k">||</span> integrator<span class="pl-k">.</span>u[<span class="pl-c1">1</span>] <span class="pl-k">&gt;</span> π)
cb <span class="pl-k">=</span> <span class="pl-c1">DiscreteCallback</span>(condition,affect!)
F <span class="pl-k">=</span> <span class="pl-c1">1.66</span>; ω <span class="pl-k">=</span> <span class="pl-c1">1.</span>; d<span class="pl-k">=</span><span class="pl-c1">0.2</span>
df <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(forced_pendulum!,<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>),(<span class="pl-c1">0.0</span>,<span class="pl-c1">20.0</span>), [d, F, ω])
integ <span class="pl-k">=</span> <span class="pl-c1">init</span>(df, alg<span class="pl-k">=</span><span class="pl-c1">AutoTsit5</span>(<span class="pl-c1">Rosenbrock23</span>()); reltol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>, abstol<span class="pl-k">=</span><span class="pl-c1">1e-9</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>, callback<span class="pl-k">=</span>cb)
bsn <span class="pl-k">=</span> <span class="pl-c1">basins_map2D</span>(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">pi</span>,<span class="pl-c1">pi</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>), <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.</span>,<span class="pl-c1">4.</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>), integ; T<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span><span class="pl-k">/</span>ω)

<span class="pl-c"><span class="pl-c">#</span> sa is the left set and sb is the right set.</span>
sa,sb <span class="pl-k">=</span> <span class="pl-c1">compute_saddle</span>(integ, bsn, [<span class="pl-c1">1</span>], [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>], <span class="pl-c1">1000</span>)
s <span class="pl-k">=</span> <span class="pl-c1">Dataset</span>(sa) <span class="pl-c"><span class="pl-c">#</span> convert to a dataset for ploting</span>
<span class="pl-c1">plot</span>(xg,yg,bsn<span class="pl-k">.</span>basin<span class="pl-k">'</span>, seriestype<span class="pl-k">=</span><span class="pl-c1">:heatmap</span>)
<span class="pl-c1">plot!</span>(s[:,<span class="pl-c1">1</span>],s[:,<span class="pl-c1">2</span>],seriestype<span class="pl-k">=</span><span class="pl-c1">:scatter</span>, markercolor<span class="pl-k">=</span><span class="pl-c1">:blue</span>)</pre></div>
<p>The arguments of <code>compute_saddle</code> are:</p>
<ul>
<li><code>integ</code> : the matrix containing the information of the basin.</li>
<li><code>bsn_nfo</code> : structure that holds the information of the basin as well as the map function. This structure is set when the basin is first computed with <code>basins_map2D</code> or <code>basin_poincare_map</code>.</li>
<li><code>bas_A</code> : vector with the indices of the attractors that will represent the generalized basin A</li>
<li><code>bas_B</code> : vector with the indices of the attractors that will represent the generalized basin B. Notice that <code>bas_A ∪ bas_B = [1:N]</code> and <code>bas_A ∩ bas_B = ∅</code></li>
</ul>
<p>Keyword arguments are:</p>
<ul>
<li><code>N</code> : number of points of the saddle to compute</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/92eceab849327c2d91e4b3e91bb9484a9edbf3da8ab05cde34cb43005203c129/68747470733a2f2f692e696d6775722e636f6d2f70514c444f304f6c2e706e67"><img src="https://camo.githubusercontent.com/92eceab849327c2d91e4b3e91bb9484a9edbf3da8ab05cde34cb43005203c129/68747470733a2f2f692e696d6775722e636f6d2f70514c444f304f6c2e706e67" alt="image" data-canonical-src="https://i.imgur.com/pQLDO0Ol.png" style="max-width:100%;"></a></p>
<h2><a id="user-content-6---computation-of-the-basin-stability" class="anchor" aria-hidden="true" href="#6---computation-of-the-basin-stability"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>6 - Computation of the Basin Stability</h2>
<p>The Basin Stability [6] measures the relative sizes of the basin. Larger basin are considered more stable since a small perturbation or error in the initial conditions is less likely to change the attractor.</p>
<h3><a id="user-content-usage-6" class="anchor" aria-hidden="true" href="#usage-6"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Basins, DynamicalSystems, DifferentialEquations
ω=1.; F = 0.2
ds =Systems.duffing([0.1, 0.25]; ω = ω, f = F, d = 0.15, β = -1)
integ_df  = integrator(ds; alg=Tsit5(),  reltol=1e-8, save_everystep=false)
xg = range(-2.2,2.2,length=200); yg = range(-2.2,2.2,length=200)
bsn = basins_map2D(xg, yg, integ_df; T=2*pi/ω)

@show basin_stability(bsn)
"><pre><span class="pl-k">using</span> Basins, DynamicalSystems, DifferentialEquations
ω<span class="pl-k">=</span><span class="pl-c1">1.</span>; F <span class="pl-k">=</span> <span class="pl-c1">0.2</span>
ds <span class="pl-k">=</span>Systems<span class="pl-k">.</span><span class="pl-c1">duffing</span>([<span class="pl-c1">0.1</span>, <span class="pl-c1">0.25</span>]; ω <span class="pl-k">=</span> ω, f <span class="pl-k">=</span> F, d <span class="pl-k">=</span> <span class="pl-c1">0.15</span>, β <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>)
integ_df  <span class="pl-k">=</span> <span class="pl-c1">integrator</span>(ds; alg<span class="pl-k">=</span><span class="pl-c1">Tsit5</span>(),  reltol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>, save_everystep<span class="pl-k">=</span><span class="pl-c1">false</span>)
xg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>); yg <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2.2</span>,<span class="pl-c1">2.2</span>,length<span class="pl-k">=</span><span class="pl-c1">200</span>)
bsn <span class="pl-k">=</span> <span class="pl-c1">basins_map2D</span>(xg, yg, integ_df; T<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span><span class="pl-k">/</span>ω)

<span class="pl-c1">@show</span> <span class="pl-c1">basin_stability</span>(bsn)</pre></div>
<h2><a id="user-content-7---more-examples" class="anchor" aria-hidden="true" href="#7---more-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>7 - More examples</h2>
<p>You can find more examples in <code>src/examples</code></p>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>References</h2>
<p>[1] H. E. Nusse and J. A. Yorke, Dynamics: numerical explorations, Springer, New York, 2012</p>
<p>[2] A. Daza, A. Wagemakers, B. Georgeot, D. Guéry-Odelin and M. A. F. Sanjuán, Basin entropy: a new tool to analyze uncertainty in dynamical systems, Sci. Rep., 6, 31416 (2016).</p>
<p>[3] C. Grebogi, S. W. McDonald, E. Ott, J. A. Yorke, Final state sensitivity: An obstruction to predictability, Physics Letters A, 99, 9, 1983</p>
<p>[4] A. Daza, A. Wagemakers and M. A. F. Sanjuán, Ascertaining when a basin is Wada: the merging method, Sci. Rep., 8, 9954 (2018).</p>
<p>[5] A. Daza, A. Wagemakers, M. A. F. Sanjuán and J. A. Yorke, Testing for Basins of Wada, Sci. Rep., 5, 16579 (2015).</p>
<p>[6] P. Menck, J. Heitzig, N. Marwan et al. How basin stability complements the linear-stability paradigm. Nature Phys 9, 89–92 (2013).</p>
</article></div>