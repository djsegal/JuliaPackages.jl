<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-gumbelsoftmax" class="anchor" aria-hidden="true" href="#gumbelsoftmax"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GumbelSoftmax</h1>
<p dir="auto"><a href="https://github.com/arnauqb/GumbelSoftmax.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/arnauqb/GumbelSoftmax.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/arnauqb/GumbelSoftmax.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/57dac22ad574f4a238f9c835929e68133ba7c41c646fde93e4c84c7f317cfde1/68747470733a2f2f636f6465636f762e696f2f67682f61726e617571622f47756d62656c536f66746d61782e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/arnauqb/GumbelSoftmax.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package implements the <a href="https://arxiv.org/abs/1611.01144" rel="nofollow">Gumbel-Softmax reparametrization trick</a> in Julia using <a href="https://github.com/FluxML/Zygote.jl">Zygote</a>.</p>
<h1 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h1>
<p dir="auto">Let's suppose we want to sample from 4 Categorical variables each with 3 possible outcomes. We can input the probabilities like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; p = [[0.1, 0.2, 0.3, 0.4] [0.5, 0.6, 0.1, 0.3] [0.4, 0.2, 0.6, 0.3]]
4×3 Matrix{Float64}:
 0.1  0.5  0.4
 0.2  0.6  0.2
 0.3  0.1  0.6
 0.4  0.3  0.3"><pre>julia<span class="pl-k">&gt;</span> p <span class="pl-k">=</span> [[<span class="pl-c1">0.1</span>, <span class="pl-c1">0.2</span>, <span class="pl-c1">0.3</span>, <span class="pl-c1">0.4</span>] [<span class="pl-c1">0.5</span>, <span class="pl-c1">0.6</span>, <span class="pl-c1">0.1</span>, <span class="pl-c1">0.3</span>] [<span class="pl-c1">0.4</span>, <span class="pl-c1">0.2</span>, <span class="pl-c1">0.6</span>, <span class="pl-c1">0.3</span>]]
<span class="pl-c1">4</span><span class="pl-k">×</span><span class="pl-c1">3</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.1</span>  <span class="pl-c1">0.5</span>  <span class="pl-c1">0.4</span>
 <span class="pl-c1">0.2</span>  <span class="pl-c1">0.6</span>  <span class="pl-c1">0.2</span>
 <span class="pl-c1">0.3</span>  <span class="pl-c1">0.1</span>  <span class="pl-c1">0.6</span>
 <span class="pl-c1">0.4</span>  <span class="pl-c1">0.3</span>  <span class="pl-c1">0.3</span></pre></div>
<p dir="auto">In this case the note that the rows add to 1, but it is not necessary to have the matrix normalized. We can then sample in a differentiable way like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using GumbelSoftmax
julia&gt; result = sample_gumbel_softmax(p, 0.1; hard=true)
4×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  0.0  1.0
 1.0  0.0  0.0
 0.0  1.0  0.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> GumbelSoftmax
julia<span class="pl-k">&gt;</span> result <span class="pl-k">=</span> <span class="pl-c1">sample_gumbel_softmax</span>(p, <span class="pl-c1">0.1</span>; hard<span class="pl-k">=</span><span class="pl-c1">true</span>)
<span class="pl-c1">4</span><span class="pl-k">×</span><span class="pl-c1">3</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">1.0</span>
 <span class="pl-c1">1.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">1.0</span>  <span class="pl-c1">0.0</span></pre></div>
<p dir="auto">where 0.1 corresponds to the temperature parameter, and <code>hard=true</code> specified whether we want hard samples (ie 0 or 1). We can then calculate the gradient using the standard Zygote interface. Note that we can only calculate gradients, so we will suppose we are interested in the sum of results in the second column:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Zygote
function to_derive(p)
    result = sample_gumbel_softmax(p, 0.1; hard=true)
    return sum(result[:,2])
end

grad_value = gradient(to_derive, p)
([-1.8664458645494402e-16 1.6225865540064885e-7 -2.0282331979907546e-7; -2.152607762114983e-16 8.83806125520096e-11 -2.651416223952525e-10; -9.333173809814049e-18 5.633448015616505e-9 -9.38907997936165e-10; -1.1976417933816025e-8 0.009956664887966756 -0.009956648919416302],)"><pre><span class="pl-k">using</span> Zygote
<span class="pl-k">function</span> <span class="pl-en">to_derive</span>(p)
    result <span class="pl-k">=</span> <span class="pl-c1">sample_gumbel_softmax</span>(p, <span class="pl-c1">0.1</span>; hard<span class="pl-k">=</span><span class="pl-c1">true</span>)
    <span class="pl-k">return</span> <span class="pl-c1">sum</span>(result[:,<span class="pl-c1">2</span>])
<span class="pl-k">end</span>

grad_value <span class="pl-k">=</span> <span class="pl-c1">gradient</span>(to_derive, p)
([<span class="pl-k">-</span><span class="pl-c1">1.8664458645494402e-16</span> <span class="pl-c1">1.6225865540064885e-7</span> <span class="pl-k">-</span><span class="pl-c1">2.0282331979907546e-7</span>; <span class="pl-k">-</span><span class="pl-c1">2.152607762114983e-16</span> <span class="pl-c1">8.83806125520096e-11</span> <span class="pl-k">-</span><span class="pl-c1">2.651416223952525e-10</span>; <span class="pl-k">-</span><span class="pl-c1">9.333173809814049e-18</span> <span class="pl-c1">5.633448015616505e-9</span> <span class="pl-k">-</span><span class="pl-c1">9.38907997936165e-10</span>; <span class="pl-k">-</span><span class="pl-c1">1.1976417933816025e-8</span> <span class="pl-c1">0.009956664887966756</span> <span class="pl-k">-</span><span class="pl-c1">0.009956648919416302</span>],)</pre></div>
</article></div>