<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-ondaedfjl" class="anchor" aria-hidden="true" href="#ondaedfjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>OndaEDF.jl</h1>
<p dir="auto"><a href="https://github.com/beacon-biosignals/OndaEDF.jl/actions/workflows/CI.yml"><img src="https://github.com/beacon-biosignals/OndaEDF.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/beacon-biosignals/OndaEDF.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/441d1d648184b7f02279e8220827fd1d0d9b7f6d70fee450353f99ef7a3420d4/68747470733a2f2f636f6465636f762e696f2f67682f626561636f6e2d62696f7369676e616c732f4f6e64614544462e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d376f5a68783750396b71" alt="codecov" data-canonical-src="https://codecov.io/gh/beacon-biosignals/OndaEDF.jl/branch/master/graph/badge.svg?token=7oZhx7P9kq" style="max-width: 100%;"></a>
<a href="https://beacon-biosignals.github.io/OndaEDF.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">OndaEDF provides functionality to convert/import/export EDF files to/from Onda recordings; see the <code>edf_to_onda_samples</code>, <code>edf_to_onda_annotations</code>, and <code>onda_to_edf</code> docs/tests for details.</p>
<h2 dir="auto"><a id="user-content-edf-formatting-expectations" class="anchor" aria-hidden="true" href="#edf-formatting-expectations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>EDF Formatting Expectations</h2>
<p dir="auto">While OndaEDF attempts to be somewhat robust to more common nonstandard/noncompliant quirks that often appear in EDF files "in the wild", the package generally expects the caller to perform any necessary preprocessing to their EDFs to ensure they comply with the EDF/EDF+ standards/specifications, as well as a few other expectations to facilitate conversion to Onda.</p>
<p dir="auto">These expectations are as follows:</p>
<ul dir="auto">
<li><code>EDF.Signal</code> labels follow the standard "$TYPE $SPECIFICATION" structure defined by <a href="https://www.edfplus.info/specs/edftexts.html" rel="nofollow">the EDF standards</a>, and signal types documented by the aforementioned standard (EEG, EKG, etc.) are labeled in compliance with naming conventions defined by the standard.</li>
<li><code>EDF.Signal</code>s that are matched as channels to a common <code>Onda.Signal</code> must have the same <code>physical_dimension</code>, sample rate, and sample count.</li>
<li>The <code>physical_dimension</code> field for any given <code>EDF.Signal</code> is a value supported by <code>OndaEDF.STANDARD_UNITS</code>.</li>
</ul>
<p dir="auto">Note that callers can additionally use the <code>labels</code> argument to <code>edf_to_onda_signals</code> to workaround some of these expectations; see the <code>plan_edf_to_onda_samples</code> docstring for more details.</p>
<h2 dir="auto"><a id="user-content-fine-grained-control-over-signal-processing-plan_edf_to_onda_samples-and-edf_to_onda_samplesedf-plan" class="anchor" aria-hidden="true" href="#fine-grained-control-over-signal-processing-plan_edf_to_onda_samples-and-edf_to_onda_samplesedf-plan"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Fine-grained control over <code>Signal</code> processing: <code>plan_edf_to_onda_samples</code> and <code>edf_to_onda_samples(edf, plan)</code></h2>
<p dir="auto">Because the default labels do not always match EDF files as seen in the wild, OndaEDF provides additional tools for creating, inspecting, manipulating, and recording the <code>EDF.Signal</code>-to-<code>Onda.Samples</code> mapping.
In fact, the high-level function <code>edf_to_onda_samples</code> contains very few lines of code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function edf_to_onda_samples(edf::EDF.File; kwargs...)
    signals_plan = plan_edf_to_onda_samples(edf; kwargs...)
    EDF.read!(edf)
    samples, exec_plan = edf_to_onda_samples(edf, signals_plan)
    return samples, exec_plan
end"><pre><span class="pl-k">function</span> <span class="pl-en">edf_to_onda_samples</span>(edf<span class="pl-k">::</span><span class="pl-c1">EDF.File</span>; kwargs<span class="pl-k">...</span>)
    signals_plan <span class="pl-k">=</span> <span class="pl-c1">plan_edf_to_onda_samples</span>(edf; kwargs<span class="pl-k">...</span>)
    EDF<span class="pl-k">.</span><span class="pl-c1">read!</span>(edf)
    samples, exec_plan <span class="pl-k">=</span> <span class="pl-c1">edf_to_onda_samples</span>(edf, signals_plan)
    <span class="pl-k">return</span> samples, exec_plan
<span class="pl-k">end</span></pre></div>
<p dir="auto">The executed plan as returned is a <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>-compatible table, with one row per <code>EDF.Signal</code> and columns for</p>
<ul dir="auto">
<li>the fields of the original <code>EDF.SignalHeader</code></li>
<li>the fields of the generated <code>Onda.SamplesInfoV2</code>, including
<ul dir="auto">
<li><code>:sensor_type</code>, the extracted sensor type</li>
<li><code>:channel</code>, the extracted channel label (instead of <code>:channels</code>, since each <code>EDF.Signal</code> is exactly one channel in <code>Onda.Samples</code>)</li>
</ul>
</li>
<li><code>:edf_signal_index</code>, the 1-based numerical index of the source signal in <code>edf.signals</code></li>
<li><code>:onda_signal_index</code>, the ordinal index of the resulting samples (not necessarily the index into <code>samples</code>, since some groups might be skipped)</li>
<li><code>:error</code>, any errors that were caught during planning and/or execution.</li>
</ul>
<p dir="auto">This table could, for instance, be recorded somewhere during ingest of large or complex datasets, as a record of how the <code>Onda.Samples</code> were generated.
OndaEDF includes the OndaEDFSchemas sub-package, which provides <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas-Schemas-and-Rows-1" rel="nofollow">Legolas.jl Schemas</a> for this purpose: <code>Plan</code> (<code>"ondaedf.plan@1"</code>) which corresponds to the columns for a single EDF signal-to-Onda channel conversion, and <code>FilePlan</code> (<code>"ondaedf.file-plan@1"</code>) which includes the additional file-level linkage columns <code>:edf_signal_index</code> and <code>:onda_signal_index</code>.
The <code>write_plan(io_or_path, plan_table)</code> provides a wrapper around <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas.write" rel="nofollow"><code>Legolas.write</code></a> which writes a table following the <code>"ondaedf.file-plan@1"</code> schema to a generic path-like destination.
If you are including the plan tables in a dataset, you can add a dependency on OndaEDFSchemas to make sure the relevant schemas are defined without the full OndaEDF dependency.</p>
<p dir="auto">It can also be manipulated programmatically, by manually or semi-automatically modifying the <code>:sensor_type</code>, <code>:channel</code>, or other columns to correct for missed signals by the default labels (for which <code>:sensor_type</code> and <code>:channel</code> will be <code>missing</code>).
We give two examples of how such a workflow might work here: one where the plan is modified before being executed, and another where EDF signal headers are be <em>preprocessed</em> before the plan is constructed.</p>
<h3 dir="auto"><a id="user-content-modification-of-a-plan" class="anchor" aria-hidden="true" href="#modification-of-a-plan"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Modification of a plan</h3>
<p dir="auto">For instance, some EEG datasets have the physical units set to millivolts, but the signals are usually better measured in microvolts.
During import, you want to correct this by adjusting the encoding settings used by Onda to store samples, by scaling the sample offset and resolution by 1000 and setting the physical units.
This can be accomplished by modifying the rows of the plan like so:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="edf = EDF.File(my_edf_file_path)
plans = plan_edf_to_onda_samples(edf; label=my_labels)

function fix_millivolts(plan)
    if plan.sample_unit == &quot;millivolt&quot; &amp;&amp; plan.sensor_type == &quot;eeg&quot;
        sample_resolution_in_unit = plan.sample_resolution_in_unit * 1000
        sample_offset_in_unit = plan.sample_offset_in_unit * 1000
        return Tables.rowmerge(plan; sample_unit=&quot;microvolt&quot;,
                               sample_resolution_in_unit,
                               sample_offset_in_unit)
    else
        return plan
    end
end

new_plan = map(fix_millivolts, Tables.rows(plans))
samples, plan_executed = edf_to_onda_samples(edf, new_plan)"><pre>edf <span class="pl-k">=</span> EDF<span class="pl-k">.</span><span class="pl-c1">File</span>(my_edf_file_path)
plans <span class="pl-k">=</span> <span class="pl-c1">plan_edf_to_onda_samples</span>(edf; label<span class="pl-k">=</span>my_labels)

<span class="pl-k">function</span> <span class="pl-en">fix_millivolts</span>(plan)
    <span class="pl-k">if</span> plan<span class="pl-k">.</span>sample_unit <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>millivolt<span class="pl-pds">"</span></span> <span class="pl-k">&amp;&amp;</span> plan<span class="pl-k">.</span>sensor_type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>eeg<span class="pl-pds">"</span></span>
        sample_resolution_in_unit <span class="pl-k">=</span> plan<span class="pl-k">.</span>sample_resolution_in_unit <span class="pl-k">*</span> <span class="pl-c1">1000</span>
        sample_offset_in_unit <span class="pl-k">=</span> plan<span class="pl-k">.</span>sample_offset_in_unit <span class="pl-k">*</span> <span class="pl-c1">1000</span>
        <span class="pl-k">return</span> Tables<span class="pl-k">.</span><span class="pl-c1">rowmerge</span>(plan; sample_unit<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>microvolt<span class="pl-pds">"</span></span>,
                               sample_resolution_in_unit,
                               sample_offset_in_unit)
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> plan
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

new_plan <span class="pl-k">=</span> <span class="pl-c1">map</span>(fix_millivolts, Tables<span class="pl-k">.</span><span class="pl-c1">rows</span>(plans))
samples, plan_executed <span class="pl-k">=</span> <span class="pl-c1">edf_to_onda_samples</span>(edf, new_plan)</pre></div>
<p dir="auto">As another, similar example, sometimes EMG channels get recorded with different physical units.
In such a case, OndaEDF cannot merge these channels and will create multiple separate <code>Samples</code> objects which each have <code>sensor_type = "emg"</code>.
This can be corrected in a similar way, for exmaple by converting millivolts to microvolts (adjusting of course depending on the nature of your dataset) and re-grouping into Onda samples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="edf = EDF.File(my_edf_file_path)
plans = plan_edf_to_onda_samples(edf; label=my_labels)

function fix_emg(plan)
    if plan.sensor_type == &quot;emg&quot;
        if plan.sample_unit == &quot;millivolt&quot;
            sample_resolution_in_unit = plan.sample_resolution_in_unit * 1000
            sample_offset_in_unit = plan.sample_offset_in_unit * 1000
            plan = Tables.rowmerge(plan; sample_unit=&quot;microvolt&quot;,
                                   sample_resolution_in_unit,
                                   sample_offset_in_unit)
        end
        return plan
    else
        return plan
    end
end

new_plan = map(fix_emg, Tables.rows(plans))
# re-compute the grouping of EDF signals into Onda signals:
new_plan = plan_edf_to_onda_samples_groups(new_plan)
samples, plan_executed = edf_to_onda_samples(edf, new_plan)"><pre>edf <span class="pl-k">=</span> EDF<span class="pl-k">.</span><span class="pl-c1">File</span>(my_edf_file_path)
plans <span class="pl-k">=</span> <span class="pl-c1">plan_edf_to_onda_samples</span>(edf; label<span class="pl-k">=</span>my_labels)

<span class="pl-k">function</span> <span class="pl-en">fix_emg</span>(plan)
    <span class="pl-k">if</span> plan<span class="pl-k">.</span>sensor_type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>emg<span class="pl-pds">"</span></span>
        <span class="pl-k">if</span> plan<span class="pl-k">.</span>sample_unit <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>millivolt<span class="pl-pds">"</span></span>
            sample_resolution_in_unit <span class="pl-k">=</span> plan<span class="pl-k">.</span>sample_resolution_in_unit <span class="pl-k">*</span> <span class="pl-c1">1000</span>
            sample_offset_in_unit <span class="pl-k">=</span> plan<span class="pl-k">.</span>sample_offset_in_unit <span class="pl-k">*</span> <span class="pl-c1">1000</span>
            plan <span class="pl-k">=</span> Tables<span class="pl-k">.</span><span class="pl-c1">rowmerge</span>(plan; sample_unit<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>microvolt<span class="pl-pds">"</span></span>,
                                   sample_resolution_in_unit,
                                   sample_offset_in_unit)
        <span class="pl-k">end</span>
        <span class="pl-k">return</span> plan
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> plan
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

new_plan <span class="pl-k">=</span> <span class="pl-c1">map</span>(fix_emg, Tables<span class="pl-k">.</span><span class="pl-c1">rows</span>(plans))
<span class="pl-c"><span class="pl-c">#</span> re-compute the grouping of EDF signals into Onda signals:</span>
new_plan <span class="pl-k">=</span> <span class="pl-c1">plan_edf_to_onda_samples_groups</span>(new_plan)
samples, plan_executed <span class="pl-k">=</span> <span class="pl-c1">edf_to_onda_samples</span>(edf, new_plan)</pre></div>
<h3 dir="auto"><a id="user-content-pre-processing-signal-headers" class="anchor" aria-hidden="true" href="#pre-processing-signal-headers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Pre-processing signal headers</h3>
<p dir="auto">Sometimes non-standard usage of the label and transducer type fields makes automatic matching difficult.
In such cases, you can <em>preprocess</em> the signal headers before generating a plan.
For example, in a situation where the transducer type and labels are switched, you can switch them back before planning:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="edf = EDF.File(my_edf_file_path)

function corrected_header(signal::EDF.Signal)
    header = signal.header
    return Tables.rowmerge(header; 
                           label=header.transducer_type, 
                           transducer_type=header.label)
end

plans = map(plan_edf_to_onda_samples ∘ corrected_header, edf.signals)
grouped_plans = plan_edf_to_onda_samples_groups(plans)
samples, plan_executed = edf_to_onda_samples(edf, grouped_plans)"><pre>edf <span class="pl-k">=</span> EDF<span class="pl-k">.</span><span class="pl-c1">File</span>(my_edf_file_path)

<span class="pl-k">function</span> <span class="pl-en">corrected_header</span>(signal<span class="pl-k">::</span><span class="pl-c1">EDF.Signal</span>)
    header <span class="pl-k">=</span> signal<span class="pl-k">.</span>header
    <span class="pl-k">return</span> Tables<span class="pl-k">.</span><span class="pl-c1">rowmerge</span>(header; 
                           label<span class="pl-k">=</span>header<span class="pl-k">.</span>transducer_type, 
                           transducer_type<span class="pl-k">=</span>header<span class="pl-k">.</span>label)
<span class="pl-k">end</span>

plans <span class="pl-k">=</span> <span class="pl-c1">map</span>(plan_edf_to_onda_samples <span class="pl-k">∘</span> corrected_header, edf<span class="pl-k">.</span>signals)
grouped_plans <span class="pl-k">=</span> <span class="pl-c1">plan_edf_to_onda_samples_groups</span>(plans)
samples, plan_executed <span class="pl-k">=</span> <span class="pl-c1">edf_to_onda_samples</span>(edf, grouped_plans)</pre></div>
</article></div>