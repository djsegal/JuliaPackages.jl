<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-kmeanspnnsmoothingjl" class="anchor" aria-hidden="true" href="#kmeanspnnsmoothingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>KMeansPNNSmoothing.jl</h1>
<p dir="auto">This code implements the PNN-smoothing seeding method for k-means described in the paper
<em>"Systematically and efficiently improving existing k-means initialization algorithms
by pairwise-nearest-neighbor smoothing"</em> by C. Baldassi,
submitted for publication, (2022) <a href="https://arxiv.org/abs/2202.03949" rel="nofollow">arXiv</a>.</p>
<p dir="auto">The code is written in <a href="https://julialang.org" rel="nofollow">Julia</a>. It requires Julia 1.6 or later.</p>
<p dir="auto">It provides a multi-threaded implementation of Lloyd's algorithm, also known as k-means,
with several seeding options:</p>
<ul dir="auto">
<li>sample centroids uniformly at random from the dataset, without replacement</li>
<li><a href="https://scholar.google.com/scholar?cluster=16794944444927209316" rel="nofollow">kmeans++</a>, including the "greedy" variant which is also used by
<a href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/cluster/_kmeans.py">scikit-learn</a></li>
<li>furthest-point heuristic, also called "maxmin" from <a href="https://ieeexplore.ieee.org/document/329844" rel="nofollow">this paper</a></li>
<li><a href="https://arxiv.org/abs/1203.6402" rel="nofollow">kmeansâ€–</a>, also called "scalable kmeans++"</li>
<li><a href="https://ieeexplore.ieee.org/document/35395" rel="nofollow">pairwise nearest-neighbor</a> hierarchical clustering (note: this scales more
than quadratically with the number of points)</li>
<li>the PNN-smoothing meta-method</li>
<li>the <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.8528&amp;rep=rep1&amp;type=pdf" rel="nofollow">refine</a> meta-method</li>
</ul>
<p dir="auto">It also implements a number of different techniques that can accelerate the iterations
of Lloyd's algorithm:</p>
<ul dir="auto">
<li>the naive standard one (no acceleration)</li>
<li>the "reduced comparison" method from <a href="https://doi.org/10.1109/TPAMI.2020.3008694" rel="nofollow">this paper</a></li>
<li>methods based on <a href="https://doi.org/10.1137/1.9781611972801.12" rel="nofollow">Hamerly 2010</a></li>
<li>methods based on <a href="https://www.aaai.org/Papers/ICML/2003/ICML03-022.pdf" rel="nofollow">Elkan 2003</a></li>
<li>variants of the "yinyang" method from <a href="https://proceedings.mlr.press/v37/ding15.html" rel="nofollow">this paper</a></li>
<li>the "exponion" method from <a href="https://proceedings.mlr.press/v48/newling16.html" rel="nofollow">this paper</a></li>
<li>the "ball" method from <a href="https://doi.org/10.1109/TPAMI.2020.3008694" rel="nofollow">this paper</a></li>
</ul>
<p dir="auto">The package also provides two functions to compute the centroid index as defined in <a href="https://www.sciencedirect.com/science/article/abs/pii/S0031320314001150" rel="nofollow">this paper</a>,
an asymmetric one called <code>CI</code> and a symmetric one called <code>CI_sym</code>. These are not exported.</p>
<p dir="auto">It also provides a function to compute the variation of information metric to quantify the
distance between two partitions as defined in <a href="https://www.sciencedirect.com/science/article/pii/S0047259X06002016?via%3Dihub" rel="nofollow">this paper</a>. The function is called <code>VI</code> and is
not exported.</p>
<h3 dir="auto"><a id="user-content-installation-and-setup" class="anchor" aria-hidden="true" href="#installation-and-setup"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation and setup</h3>
<p dir="auto">To install the module, just clone it from GitHub into some directory. Then enter in such directory
and run julia with the "project" option:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ julia --project"><pre class="notranslate"><code>$ julia --project
</code></pre></div>
<p dir="auto">(Alternatively, if you start Julia from some other directory, you can press <kbd>;</kbd> to enter
in shell mode, <code>cd</code> into the project's directory, enter in pkg mode with <kbd>]</kbd> and use the
<code>activate</code> command.)</p>
<p dir="auto">The first time you do this, you will then need to setup the project's environment. To do that,
when you're in the Julia REPL, press the <kbd>]</kbd> key to enter in pkg mode, then resolve the
dependencies:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="(KMeansPNNSmoothing) pkg&gt; resolve"><pre class="notranslate"><code>(KMeansPNNSmoothing) pkg&gt; resolve
</code></pre></div>
<p dir="auto">This should download all the required packages. You can subsequently type <code>test</code> to check that
everything works. After this, you can press the backspace key to get back to the standard Julia
prompt, and load the package:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; using KMeansPNNSmoothing"><pre class="notranslate"><code>julia&gt; using KMeansPNNSmoothing
</code></pre></div>
<h3 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h3>
<p dir="auto">The format of the data must be a <code>Matrix{Float64}</code> with the data points organized by column.
(Typically, this means that if you're reading a dataset you'll need to transpose it. See for
example the <code>runfile.jl</code> script in the <code>test</code> directory.)</p>
<p dir="auto">Here is an example run, assuming we want to cluster a <code>data</code> matrix into <code>k</code> clusters with
the original kmeans++ algorithm (the <code>{1}</code> type parameter deactivates the "greedy" version)
and using the "reduced yinyang" acceleration method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="result = kmeans(data, k; kmseeder=KMSeed.PlusPlus{1}(), accel=KMAccel.Ryy)"><pre>result <span class="pl-k">=</span> <span class="pl-c1">kmeans</span>(data, k; kmseeder<span class="pl-k">=</span>KMSeed<span class="pl-k">.</span><span class="pl-c1">PlusPlus</span><span class="pl-c1">{1}</span>(), accel<span class="pl-k">=</span>KMAccel<span class="pl-k">.</span>Ryy)</pre></div>
<p dir="auto">and here is an example running the PNN-smoothing scheme, using the non-greedy kmeans++ to
seed the initial sub-sets (this is actually the default if no keyword arguments are
passed):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="result = kmeans(data, k; kmseeder=KMSeed.PNNS(KMSeed.PlusPlus{1}()))"><pre>result <span class="pl-k">=</span> <span class="pl-c1">kmeans</span>(data, k; kmseeder<span class="pl-k">=</span>KMSeed<span class="pl-k">.</span><span class="pl-c1">PNNS</span>(KMSeed<span class="pl-k">.</span><span class="pl-c1">PlusPlus</span><span class="pl-c1">{1}</span>()))</pre></div>
<p dir="auto">and here is again PNN-smoothing but this time using "maxmin" at 2 levels of recursion:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="result = kmeans(data, k; kmseeder=KMSeed.PNNS(KMSeed.MaxMin(), rlevel=2))"><pre>result <span class="pl-k">=</span> <span class="pl-c1">kmeans</span>(data, k; kmseeder<span class="pl-k">=</span>KMSeed<span class="pl-k">.</span><span class="pl-c1">PNNS</span>(KMSeed<span class="pl-k">.</span><span class="pl-c1">MaxMin</span>(), rlevel<span class="pl-k">=</span><span class="pl-c1">2</span>))</pre></div>
<p dir="auto">For the complete documentation you can use the Julia help (press the <kbd>?</kbd> key in
the REPL, then type <code>kmeans</code>, or <code>KMSeed</code> or <code>KMAccel</code>)</p>
<p dir="auto">All codes are parallellized (in most cases over the data points) if there are threads
available: either run Julia with the <code>-t</code> option or use the <code>JULIA_NUM_THREADS</code> environment
variable.</p>
<h2 dir="auto"><a id="user-content-licence" class="anchor" aria-hidden="true" href="#licence"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Licence</h2>
<p dir="auto">The code is released under the MIT licence.</p>
<p dir="auto">The code has originated from the code of <a href="https://github.com/carlobaldassi/RecombinatorKMeans.jl">RecombinatorKMeans.jl</a>, see the
licence information there.</p>
</article></div>