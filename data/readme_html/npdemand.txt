<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-npdemand" class="anchor" aria-hidden="true" href="#npdemand"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NPDemand</h1>
<p dir="auto"><a href="https://travis-ci.com/jamesbrandecon/NPDemand.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d4d0ebf620ca566ebaea6e1ecf6bcdff3b17d120482a9a1a7f7f7c7d389a9cd8/68747470733a2f2f7472617669732d63692e636f6d2f6a616d65736272616e6465636f6e2f4e5044656d616e642e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jamesbrandecon/NPDemand.jl.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">This package is designed to take data on many markets of potentially many products (where all products are in each market), select small subgroups of products between which substitution is strongest, and estimate structural demand curves nonparametrically on those subgroups. It can currently handle cases in which each subgroup has ~8 or fewer products, and price is the only observed product characteristic, fairly well. More complicated cases quickly face a curse of dimensionality.</p>
<p dir="auto">Please let me know if you have any suggestions for the package.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">The package is new, so it isn't registered. To install, use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add https://github.com/jamesbrandecon/NPDemand.jl"><pre>pkg<span class="pl-k">&gt;</span> add https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>jamesbrandecon<span class="pl-k">/</span>NPDemand<span class="pl-k">.</span>jl</pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">There are three important functions included here so far: <code>inverse_demand</code>, <code>price_elasticity</code>, and <code>hierNet</code>/<code>hierNet_boot</code>:</p>
<ul dir="auto">
<li><code>inverse_demand(df::DataFrame)</code>: Takes as input a dataframe with columns <code>shares0-sharesJ-1</code>, <code>prices0 - pricesJ-1</code>, <code>demand_instruments0-demand_instrumentsJ-1</code> for J products and estimates inverse demand functions separately for each good. Each inverse demand function is approximated by a Bernstein polynomial of user-chosen order. There are a number of options which are demonstrated in the examples.</li>
<li><code>price_elasticity(inv_sigma, df, p_points, included)</code>: Takes <code>inv_sigma</code> (the output of <code>inverse_demand</code>), and returns estimates of own- or cross-price elasticities, according to the matrix <code>included</code> which specifies which products are substitutes for each other, calculated at a pre-specified vector of prices <code>p_points</code>, which can be user-chosen or the realized prices in the data. The former requires solving for counterfactual market shares and setting the option <code>trueS = false</code>, and is best for getting a sense of the shape of the demand curve. The latter can be used, for example, to calculate markups under traditional models of static pricing in industrial organization.</li>
<li><code>hierNet</code>/<code>hierNet_boot</code>: These functions are for model selection. They take as an input the same DataFrame as above and run constrained lasso regressions (details in draft, coming soon) to select subsets of products which are strong substitutes. <code>hierNet_boot</code> runs this procedure multiple times on bootstrapped samples and takes the intersection of selected substitutes across bootstraps. This takes longer but is less likely to include extraneous substitutes. See examples for options.</li>
</ul>
<p dir="auto">One helpful additional function is <code>simulate_logit</code>, which allows one to easily simulate data from a logit demand system with endogenous prices (and instruments for those prices) to test the <code>NPDemand</code> functions.</p>
<p dir="auto">Rather than run through some short examples here, I've included example files in <code>/examples</code> which demonstrates the use of the most important functions and provides descriptions of the relevant inputs.</p>
<h2 dir="auto"><a id="user-content-model-selection-details" class="anchor" aria-hidden="true" href="#model-selection-details"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Model Selection Details</h2>
<p dir="auto">Model selection follows a modified version of <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4527358/" rel="nofollow">Bien et al (2013)</a>. Currently, I simply regress each product's <code>shares</code>j on all demand instruments. Changing this first-stage to a random forest is on the to-do list for the package. I then run J "hierarchical lasso" regressions of each <code>prices</code> on all predicted <code>shares</code> with either "weak" or "strong" hierarchy imposed. This regression approximates a product's price with an interacted quadratic function in all market shares.</p>
<p dir="auto">I then define a product k as being a substitute for j if the linear coefficient on <code>shares</code>k is non-zero. When "strong" hierarchy is imposed, this is quite natural, as the quadratic term and any interactions involving <code>shares</code>k are nonzero only if the linear term is also nonzero. When "weak" hierarchy is imposed, interaction terms may be nonzero even if the linear term is zero, so this definition of substitutes implicitly treats any such cases as mistaken. Strong hierarchy is therefore better suited to the task at hand, but is far more time consuming and often yields very similar selected models in my simulations.</p>
<h2 dir="auto"><a id="user-content-minimal-example-with-model-selection" class="anchor" aria-hidden="true" href="#minimal-example-with-model-selection"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Minimal Example with Model Selection</h2>
<p dir="auto">As described above, begin with a DataFrame which takes the following form:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; first(df, 5)
5×6 DataFrame
│ Row │ shares0  │ prices0  │ demand_instruments0 │ shares1  │ prices1  │ demand_instruments1 │
│     │ Float64  │ Float64  │ Float64             │ Float64  │ Float64  │ Float64             │
├─────┼──────────┼──────────┼─────────────────────┼──────────┼──────────┼─────────────────────┤
│ 1   │ 0.318976 │ 0.840209 │ 0.377864            │ 0.25169  │ 1.46536  │ 0.612532            │
│ 2   │ 0.221904 │ 1.41531  │ 0.705143            │ 0.312787 │ 1.88974  │ 0.762217            │
│ 3   │ 0.252167 │ 1.02818  │ 0.584668            │ 0.252472 │ 2.06294  │ 0.941736            │
│ 4   │ 0.252374 │ 1.79092  │ 0.788273            │ 0.279031 │ 1.49938  │ 0.672677            │
│ 5   │ 0.286579 │ 1.28321  │ 0.526458            │ 0.292947 │ 0.459311 │ 0.280061            │"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">first</span>(df, <span class="pl-c1">5</span>)
<span class="pl-c1">5</span><span class="pl-k">×</span><span class="pl-c1">6</span> DataFrame
│ Row │ shares0  │ prices0  │ demand_instruments0 │ shares1  │ prices1  │ demand_instruments1 │
│     │ Float64  │ Float64  │ Float64             │ Float64  │ Float64  │ Float64             │
├─────┼──────────┼──────────┼─────────────────────┼──────────┼──────────┼─────────────────────┤
│ <span class="pl-c1">1</span>   │ <span class="pl-c1">0.318976</span> │ <span class="pl-c1">0.840209</span> │ <span class="pl-c1">0.377864</span>            │ <span class="pl-c1">0.25169</span>  │ <span class="pl-c1">1.46536</span>  │ <span class="pl-c1">0.612532</span>            │
│ <span class="pl-c1">2</span>   │ <span class="pl-c1">0.221904</span> │ <span class="pl-c1">1.41531</span>  │ <span class="pl-c1">0.705143</span>            │ <span class="pl-c1">0.312787</span> │ <span class="pl-c1">1.88974</span>  │ <span class="pl-c1">0.762217</span>            │
│ <span class="pl-c1">3</span>   │ <span class="pl-c1">0.252167</span> │ <span class="pl-c1">1.02818</span>  │ <span class="pl-c1">0.584668</span>            │ <span class="pl-c1">0.252472</span> │ <span class="pl-c1">2.06294</span>  │ <span class="pl-c1">0.941736</span>            │
│ <span class="pl-c1">4</span>   │ <span class="pl-c1">0.252374</span> │ <span class="pl-c1">1.79092</span>  │ <span class="pl-c1">0.788273</span>            │ <span class="pl-c1">0.279031</span> │ <span class="pl-c1">1.49938</span>  │ <span class="pl-c1">0.672677</span>            │
│ <span class="pl-c1">5</span>   │ <span class="pl-c1">0.286579</span> │ <span class="pl-c1">1.28321</span>  │ <span class="pl-c1">0.526458</span>            │ <span class="pl-c1">0.292947</span> │ <span class="pl-c1">0.459311</span> │ <span class="pl-c1">0.280061</span>            │</pre></div>
<p dir="auto">In this case, there are two goods, so model selection is not necessary, but we can demonstrate the approach regardless. Selecting a model requires a call to <code>hierNet</code> or <code>hierNet_boot</code>, the latter of which takes an extra option <code>nboots</code> which controls the number of bootstrapped samples on which the selection procedure is performed:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="included, included_symmetric = hierNet_boot(df; nfolds = 5, nlam = 10, strong = false, nboot = 5);
included, included_symmetric = hierNet(df; nfolds = 5, nlam = 10, strong = false);"><pre>included, included_symmetric <span class="pl-k">=</span> <span class="pl-c1">hierNet_boot</span>(df; nfolds <span class="pl-k">=</span> <span class="pl-c1">5</span>, nlam <span class="pl-k">=</span> <span class="pl-c1">10</span>, strong <span class="pl-k">=</span> <span class="pl-c1">false</span>, nboot <span class="pl-k">=</span> <span class="pl-c1">5</span>);
included, included_symmetric <span class="pl-k">=</span> <span class="pl-c1">hierNet</span>(df; nfolds <span class="pl-k">=</span> <span class="pl-c1">5</span>, nlam <span class="pl-k">=</span> <span class="pl-c1">10</span>, strong <span class="pl-k">=</span> <span class="pl-c1">false</span>);</pre></div>
<p dir="auto">The matrix <code>included</code> is a matrix of ones and zeros indicating which products are close substitutes, and <code>included_symmetric</code> is a similar matrix which enforces that k must substitute for j if j substitutes for k. Next, one can estimate demand and calculate price elasticites:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="inv_sigma, designs = inverse_demand(df; included = included_symmetric);
elast, Jacobians, share_vec = price_elasticity(inv_sigma, df, p; whichProducts = [1,1],
             included = included_symmetric, trueS = true);"><pre>inv_sigma, designs <span class="pl-k">=</span> <span class="pl-c1">inverse_demand</span>(df; included <span class="pl-k">=</span> included_symmetric);
elast, Jacobians, share_vec <span class="pl-k">=</span> <span class="pl-c1">price_elasticity</span>(inv_sigma, df, p; whichProducts <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">1</span>],
             included <span class="pl-k">=</span> included_symmetric, trueS <span class="pl-k">=</span> <span class="pl-c1">true</span>);</pre></div>
<p dir="auto"><code>whichProducts=[j,k]</code> indicates that you want <code>elast</code> to include elasticities of demand for product j with respect to price k, and <code>trueS = true</code> indicates that you want these elasticities evaluated at the realized market shares and prices.</p>
<h2 dir="auto"><a id="user-content-calling-from-pythonr" class="anchor" aria-hidden="true" href="#calling-from-pythonr"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calling from Python/R</h2>
<p dir="auto">Some researchers may wish to call this package directly from Python code. The easiest way to do this is through a Jupyter notebook. In IPython, after running the command <code>%load_ext julia.magic</code>, one can call Julia (assuming it is installed) by prefacing each line with <code>%julia</code>. In R, one can use the <code>JuliaCall</code> package.</p>
<h2 dir="auto"><a id="user-content-to-do" class="anchor" aria-hidden="true" href="#to-do"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>To-do</h2>
<ul dir="auto">
<li>Additional documentation for <code>hierNet_boot</code> and <code>price_elasticity</code> options.</li>
<li>Give option to make first stage prediction in <code>hierNet</code> a random forest.</li>
<li>Convert Compiani (2020) code to Julia in order to add exchangeability as an optional constraint.</li>
</ul>
</article></div>