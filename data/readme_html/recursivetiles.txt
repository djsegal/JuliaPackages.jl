<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-recursivetiles" class="anchor" aria-hidden="true" href="#recursivetiles"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>RecursiveTiles</h1>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(&quot;RecursiveTiles&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>RecursiveTiles<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-description" class="anchor" aria-hidden="true" href="#description"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Description</h2>
<p dir="auto">One has data arranged in an array, each slice of which corresponds to
a single data point.  Across slices, some information is
repeated. This repeated information may be viewed as an index common
to the non-repeated information of each slice. Let us consider cases
in which the slices are arranged such that repetitions of an index
are contiguous. In such a scenario, the non-repeated information forms
a contiguous partition. We shall refer to this contiguous partition of
value(s) under a common index as a tile. In the abstract, this tile is
but one piece of the mosaic which is the host array.</p>
<p dir="auto">As the contiguous repetition of an index across slices serves to
demarcate the extent of a tile, one might naturally consider
augmentation with an additional index which spans multiple tiles. We
may view the additional index as defining a contiguous partition, the
elements of which are themselves partitions defined by the original
index. In other words, a tile of tiles. Thus, we arrive at the
following abstraction: a tile is comprised of elements, and the
demarcation of said tile occurs by the contiguous repetition of an
index. Consequently, through augmentation with an index, we define a
partitioning of elements; through multiple augmentations, we
may recursively define partitions the elements of which are
partitions. Construction then proceeds from the outermost index, which
defines the outermost partition, which is then partitioned according
to the next successive index, and so on.</p>
<p dir="auto">This package provides composable types which provide a succinct method
for construction of recursively tiled slices of arrays.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">The recursive partitioning (by quantities which serve as indices) can
be fruitfully expressed through a composition of types. The composite
may then be used to direct the construction of tiles of arbitrary depth.</p>
<p dir="auto">To direct the construction of individual tiles, one uses a <code>Scheme</code>,
consisting of a transformation, <code>f</code>, which constructs the element of a
tile, and a transformation, <code>g</code>, which constructs the index of the
tile.  A single tile may be constructed as <code>tile(Scheme(f,g), A)</code>, or
multiple tiles, using <code>g</code> to partition, as <code>tiles(Scheme(f,g), A)</code>.
An index may be added by extending the <code>s = Scheme(f,g)</code> by wrapping
it as <code>ExtendScheme(s, h)</code> where <code>s</code> is the <code>Scheme</code> or <code>ExtendScheme</code>
to which an index is being added and <code>h</code> is the transformation which
constructs the index.  In the presence of multiple indices, as
indicated by the <code>ExtendScheme</code> type, one or more inner partitions
exist, hence, a <code>tile(ExtendScheme(s, h), A)</code> call will partition <code>A</code>
by the inner index, then call <code>tile(s, B)</code> on each partition <code>B</code>,
ultimately returning a tile with outer index given by <code>h</code> and a vector
of â‰¥ 1 tiles, each with their respective inner index.  This proceeds
recursively, such that an arbitrary number of indices may be added by
extending via <code>ExtendScheme</code> wraps.</p>
<p dir="auto">It can be tedious to write out each <code>ExtendScheme</code> wrap, hence,
<code>@scheme</code> macro is provided to facilitate this, such that <code>@scheme f g h1 h2 h3</code> is equivalent to
<code>ExtendScheme(ExtendScheme(ExtendScheme(Scheme(f, g), h1), h2), h3)</code>.
The reader will likely agree that specification via the macro is also
much easier to read.</p>
<p dir="auto">Note that anything may serve as an index -- naturally one thinks in
terms of, an <code>Integer</code>, or <code>NTuple</code> thereof, but no type-based
limitations exist. One may choose to use, for example, <code>Tuple{String, Int, Float64}</code>, <code>Vector{Any}</code>, or any other type, if the application
calls for it; the only requirement is that <code>isequal(a,b)</code> return a
sensible result.</p>
<h2 dir="auto"><a id="user-content-type-interface" class="anchor" aria-hidden="true" href="#type-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Type Interface</h2>
<p dir="auto">The <code>AbstractTile</code> type is a subtype of <code>AbstractVector</code>, hence,
the interface for types returned by this package is that of
<code>AbstractArray</code>; a small number of specializations
(<code>hash</code>, <code>==</code>, <code>isequal</code>, <code>&lt;</code>, <code>isless</code>) exist so as to enable
set operations, sorting, comparison, etc. to respect the presence of
the index held by each tile. Such specializations would not normally
be visible to the user, and, as applied here, serve only to encourage
the user to treat <code>Tile</code>s as <code>AbstractArray</code>s.</p>
<h2 dir="auto"><a id="user-content-recommendations" class="anchor" aria-hidden="true" href="#recommendations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Recommendations</h2>
<ul dir="auto">
<li>As a tile is defined by contiguous repetition of some value (which
we call an index) produced by the transformation of each slice,
it can often be easier to achieve a given tiling
by first transforming the array in the appropriate way, sorting it
along the appropriate dimensions by the appropriate tuple(s), then
finally constructing the tiling scheme. This may make it easier to
reason about how the index (or indices) should be presented;
naturally, this does not apply to the value in the base case (the
value returned by <code>f</code>).</li>
<li>The recursive tiling defines partitions based on the transformation
of each slice, not the literal values (though, we might specify a
literal value, e.g. <code>first</code>). This means that non-contiguous
occurrences of the same index belong to separate partitions. Note
the contrast with a <code>groupby</code> operation, which would imply that all
occurrences of the same index belong to the same partition.</li>
</ul>
<h2 dir="auto"><a id="user-content-conventions" class="anchor" aria-hidden="true" href="#conventions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Conventions</h2>
<p dir="auto">In calls to both <code>tile</code> and <code>tiles</code>, <code>A</code> is assumed to be in the
desired state, and will be treated as an <code>AbstractArray</code>. Commonly,
this means using <code>eachrow</code>, <code>eachcol</code> or <code>eachslice</code>, such that one
actually passes <code>B = eachslice(A, dims=...)</code>.</p>
<p dir="auto">The distinction between <code>Scheme</code> and <code>ExtendScheme</code> exists for
signaling purposes. In the call to <code>tile</code>, a <code>Scheme</code> is always the
base case, and signals that it should be applied to the entirety of
<code>A</code>, whereas an <code>ExtendScheme</code> signals that <code>A</code> should be partitioned
according to the inner index defined by the entity-being wrapped
(<code>e.s.g</code> if <code>ExtendScheme(Scheme)</code>, or <code>e.s.h</code> if
<code>ExtendScheme(ExtendScheme(...))</code>), and the <code>Scheme</code>/<code>ExtendScheme</code> applied to
each partition. Each partition consists of a contiguous range, across
which <code>g</code> (or <code>h</code>) has the same value; hence, this value serves as the index of
the partition.</p>
<h3 dir="auto"><a id="user-content-tiles-a" class="anchor" aria-hidden="true" href="#tiles-a"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>tile(s, A)</code></h3>
<ul dir="auto">
<li>When <code>tile(s::AbstractScheme, A)</code> is called, it is assumed that an
outermost index applies to the entirety of <code>A</code>, and that the <code>Scheme</code> is
to be applied to the entirety of <code>A</code>.</li>
<li>When <code>tile(s::AbstractExtendScheme, A)</code> is called, it is assumed
that the outermost index applies to the entirety of <code>A</code>, and that
the inner index -- the index of the <code>Scheme/ExtendScheme</code> being
extended -- defines â‰¥ 1 ranges on <code>A</code>. These ranges are found, and
the entity-being-wrapped is called on each contiguous range, thereby
returning a tile of inner tiles bearing an outer index given by <code>h</code>.</li>
<li>If <code>g::Nothing</code>, no index exists for the tile. If <code>h::Nothing</code>, this
is simply a no-op and the entity-being-wrapped is unwrapped and
passed to <code>tile</code>.</li>
<li>If a <code>Scheme</code> without an index (i.e. <code>s = Scheme(f, nothing)</code>) is
wrapped in an <code>ExtendScheme</code> with an outer index (i.e. <code>e = ExtendScheme(s, h)</code>), then this is equivalent to the outer index
being on the <code>Scheme</code> itself, hence, this could be expressed as
<code>Scheme(f, h)</code>.</li>
</ul>
<h3 dir="auto"><a id="user-content-tiless-a" class="anchor" aria-hidden="true" href="#tiless-a"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>tiles(s, A)</code></h3>
<ul dir="auto">
<li>When <code>tiles(s::AbstractScheme, A)</code> is called, the index is
assumed to define â‰¥ 1 ranges on A; these are found and the <code>Scheme</code>
is then called on each contiguous slice, producing a vector of
tiles, each of which bears the index which defined its contiguous
slice.</li>
<li>When <code>tiles(s::AbstractExtendScheme, A)</code> is called, the behavior is
the same: the outer index (defined by <code>h</code>) is assumed to define â‰¥ 1
ranges on A, which are then found and the <code>ExtendScheme</code> is then
called on each contiguous slice.</li>
</ul>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<h3 dir="auto"><a id="user-content-simple" class="anchor" aria-hidden="true" href="#simple"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simple</h3>
<details>
 
<p dir="auto">
</p><p dir="auto">As a simple example, consider a matrix in which the second and third columns contain
indices which may be used to partition the matrix. Under normal circumstances, one
might not use an <code>f</code> which is applied to the entire slice, but here we opt for <code>sum</code>
as this produces distinct values which aids the illustration.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; second(x) = x[begin+1];

julia&gt; A = [10 1 1
            20 1 1
            30 1 1
            10 2 1
            20 2 1
            30 2 2
            10 3 2
            20 3 2
            10 4 2
            20 4 2];

julia&gt; B = eachrow(A);

julia&gt; s = @scheme sum second last;

# This partitions by `second` only (as the call is via `tile`), yielding
# 4 total tiles.

julia&gt; x = tile(s, B)
4-element Tile{Vector{Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, 1}}, Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}:
 [12, 22, 32]
 [13, 23, 34]
 [15, 25]
 [16, 26]

julia&gt; x.I
(1,)

julia&gt; (x...,)
([12, 22, 32], [13, 23, 34], [15, 25], [16, 26])

julia&gt; getproperty.(x, :I)
4-element Vector{Tuple{Int64}}:
 (1,)
 (2,)
 (3,)
 (4,)

# This partitions by `last`, then partitions each resultant slice by `second`,
# yielding 2 tiles, the first of which consists of 2 tiles and and the second
# of which consists of 3 tiles.

julia&gt; xs = tiles(s, B)
2-element Vector{Tile{Vector{Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, 1}}, Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}}:
 [[12, 22, 32], [13, 23]]
 [[34], [15, 25], [16, 26]]

julia&gt; getproperty.(xs, :I)
2-element Vector{Tuple{Int64}}:
 (1,)
 (2,)

julia&gt; map(x -&gt; getproperty.(x, :I), xs)
2-element Vector{Vector{Tuple{Int64}}}:
 [(1,), (2,)]
 [(2,), (3,), (4,)]"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">second</span>(x) <span class="pl-k">=</span> x[<span class="pl-c1">begin</span><span class="pl-k">+</span><span class="pl-c1">1</span>];

julia<span class="pl-k">&gt;</span> A <span class="pl-k">=</span> [<span class="pl-c1">10</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>
            <span class="pl-c1">20</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>
            <span class="pl-c1">30</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>
            <span class="pl-c1">10</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>
            <span class="pl-c1">20</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>
            <span class="pl-c1">30</span> <span class="pl-c1">2</span> <span class="pl-c1">2</span>
            <span class="pl-c1">10</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span>
            <span class="pl-c1">20</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span>
            <span class="pl-c1">10</span> <span class="pl-c1">4</span> <span class="pl-c1">2</span>
            <span class="pl-c1">20</span> <span class="pl-c1">4</span> <span class="pl-c1">2</span>];

julia<span class="pl-k">&gt;</span> B <span class="pl-k">=</span> <span class="pl-c1">eachrow</span>(A);

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">@scheme</span> sum second last;

<span class="pl-c"><span class="pl-c">#</span> This partitions by `second` only (as the call is via `tile`), yielding</span>
<span class="pl-c"><span class="pl-c">#</span> 4 total tiles.</span>

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">tile</span>(s, B)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Tile{Vector{Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}<span class="pl-k">:</span>
 [<span class="pl-c1">12</span>, <span class="pl-c1">22</span>, <span class="pl-c1">32</span>]
 [<span class="pl-c1">13</span>, <span class="pl-c1">23</span>, <span class="pl-c1">34</span>]
 [<span class="pl-c1">15</span>, <span class="pl-c1">25</span>]
 [<span class="pl-c1">16</span>, <span class="pl-c1">26</span>]

julia<span class="pl-k">&gt;</span> x<span class="pl-k">.</span>I
(<span class="pl-c1">1</span>,)

julia<span class="pl-k">&gt;</span> (x<span class="pl-k">...</span>,)
([<span class="pl-c1">12</span>, <span class="pl-c1">22</span>, <span class="pl-c1">32</span>], [<span class="pl-c1">13</span>, <span class="pl-c1">23</span>, <span class="pl-c1">34</span>], [<span class="pl-c1">15</span>, <span class="pl-c1">25</span>], [<span class="pl-c1">16</span>, <span class="pl-c1">26</span>])

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getproperty</span>.(x, <span class="pl-c1">:I</span>)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Vector{Tuple{Int64}}<span class="pl-k">:</span>
 (<span class="pl-c1">1</span>,)
 (<span class="pl-c1">2</span>,)
 (<span class="pl-c1">3</span>,)
 (<span class="pl-c1">4</span>,)

<span class="pl-c"><span class="pl-c">#</span> This partitions by `last`, then partitions each resultant slice by `second`,</span>
<span class="pl-c"><span class="pl-c">#</span> yielding 2 tiles, the first of which consists of 2 tiles and and the second</span>
<span class="pl-c"><span class="pl-c">#</span> of which consists of 3 tiles.</span>

julia<span class="pl-k">&gt;</span> xs <span class="pl-k">=</span> <span class="pl-c1">tiles</span>(s, B)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Tile{Vector{Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Int64}, Int64, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}<span class="pl-k">:</span>
 [[<span class="pl-c1">12</span>, <span class="pl-c1">22</span>, <span class="pl-c1">32</span>], [<span class="pl-c1">13</span>, <span class="pl-c1">23</span>]]
 [[<span class="pl-c1">34</span>], [<span class="pl-c1">15</span>, <span class="pl-c1">25</span>], [<span class="pl-c1">16</span>, <span class="pl-c1">26</span>]]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getproperty</span>.(xs, <span class="pl-c1">:I</span>)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Tuple{Int64}}<span class="pl-k">:</span>
 (<span class="pl-c1">1</span>,)
 (<span class="pl-c1">2</span>,)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">getproperty</span>.(x, <span class="pl-c1">:I</span>), xs)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Vector{Tuple{Int64}}}<span class="pl-k">:</span>
 [(<span class="pl-c1">1</span>,), (<span class="pl-c1">2</span>,)]
 [(<span class="pl-c1">2</span>,), (<span class="pl-c1">3</span>,), (<span class="pl-c1">4</span>,)]</pre></div>
<p dir="auto"></p>
</details>
<h3 dir="auto"><a id="user-content-sort-before-tiling" class="anchor" aria-hidden="true" href="#sort-before-tiling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sort before tiling</h3>
<details>
 
<p dir="auto">
</p><p dir="auto">As an example where it may be necessary to sort the array prior to
tiling, consider the following matrix.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; second(x) = x[begin+1]; third(x) = x[begin+2];

julia&gt; A = [1 7 1 'a'
            1 7 2 'a'
            1 8 1 'b'
            1 8 1 'c'
            2 7 1 'c'
            2 7 1 'a'
            2 7 2 'b'
            2 7 2 'c'
            2 7 2 'b'
            1 8 1 'b'
            1 8 2 'a'
            1 8 2 'c'
            1 7 1 'b'
            1 7 2 'a'
            1 8 3 'a'
            ];

# Here, it is necessary to first sort the array in order to form contiguous repetitions.
# Conversely, if the contiguous repetitions of the original array are intentional,
# then sorting would destroy said structure.
julia&gt; Aâ€² = sortslices(A, dims=1, by=x -&gt; (x[1], x[2], x[3]))
15Ã—4 Matrix{Any}:
 1  7  1  'a'
 1  7  1  'b'
 1  7  2  'a'
 1  7  2  'a'
 1  8  1  'b'
 1  8  1  'c'
 1  8  1  'b'
 1  8  2  'a'
 1  8  2  'c'
 1  8  3  'a'
 2  7  1  'c'
 2  7  1  'a'
 2  7  2  'b'
 2  7  2  'c'
 2  7  2  'b'

julia&gt; s = @scheme last third second first;

julia&gt; Bâ€² = eachrow(Aâ€²);

julia&gt; xs = tiles(s, Bâ€²)
2-element Vector{Tile{Vector{Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}}, Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}}:
 [[['a', 'b'], ['a', 'a']], [['b', 'c', 'b'], ['a', 'c'], ['a']]]
 [[['c', 'a'], ['b', 'c', 'b']]]

julia&gt; x1, x2 = xs;

julia&gt; x1
2-element Tile{Vector{Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}}, Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}:
 [['a', 'b'], ['a', 'a']]
 [['b', 'c', 'b'], ['a', 'c'], ['a']]

julia&gt; x2
1-element Tile{Vector{Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}}, Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}, Tuple{Int64}, Int64, 1}:
 [['c', 'a'], ['b', 'c', 'b']]

# Let's look at the indices
julia&gt; x1.I, x2.I
((1,), (2,))

julia&gt; getproperty.(x1, :I)
2-element Vector{Tuple{Int64}}:
 (7,)
 (8,)

julia&gt; getproperty.(x2, :I)
1-element Vector{Tuple{Int64}}:
 (7,)

julia&gt; map(x -&gt; getproperty.(x, :I), x1)
2-element Vector{Vector{Tuple{Int64}}}:
 [(1,), (2,)]
 [(1,), (2,), (3,)]

julia&gt; map(x -&gt; getproperty.(x, :I), x2)
1-element Vector{Vector{Tuple{Int64}}}:
 [(1,), (2,)]"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">second</span>(x) <span class="pl-k">=</span> x[<span class="pl-c1">begin</span><span class="pl-k">+</span><span class="pl-c1">1</span>]; <span class="pl-en">third</span>(x) <span class="pl-k">=</span> x[<span class="pl-c1">begin</span><span class="pl-k">+</span><span class="pl-c1">2</span>];

julia<span class="pl-k">&gt;</span> A <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">7</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">7</span> <span class="pl-c1">2</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">8</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">8</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
            <span class="pl-c1">2</span> <span class="pl-c1">7</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
            <span class="pl-c1">2</span> <span class="pl-c1">7</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
            <span class="pl-c1">2</span> <span class="pl-c1">7</span> <span class="pl-c1">2</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
            <span class="pl-c1">2</span> <span class="pl-c1">7</span> <span class="pl-c1">2</span> <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
            <span class="pl-c1">2</span> <span class="pl-c1">7</span> <span class="pl-c1">2</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">8</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">8</span> <span class="pl-c1">2</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">8</span> <span class="pl-c1">2</span> <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">7</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">7</span> <span class="pl-c1">2</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
            <span class="pl-c1">1</span> <span class="pl-c1">8</span> <span class="pl-c1">3</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
            ];

<span class="pl-c"><span class="pl-c">#</span> Here, it is necessary to first sort the array in order to form contiguous repetitions.</span>
<span class="pl-c"><span class="pl-c">#</span> Conversely, if the contiguous repetitions of the original array are intentional,</span>
<span class="pl-c"><span class="pl-c">#</span> then sorting would destroy said structure.</span>
julia<span class="pl-k">&gt;</span> Aâ€² <span class="pl-k">=</span> <span class="pl-c1">sortslices</span>(A, dims<span class="pl-k">=</span><span class="pl-c1">1</span>, by<span class="pl-k">=</span>x <span class="pl-k">-&gt;</span> (x[<span class="pl-c1">1</span>], x[<span class="pl-c1">2</span>], x[<span class="pl-c1">3</span>]))
<span class="pl-c1">15</span><span class="pl-k">Ã—</span><span class="pl-c1">4</span> Matrix{Any}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-c1">7</span>  <span class="pl-c1">1</span>  <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">7</span>  <span class="pl-c1">1</span>  <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">7</span>  <span class="pl-c1">2</span>  <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">7</span>  <span class="pl-c1">2</span>  <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">8</span>  <span class="pl-c1">1</span>  <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">8</span>  <span class="pl-c1">1</span>  <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">8</span>  <span class="pl-c1">1</span>  <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">8</span>  <span class="pl-c1">2</span>  <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">8</span>  <span class="pl-c1">2</span>  <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
 <span class="pl-c1">1</span>  <span class="pl-c1">8</span>  <span class="pl-c1">3</span>  <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
 <span class="pl-c1">2</span>  <span class="pl-c1">7</span>  <span class="pl-c1">1</span>  <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
 <span class="pl-c1">2</span>  <span class="pl-c1">7</span>  <span class="pl-c1">1</span>  <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>
 <span class="pl-c1">2</span>  <span class="pl-c1">7</span>  <span class="pl-c1">2</span>  <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>
 <span class="pl-c1">2</span>  <span class="pl-c1">7</span>  <span class="pl-c1">2</span>  <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>
 <span class="pl-c1">2</span>  <span class="pl-c1">7</span>  <span class="pl-c1">2</span>  <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">@scheme</span> last third second first;

julia<span class="pl-k">&gt;</span> Bâ€² <span class="pl-k">=</span> <span class="pl-c1">eachrow</span>(Aâ€²);

julia<span class="pl-k">&gt;</span> xs <span class="pl-k">=</span> <span class="pl-c1">tiles</span>(s, Bâ€²)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Tile{Vector{Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}<span class="pl-k">:</span>
 [[[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>]], [[<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>]]]
 [[[<span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>]]]

julia<span class="pl-k">&gt;</span> x1, x2 <span class="pl-k">=</span> xs;

julia<span class="pl-k">&gt;</span> x1
<span class="pl-c1">2</span><span class="pl-k">-</span>element Tile{Vector{Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}<span class="pl-k">:</span>
 [[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>]]
 [[<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>]]

julia<span class="pl-k">&gt;</span> x2
<span class="pl-c1">1</span><span class="pl-k">-</span>element Tile{Vector{Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}}, Tile{Vector{Char}, Char, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}, Tuple{Int64}, Int64, <span class="pl-c1">1</span>}<span class="pl-k">:</span>
 [[<span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>], [<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>]]

<span class="pl-c"><span class="pl-c">#</span> Let's look at the indices</span>
julia<span class="pl-k">&gt;</span> x1<span class="pl-k">.</span>I, x2<span class="pl-k">.</span>I
((<span class="pl-c1">1</span>,), (<span class="pl-c1">2</span>,))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getproperty</span>.(x1, <span class="pl-c1">:I</span>)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Tuple{Int64}}<span class="pl-k">:</span>
 (<span class="pl-c1">7</span>,)
 (<span class="pl-c1">8</span>,)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getproperty</span>.(x2, <span class="pl-c1">:I</span>)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Vector{Tuple{Int64}}<span class="pl-k">:</span>
 (<span class="pl-c1">7</span>,)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">getproperty</span>.(x, <span class="pl-c1">:I</span>), x1)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Vector{Tuple{Int64}}}<span class="pl-k">:</span>
 [(<span class="pl-c1">1</span>,), (<span class="pl-c1">2</span>,)]
 [(<span class="pl-c1">1</span>,), (<span class="pl-c1">2</span>,), (<span class="pl-c1">3</span>,)]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">map</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">getproperty</span>.(x, <span class="pl-c1">:I</span>), x2)
<span class="pl-c1">1</span><span class="pl-k">-</span>element Vector{Vector{Tuple{Int64}}}<span class="pl-k">:</span>
 [(<span class="pl-c1">1</span>,), (<span class="pl-c1">2</span>,)]</pre></div>
<p dir="auto"></p>
</details>
<h3 dir="auto"><a id="user-content-various-abstractarrays-multidimensional" class="anchor" aria-hidden="true" href="#various-abstractarrays-multidimensional"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Various <code>AbstractArray</code>s; multidimensional</h3>
<details>
 
<p dir="auto">
</p><p dir="auto">The methods apply are agnostic to the particular subtype of <code>AbstractArray</code>, as demonstrated by
the somewhat contrived examples below.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; second(x) = x[begin+1]; third(x) = x[begin+2];

julia&gt; r = -12:12;

julia&gt; A = reshape(r, 5, 5)
5Ã—5 reshape(::UnitRange{Int64}, 5, 5) with eltype Int64:
 -12  -7  -2  3   8
 -11  -6  -1  4   9
 -10  -5   0  5  10
  -9  -4   1  6  11
  -8  -3   2  7  12

julia&gt; B = eachcol(A);

julia&gt; s = @scheme sum signbit âˆ˜ third;

julia&gt; xs = tiles(s, B)
2-element Vector{Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, 1}}:
 [-50, -25]
 [0, 25, 50]

julia&gt; x1, x2 = xs;

julia&gt; x1
2-element Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, 1}:
 -50
 -25

julia&gt; x2
3-element Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, 1}:
  0
 25
 50

julia&gt; x1.I, x2.I
((true,), (false,))

julia&gt; using OffsetArrays

julia&gt; oA = reshape(r, -2:2, -3:1)
5Ã—5 OffsetArray(reshape(::UnitRange{Int64}, 5, 5), -2:2, -3:1) with eltype Int64 with indices -2:2Ã—-3:1: -12  -7  -2  3   8
 -11  -6  -1  4   9
 -10  -5   0  5  10
  -9  -4   1  6  11
  -8  -3   2  7  12

julia&gt; ob = eachcol(oA);

julia&gt; xs == tiles(s, oB)
true

# More than one dimension; this keeps the partition function simple for clarity

julia&gt; r = -13:13
-13:13

julia&gt; A = reshape(r, 3, 3,3)
3Ã—3Ã—3 reshape(::UnitRange{Int64}, 3, 3, 3) with eltype Int64:
[:, :, 1] =
 -13  -10  -7
 -12   -9  -6
 -11   -8  -5

[:, :, 2] =
 -4  -1  2
 -3   0  3
 -2   1  4

[:, :, 3] =
 5   8  11
 6   9  12
 7  10  13

julia&gt; B = eachslice(A, dims=(2,3))
3Ã—3 Slices{Base.ReshapedArray{Int64, 3, UnitRange{Int64}, Tuple{}}, Tuple{Colon, Int64, Int64}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}, SubArray{Int64, 1, Base.ReshapedArray{Int64, 3, UnitRange{Int64}, Tuple{}}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64, Int64}, true}, 2}:
 [-13, -12, -11]  [-4, -3, -2]  [5, 6, 7]
 [-10, -9, -8]    [-1, 0, 1]    [8, 9, 10]
 [-7, -6, -5]     [2, 3, 4]     [11, 12, 13]

julia&gt; s = @scheme sum signbit âˆ˜ second;

julia&gt; xs = tiles(s, B)
2-element Vector{Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, 1}}:
 [-36, -27, -18, -9]
 [0, 9, 18, 27, 36]

julia&gt; x1, x2 = xs;

julia&gt; x1 == sum.(B[1:4])
true

julia&gt; x2 == sum.(B[5:9])
true

julia&gt; vcat(xs...) == vec(sum(A, dims=1))
true

# And one last example, just for fun

julia&gt; s = @scheme sum x -&gt; abs(sum(x)) &gt; 9;

julia&gt; xs = tiles(s, B)
3-element Vector{Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, 1}}:
 [-36, -27, -18]
 [-9, 0, 9]
 [18, 27, 36]

julia&gt; getproperty.(xs, :I)
3-element Vector{Tuple{Bool}}:
 (1,)
 (0,)
 (1,)

julia&gt; x1, x2, x3 = xs;

julia&gt; x1 == sum.(B[1:3])
true

julia&gt; x2 == sum.(B[4:6])
true

julia&gt; x3 == sum.(B[7:9])
true

julia&gt; vcat(xs...) == vec(sum(A, dims=1))
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">second</span>(x) <span class="pl-k">=</span> x[<span class="pl-c1">begin</span><span class="pl-k">+</span><span class="pl-c1">1</span>]; <span class="pl-en">third</span>(x) <span class="pl-k">=</span> x[<span class="pl-c1">begin</span><span class="pl-k">+</span><span class="pl-c1">2</span>];

julia<span class="pl-k">&gt;</span> r <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">12</span><span class="pl-k">:</span><span class="pl-c1">12</span>;

julia<span class="pl-k">&gt;</span> A <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(r, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>)
<span class="pl-c1">5</span><span class="pl-k">Ã—</span><span class="pl-c1">5</span> <span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>) with eltype Int64<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">12</span>  <span class="pl-k">-</span><span class="pl-c1">7</span>  <span class="pl-k">-</span><span class="pl-c1">2</span>  <span class="pl-c1">3</span>   <span class="pl-c1">8</span>
 <span class="pl-k">-</span><span class="pl-c1">11</span>  <span class="pl-k">-</span><span class="pl-c1">6</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>  <span class="pl-c1">4</span>   <span class="pl-c1">9</span>
 <span class="pl-k">-</span><span class="pl-c1">10</span>  <span class="pl-k">-</span><span class="pl-c1">5</span>   <span class="pl-c1">0</span>  <span class="pl-c1">5</span>  <span class="pl-c1">10</span>
  <span class="pl-k">-</span><span class="pl-c1">9</span>  <span class="pl-k">-</span><span class="pl-c1">4</span>   <span class="pl-c1">1</span>  <span class="pl-c1">6</span>  <span class="pl-c1">11</span>
  <span class="pl-k">-</span><span class="pl-c1">8</span>  <span class="pl-k">-</span><span class="pl-c1">3</span>   <span class="pl-c1">2</span>  <span class="pl-c1">7</span>  <span class="pl-c1">12</span>

julia<span class="pl-k">&gt;</span> B <span class="pl-k">=</span> <span class="pl-c1">eachcol</span>(A);

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">@scheme</span> sum signbit <span class="pl-k">âˆ˜</span> third;

julia<span class="pl-k">&gt;</span> xs <span class="pl-k">=</span> <span class="pl-c1">tiles</span>(s, B)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, <span class="pl-c1">1</span>}}<span class="pl-k">:</span>
 [<span class="pl-k">-</span><span class="pl-c1">50</span>, <span class="pl-k">-</span><span class="pl-c1">25</span>]
 [<span class="pl-c1">0</span>, <span class="pl-c1">25</span>, <span class="pl-c1">50</span>]

julia<span class="pl-k">&gt;</span> x1, x2 <span class="pl-k">=</span> xs;

julia<span class="pl-k">&gt;</span> x1
<span class="pl-c1">2</span><span class="pl-k">-</span>element Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, <span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">50</span>
 <span class="pl-k">-</span><span class="pl-c1">25</span>

julia<span class="pl-k">&gt;</span> x2
<span class="pl-c1">3</span><span class="pl-k">-</span>element Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, <span class="pl-c1">1</span>}<span class="pl-k">:</span>
  <span class="pl-c1">0</span>
 <span class="pl-c1">25</span>
 <span class="pl-c1">50</span>

julia<span class="pl-k">&gt;</span> x1<span class="pl-k">.</span>I, x2<span class="pl-k">.</span>I
((<span class="pl-c1">true</span>,), (<span class="pl-c1">false</span>,))

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> OffsetArrays

julia<span class="pl-k">&gt;</span> oA <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(r, <span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">1</span>)
<span class="pl-c1">5</span><span class="pl-k">Ã—</span><span class="pl-c1">5</span> <span class="pl-c1">OffsetArray</span>(<span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>), <span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">1</span>) with eltype Int64 with indices <span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">Ã—-</span><span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">12</span>  <span class="pl-k">-</span><span class="pl-c1">7</span>  <span class="pl-k">-</span><span class="pl-c1">2</span>  <span class="pl-c1">3</span>   <span class="pl-c1">8</span>
 <span class="pl-k">-</span><span class="pl-c1">11</span>  <span class="pl-k">-</span><span class="pl-c1">6</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>  <span class="pl-c1">4</span>   <span class="pl-c1">9</span>
 <span class="pl-k">-</span><span class="pl-c1">10</span>  <span class="pl-k">-</span><span class="pl-c1">5</span>   <span class="pl-c1">0</span>  <span class="pl-c1">5</span>  <span class="pl-c1">10</span>
  <span class="pl-k">-</span><span class="pl-c1">9</span>  <span class="pl-k">-</span><span class="pl-c1">4</span>   <span class="pl-c1">1</span>  <span class="pl-c1">6</span>  <span class="pl-c1">11</span>
  <span class="pl-k">-</span><span class="pl-c1">8</span>  <span class="pl-k">-</span><span class="pl-c1">3</span>   <span class="pl-c1">2</span>  <span class="pl-c1">7</span>  <span class="pl-c1">12</span>

julia<span class="pl-k">&gt;</span> ob <span class="pl-k">=</span> <span class="pl-c1">eachcol</span>(oA);

julia<span class="pl-k">&gt;</span> xs <span class="pl-k">==</span> <span class="pl-c1">tiles</span>(s, oB)
<span class="pl-c1">true</span>

<span class="pl-c"><span class="pl-c">#</span> More than one dimension; this keeps the partition function simple for clarity</span>

julia<span class="pl-k">&gt;</span> r <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">13</span><span class="pl-k">:</span><span class="pl-c1">13</span>
<span class="pl-k">-</span><span class="pl-c1">13</span><span class="pl-k">:</span><span class="pl-c1">13</span>

julia<span class="pl-k">&gt;</span> A <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(r, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>,<span class="pl-c1">3</span>)
<span class="pl-c1">3</span><span class="pl-k">Ã—</span><span class="pl-c1">3</span><span class="pl-k">Ã—</span><span class="pl-c1">3</span> <span class="pl-c1">reshape</span>(<span class="pl-k">::</span><span class="pl-c1">UnitRange{Int64}</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>, <span class="pl-c1">3</span>) with eltype Int64<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-k">-</span><span class="pl-c1">13</span>  <span class="pl-k">-</span><span class="pl-c1">10</span>  <span class="pl-k">-</span><span class="pl-c1">7</span>
 <span class="pl-k">-</span><span class="pl-c1">12</span>   <span class="pl-k">-</span><span class="pl-c1">9</span>  <span class="pl-k">-</span><span class="pl-c1">6</span>
 <span class="pl-k">-</span><span class="pl-c1">11</span>   <span class="pl-k">-</span><span class="pl-c1">8</span>  <span class="pl-k">-</span><span class="pl-c1">5</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-k">-</span><span class="pl-c1">4</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>  <span class="pl-c1">2</span>
 <span class="pl-k">-</span><span class="pl-c1">3</span>   <span class="pl-c1">0</span>  <span class="pl-c1">3</span>
 <span class="pl-k">-</span><span class="pl-c1">2</span>   <span class="pl-c1">1</span>  <span class="pl-c1">4</span>

[:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
 <span class="pl-c1">5</span>   <span class="pl-c1">8</span>  <span class="pl-c1">11</span>
 <span class="pl-c1">6</span>   <span class="pl-c1">9</span>  <span class="pl-c1">12</span>
 <span class="pl-c1">7</span>  <span class="pl-c1">10</span>  <span class="pl-c1">13</span>

julia<span class="pl-k">&gt;</span> B <span class="pl-k">=</span> <span class="pl-c1">eachslice</span>(A, dims<span class="pl-k">=</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>))
<span class="pl-c1">3</span><span class="pl-k">Ã—</span><span class="pl-c1">3</span> Slices{Base<span class="pl-k">.</span>ReshapedArray{Int64, <span class="pl-c1">3</span>, UnitRange{Int64}, Tuple{}}, Tuple{Colon, Int64, Int64}, Tuple{Base<span class="pl-k">.</span>OneTo{Int64}, Base<span class="pl-k">.</span>OneTo{Int64}}, SubArray{Int64, <span class="pl-c1">1</span>, Base<span class="pl-k">.</span>ReshapedArray{Int64, <span class="pl-c1">3</span>, UnitRange{Int64}, Tuple{}}, Tuple{Base<span class="pl-k">.</span>Slice{Base<span class="pl-k">.</span>OneTo{Int64}}, Int64, Int64}, <span class="pl-c1">true</span>}, <span class="pl-c1">2</span>}<span class="pl-k">:</span>
 [<span class="pl-k">-</span><span class="pl-c1">13</span>, <span class="pl-k">-</span><span class="pl-c1">12</span>, <span class="pl-k">-</span><span class="pl-c1">11</span>]  [<span class="pl-k">-</span><span class="pl-c1">4</span>, <span class="pl-k">-</span><span class="pl-c1">3</span>, <span class="pl-k">-</span><span class="pl-c1">2</span>]  [<span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>]
 [<span class="pl-k">-</span><span class="pl-c1">10</span>, <span class="pl-k">-</span><span class="pl-c1">9</span>, <span class="pl-k">-</span><span class="pl-c1">8</span>]    [<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>]    [<span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>]
 [<span class="pl-k">-</span><span class="pl-c1">7</span>, <span class="pl-k">-</span><span class="pl-c1">6</span>, <span class="pl-k">-</span><span class="pl-c1">5</span>]     [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>]     [<span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">13</span>]

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">@scheme</span> sum signbit <span class="pl-k">âˆ˜</span> second;

julia<span class="pl-k">&gt;</span> xs <span class="pl-k">=</span> <span class="pl-c1">tiles</span>(s, B)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, <span class="pl-c1">1</span>}}<span class="pl-k">:</span>
 [<span class="pl-k">-</span><span class="pl-c1">36</span>, <span class="pl-k">-</span><span class="pl-c1">27</span>, <span class="pl-k">-</span><span class="pl-c1">18</span>, <span class="pl-k">-</span><span class="pl-c1">9</span>]
 [<span class="pl-c1">0</span>, <span class="pl-c1">9</span>, <span class="pl-c1">18</span>, <span class="pl-c1">27</span>, <span class="pl-c1">36</span>]

julia<span class="pl-k">&gt;</span> x1, x2 <span class="pl-k">=</span> xs;

julia<span class="pl-k">&gt;</span> x1 <span class="pl-k">==</span> <span class="pl-c1">sum</span>.(B[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>])
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> x2 <span class="pl-k">==</span> <span class="pl-c1">sum</span>.(B[<span class="pl-c1">5</span><span class="pl-k">:</span><span class="pl-c1">9</span>])
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vcat</span>(xs<span class="pl-k">...</span>) <span class="pl-k">==</span> <span class="pl-c1">vec</span>(<span class="pl-c1">sum</span>(A, dims<span class="pl-k">=</span><span class="pl-c1">1</span>))
<span class="pl-c1">true</span>

<span class="pl-c"><span class="pl-c">#</span> And one last example, just for fun</span>

julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">@scheme</span> sum x <span class="pl-k">-&gt;</span> <span class="pl-c1">abs</span>(<span class="pl-c1">sum</span>(x)) <span class="pl-k">&gt;</span> <span class="pl-c1">9</span>;

julia<span class="pl-k">&gt;</span> xs <span class="pl-k">=</span> <span class="pl-c1">tiles</span>(s, B)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Vector{Tile{Vector{Int64}, Int64, Tuple{Bool}, Bool, <span class="pl-c1">1</span>}}<span class="pl-k">:</span>
 [<span class="pl-k">-</span><span class="pl-c1">36</span>, <span class="pl-k">-</span><span class="pl-c1">27</span>, <span class="pl-k">-</span><span class="pl-c1">18</span>]
 [<span class="pl-k">-</span><span class="pl-c1">9</span>, <span class="pl-c1">0</span>, <span class="pl-c1">9</span>]
 [<span class="pl-c1">18</span>, <span class="pl-c1">27</span>, <span class="pl-c1">36</span>]

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getproperty</span>.(xs, <span class="pl-c1">:I</span>)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Vector{Tuple{Bool}}<span class="pl-k">:</span>
 (<span class="pl-c1">1</span>,)
 (<span class="pl-c1">0</span>,)
 (<span class="pl-c1">1</span>,)

julia<span class="pl-k">&gt;</span> x1, x2, x3 <span class="pl-k">=</span> xs;

julia<span class="pl-k">&gt;</span> x1 <span class="pl-k">==</span> <span class="pl-c1">sum</span>.(B[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>])
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> x2 <span class="pl-k">==</span> <span class="pl-c1">sum</span>.(B[<span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">6</span>])
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> x3 <span class="pl-k">==</span> <span class="pl-c1">sum</span>.(B[<span class="pl-c1">7</span><span class="pl-k">:</span><span class="pl-c1">9</span>])
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vcat</span>(xs<span class="pl-k">...</span>) <span class="pl-k">==</span> <span class="pl-c1">vec</span>(<span class="pl-c1">sum</span>(A, dims<span class="pl-k">=</span><span class="pl-c1">1</span>))
<span class="pl-c1">true</span></pre></div>
<p dir="auto"></p>
</details>
<h2 dir="auto"><a id="user-content-limitations" class="anchor" aria-hidden="true" href="#limitations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Limitations</h2>
<p dir="auto">As originally indicated in the Project.toml, this package requires at
least Julia 1.9, which provides an updated <code>eachslice</code> which returns a
type which conforms to the <code>AbstractArray</code> interface.  In Julia 1.8
and older, <code>eachslice</code> returns an iterator, which does not permit
efficient partitioning algorithms; expect the methods in this package
to <code>throw</code> accordingly.</p>
<p dir="auto">Note that while it is <strong>not</strong> supported, it may be feasible in some
circumstances to use this package with Julia 1.8 and older by calling
<code>collect</code> on the iterator returned by <code>eachslice</code>. Lack of support
side, the author does not recommend such a practice due to the
substantial performance degradation it entails.</p>
</article></div>