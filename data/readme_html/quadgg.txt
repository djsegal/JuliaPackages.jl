<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-quadggjl" class="anchor" aria-hidden="true" href="#quadggjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QuadGG.jl</h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/0058ce9713cb93a553c2f23207afbb49b1b852a70a4a24de20e2e816c58b299e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d6f72616e67652e737667"><img src="https://camo.githubusercontent.com/0058ce9713cb93a553c2f23207afbb49b1b852a70a4a24de20e2e816c58b299e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d6f72616e67652e737667" alt="Lifecycle" data-canonical-src="https://img.shields.io/badge/lifecycle-experimental-orange.svg" style="max-width:100%;"></a>
<a href="https://travis-ci.com/tbeason/QuadGG.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/7304dbadc14ede9ca3ccdcfc08ab6d89a04ff3d1e97ed78595958cf1b7aae583/68747470733a2f2f7472617669732d63692e636f6d2f74626561736f6e2f5175616447472e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/tbeason/QuadGG.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="http://codecov.io/github/tbeason/QuadGG.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/3ba1da62d83fef878269d1b2ef32904c4647860b6fadf6bbb98f2c80dd077939/687474703a2f2f636f6465636f762e696f2f6769746875622f74626561736f6e2f5175616447472e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/tbeason/QuadGG.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>

<p><code>QuadGG.jl</code> provides a pure Julia implementation of the MATLAB quadrature routines from Gander &amp; Gautschi (2000) <a href="https://link.springer.com/article/10.1023/A:1022318402393" rel="nofollow">"Adaptive Quadrature -- Revisited"</a>.</p>
<p>The first is an adaptive Gauss-Lobatto method, while the second is an adaptive Simpson's rule. The Gauss-Lobatto routine seems to be the preferred method of the two.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>There are two exported functions: <code>adaptlob</code> for the adaptive Gauss-Lobatto routine and <code>adaptsim</code> for the adaptive Simpson's rule.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using QuadGG

adaptlob(x-&gt;x^2,0,1) #  == 1/3
adaptlob(sqrt,0,1;tol=1e-16) #  == 2/3

adaptsim(x-&gt;x^2,0,1) #  == 1/3
adaptsim(sqrt,0,1;tol=1e-16) #  == 2/3
"><pre><span class="pl-k">using</span> QuadGG

<span class="pl-c1">adaptlob</span>(x<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span>  == 1/3</span>
<span class="pl-c1">adaptlob</span>(sqrt,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>;tol<span class="pl-k">=</span><span class="pl-c1">1e-16</span>) <span class="pl-c"><span class="pl-c">#</span>  == 2/3</span>

<span class="pl-c1">adaptsim</span>(x<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span>  == 1/3</span>
<span class="pl-c1">adaptsim</span>(sqrt,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>;tol<span class="pl-k">=</span><span class="pl-c1">1e-16</span>) <span class="pl-c"><span class="pl-c">#</span>  == 2/3</span></pre></div>
<h2><a id="user-content-alternative-packages" class="anchor" aria-hidden="true" href="#alternative-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternative Packages</h2>
<p>I wrote this package (ported the code is more like it) so that I could take advantage of a particular feature of the problem I was solving. <a href="https://github.com/JuliaMath/QuadGK.jl">QuadGK.jl</a> and <a href="https://github.com/JuliaMath/HCubature.jl">HCubature.jl</a> offer additional features compared to this library and are likely better choices for general numerical integration problems.</p>
<p>The biggest conceptual difference from <code>QuadGK.jl</code> is that the Gauss-Lobatto scheme does evaluate the integral at the interval endpoints and they use different adaptive sampling techniques. The <code>QuadGK.jl</code> methods are very lean, therefore if your integrand is <em>really</em> smooth they can integrate pretty much instantly. This package would use many more function evaluations in those cases. For more difficult integrals, the speed differences between the package are not so great (and sometimes this package is faster).</p>
</article></div>