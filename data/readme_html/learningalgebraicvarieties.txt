<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-learning-algebraic-varieties" class="anchor" aria-hidden="true" href="#learning-algebraic-varieties"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Learning Algebraic Varieties</h1>
<p dir="auto">Welcome to the LearningAlgebraicVarieties package from the article <a href="https://link.springer.com/content/pdf/10.1007/s13163-018-0273-6.pdf" rel="nofollow">Learning Algebraic Varieties from Samples</a> by P. Breiding, S. Kalisnik, B. Sturmfels and M. Weinstein.</p>
<p dir="auto">Special thanks to <a href="http://math.tkk.fi/en/people/venla.valve" rel="nofollow">V. Valve</a> who helped updating the PHCcurve diagrams.</p>
<p dir="auto">To install the package, open a new <code>Julia</code> session and type</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="]add LearningAlgebraicVarieties"><pre>]add LearningAlgebraicVarieties</pre></div>
<p dir="auto">After the installation is completed the command</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LearningAlgebraicVarieties"><pre><span class="pl-k">using</span> LearningAlgebraicVarieties</pre></div>
<p dir="auto">loads all the functions into the current session.</p>
<p dir="auto">All functions accept m data points in ℝ^n or ℙ^(n-1) as an m×n matrix Ω; i.e., as arrays.</p>
<p dir="auto">We provide some datasets in the <a href="https://github.com/JuliaIO/JLD2.jl.git">JLD2</a> data format. Download the <code>datasets.jld2</code> from this repository, navigate to its folder and use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JLD2 # add this packages with ]add JLD2
@load &quot;datasets.jld2&quot;"><pre><span class="pl-k">using</span> JLD2 <span class="pl-c"><span class="pl-c">#</span> add this packages with ]add JLD2</span>
<span class="pl-c1">@load</span> <span class="pl-s"><span class="pl-pds">"</span>datasets.jld2<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">Now, your session should contain a dictionary with name <code>data</code> containing some datasets.</p>
<h2 dir="auto"><a id="user-content-how-to-make-dimension-diagrams" class="anchor" aria-hidden="true" href="#how-to-make-dimension-diagrams"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to make dimension diagrams</h2>
<p dir="auto">Here is an example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="DimensionDiagrams(Ω, true)"><pre><span class="pl-c1">DimensionDiagrams</span>(Ω, <span class="pl-c1">true</span>)</pre></div>
<p dir="auto">plots the all dimension diagrams for the data in projective space. On the other hand,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="DimensionDiagrams(Ω, false, diagrams = [:CorrSum, :BoxCounting], eps_ticks = 10)"><pre><span class="pl-c1">DimensionDiagrams</span>(Ω, <span class="pl-c1">false</span>, diagrams <span class="pl-k">=</span> [<span class="pl-c1">:CorrSum</span>, <span class="pl-c1">:BoxCounting</span>], eps_ticks <span class="pl-k">=</span> <span class="pl-c1">10</span>)</pre></div>
<p dir="auto">plots the dimension diagrams CorrSum and BoxCounting for data in euclidean space. The estimates are computed for 10 values of ϵ between 0 and 1.</p>
<p dir="auto">The complete syntax of the <code>DimensionDiagrams</code> function is as follows.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="DimensionDiagrams(
    Ω::Array{T,2},
    projective::Bool;
    diagrams  = [:CorrSum, :BoxCounting, :NPCA, :MLE, :ANOVA, :PHCurve],
    eps_ticks = 25,
    fontsize = 16,
    lw = 4
    ) where {T &lt;: Number}"><pre><span class="pl-c1">DimensionDiagrams</span>(
    Ω<span class="pl-k">::</span><span class="pl-c1">Array{T,2}</span>,
    projective<span class="pl-k">::</span><span class="pl-c1">Bool</span>;
    diagrams  <span class="pl-k">=</span> [<span class="pl-c1">:CorrSum</span>, <span class="pl-c1">:BoxCounting</span>, <span class="pl-c1">:NPCA</span>, <span class="pl-c1">:MLE</span>, <span class="pl-c1">:ANOVA</span>, <span class="pl-c1">:PHCurve</span>],
    eps_ticks <span class="pl-k">=</span> <span class="pl-c1">25</span>,
    fontsize <span class="pl-k">=</span> <span class="pl-c1">16</span>,
    lw <span class="pl-k">=</span> <span class="pl-c1">4</span>
    ) <span class="pl-k">where</span> {T <span class="pl-k">&lt;:</span> <span class="pl-c1">Number</span>}</pre></div>
<p dir="auto">Here:</p>
<ul dir="auto">
<li><code>Ω</code> is a matrix whose columns are the data points.</li>
<li><code>projective = false</code>: makes diagrams in euclidean space.</li>
<li><code>projective = true</code>: makes diagrams in projective space.
There are some optional arguments.</li>
<li><code>methods</code>: lists the dimension estimators to be plotted.</li>
<li><code>eps_ticks = k</code>: puts k evenly spaced ϵ into [0,1]. At those ϵs the dimensions are computed.</li>
<li><code>fontsize</code>: sets the font size of the axes.</li>
<li><code>lw</code>: sets the line width.</li>
</ul>
<h2 dir="auto"><a id="user-content-how-to-compute-multivariate-vandermonde-matrices" class="anchor" aria-hidden="true" href="#how-to-compute-multivariate-vandermonde-matrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to compute multivariate Vandermonde matrices</h2>
<p dir="auto">Here is an example.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="MultivariateVandermondeMatrix(Ω, 2, true)"><pre><span class="pl-c1">MultivariateVandermondeMatrix</span>(Ω, <span class="pl-c1">2</span>, <span class="pl-c1">true</span>)</pre></div>
<p dir="auto">computes the multivariate Vandermonde matrix for the sample Ω and all monomials of degree  2. The <code>true</code> value determines homogeneous equations. On the other hand, the Vandermonde matrix with all monomials of degree at most 2 is computed by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="MultivariateVandermondeMatrix(Ω, 2, false)"><pre><span class="pl-c1">MultivariateVandermondeMatrix</span>(Ω, <span class="pl-c1">2</span>, <span class="pl-c1">false</span>)</pre></div>
<p dir="auto">It is also possible to define the exponents involved. For example,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="exponents = [[1,0,0], [1,1,1]]
MultivariateVandermondeMatrix(Ω, exponents)"><pre>exponents <span class="pl-k">=</span> [[<span class="pl-c1">1</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>], [<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]]
<span class="pl-c1">MultivariateVandermondeMatrix</span>(Ω, exponents)</pre></div>
<p dir="auto">computes the multivariate Vandermonde matrix for Ω ⊂ ℝ^3 and the monomials <code>x_1</code> and <code>x_1 x_2 x_3</code>.</p>
<p dir="auto">Here is the full syntax</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="MultivariateVandermondeMatrix(Ω::Array{T},
                              d::Int64,
                              homogeneous_equations::Bool)

MultivariateVandermondeMatrix(data::Array{T},
                              exponents::Vector)"><pre><span class="pl-c1">MultivariateVandermondeMatrix</span>(Ω<span class="pl-k">::</span><span class="pl-c1">Array{T}</span>,
                              d<span class="pl-k">::</span><span class="pl-c1">Int64</span>,
                              homogeneous_equations<span class="pl-k">::</span><span class="pl-c1">Bool</span>)

<span class="pl-c1">MultivariateVandermondeMatrix</span>(data<span class="pl-k">::</span><span class="pl-c1">Array{T}</span>,
                              exponents<span class="pl-k">::</span><span class="pl-c1">Vector</span>)</pre></div>
<p dir="auto">where</p>
<ul dir="auto">
<li><code>Ω</code> is a matrix whose colums are the data.</li>
<li><code>d</code> is the degree of the monomials.</li>
<li><code>homogeneous_equations = true</code> restricts the space of monomials to monomials of degree d.</li>
<li><code>homogeneous_equations = false</code> computes all monomials of degree at most d.</li>
<li><code>exponents</code> is an array of exponents vectors.</li>
</ul>
<h2 dir="auto"><a id="user-content-how-to-find-equations" class="anchor" aria-hidden="true" href="#how-to-find-equations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to find equations</h2>
<p dir="auto">Here is an example.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FindEquations(Ω, :with_svd, 2, true)"><pre><span class="pl-c1">FindEquations</span>(Ω, <span class="pl-c1">:with_svd</span>, <span class="pl-c1">2</span>, <span class="pl-c1">true</span>)</pre></div>
<p dir="auto">finds homogeneous equations of degree 2 using SVD to compute the kernel of the Vandermonde matrix, while</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FindEquations(Ω, :with_qr, 3, false)"><pre><span class="pl-c1">FindEquations</span>(Ω, <span class="pl-c1">:with_qr</span>, <span class="pl-c1">3</span>, <span class="pl-c1">false</span>)</pre></div>
<p dir="auto">finds all polynomials of degree at most 3 and uses QR to compute the kernel of the Vandermonde matrix.</p>
<p dir="auto">To find all equations with support <code>x_1 x_2</code> and <code>x_1^2</code> using the reduced row echelon form to compute the kernel, type</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="exponents = [[1,1], [2,0]]
FindEquations(Ω, :with_rref, exponents)"><pre>exponents <span class="pl-k">=</span> [[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>], [<span class="pl-c1">2</span>,<span class="pl-c1">0</span>]]
<span class="pl-c1">FindEquations</span>(Ω, <span class="pl-c1">:with_rref</span>, exponents)</pre></div>
<p dir="auto">A multivariate Vandermonde matrix  may be passed to FindEquations:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="M = MultivariateVandermondeMatrix(Ω, 2, false)
FindEquations(M, :with_svd, τ)"><pre>M <span class="pl-k">=</span> <span class="pl-c1">MultivariateVandermondeMatrix</span>(Ω, <span class="pl-c1">2</span>, <span class="pl-c1">false</span>)
<span class="pl-c1">FindEquations</span>(M, <span class="pl-c1">:with_svd</span>, τ)</pre></div>
<p dir="auto">where τ is a tolerance value.</p>
<p dir="auto">The full syntax of <code>FindEquations</code> is as follows.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FindEquations(Ω::Array{T,2},
              alg::Symbol,
              d::Int64,
              homogeneous_equations::Bool)
              where  {T&lt;:Number}

FindEquations(Ω::Array{T,2},
              alg::Symbol,
              exponents::Array{Array{Int64,1},1})
              where  {T&lt;:Number}

FindEquations(M::MultivariateVandermondeMatrix,
              alg::Symbol,
              τ::Float64)"><pre><span class="pl-c1">FindEquations</span>(Ω<span class="pl-k">::</span><span class="pl-c1">Array{T,2}</span>,
              alg<span class="pl-k">::</span><span class="pl-c1">Symbol</span>,
              d<span class="pl-k">::</span><span class="pl-c1">Int64</span>,
              homogeneous_equations<span class="pl-k">::</span><span class="pl-c1">Bool</span>)
              <span class="pl-k">where</span>  {T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>}

<span class="pl-c1">FindEquations</span>(Ω<span class="pl-k">::</span><span class="pl-c1">Array{T,2}</span>,
              alg<span class="pl-k">::</span><span class="pl-c1">Symbol</span>,
              exponents<span class="pl-k">::</span><span class="pl-c1">Array{Array{Int64,1},1}</span>)
              <span class="pl-k">where</span>  {T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>}

<span class="pl-c1">FindEquations</span>(M<span class="pl-k">::</span><span class="pl-c1">MultivariateVandermondeMatrix</span>,
              alg<span class="pl-k">::</span><span class="pl-c1">Symbol</span>,
              τ<span class="pl-k">::</span><span class="pl-c1">Float64</span>)</pre></div>
<p dir="auto">Here:</p>
<ul dir="auto">
<li><code>Ω</code> is a matrix whose colums are the data points.</li>
<li><code>alg</code> is the algorithm that should be used (one of <code>:with_svd</code>, <code>:with_qr</code>, <code>:with_rref</code>).</li>
<li><code>d</code> is the degree of the equations.</li>
<li><code>homogeneous_equations = true</code> restricts the search space to homogeneous polynomials.</li>
<li><code>homogeneous_equations = false</code> computes all polynomials of degree at most d.</li>
<li><code>exponents</code> is an array of exponent vectors.</li>
<li><code>τ</code> is the tolerance value.</li>
</ul>
<h2 dir="auto"><a id="user-content-distances" class="anchor" aria-hidden="true" href="#distances"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Distances</h2>
<p dir="auto">Computing distances is a key aspect in both dimension estimation and persistent homology. Here are the functions with which we compute distances.</p>
<p dir="auto">To compute the scaled Fubini Study distances between the data points in Ω type</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ScaledEuclidean(Ω)"><pre><span class="pl-c1">ScaledEuclidean</span>(Ω)</pre></div>
<p dir="auto">On the other hand,to compute the scaled Fubini Study distances between the data points in Ω type</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ScaledFubiniStudy(Ω)"><pre><span class="pl-c1">ScaledFubiniStudy</span>(Ω)</pre></div>
<p dir="auto">Finally, the ellipsoid-driven complex is encoded in a distance matrix. It is computed by typing</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="EllipsoidDistances(Ω, f, λ)"><pre><span class="pl-c1">EllipsoidDistances</span>(Ω, f, λ)</pre></div>
<p dir="auto">where <code>f</code> is a vector of polynomials of the type provided by <a href="https://github.com/JuliaAlgebra/DynamicPolynomials.jl">DynamicPolynomials.jl</a> and λ sets the ratio between the principal axes of the ellipsoids</p>
</article></div>