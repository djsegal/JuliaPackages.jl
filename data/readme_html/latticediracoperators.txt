<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-latticediracoperators" class="anchor" aria-hidden="true" href="#latticediracoperators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LatticeDiracOperators</h1>
<p dir="auto"><a href="https://akio-tomiya.github.io/LatticeDiracOperators.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/akio-tomiya/LatticeDiracOperators.jl/actions/workflows/CI.yml"><img src="https://github.com/akio-tomiya/LatticeDiracOperators.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-abstract" class="anchor" aria-hidden="true" href="#abstract"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Abstract</h1>
<p dir="auto">This is a package for lattice QCD codes.
Treating pseudo-femrion fields with various lattice Dirac operators, fermion actions with MPI.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="LQCDjl_block.png"><img src="LQCDjl_block.png" width="300" style="max-width: 100%;"></a></p> 
<p dir="auto">This package will be used in <a href="https://github.com/akio-tomiya/LatticeQCD.jl">LatticeQCD.jl</a>.</p>
<h1 dir="auto"><a id="user-content-what-this-package-can-do" class="anchor" aria-hidden="true" href="#what-this-package-can-do"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What this package can do:</h1>
<ul dir="auto">
<li>Constructing actions and its derivative for Staggered Fermion with 1-8 tastes (with the use of the rational HMC technique)</li>
<li>Constructing actions and its derivative for Wilson Fermion</li>
<li>(EXPERIMENTAL) Constructing actions and its derivative for Standard Domainwall Fermion</li>
<li>Hybrid Monte Carlo method with fermions.</li>
</ul>
<p dir="auto">With the use of the Gaugefields.jl, we can also do the HMC with STOUT smearing.</p>
<p dir="auto">This package will be used in LatticeQCD.jl.
This package uses <a href="https://github.com/akio-tomiya/Gaugefields.jl">Gaugefields.jl</a>.
This package can be regarded as the additional package of the Gaugefields.jl to treat with Lattice fermions (pseudo- fermions).</p>
<h1 dir="auto"><a id="user-content-install" class="anchor" aria-hidden="true" href="#install"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Install</h1>
<p dir="auto">In the package mode, Julia REPL,</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add LatticeDiracOperators"><pre class="notranslate"><code>add LatticeDiracOperators
</code></pre></div>
<h1 dir="auto"><a id="user-content-how-to-use" class="anchor" aria-hidden="true" href="#how-to-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use</h1>
<h2 dir="auto"><a id="user-content-definition-of-the-pseudo-fermion-fields" class="anchor" aria-hidden="true" href="#definition-of-the-pseudo-fermion-fields"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Definition of the pseudo-fermion fields</h2>
<p dir="auto">The pseudo-fermin field is defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields
using LatticeDiracOperators

NX = 4
NY = 4
NZ = 4
NT = 4
Nwing = 1
Dim = 4
NC = 3

U = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)
x = Initialize_pseudofermion_fields(U[1],&quot;Wilson&quot;)"><pre><span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LatticeDiracOperators

NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

U <span class="pl-k">=</span> <span class="pl-c1">Initialize_4DGaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)
x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Now, x is a pseudo fermion fields for Wilson Dirac operator.
The element of x is <code>x[ic,ix,iy,iz,it,ialpha]</code>. ic is an index of the color. ialpha is the internal degree of the gamma matrix.</p>
<p dir="auto">Then, the Wilson Dirac operator can be defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="params = Dict()
params[&quot;Dirac_operator&quot;] = &quot;Wilson&quot;
params[&quot;κ&quot;] = 0.141139
params[&quot;eps_CG&quot;] = 1.0e-8
params[&quot;verbose_level&quot;] = 2

D = Dirac_operator(U,x,params)"><pre>params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>
params[<span class="pl-s"><span class="pl-pds">"</span>κ<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.141139</span>
params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-8</span>
params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>

D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)</pre></div>
<p dir="auto">If you want to get the Gaussian distributed pseudo-fermions, just do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="gauss_distribution_fermion!(x)"><pre><span class="pl-c1">gauss_distribution_fermion!</span>(x)</pre></div>
<p dir="auto">Then, you can apply the Dirac operator to the pseudo-fermion fields.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra
y = similar(x)
mul!(y,D,x)"><pre><span class="pl-k">using</span> LinearAlgebra
y <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)
<span class="pl-c1">mul!</span>(y,D,x)</pre></div>
<p dir="auto">And you can solve the equation <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="261632248ca0f2cf3c623819b51c427f">$D x = b$</math-renderer> like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="solve_DinvX!(y,D,x)
println(y[1,1,1,1,1,1])"><pre><span class="pl-c1">solve_DinvX!</span>(y,D,x)
<span class="pl-c1">println</span>(y[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])</pre></div>
<p dir="auto">If you want to see the convergence of the CG method, you can change the "verbose_level" in the Dirac operator.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="params[&quot;verbose_level&quot;] = 3
D = Dirac_operator(U,x,params)
gauss_distribution_fermion!(x)
solve_DinvX!(y,D,x)
println(y[1,1,1,1,1,1])"><pre>params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">3</span>
D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)
<span class="pl-c1">gauss_distribution_fermion!</span>(x)
<span class="pl-c1">solve_DinvX!</span>(y,D,x)
<span class="pl-c1">println</span>(y[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])</pre></div>
<p dir="auto">The output is like</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="bicg method
1-th eps: 1742.5253056262081
2-th eps: 758.2899742222573
3-th eps: 378.7020470573924
4-th eps: 210.17029515182503
5-th eps: 118.00493128655506
6-th eps: 63.31719669150997
7-th eps: 36.18603541453448
8-th eps: 21.593691953496077
9-th eps: 16.02895509383768
10-th eps: 12.920647360667004
11-th eps: 9.532250164198402
12-th eps: 5.708202470516758
13-th eps: 3.1711913019834337
14-th eps: 0.9672090407947617
15-th eps: 0.14579004932559966
16-th eps: 0.02467506197970277
17-th eps: 0.005588563782732157
18-th eps: 0.002285284357387675
19-th eps: 5.147142014626153e-5
20-th eps: 3.5632092739322066e-10
Converged at 20-th step. eps: 3.5632092739322066e-10"><pre class="notranslate"><code>bicg method
1-th eps: 1742.5253056262081
2-th eps: 758.2899742222573
3-th eps: 378.7020470573924
4-th eps: 210.17029515182503
5-th eps: 118.00493128655506
6-th eps: 63.31719669150997
7-th eps: 36.18603541453448
8-th eps: 21.593691953496077
9-th eps: 16.02895509383768
10-th eps: 12.920647360667004
11-th eps: 9.532250164198402
12-th eps: 5.708202470516758
13-th eps: 3.1711913019834337
14-th eps: 0.9672090407947617
15-th eps: 0.14579004932559966
16-th eps: 0.02467506197970277
17-th eps: 0.005588563782732157
18-th eps: 0.002285284357387675
19-th eps: 5.147142014626153e-5
20-th eps: 3.5632092739322066e-10
Converged at 20-th step. eps: 3.5632092739322066e-10
</code></pre></div>
<h2 dir="auto">
<a id="user-content-other-operators" class="anchor" aria-hidden="true" href="#other-operators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Other operators</h2>
<p dir="auto">You can use the adjoint of the Dirac operator</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="gauss_distribution_fermion!(x)
solve_DinvX!(y,D',x)
println(y[1,1,1,1,1,1])"><pre><span class="pl-c1">gauss_distribution_fermion!</span>(x)
<span class="pl-c1">solve_DinvX!</span>(y,D<span class="pl-k">'</span>,x)
<span class="pl-c1">println</span>(y[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])</pre></div>
<p dir="auto">You can define the <code>D^{\dagger} D</code> operator.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="DdagD = DdagD_operator(U,x,params)
gauss_distribution_fermion!(x)
solve_DinvX!(y,DdagD,x) 
println(y[1,1,1,1,1,1])"><pre>DdagD <span class="pl-k">=</span> <span class="pl-c1">DdagD_operator</span>(U,x,params)
<span class="pl-c1">gauss_distribution_fermion!</span>(x)
<span class="pl-c1">solve_DinvX!</span>(y,DdagD,x) 
<span class="pl-c1">println</span>(y[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])</pre></div>
<h1 dir="auto">
<a id="user-content-staggared-fermions" class="anchor" aria-hidden="true" href="#staggared-fermions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Staggared Fermions</h1>
<p dir="auto">The Dirac operator of the staggered fermions is defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = Initialize_pseudofermion_fields(U[1],&quot;staggered&quot;)
gauss_distribution_fermion!(x)
params = Dict()
params[&quot;Dirac_operator&quot;] = &quot;staggered&quot;
params[&quot;mass&quot;] = 0.1
params[&quot;eps_CG&quot;] = 1.0e-8
params[&quot;verbose_level&quot;] = 2
D = Dirac_operator(U,x,params)

y = similar(x)
mul!(y,D,x)
println(y[1,1,1,1,1,1])

solve_DinvX!(y,D,x)
println(y[1,1,1,1,1,1])"><pre>x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>staggered<span class="pl-pds">"</span></span>)
<span class="pl-c1">gauss_distribution_fermion!</span>(x)
params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>staggered<span class="pl-pds">"</span></span>
params[<span class="pl-s"><span class="pl-pds">"</span>mass<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.1</span>
params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-8</span>
params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>
D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)

y <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)
<span class="pl-c1">mul!</span>(y,D,x)
<span class="pl-c1">println</span>(y[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])

<span class="pl-c1">solve_DinvX!</span>(y,D,x)
<span class="pl-c1">println</span>(y[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])</pre></div>
<p dir="auto">The "tastes" of the Staggered Fermion is defined in the action.</p>
<h1 dir="auto">
<a id="user-content-experimental-domainwall-fermions" class="anchor" aria-hidden="true" href="#experimental-domainwall-fermions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>(EXPERIMENTAL) Domainwall Fermions</h1>
<p dir="auto">This package supports standard domainwall fermions.
The Dirac operator of the domainwall fermion is defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="L5 = 4
x = Initialize_pseudofermion_fields(U[1],&quot;Domainwall&quot;,L5=L5)
println(&quot;x &quot;, x.w[1][1,1,1,1,1,1])
gauss_distribution_fermion!(x)

params = Dict()
params[&quot;Dirac_operator&quot;] = &quot;Domainwall&quot;
params[&quot;eps_CG&quot;] = 1.0e-16
params[&quot;MaxCGstep&quot;] = 3000
params[&quot;verbose_level&quot;] = 3
params[&quot;mass&quot;] = 0.1
params[&quot;L5&quot;] = L5
D = Dirac_operator(U,x,params)

println(&quot;x &quot;, x[1,1,1,1,1,1,1])
y = similar(x)
solve_DinvX!(y,D,x)
println(&quot;y &quot;, y[1,1,1,1,1,1,1])

z = similar(x)
mul!(z,D,y)
println(&quot;z &quot;, z[1,1,1,1,1,1,1])
"><pre>L5 <span class="pl-k">=</span> <span class="pl-c1">4</span>
x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>Domainwall<span class="pl-pds">"</span></span>,L5<span class="pl-k">=</span>L5)
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>x <span class="pl-pds">"</span></span>, x<span class="pl-k">.</span>w[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])
<span class="pl-c1">gauss_distribution_fermion!</span>(x)

params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Domainwall<span class="pl-pds">"</span></span>
params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-16</span>
params[<span class="pl-s"><span class="pl-pds">"</span>MaxCGstep<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">3000</span>
params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">3</span>
params[<span class="pl-s"><span class="pl-pds">"</span>mass<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.1</span>
params[<span class="pl-s"><span class="pl-pds">"</span>L5<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> L5
D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)

<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>x <span class="pl-pds">"</span></span>, x[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])
y <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)
<span class="pl-c1">solve_DinvX!</span>(y,D,x)
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>y <span class="pl-pds">"</span></span>, y[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])

z <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)
<span class="pl-c1">mul!</span>(z,D,y)
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>z <span class="pl-pds">"</span></span>, z[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])
</pre></div>
<p dir="auto">The domainwall fermion is defined in 5D space. The element of x is <code>x[ic,ix,iy,iz,it,ialpha,iL]</code>, where iL is an index on the five dimensional axis.</p>
<h1 dir="auto">
<a id="user-content-fermion-action" class="anchor" aria-hidden="true" href="#fermion-action"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Fermion Action</h1>
<h2 dir="auto">
<a id="user-content-wilson-fermion" class="anchor" aria-hidden="true" href="#wilson-fermion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Wilson Fermion</h2>
<p dir="auto">The action for pseudo-fermion is defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
NX = 4
NY = 4
NZ = 4
NT = 4
Nwing = 1
Dim = 4
NC = 3

U = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)
x = Initialize_pseudofermion_fields(U[1],&quot;Wilson&quot;)
gauss_distribution_fermion!(x)

params = Dict()
params[&quot;Dirac_operator&quot;] = &quot;Wilson&quot;
params[&quot;κ&quot;] = 0.141139
params[&quot;eps_CG&quot;] = 1.0e-8
params[&quot;verbose_level&quot;] = 2

D = Dirac_operator(U,x,params)

parameters_action = Dict()
fermi_action = FermiAction(D,parameters_action)

"><pre>NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

U <span class="pl-k">=</span> <span class="pl-c1">Initialize_4DGaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)
x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>)
<span class="pl-c1">gauss_distribution_fermion!</span>(x)

params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>
params[<span class="pl-s"><span class="pl-pds">"</span>κ<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.141139</span>
params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-8</span>
params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>

D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)

parameters_action <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
fermi_action <span class="pl-k">=</span> <span class="pl-c1">FermiAction</span>(D,parameters_action)

</pre></div>
<p dir="auto">The fermion action with given pseudo-fermion fields is evaluated as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Sfnew = evaluate_FermiAction(fermi_action,U,x)
println(Sfnew)"><pre>Sfnew <span class="pl-k">=</span> <span class="pl-c1">evaluate_FermiAction</span>(fermi_action,U,x)
<span class="pl-c1">println</span>(Sfnew)</pre></div>
<p dir="auto">The derivative of the fermion action dSf/dU can be calculated as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="UdSfdUμ = calc_UdSfdU(fermi_action,U,x)"><pre>UdSfdUμ <span class="pl-k">=</span> <span class="pl-c1">calc_UdSfdU</span>(fermi_action,U,x)</pre></div>
<p dir="auto">The function calc_UdSfdU calculates the <code>U dSf/dU</code>,
You can also use <code>calc_UdSfdU!(UdSfdUμ,fermi_action,U,x)</code></p>
<h2 dir="auto">
<a id="user-content-staggered-fermion" class="anchor" aria-hidden="true" href="#staggered-fermion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Staggered Fermion</h2>
<p dir="auto">In the case of the Staggered fermion, we can choose "taste".
The action is defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = Initialize_pseudofermion_fields(U[1],&quot;staggered&quot;)
gauss_distribution_fermion!(x)
params = Dict()
params[&quot;Dirac_operator&quot;] = &quot;staggered&quot;
params[&quot;mass&quot;] = 0.1
params[&quot;eps_CG&quot;] = 1.0e-8
params[&quot;verbose_level&quot;] = 2
D = Dirac_operator(U,x,params)

Nf = 2

println(&quot;Nf = $Nf&quot;)
parameters_action = Dict()
parameters_action[&quot;Nf&quot;] = Nf
fermi_action = FermiAction(D,parameters_action)

Sfnew = evaluate_FermiAction(fermi_action,U,x)
println(Sfnew)

UdSfdUμ = calc_UdSfdU(fermi_action,U,x)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>staggered<span class="pl-pds">"</span></span>)
<span class="pl-c1">gauss_distribution_fermion!</span>(x)
params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>staggered<span class="pl-pds">"</span></span>
params[<span class="pl-s"><span class="pl-pds">"</span>mass<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.1</span>
params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-8</span>
params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>
D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)

Nf <span class="pl-k">=</span> <span class="pl-c1">2</span>

<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Nf = <span class="pl-v">$Nf</span><span class="pl-pds">"</span></span>)
parameters_action <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
parameters_action[<span class="pl-s"><span class="pl-pds">"</span>Nf<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> Nf
fermi_action <span class="pl-k">=</span> <span class="pl-c1">FermiAction</span>(D,parameters_action)

Sfnew <span class="pl-k">=</span> <span class="pl-c1">evaluate_FermiAction</span>(fermi_action,U,x)
<span class="pl-c1">println</span>(Sfnew)

UdSfdUμ <span class="pl-k">=</span> <span class="pl-c1">calc_UdSfdU</span>(fermi_action,U,x)</pre></div>
<p dir="auto">This package uses the RHMC techniques.</p>
<h2 dir="auto">
<a id="user-content-experimental-domainwall-fermions-1" class="anchor" aria-hidden="true" href="#experimental-domainwall-fermions-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>(EXPERIMENTAL) Domainwall Fermions</h2>
<p dir="auto">In the case of the domainwall fermion, the action is defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content=" L5 = 4
x = Initialize_pseudofermion_fields(U[1],&quot;Domainwall&quot;,L5 = L5)
gauss_distribution_fermion!(x)

params = Dict()
params[&quot;Dirac_operator&quot;] = &quot;Domainwall&quot;
params[&quot;mass&quot;] = 0.1
params[&quot;L5&quot;] = L5
params[&quot;eps_CG&quot;] = 1.0e-19
params[&quot;verbose_level&quot;] = 2
params[&quot;method_CG&quot;] = &quot;bicg&quot;
D = Dirac_operator(U,x,params)

parameters_action = Dict()
fermi_action = FermiAction(D,parameters_action)

Sfnew = evaluate_FermiAction(fermi_action,U,x)
println(Sfnew)

UdSfdUμ = calc_UdSfdU(fermi_action,U,x)"><pre> L5 <span class="pl-k">=</span> <span class="pl-c1">4</span>
x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>Domainwall<span class="pl-pds">"</span></span>,L5 <span class="pl-k">=</span> L5)
<span class="pl-c1">gauss_distribution_fermion!</span>(x)

params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Domainwall<span class="pl-pds">"</span></span>
params[<span class="pl-s"><span class="pl-pds">"</span>mass<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.1</span>
params[<span class="pl-s"><span class="pl-pds">"</span>L5<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> L5
params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-19</span>
params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>
params[<span class="pl-s"><span class="pl-pds">"</span>method_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bicg<span class="pl-pds">"</span></span>
D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)

parameters_action <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
fermi_action <span class="pl-k">=</span> <span class="pl-c1">FermiAction</span>(D,parameters_action)

Sfnew <span class="pl-k">=</span> <span class="pl-c1">evaluate_FermiAction</span>(fermi_action,U,x)
<span class="pl-c1">println</span>(Sfnew)

UdSfdUμ <span class="pl-k">=</span> <span class="pl-c1">calc_UdSfdU</span>(fermi_action,U,x)</pre></div>
<h1 dir="auto">
<a id="user-content-hybrid-monte-carlo-with-fermions" class="anchor" aria-hidden="true" href="#hybrid-monte-carlo-with-fermions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hybrid Monte Carlo with fermions</h1>
<h2 dir="auto">
<a id="user-content-wilson-fermion-1" class="anchor" aria-hidden="true" href="#wilson-fermion-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Wilson Fermion</h2>
<p dir="auto">We show the HMC code with this package.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields
using LatticeDiracOperators
using LinearAlgebra
using InteractiveUtils
using Random

function MDtest!(gauge_action,U,Dim,fermi_action,η,ξ)
    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. 
    Uold = similar(U)
    substitute_U!(Uold,U)
    MDsteps = 10
    temp1 = similar(U[1])
    temp2 = similar(U[1])
    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    numaccepted = 0
    Random.seed!(123)

    numtrj = 10
    for itrj = 1:numtrj
        @time accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,fermi_action,η,ξ)
        numaccepted += ifelse(accepted,1,0)

        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        println(&quot;$itrj plaq_t = $plaq_t&quot;)
        println(&quot;acceptance ratio &quot;,numaccepted/itrj)
    end
end

function calc_action(gauge_action,U,p)
    NC = U[1].NC
    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))
    Sp = p*p/2
    S = Sp + Sg
    return real(S)
end


function MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,fermi_action,η,ξ)
    Δτ = 1/MDsteps
    NC,_,NN... = size(U[1])
    
    gauss_distribution!(p)
    
    substitute_U!(Uold,U)
    gauss_sampling_in_action!(ξ,U,fermi_action)
    sample_pseudofermions!(η,U,fermi_action,ξ)
    Sfold = real(dot(ξ,ξ))
    println(&quot;Sfold = $Sfold&quot;)

    Sold = calc_action(gauge_action,U,p) + Sfold
    println(&quot;Sold = &quot;,Sold)

    for itrj=1:MDsteps
        U_update!(U,p,0.5,Δτ,Dim,gauge_action)

        P_update!(U,p,1.0,Δτ,Dim,gauge_action)
        P_update_fermion!(U,p,1.0,Δτ,Dim,gauge_action,fermi_action,η)

        U_update!(U,p,0.5,Δτ,Dim,gauge_action)
    end
    Sfnew = evaluate_FermiAction(fermi_action,U,η)
    println(&quot;Sfnew = $Sfnew&quot;)
    Snew = calc_action(gauge_action,U,p) + Sfnew
    
    println(&quot;Sold = $Sold, Snew = $Snew&quot;)
    println(&quot;Snew - Sold = $(Snew-Sold)&quot;)

    accept = exp(Sold - Snew) &gt;= rand()

    #ratio = min(1,exp(Snew-Sold))
    if accept != true #rand() &gt; ratio
        substitute_U!(U,Uold)
        return false
    else
        return true
    end
end

function U_update!(U,p,ϵ,Δτ,Dim,gauge_action)
    temps = get_temporary_gaugefields(gauge_action)
    temp1 = temps[1]
    temp2 = temps[2]
    expU = temps[3]
    W = temps[4]

    for μ=1:Dim
        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])
        mul!(W,expU,U[μ])
        substitute_U!(U[μ],W)
        
    end
end

function P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -&gt; p +factor*U*dSdUμ
    NC = U[1].NC
    temps = get_temporary_gaugefields(gauge_action)
    dSdUμ = temps[end]
    factor =  -ϵ*Δτ/(NC)

    for μ=1:Dim
        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)
        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ
        Traceless_antihermitian_add!(p[μ],factor,temps[1])
    end
end

function P_update_fermion!(U,p,ϵ,Δτ,Dim,gauge_action,fermi_action,η)  # p -&gt; p +factor*U*dSdUμ
    #NC = U[1].NC
    temps = get_temporary_gaugefields(gauge_action)
    UdSfdUμ = temps[1:Dim]
    factor =  -ϵ*Δτ

    calc_UdSfdU!(UdSfdUμ,fermi_action,U,η)

    for μ=1:Dim
        Traceless_antihermitian_add!(p[μ],factor,UdSfdUμ[μ])
        #println(&quot; p[μ] = &quot;, p[μ][1,1,1,1,1])
    end
end

function test1()
    NX = 4
    NY = 4
    NZ = 4
    NT = 4
    Nwing = 1
    Dim = 4
    NC = 3

    U = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)

    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop')
    β = 5.5/2
    push!(gauge_action,β,plaqloop)
    
    show(gauge_action)

    x = Initialize_pseudofermion_fields(U[1],&quot;Wilson&quot;)


    params = Dict()
    params[&quot;Dirac_operator&quot;] = &quot;Wilson&quot;
    params[&quot;κ&quot;] = 0.141139
    params[&quot;eps_CG&quot;] = 1.0e-8
    params[&quot;verbose_level&quot;] = 2
    D = Dirac_operator(U,x,params)


    parameters_action = Dict()
    fermi_action = FermiAction(D,parameters_action)

    y = similar(x)

    
    MDtest!(gauge_action,U,Dim,fermi_action,x,y)

end


test1()"><pre><span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LatticeDiracOperators
<span class="pl-k">using</span> LinearAlgebra
<span class="pl-k">using</span> InteractiveUtils
<span class="pl-k">using</span> Random

<span class="pl-k">function</span> <span class="pl-en">MDtest!</span>(gauge_action,U,Dim,fermi_action,η,ξ)
    p <span class="pl-k">=</span> <span class="pl-c1">initialize_TA_Gaugefields</span>(U) <span class="pl-c"><span class="pl-c">#</span>This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. </span>
    Uold <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    <span class="pl-c1">substitute_U!</span>(Uold,U)
    MDsteps <span class="pl-k">=</span> <span class="pl-c1">10</span>
    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    numaccepted <span class="pl-k">=</span> <span class="pl-c1">0</span>
    Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">123</span>)

    numtrj <span class="pl-k">=</span> <span class="pl-c1">10</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numtrj
        <span class="pl-c1">@time</span> accepted <span class="pl-k">=</span> <span class="pl-c1">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold,fermi_action,η,ξ)
        numaccepted <span class="pl-k">+=</span> <span class="pl-c1">ifelse</span>(accepted,<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)

        plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>acceptance ratio <span class="pl-pds">"</span></span>,numaccepted<span class="pl-k">/</span>itrj)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">calc_action</span>(gauge_action,U,p)
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    Sg <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">evaluate_GaugeAction</span>(gauge_action,U)<span class="pl-k">/</span>NC <span class="pl-c"><span class="pl-c">#</span>evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))</span>
    Sp <span class="pl-k">=</span> p<span class="pl-k">*</span>p<span class="pl-k">/</span><span class="pl-c1">2</span>
    S <span class="pl-k">=</span> Sp <span class="pl-k">+</span> Sg
    <span class="pl-k">return</span> <span class="pl-c1">real</span>(S)
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold,fermi_action,η,ξ)
    Δτ <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>MDsteps
    NC,_,NN<span class="pl-k">...</span> <span class="pl-k">=</span> <span class="pl-c1">size</span>(U[<span class="pl-c1">1</span>])
    
    <span class="pl-c1">gauss_distribution!</span>(p)
    
    <span class="pl-c1">substitute_U!</span>(Uold,U)
    <span class="pl-c1">gauss_sampling_in_action!</span>(ξ,U,fermi_action)
    <span class="pl-c1">sample_pseudofermions!</span>(η,U,fermi_action,ξ)
    Sfold <span class="pl-k">=</span> <span class="pl-c1">real</span>(<span class="pl-c1">dot</span>(ξ,ξ))
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sfold = <span class="pl-v">$Sfold</span><span class="pl-pds">"</span></span>)

    Sold <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p) <span class="pl-k">+</span> Sfold
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-pds">"</span></span>,Sold)

    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>MDsteps
        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">P_update!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action)
        <span class="pl-c1">P_update_fermion!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action,fermi_action,η)

        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)
    <span class="pl-k">end</span>
    Sfnew <span class="pl-k">=</span> <span class="pl-c1">evaluate_FermiAction</span>(fermi_action,U,η)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sfnew = <span class="pl-v">$Sfnew</span><span class="pl-pds">"</span></span>)
    Snew <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p) <span class="pl-k">+</span> Sfnew
    
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-v">$Sold</span>, Snew = <span class="pl-v">$Snew</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Snew - Sold = <span class="pl-v">$(Snew<span class="pl-k">-</span>Sold)</span><span class="pl-pds">"</span></span>)

    accept <span class="pl-k">=</span> <span class="pl-c1">exp</span>(Sold <span class="pl-k">-</span> Snew) <span class="pl-k">&gt;=</span> <span class="pl-c1">rand</span>()

    <span class="pl-c"><span class="pl-c">#</span>ratio = min(1,exp(Snew-Sold))</span>
    <span class="pl-k">if</span> accept <span class="pl-k">!=</span> <span class="pl-c1">true</span> <span class="pl-c"><span class="pl-c">#</span>rand() &gt; ratio</span>
        <span class="pl-c1">substitute_U!</span>(U,Uold)
        <span class="pl-k">return</span> <span class="pl-c1">false</span>
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">U_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action)
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    expU <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    W <span class="pl-k">=</span> temps[<span class="pl-c1">4</span>]

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">exptU!</span>(expU,ϵ<span class="pl-k">*</span>Δτ,p[μ],[temp1,temp2])
        <span class="pl-c1">mul!</span>(W,expU,U[μ])
        <span class="pl-c1">substitute_U!</span>(U[μ],W)
        
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">P_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action) <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    dSdUμ <span class="pl-k">=</span> temps[<span class="pl-c1">end</span>]
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ<span class="pl-k">/</span>(NC)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">calc_dSdUμ!</span>(dSdUμ,gauge_action,μ,U)
        <span class="pl-c1">mul!</span>(temps[<span class="pl-c1">1</span>],U[μ],dSdUμ) <span class="pl-c"><span class="pl-c">#</span> U*dSdUμ</span>
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,temps[<span class="pl-c1">1</span>])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">P_update_fermion!</span>(U,p,ϵ,Δτ,Dim,gauge_action,fermi_action,η)  <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    <span class="pl-c"><span class="pl-c">#</span>NC = U[1].NC</span>
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    UdSfdUμ <span class="pl-k">=</span> temps[<span class="pl-c1">1</span><span class="pl-k">:</span>Dim]
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ

    <span class="pl-c1">calc_UdSfdU!</span>(UdSfdUμ,fermi_action,U,η)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,UdSfdUμ[μ])
        <span class="pl-c"><span class="pl-c">#</span>println(" p[μ] = ", p[μ][1,1,1,1,1])</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">test1</span>()
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_4DGaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)

    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)
    β <span class="pl-k">=</span> <span class="pl-c1">5.5</span><span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)
    
    <span class="pl-c1">show</span>(gauge_action)

    x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>)


    params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
    params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>
    params[<span class="pl-s"><span class="pl-pds">"</span>κ<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.141139</span>
    params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-8</span>
    params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>
    D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)


    parameters_action <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
    fermi_action <span class="pl-k">=</span> <span class="pl-c1">FermiAction</span>(D,parameters_action)

    y <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)

    
    <span class="pl-c1">MDtest!</span>(gauge_action,U,Dim,fermi_action,x,y)

<span class="pl-k">end</span>


<span class="pl-c1">test1</span>()</pre></div>
<h2 dir="auto">
<a id="user-content-staggered-fermion-1" class="anchor" aria-hidden="true" href="#staggered-fermion-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Staggered Fermion</h2>
<p dir="auto">if you want to use the Staggered fermions in HMC, the code is like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function test2()
    NX = 4
    NY = 4
    NZ = 4
    NT = 4
    Nwing = 1
    Dim = 4
    NC = 3

    U = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)

    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop')
    β = 5.5/2
    push!(gauge_action,β,plaqloop)
    
    show(gauge_action)

    x = Initialize_pseudofermion_fields(U[1],&quot;staggered&quot;)
    gauss_distribution_fermion!(x)
    params = Dict()
    params[&quot;Dirac_operator&quot;] = &quot;staggered&quot;
    params[&quot;mass&quot;] = 0.1
    params[&quot;eps_CG&quot;] = 1.0e-8
    params[&quot;verbose_level&quot;] = 2
    D = Dirac_operator(U,x,params)
    
    Nf = 2
    
    println(&quot;Nf = $Nf&quot;)
    parameters_action = Dict()
    parameters_action[&quot;Nf&quot;] = Nf
    fermi_action = FermiAction(D,parameters_action)

    y = similar(x)

    
    MDtest!(gauge_action,U,Dim,fermi_action,x,y)

end
"><pre><span class="pl-k">function</span> <span class="pl-en">test2</span>()
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_4DGaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)

    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)
    β <span class="pl-k">=</span> <span class="pl-c1">5.5</span><span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)
    
    <span class="pl-c1">show</span>(gauge_action)

    x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>staggered<span class="pl-pds">"</span></span>)
    <span class="pl-c1">gauss_distribution_fermion!</span>(x)
    params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
    params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>staggered<span class="pl-pds">"</span></span>
    params[<span class="pl-s"><span class="pl-pds">"</span>mass<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.1</span>
    params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-8</span>
    params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>
    D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)
    
    Nf <span class="pl-k">=</span> <span class="pl-c1">2</span>
    
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Nf = <span class="pl-v">$Nf</span><span class="pl-pds">"</span></span>)
    parameters_action <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
    parameters_action[<span class="pl-s"><span class="pl-pds">"</span>Nf<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> Nf
    fermi_action <span class="pl-k">=</span> <span class="pl-c1">FermiAction</span>(D,parameters_action)

    y <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)

    
    <span class="pl-c1">MDtest!</span>(gauge_action,U,Dim,fermi_action,x,y)

<span class="pl-k">end</span>
</pre></div>
<h1 dir="auto">
<a id="user-content-hmc-with-fermions-with-stout-smearing" class="anchor" aria-hidden="true" href="#hmc-with-fermions-with-stout-smearing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>HMC with fermions with stout smearing</h1>
<p dir="auto">We show the code of HMC with Wilson fermions with stout smearing.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields
using LatticeDiracOperators
using LinearAlgebra
using LatticeDiracOperators

function MDtest!(gauge_action,U,Dim,nn,fermi_action,η,ξ)
    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. 
    Uold = similar(U)
    dSdU = similar(U)
    
    substitute_U!(Uold,U)
    MDsteps = 10
    temp1 = similar(U[1])
    temp2 = similar(U[1])
    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    numaccepted = 0
    

    numtrj = 100
    for itrj = 1:numtrj
        accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU,fermi_action,η,ξ)
        numaccepted += ifelse(accepted,1,0)

        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        println(&quot;$itrj plaq_t = $plaq_t&quot;)
        println(&quot;acceptance ratio &quot;,numaccepted/itrj)
    end
end

function calc_action(gauge_action,U,p)
    NC = U[1].NC
    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))
    Sp = p*p/2
    S = Sp + Sg
    return real(S)
end


function MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU,fermi_action,η,ξ)
    

    Δτ = 1/MDsteps
    gauss_distribution!(p)

    Uout,Uout_multi,_ = calc_smearedU(U,nn)
    #Sold = calc_action(gauge_action,Uout,p)

    substitute_U!(Uold,U)

    gauss_sampling_in_action!(ξ,Uout,fermi_action)
    sample_pseudofermions!(η,Uout,fermi_action,ξ)
    Sfold = real(dot(ξ,ξ))
    println(&quot;Sfold = $Sfold&quot;)

    Sold = calc_action(gauge_action,U,p) + Sfold
    println(&quot;Sold = &quot;,Sold)


    for itrj=1:MDsteps
        U_update!(U,p,0.5,Δτ,Dim,gauge_action)

        P_update!(U,p,1.0,Δτ,Dim,gauge_action)
        P_update_fermion!(U,p,1.0,Δτ,Dim,gauge_action,dSdU,nn,fermi_action,η)

        U_update!(U,p,0.5,Δτ,Dim,gauge_action)
    end

    Uout,Uout_multi,_ = calc_smearedU(U,nn)
    #Snew = calc_action(gauge_action,Uout,p)

    Sfnew = evaluate_FermiAction(fermi_action,Uout,η)
    println(&quot;Sfnew = $Sfnew&quot;)
    Snew = calc_action(gauge_action,U,p) + Sfnew
    

    println(&quot;Sold = $Sold, Snew = $Snew&quot;)
    println(&quot;Snew - Sold = $(Snew-Sold)&quot;)
    ratio = min(1,exp(Snew-Sold))
    if rand() &gt; ratio
        substitute_U!(U,Uold)
        return false
    else
        return true
    end
end

function U_update!(U,p,ϵ,Δτ,Dim,gauge_action)
    temps = get_temporary_gaugefields(gauge_action)
    temp1 = temps[1]
    temp2 = temps[2]
    expU = temps[3]
    W = temps[4]

    for μ=1:Dim
        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])
        mul!(W,expU,U[μ])
        substitute_U!(U[μ],W)
        
    end
end

function P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -&gt; p +factor*U*dSdUμ
    NC = U[1].NC
    temps = get_temporary_gaugefields(gauge_action)
    dSdUμ = temps[end]
    factor =  -ϵ*Δτ/(NC)

    for μ=1:Dim
        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)
        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ
        Traceless_antihermitian_add!(p[μ],factor,temps[1])
    end
end


function P_update_fermion!(U,p,ϵ,Δτ,Dim,gauge_action,dSdU,nn,fermi_action,η)  # p -&gt; p +factor*U*dSdUμ
    #NC = U[1].NC
    temps = get_temporary_gaugefields(gauge_action)
    UdSfdUμ = temps[1:Dim]
    factor =  -ϵ*Δτ

    Uout,Uout_multi,_ = calc_smearedU(U,nn)

    for μ=1:Dim
        calc_UdSfdU!(UdSfdUμ,fermi_action,Uout,η)
        mul!(dSdU[μ],Uout[μ]',UdSfdUμ[μ])
    end

    dSdUbare = back_prop(dSdU,nn,Uout_multi,U) 
    

    for μ=1:Dim
        mul!(temps[1],U[μ],dSdUbare[μ]) # U*dSdUμ
        Traceless_antihermitian_add!(p[μ],factor,temps[1])
        #println(&quot; p[μ] = &quot;, p[μ][1,1,1,1,1])
    end
end

function test1()
    NX = 4
    NY = 4
    NZ = 4
    NT = 4
    Nwing = 1
    Dim = 4
    NC = 3

    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;)


    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop')
    β = 5.7/2
    push!(gauge_action,β,plaqloop)

    show(gauge_action)

    L = [NX,NY,NZ,NT]
    nn = CovNeuralnet()
    ρ = [0.1]
    layername = [&quot;plaquette&quot;]
    st = STOUT_Layer(layername,ρ,L)
    push!(nn,st)
    #push!(nn,st)

    x = Initialize_pseudofermion_fields(U[1],&quot;Wilson&quot;)


    params = Dict()
    params[&quot;Dirac_operator&quot;] = &quot;Wilson&quot;
    params[&quot;κ&quot;] = 0.141139
    params[&quot;eps_CG&quot;] = 1.0e-8
    params[&quot;verbose_level&quot;] = 2
    D = Dirac_operator(U,x,params)


    parameters_action = Dict()
    fermi_action = FermiAction(D,parameters_action)

    y = similar(x)
    

    MDtest!(gauge_action,U,Dim,nn,fermi_action,x,y)

end


test1()"><pre><span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LatticeDiracOperators
<span class="pl-k">using</span> LinearAlgebra
<span class="pl-k">using</span> LatticeDiracOperators

<span class="pl-k">function</span> <span class="pl-en">MDtest!</span>(gauge_action,U,Dim,nn,fermi_action,η,ξ)
    p <span class="pl-k">=</span> <span class="pl-c1">initialize_TA_Gaugefields</span>(U) <span class="pl-c"><span class="pl-c">#</span>This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. </span>
    Uold <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    dSdU <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    
    <span class="pl-c1">substitute_U!</span>(Uold,U)
    MDsteps <span class="pl-k">=</span> <span class="pl-c1">10</span>
    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    numaccepted <span class="pl-k">=</span> <span class="pl-c1">0</span>
    

    numtrj <span class="pl-k">=</span> <span class="pl-c1">100</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numtrj
        accepted <span class="pl-k">=</span> <span class="pl-c1">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU,fermi_action,η,ξ)
        numaccepted <span class="pl-k">+=</span> <span class="pl-c1">ifelse</span>(accepted,<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)

        plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>acceptance ratio <span class="pl-pds">"</span></span>,numaccepted<span class="pl-k">/</span>itrj)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">calc_action</span>(gauge_action,U,p)
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    Sg <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">evaluate_GaugeAction</span>(gauge_action,U)<span class="pl-k">/</span>NC <span class="pl-c"><span class="pl-c">#</span>evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))</span>
    Sp <span class="pl-k">=</span> p<span class="pl-k">*</span>p<span class="pl-k">/</span><span class="pl-c1">2</span>
    S <span class="pl-k">=</span> Sp <span class="pl-k">+</span> Sg
    <span class="pl-k">return</span> <span class="pl-c1">real</span>(S)
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU,fermi_action,η,ξ)
    

    Δτ <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>MDsteps
    <span class="pl-c1">gauss_distribution!</span>(p)

    Uout,Uout_multi,_ <span class="pl-k">=</span> <span class="pl-c1">calc_smearedU</span>(U,nn)
    <span class="pl-c"><span class="pl-c">#</span>Sold = calc_action(gauge_action,Uout,p)</span>

    <span class="pl-c1">substitute_U!</span>(Uold,U)

    <span class="pl-c1">gauss_sampling_in_action!</span>(ξ,Uout,fermi_action)
    <span class="pl-c1">sample_pseudofermions!</span>(η,Uout,fermi_action,ξ)
    Sfold <span class="pl-k">=</span> <span class="pl-c1">real</span>(<span class="pl-c1">dot</span>(ξ,ξ))
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sfold = <span class="pl-v">$Sfold</span><span class="pl-pds">"</span></span>)

    Sold <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p) <span class="pl-k">+</span> Sfold
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-pds">"</span></span>,Sold)


    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>MDsteps
        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">P_update!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action)
        <span class="pl-c1">P_update_fermion!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action,dSdU,nn,fermi_action,η)

        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)
    <span class="pl-k">end</span>

    Uout,Uout_multi,_ <span class="pl-k">=</span> <span class="pl-c1">calc_smearedU</span>(U,nn)
    <span class="pl-c"><span class="pl-c">#</span>Snew = calc_action(gauge_action,Uout,p)</span>

    Sfnew <span class="pl-k">=</span> <span class="pl-c1">evaluate_FermiAction</span>(fermi_action,Uout,η)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sfnew = <span class="pl-v">$Sfnew</span><span class="pl-pds">"</span></span>)
    Snew <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p) <span class="pl-k">+</span> Sfnew
    

    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-v">$Sold</span>, Snew = <span class="pl-v">$Snew</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Snew - Sold = <span class="pl-v">$(Snew<span class="pl-k">-</span>Sold)</span><span class="pl-pds">"</span></span>)
    ratio <span class="pl-k">=</span> <span class="pl-c1">min</span>(<span class="pl-c1">1</span>,<span class="pl-c1">exp</span>(Snew<span class="pl-k">-</span>Sold))
    <span class="pl-k">if</span> <span class="pl-c1">rand</span>() <span class="pl-k">&gt;</span> ratio
        <span class="pl-c1">substitute_U!</span>(U,Uold)
        <span class="pl-k">return</span> <span class="pl-c1">false</span>
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">U_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action)
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    expU <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    W <span class="pl-k">=</span> temps[<span class="pl-c1">4</span>]

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">exptU!</span>(expU,ϵ<span class="pl-k">*</span>Δτ,p[μ],[temp1,temp2])
        <span class="pl-c1">mul!</span>(W,expU,U[μ])
        <span class="pl-c1">substitute_U!</span>(U[μ],W)
        
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">P_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action) <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    dSdUμ <span class="pl-k">=</span> temps[<span class="pl-c1">end</span>]
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ<span class="pl-k">/</span>(NC)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">calc_dSdUμ!</span>(dSdUμ,gauge_action,μ,U)
        <span class="pl-c1">mul!</span>(temps[<span class="pl-c1">1</span>],U[μ],dSdUμ) <span class="pl-c"><span class="pl-c">#</span> U*dSdUμ</span>
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,temps[<span class="pl-c1">1</span>])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">P_update_fermion!</span>(U,p,ϵ,Δτ,Dim,gauge_action,dSdU,nn,fermi_action,η)  <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    <span class="pl-c"><span class="pl-c">#</span>NC = U[1].NC</span>
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    UdSfdUμ <span class="pl-k">=</span> temps[<span class="pl-c1">1</span><span class="pl-k">:</span>Dim]
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ

    Uout,Uout_multi,_ <span class="pl-k">=</span> <span class="pl-c1">calc_smearedU</span>(U,nn)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">calc_UdSfdU!</span>(UdSfdUμ,fermi_action,Uout,η)
        <span class="pl-c1">mul!</span>(dSdU[μ],Uout[μ]<span class="pl-k">'</span>,UdSfdUμ[μ])
    <span class="pl-k">end</span>

    dSdUbare <span class="pl-k">=</span> <span class="pl-c1">back_prop</span>(dSdU,nn,Uout_multi,U) 
    

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">mul!</span>(temps[<span class="pl-c1">1</span>],U[μ],dSdUbare[μ]) <span class="pl-c"><span class="pl-c">#</span> U*dSdUμ</span>
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,temps[<span class="pl-c1">1</span>])
        <span class="pl-c"><span class="pl-c">#</span>println(" p[μ] = ", p[μ][1,1,1,1,1])</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">test1</span>()
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

    U  <span class="pl-k">=</span><span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>)


    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)
    β <span class="pl-k">=</span> <span class="pl-c1">5.7</span><span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)

    <span class="pl-c1">show</span>(gauge_action)

    L <span class="pl-k">=</span> [NX,NY,NZ,NT]
    nn <span class="pl-k">=</span> <span class="pl-c1">CovNeuralnet</span>()
    ρ <span class="pl-k">=</span> [<span class="pl-c1">0.1</span>]
    layername <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>]
    st <span class="pl-k">=</span> <span class="pl-c1">STOUT_Layer</span>(layername,ρ,L)
    <span class="pl-c1">push!</span>(nn,st)
    <span class="pl-c"><span class="pl-c">#</span>push!(nn,st)</span>

    x <span class="pl-k">=</span> <span class="pl-c1">Initialize_pseudofermion_fields</span>(U[<span class="pl-c1">1</span>],<span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>)


    params <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
    params[<span class="pl-s"><span class="pl-pds">"</span>Dirac_operator<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Wilson<span class="pl-pds">"</span></span>
    params[<span class="pl-s"><span class="pl-pds">"</span>κ<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">0.141139</span>
    params[<span class="pl-s"><span class="pl-pds">"</span>eps_CG<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.0e-8</span>
    params[<span class="pl-s"><span class="pl-pds">"</span>verbose_level<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>
    D <span class="pl-k">=</span> <span class="pl-c1">Dirac_operator</span>(U,x,params)


    parameters_action <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
    fermi_action <span class="pl-k">=</span> <span class="pl-c1">FermiAction</span>(D,parameters_action)

    y <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)
    

    <span class="pl-c1">MDtest!</span>(gauge_action,U,Dim,nn,fermi_action,x,y)

<span class="pl-k">end</span>


<span class="pl-c1">test1</span>()</pre></div>
</article></div>