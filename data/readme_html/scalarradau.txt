<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-scalarradau" class="anchor" aria-hidden="true" href="#scalarradau"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ScalarRadau</h1>
<p dir="auto"><a href="https://github.com/markmbaum/ScalarRadau.jl/actions"><img src="https://github.com/markmbaum/ScalarRadau.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://app.codecov.io/gh/markmbaum/ScalarRadau.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/fbde4343f5d8cb9aa60bf4c4b348b0969ad82a3b95ff1f8ed43af59a31b79d2d/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f6d61726b6d6261756d2f5363616c617252616461752e6a6c3f6c6f676f3d436f6465636f76" alt="Codecov" data-canonical-src="https://img.shields.io/codecov/c/github/markmbaum/ScalarRadau.jl?logo=Codecov" style="max-width: 100%;"></a></p>
<p dir="auto">Solve a <em>scalar</em> differential equation with accuracy, efficiency, and stability</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using BenchmarkTools, ScalarRadau, Plots
F(x, y, p) = 50*(cos(x) - y);
x, y = radau(F, 0.1, 0, 3, 1000);
plot(x, y, legend=false, xlabel=&quot;x&quot;, ylabel=&quot;y&quot;);"><pre><span class="pl-k">using</span> BenchmarkTools, ScalarRadau, Plots
<span class="pl-en">F</span>(x, y, p) <span class="pl-k">=</span> <span class="pl-c1">50</span><span class="pl-k">*</span>(<span class="pl-c1">cos</span>(x) <span class="pl-k">-</span> y);
x, y <span class="pl-k">=</span> <span class="pl-c1">radau</span>(F, <span class="pl-c1">0.1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">1000</span>);
<span class="pl-c1">plot</span>(x, y, legend<span class="pl-k">=</span><span class="pl-c1">false</span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>);</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="img/example.png"><img src="img/example.png" alt="example" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = LinRange(0, 3, 100)
y = zeros(length(x))
@btime radau!($y, $x, $F, 0.1, 0.0, 3.0);
  5.667 μs (2 allocations: 1.75 KiB)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">LinRange</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">100</span>)
y <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">length</span>(x))
<span class="pl-c1">@btime</span> <span class="pl-c1">radau!</span>(<span class="pl-k">$</span>y, <span class="pl-k">$</span>x, <span class="pl-k">$</span>F, <span class="pl-c1">0.1</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">3.0</span>);
  <span class="pl-c1">5.667</span> μs (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.75</span> KiB)</pre></div>
<hr>
<p dir="auto">This module contains a lightweight implementation of the classic 5th order <a href="https://link.springer.com/referenceworkentry/10.1007%2F978-3-540-70529-1_139" rel="nofollow">Radau IIA method</a> for a <strong>scalar</strong> ordinary differential equation (ODE) in Julia. The algorithm is famously effective when the stability of the ODE solving method is a priority. It is "stiffly accurate" and A-B-L stable. Implementation mostly follows the description in chapter IV.8 in <a href="https://www.springer.com/gp/book/9783540604525" rel="nofollow">Solving Ordinary Differential Equations II</a>, by Ernst Hairer and Gerhard Wanner.</p>
<p dir="auto">Some basic points of description:</p>
<ul dir="auto">
<li>Step size is adaptive and the initial step size is chosen automatically.</li>
<li>Functions implemented here mostly type-flexible. The dependent variable (<code>y₀</code>, <code>yout</code>) is restricted to <code>&lt;:Real</code>. Also, your ODE should be type stable and probably should not return anything that isn't <code>&lt;:Real</code>.</li>
<li>Dense output for continuous solutions is implemented using cubic Hermite interpolation.</li>
<li>Approximate Jacobian evaluation is performed with a simple finite difference, which costs one function evaluation for each attempted step.</li>
<li>Because the equation is scalar and the 5th order Radau method has three stages, the Jacobian is always a 3 x 3 matrix. <a href="https://github.com/JuliaArrays/StaticArrays.jl">Static arrays</a> are used for efficient quasi-Newton iterations.</li>
</ul>
<p dir="auto">The implementation here is designed for a scenario where a scalar ODE must be solved repeatedly and the stability of the solver is really important. The module was originally written to solve the <a href="https://en.wikipedia.org/wiki/Schwarzschild%27s_equation_for_radiative_transfer" rel="nofollow">Schwarzschild equation for radiative transfer</a> as part of <a href="https://github.com/markmbaum/ClearSky.jl">ClearSky.jl</a>. In this case, the stability properties of the solver are crucial because they prevent non-physical "overshoots."</p>
<p dir="auto">The solver functions specialize directly on the ODE provided. This is slightly different than <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>, which uses a two-step system of defining an ODE problem with one function then solving it with another function, but if you need to solve a stiff system of ODEs instead of a scalar equation, look <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Stiff-Problems" rel="nofollow">here</a>. Specifically, the vector implementation of the same Radau method is called <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Fully-Implicit-Runge-Kutta-Methods-(FIRK)" rel="nofollow"><code>RadauIIA5</code></a>.</p>
<p dir="auto">For a nice mathematical overview of Radau methods, check out: <a href="https://www.sciencedirect.com/science/article/pii/S037704279900134X" rel="nofollow">Stiff differential equations solved by Radau methods</a>.</p>
<h3 dir="auto"><a id="user-content-how-to-use-scalarradau" class="anchor" aria-hidden="true" href="#how-to-use-scalarradau"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to Use <code>ScalarRadau</code></h3>
<p dir="auto">Install using Julia's package manager</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ]add ScalarRadau"><pre>julia<span class="pl-k">&gt;</span> ]add ScalarRadau</pre></div>
<p dir="auto">To solve an ODE, first define it as a function, then pass it to the <code>radau</code> function.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ScalarRadau
F(x, y, param) = -y
x, y = radau(F, 1.0, 0, 2, 25)"><pre><span class="pl-k">using</span> ScalarRadau
<span class="pl-en">F</span>(x, y, param) <span class="pl-k">=</span> <span class="pl-k">-</span>y
x, y <span class="pl-k">=</span> <span class="pl-c1">radau</span>(F, <span class="pl-c1">1.0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">2</span>, <span class="pl-c1">25</span>)</pre></div>
<p dir="auto">The snippet above solves the equation <code>dy/dx = -y</code>, starting at <code>y=1</code>, between <code>x=0</code> and <code>x=2</code>, and returns 25 evenly spaced points in the solution interval.</p>
<p dir="auto">The "function" <code>F</code> can be any callable object, as long as it can be called with <code>(x, y, param)</code> arguments.</p>
<h3 dir="auto"><a id="user-content-in-place-solution" class="anchor" aria-hidden="true" href="#in-place-solution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>In-place Solution</h3>
<p dir="auto">For full control over output points, the in-place function is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="radau!(yout, xout, F, y₀, x₀, xₙ, param=nothing; rtol=1e-6, atol=1e-6, facmax=100.0, facmin=0.01, κ=1e-3, ϵ=0.25, maxnewt=7, maxstep=1000000, maxfail=10)"><pre><span class="pl-c1">radau!</span>(yout, xout, F, y₀, x₀, xₙ, param<span class="pl-k">=</span><span class="pl-c1">nothing</span>; rtol<span class="pl-k">=</span><span class="pl-c1">1e-6</span>, atol<span class="pl-k">=</span><span class="pl-c1">1e-6</span>, facmax<span class="pl-k">=</span><span class="pl-c1">100.0</span>, facmin<span class="pl-k">=</span><span class="pl-c1">0.01</span>, κ<span class="pl-k">=</span><span class="pl-c1">1e-3</span>, ϵ<span class="pl-k">=</span><span class="pl-c1">0.25</span>, maxnewt<span class="pl-k">=</span><span class="pl-c1">7</span>, maxstep<span class="pl-k">=</span><span class="pl-c1">1000000</span>, maxfail<span class="pl-k">=</span><span class="pl-c1">10</span>)</pre></div>
<p dir="auto">Mandatory function arguments are</p>
<ul dir="auto">
<li><code>yout</code> - vector where output points will be written</li>
<li><code>xout</code> - sorted vector of <code>x</code> values where output points should be sampled</li>
<li><code>F</code> - scalar ODE in the form <code>dy/dx = F(x, y, param)</code></li>
<li><code>y₀</code> - initial value for <code>y</code></li>
<li><code>x₀</code> - starting point for <code>x</code></li>
<li><code>xₙ</code> - end point of the integration</li>
</ul>
<p dir="auto">The optional <code>param</code> argument is <code>nothing</code> by default, but it may be any type and is meant for scenarios where extra information must be accessible to the ODE function. It is passed to <code>F</code> whenever it's called.</p>
<p dir="auto">The coordinates of the output points (<code>xout</code>) should be between <code>x₀</code> and <code>xₙ</code> and they should be in ascending order. They are not checked for integrity before integrating. The only check performed is <code>xₙ &gt; x₀</code>, or that the integration isn't going backward.</p>
<p dir="auto"><strong>When solving in-place, values in <code>yout</code> are added to, not overwritten.</strong> This means that if <code>yout</code> is full of NaNs or any other non-zero values upon calling <code>radau!</code>, they will be present in the result. You must pre-fill <code>yout</code> with zeros on your own.</p>
<p dir="auto">Keyword arguments are</p>
<ul dir="auto">
<li><code>rtol</code> - relative error tolerance</li>
<li><code>atol</code> - absolute error tolerance</li>
<li><code>facmax</code> - maximum fraction that the step size may increase, compared to the previous step</li>
<li><code>facmin</code> - minimum fraction that the step size may decrease, compared to the previous step</li>
<li><code>κ</code> (kappa) - stopping tolerance for Newton iterations</li>
<li><code>ϵ</code> (epsilon) - fraction of current step size used for finite difference Jacobian approximation</li>
<li><code>maxnewt</code> - maximum number of Newton iterations before step size reduction</li>
<li><code>maxstep</code> - maximum number of steps before the solver stops and throws an error</li>
<li><code>maxfail</code> - maximum number of Newton convergence failures before error</li>
</ul>
<p dir="auto">The <code>maxnewt</code>,  <code>maxstep</code>, and <code>maxfail</code> arguments are not restricted to integers, so they can be set to <code>Inf</code> to effectively disable them.</p>
<p dir="auto">Two other functions, described below, are available to make different output options convenient. Both of them use the in-place version internally.</p>
<h3 dir="auto"><a id="user-content-evenly-spaced-output" class="anchor" aria-hidden="true" href="#evenly-spaced-output"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Evenly Spaced Output</h3>
<p dir="auto">For evenly spaced output points (as in the example above) the function definition is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="radau(F, y₀, x₀, xₙ, nout, param=nothing; kwargs...)"><pre><span class="pl-c1">radau</span>(F, y₀, x₀, xₙ, nout, param<span class="pl-k">=</span><span class="pl-c1">nothing</span>; kwargs<span class="pl-k">...</span>)</pre></div>
<p dir="auto">In this case, you must specify the number of output points with the <code>nout</code> argument. Keyword arguments and default values are the same as above. Solution vectors for <code>x</code> and <code>y</code> are returned.</p>
<h3 dir="auto"><a id="user-content-end-point-output" class="anchor" aria-hidden="true" href="#end-point-output"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>End-point Output</h3>
<p dir="auto">To compute only the <code>y</code> value at the end of the integration interval (<code>xₙ</code>), the function is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="radau(F, y₀, x₀, xₙ, param=nothing; kwargs...)"><pre><span class="pl-c1">radau</span>(F, y₀, x₀, xₙ, param<span class="pl-k">=</span><span class="pl-c1">nothing</span>; kwargs<span class="pl-k">...</span>)</pre></div>
<p dir="auto">Again, keyword arguments and default values are identical to the in-place function.</p>
</article></div>