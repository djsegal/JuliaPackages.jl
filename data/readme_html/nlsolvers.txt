<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-nlsolvers" class="anchor" aria-hidden="true" href="#nlsolvers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NLSolvers</h1>
<table>
<thead>
<tr>
<th align="center"><strong>Source</strong></th>
<th align="center"><strong>Build Status</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://github.com/pkofod/NLSolvers.jl"><img src="https://camo.githubusercontent.com/f6320b08c097e94fd333ab67ebe0bf51844f77b0/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4769744875622d736f757263652d677265656e2e737667" alt="Source" data-canonical-src="https://img.shields.io/badge/GitHub-source-green.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://travis-ci.org/pkofod/NLSolvers.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d57fbf20b723f2ab843830b7c455fe2b6906b441/68747470733a2f2f7472617669732d63692e6f72672f706b6f666f642f4e4c536f6c766572732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/pkofod/NLSolvers.jl.svg?branch=master" style="max-width:100%;"></a></td>
</tr>
<tr>
<td align="center"><a href="https://codecov.io/gh/pkofod/NLSolvers.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e956b1b991f6037ed1fabe1be27782c077c33e3d/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f706b6f666f642f4e4c536f6c766572732e6a6c2f6d61737465722e737667" alt="Codecov branch" data-canonical-src="https://img.shields.io/codecov/c/github/pkofod/NLSolvers.jl/master.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://ci.appveyor.com/project/blegat/optim-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/8287e82af0387b88e2c1afb63c98f125d462701e/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f707270387967667034727239746166653f7376673d74727565" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/prp8ygfp4rr9tafe?svg=true" style="max-width:100%;"></a></td>
</tr>
</tbody>
</table>
<p>NLSolvers provides optimization, curve fitting, and equation solving functionalities for Julia.
The goal is to provide a set of robust and flexible methods that runs fast and is easy to use.</p>
<h2><a id="user-content-solving-your-problems" class="anchor" aria-hidden="true" href="#solving-your-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solving your problems</h2>
<p>NLSolvers.jl uses different problem types for different problems. For example, a <code>MinProblem</code> would
be <code>solve!</code>ed or <code>solve</code>ed depending of the circumstances.</p>
<p>Take the following scalar objective (with scalar input)</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> NLSolvers
<span class="pl-k">function</span> <span class="pl-en">scalarobj</span>(x, ∇f, ∇²f)
    <span class="pl-k">if</span> ∇²f <span class="pl-k">!==</span> <span class="pl-c1">nothing</span>
        ∇²f <span class="pl-k">=</span> <span class="pl-c1">12</span>x<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">sin</span>(x)
    <span class="pl-k">end</span>
    <span class="pl-k">if</span> ∇f <span class="pl-k">!==</span> <span class="pl-c1">nothing</span>
        ∇f <span class="pl-k">=</span> <span class="pl-c1">4</span>x<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">cos</span>(x)
    <span class="pl-k">end</span>

    fx <span class="pl-k">=</span> x<span class="pl-k">^</span><span class="pl-c1">4</span> <span class="pl-k">+</span> <span class="pl-c1">sin</span>(x)
    <span class="pl-c1">objective_return</span>(fx, ∇f, ∇²f)
<span class="pl-k">end</span>
scalar_obj <span class="pl-k">=</span> <span class="pl-c1">TwiceDiffed</span>(scalarobj)</pre></div>
<p>Now, define a <code>MinProblem</code></p>
<div class="highlight highlight-source-julia"><pre>mp <span class="pl-k">=</span> <span class="pl-c1">MinProblem</span>(scalar_obj)</pre></div>
<p>Then, we would use <code>solve</code> to solve the instance</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">solve</span>(mp, x0, <span class="pl-c1">LineSearch</span>(<span class="pl-c1">Newton</span>()), <span class="pl-c1">MinOptions</span>())</pre></div>
<p>and then</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">solve</span>(mp, <span class="pl-c1">4.0</span>, <span class="pl-c1">LineSearch</span>(<span class="pl-c1">ConjugateGradient</span>()), <span class="pl-c1">MinOptions</span>())</pre></div>
<p>which gives</p>
<div class="highlight highlight-source-julia"><pre>Results of minimization

<span class="pl-k">*</span> Algorithm<span class="pl-k">:</span>
  Conjugate Gradient Descent (HZ) with backtracking (no interp)

<span class="pl-k">*</span> Candidate solution<span class="pl-k">:</span>
  Final objective value<span class="pl-k">:</span>    <span class="pl-k">-</span><span class="pl-c1">4.35e-01</span>
  Final gradient norm<span class="pl-k">:</span>      <span class="pl-c1">2.88e-09</span>

  Initial objective value<span class="pl-k">:</span>  <span class="pl-c1">2.55e+02</span>
  Initial gradient norm<span class="pl-k">:</span>    <span class="pl-c1">2.55e+02</span>

<span class="pl-k">*</span> Convergence measures
  <span class="pl-k">|</span>x <span class="pl-k">-</span> x<span class="pl-k">'</span><span class="pl-k">|</span>              <span class="pl-k">=</span> <span class="pl-c1">4.11e-07</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">0.00e+00</span> (<span class="pl-c1">false</span>)
  <span class="pl-k">|</span>x <span class="pl-k">-</span> x<span class="pl-k">'</span><span class="pl-k">|</span><span class="pl-k">/</span><span class="pl-k">|</span>x<span class="pl-k">|</span>          <span class="pl-k">=</span> <span class="pl-c1">6.94e-07</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">0.00e+00</span> (<span class="pl-c1">false</span>)
  <span class="pl-k">|</span><span class="pl-c1">f</span>(x) <span class="pl-k">-</span> <span class="pl-c1">f</span>(x<span class="pl-k">'</span>)<span class="pl-k">|</span>        <span class="pl-k">=</span> <span class="pl-c1">4.01e-13</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">0.00e+00</span> (<span class="pl-c1">false</span>)
  <span class="pl-k">|</span><span class="pl-c1">f</span>(x) <span class="pl-k">-</span> <span class="pl-c1">f</span>(x<span class="pl-k">'</span>)<span class="pl-k">|</span><span class="pl-k">/</span><span class="pl-k">|</span><span class="pl-c1">f</span>(x)<span class="pl-k">|</span> <span class="pl-k">=</span> <span class="pl-c1">9.22e-13</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">0.00e+00</span> (<span class="pl-c1">false</span>)
  <span class="pl-k">|</span><span class="pl-c1">g</span>(x)<span class="pl-k">|</span>                <span class="pl-k">=</span> <span class="pl-c1">2.88e-09</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">1.00e-08</span> (<span class="pl-c1">true</span>)
  <span class="pl-k">|</span><span class="pl-c1">g</span>(x)<span class="pl-k">|</span><span class="pl-k">/</span><span class="pl-k">|</span><span class="pl-c1">g</span>(x₀)<span class="pl-k">|</span>        <span class="pl-k">=</span> <span class="pl-c1">1.13e-11</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">0.00e+00</span> (<span class="pl-c1">false</span>)

<span class="pl-k">*</span> Work counters
  Seconds run<span class="pl-k">:</span>   <span class="pl-c1">1.94e-01</span>
  Iterations<span class="pl-k">:</span>    <span class="pl-c1">18</span>
</pre></div>
<p>The problem types are especially useful when manifolds, bounds, and other constraints enter the picture. They make sure that there is only ever one initial argument: the objective or the problem definition. The functions <code>minimize(!)</code> are really shortcuts for unconstrained optimization.</p>
<h2><a id="user-content-custom-solve" class="anchor" aria-hidden="true" href="#custom-solve"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom solve</h2>
<p>Newton methods generally accept a linsolve argument.</p>
<h2><a id="user-content-preconditioning" class="anchor" aria-hidden="true" href="#preconditioning"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preconditioning</h2>
<p>Several methods accept nonlinear (left-)preconditioners. A preconditioner is provided as a function that has two methods: <code>p(x)</code> and <code>p(x, P)</code> where the first prepares and returns the preconditioner and the second is the signature for updating the preconditioner. If the preconditioner is constant, both method
will simply return this preconditioner. A preconditioner is used in two contexts: in <code>ldiv!(pgr, factorize(P), gr)</code> that accepts a cache array for the preconditioned gradient <code>pgr</code>, the preconditioner <code>P</code>, and the gradient to be preconditioned <code>gr</code>, and in <code>mul!(x, P, y)</code>. For the out-of-place methods (<code>minimize</code> as opposed to <code>minimize!</code>) it is sufficient to have <code>\(P, gr)</code> and <code>*(P, y)</code> defined.</p>
<h2><a id="user-content-beware-chaotic-gradient-methods" class="anchor" aria-hidden="true" href="#beware-chaotic-gradient-methods"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beware, chaotic gradient methods!</h2>
<p>Some methods that might be labeled as acceleration, momentum, or spectral methods can exhibit chaotic behavior. Please keep this in mind if comparing things like <code>DFSANE</code> with similar implemenations in other software. It can give very different results given different compiler optimizations, CPU architectures, etc. See for example <a href="https://link.springer.com/article/10.1007/s10915-011-9521-3" rel="nofollow">https://link.springer.com/article/10.1007/s10915-011-9521-3</a> .</p>
<p>Two types of functions:
WorkVars # x, F, J, H, ??
AlgVars # s, y, z, ...
Documented in each type's docstring including LineSearch, BFGS, ....</p>
<p>AlgVars = (LSVars, QNVars, ...)
OptVars?
Initial modelvars and QNvars</p>
<p>tracing!
Abstract arrays!!! :|
manifolds
Use user norms
MArray support
Banded Jacobian
AD
nan return, nan gradient, nan hessian</p>
<p>line search should have a short curcuit for very small steps</p>
<p>MaxProblem
NLsqProblem</p>
<h2><a id="user-content-common-interface" class="anchor" aria-hidden="true" href="#common-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Common interface</h2>
<p>See Optims.jl</p>
<p>This provides an interface for other solvers as well</p>
<h2><a id="user-content-scalar-optimization-w-different-number-types" class="anchor" aria-hidden="true" href="#scalar-optimization-w-different-number-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scalar optimization (w/ different number types)</h2>
<pre><code>using NLSolvers, DoubleFloats

function myfun(x::T, ∇f=nothing, ∇²f=nothing) where T
   if !(∇²f == nothing)
       ∇²f = 12x^2 - sin(x)
   end
   if !(∇f == nothing)
       ∇f = 4x^3 + cos(x)
   end

   fx = x^4 +sin(x)

   objective_return(T(fx), T(∇f), T(∇²f))
end
my_obj_1 = OnceDiffed(myfun)
res = minimize(my_obj_1, Float64(4), BFGS(Inverse()))
res = minimize(my_obj_1, Double32(4), BFGS(Inverse()))
res = minimize(my_obj_1, Double64(4), BFGS(Inverse()))
my_obj_2 = TwiceDiffed(myfun)
res = minimize(my_obj_2, Float64(4), Newton())
res = minimize(my_obj_2, Double32(4), Newton())
res = minimize(my_obj_2, Double64(4), Newton())
</code></pre>
<h2><a id="user-content-multivariate-optimization-w-different-number-and-array-types" class="anchor" aria-hidden="true" href="#multivariate-optimization-w-different-number-and-array-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multivariate optimization (w/ different number and array types)</h2>
<pre><code>using NLSolvers, StaticArrays
function theta(x)
   if x[1] &gt; 0
       return atan(x[2] / x[1]) / (2.0 * pi)
   else
       return (pi + atan(x[2] / x[1])) / (2.0 * pi)
   end
end
f(x) = 100.0 * ((x[3] - 10.0 * theta(x))^2 + (sqrt(x[1]^2 + x[2]^2) - 1.0)^2) + x[3]^2

function f∇f!(∇f, x)
    if !(∇f==nothing)
        if ( x[1]^2 + x[2]^2 == 0 )
            dtdx1 = 0;
            dtdx2 = 0;
        else
            dtdx1 = - x[2] / ( 2 * pi * ( x[1]^2 + x[2]^2 ) );
            dtdx2 =   x[1] / ( 2 * pi * ( x[1]^2 + x[2]^2 ) );
        end
        ∇f[1] = -2000.0*(x[3]-10.0*theta(x))*dtdx1 +
            200.0*(sqrt(x[1]^2+x[2]^2)-1)*x[1]/sqrt( x[1]^2+x[2]^2 );
        ∇f[2] = -2000.0*(x[3]-10.0*theta(x))*dtdx2 +
            200.0*(sqrt(x[1]^2+x[2]^2)-1)*x[2]/sqrt( x[1]^2+x[2]^2 );
        ∇f[3] =  200.0*(x[3]-10.0*theta(x)) + 2.0*x[3];
    end

    fx = f(x)
    return ∇f==nothing ? fx : (fx, ∇f)
end

function f∇f(∇f, x)
    if !(∇f == nothing)
        gx = similar(x)
        return f∇f!(gx, x)
    else
        return f∇f!(∇f, x)
    end
end
function f∇fs(∇f, x)
    if !(∇f == nothing)
        if ( x[1]^2 + x[2]^2 == 0 )
            dtdx1 = 0;
            dtdx2 = 0;
        else
            dtdx1 = - x[2] / ( 2 * pi * ( x[1]^2 + x[2]^2 ) )
            dtdx2 =   x[1] / ( 2 * pi * ( x[1]^2 + x[2]^2 ) )
        end

        s1 = -2000.0*(x[3]-10.0*theta(x))*dtdx1 +
            200.0*(sqrt(x[1]^2+x[2]^2)-1)*x[1]/sqrt( x[1]^2+x[2]^2 )
        s2 = -2000.0*(x[3]-10.0*theta(x))*dtdx2 +
            200.0*(sqrt(x[1]^2+x[2]^2)-1)*x[2]/sqrt( x[1]^2+x[2]^2 )
        s3 = 200.0*(x[3]-10.0*theta(x)) + 2.0*x[3]
        ∇f = @SVector [s1, s2, s3]
        return f(x), ∇f
    else
        return f(x)
    end
end

x0 = [-1.0, 0.0, 0.0]
res = minimize(f∇f, x0, DFP(Inverse()))
res = minimize!(f∇f!, copy(x0), DFP(Inverse()))

x0s = @SVector [-1.0, 0.0, 0.0]
res = minimize(f∇fs, x0s, DFP(Inverse()))

</code></pre>
<h1><a id="user-content-second-order-optimization" class="anchor" aria-hidden="true" href="#second-order-optimization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Second order optimization</h1>
<pre><code>    using NLSolvers
    function himmelblau!(x)
        fx = (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
        return fx
    end
    function himmelblau!(∇f, x)
        if !(∇f == nothing)
            ∇f[1] = 4.0 * x[1]^3 + 4.0 * x[1] * x[2] -
                44.0 * x[1] + 2.0 * x[1] + 2.0 * x[2]^2 - 14.0
            ∇f[2] = 2.0 * x[1]^2 + 2.0 * x[2] - 22.0 +
                4.0 * x[1] * x[2] + 4.0 * x[2]^3 - 28.0 * x[2]
        end

        fx = (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
        return ∇f == nothing ? fx : (fx, ∇f)
    end

    function himmelblau!(∇²f, ∇f, x)
        if !(∇²f == nothing)
            ∇²f[1, 1] = 12.0 * x[1]^2 + 4.0 * x[2] - 42.0
            ∇²f[1, 2] = 4.0 * x[1] + 4.0 * x[2]
            ∇²f[2, 1] = 4.0 * x[1] + 4.0 * x[2]
            ∇²f[2, 2] = 12.0 * x[2]^2 + 4.0 * x[1] - 26.0
        end

        if ∇f == nothing &amp;&amp; ∇²f == nothing
            fx = himmelblau!(∇f, x)
            return fx
        elseif ∇²f == nothing
            return himmelblau!(∇f, x)
        else
            fx, ∇f = himmelblau!(∇f, x)
            return fx, ∇f, ∇²f
        end
    end

    res = minimize!(NonDiffed(himmelblau!), copy([2.0,2.0]), NelderMead())
    res = minimize!(OnceDiffed(himmelblau!), copy([2.0,2.0]), BFGS())
    res = minimize!(TwiceDiffed(himmelblau!), copy([2.0,2.0]), Newton())
</code></pre>
<h1><a id="user-content-mixnmatch" class="anchor" aria-hidden="true" href="#mixnmatch"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mix'n'match</h1>
<pre><code>using NLSolvers
function himmelblau!(∇f, x)
    if !(∇f == nothing)
        ∇f[1] = 4.0 * x[1]^3 + 4.0 * x[1] * x[2] -
            44.0 * x[1] + 2.0 * x[1] + 2.0 * x[2]^2 - 14.0
        ∇f[2] = 2.0 * x[1]^2 + 2.0 * x[2] - 22.0 +
            4.0 * x[1] * x[2] + 4.0 * x[2]^3 - 28.0 * x[2]
    end

    fx = (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
    return ∇f == nothing ? fx : (fx, ∇f)
end

function himmelblau!(∇²f, ∇f, x)
    if !(∇²f == nothing)
        ∇²f[1, 1] = 12.0 * x[1]^2 + 4.0 * x[2] - 42.0
        ∇²f[1, 2] = 4.0 * x[1] + 4.0 * x[2]
        ∇²f[2, 1] = 4.0 * x[1] + 4.0 * x[2]
        ∇²f[2, 2] = 12.0 * x[2]^2 + 4.0 * x[1] - 26.0
    end


    if ∇f == nothing &amp;&amp; ∇²f == nothing
        fx = himmelblau!(∇f, x)
        return fx
    elseif ∇²f == nothing
        return himmelblau!(∇f, x)
    else
        fx, ∇f = himmelblau!(∇f, x)
        return fx, ∇f, ∇²f
    end
end

res = minimize!(himmelblau!, copy([2.0,2.0]), Newton(Direct()))
res = minimize!(himmelblau!, copy([2.0,2.0]), (Newton(Direct()), Backtracking()))
res = minimize!(himmelblau!, copy([2.0,2.0]), (Newton(Direct()), NWI()))
</code></pre>
<h2><a id="user-content-wrapping-a-leastsquares-problem-for-minproblems" class="anchor" aria-hidden="true" href="#wrapping-a-leastsquares-problem-for-minproblems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrapping a LeastSquares problem for MinProblems</h2>
<p>To be able to do inplace least squares problems it is necessary to provide proper cache arrays to be used internally. To do this we write</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@.</span> <span class="pl-en">model</span>(x, p) <span class="pl-k">=</span> p[<span class="pl-c1">1</span>]<span class="pl-k">*</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span>x<span class="pl-k">*</span>p[<span class="pl-c1">2</span>])
xdata <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, stop<span class="pl-k">=</span><span class="pl-c1">10</span>, length<span class="pl-k">=</span><span class="pl-c1">20</span>)
ydata <span class="pl-k">=</span> <span class="pl-c1">model</span>(xdata, [<span class="pl-c1">1.0</span> <span class="pl-c1">2.0</span>]) <span class="pl-k">+</span> <span class="pl-c1">0.01</span><span class="pl-k">*</span><span class="pl-c1">randn</span>(<span class="pl-c1">length</span>(xdata))
p0 <span class="pl-k">=</span> [<span class="pl-c1">0.5</span>, <span class="pl-c1">0.5</span>]

<span class="pl-k">using</span> ForwardDiff
<span class="pl-k">function</span> <span class="pl-en">F</span>(p)
  <span class="pl-c1">model</span>(xdata, p)
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">J</span>(p)
  ForwardDiff<span class="pl-k">.</span><span class="pl-c1">jacobian</span>(F, p)
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">obj</span>(_J, _F, x)
    f <span class="pl-k">=</span> <span class="pl-c1">F</span>(x)
    j <span class="pl-k">=</span> _J <span class="pl-k">isa</span> Nothing ? _J : <span class="pl-c1">J</span>(x)
    <span class="pl-c1">objective_return</span>(f, j)
<span class="pl-k">end</span>
od <span class="pl-k">=</span> <span class="pl-c1">OnceDiffed</span>(obj)
lw <span class="pl-k">=</span> <span class="pl-c1">LsqWrapper1</span>(od, <span class="pl-c1">true</span>, <span class="pl-c1">true</span>)</pre></div>
<h1><a id="user-content-next-steps" class="anchor" aria-hidden="true" href="#next-steps"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>next steps</h1>
<p>Mixed complementatiry
SAMIN, BOXES, Projected solver
Univariate!!
IP Newotn
Krylov Hessian
LsqFit wrapper</p>
</article></div>