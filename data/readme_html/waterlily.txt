<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-waterlilyjl" class="anchor" aria-hidden="true" href="#waterlilyjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>WaterLily.jl</h1>
<p dir="auto"><a href="https://weymouth.github.io/WaterLily.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/weymouth/WaterLily.jl/actions"><img src="https://github.com/weymouth/WaterLily.jl/workflows/CI/badge.svg?branch=master&amp;event=push" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/weymouth/WaterLily.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ee68fb5a75cebe57d4f971163db9ab35b8da84e97f0ef09d0965540f17f22dec/68747470733a2f2f636f6465636f762e696f2f67682f7765796d6f7574682f57617465724c696c792e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d38585946574b4f55464e" alt="codecov" data-canonical-src="https://codecov.io/gh/weymouth/WaterLily.jl/branch/master/graph/badge.svg?token=8XYFWKOUFN" style="max-width: 100%;"></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="examples/julia.gif"><img src="examples/julia.gif" alt="Julia flow" data-animated-image="" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h2>
<p dir="auto">WaterLily.jl is a simple and fast fluid simulator written in pure Julia. This is an experimental project to take advantage of the active scientific community in Julia to accelerate and enhance fluid simulations. Watch the JuliaCon2021 talk here:</p>
<p dir="auto"><a href="https://youtu.be/YsPkfZqbNSQ" rel="nofollow"><img src="examples/JuliaCon2021.jpg" alt="JuliaCon2021 Youtube still and link" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-methodcapabilities" class="anchor" aria-hidden="true" href="#methodcapabilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Method/capabilities</h2>
<p dir="auto">WaterLily.jl solves the unsteady incompressible 2D or 3D <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations" rel="nofollow">Navier-Stokes equations</a> on a Cartesian grid. The pressure Poisson equation is solved with a <a href="https://en.wikipedia.org/wiki/Multigrid_method" rel="nofollow">geometric multigrid</a> method. Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/" rel="nofollow">Boundary Data Immersion Method</a>. The solver can run on serial CPU, multi-threaded CPU, or GPU backends.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">The user can set the boundary conditions, the initial velocity field, the fluid viscosity (which determines the <a href="https://en.wikipedia.org/wiki/Reynolds_number" rel="nofollow">Reynolds number</a>), and immerse solid obstacles using a signed distance function. These examples and others are found in the <a href="examples">examples</a>.</p>
<h3 dir="auto"><a id="user-content-flow-over-a-circle" class="anchor" aria-hidden="true" href="#flow-over-a-circle"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Flow over a circle</h3>
<p dir="auto">We define the size of the simulation domain as <code>n</code>x<code>m</code> cells. The circle has radius <code>m/8</code> and is centered at <code>(m/2,m/2)</code>. The flow boundary conditions are <code>(U=1,0)</code> and Reynolds number is <code>Re=U*radius/ν</code> where <code>ν</code> (Greek "nu" U+03BD, not Latin lowercase "v") is the kinematic viscosity of the fluid.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using WaterLily
function circle(n,m;Re=250,U=1)
    radius, center = m/8, m/2
    body = AutoBody((x,t)-&gt;√sum(abs2, x .- center) - radius)
    Simulation((n,m), (U,0), radius; ν=U*radius/Re, body)
end"><pre><span class="pl-k">using</span> WaterLily
<span class="pl-k">function</span> <span class="pl-en">circle</span>(n,m;Re<span class="pl-k">=</span><span class="pl-c1">250</span>,U<span class="pl-k">=</span><span class="pl-c1">1</span>)
    radius, center <span class="pl-k">=</span> m<span class="pl-k">/</span><span class="pl-c1">8</span>, m<span class="pl-k">/</span><span class="pl-c1">2</span>
    body <span class="pl-k">=</span> <span class="pl-c1">AutoBody</span>((x,t)<span class="pl-k">-&gt;</span><span class="pl-k">√</span><span class="pl-c1">sum</span>(abs2, x <span class="pl-k">.-</span> center) <span class="pl-k">-</span> radius)
    <span class="pl-c1">Simulation</span>((n,m), (U,<span class="pl-c1">0</span>), radius; ν<span class="pl-k">=</span>U<span class="pl-k">*</span>radius<span class="pl-k">/</span>Re, body)
<span class="pl-k">end</span></pre></div>
<p dir="auto">The second to last line defines the circle geometry using a <a href="https://en.wikipedia.org/wiki/Signed_distance_function#Applications" rel="nofollow">signed distance function</a>. The <code>AutoBody</code> function uses <a href="https://github.com/JuliaDiff/">automatic differentiation</a> to infer the other geometric parameter automatically. Replace the circle's distance function with any other, and now you have the flow around something else... such as a <a href="examples/ThreeD_donut.jl">donut</a> or the <a href="examples/TwoD_Julia.jl">Julia logo</a>. Finally, the last line defines the <code>Simulation</code> by passing in parameters we've defined.</p>
<p dir="auto">Now we can create a simulation (first line) and run it forward in time (third line)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="circ = circle(3*2^6,2^7)
t_end = 10
sim_step!(circ,t_end)"><pre>circ <span class="pl-k">=</span> <span class="pl-c1">circle</span>(<span class="pl-c1">3</span><span class="pl-k">*</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">6</span>,<span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">7</span>)
t_end <span class="pl-k">=</span> <span class="pl-c1">10</span>
<span class="pl-c1">sim_step!</span>(circ,t_end)</pre></div>
<p dir="auto">Note we've set <code>n,m</code> to be multiples of powers of 2, which is important when using the (very fast) Multi-Grid solver. We can now access and plot whatever variables we like. For example, we could print the velocity at <code>I::CartesianIndex</code> using <code>println(circ.flow.u[I])</code> or plot the whole pressure field using</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Plots
contour(circ.flow.p')"><pre><span class="pl-k">using</span> Plots
<span class="pl-c1">contour</span>(circ<span class="pl-k">.</span>flow<span class="pl-k">.</span>p<span class="pl-k">'</span>)</pre></div>
<p dir="auto">A set of <a href="src/Metrics.jl">flow metric functions</a> have been implemented and the examples use these to make gifs such as the one above.</p>
<h3 dir="auto"><a id="user-content-3d-taylor-green-vortex" class="anchor" aria-hidden="true" href="#3d-taylor-green-vortex"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3D Taylor Green Vortex</h3>
<p dir="auto">The three-dimensional <a href="examples/ThreeD_TaylorGreenVortex.jl">Taylor Green Vortex</a> demonstrates many of the other available simulation options. First, you can simulate a nontrivial initial velocity field by passing in a vector function <code>uλ(i,xyz)</code> where <code>i ∈ (1,2,3)</code> indicates the velocity component <code>uᵢ</code> and <code>xyz=[x,y,z]</code> is the position vector.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function TGV(; pow=6, Re=1e5, T=Float64, mem=Array)
    # Define vortex size, velocity, viscosity
    L = 2^pow; U = 1; ν = U*L/Re
    # Taylor-Green-Vortex initial velocity field
    function uλ(i,xyz)
        x,y,z = @. (xyz-1.5)*π/L               # scaled coordinates
        i==1 &amp;&amp; return -U*sin(x)*cos(y)*cos(z) # u_x
        i==2 &amp;&amp; return  U*cos(x)*sin(y)*cos(z) # u_y
        return 0.                              # u_z
    end
    # Initialize simulation
    return Simulation((L, L, L), (0, 0, 0), L; U, uλ, ν, T, mem)
end"><pre><span class="pl-k">function</span> <span class="pl-en">TGV</span>(; pow<span class="pl-k">=</span><span class="pl-c1">6</span>, Re<span class="pl-k">=</span><span class="pl-c1">1e5</span>, T<span class="pl-k">=</span>Float64, mem<span class="pl-k">=</span>Array)
    <span class="pl-c"><span class="pl-c">#</span> Define vortex size, velocity, viscosity</span>
    L <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">^</span>pow; U <span class="pl-k">=</span> <span class="pl-c1">1</span>; ν <span class="pl-k">=</span> U<span class="pl-k">*</span>L<span class="pl-k">/</span>Re
    <span class="pl-c"><span class="pl-c">#</span> Taylor-Green-Vortex initial velocity field</span>
    <span class="pl-k">function</span> <span class="pl-en">uλ</span>(i,xyz)
        x,y,z <span class="pl-k">=</span> <span class="pl-c1">@.</span> (xyz<span class="pl-k">-</span><span class="pl-c1">1.5</span>)<span class="pl-k">*</span>π<span class="pl-k">/</span>L               <span class="pl-c"><span class="pl-c">#</span> scaled coordinates</span>
        i<span class="pl-k">==</span><span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">return</span> <span class="pl-k">-</span>U<span class="pl-k">*</span><span class="pl-c1">sin</span>(x)<span class="pl-k">*</span><span class="pl-c1">cos</span>(y)<span class="pl-k">*</span><span class="pl-c1">cos</span>(z) <span class="pl-c"><span class="pl-c">#</span> u_x</span>
        i<span class="pl-k">==</span><span class="pl-c1">2</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">return</span>  U<span class="pl-k">*</span><span class="pl-c1">cos</span>(x)<span class="pl-k">*</span><span class="pl-c1">sin</span>(y)<span class="pl-k">*</span><span class="pl-c1">cos</span>(z) <span class="pl-c"><span class="pl-c">#</span> u_y</span>
        <span class="pl-k">return</span> <span class="pl-c1">0.</span>                              <span class="pl-c"><span class="pl-c">#</span> u_z</span>
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span> Initialize simulation</span>
    <span class="pl-k">return</span> <span class="pl-c1">Simulation</span>((L, L, L), (<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>), L; U, uλ, ν, T, mem)
<span class="pl-k">end</span></pre></div>
<p dir="auto">This example also demonstrates the floating point type (<code>T=Float64</code>) and array memory type (<code>mem=Array</code>) options. For example, to run on an NVIDIA GPU we only need to import the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> library and initialize the <code>Simulation</code> memory on that device.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import CUDA
@assert CUDA.functional()
vortex = TGV(T=Float32,mem=CUDA.CuArray)
sim_step!(vortex,1)"><pre><span class="pl-k">import</span> CUDA
<span class="pl-c1">@assert</span> CUDA<span class="pl-k">.</span><span class="pl-c1">functional</span>()
vortex <span class="pl-k">=</span> <span class="pl-c1">TGV</span>(T<span class="pl-k">=</span>Float32,mem<span class="pl-k">=</span>CUDA<span class="pl-k">.</span>CuArray)
<span class="pl-c1">sim_step!</span>(vortex,<span class="pl-c1">1</span>)</pre></div>
<p dir="auto">For an AMD GPU, use <code>import AMDGPU</code> and <code>mem=AMDGPU.ROCArray</code>. Note that Julia 1.9 is required for AMD GPUs.</p>
<h3 dir="auto"><a id="user-content-moving-bodies" class="anchor" aria-hidden="true" href="#moving-bodies"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Moving bodies</h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="examples/hover.gif"><img src="examples/hover.gif" alt="Flapping line segment flow" data-animated-image="" style="max-width: 100%;"></a></p>
<p dir="auto">You can simulate moving bodies in Waterlily by passing a coordinate <code>map</code> to <code>AutoBody</code> in addition to the <code>sdf</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using StaticArrays
function hover(L=2^5;Re=250,U=1,amp=π/4,ϵ=0.5,thk=2ϵ+√2)
    # Line segment SDF
    function sdf(x,t)
        y = x .- SA[0,clamp(x[2],-L/2,L/2)]
        √sum(abs2,y)-thk/2
    end
    # Oscillating motion and rotation
    function map(x,t)
        α = amp*cos(t*U/L); R = SA[cos(α) sin(α); -sin(α) cos(α)]
        R * (x - SA[3L-L*sin(t*U/L),4L])
    end
    Simulation((6L,6L),(0,0),L;U,ν=U*L/Re,body=AutoBody(sdf,map),ϵ)
end"><pre><span class="pl-k">using</span> StaticArrays
<span class="pl-k">function</span> <span class="pl-en">hover</span>(L<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">5</span>;Re<span class="pl-k">=</span><span class="pl-c1">250</span>,U<span class="pl-k">=</span><span class="pl-c1">1</span>,amp<span class="pl-k">=</span>π<span class="pl-k">/</span><span class="pl-c1">4</span>,ϵ<span class="pl-k">=</span><span class="pl-c1">0.5</span>,thk<span class="pl-k">=</span><span class="pl-c1">2</span>ϵ<span class="pl-k">+√</span><span class="pl-c1">2</span>)
    <span class="pl-c"><span class="pl-c">#</span> Line segment SDF</span>
    <span class="pl-k">function</span> <span class="pl-en">sdf</span>(x,t)
        y <span class="pl-k">=</span> x <span class="pl-k">.-</span> SA[<span class="pl-c1">0</span>,<span class="pl-c1">clamp</span>(x[<span class="pl-c1">2</span>],<span class="pl-k">-</span>L<span class="pl-k">/</span><span class="pl-c1">2</span>,L<span class="pl-k">/</span><span class="pl-c1">2</span>)]
        <span class="pl-k">√</span><span class="pl-c1">sum</span>(abs2,y)<span class="pl-k">-</span>thk<span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span> Oscillating motion and rotation</span>
    <span class="pl-k">function</span> <span class="pl-en">map</span>(x,t)
        α <span class="pl-k">=</span> amp<span class="pl-k">*</span><span class="pl-c1">cos</span>(t<span class="pl-k">*</span>U<span class="pl-k">/</span>L); R <span class="pl-k">=</span> SA[<span class="pl-c1">cos</span>(α) <span class="pl-c1">sin</span>(α); <span class="pl-k">-</span><span class="pl-c1">sin</span>(α) <span class="pl-c1">cos</span>(α)]
        R <span class="pl-k">*</span> (x <span class="pl-k">-</span> SA[<span class="pl-c1">3</span>L<span class="pl-k">-</span>L<span class="pl-k">*</span><span class="pl-c1">sin</span>(t<span class="pl-k">*</span>U<span class="pl-k">/</span>L),<span class="pl-c1">4</span>L])
    <span class="pl-k">end</span>
    <span class="pl-c1">Simulation</span>((<span class="pl-c1">6</span>L,<span class="pl-c1">6</span>L),(<span class="pl-c1">0</span>,<span class="pl-c1">0</span>),L;U,ν<span class="pl-k">=</span>U<span class="pl-k">*</span>L<span class="pl-k">/</span>Re,body<span class="pl-k">=</span><span class="pl-c1">AutoBody</span>(sdf,map),ϵ)
<span class="pl-k">end</span></pre></div>
<p dir="auto">In this example, the <code>sdf</code> function defines a line segment from <code>-L/2 ≤ x[2] ≤ L/2</code> with a thickness <code>thk</code>. To make the line segment move, we define a coordinate tranformation function <code>map(x,t)</code>. In this example, the coordinate <code>x</code> is shifted by <code>(3L,4L)</code> at time <code>t=0</code>, which moves the center of the segment to this point. However, the horizontal shift varies harmonically in time, sweeping the segment left and right during the simulation. The example also rotates the segment using the rotation matrix <code>R = [cos(α) sin(α); -sin(α) cos(α)]</code> where the angle <code>α</code> is also varied harmonically. The combined result is a thin flapping line, similar to a cross-section of a hovering insect wing.</p>
<p dir="auto">One important thing to note here is the use of <code>StaticArrays</code> to define the <code>sdf</code> and <code>map</code>. This speeds up the simulation since it eliminates allocations at every grid cell and time step.</p>
<h2 dir="auto"><a id="user-content-multi-threading-and-gpu-backends" class="anchor" aria-hidden="true" href="#multi-threading-and-gpu-backends"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multi-threading and GPU backends</h2>
<p dir="auto">WaterLily uses <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> to multi-thread on CPU and run on GPU backends. The implementation method and speed-up are documented in our <a href="https://arxiv.org/abs/2304.08159" rel="nofollow">ParCFD abstract</a>. In summary, a single macro <code>WaterLily.@loop</code> is used for nearly every loop in the code base, and this uses KernelAbstractactions to generate optimized code for each back-end. The speed-up is more pronounce for large simulations, and we've <a href="benchmark/donut/donut.jl">benchmarked</a> up to 23x-speed up on a Intel Core i7-10750H x6 processor, and 182x speed-up NVIDIA GeForce GTX 1650 Ti GPU card.</p>
<p dir="auto">Note that multi-threading requires <em>starting</em> Julia with the  <code>--threads</code> argument, see <a href="https://docs.julialang.org/en/v1/manual/multi-threading/" rel="nofollow">the multi-threading section</a> of the manual. If you are running Julia with multiple threads, KernelAbstractions will detect this and multi-thread the loops automatically. As in the Taylor-Green-Vortex examples above, running on a GPU requires initializing the <code>Simulation</code> memory on the GPU, and care needs to be taken to move the data back to the CPU for visualization. See <a href="examples/ThreeD_jelly.jl">jelly fish</a> for another non-trivial example.</p>
<p dir="auto">Finally, KernelAbstractions does incur some CPU allocations for every loop, but other than this <code>sim_step!</code> is completely non-allocating. This is one reason why the speed-up improves as the size of the simulation increases.</p>
<h2 dir="auto"><a id="user-content-development-goals" class="anchor" aria-hidden="true" href="#development-goals"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Development goals</h2>
<ul dir="auto">
<li>Immerse obstacles defined by 3D meshes using <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics</a>.</li>
<li>Multi-CPU/GPU simulations.</li>
<li>Add free-surface physics with Volume-of-Fluid or Level-Set.</li>
<li>Add external potential-flow domain boundary conditions.</li>
</ul>
<p dir="auto">If you have other suggestions or want to help, please raise an issue on github.</p>
</article></div>