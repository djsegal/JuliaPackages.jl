<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-srcwajl" class="anchor" aria-hidden="true" href="#srcwajl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SRCWA.jl</h1>
<p>Scatter-matrix Rigorously Coupled Wave Analysis implemented in Julia</p>
<p>This solves Maxwell's equations for periodically patterned multilayers of optically isotropic materials, currently supporting the computation of reflection, transmission and layerwise absorption for arbitrary plane wave incidence.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<h3><a id="user-content-defining-a-reciprocal-space-grid" class="anchor" aria-hidden="true" href="#defining-a-reciprocal-space-grid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Defining a reciprocal space grid</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using SRCWA
Nx=Ny=3#maximum order of the reciprocal space vector in x and y
nx,ny,dnx,dny=grid_n(Nx,Ny)#create grids in reciprocal space
"><pre><span class="pl-k">using</span> SRCWA
Nx<span class="pl-k">=</span>Ny<span class="pl-k">=</span><span class="pl-c1">3</span><span class="pl-c"><span class="pl-c">#</span>maximum order of the reciprocal space vector in x and y</span>
nx,ny,dnx,dny<span class="pl-k">=</span><span class="pl-c1">grid_n</span>(Nx,Ny)<span class="pl-c"><span class="pl-c">#</span>create grids in reciprocal space</span></pre></div>
<p>SRCWA solves Maxwell equtions in reciprocal space. All electric and magnetic fields are dealt with in terms of frequency $k_0$, reciprocal space x and y wavevector $k_x$ and $k_y$, and real space z coordinate $z$. Nx and Ny define the highes index of the reciprocal lattice vector, so Nx=0 gives only zeroth order and a one-element vector while Nx=1 gives the three-element vector (-1,0,1). Higher orders give higher accuracy in the result at the cost of higher computation time. When dealing with structures that are homeogenous in one or both lateral directions, the resulting order can be left at zero.</p>
<h3><a id="user-content-scaling-the-grid-to-the-desired-frequency-and-periodicity" class="anchor" aria-hidden="true" href="#scaling-the-grid-to-the-desired-frequency-and-periodicity"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Scaling the grid to the desired frequency and periodicity</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="theta=1E-5#incident angle in degrees between propagation direction and surface normal
phi=0#azimuth angle in degrees
lambda=1000#wavelength
ax=ay=1000#uni cell size in x and y
epsilon_ref=1#reflection halfspace (space above the device) relative permittivity
k0,Kx,Ky,kin=grid_k(nx,ny,theta,phi,lambda,ax,ay,epsilon_ref)
"><pre>theta<span class="pl-k">=</span><span class="pl-c1">1E-5</span><span class="pl-c"><span class="pl-c">#</span>incident angle in degrees between propagation direction and surface normal</span>
phi<span class="pl-k">=</span><span class="pl-c1">0</span><span class="pl-c"><span class="pl-c">#</span>azimuth angle in degrees</span>
lambda<span class="pl-k">=</span><span class="pl-c1">1000</span><span class="pl-c"><span class="pl-c">#</span>wavelength</span>
ax<span class="pl-k">=</span>ay<span class="pl-k">=</span><span class="pl-c1">1000</span><span class="pl-c"><span class="pl-c">#</span>uni cell size in x and y</span>
epsilon_ref<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-c"><span class="pl-c">#</span>reflection halfspace (space above the device) relative permittivity</span>
k0,Kx,Ky,kin<span class="pl-k">=</span><span class="pl-c1">grid_k</span>(nx,ny,theta,phi,lambda,ax,ay,epsilon_ref)</pre></div>
<p>In order to obtain the reciprocal lattice vectors, one has to define the incident wavelength and real space unit cell size and scale the grid by these. This RCWA implementation works for arbitrary plane wave incidence conditions. However, $\theta$ should not be set to zero in order to avoid numerical singularities. One can find a sufficiently small angle where other numerical errors overshadow the problem of imperfectly normal incidence. The choice of the length units for wavelength and cell size is arbitrary, but must be consistent.</p>
<p>The returned values are the free-space wavevector aka frequency $k_0$ and diagonal matrices of the lateral reciprocal wave vectors Kx and Ky. kin is the incident wave vector required for the calculation of the normalized field components of the impinging plane wave.</p>
<h3><a id="user-content-reflection-and-transmission-halfspace" class="anchor" aria-hidden="true" href="#reflection-and-transmission-halfspace"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reflection and Transmission halfspace</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
epsilon_tra=4#transmission halfspace relative permittivity
refspace=halfspace(Kx,Ky,epsilon_ref)#reflection halfspace effective impedance and modes
traspace=halfspace(Kx,Ky,epsilon_tra)#transmission halfspace effective impedance and modes
V0,Kz0=modes_freespace(Kx,Ky)#free space effective impedance and modes for normalization
Sref=matrix_ref(refspace,V0)#scattering matrix of the reflection halfspace
Stra=matrix_tra(traspace,V0)#scattering matrix of the transmission halfspace
"><pre>epsilon_tra<span class="pl-k">=</span><span class="pl-c1">4</span><span class="pl-c"><span class="pl-c">#</span>transmission halfspace relative permittivity</span>
refspace<span class="pl-k">=</span><span class="pl-c1">halfspace</span>(Kx,Ky,epsilon_ref)<span class="pl-c"><span class="pl-c">#</span>reflection halfspace effective impedance and modes</span>
traspace<span class="pl-k">=</span><span class="pl-c1">halfspace</span>(Kx,Ky,epsilon_tra)<span class="pl-c"><span class="pl-c">#</span>transmission halfspace effective impedance and modes</span>
V0,Kz0<span class="pl-k">=</span><span class="pl-c1">modes_freespace</span>(Kx,Ky)<span class="pl-c"><span class="pl-c">#</span>free space effective impedance and modes for normalization</span>
Sref<span class="pl-k">=</span><span class="pl-c1">matrix_ref</span>(refspace,V0)<span class="pl-c"><span class="pl-c">#</span>scattering matrix of the reflection halfspace</span>
Stra<span class="pl-k">=</span><span class="pl-c1">matrix_tra</span>(traspace,V0)<span class="pl-c"><span class="pl-c">#</span>scattering matrix of the transmission halfspace</span></pre></div>
<p>Any SRCWA computation will require the scattering matrices of the halfspaces above (reflection) and below (transmission) the device of interest. They are modeled with zero thickness, corresponding to the measurement of the plane wave directly at the device, without additional propagation losses or phase shift. The computation is done in two steps. Firstly the effective impedance of the halfspaces is calculated, then it is normalized with that of free space. A minimal simulation model, which basically just yields the same as Fresnel's equation, is comprised of a transmission and reflection layer.</p>
<h3><a id="user-content-building-a-device-layer-by-layer" class="anchor" aria-hidden="true" href="#building-a-device-layer-by-layer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Building a device layer by layer</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="t1=100#thickness, same units as wavelength
eps1=2#relative permittivity
l1=layer_plain(Kx,Ky,k0,t1,eps1)#compute modes of a plain layer
S1=matrix_layer(l1,V0)#compute the scattering matrix of l1

eps2a=2#permittivity inside the inclusion of layer 2
eps2b=3+1im#permittivity outside the inclusion of layer 2
fill_x=fill_y=.5#fill factor of inclusion in x and y
F=circft(fill_x,dnx,dny)# Fourier transform of a circular inclusion in real space into reciprocal space
F=ellipft(fill_x,fill_y,dnx,dny)# Fourier transform of an elliptic inclusion in real space into reciprocal space
F=rectft(fill_x,fill_y,dnx,dny)# Fourier transform of a rectangular inclusion in real space into reciprocal space

using LinearAlgebra
eps2=eps2a*F+eps2b*(I-F)#the permittivity distribution of layer 2 in reciprocal space
t2=200#thickness of layer 2
l2=layer_patterned(Kx,Ky,k0,t2,eps2)#compute modes of a patterned layer
S2=matrix_layer(l2,V0)#compute the scattering matrix of l2

S=concatenate([Sref,S1,S2,Stra])
"><pre>t1<span class="pl-k">=</span><span class="pl-c1">100</span><span class="pl-c"><span class="pl-c">#</span>thickness, same units as wavelength</span>
eps1<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-c"><span class="pl-c">#</span>relative permittivity</span>
l1<span class="pl-k">=</span><span class="pl-c1">layer_plain</span>(Kx,Ky,k0,t1,eps1)<span class="pl-c"><span class="pl-c">#</span>compute modes of a plain layer</span>
S1<span class="pl-k">=</span><span class="pl-c1">matrix_layer</span>(l1,V0)<span class="pl-c"><span class="pl-c">#</span>compute the scattering matrix of l1</span>

eps2a<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-c"><span class="pl-c">#</span>permittivity inside the inclusion of layer 2</span>
eps2b<span class="pl-k">=</span><span class="pl-c1">3</span><span class="pl-k">+</span><span class="pl-c1">1im</span><span class="pl-c"><span class="pl-c">#</span>permittivity outside the inclusion of layer 2</span>
fill_x<span class="pl-k">=</span>fill_y<span class="pl-k">=</span><span class="pl-c1">.5</span><span class="pl-c"><span class="pl-c">#</span>fill factor of inclusion in x and y</span>
F<span class="pl-k">=</span><span class="pl-c1">circft</span>(fill_x,dnx,dny)<span class="pl-c"><span class="pl-c">#</span> Fourier transform of a circular inclusion in real space into reciprocal space</span>
F<span class="pl-k">=</span><span class="pl-c1">ellipft</span>(fill_x,fill_y,dnx,dny)<span class="pl-c"><span class="pl-c">#</span> Fourier transform of an elliptic inclusion in real space into reciprocal space</span>
F<span class="pl-k">=</span><span class="pl-c1">rectft</span>(fill_x,fill_y,dnx,dny)<span class="pl-c"><span class="pl-c">#</span> Fourier transform of a rectangular inclusion in real space into reciprocal space</span>

<span class="pl-k">using</span> LinearAlgebra
eps2<span class="pl-k">=</span>eps2a<span class="pl-k">*</span>F<span class="pl-k">+</span>eps2b<span class="pl-k">*</span>(I<span class="pl-k">-</span>F)<span class="pl-c"><span class="pl-c">#</span>the permittivity distribution of layer 2 in reciprocal space</span>
t2<span class="pl-k">=</span><span class="pl-c1">200</span><span class="pl-c"><span class="pl-c">#</span>thickness of layer 2</span>
l2<span class="pl-k">=</span><span class="pl-c1">layer_patterned</span>(Kx,Ky,k0,t2,eps2)<span class="pl-c"><span class="pl-c">#</span>compute modes of a patterned layer</span>
S2<span class="pl-k">=</span><span class="pl-c1">matrix_layer</span>(l2,V0)<span class="pl-c"><span class="pl-c">#</span>compute the scattering matrix of l2</span>

S<span class="pl-k">=</span><span class="pl-c1">concatenate</span>([Sref,S1,S2,Stra])</pre></div>
<p>Plain layers with a homogenous relative permittivity can be constructed in a simple way, similar to the transmission and reflection halfspaces. In addition to their different relative impedance, they incorporate absorption and phase shift.</p>
<p>For patterned layers, the permittivity is given as a function of the reciprocal space vector, obtained by Fourier transform. This will make the waves different reciprocal lattice vectors propagate with different effective permittivities, and couple with each other at interfaces.</p>
<p>The scattering matrix of the full device can then be obtained from the individual scattering matrices.</p>
<h3><a id="user-content-reflection-and-transmission" class="anchor" aria-hidden="true" href="#reflection-and-transmission"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reflection and transmission</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="a0te,a0tm=prepare_source(kin,refspace.W,Nx,Ny)#calculate the amplitudes of the impinging plane wave for te or tm polarization
aRte=S.S11*a0te#reflected wave for incident TE
Rte=a2p(aRte,refspace,Kx,Ky,kin[3])#reflected power for incident TE
aTte=S.S21*a0te#transmitted wave for incident TE
Tte=a2p(aTte,traspace,Kx,Ky,kin[3])#transmitted power for incident TE
aRtm=S.S11*a0tm#reflected wave for incident TM
Rtm=a2p(aRtm,refspace,Kx,Ky,kin[3])#reflected power for incident TM
aTtm=S.S21*a0tm#transmitted wave for incident TM
Ttm=a2p(aTtm,traspace,Kx,Ky,kin[3])#transmitted power for incident TM
"><pre>a0te,a0tm<span class="pl-k">=</span><span class="pl-c1">prepare_source</span>(kin,refspace<span class="pl-k">.</span>W,Nx,Ny)<span class="pl-c"><span class="pl-c">#</span>calculate the amplitudes of the impinging plane wave for te or tm polarization</span>
aRte<span class="pl-k">=</span>S<span class="pl-k">.</span>S11<span class="pl-k">*</span>a0te<span class="pl-c"><span class="pl-c">#</span>reflected wave for incident TE</span>
Rte<span class="pl-k">=</span><span class="pl-c1">a2p</span>(aRte,refspace,Kx,Ky,kin[<span class="pl-c1">3</span>])<span class="pl-c"><span class="pl-c">#</span>reflected power for incident TE</span>
aTte<span class="pl-k">=</span>S<span class="pl-k">.</span>S21<span class="pl-k">*</span>a0te<span class="pl-c"><span class="pl-c">#</span>transmitted wave for incident TE</span>
Tte<span class="pl-k">=</span><span class="pl-c1">a2p</span>(aTte,traspace,Kx,Ky,kin[<span class="pl-c1">3</span>])<span class="pl-c"><span class="pl-c">#</span>transmitted power for incident TE</span>
aRtm<span class="pl-k">=</span>S<span class="pl-k">.</span>S11<span class="pl-k">*</span>a0tm<span class="pl-c"><span class="pl-c">#</span>reflected wave for incident TM</span>
Rtm<span class="pl-k">=</span><span class="pl-c1">a2p</span>(aRtm,refspace,Kx,Ky,kin[<span class="pl-c1">3</span>])<span class="pl-c"><span class="pl-c">#</span>reflected power for incident TM</span>
aTtm<span class="pl-k">=</span>S<span class="pl-k">.</span>S21<span class="pl-k">*</span>a0tm<span class="pl-c"><span class="pl-c">#</span>transmitted wave for incident TM</span>
Ttm<span class="pl-k">=</span><span class="pl-c1">a2p</span>(aTtm,traspace,Kx,Ky,kin[<span class="pl-c1">3</span>])<span class="pl-c"><span class="pl-c">#</span>transmitted power for incident TM</span></pre></div>
<p>With the scattering matrix constructed, it is easy to compute transmitted and reflected wave amplitudes and power for TE and TM incident polarizations.</p>
<h3><a id="user-content-absorption" class="anchor" aria-hidden="true" href="#absorption"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Absorption</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Sabove=concatenate([Sref,S1])#scatter matrix of the layers above the layer of interest
Sint=S2#layer of interest
Sbelow=Stra#scatter matrix of the layers below the layer of interest
Ate=absorption(Sabove,Sint,Sbelow,V0,a0te,kin[3])#Absorption in layer 2 for TE incidence
Atm=absorption(Sabove,Sint,Sbelow,V0,a0tm,kin[3])#Absorption in layer 2 for TM incidence
"><pre>Sabove<span class="pl-k">=</span><span class="pl-c1">concatenate</span>([Sref,S1])<span class="pl-c"><span class="pl-c">#</span>scatter matrix of the layers above the layer of interest</span>
Sint<span class="pl-k">=</span>S2<span class="pl-c"><span class="pl-c">#</span>layer of interest</span>
Sbelow<span class="pl-k">=</span>Stra<span class="pl-c"><span class="pl-c">#</span>scatter matrix of the layers below the layer of interest</span>
Ate<span class="pl-k">=</span><span class="pl-c1">absorption</span>(Sabove,Sint,Sbelow,V0,a0te,kin[<span class="pl-c1">3</span>])<span class="pl-c"><span class="pl-c">#</span>Absorption in layer 2 for TE incidence</span>
Atm<span class="pl-k">=</span><span class="pl-c1">absorption</span>(Sabove,Sint,Sbelow,V0,a0tm,kin[<span class="pl-c1">3</span>])<span class="pl-c"><span class="pl-c">#</span>Absorption in layer 2 for TM incidence</span></pre></div>
<p>This simple method calculates the absorption of a layer from the difference in the power of the electromagnetic wave entering and leaving the layer.</p>
<h3><a id="user-content-electric-and-magnetic-fields" class="anchor" aria-hidden="true" href="#electric-and-magnetic-fields"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Electric and magnetic fields</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="realgrid=grid_xy_square(51)#create a grid in real space for the data
Sabove=concatenate([Sref,S1])#scatter matrix of the layers above the layer of interest
Sint=S2#layer of interest
Sbelow=Stra#scatter matrix of the layers below the layer of interest
ain,aout,bin,bout=stackamp(Sabove,Sint,Sbelow,a0tm)#the amplitude vectors going into and out of the layer for tm incidence
e1h=field_expansion(ain,aout,bin,bout,l2,V0,100,Kx,Ky,Kz0,k0,nx,ny,realgrid)#calculate the fields in real space
"><pre>realgrid<span class="pl-k">=</span><span class="pl-c1">grid_xy_square</span>(<span class="pl-c1">51</span>)<span class="pl-c"><span class="pl-c">#</span>create a grid in real space for the data</span>
Sabove<span class="pl-k">=</span><span class="pl-c1">concatenate</span>([Sref,S1])<span class="pl-c"><span class="pl-c">#</span>scatter matrix of the layers above the layer of interest</span>
Sint<span class="pl-k">=</span>S2<span class="pl-c"><span class="pl-c">#</span>layer of interest</span>
Sbelow<span class="pl-k">=</span>Stra<span class="pl-c"><span class="pl-c">#</span>scatter matrix of the layers below the layer of interest</span>
ain,aout,bin,bout<span class="pl-k">=</span><span class="pl-c1">stackamp</span>(Sabove,Sint,Sbelow,a0tm)<span class="pl-c"><span class="pl-c">#</span>the amplitude vectors going into and out of the layer for tm incidence</span>
e1h<span class="pl-k">=</span><span class="pl-c1">field_expansion</span>(ain,aout,bin,bout,l2,V0,<span class="pl-c1">100</span>,Kx,Ky,Kz0,k0,nx,ny,realgrid)<span class="pl-c"><span class="pl-c">#</span>calculate the fields in real space</span></pre></div>
<p>The actual electric and magnetic fields inside the layers can be computed from the amplitudes using the eigenmodes of the layers. For this, the amplitudes of the plane wave components are transformed into the eigenstates of the layer, in order to compute the amplitude at each z-component. This is then converted to the components of the electric and magnetic field and transformed to real space with a given grid.</p>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>References</h2>
<ol>
<li>
<p>D. M. Whittaker and I. S. Culshaw, Scattering-matrix treatment of patterned multilayer photonic structures, Phys. Rev. B60(1999), 2610–2618.1</p>
</li>
<li>
<p>Marco Liscidini, Dario Gerace, Lucio Claudio Andreani, and J. E. Sipe, Scattering-matrix analysis of periodically patterned multilayers with asymmetric unit cells and birefringent media,Phys. Rev. B77(2008), 035324.1</p>
</li>
<li>
<p>Raymond Rumpf, Improved formulation of scattering matrices for semi-analytical methods thatis consistent with convention, Progress In Electromagnetics Research B35(2011), 241–261.1</p>
</li>
</ol>
</article></div>