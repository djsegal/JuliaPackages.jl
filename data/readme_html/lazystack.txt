<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-lazystackjl" class="anchor" aria-hidden="true" href="#lazystackjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LazyStack.jl</h1>
<p><a href="https://travis-ci.org/mcabbott/LazyStack.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/69b0bb3791bd321b69cb10719a671d7aacbee7f8/68747470733a2f2f7472617669732d63692e6f72672f6d636162626f74742f4c617a79537461636b2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/mcabbott/LazyStack.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p>This package exports one function, <code>stack</code>, for turning a list of arrays
into one <code>AbstractArray</code>. Given several arrays with the same <code>eltype</code>,
or an array of such arrays, it returns a lazy <code>Stacked{T,N}</code> view of these:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">stack</span>([<span class="pl-c1">zeros</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-c1">ones</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)])  <span class="pl-c"><span class="pl-c">#</span> isa Stacked{Float64, 3, &lt;:Vector{&lt;:Matrix}}</span>
<span class="pl-c1">stack</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>], <span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">6</span>)             <span class="pl-c"><span class="pl-c">#</span> isa Stacked{Int, 2, &lt;:Tuple{&lt;:Vector, &lt;:UnitRange}}</span></pre></div>
<p>Given a generator, it instead iterates through the elements and writes into a new array.
Given a function and then some arrays, it behaves like <code>map(f, A, B)</code> but immediately writes
into a new array:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">stack</span>([i,<span class="pl-c1">2</span>i] <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>)            <span class="pl-c"><span class="pl-c">#</span> isa Matrix{Int}     # size(ans) == (2, 5)</span>
<span class="pl-c1">stack</span>(<span class="pl-k">*</span>, <span class="pl-c1">eachcol</span>(<span class="pl-c1">ones</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>)), <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>)     <span class="pl-c"><span class="pl-c">#</span> == Matrix(stack(map(*, eachcol(...), 1:4)))</span></pre></div>
<p>The same <code>stack_iter</code> method is also used for any list of arrays of heterogeneous element type,
and for arrays of tuples. Notice that like <code>map(identity, Any[1, 1.0, 5im])</code>, this promotes using
<code>promote_typejoin</code>, to <code>Number</code> here, rather than to <code>Complex{Float64}</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">stack</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>], [<span class="pl-c1">3.0</span>, <span class="pl-c1">4.0</span>], [<span class="pl-c1">5im</span>, <span class="pl-c1">6im</span>])  <span class="pl-c"><span class="pl-c">#</span> isa Matrix{Number}  # size(ans) == (2, 3)</span>
<span class="pl-c1">stack</span>([(i,<span class="pl-c1">2.0</span>,<span class="pl-c1">3</span><span class="pl-k">//</span>j) <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>, j<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>])<span class="pl-c"><span class="pl-c">#</span> isa Array{Real, 3}  # size(ans) == (3, 4, 5)</span></pre></div>
<p>The slices must all have the same <code>size</code>, but they (and the container)
can have any number of dimensions. <code>stack</code> always places the slice dimensions first.
There are no options.</p>
<h3><a id="user-content-ragged-stack" class="anchor" aria-hidden="true" href="#ragged-stack"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ragged stack</h3>
<p>There is also a version which does not demand that slices have equal <code>size</code> (or equal <code>ndims</code>),
which always returns a new <code>Array</code>. You can control the position of slices <code>using OffsetArrays</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">rstack</span>([<span class="pl-c1">1</span><span class="pl-k">:</span>n <span class="pl-k">for</span> n <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>])           <span class="pl-c"><span class="pl-c">#</span> upper triangular Matrix{Int}</span>
<span class="pl-c1">rstack</span>(<span class="pl-c1">OffsetArray</span>(<span class="pl-c1">fill</span>(n,<span class="pl-c1">4</span>), <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) <span class="pl-k">for</span> n <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>; fill<span class="pl-k">=</span><span class="pl-c1">NaN</span>)</pre></div>
<h3><a id="user-content-other-packages" class="anchor" aria-hidden="true" href="#other-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other packages</h3>
<p>This one plays well with <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays.jl</a>,
<a href="https://github.com/invenia/NamedDims.jl">NamedDims.jl</a>, and
<a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>.</p>
<p>Besides which, there are several other ways to achieve similar things:</p>
<ul>
<li>For an array of arrays, you can also use <a href="https://bramtayl.github.io/JuliennedArrays.jl/latest/#JuliennedArrays.Align" rel="nofollow"><code>JuliennedArrays.Align</code></a>. This requires (or enables) you to specify which dimensions of the output belong to the sub-arrays, instead of writing <code>PermutedDimsArray(stack(...), ...)</code>.</li>
<li>There is also <a href="https://github.com/JuliaDiffEq/RecursiveArrayTools.jl#vectorofarray"><code>RecursiveArrayTools.VectorOfArray</code></a> which as its name hints only allows a one-dimensional container. Linear indexing retreives a slice, not an element, which is sometimes surprising.</li>
<li>For a tuple of arrays, <a href="https://github.com/JuliaArrays/LazyArrays.jl#concatenation"><code>LazyArrays.Hcat</code></a> is at present faster to index than <code>stack</code>, but doesn't allow arbitrary dimensions.</li>
<li>For a generator of arrays, the built-in <code>reduce(hcat,...)</code> may work, but it slow compared to <code>stack</code>: see <a href="test/speed.jl">test/speed.jl</a> for some examples.</li>
</ul>
<p>The package <a href="https://oschulz.github.io/ArraysOfArrays.jl/stable/#section_ArrayOfSimilarArrays-1" rel="nofollow">ArraysOfArrays.jl</a> solves the opposite problem, of accessing one large array as if it were many slices. As does <a href="https://bramtayl.github.io/JuliennedArrays.jl/latest/#JuliennedArrays.Slices-Union%7BTuple%7BNumberOfDimensions%7D,%20Tuple%7BItem%7D,%20Tuple%7BAbstractArray%7BItem,NumberOfDimensions%7D,Vararg%7BInt64,N%7D%20where%20N%7D%7D%20where%20NumberOfDimensions%20where%20Item" rel="nofollow"><code>JuliennedArrays.Slices</code></a>, and of course <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.eachslice" rel="nofollow"><code>Base.eachslice</code></a>.</p>
<p>Finally, after writing this I learned of <a href="https://github.com/JuliaLang/julia/pull/31644">julia/31644</a> which extends <code>reduce(hcat,...)</code> to work on generators.</p>
</article></div>