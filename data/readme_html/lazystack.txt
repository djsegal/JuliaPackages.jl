<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-lazystackjl" class="anchor" aria-hidden="true" href="#lazystackjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>LazyStack.jl</h1>
<p><a href="https://travis-ci.org/mcabbott/LazyStack.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f6e0dc54665b0c5b6345eea0f1fcbf0ecfec3a41add68d35bfdc020986af31d3/68747470733a2f2f7472617669732d63692e6f72672f6d636162626f74742f4c617a79537461636b2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/mcabbott/LazyStack.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p>This package exports one function, <code>stack</code>, for turning a list of arrays
into one <code>AbstractArray</code>. Given several arrays with the same <code>eltype</code>,
or an array of such arrays, it returns a lazy <code>Stacked{T,N}</code> view of these:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="stack([zeros(2,2), ones(2,2)])  # isa Stacked{Float64, 3, &lt;:Vector{&lt;:Matrix}}
stack([1,2,3], 4:6)             # isa Stacked{Int, 2, &lt;:Tuple{&lt;:Vector, &lt;:UnitRange}}
"><pre><span class="pl-c1">stack</span>([<span class="pl-c1">zeros</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-c1">ones</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)])  <span class="pl-c"><span class="pl-c">#</span> isa Stacked{Float64, 3, &lt;:Vector{&lt;:Matrix}}</span>
<span class="pl-c1">stack</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>], <span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">6</span>)             <span class="pl-c"><span class="pl-c">#</span> isa Stacked{Int, 2, &lt;:Tuple{&lt;:Vector, &lt;:UnitRange}}</span></pre></div>
<p>Given a generator, it instead iterates through the elements and writes into a new array.
Given a function and then some arrays, it behaves like <code>map(f, A, B)</code> but immediately writes
into a new array:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="stack([i,2i] for i in 1:5)            # isa Matrix{Int}     # size(ans) == (2, 5)
stack(*, eachcol(ones(2,4)), 1:4)     # == Matrix(stack(map(*, eachcol(...), 1:4)))
"><pre><span class="pl-c1">stack</span>([i,<span class="pl-c1">2</span>i] <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>)            <span class="pl-c"><span class="pl-c">#</span> isa Matrix{Int}     # size(ans) == (2, 5)</span>
<span class="pl-c1">stack</span>(<span class="pl-k">*</span>, <span class="pl-c1">eachcol</span>(<span class="pl-c1">ones</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>)), <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>)     <span class="pl-c"><span class="pl-c">#</span> == Matrix(stack(map(*, eachcol(...), 1:4)))</span></pre></div>
<p>The same <code>stack_iter</code> method is also used for any list of arrays of heterogeneous element type,
and for arrays of tuples. Notice that like <code>map(identity, Any[1, 1.0, 5im])</code>, this promotes using
<code>promote_typejoin</code>, to <code>Number</code> here, rather than to <code>Complex{Float64}</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="stack([1,2], [3.0, 4.0], [5im, 6im])  # isa Matrix{Number}  # size(ans) == (2, 3)
stack([(i,2.0,3//j) for i=1:4, j=1:5])# isa Array{Real, 3}  # size(ans) == (3, 4, 5)
"><pre><span class="pl-c1">stack</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>], [<span class="pl-c1">3.0</span>, <span class="pl-c1">4.0</span>], [<span class="pl-c1">5im</span>, <span class="pl-c1">6im</span>])  <span class="pl-c"><span class="pl-c">#</span> isa Matrix{Number}  # size(ans) == (2, 3)</span>
<span class="pl-c1">stack</span>([(i,<span class="pl-c1">2.0</span>,<span class="pl-c1">3</span><span class="pl-k">//</span>j) <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>, j<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>])<span class="pl-c"><span class="pl-c">#</span> isa Array{Real, 3}  # size(ans) == (3, 4, 5)</span></pre></div>
<p>The slices must all have the same <code>size</code>, but they (and the container)
can have any number of dimensions. <code>stack</code> always places the slice dimensions first.
There are no options.</p>
<h3><a id="user-content-ragged-stack" class="anchor" aria-hidden="true" href="#ragged-stack"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Ragged stack</h3>
<p>There is also a version which does not demand that slices have equal <code>size</code> (or equal <code>ndims</code>),
which always returns a new <code>Array</code>. You can control the position of slices <code>using OffsetArrays</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="rstack([1:n for n in 1:10])           # upper triangular Matrix{Int}
rstack(OffsetArray(fill(n,4), rand(-2:2)) for n in 1:10; fill=NaN)
"><pre><span class="pl-c1">rstack</span>([<span class="pl-c1">1</span><span class="pl-k">:</span>n <span class="pl-k">for</span> n <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>])           <span class="pl-c"><span class="pl-c">#</span> upper triangular Matrix{Int}</span>
<span class="pl-c1">rstack</span>(<span class="pl-c1">OffsetArray</span>(<span class="pl-c1">fill</span>(n,<span class="pl-c1">4</span>), <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) <span class="pl-k">for</span> n <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>; fill<span class="pl-k">=</span><span class="pl-c1">NaN</span>)</pre></div>
<h3><a id="user-content-other-packages" class="anchor" aria-hidden="true" href="#other-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Other packages</h3>
<p>This one plays well with <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays.jl</a>,
<a href="https://github.com/invenia/NamedDims.jl">NamedDims.jl</a>, and
<a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>.</p>
<p>Besides which, there are several other ways to achieve similar things:</p>
<ul>
<li>For an array of arrays, you can also use <a href="https://bramtayl.github.io/JuliennedArrays.jl/latest/#JuliennedArrays.Align" rel="nofollow"><code>JuliennedArrays.Align</code></a>. This requires (or enables) you to specify which dimensions of the output belong to the sub-arrays, instead of writing <code>PermutedDimsArray(stack(...), ...)</code>.</li>
<li>There is also <a href="https://github.com/JuliaDiffEq/RecursiveArrayTools.jl#vectorofarray"><code>RecursiveArrayTools.VectorOfArray</code></a> which as its name hints only allows a one-dimensional container. Linear indexing retreives a slice, not an element, which is sometimes surprising.</li>
<li>For a tuple of arrays, <a href="https://github.com/JuliaArrays/LazyArrays.jl#concatenation"><code>LazyArrays.Hcat</code></a> is at present faster to index than <code>stack</code>, but doesn't allow arbitrary dimensions.</li>
<li>For a generator of arrays, the built-in <code>reduce(hcat,...)</code> may work, but it slow compared to <code>stack</code>: see <a href="test/speed.jl">test/speed.jl</a> for some examples.</li>
</ul>
<p>And a few more:</p>
<ul>
<li>When writing this I missed <a href="https://github.com/JuliaData/SplitApplyCombine.jl#combinedimsviewarray"><code>SplitApplyCombine.combinedimsview</code></a>, which is very similar to <code>stack</code>, but doesn't handle tuples.</li>
<li>Newer than this is <a href="https://github.com/JuliaArrays/StackViews.jl">StackViews.jl</a> handles both, with <code>StackView(A,B,dims=4) == StackView([A,B],4)</code> creating a 4th dimension; the container is always one-dimensional.</li>
<li><a href="https://fluxml.ai/Flux.jl/stable/utilities/#Flux.stack" rel="nofollow"><code>Flux.stack</code></a> similarly takes a dimension, but eagerly creates an <code>Array</code>.</li>
</ul>
<p>The package <a href="https://github.com/JuliaArrays/ArraysOfArrays.jl">ArraysOfArrays.jl</a> solves the opposite problem, of accessing one large array as if it were many slices. As does <a href="https://bramtayl.github.io/JuliennedArrays.jl/latest/#JuliennedArrays.Slices-Union%7BTuple%7BNumberOfDimensions%7D,%20Tuple%7BItem%7D,%20Tuple%7BAbstractArray%7BItem,NumberOfDimensions%7D,Vararg%7BInt64,N%7D%20where%20N%7D%7D%20where%20NumberOfDimensions%20where%20Item" rel="nofollow"><code>JuliennedArrays.Slices</code></a>, and of course <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.eachslice" rel="nofollow"><code>Base.eachslice</code></a>.</p>
<p>After writing this I learned of <a href="https://github.com/JuliaLang/julia/pull/31644">JuliaLang#31644</a> which extends <code>reduce(hcat,...)</code> to work on generators. Also relevant is <a href="https://github.com/JuliaLang/julia/pull/32310">JuliaLang#32310</a> which extends <code>eachslice</code> to produce a multi-dimensional container.</p>
</article></div>