<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-feynmandiagram" class="anchor" aria-hidden="true" href="#feynmandiagram"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FeynmanDiagram</h1>
<p dir="auto"><a href="https://numericalEFT.github.io/FeynmanDiagram.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://numericalEFT.github.io/FeynmanDiagram.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/numericalEFT/FeynmanDiagram.jl/actions"><img src="https://github.com/numericalEFT/FeynmanDiagram.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/numericalEFT/FeynmanDiagram.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/6e2b451cc4508d46b6f0264804a1141e15b852bff2ba48283598e7b1e6530b35/68747470733a2f2f636f6465636f762e696f2f67682f6e756d65726963616c4546542f4665796e6d616e4469616772616d2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/numericalEFT/FeynmanDiagram.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package implements a mini-compiler that compiles generic Feynman diagrams into computational-graph representations for fast computation.</p>
<h2 dir="auto"><a id="user-content-infrastructure" class="anchor" aria-hidden="true" href="#infrastructure"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Infrastructure</h2>
<p dir="auto">In general, Feynman diagrams represents high-order integral. The integrand are propagators/interactions composed by the basis arithmetic operations (multiplication, addition). The sequence of calculating the integrand by combining the propagators/interactions with the arithmetic operatos can be represented as an algebraic computational graph. In this sense, the computational graph provides an intermediate representation (IR) for Feynman diagrams that completely independent of the diagram type.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="assets/diagram_compiler.svg?raw=true"><img src="assets/diagram_compiler.svg?raw=true" alt="infrastructure" title="Compiler Infrastructure" style="max-width: 100%;"></a></p>
<p dir="auto">Base on this observation, we develop a package to compile the integrand of Feynman diagrams into machine code so that one can evaluate the it efficiently. The infrastructure of this package is similar to the modern compiler LLVM for generic programming language. There are three layers: a front-end translates a source code into an IR as a computational graph, then a mid-end optimizes and transforms the IR, and a back-end to compiles the IR to machine code.</p>
<ul dir="auto">
<li>
<p dir="auto">The front-end supports Feynman diagrams from weak coupling expansion or strong coupling expansion. The user can incorprate new types of diagrams by writing their own front-end.</p>
</li>
<li>
<p dir="auto">The mid-end performs universal optimizations and transformations of one computational graph to another. The possible optimizations of the computational graph includes: remove common nodes/leaves, remove zero-valued nodes/leaves, merge small nodes into a large one. The possible transformations include automatic differentiation (which can be useful to derive the diagrams for the specific heat, RG flow equation, etc.), renormalization of the propagators and the interactions, and analytic Matsubara-frequency integration (work in progress).</p>
</li>
<li>
<p dir="auto">The back-end provides a universal subroutine to evalue the computational graph efficiently.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-supported-front-end" class="anchor" aria-hidden="true" href="#supported-front-end"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Supported Front-end</h2>
<h3 dir="auto"><a id="user-content-1-generic-weak-coupling-expansion-based-on-the-parquet-algorithm" class="anchor" aria-hidden="true" href="#1-generic-weak-coupling-expansion-based-on-the-parquet-algorithm"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>1. Generic Weak Coupling Expansion based on the Parquet Algorithm</h3>
<p dir="auto">This algorithm generates the Feynman diagrams of weak coupling expansion. It supports the diagrams of self-energy, polarization, 3-point vertex function and 4-point vertex function. The internal degrees of freedom can be either the loop variables (e.g., momentum or frequency) or the site variables (e.g., imaginary-time or lattice site).</p>
<p dir="auto">The main idea of the algorithm is to use the parquet equation to build high-order-vertex-function diagrams from the lower order sub-diagrams.</p>
<p dir="auto">The following code is a simple example to generate the one-loop 4-point vertex function diagrams, then visualize the computational graph (namely, an experssion tree).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FeynmanDiagram

# Define a parameter structure for the 4-vertex diagram with one-loop, in the momentum and the imaginary-time representation. Require the diagrams to be green's function irreducible.
para = DiagParaF64(type = Ver4Diag, innerLoopNum = 1,hasTau = true, filter=[NoHartree, Girreducible,])

ver4=Parquet.build(para) #build the diagram tree with the parquet algorithm.

plot_tree(ver4) # visualize the generated diagram tree

tree=ExprTree.build(ver4.diagram) #optimize the diagram tree to get an optimized expression tree"><pre><span class="pl-k">using</span> FeynmanDiagram

<span class="pl-c"><span class="pl-c">#</span> Define a parameter structure for the 4-vertex diagram with one-loop, in the momentum and the imaginary-time representation. Require the diagrams to be green's function irreducible.</span>
para <span class="pl-k">=</span> <span class="pl-c1">DiagParaF64</span>(type <span class="pl-k">=</span> Ver4Diag, innerLoopNum <span class="pl-k">=</span> <span class="pl-c1">1</span>,hasTau <span class="pl-k">=</span> <span class="pl-c1">true</span>, filter<span class="pl-k">=</span>[NoHartree, Girreducible,])

ver4<span class="pl-k">=</span>Parquet<span class="pl-k">.</span><span class="pl-c1">build</span>(para) <span class="pl-c"><span class="pl-c">#</span>build the diagram tree with the parquet algorithm.</span>

<span class="pl-c1">plot_tree</span>(ver4) <span class="pl-c"><span class="pl-c">#</span> visualize the generated diagram tree</span>

tree<span class="pl-k">=</span>ExprTree<span class="pl-k">.</span><span class="pl-c1">build</span>(ver4<span class="pl-k">.</span>diagram) <span class="pl-c"><span class="pl-c">#</span>optimize the diagram tree to get an optimized expression tree</span></pre></div>
<p dir="auto">The generated diagram tree is as shown in the following figure. The leaves of the tree are the propagators (labeled with <code>G</code>) and the interactions (labeled with <code>Ins</code>). By default, the interactions is assumed to spin-symmetric. A typical example is the Coulomb interaction.
<a target="_blank" rel="noopener noreferrer" href="assets/ver4tree.png?raw=true"><img src="assets/ver4tree.png?raw=true" alt="tree" title="Diagram Tree" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-2-generic-strong-coupling-expansion-work-in-progress" class="anchor" aria-hidden="true" href="#2-generic-strong-coupling-expansion-work-in-progress"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>2. Generic Strong Coupling Expansion (work in progress)</h3>
<h3 dir="auto"><a id="user-content-3-hand-drawing-feynman-diagrams-work-in-progress" class="anchor" aria-hidden="true" href="#3-hand-drawing-feynman-diagrams-work-in-progress"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3. Hand-drawing Feynman diagrams (work in progress)</h3>
<h2 dir="auto"><a id="user-content-computational-graph-visualization" class="anchor" aria-hidden="true" href="#computational-graph-visualization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Computational Graph visualization</h2>
<p dir="auto">To visualize the diagram tree, you need to install the ete3 python3 package (<a href="http://etetoolkit.org/" rel="nofollow">http://etetoolkit.org/</a>).</p>
<p dir="auto">Note that we rely on "PyCall.jl" to call the ete3 python functions from julia. Therefore, you have to install ete3 python package use the python distribution associated with PyCall. According to the tutorial of PyCall (<a href="https://github.com/JuliaPy/PyCall.jl">https://github.com/JuliaPy/PyCall.jl</a>), "by default on Mac and Windows systems, Pkg.add("PyCall") or Pkg.build("PyCall") will use the Conda.jl package to install a minimal Python distribution (via Miniconda) that is private to Julia (not in your PATH). You can use the Conda Julia package to install more Python packages, and import Conda to print the Conda.PYTHONDIR directory where python was installed. On GNU/Linux systems, PyCall will default to using the python3 program (if any, otherwise python) in your PATH."</p>
</article></div>