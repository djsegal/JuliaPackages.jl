<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-using-sciml-symbolics-to-solve-perturbation-problems" class="anchor" aria-hidden="true" href="#using-sciml-symbolics-to-solve-perturbation-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using SciML Symbolics to Solve Perturbation Problems</h1>
<h2><a id="user-content-background" class="anchor" aria-hidden="true" href="#background"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Background</h2>
<p><a href="https://github.com/JuliaSymbolics/Symbolics.jl"><strong>Symbolics.jl</strong></a> is a fast and modern Computer Algebra System (CAS) written in the Julia Programming Language. It is an integral part of the <a href="https://sciml.ai/" rel="nofollow">SciML</a> ecosystem of differential equation solvers and scientific machine learning packages. While <strong>Symbolics.jl</strong> is primarily designed for modern scientific computing (e.g., auto-differentiation, machine learning), it is a powerful CAS and can also be useful for <em>classic</em> scientific computing. One such application is using the <em>perturbation</em> theory to solve algebraic and differential equations.</p>
<p>Perturbation methods are a collection of techniques to solve problems that generally don't have a closed solution but depend on a tunable parameter and have closed-form or easy solutions for some values of the parameter. The main idea is to assume a solution as a power series in the tunable parameter (say 𝜀), such that 𝜀 = 0 corresponds to an easy solution.</p>
<p>We will discuss the general steps of the perturbation methods in four examples below. One hallmark of the perturbation method is the generation of long and convoluted intermediate equations, which are subjected to algorithmic and mechanical manipulations. Therefore, these problems are well suited for CAS. In fact, CAS softwares have been used to help with the perturbation calculations since the 1950s.</p>
<p>In this tutorial our goal is to show how to use Julia and <strong>Symbolics.jl</strong> to solve simple perturbation problems. The code for the for examples (<code>test_*</code> functions) and the helper functions are in <code>src/perturb.jl</code>.</p>
<h2><a id="user-content-solving-the-quintic" class="anchor" aria-hidden="true" href="#solving-the-quintic"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Solving the Quintic</h2>
<p>We start with the "hello world!" analog of the perturbation problems: solving the quintic (fifth-order) equations. We want to find a real valued 𝑥 such that 𝑥⁵ + 𝑥 = 1. According to the Abel's theorem, a general quintic equation does not have a closed form solution. Of course, we can easily solve this equation numerically; for example, by using the Newton's method. We use the following implementation of the Newton's method:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Symbolics, SymbolicUtils

function solve_newton(f, x, x₀; abstol=1e-8, maxiter=50)
    xₙ = Float64(x₀)
    fₙ₊₁ = x - f / Symbolics.derivative(f, x)

    for i = 1:maxiter
        xₙ₊₁ = substitute(fₙ₊₁, Dict(x =&gt; xₙ))
        if abs(xₙ₊₁ - xₙ) &lt; abstol
            return xₙ₊₁
        else
            xₙ = xₙ₊₁
        end
    end
    return xₙ₊₁
end
"><pre><span class="pl-k">using</span> Symbolics, SymbolicUtils

<span class="pl-k">function</span> <span class="pl-en">solve_newton</span>(f, x, x₀; abstol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>, maxiter<span class="pl-k">=</span><span class="pl-c1">50</span>)
    xₙ <span class="pl-k">=</span> <span class="pl-c1">Float64</span>(x₀)
    fₙ₊₁ <span class="pl-k">=</span> x <span class="pl-k">-</span> f <span class="pl-k">/</span> Symbolics<span class="pl-k">.</span><span class="pl-c1">derivative</span>(f, x)

    <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>maxiter
        xₙ₊₁ <span class="pl-k">=</span> <span class="pl-c1">substitute</span>(fₙ₊₁, <span class="pl-c1">Dict</span>(x <span class="pl-k">=&gt;</span> xₙ))
        <span class="pl-k">if</span> <span class="pl-c1">abs</span>(xₙ₊₁ <span class="pl-k">-</span> xₙ) <span class="pl-k">&lt;</span> abstol
            <span class="pl-k">return</span> xₙ₊₁
        <span class="pl-k">else</span>
            xₙ <span class="pl-k">=</span> xₙ₊₁
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> xₙ₊₁
<span class="pl-k">end</span></pre></div>
<p>In this code, <code>Symbolics.derivative(eq, x)</code> does exactly what it names implies: it calculates the symbolic derivative of <code>eq</code> (a <strong>Symbolics.jl</strong> expression) with respect to <code>x</code> (a <strong>Symbolics.jl</strong> variable). We use <code>Symbolics.substitute(eq, D)</code> to evaluate the update formula by substituting variables or sub-expressions (defined as a dictionary <code>D</code>) in <code>eq</code>. It should be noted that <code>substitute</code> is the workhorse of our code and will be used multiple times in the rest of this tutorial. <code>solve_newton</code> is written with simplicity and clarity in mind and not performance but suffices for our purpose.</p>
<p>Let's go back to our quintic. We can define a Symbolics variable as <code>@variables x</code> and then solve the equation <code>solve_newton(x^5 + x - 1, x, 1.0)</code> (here, <code>x₀ = 0</code> is our first guess). The answer is <code>x = 0.7549</code>. Now, let's see how we can solve this problem using the perturbation method.</p>
<p>We introduce a tuning parameter 𝜀 into our equation: 𝑥⁵ + 𝑥 = 1. If 𝜀 = 1, we get our original problem. For 𝜀 = 0, the problem transforms to an easy one: 𝑥⁵ = 1 which has a solution 𝑥 = 1 (and four complex solutions which we ignore here). We expand 𝑥 as a power series on 𝜀:</p>
<p>𝑥(𝜀) = 𝑎₀ + 𝑎₁𝜀 + 𝑎₂𝜀² + 𝑂(𝜀³)</p>
<p>𝑎₀ is the solution of the easy equation, therefore 𝑎₀ = 1. Substituting into the original problem,</p>
<p>(1 + 𝑎₁𝜀 + 𝑎₂𝜀²)⁵ + 𝜀 (1 + 𝑎₁𝜀 + 𝑎₂𝜀²) - 1 = 0</p>
<p>Expanding the equations, we get</p>
<p>𝜀 (1 + 5𝑎₁) + 𝜀² (𝑎₁ + 5𝑎₂ + 10𝑎₁²) + 𝑂(𝜀³) = 0</p>
<p>This equation should hold for each power of 𝜀. Therefore,</p>
<p>1 + 5𝑎₁ = 0,</p>
<p>and</p>
<p>𝑎₁ + 5𝑎₂ + 10𝑎₁² = 0.</p>
<p>This system of equations does not initially seem to be linear because of the presence of terms like 10𝑎₁², but upon closer inspection is found to be in fact linear (this is a feature of the permutation method). In addition, the system is in a triangular form, meaning the first equation depends only on 𝑎₁, the second one on 𝑎₁ and 𝑎₂, such that we can replace the result of 𝑎₁ from the first one into the second equation and remove the non-linear term. We solve the first equation to get 𝑎₁ = -1/5. Substituting in the second one and solve for 𝑎₂:</p>
<p>𝑎₂ = (-1/5 + 10(-(1/5)²) / 5 = -1/25</p>
<p>Finally,</p>
<p>𝑥(𝜀) = 1 - 𝜀 / 5 - 𝜀² / 25 + 𝑂(𝜀³)</p>
<p>Solving the original problem, 𝑥(1) = 0.76, compared to 0.75487767 calculated numerically. We can improve the accuracy by including more terms in the expansion of 𝑥. However, the calculations, while straightforward, become messy and intractable to do manually very quickly. This is why a CAS is very helpful to solve perturbation problems.</p>
<p>Now, let's see how we can do these calculations in Julia (see <code>test_quintic</code> function). Let <code>n = 2</code> be the order of the expansion. We start by defining the symbolic variables:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  @variables @variables ϵ a[1:n]        
"><pre>  <span class="pl-c1">@variables</span> <span class="pl-c1">@variables</span> ϵ a[<span class="pl-c1">1</span><span class="pl-k">:</span>n]        </pre></div>
<p>Then, we define <code>x = 1 + a[1]*ϵ + a[2]*ϵ^2</code>. Note that in <code>test_quintic</code> we use the helper function <code>def_taylor</code> to define <code>x</code> by calling it as <code>x = def_taylor(ϵ, a, 1)</code>, where the arguments are the expansion variable, an array of parameters, and the constant term. The next step is to substitute <code>x</code> in the problem equation <code>eq = x^5 + ϵ*x - 1</code>. Now, <code>eq</code> is</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  ϵ*(1 + a₁*ϵ + a₂*(ϵ^2)) + (1 + a₁*ϵ + a₂*(ϵ^2))^5 - 1
"><pre>  ϵ<span class="pl-k">*</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> a₁<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> a₂<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>)) <span class="pl-k">+</span> (<span class="pl-c1">1</span> <span class="pl-k">+</span> a₁<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> a₂<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>))<span class="pl-k">^</span><span class="pl-c1">5</span> <span class="pl-k">-</span> <span class="pl-c1">1</span></pre></div>
<p>Or in the expanded form (calculated as <code>expand(eq)</code>):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ϵ + a₁*(ϵ^2) + a₂*(ϵ^3) + (a₁^5)*(ϵ^5) + (a₂^5)*(ϵ^10) + 5a₁*ϵ + 5a₂*(ϵ^2) +
10(a₁^2)*(ϵ^2) + 10(a₁^3)*(ϵ^3) + 5(a₁^4)*(ϵ^4) + 10(a₂^2)*(ϵ^4) +
10(a₂^3)*(ϵ^6) + 5(a₂^4)*(ϵ^8) + 20a₁*a₂*(ϵ^3) + 30a₁*(a₂^2)*(ϵ^5) +
20a₁*(a₂^3)*(ϵ^7) + 5a₁*(a₂^4)*(ϵ^9) + 30a₂*(a₁^2)*(ϵ^4) + 20a₂*(a₁^3)*(ϵ^5) +
5a₂*(a₁^4)*(ϵ^6) + 30(a₁^2)*(a₂^2)*(ϵ^6) + 10(a₁^2)*(a₂^3)*(ϵ^8) +
10(a₁^3)*(a₂^2)*(ϵ^7)
"><pre>ϵ <span class="pl-k">+</span> a₁<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> a₂<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">3</span>) <span class="pl-k">+</span> (a₁<span class="pl-k">^</span><span class="pl-c1">5</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">5</span>) <span class="pl-k">+</span> (a₂<span class="pl-k">^</span><span class="pl-c1">5</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">10</span>) <span class="pl-k">+</span> <span class="pl-c1">5</span>a₁<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> <span class="pl-c1">5</span>a₂<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span>
<span class="pl-c1">10</span>(a₁<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">10</span>(a₁<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">3</span>) <span class="pl-k">+</span> <span class="pl-c1">5</span>(a₁<span class="pl-k">^</span><span class="pl-c1">4</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">4</span>) <span class="pl-k">+</span> <span class="pl-c1">10</span>(a₂<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">4</span>) <span class="pl-k">+</span>
<span class="pl-c1">10</span>(a₂<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">6</span>) <span class="pl-k">+</span> <span class="pl-c1">5</span>(a₂<span class="pl-k">^</span><span class="pl-c1">4</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">8</span>) <span class="pl-k">+</span> <span class="pl-c1">20</span>a₁<span class="pl-k">*</span>a₂<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">3</span>) <span class="pl-k">+</span> <span class="pl-c1">30</span>a₁<span class="pl-k">*</span>(a₂<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">5</span>) <span class="pl-k">+</span>
<span class="pl-c1">20</span>a₁<span class="pl-k">*</span>(a₂<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">7</span>) <span class="pl-k">+</span> <span class="pl-c1">5</span>a₁<span class="pl-k">*</span>(a₂<span class="pl-k">^</span><span class="pl-c1">4</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">9</span>) <span class="pl-k">+</span> <span class="pl-c1">30</span>a₂<span class="pl-k">*</span>(a₁<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">4</span>) <span class="pl-k">+</span> <span class="pl-c1">20</span>a₂<span class="pl-k">*</span>(a₁<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">5</span>) <span class="pl-k">+</span>
<span class="pl-c1">5</span>a₂<span class="pl-k">*</span>(a₁<span class="pl-k">^</span><span class="pl-c1">4</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">6</span>) <span class="pl-k">+</span> <span class="pl-c1">30</span>(a₁<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(a₂<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">6</span>) <span class="pl-k">+</span> <span class="pl-c1">10</span>(a₁<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(a₂<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">8</span>) <span class="pl-k">+</span>
<span class="pl-c1">10</span>(a₁<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(a₂<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>(ϵ<span class="pl-k">^</span><span class="pl-c1">7</span>)</pre></div>
<p>We need a way to get the coefficients of different powers of 𝜀. Function <code>collect_powers(eq, x, ns)</code> returns the powers of variable <code>x</code> in expression <code>eq</code>. Argument <code>ns</code> is the range of the powers.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function collect_powers(eq, x, ns; max_power=100)
    eq = substitute(expand(eq), Dict(x^j =&gt; 0 for j=last(ns)+1:max_power))

    eqs = []
    for i in ns
        powers = Dict(x^j =&gt; (i==j ? 1 : 0) for j=1:last(ns))
        push!(eqs, substitute(eq, powers))
    end
    eqs
end
"><pre><span class="pl-k">function</span> <span class="pl-en">collect_powers</span>(eq, x, ns; max_power<span class="pl-k">=</span><span class="pl-c1">100</span>)
    eq <span class="pl-k">=</span> <span class="pl-c1">substitute</span>(<span class="pl-c1">expand</span>(eq), <span class="pl-c1">Dict</span>(x<span class="pl-k">^</span>j <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">for</span> j<span class="pl-k">=</span><span class="pl-c1">last</span>(ns)<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span>max_power))

    eqs <span class="pl-k">=</span> []
    <span class="pl-k">for</span> i <span class="pl-k">in</span> ns
        powers <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(x<span class="pl-k">^</span>j <span class="pl-k">=&gt;</span> (i<span class="pl-k">==</span>j <span class="pl-k">?</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">0</span>) <span class="pl-k">for</span> j<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">last</span>(ns))
        <span class="pl-c1">push!</span>(eqs, <span class="pl-c1">substitute</span>(eq, powers))
    <span class="pl-k">end</span>
    eqs
<span class="pl-k">end</span></pre></div>
<p>For example, <code>collect_powers(eq, ϵ, 1:2)</code> means the coefficients of <code>ϵ</code> and <code>ϵ^2</code> in <code>eq</code> and returns a list of expressions <code>[1 + 5a₁, a₁ + 5a₂ + 10(a₁^2)]</code>. We assign this list to <code>eqs</code>.</p>
<p><code>collect_powers</code> uses <code>substitute</code> to find the coefficient of a given power of <code>x</code> by passing a <code>Dict</code> with all powers of <code>x</code> set to 0, except the target power which is set to 1. The following experssion returns the coefficient of <code>ϵ^2</code> in <code>eq</code>,</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  substitute(expand(eq), Dict(
    ϵ =&gt; 0,
    ϵ^2 =&gt; 1,
    ϵ^3 =&gt; 0,
    ϵ^4 =&gt; 0,
    ϵ^5 =&gt; 0,
    ϵ^6 =&gt; 0,
    ϵ^7 =&gt; 0,
    ϵ^8 =&gt; 0)
  )
"><pre>  <span class="pl-c1">substitute</span>(<span class="pl-c1">expand</span>(eq), <span class="pl-c1">Dict</span>(
    ϵ <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>,
    ϵ<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>,
    ϵ<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>,
    ϵ<span class="pl-k">^</span><span class="pl-c1">4</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>,
    ϵ<span class="pl-k">^</span><span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>,
    ϵ<span class="pl-k">^</span><span class="pl-c1">6</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>,
    ϵ<span class="pl-k">^</span><span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>,
    ϵ<span class="pl-k">^</span><span class="pl-c1">8</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>)
  )</pre></div>
<p>Back to our problem. Having the coefficients of the powers of <code>ϵ</code>, we can set each equation to 0 and solve the system of linear equations to find the numerical values of the coefficients. <strong>Symbolics.jl</strong> has a function <code>Symbolics.solve_for</code> that can solve systems of linear equations. We can start by solving <code>eqs[1]</code> for <code>a₁</code> and then substitute this in <code>eqs[2]</code> and solve for <code>a₂</code>.  This process is done by function <code>solve_coef(eqs, ps)</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="function solve_coef(eqs, ps)
    vals = Dict()

    for i = 1:length(ps)
        eq = substitute(eqs[i], vals)
        vals[ps[i]] = Symbolics.solve_for(eq ~ 0, ps[i])
    end
    vals
end
"><pre><span class="pl-k">function</span> <span class="pl-en">solve_coef</span>(eqs, ps)
    vals <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()

    <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(ps)
        eq <span class="pl-k">=</span> <span class="pl-c1">substitute</span>(eqs[i], vals)
        vals[ps[i]] <span class="pl-k">=</span> Symbolics<span class="pl-k">.</span><span class="pl-c1">solve_for</span>(eq <span class="pl-k">~</span> <span class="pl-c1">0</span>, ps[i])
    <span class="pl-k">end</span>
    vals
<span class="pl-k">end</span></pre></div>
<p>Here, <code>eqs</code> is an array of expressions (assumed to be equal to 0) and <code>ps</code> is an array of variables. The result is a dictionary of <em>variable</em> =&gt; <em>value</em> pairs. For example, <code>solve_coef(eqs, a)</code> returns <code>Dict(a₁ =&gt; -0.2, a₂ =&gt; -0.04)</code>. Substituting back in the definition of <code>x</code>, i.e., <code>x = 1 + a[1]*ϵ + a[2]*ϵ^2</code>, we obtain <code>X = ϵ -&gt; 1 - 0.2*ϵ - 0.04*ϵ^2</code>. Therefore, the solution to our original problem becomes <code>X(1)</code>, which is equal to 0.76.</p>
<p>We can use larger values of <code>n</code> to improve the accuracy of estimations:</p>
<table>
<thead>
<tr>
<th>n</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0.8</td>
</tr>
<tr>
<td>2</td>
<td>0.76</td>
</tr>
<tr>
<td>3</td>
<td>0.752</td>
</tr>
<tr>
<td>4</td>
<td>0.752</td>
</tr>
<tr>
<td>5</td>
<td>0.7533</td>
</tr>
<tr>
<td>6</td>
<td>0.7543</td>
</tr>
<tr>
<td>7</td>
<td>0.7548</td>
</tr>
<tr>
<td>8</td>
<td>0.7550</td>
</tr>
</tbody>
</table>
<p>Remember the numerical value is 0.7549.</p>
<p>The two functions <code>collect_powers</code> and <code>solve_coef(eqs, a)</code> are used in all the examples in this tutorial.</p>
<h2><a id="user-content-solving-the-keplers-equation" class="anchor" aria-hidden="true" href="#solving-the-keplers-equation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Solving the Kepler's Equation</h2>
<p>Historically, the perturbation methods were first invented to solve orbital calculations needed to calculate the orbit of the Moon and the planets. In homage to this history, our second example has a celestial theme. Our goal is solve the Kepler's equation:</p>
<p>𝐸 - 𝑒 sin(𝐸) = 𝑀.</p>
<p>where 𝑒 is the <em>eccentricity</em> of the elliptical orbit, 𝑀 is the <em>mean anomaly</em>, and 𝐸 (unknown) is the <em>eccentric anomaly</em> (the angle between the position of a planet in an elliptical orbit and the point of periapsis). This equation is central to solving two-body Keplerian orbits. We want to find a function 𝐸(𝑀; 𝑒).</p>
<p>Similar to the first example, it is easy to solve this problem using the Newton's method. For example, let 𝑒 = 0.01671 (the eccentricity of the Earth) and 𝑀 = π/2. We have <code>solve_newton(x - e*sin(x) - M, x, M)</code> equals to 1.5875 (compared to π/2 = 1.5708). Now, we try to solve the same problem using the perturbation techniques (see function <code>test_kepler</code>).</p>
<p>For 𝑒 = 0, we have 𝐸 = 𝑀. Therefore, we can use 𝑒 as our perturbation parameter. For consistency, we rename it to 𝜀. We start by defining the variables (assuming <code>n = 3</code>):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  @variables ϵ M a[1:n]
  x = def_taylor(ϵ, n, M)  
"><pre>  <span class="pl-c1">@variables</span> ϵ M a[<span class="pl-c1">1</span><span class="pl-k">:</span>n]
  x <span class="pl-k">=</span> <span class="pl-c1">def_taylor</span>(ϵ, n, M)  </pre></div>
<p>The problem equation is <code>eq = E - ϵ * sin(E) - M</code>. We further simplify by substituting sin with its power series (using <code>expand_sin</code> helper function):</p>
<p>sin(𝐸) = 𝑥 - 𝑥³ / 6 + 𝑥⁵ / 120 - 𝑥⁷ / 5040 + 𝑂(𝑥⁹).</p>
<p>We follow the same algorithm as before. We collect the coefficients of the powers of 𝜀:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="  eqs = collect_powers(eq, ϵ, 1:n)
"><pre><code>  eqs = collect_powers(eq, ϵ, 1:n)
</code></pre></div>
<p>and then solve for <code>a</code>:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="  vals = solve_coef(eqs, a)
"><pre><code>  vals = solve_coef(eqs, a)
</code></pre></div>
<p>Finally, we substitute <code>vals</code> back in <code>x</code> to get a formula to calculate <code>E</code>:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="  X = substitute(x, vals)
  substitute(X, Dict(ϵ =&gt; 0.01671, M =&gt; π/2))
"><pre><code>  X = substitute(x, vals)
  substitute(X, Dict(ϵ =&gt; 0.01671, M =&gt; π/2))
</code></pre></div>
<p>The result is 1.5876, compared to the numerical value of 1.5875. It is customary to order <code>X</code> based on the powers of <code>M</code> instead of <code>ϵ</code>. We can calculate this series as <code>collect_powers(sol, M, 0:3) </code>. The result (after manual cleanup) is</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  E(M, ϵ) =
    (1 + ϵ + ϵ^2 + ϵ^3)*M
    - (ϵ + 4*ϵ^2 + 10*ϵ^3)*M^3/6
    + (ϵ + 16*ϵ^2 + 91*ϵ^3)*M^5/120
"><pre>  <span class="pl-en">E</span>(M, ϵ) <span class="pl-k">=</span>
    (<span class="pl-c1">1</span> <span class="pl-k">+</span> ϵ <span class="pl-k">+</span> ϵ<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> ϵ<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>M
    <span class="pl-k">-</span> (ϵ <span class="pl-k">+</span> <span class="pl-c1">4</span><span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">10</span><span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>M<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">/</span><span class="pl-c1">6</span>
    <span class="pl-k">+</span> (ϵ <span class="pl-k">+</span> <span class="pl-c1">16</span><span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">91</span><span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>M<span class="pl-k">^</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">120</span></pre></div>
<p>Comparing the formula to the one for 𝐸 in the <a href="https://en.wikipedia.org/wiki/Kepler%27s_equation" rel="nofollow">Wikipedia article on the Kepler's equation</a>:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://render.githubusercontent.com/render/math?math=E = \frac{1}{1-\epsilon}M-\frac{\epsilon}{(1-\epsilon)^4} \frac{M^3}{3!} %2B \frac{(9\epsilon^2 %2B  \epsilon)}{(1-\epsilon)^7}\frac{M^5}{5!}\cdots"><img src="https://render.githubusercontent.com/render/math?math=E = \frac{1}{1-\epsilon}M-\frac{\epsilon}{(1-\epsilon)^4} \frac{M^3}{3!} %2B \frac{(9\epsilon^2 %2B  \epsilon)}{(1-\epsilon)^7}\frac{M^5}{5!}\cdots" style="max-width:100%;"></a></p>
<p>The first deviation is in the coefficient of 𝜀³𝑀⁵.</p>
<h2><a id="user-content-the-trajectory-of-a-ball" class="anchor" aria-hidden="true" href="#the-trajectory-of-a-ball"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Trajectory of a Ball!</h2>
<p>In the first two examples, we applied the permutation method to algebraic problems. However, the main power of the permutation method is to solve differential equations (usually ODEs, but also occasionally PDEs). Surprisingly, the main procedure developed to solve algebraic problems works well for differential equations. In fact, we will use the same two helper functions, <code>collect_powers</code> and <code>solve_coef</code>. The main difference is in the way we expand the dependent variables. For algebraic problems, the coefficients of 𝜀 are constants; whereas, for differential equations, they are functions of the dependent variable (usually time).</p>
<p>For the first example on how to solve an ODE, we have chosen a simple and well-behaved problem. The problem is a variation of a standard first-year physics problem: what is the trajectory of an object (say, a ball or a rocket) thrown vertically at velocity 𝑣 from the surface of a planet. Assuming a  constant acceleration of gravity, 𝑔, every burgeoning physicist knows the answer: 𝑥(𝑡) = 𝑥(0) + 𝑣𝑡 - 𝑔𝑡²/2. However, what happens if 𝑔 is not constant? Specifically, 𝑔 is inversely proportional to the distant from the center of the planet. If 𝑣 is large, the assumption of constant gravity does not hold. However, unless 𝑣 is large compared to the escape velocity, the correction is usually small. After simplifications and reframing in dimensionless variables, the problem becomes 𝑥̈(𝑡) = -(1 + 𝜀𝑥(𝑡))⁻², assuming 𝑥(0) = 0, and 𝑥̇(0) = 1. Note that for 𝜀 = 0, this equation transforms back to the standard one.</p>
<p>Let's start with defining the variables</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  @variables ϵ t y[1:n](t) ∂∂y[1:n]
"><pre>  <span class="pl-c1">@variables</span> ϵ t y[<span class="pl-c1">1</span><span class="pl-k">:</span>n](t) ∂∂y[<span class="pl-c1">1</span><span class="pl-k">:</span>n]</pre></div>
<p>Next, we define 𝑥 (for <code>n = 3</code>):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  x = y[1] + y[2]*ϵ + y[3]*ϵ^2
"><pre>  x <span class="pl-k">=</span> y[<span class="pl-c1">1</span>] <span class="pl-k">+</span> y[<span class="pl-c1">2</span>]<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> y[<span class="pl-c1">3</span>]<span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<p>We need the second derivative of <code>x</code>. It may seem that we can do this using <code>Differential(t)</code>; however, this operation needs to wait! Instead, we define dummy variables <code>∂∂y</code> as the placeholder for the second derivatives and define</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  ∂∂x = ∂∂y[1] + ∂∂y[2]*ϵ + ∂∂y[3]*ϵ^2
"><pre>  ∂∂x <span class="pl-k">=</span> ∂∂y[<span class="pl-c1">1</span>] <span class="pl-k">+</span> ∂∂y[<span class="pl-c1">2</span>]<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> ∂∂y[<span class="pl-c1">3</span>]<span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<p>as the second derivative of <code>x</code>. After rearrangement, our governing equation is 𝑥̈(𝑡)(1 + 𝜀𝑥(𝑡))² + 1 = 0, or</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  eq = ∂∂x * (1 + ϵ*x)^2 + 1
"><pre>  eq <span class="pl-k">=</span> ∂∂x <span class="pl-k">*</span> (<span class="pl-c1">1</span> <span class="pl-k">+</span> ϵ<span class="pl-k">*</span>x)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1</span></pre></div>
<p>The next steps are the same as before (however, note that we pass <code>0:n-1</code> to <code>collect_powers</code> because the zeroth order term is needed here)</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  eqs = collect_powers(eq, ϵ, 0:n-1)
  vals = solve_coef(eqs, ∂∂y)
"><pre>  eqs <span class="pl-k">=</span> <span class="pl-c1">collect_powers</span>(eq, ϵ, <span class="pl-c1">0</span><span class="pl-k">:</span>n<span class="pl-k">-</span><span class="pl-c1">1</span>)
  vals <span class="pl-k">=</span> <span class="pl-c1">solve_coef</span>(eqs, ∂∂y)</pre></div>
<p>At this stage,</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  vals = Dict(
    ∂∂y₁ =&gt; -1.0,
    ∂∂y₂ =&gt; 2.0y₁(t),
    ∂∂y₃ =&gt; 2.0y₂(t) - (3.0(y₁(t)^2))
  )
"><pre>  vals <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(
    ∂∂y₁ <span class="pl-k">=&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1.0</span>,
    ∂∂y₂ <span class="pl-k">=&gt;</span> <span class="pl-c1">2.0</span><span class="pl-c1">y₁</span>(t),
    ∂∂y₃ <span class="pl-k">=&gt;</span> <span class="pl-c1">2.0</span><span class="pl-c1">y₂</span>(t) <span class="pl-k">-</span> (<span class="pl-c1">3.0</span>(<span class="pl-c1">y₁</span>(t)<span class="pl-k">^</span><span class="pl-c1">2</span>))
  )</pre></div>
<p>Our system of ODEs is forming. Note the triangular form of the relationship. This is time to convert <code>∂∂</code>s to the correct <strong>Symbolics.jl</strong> form by substitution:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  D = Differential(t)
  subs = Dict(∂∂y[i] =&gt; D(D(y[i])) for i = 1:n)
  eqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]
"><pre>  D <span class="pl-k">=</span> <span class="pl-c1">Differential</span>(t)
  subs <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(∂∂y[i] <span class="pl-k">=&gt;</span> <span class="pl-c1">D</span>(<span class="pl-c1">D</span>(y[i])) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n)
  eqs <span class="pl-k">=</span> [<span class="pl-c1">substitute</span>(<span class="pl-c1">first</span>(v), subs) <span class="pl-k">~</span> <span class="pl-c1">substitute</span>(<span class="pl-c1">last</span>(v), subs) <span class="pl-k">for</span> v <span class="pl-k">in</span> vals]</pre></div>
<p>Now, <code>eqs</code> becomes</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  [Differential(t)(Differential(t)(y₁(t))) ~ -1.0,
   Differential(t)(Differential(t)(y₂(t))) ~ 2.0y₁(t),
   Differential(t)(Differential(t)(y₃(t))) ~ 2.0y₂(t) - (3.0(y₁(t)^2))]
"><pre>  [<span class="pl-c1">Differential</span>(t)(<span class="pl-c1">Differential</span>(t)(<span class="pl-c1">y₁</span>(t))) <span class="pl-k">~</span> <span class="pl-k">-</span><span class="pl-c1">1.0</span>,
   <span class="pl-c1">Differential</span>(t)(<span class="pl-c1">Differential</span>(t)(<span class="pl-c1">y₂</span>(t))) <span class="pl-k">~</span> <span class="pl-c1">2.0</span><span class="pl-c1">y₁</span>(t),
   <span class="pl-c1">Differential</span>(t)(<span class="pl-c1">Differential</span>(t)(<span class="pl-c1">y₃</span>(t))) <span class="pl-k">~</span> <span class="pl-c1">2.0</span><span class="pl-c1">y₂</span>(t) <span class="pl-k">-</span> (<span class="pl-c1">3.0</span>(<span class="pl-c1">y₁</span>(t)<span class="pl-k">^</span><span class="pl-c1">2</span>))]</pre></div>
<p>We are nearly there! From this point on, the rest is standard ODE solving procedures. Potentially we can use a symbolic ODE solver to find a closed form solution to this problem. However, <strong>Symbolics.jl</strong> currently does not support this functionality. Instead, we solve the problem numerically. We form an <code>ODESystem</code>, lower the order (convert second derivatives to first), generate an <code>ODEProblem</code> (after passing the correct initial conditions), and, finally, solve it.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  using ModelingToolkit, DifferentialEquations

  sys = ODESystem(eqs, t)
  sys = ode_order_lowering(sys)
  prob = ODEProblem(sys, [1.0, 0.0, 0.0, 0.0, 0.0, 0.0], (0, 5.0))
  sol = solve(prob; dtmax=0.01)
"><pre>  <span class="pl-k">using</span> ModelingToolkit, DifferentialEquations

  sys <span class="pl-k">=</span> <span class="pl-c1">ODESystem</span>(eqs, t)
  sys <span class="pl-k">=</span> <span class="pl-c1">ode_order_lowering</span>(sys)
  prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(sys, [<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>], (<span class="pl-c1">0</span>, <span class="pl-c1">5.0</span>))
  sol <span class="pl-k">=</span> <span class="pl-c1">solve</span>(prob; dtmax<span class="pl-k">=</span><span class="pl-c1">0.01</span>)</pre></div>
<p>The solution to the problem can be written as</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  X = ϵ -&gt; sol[y[1]] .+ sol[y[2]] * ϵ .+ sol[y[3]] * ϵ^2
"><pre>  X <span class="pl-k">=</span> ϵ <span class="pl-k">-&gt;</span> sol[y[<span class="pl-c1">1</span>]] <span class="pl-k">.+</span> sol[y[<span class="pl-c1">2</span>]] <span class="pl-k">*</span> ϵ <span class="pl-k">.+</span> sol[y[<span class="pl-c1">3</span>]] <span class="pl-k">*</span> ϵ<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<p>The following figure is generated by running</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  using Plots

  plot(sol.t, hcat([X(ϵ) for ϵ = 0.0:0.1:0.5]...))    
"><pre>  <span class="pl-k">using</span> Plots

  <span class="pl-c1">plot</span>(sol<span class="pl-k">.</span>t, <span class="pl-c1">hcat</span>([<span class="pl-c1">X</span>(ϵ) <span class="pl-k">for</span> ϵ <span class="pl-k">=</span> <span class="pl-c1">0.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">0.5</span>]<span class="pl-k">.</span><span class="pl-k">..</span>))    </pre></div>
<p>and shows the trajectories for a range of <code>ϵ</code>:</p>
<p><a target="_blank" rel="noopener noreferrer" href="figures/rocket.png"><img src="figures/rocket.png" alt="" style="max-width:100%;"></a></p>
<p>As expected, the higher <code>ϵ</code> is (meaning the gravity is less with altitude), the object goes higher and stays up for a longer duration. Of course, we could have solved the problem directly using as ODE solver. One of the benefits of the perturbation method is that we need to run the ODE solver only once and then can just calculate the answer for different values of <code>ϵ</code>; whereas, if we were using the direct method, we needed to run the solver once for each value of <code>ϵ</code>.</p>
<h2><a id="user-content-a-weakly-nonlinear-oscillator" class="anchor" aria-hidden="true" href="#a-weakly-nonlinear-oscillator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>A Weakly Nonlinear Oscillator</h2>
<p>For our final example, we have chosen a simple example from a very important class of problems, the nonlinear oscillators. As we will see, perturbation theory has difficulty providing a good solution to this problem, but the process is instructive. This example follows closely chapter 7.6 of <em>Nonlinear Dynamics and Chaos</em> by Steven Strogatz.</p>
<p>The problem is to solve 𝑥̈(𝑡) + 2𝜀𝑥̇ + 𝑥 = 0, assuming 𝑥(0) = 0, and 𝑥̇(0) = 1. If 𝜀 = 0, the problem reduces to the simple linear harmonic oscillator with the exact solution 𝑥(t) = sin(𝑡). We follow the same steps as the previous example.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  @variables ϵ t y[1:n](t) ∂y[1:n] ∂∂y[1:n] # n = 3
  x = y[1] + y[2]*ϵ + y[3]*ϵ^2
  ∂x = ∂y[1] + ∂y[2]*ϵ + ∂y[3]*ϵ^2
  ∂∂x = ∂∂y[1] + ∂∂y[2]*ϵ + ∂∂y[3]*ϵ^2
"><pre>  <span class="pl-c1">@variables</span> ϵ t y[<span class="pl-c1">1</span><span class="pl-k">:</span>n](t) ∂y[<span class="pl-c1">1</span><span class="pl-k">:</span>n] ∂∂y[<span class="pl-c1">1</span><span class="pl-k">:</span>n] <span class="pl-c"><span class="pl-c">#</span> n = 3</span>
  x <span class="pl-k">=</span> y[<span class="pl-c1">1</span>] <span class="pl-k">+</span> y[<span class="pl-c1">2</span>]<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> y[<span class="pl-c1">3</span>]<span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>
  ∂x <span class="pl-k">=</span> ∂y[<span class="pl-c1">1</span>] <span class="pl-k">+</span> ∂y[<span class="pl-c1">2</span>]<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> ∂y[<span class="pl-c1">3</span>]<span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>
  ∂∂x <span class="pl-k">=</span> ∂∂y[<span class="pl-c1">1</span>] <span class="pl-k">+</span> ∂∂y[<span class="pl-c1">2</span>]<span class="pl-k">*</span>ϵ <span class="pl-k">+</span> ∂∂y[<span class="pl-c1">3</span>]<span class="pl-k">*</span>ϵ<span class="pl-k">^</span><span class="pl-c1">2</span></pre></div>
<p>Note that now we also need the first derivative terms. Continuing,</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  eq = ∂∂x + 2*ϵ*∂x + x
  eqs = collect_powers(eq, ϵ, 0:n-1)
  vals = solve_coef(eqs, ∂∂y)
"><pre>  eq <span class="pl-k">=</span> ∂∂x <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>ϵ<span class="pl-k">*</span>∂x <span class="pl-k">+</span> x
  eqs <span class="pl-k">=</span> <span class="pl-c1">collect_powers</span>(eq, ϵ, <span class="pl-c1">0</span><span class="pl-k">:</span>n<span class="pl-k">-</span><span class="pl-c1">1</span>)
  vals <span class="pl-k">=</span> <span class="pl-c1">solve_coef</span>(eqs, ∂∂y)</pre></div>
<p>Let's inspect <code>vals</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  vals = Dict(
    ∂∂y₁ =&gt; -y₁(t),
    ∂∂y₂ =&gt; -2.0∂y₁ - y₂(t),
    ∂∂y₃ =&gt; -2.0∂y₂ - y₃(t))
  )
"><pre>  vals <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(
    ∂∂y₁ <span class="pl-k">=&gt;</span> <span class="pl-k">-</span><span class="pl-c1">y₁</span>(t),
    ∂∂y₂ <span class="pl-k">=&gt;</span> <span class="pl-k">-</span><span class="pl-c1">2.0</span>∂y₁ <span class="pl-k">-</span> <span class="pl-c1">y₂</span>(t),
    ∂∂y₃ <span class="pl-k">=&gt;</span> <span class="pl-k">-</span><span class="pl-c1">2.0</span>∂y₂ <span class="pl-k">-</span> <span class="pl-c1">y₃</span>(t))
  )</pre></div>
<p>Next, we need to replace <code>∂</code>s and <code>∂∂</code>s with their <strong>Symbolics.jl</strong> counterparts:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  D = Differential(t)
  subs1 = Dict(∂y[i] =&gt; D(y[i]) for i = 1:n)
  subs2 = Dict(∂∂y[i] =&gt; D(D(y[i])) for i = 1:n)
  subs = subs1 ∪ subs2
  eqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]
"><pre>  D <span class="pl-k">=</span> <span class="pl-c1">Differential</span>(t)
  subs1 <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(∂y[i] <span class="pl-k">=&gt;</span> <span class="pl-c1">D</span>(y[i]) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n)
  subs2 <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(∂∂y[i] <span class="pl-k">=&gt;</span> <span class="pl-c1">D</span>(<span class="pl-c1">D</span>(y[i])) <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n)
  subs <span class="pl-k">=</span> subs1 <span class="pl-k">∪</span> subs2
  eqs <span class="pl-k">=</span> [<span class="pl-c1">substitute</span>(<span class="pl-c1">first</span>(v), subs) <span class="pl-k">~</span> <span class="pl-c1">substitute</span>(<span class="pl-c1">last</span>(v), subs) <span class="pl-k">for</span> v <span class="pl-k">in</span> vals]</pre></div>
<p>We continue with converting to an <code>ODEProblem</code>, solving it, and finally plot the results against the exact solution to the original problem.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="  sys = ODESystem(eqs, t)
  sys = ode_order_lowering(sys)
  prob = ODEProblem(sys, [1.0, 0.0, 0.0, 0.0, 0.0, 0.0], (0, 50.0))
  sol = solve(prob; dtmax=0.01)

  T = sol.t
  X = ϵ -&gt; sol[y[1]] .+ sol[y[2]] * ϵ .+ sol[y[3]] * ϵ^2
  Y = ϵ -&gt; exp.(-ϵ*T) .* sin.(sqrt(1 - ϵ^2)*T) / sqrt(1 - ϵ^2)    # exact solution

  plot(sol.t, [Y(0.1), X(0.1)])
"><pre>  sys <span class="pl-k">=</span> <span class="pl-c1">ODESystem</span>(eqs, t)
  sys <span class="pl-k">=</span> <span class="pl-c1">ode_order_lowering</span>(sys)
  prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>(sys, [<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>], (<span class="pl-c1">0</span>, <span class="pl-c1">50.0</span>))
  sol <span class="pl-k">=</span> <span class="pl-c1">solve</span>(prob; dtmax<span class="pl-k">=</span><span class="pl-c1">0.01</span>)

  T <span class="pl-k">=</span> sol<span class="pl-k">.</span>t
  X <span class="pl-k">=</span> ϵ <span class="pl-k">-&gt;</span> sol[y[<span class="pl-c1">1</span>]] <span class="pl-k">.+</span> sol[y[<span class="pl-c1">2</span>]] <span class="pl-k">*</span> ϵ <span class="pl-k">.+</span> sol[y[<span class="pl-c1">3</span>]] <span class="pl-k">*</span> ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>
  Y <span class="pl-k">=</span> ϵ <span class="pl-k">-&gt;</span> <span class="pl-c1">exp</span>.(<span class="pl-k">-</span>ϵ<span class="pl-k">*</span>T) <span class="pl-k">.*</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">sqrt</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span> ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">*</span>T) <span class="pl-k">/</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span> ϵ<span class="pl-k">^</span><span class="pl-c1">2</span>)    <span class="pl-c"><span class="pl-c">#</span> exact solution</span>

  <span class="pl-c1">plot</span>(sol<span class="pl-k">.</span>t, [<span class="pl-c1">Y</span>(<span class="pl-c1">0.1</span>), <span class="pl-c1">X</span>(<span class="pl-c1">0.1</span>)])</pre></div>
<p>The result is (compare to Figure 7.6.2 in <em>Nonlinear Dynamics and Chaos</em>)</p>
<p><a target="_blank" rel="noopener noreferrer" href="figures/oscillator.png"><img src="figures/oscillator.png" alt="" style="max-width:100%;"></a></p>
<p>The two curves fit well for the first couple of cycles, but then the perturbation method curve diverges from the true solution. The main reason is that the problem has two or more time-scales.</p>
</article></div>