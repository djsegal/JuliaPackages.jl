<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-actrsimulators" class="anchor" aria-hidden="true" href="#actrsimulators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ACTRSimulators</h1>
<p dir="auto">ACTRSimulators.jl is a package for developing discrete event simulations of the ACT-R cognitive architecture. Although the basic framework for conducting simulations has been developed, currently some
features of ACT-R have not been implimented.</p>
<h1 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h1>
<p dir="auto">As a simple example, we will develop an ACT-R model of the psychomotor vigilence task (PVT). The PVT is a reaction time task used to measure vigilance decrements stemming from fatigue. On each trial, a stimulus is presented after a random delay lasting 2 to 10 seconds. Once a response is made by keystroke, the next trial begins. Key components of the code will be described below. The full source code can be found in <code>Examples/PVT_Example</code>.</p>
<p dir="auto">After installing <code>ACTRSimulators.jl</code>, the first step is to load the following dependencies.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ACTRSimulators
import ACTRSimulators: start!, press_key!, repaint!
include(&quot;PVT.jl&quot;)
include(&quot;PVT_Model.jl&quot;)
import_gui()"><pre><span class="pl-k">using</span> ACTRSimulators
<span class="pl-k">import</span> ACTRSimulators<span class="pl-k">:</span> start!, press_key!, repaint!
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>PVT.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>PVT_Model.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">import_gui</span>()</pre></div>
<p dir="auto">Next, create an event scheduler as follows. When the option <code>model_trace</code> is set to true, a description and execution time will print for each processed model event. Task events can be added to the trace with <code>task_trace</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="scheduler = ACTRScheduler(;model_trace=true)"><pre>scheduler <span class="pl-k">=</span> <span class="pl-c1">ACTRScheduler</span>(;model_trace<span class="pl-k">=</span><span class="pl-c1">true</span>)</pre></div>
<p dir="auto">A task object is created with the <code>PVT</code> constructor, which includes options for the number of trials, whether the GUI is visible and whether the task executes in real time.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="task = PVT(;scheduler, n_trials=2, visible=true, realtime=true)"><pre>task <span class="pl-k">=</span> <span class="pl-c1">PVT</span>(;scheduler, n_trials<span class="pl-k">=</span><span class="pl-c1">2</span>, visible<span class="pl-k">=</span><span class="pl-c1">true</span>, realtime<span class="pl-k">=</span><span class="pl-c1">true</span>)</pre></div>
<p dir="auto">Now we will initialize the model. The model consists of components for the following modules:</p>
<ul dir="auto">
<li><code>procedural</code> memory</li>
<li><code>visual_location</code></li>
<li><code>visual</code></li>
</ul>
<p dir="auto">Each of the modules are passed to the <code>actr</code> model object along with a reference to the scheduler.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="procedural = Procedural()
T = vo_to_chunk() |&gt; typeof
visual_location = VisualLocation(buffer=T[])
visual = Visual(buffer=T[])
motor = Motor()
actr = ACTR(;scheduler, procedural, visual_location, visual, motor)"><pre>procedural <span class="pl-k">=</span> <span class="pl-c1">Procedural</span>()
T <span class="pl-k">=</span> <span class="pl-c1">vo_to_chunk</span>() <span class="pl-k">|&gt;</span> typeof
visual_location <span class="pl-k">=</span> <span class="pl-c1">VisualLocation</span>(buffer<span class="pl-k">=</span>T[])
visual <span class="pl-k">=</span> <span class="pl-c1">Visual</span>(buffer<span class="pl-k">=</span>T[])
motor <span class="pl-k">=</span> <span class="pl-c1">Motor</span>()
actr <span class="pl-k">=</span> <span class="pl-c1">ACTR</span>(;scheduler, procedural, visual_location, visual, motor)</pre></div>
<h1 dir="auto"><a id="user-content-production-rules" class="anchor" aria-hidden="true" href="#production-rules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Production Rules</h1>
<p dir="auto">A production rule consists of higher order functions: one for the conditions and another for the actions. The PVT model uses three production rules: <code>wait</code> for the stimulus to appear, <code>attend</code> to the stimulus once it appears, <code>respond</code> to the stimulus after attending to it.</p>
<h2 dir="auto"><a id="user-content-conditions" class="anchor" aria-hidden="true" href="#conditions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Conditions</h2>
<p dir="auto">The conditions for a production rule is a set of functions that return a <code>Bool</code> or a utility value proportional to the degree of match. By convention, the name for the conditions for a production rule is prefixed by "can". For example, <code>can_wait</code> returns a set of functions that evaluate the conditions for executing the <code>wait</code> production rule. Each condition requires an <code>actr</code> model object.</p>
<h3 dir="auto"><a id="user-content-wait" class="anchor" aria-hidden="true" href="#wait"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Wait</h3>
<p dir="auto">The model will wait if the <code>visual_location</code> and <code>visual</code> buffers are empty and the same modules are not busy.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function can_wait(actr)
    c1(actr) = actr.visual_location.state.empty
    c2(actr) = actr.visual.state.empty
    c3(actr) = !actr.visual.state.busy
    c4(actr) = !actr.motor.state.busy
    return c1, c2, c3, c4
end"><pre><span class="pl-k">function</span> <span class="pl-en">can_wait</span>(actr)
    <span class="pl-en">c1</span>(actr) <span class="pl-k">=</span> actr<span class="pl-k">.</span>visual_location<span class="pl-k">.</span>state<span class="pl-k">.</span>empty
    <span class="pl-en">c2</span>(actr) <span class="pl-k">=</span> actr<span class="pl-k">.</span>visual<span class="pl-k">.</span>state<span class="pl-k">.</span>empty
    <span class="pl-en">c3</span>(actr) <span class="pl-k">=</span> <span class="pl-k">!</span>actr<span class="pl-k">.</span>visual<span class="pl-k">.</span>state<span class="pl-k">.</span>busy
    <span class="pl-en">c4</span>(actr) <span class="pl-k">=</span> <span class="pl-k">!</span>actr<span class="pl-k">.</span>motor<span class="pl-k">.</span>state<span class="pl-k">.</span>busy
    <span class="pl-k">return</span> c1, c2, c3, c4
<span class="pl-k">end</span></pre></div>
<h3 dir="auto"><a id="user-content-attend" class="anchor" aria-hidden="true" href="#attend"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Attend</h3>
<p dir="auto">Upon stimulus presentation, a visual object is "stuffed" into the <code>visual_location</code> buffer. The <code>attend</code> production rule will execute if the <code>visual_location</code> buffer is not empty and the <code>visual</code> module is not busy.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function can_attend(actr)
    c1(actr) = !actr.visual_location.state.empty
    c2(actr) = !actr.visual.state.busy
    return c1, c2
end"><pre><span class="pl-k">function</span> <span class="pl-en">can_attend</span>(actr)
    <span class="pl-en">c1</span>(actr) <span class="pl-k">=</span> <span class="pl-k">!</span>actr<span class="pl-k">.</span>visual_location<span class="pl-k">.</span>state<span class="pl-k">.</span>empty
    <span class="pl-en">c2</span>(actr) <span class="pl-k">=</span> <span class="pl-k">!</span>actr<span class="pl-k">.</span>visual<span class="pl-k">.</span>state<span class="pl-k">.</span>busy
    <span class="pl-k">return</span> c1, c2
<span class="pl-k">end</span></pre></div>
<h3 dir="auto"><a id="user-content-respond" class="anchor" aria-hidden="true" href="#respond"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Respond</h3>
<p dir="auto">Once the model attends to the stimulus, it can execute a response. The <code>respond</code> production rule will fire if the <code>visual</code> buffer is not empty and the <code>motor</code> module is not busy.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function can_respond(actr)
    c1(actr) = !actr.visual.state.empty
    c2(actr) = !actr.motor.state.busy
    return c1, c2
end"><pre><span class="pl-k">function</span> <span class="pl-en">can_respond</span>(actr)
    <span class="pl-en">c1</span>(actr) <span class="pl-k">=</span> <span class="pl-k">!</span>actr<span class="pl-k">.</span>visual<span class="pl-k">.</span>state<span class="pl-k">.</span>empty
    <span class="pl-en">c2</span>(actr) <span class="pl-k">=</span> <span class="pl-k">!</span>actr<span class="pl-k">.</span>motor<span class="pl-k">.</span>state<span class="pl-k">.</span>busy
    <span class="pl-k">return</span> c1, c2
<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-actions" class="anchor" aria-hidden="true" href="#actions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Actions</h2>
<p dir="auto">After a production rule is selected, a set of actions are executed that modify the architecture and possibly modify the exeternal environment. Each production rule is associated with an action function. For example, the action function for the production rule wait is <code>wait_action</code>. Each action requires an <code>actr</code> model object and a <code>task</code> object or <code>args...</code> if the <code>task</code> is note used.</p>
<h3 dir="auto"><a id="user-content-wait-1" class="anchor" aria-hidden="true" href="#wait-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Wait</h3>
<p dir="auto">The purpose of the <code>wait</code> production rule is to surpress the execution of other production rules when the stimulus has not appeared. There is not time cost associated with firing the <code>wait</code> production rule. Accordingly, an empty function <code>()-&gt;()</code> is immediately registered to the scheduler using the keyword <code>now</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function wait_action(actr, args...)
    description = &quot;Wait&quot;
    register!(actr.scheduler, ()-&gt;(), now; description)
    return nothing
end"><pre><span class="pl-k">function</span> <span class="pl-en">wait_action</span>(actr, args<span class="pl-k">...</span>)
    description <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Wait<span class="pl-pds">"</span></span>
    <span class="pl-c1">register!</span>(actr<span class="pl-k">.</span>scheduler, ()<span class="pl-k">-&gt;</span>(), now; description)
    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<h3 dir="auto"><a id="user-content-attend-1" class="anchor" aria-hidden="true" href="#attend-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Attend</h3>
<p dir="auto">When the <code>attend</code> production rule is selected, the chunk in the <code>visual_location</code> buffer is copied and passed to the function <code>attending</code>, which adds the chunk after a time delay that represents the time to shift visual attention. In addition, the buffer for <code>visual_location</code> is immediately cleared.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function attend_action(actr, args...)
    buffer = actr.visual_location.buffer
    chunk = deepcopy(buffer[1])
    clear_buffer!(actr.visual_location)
    attending!(actr, chunk)
    return nothing
end"><pre><span class="pl-k">function</span> <span class="pl-en">attend_action</span>(actr, args<span class="pl-k">...</span>)
    buffer <span class="pl-k">=</span> actr<span class="pl-k">.</span>visual_location<span class="pl-k">.</span>buffer
    chunk <span class="pl-k">=</span> <span class="pl-c1">deepcopy</span>(buffer[<span class="pl-c1">1</span>])
    <span class="pl-c1">clear_buffer!</span>(actr<span class="pl-k">.</span>visual_location)
    <span class="pl-c1">attending!</span>(actr, chunk)
    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<h3 dir="auto"><a id="user-content-respond-1" class="anchor" aria-hidden="true" href="#respond-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Respond</h3>
<p dir="auto">The function <code>respond_action</code> is executed upon selection of the <code>respond</code> production rule. The function <code>respond_action</code> performs two actions: (1) clear the visual buffer and (2) executes the function <code>responding!</code> which executes the motor response after a delay and calls the user-defined function <code>press_key</code>. The model uses <code>press_key</code> to interact with the task and collect data.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function respond_action(actr, task)
    clear_buffer!(actr.visual)
    key = &quot;sb&quot;
    responding!(actr, task, key)
    return nothing
end"><pre><span class="pl-k">function</span> <span class="pl-en">respond_action</span>(actr, task)
    <span class="pl-c1">clear_buffer!</span>(actr<span class="pl-k">.</span>visual)
    key <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>sb<span class="pl-pds">"</span></span>
    <span class="pl-c1">responding!</span>(actr, task, key)
    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-construct-production-rules" class="anchor" aria-hidden="true" href="#construct-production-rules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Construct Production Rules</h2>
<p dir="auto">The constructor <code>Rule</code> creates a production rule from the following keyword arguments:</p>
<ul dir="auto">
<li><code>conditions</code>: a list of functions representing selection conditions</li>
<li><code>action</code>: a function that performs the actions of the production rule</li>
<li><code>actr</code>: a reference to the <code>ACTR</code> model object</li>
<li><code>task</code>: a reference to the PVT task</li>
<li><code>name</code>: an optional name for the production rule</li>
</ul>
<p dir="auto">Each production rule is pushed into a vector located in the <code>procedural</code> memory object.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="conditions = can_attend()
rule1 = Rule(;conditions, action=attend_action, actr, task, name=&quot;Attend&quot;)
push!(procedural.rules, rule1)
conditions = can_wait()
rule2 = Rule(;conditions, action=wait_action, actr, task, name=&quot;Wait&quot;)
push!(procedural.rules, rule2)
conditions = can_respond()
rule3 = Rule(;conditions, action=respond_action, actr, task, name=&quot;Respond&quot;)
push!(procedural.rules, rule3)"><pre>conditions <span class="pl-k">=</span> <span class="pl-c1">can_attend</span>()
rule1 <span class="pl-k">=</span> <span class="pl-c1">Rule</span>(;conditions, action<span class="pl-k">=</span>attend_action, actr, task, name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Attend<span class="pl-pds">"</span></span>)
<span class="pl-c1">push!</span>(procedural<span class="pl-k">.</span>rules, rule1)
conditions <span class="pl-k">=</span> <span class="pl-c1">can_wait</span>()
rule2 <span class="pl-k">=</span> <span class="pl-c1">Rule</span>(;conditions, action<span class="pl-k">=</span>wait_action, actr, task, name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Wait<span class="pl-pds">"</span></span>)
<span class="pl-c1">push!</span>(procedural<span class="pl-k">.</span>rules, rule2)
conditions <span class="pl-k">=</span> <span class="pl-c1">can_respond</span>()
rule3 <span class="pl-k">=</span> <span class="pl-c1">Rule</span>(;conditions, action<span class="pl-k">=</span>respond_action, actr, task, name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Respond<span class="pl-pds">"</span></span>)
<span class="pl-c1">push!</span>(procedural<span class="pl-k">.</span>rules, rule3)</pre></div>
<p dir="auto">Now that the model and task have been defined, we can now run the model simulation. A GUI will appear upon running the following code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="run!(actr, task)"><pre><span class="pl-c1">run!</span>(actr, task)</pre></div>
</article></div>