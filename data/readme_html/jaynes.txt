<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p align="center">
<a target="_blank" rel="noopener noreferrer" href="docs/assets/jaynes.png"><img height="250px" src="docs/assets/jaynes.png" style="max-width:100%;"></a>
</p>
<br>
<p><a href="https://femtomc.github.io/Jaynes.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/3e353c26ddfe819150acbc732248f4f2a37f5175/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a>
<a href="https://travis-ci.org/femtomc/Jaynes.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/8d048a5040c1bacf8c39879f0dd45201e5bbbdc7/68747470733a2f2f7472617669732d63692e6f72672f66656d746f6d632f4a61796e65732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/femtomc/Jaynes.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p><em>Jaynes</em> is a probabilistic programming framework which uses IR transformations and contextual dispatch to implement the core routines for modeling and inference.</p>
<p>Currently, <em>Jaynes</em> supports a dynamic modeling DSL which is syntactically close (and semantically equivalent) to the dynamic DSL in <a href="https://www.gen.dev/" rel="nofollow">Gen</a>. This comes with a few performance caveats:</p>
<ol>
<li>It is <em>partially optimized</em>. I've chosen representations which minimize allocations via profiling - but there are still upstream issues which affect performance on certain programs.</li>
<li>There are few performance guarantees on programs with type instabilities. Because this package relies on <code>Cassette</code>, it comes with all the subtle type performance issues that <code>Cassette</code> comes with.</li>
</ol>
<p>Currently supported inference algorithms for this DSL:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Importance sampling</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Programmable MCMC (WIP)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Metropolis-Hastings (WIP)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Particle filtering</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Inference compilation (training pipeline complete, now interfaces to use trained network need to be built)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Gradient-based methods (fundamental infrastructure is working, BBVI not in yet)</li>
</ul>
<p>The dynamic DSL is not the the long term main feature of this system. Gen's version is better optimized, has better documentation, and has a better assortment of inference algorithms. <em>Jaynes</em> aims to support a restricted <em>graph-based</em> DSL which allows the user to utilize graphical model inference algorithms. Ideally, <em>Jaynes</em> should be able to identify when a program is amenable to this static representation. This is a WIP, and requires a bit more research at the IR level. The goal for this DSL is to seamlessly combine with the dynamic, sample-based DSL in a productive way.</p>
<h2><a id="user-content-extending-jaynes" class="anchor" aria-hidden="true" href="#extending-jaynes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Extending <em>Jaynes</em></h2>
<p><em>Jaynes</em> is equipped with the ability to extend the tracing interface to black-box code. This is naturally facilitated by the metaprogramming capabilities of <code>Cassette</code>. The primary usage of this extension is to define new <code>logpdf</code> method definitions for code which may contain sources of randomness which are not annotated with addresses and/or where inspection by the tracing mechanism can be safely abstracted over. Thus, <code>@primitive</code> defines a contract between the user and the tracer - we assume that what you're doing is correct and we're not going to check you on it!</p>
<p>The following example shows how this extension mechanism works.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Jaynes<span class="pl-k">:</span> <span class="pl-c1">@primitive</span>, Trace, Generate, trace

<span class="pl-k">function</span> <span class="pl-en">foo</span>(y<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
    <span class="pl-c"><span class="pl-c">#</span> Untraced randomness.</span>
    y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">Normal</span>(<span class="pl-c1">0.5</span>, <span class="pl-c1">3.0</span>))
    <span class="pl-k">return</span> y
<span class="pl-k">end</span>

<span class="pl-c1">@primitive</span> <span class="pl-k">function</span> <span class="pl-en">logpdf</span>(fn<span class="pl-k">::</span><span class="pl-c1">typeof</span>(foo), args<span class="pl-k">::</span><span class="pl-c1">Tuple{Float64}</span>, y<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
    <span class="pl-k">if</span> y <span class="pl-k">&lt;</span> <span class="pl-c1">1.0</span>
        <span class="pl-c1">log</span>(<span class="pl-c1">1</span>) 
    <span class="pl-k">else</span>
        <span class="pl-k">-</span><span class="pl-c1">Inf</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">bar</span>(z<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
    y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">:y</span>, foo, (z, ))
    <span class="pl-k">return</span> y
<span class="pl-k">end</span>

ctx <span class="pl-k">=</span> <span class="pl-c1">Generate</span>(<span class="pl-c1">Trace</span>())
ret <span class="pl-k">=</span> <span class="pl-c1">trace</span>(ctx, bar, (<span class="pl-c1">0.3</span>, ))
<span class="pl-c1">println</span>(ctx<span class="pl-k">.</span>metadata<span class="pl-k">.</span>tr)

<span class="pl-c"><span class="pl-c">#</span>  __________________________________</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>               Playback</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> y</span>
<span class="pl-c"><span class="pl-c">#</span>          val  = 2.8607525733342767</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>  __________________________________</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> score : 0.0</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>  __________________________________</span>
</pre></div>
<p><code>@primitive</code> requires that the user define a <code>logpdf</code> definition for the call. This expands into <code>overdub</code> method definitions for the tracer which automatically work with all the core library context/metadata dispatch. The signature for <code>logpdf</code> should match the following type specification:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">logpdf</span>(<span class="pl-k">::</span><span class="pl-c1">typeof</span>(your_func), <span class="pl-k">::</span><span class="pl-c1">Tuple</span>, <span class="pl-k">::</span><span class="pl-c1">T</span>)</pre></div>
<p>where <code>T</code> is the return type of <code>your_func</code>.</p>
<p>Note that, if your defined <code>logpdf</code> is differentiable - gradients will automatically be derived for use in <code>Gradient</code> learning contexts as long as <code>Zygote</code> can differentiate through it. This can be used to e.g. train neural networks in <code>Gradient</code> contexts where the loss is wrapped in the <code>logpdf</code>/<code>@primitive</code> interface mechanism.</p>
<p>The extension mechanism <em>does not</em> check if the user-defined <code>logpdf</code> is valid. This mechanism also overrides the normal fallback (i.e. tracing into calls) for any function for which the mechanism is used to write a <code>logpdf</code> - this means that if you write a <code>logpdf</code> using this mechanism for a call and there <em>is</em> addressed randomness in the call, it will be ignored by the tracer.</p>
<h2><a id="user-content-other-notes" class="anchor" aria-hidden="true" href="#other-notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Other notes</h2>
<p>The motivation for this project is to identify interfaces and techniques to combine programmable inference with graphical model inference. These techniques have complementary strengths and weaknesses - programmable sampling algorithms tend to have difficulties in high-dimensions (but can answer joint queries about a model efficiently when they are efficient) whereas the asymptotic complexity of graphical model algorithms is typically not dependent on the dimensionality of the model (and instead depends on the topology of the dependence graph) but queries are typically restricted to be marginal queries.</p>
<h2><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">module</span> Geometric

<span class="pl-k">using</span> Jaynes<span class="pl-k">:</span> trace
<span class="pl-k">using</span> Distributions

<span class="pl-en">geo</span>(p<span class="pl-k">::</span><span class="pl-c1">Float64</span>) <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">:flip</span>, Bernoulli, (p, )) <span class="pl-k">==</span> <span class="pl-c1">1</span> ? <span class="pl-c1">0</span> : <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">rand</span>(<span class="pl-c1">:geo</span>, geo, p)

tr, score <span class="pl-k">=</span> <span class="pl-c1">trace</span>(geo, (<span class="pl-c1">0.3</span>, ))
<span class="pl-c1">display</span>(tr)

<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> module</span>

<span class="pl-c"><span class="pl-c">#</span>  __________________________________</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>               Playback</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> :geo =&gt; :flip</span>
<span class="pl-c"><span class="pl-c">#</span>          val  = 0</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> flip</span>
<span class="pl-c"><span class="pl-c">#</span>          val  = 0</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> :geo =&gt; (:geo =&gt; :flip)</span>
<span class="pl-c"><span class="pl-c">#</span>          val  = 1</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>  __________________________________</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> score : 0.0</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> func : typeof(Main.Geometric.geo)</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> args : Tuple{Float64}</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> retval : 2</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>  __________________________________</span></pre></div>
<h2><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Acknowledgements</h2>
<p>The ideas which are going into this package would not have been possible without numerous conversations with very smart people in the Julia community and beyond. I would like to acknowledge the following people</p>
<blockquote>
<p>Jarred Barber, Alex Lew, Marco Cusumano-Towner, Ben Sherman, Jarrett Revels, Valentin Churavy, George Matheos, Chad Scherrer, Martin Trapp, Philipp Gabler, Lyndon White, Mike Innes, and Ari Katz...amongst many others in the probabilistic programming community.</p>
</blockquote>
<p>as well as the following systems</p>
<blockquote>
<p><a href="https://github.com/probcomp/Gen.jl">Gen</a>, <a href="https://github.com/TuringLang/Turing.jl">Turing</a>, <a href="https://github.com/cscherrer/Soss.jl">Soss</a>, <a href="https://pyro.ai/" rel="nofollow">Pyro</a>, <a href="https://www.unisonweb.org/" rel="nofollow">Unison</a>, <a href="https://github.com/jrevels/Cassette.jl">Cassette</a> and <a href="https://github.com/FluxML/Zygote.jl">Zygote</a>.</p>
</blockquote>
<hr>
</article></div>