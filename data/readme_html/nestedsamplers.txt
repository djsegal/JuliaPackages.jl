<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-nestedsamplersjl" class="anchor" aria-hidden="true" href="#nestedsamplersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>NestedSamplers.jl</h1>
<p><a href="https://github.com/turinglang/NestedSamplers.jl/actions"><img src="https://github.com/turinglang/NestedSamplers.jl/workflows/CI/badge.svg?branch=master" alt="Build Status" style="max-width:100%;"></a>
<a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/report.html" rel="nofollow"><img src="https://camo.githubusercontent.com/5239d3494ae5da263ce314d380efb7e65c86c8e2/68747470733a2f2f6a756c696163692e6769746875622e696f2f4e616e6f736f6c646965725265706f7274732f706b676576616c5f6261646765732f4e2f4e657374656453616d706c6572732e737667" alt="PkgEval" data-canonical-src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/N/NestedSamplers.svg" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/turinglang/NestedSamplers.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a5d61d0518c2965a37f670d4dcb9a736664e85e8/68747470733a2f2f636f6465636f762e696f2f67682f747572696e676c616e672f4e657374656453616d706c6572732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/turinglang/NestedSamplers.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>A Julian implementation of single- and multi-ellipsoidal nested sampling algorithms using the <a href="https://github.com/turinglang/abstractmcmc.jl">AbstractMCMC</a> interface.</p>
<p>This package was heavily influenced by <a href="https://github.com/kbarbary/nestle"><code>nestle</code></a>, <a href="https://github.com/joshspeagle/dynesty"><code>dynesty</code></a>, and <a href="https://github.com/kbarbary/NestedSampling.jl"><code>NestedSampling.jl</code></a>.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>To use the nested samplers first install this library</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> ]add NestedSamplers</pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The samplers are built using the <a href="https://github.com/turinglang/abstractmcmc.jl">AbstractMCMC</a> interface. To use it, we need to create a <code>NestedModel</code>.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> NestedSamplers
<span class="pl-k">using</span> Distributions

<span class="pl-c"><span class="pl-c">#</span> eggbox likelihood function</span>
tmax <span class="pl-k">=</span> <span class="pl-c1">3</span>π
<span class="pl-k">function</span> <span class="pl-en">logl</span>(x)
    t <span class="pl-k">=</span> <span class="pl-c1">@.</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> tmax <span class="pl-k">*</span> x <span class="pl-k">-</span> tmax
    <span class="pl-k">return</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">cos</span>(t[<span class="pl-c1">1</span>]<span class="pl-k">/</span><span class="pl-c1">2</span>) <span class="pl-k">*</span> <span class="pl-c1">cos</span>(t[<span class="pl-c1">2</span>]<span class="pl-k">/</span><span class="pl-c1">2</span>)<span class="pl-k">^</span><span class="pl-c1">5</span>
<span class="pl-k">end</span>
priors <span class="pl-k">=</span> [
    <span class="pl-c1">Uniform</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>),
    <span class="pl-c1">Uniform</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>)
]
<span class="pl-c"><span class="pl-c">#</span> or equivalently</span>
<span class="pl-en">prior_transform</span>(X) <span class="pl-k">=</span> X
<span class="pl-c"><span class="pl-c">#</span> create the model</span>
model <span class="pl-k">=</span> <span class="pl-c1">NestedModel</span>(logl, priors); <span class="pl-c"><span class="pl-c">#</span> or model = NestedModel(logl, prior_transform)</span></pre></div>
<p>now, we set up our sampling using <a href="https://github.com/JuliaStats/StatsBase.jl">StatsBase</a></p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> StatsBase<span class="pl-k">:</span> sample, Weights
<span class="pl-k">using</span> MCMCChains<span class="pl-k">:</span> Chains

<span class="pl-c"><span class="pl-c">#</span> create our sampler</span>
<span class="pl-c"><span class="pl-c">#</span> 2 parameters, 100 active points, multi-ellipsoid. See docstring</span>
spl <span class="pl-k">=</span> <span class="pl-c1">Nested</span>(<span class="pl-c1">2</span>, <span class="pl-c1">100</span>, bounds<span class="pl-k">=</span>Bounds<span class="pl-k">.</span>MultiEllipsoid)
<span class="pl-c"><span class="pl-c">#</span> by default, uses dlogz_convergence. Set the keyword args here</span>
<span class="pl-c"><span class="pl-c">#</span> currently Chains and Array are support chain_types</span>
chain <span class="pl-k">=</span> <span class="pl-c1">sample</span>(model, spl;
               dlogz<span class="pl-k">=</span><span class="pl-c1">0.2</span>,
               param_names<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>],
               chain_type<span class="pl-k">=</span>Chains)</pre></div>
<pre><code>Object of type Chains, with data of type 360×3×1 Array{Float64,3}

Log evidence      = 2.0732388578259826
Iterations        = 1:360
Thinning interval = 1
Chains            = 1
Samples per chain = 360
internals         = weights
parameters        = x, y

2-element Array{MCMCChains.ChainDataFrame,1}

Summary Statistics
  parameters    mean     std  naive_se    mcse       ess   r_hat
  ──────────  ──────  ──────  ────────  ──────  ────────  ──────
           x  0.5123  0.3071    0.0162  0.0086  397.0281  0.9972
           y  0.5149  0.3072    0.0162  0.0244  355.1881  1.0012

Quantiles
  parameters    2.5%   25.0%   50.0%   75.0%   97.5%
  ──────────  ──────  ──────  ──────  ──────  ──────
           x  0.0293  0.2202  0.5088  0.8070  0.9799
           y  0.0437  0.1992  0.5071  0.8212  0.9667
</code></pre>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> StatsPlots
<span class="pl-c1">density</span>(chain)
<span class="pl-c"><span class="pl-c">#</span> analytical posterior maxima</span>
<span class="pl-c1">vline!</span>([<span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span> π<span class="pl-k">/</span>tmax, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">+</span> π<span class="pl-k">/</span>tmax], c<span class="pl-k">=</span><span class="pl-c1">:black</span>, ls<span class="pl-k">=</span><span class="pl-c1">:dash</span>, subplot<span class="pl-k">=</span><span class="pl-c1">1</span>)
<span class="pl-c1">vline!</span>([<span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span> π<span class="pl-k">/</span>tmax, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">+</span> π<span class="pl-k">/</span>tmax], c<span class="pl-k">=</span><span class="pl-c1">:black</span>, ls<span class="pl-k">=</span><span class="pl-c1">:dash</span>, subplot<span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="docs/figures/README_4_1.png"><img src="docs/figures/README_4_1.png" alt="" style="max-width:100%;"></a></p>
<h2><a id="user-content-apireference" class="anchor" aria-hidden="true" href="#apireference"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API/Reference</h2>
<h3><a id="user-content-samplers" class="anchor" aria-hidden="true" href="#samplers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Samplers</h3>
<pre><code>NestedModel(loglike, prior_transform)
NestedModel(loglike, priors::AbstractVector{&lt;:Distribution})
</code></pre>
<p><code>loglike</code> must be callable with a signature <code>loglike(::AbstractVector)</code> where the length of the vector must match the number of parameters in your model.</p>
<p><code>prior_transform</code> must be a callable with a signature <code>prior_transform(::AbstractVector)</code> that returns the transformation from the unit-cube to parameter space. This is effectively the quantile or ppf of a statistical distribution. For convenience, if a vector of <code>Distribution</code> is provided (as a set of priors), a transformation function will automatically be constructed using <code>Distributions.quantile</code>.</p>
<p><strong>Note:</strong> <code>loglike</code> is the only function used for likelihood calculations. This means if you want your priors to be used for the likelihood calculations they must be manually included in the <code>loglike</code> function.</p>
<hr>
<pre><code>Nested(ndims, nactive;
    bounds=Bounds.MultiEllipsoid,
    proposal=:auto,
    enlarge=1.25,
    update_interval=default_update_interval(proposal),
    min_ncall=2nactive,
    min_eff=0.10)
</code></pre>
<p>Static nested sampler with <code>nactive</code> active points and <code>ndims</code> parameters.</p>
<p><code>ndims</code> is equivalent to the number of parameters to fit, which defines the dimensionality of the prior volume used in evidence sampling. <code>nactive</code> is the number of live or active points in the prior volume. This is a static sampler, so the number of live points will be constant for all of the sampling.</p>
<h2><a id="user-content-bounds-and-proposals" class="anchor" aria-hidden="true" href="#bounds-and-proposals"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Bounds and Proposals</h2>
<p><code>bounds</code> declares the Type of <a href="@ref"><code>Bounds.AbstractBoundingSpace</code></a> to use in the prior volume. The available bounds are described by <a href="@ref"><code>Bounds</code></a>. <code>proposal</code> declares the algorithm used for proposing new points. The available proposals are described in <a href="@ref"><code>Proposals</code></a>. If <code>proposal</code> is <code>:auto</code>, will choose the proposal based on <code>ndims</code></p>
<ul>
<li><code>ndims &lt; 10</code> - <a href="@ref"><code>Proposals.Uniform</code></a></li>
<li><code>ndims ≥ 10</code> - <a href="@ref"><code>Proposals.RWalk</code></a></li>
</ul>
<p>The original nested sampling algorithm is roughly equivalent to using <code>Bounds.Ellipsoid</code> with <code>Proposals.Uniform</code>. The MultiNest algorithm is roughly equivalent to <code>Bounds.MultiEllipsoid</code> with <code>Proposals.Uniform</code>.</p>
<h2><a id="user-content-other-parameters" class="anchor" aria-hidden="true" href="#other-parameters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Other Parameters</h2>
<ul>
<li>
<p><code>enlarge</code> - When fitting the bounds to live points, they will be enlarged (in terms of volume) by this linear factor.</p>
</li>
<li>
<p><code>update_interval</code> - How often to refit the live points with the bounds as a fraction of <code>nactive</code>. By default this will be determined using <code>default_update_interval</code> for the given proposal</p>
<ul>
<li><code>Proposals.Uniform</code> - <code>1.5</code></li>
<li><code>Proposals.RWalk</code> - <code>0.15walks</code></li>
</ul>
</li>
<li>
<p><code>min_ncall</code> - The minimum number of iterations before trying to fit the first bound</p>
</li>
<li>
<p><code>min_eff</code> - The maximum efficiency before trying to fit the first bound</p>
</li>
</ul>
<hr>
<h3><a id="user-content-bounds" class="anchor" aria-hidden="true" href="#bounds"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Bounds</h3>
<pre><code>NestedSamplers.Bounds
</code></pre>
<p>This module contains the different algorithms for bounding the prior volume.</p>
<p>The available implementations are</p>
<ul>
<li><a href="@ref"><code>Bounds.NoBounds</code></a> - no bounds on the prior volume (equivalent to a unit cube)</li>
<li><a href="@ref"><code>Bounds.Ellipsoid</code></a> - bound using a single ellipsoid</li>
<li><a href="@ref"><code>Bounds.MultiEllipsoid</code></a> - bound using multiple ellipsoids in an optimal cluster</li>
</ul>
<hr>
<pre><code>Bounds.NoBounds([T=Float64], N)
</code></pre>
<p>Unbounded prior volume; equivalent to the unit cube in <code>N</code> dimensions.</p>
<hr>
<pre><code>Bounds.Ellipsoid([T=Float64], N)
Bounds.Ellipsoid(center::AbstractVector, A::AbstractMatrix)
</code></pre>
<p>An <code>N</code>-dimensional ellipsoid defined by</p>
<p>$$
(x - center)^T A (x - center) = 1
$$</p>
<p>where <code>size(center) == (N,)</code> and <code>size(A) == (N,N)</code>.</p>
<hr>
<pre><code>Bounds.MultiEllipsoid([T=Float64], ndims)
Bounds.MultiEllipsoid(::AbstractVector{Ellipsoid})
</code></pre>
<p>Use multiple <a href="@ref"><code>Ellipsoid</code></a>s in an optimal clustering to bound prior space. For more details about the bounding algorithm, see the extended help (<code>??Bounds.MultiEllipsoid</code>)</p>
<hr>
<h3><a id="user-content-proposals" class="anchor" aria-hidden="true" href="#proposals"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Proposals</h3>
<pre><code>NestedSamplers.Proposals
</code></pre>
<p>This module contains the different algorithms for proposing new points within a bounding volume in unit space.</p>
<p>The available implementations are</p>
<ul>
<li><a href="@ref"><code>Proposals.Uniform</code></a> - samples uniformly within the bounding volume</li>
<li><a href="@ref"><code>Proposals.RWalk</code></a> - random walks to a new point given an existing one</li>
</ul>
<hr>
<pre><code>Proposals.Uniform()
</code></pre>
<p>Propose a new live point by uniformly sampling within the bounding volume.</p>
<hr>
<pre><code>Proposals.RWalk(;ratio=0.5, walks=25, scale=1)
</code></pre>
<p>Propose a new live point by random walking away from an existing live point.</p>
<p><code>ratio</code> is the target acceptance ratio, <code>walks</code> is the minimum number of steps to take, and <code>scale</code> is the proposal distribution scale, which will update <em>between</em> proposals.</p>
<hr>
<h3><a id="user-content-convergence" class="anchor" aria-hidden="true" href="#convergence"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Convergence</h3>
<pre><code>dlogz_convergence(args...; dlogz=0.5, kwargs...)
</code></pre>
<p>Stopping criterion: estimated fraction evidence remaining below threshold.</p>
<p>The estimated fraction evidence remaining is given by the <code>maximum(active_loglike) - it/nactive</code> where <code>it</code> is the current iteration.</p>
<hr>
<pre><code>decline_convergence(args...; decline_factor=6, kwargs...)
</code></pre>
<p>Stopping criterion: Number of consecutive declining log-evidence is greater than <code>iteration / decline_factor</code> or greater than <code>2nactive</code></p>
<h2><a id="user-content-contributing" class="anchor" aria-hidden="true" href="#contributing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contributing</h2>
<p><strong>Primary Author:</strong> Miles Lucas (<a href="https://github.com/mileslucas">@mileslucas</a>)</p>
<p>Contributions are always welcome! Take a look at the <a href="https://github.com/turinglang/nestedsamplers.jl/issues">issues</a> for ideas of open problems!</p>
<hr>
<p>This file was generated from <a href="docs/README.jmd">README.jmd</a> using <a href="https://github.com/JunoLab/Weave.jl">Weave.jl</a></p>
</article></div>