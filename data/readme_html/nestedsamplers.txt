<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-nestedsamplersjl" class="anchor" aria-hidden="true" href="#nestedsamplersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NestedSamplers.jl</h1>
<p dir="auto"><a href="https://github.com/TuringLang/NestedSamplers.jl/actions"><img src="https://github.com/TuringLang/NestedSamplers.jl/workflows/CI/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/report.html" rel="nofollow"><img src="https://camo.githubusercontent.com/1fe6d1f55ea4bc562d399d3e089d73cce24b0abe69c6f0a48307be9f10bb92cf/68747470733a2f2f6a756c696163692e6769746875622e696f2f4e616e6f736f6c646965725265706f7274732f706b676576616c5f6261646765732f4e2f4e657374656453616d706c6572732e737667" alt="PkgEval" data-canonical-src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/N/NestedSamplers.svg" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/TuringLang/NestedSamplers.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/30cb5d811d46974f5afa6e966e87e28379ffeb9ab47deae4939f3efd93dec137/68747470733a2f2f636f6465636f762e696f2f67682f547572696e674c616e672f4e657374656453616d706c6572732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/TuringLang/NestedSamplers.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a>
<a href="LICENSE"><img src="https://camo.githubusercontent.com/754ad8eaf947e3aa14fe30a60b904045309ffa7deb248b599e99f845611ae200/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f547572696e674c616e672f4e657374656453616d706c6572732e6a6c3f636f6c6f723d79656c6c6f77" alt="LICENSE" data-canonical-src="https://img.shields.io/github/license/TuringLang/NestedSamplers.jl?color=yellow" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://TuringLang.github.io/NestedSamplers.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://TuringLang.github.io/NestedSamplers.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Implementations of single- and multi-ellipsoidal nested sampling algorithms in pure Julia. We implement the <a href="https://github.com/TuringLang/AbstractMCMC.jl">AbstractMCMC.jl</a> interface, allowing straightforward sampling from a variety of statistical models.</p>
<p dir="auto">This package was heavily influenced by <a href="https://github.com/kbarbary/nestle">nestle</a>, <a href="https://github.com/joshspeagle/dynesty">dynesty</a>, and <a href="https://github.com/kbarbary/NestedSampling.jl">NestedSampling.jl</a>.</p>
<h2 dir="auto"><a id="user-content-citing" class="anchor" aria-hidden="true" href="#citing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citing</h2>
<p dir="auto"><a href="https://doi.org/10.5281/zenodo.3950594" rel="nofollow"><img src="https://camo.githubusercontent.com/b9a9e64bcbac703a7cf470e2bb5bf6dcc4b9582261ef44609301129ae337cd40/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f444f492f31302e353238312f7a656e6f646f2e333935303539342e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/DOI/10.5281/zenodo.3950594.svg" style="max-width: 100%;"></a></p>
<p dir="auto">If you use this library, or a derivative of it, in your work, please consider citing it. This code is built off a multitude of academic works, which have been noted in the docstrings where appropriate. These references, along with references for the more general calculations, can all be found in <a href="CITATION.bib">CITATION.bib</a></p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">To use the nested samplers first install this library</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ]add NestedSamplers"><pre>julia<span class="pl-k">&gt;</span> ]add NestedSamplers</pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">For in-depth usage, see the <a href="https://TuringLang.github.io/NestedSamplers.jl/dev/" rel="nofollow">online documentation</a>. In general, you'll need to write a log-likelihood function and a prior transform function. These are supplied to a <code>NestedModel</code>, defining the statistical model</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using NestedSamplers
using Distributions
using LinearAlgebra

logl(X) = logpdf(MvNormal([1, -1], I), X)
prior(X) = 4 .* (X .- 0.5)
# or equivalently
priors = [Uniform(-2, 2), Uniform(-2, 2)]
model = NestedModel(logl, priors)"><pre><span class="pl-k">using</span> NestedSamplers
<span class="pl-k">using</span> Distributions
<span class="pl-k">using</span> LinearAlgebra

<span class="pl-en">logl</span>(X) <span class="pl-k">=</span> <span class="pl-c1">logpdf</span>(<span class="pl-c1">MvNormal</span>([<span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>], I), X)
<span class="pl-en">prior</span>(X) <span class="pl-k">=</span> <span class="pl-c1">4</span> <span class="pl-k">.*</span> (X <span class="pl-k">.-</span> <span class="pl-c1">0.5</span>)
<span class="pl-c"><span class="pl-c">#</span> or equivalently</span>
priors <span class="pl-k">=</span> [<span class="pl-c1">Uniform</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-c1">Uniform</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">2</span>)]
model <span class="pl-k">=</span> <span class="pl-c1">NestedModel</span>(logl, priors)</pre></div>
<p dir="auto">after defining the model, set up the nested sampler. This will involve choosing the bounding space and proposal scheme, or you can rely on the defaults. In addition, we need to define the dimensionality of the problem and the number of live points. More points results in a more precise evidence estimate at the cost of runtime. For more information, see the docs.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="bounds = Bounds.MultiEllipsoid
prop = Proposals.Slice(slices=10)
# 1000 live points
sampler = Nested(2, 1000; bounds=bounds, proposal=prop)"><pre>bounds <span class="pl-k">=</span> Bounds<span class="pl-k">.</span>MultiEllipsoid
prop <span class="pl-k">=</span> Proposals<span class="pl-k">.</span><span class="pl-c1">Slice</span>(slices<span class="pl-k">=</span><span class="pl-c1">10</span>)
<span class="pl-c"><span class="pl-c">#</span> 1000 live points</span>
sampler <span class="pl-k">=</span> <span class="pl-c1">Nested</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1000</span>; bounds<span class="pl-k">=</span>bounds, proposal<span class="pl-k">=</span>prop)</pre></div>
<p dir="auto">once the sampler is set up, we can leverage all of the <a href="https://github.com/TuringLang/AbstractMCMC.jl">AbstractMCMC.jl</a> interface, including the step iterator, transducer, and a convenience <code>sample</code> method. The <code>sample</code> method takes keyword arguments for the convergence criteria.</p>
<p dir="auto"><strong>Note:</strong> both the samples <em>and</em> the sampler state will be returned by <code>sample</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using StatsBase
chain, state = sample(model, sampler; dlogz=0.2)"><pre><span class="pl-k">using</span> StatsBase
chain, state <span class="pl-k">=</span> <span class="pl-c1">sample</span>(model, sampler; dlogz<span class="pl-k">=</span><span class="pl-c1">0.2</span>)</pre></div>
<p dir="auto">you can resample taking into account the statistical weights, again using StatsBase</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="chain_resampled = sample(chain, Weights(vec(chain[&quot;weights&quot;])), length(chain))"><pre>chain_resampled <span class="pl-k">=</span> <span class="pl-c1">sample</span>(chain, <span class="pl-c1">Weights</span>(<span class="pl-c1">vec</span>(chain[<span class="pl-s"><span class="pl-pds">"</span>weights<span class="pl-pds">"</span></span>])), <span class="pl-c1">length</span>(chain))</pre></div>
<p dir="auto">These are chains from <a href="https://github.com/TuringLang/MCMCChains.jl">MCMCChains.jl</a>, which offer a lot of flexibility in exploring posteriors, combining data, and offering lots of convenient conversions (like to <code>DataFrame</code>s).</p>
<p dir="auto">Finally, we can see the estimate of the Bayesian evidence</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Measurements
state.logz ± state.logzerr"><pre><span class="pl-k">using</span> Measurements
state<span class="pl-k">.</span>logz ± state<span class="pl-k">.</span>logzerr</pre></div>
<h2 dir="auto"><a id="user-content-contributions-and-support" class="anchor" aria-hidden="true" href="#contributions-and-support"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contributions and Support</h2>
<p dir="auto"><a href="https://github.com/SciML/ColPrac"><img src="https://camo.githubusercontent.com/a6c1efcb19a957860ecb25966a730260b03d6e05380d0c27992ee7f9e3b1feb3/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436f6c507261632d436f6e7472696275746f72277325323047756964652d626c756576696f6c6574" alt="ColPrac: Contributor's Guide on Collaborative Practices for Community Packages" data-canonical-src="https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet" style="max-width: 100%;"></a></p>
<p dir="auto"><strong>Primary Author:</strong> Miles Lucas (<a href="https://github.com/mileslucas">@mileslucas</a>)</p>
<p dir="auto">Contributions are always welcome! In general, contributions should follow <a href="https://github.com/SciML/ColPrac">ColPrac</a>. Take a look at the <a href="https://github.com/TuringLang/NestedSamplers.jl/issues">issues</a> for ideas of open problems! To discuss ideas or plan contributions, open a <a href="https://github.com/TuringLang/NestedSamplers.jl/discussions">discussion</a>.</p>
</article></div>