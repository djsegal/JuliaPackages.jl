<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-nestedsamplersjl" class="anchor" aria-hidden="true" href="#nestedsamplersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NestedSamplers.jl</h1>
<p><a href="https://github.com/turinglang/NestedSamplers.jl/actions"><img src="https://github.com/turinglang/NestedSamplers.jl/workflows/CI/badge.svg?branch=master" alt="Build Status" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/turinglang/NestedSamplers.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a5d61d0518c2965a37f670d4dcb9a736664e85e8/68747470733a2f2f636f6465636f762e696f2f67682f747572696e676c616e672f4e657374656453616d706c6572732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/turinglang/NestedSamplers.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>A Julian implementation of single- and multi-ellipsoidal nested sampling algorithms using the <a href="https://github.com/turinglang/abstractmcmc.jl">AbstractMCMC</a> interface.</p>
<p>This package was heavily influenced by <a href="https://github.com/kbarbary/nestle"><code>nestle</code></a> and <a href="https://github.com/kbarbary/NestedSampling.jl"><code>NestedSampling.jl</code></a>.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>To use the nested samplers first install this library</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> ]add NestedSamplers</pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>The samplers are built using the <a href="https://github.com/turinglang/abstractmcmc.jl">AbstractMCMC</a> interface. To use it, we need to create a <code>NestedModel</code>.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> NestedSamplers
<span class="pl-k">using</span> Distributions

<span class="pl-c"><span class="pl-c">#</span> eggbox likelihood function</span>
tmax <span class="pl-k">=</span> <span class="pl-c1">3</span>π
<span class="pl-k">function</span> <span class="pl-en">logl</span>(x)
    t <span class="pl-k">=</span> <span class="pl-c1">@.</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> tmax <span class="pl-k">*</span> x <span class="pl-k">-</span> tmax
    <span class="pl-k">return</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">cos</span>(t[<span class="pl-c1">1</span>]<span class="pl-k">/</span><span class="pl-c1">2</span>) <span class="pl-k">*</span> <span class="pl-c1">cos</span>(t[<span class="pl-c1">2</span>]<span class="pl-k">/</span><span class="pl-c1">2</span>)<span class="pl-k">^</span><span class="pl-c1">5</span>
<span class="pl-k">end</span>
priors <span class="pl-k">=</span> [
    <span class="pl-c1">Uniform</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>),
    <span class="pl-c1">Uniform</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>)
]
<span class="pl-c"><span class="pl-c">#</span> create the model</span>
model <span class="pl-k">=</span> <span class="pl-c1">NestedModel</span>(logl, priors);</pre></div>
<p>now, we set up our sampling using <a href="https://github.com/JuliaStats/StatsBase.jl">StatsBase</a></p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> StatsBase<span class="pl-k">:</span> sample
<span class="pl-k">using</span> MCMCChains<span class="pl-k">:</span> Chains

<span class="pl-c"><span class="pl-c">#</span> create our sampler</span>
<span class="pl-c"><span class="pl-c">#</span> 100 active points; multi-ellipsoid. See docstring</span>
spl <span class="pl-k">=</span> <span class="pl-c1">Nested</span>(<span class="pl-c1">100</span>, method<span class="pl-k">=</span><span class="pl-c1">:multi</span>)
<span class="pl-c"><span class="pl-c">#</span> by default, uses dlogz_convergence. Set the keyword args here</span>
<span class="pl-c"><span class="pl-c">#</span> currently Chains and Array are support chain_types</span>
chain <span class="pl-k">=</span> <span class="pl-c1">sample</span>(model, spl;
               dlogz<span class="pl-k">=</span><span class="pl-c1">0.2</span>,
               param_names<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>],
               chain_type<span class="pl-k">=</span>Chains)</pre></div>
<pre><code>Object of type Chains, with data of type 355×3×1 Array{Float64,3}

Log evidence      = 8.401484862715426
Iterations        = 1:355
Thinning interval = 1
Chains            = 1
Samples per chain = 355
internals         = weights
parameters        = x, y

2-element Array{MCMCChains.ChainDataFrame,1}

Summary Statistics
  parameters    mean     std  naive_se    mcse       ess   r_hat
  ──────────  ──────  ──────  ────────  ──────  ────────  ──────
           x  0.4739  0.3118    0.0166  0.0159  337.7470  0.9976
           y  0.4768  0.2986    0.0158  0.0204  352.2510  0.9977

Quantiles
  parameters    2.5%   25.0%   50.0%   75.0%   97.5%
  ──────────  ──────  ──────  ──────  ──────  ──────
           x  0.0291  0.1744  0.4682  0.7870  0.9574
           y  0.0313  0.1822  0.4672  0.7974  0.9137
</code></pre>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> StatsPlots
<span class="pl-c1">density</span>(chain)
<span class="pl-c"><span class="pl-c">#</span> analytical posterior maxima</span>
<span class="pl-c1">vline!</span>([<span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span> π<span class="pl-k">/</span>tmax, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">+</span> π<span class="pl-k">/</span>tmax], c<span class="pl-k">=</span><span class="pl-c1">:black</span>, ls<span class="pl-k">=</span><span class="pl-c1">:dash</span>, subplot<span class="pl-k">=</span><span class="pl-c1">1</span>)
<span class="pl-c1">vline!</span>([<span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span> π<span class="pl-k">/</span>tmax, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">+</span> π<span class="pl-k">/</span>tmax], c<span class="pl-k">=</span><span class="pl-c1">:black</span>, ls<span class="pl-k">=</span><span class="pl-c1">:dash</span>, subplot<span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="docs/figures/README_4_1.png"><img src="docs/figures/README_4_1.png" alt="" style="max-width:100%;"></a></p>
<h2><a id="user-content-apireference" class="anchor" aria-hidden="true" href="#apireference"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>API/Reference</h2>
<pre><code>Nested(nactive; enlarge=1.2, update_interval=round(Int, 0.6nactive), method=:single)
</code></pre>
<p>Ellipsoidal nested sampler.</p>
<p>The two methods are <code>:single</code>, which uses a single bounding ellipsoid, and <code>:multi</code>, which finds an optimal clustering of ellipsoids.</p>
<h3><a id="user-content-parameters" class="anchor" aria-hidden="true" href="#parameters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parameters</h3>
<ul>
<li><code>nactive</code> - The number of live points.</li>
<li><code>enlarge</code> - When fitting ellipsoids to live points, they will be enlarged (in terms of volume) by this factor.</li>
<li><code>update_interval</code> - How often to refit the live points with the ellipsoids</li>
<li><code>method</code> - as mentioned above, the algorithm to use for sampling. <code>:single</code> uses a single ellipsoid and follows the original nested sampling algorithm proposed in Skilling 2004. <code>:multi</code> uses multiple ellipsoids- much like the MultiNest algorithm.</li>
</ul>
<hr>
<pre><code>NestedModel(loglike, priors::AbstractVector{&lt;:Distribution})
</code></pre>
<p>A model for use with the <code>Nested</code> sampler.</p>
<p><code>loglike</code> must be callable with a signature <code>loglike(::AbstractVector)::Real</code> where the length of the vector must match the number of parameters in your model.</p>
<p><code>priors</code> are required for each variable in order to transform between a unit-sphere and parameter space. This means they must have <code>Distributions.cdf</code> and <code>Distributions.quantile</code> implemented.</p>
<p><strong>Note:</strong> <code>loglike</code> is the only function used for likelihood calculations. This means if you want your priors to be used for the likelihood calculations they must be manually included in that function.</p>
<hr>
<pre><code>dlogz_convergence(args...; dlogz=0.5, kwargs...)
</code></pre>
<p>Stopping criterion: estimated fraction evidence remaining below threshold.</p>
<p>The estimated fraction evidence remaining is given by the <code>maximum(active_loglike) - it/nactive</code> where <code>it</code> is the current iteration.</p>
<hr>
<pre><code>decline_convergence(args...; decline_factor=6, kwargs...)
</code></pre>
<p>Stopping criterion: Number of consecutive declining log-evidence is greater than <code>iteration / decline_factor</code> or greater than <code>2nactive</code></p>
<h2><a id="user-content-contributing" class="anchor" aria-hidden="true" href="#contributing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Contributing</h2>
<p><strong>Primary Author:</strong> Miles Lucas (<a href="https://github.com/mileslucas">@mileslucas</a>)</p>
<p>Contributions are always welcome! Take a look at the <a href="https://github.com/turinglang/nestedsamplers.jl/issues">issues</a> for ideas of open problems!</p>
<hr>
<p>This file was generated from <a href="docs/README.jmd">README.jmd</a> using <a href="https://github.com/JunoLab/Weave.jl">Weave.jl</a></p>
</article></div>