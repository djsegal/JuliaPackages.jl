<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-easyranges-range-expressions-made-easier-for-julia" class="anchor" aria-hidden="true" href="#easyranges-range-expressions-made-easier-for-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>EasyRanges: range expressions made easier for Julia</h1>
<p dir="auto"><a href="https://github.com/emmt/EasyRanges.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/emmt/EasyRanges.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/emmt/EasyRanges-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/b6474afc3013a5631e9882709e3371a55a1c8fe7d8cf7660f3724a31ec953f8a/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f656d6d742f4561737952616e6765732e6a6c3f7376673d74727565" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/emmt/EasyRanges.jl?svg=true" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/emmt/EasyRanges.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/689bf0fa63273ae3cd2794e65c5db95928b978dd6b310ec9a5215c74418e3ddd/68747470733a2f2f636f6465636f762e696f2f67682f656d6d742f4561737952616e6765732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/emmt/EasyRanges.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><code>EasyRanges</code> is a small Julia package dedicated at making life easier with
integer or Cartesian indices and ranges.  This package exports macros <code>@range</code>
and <code>@reverse_range</code> which take a single expression and rewrite it with
extended syntax rules to produce an <code>Int</code>-valued <em>index range</em> which may be a
step range or an instance of <code>CartesianIndices</code>.  These two macros differ in
the step sign of the result.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using EasyRanges"><pre><span class="pl-k">using</span> EasyRanges</pre></div>
<p dir="auto">brings two macros, <code>@range</code> and <code>@reverse_range</code>, into scope.  These macros can
be used as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range expr
@reverse_range expr"><pre><span class="pl-c1">@range</span> expr
<span class="pl-c1">@reverse_range</span> expr</pre></div>
<p dir="auto">to evaluate expression <code>expr</code> with special rules (see below) where integers,
Cartesian indices, and ranges of integers or of Cartesian indices are treated
specifically:</p>
<ul dir="auto">
<li>
<p dir="auto">integers are converted to <code>Int</code>, ranges to <code>Int</code>-valued ranges, and tuples of
integers to tuples of <code>Int</code>;</p>
</li>
<li>
<p dir="auto">arithmetic expressions only involving indices and ranges yield lightweight
and efficient ranges (of integers or of Cartesian indices);</p>
</li>
<li>
<p dir="auto">ranges produced by <code>@range</code> (resp. <code>@reverse_range</code>) always have positive
(resp. negative) steps;</p>
</li>
<li>
<p dir="auto">operators <code>+</code> and <code>-</code> can be used to <a href="#shift-operations"><em>shift</em></a> index
ranges;</p>
</li>
<li>
<p dir="auto">operator <code>∩</code> and method <code>intersect</code> yield the <a href="#intersecting">intersection</a>
of ranges with ranges, of ranges with indices, or of indices with indices;</p>
</li>
<li>
<p dir="auto">operator <code>±</code> can be used to <a href="#stretching"><em>stretch</em></a> ranges or to produce
centered ranges;</p>
</li>
<li>
<p dir="auto">operator <code>∓</code> can be used to <a href="#shrinking"><em>shrink</em></a> ranges.</p>
</li>
</ul>
<p dir="auto">As shown in <a href="#a-working-example"><em>A working example</em></a> below, these rules are
useful for writing readable ranges in <code>for</code> loops without sacrificing
efficiency.</p>
<h3 dir="auto"><a id="user-content-definitions" class="anchor" aria-hidden="true" href="#definitions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Definitions</h3>
<p dir="auto">In <code>EasyRanges</code>, if <em>indices</em> are integers, <em>ranges</em> means ranges of integers
(of super-type <code>OrdinalRange{Int}{Int}</code>); if <em>indices</em> are Cartesian indices,
<em>ranges</em> means ranges of Cartesian indices (of super-type <code>CartesianIndices</code>).</p>
<h3 dir="auto"><a id="user-content-shift-operations" class="anchor" aria-hidden="true" href="#shift-operations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Shift operations</h3>
<p dir="auto">In <code>@range</code> and <code>@reverse_range</code> expressions, an index range <code>R</code> can be shifted
with the operators <code>+</code> and <code>-</code> by an amount specified by an index <code>I</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range R + I -&gt; S # J ∈ S is equivalent to J - I ∈ R
@range R - I -&gt; S # J ∈ S is equivalent to J + I ∈ R

@range I + R -&gt; S # J ∈ S is equivalent to J - I ∈ R
@range I - R -&gt; S # J ∈ S is equivalent to I - J ∈ R"><pre><span class="pl-c1">@range</span> R <span class="pl-k">+</span> I <span class="pl-k">-&gt;</span> S <span class="pl-c"><span class="pl-c">#</span> J ∈ S is equivalent to J - I ∈ R</span>
<span class="pl-c1">@range</span> R <span class="pl-k">-</span> I <span class="pl-k">-&gt;</span> S <span class="pl-c"><span class="pl-c">#</span> J ∈ S is equivalent to J + I ∈ R</span>

<span class="pl-c1">@range</span> I <span class="pl-k">+</span> R <span class="pl-k">-&gt;</span> S <span class="pl-c"><span class="pl-c">#</span> J ∈ S is equivalent to J - I ∈ R</span>
<span class="pl-c1">@range</span> I <span class="pl-k">-</span> R <span class="pl-k">-&gt;</span> S <span class="pl-c"><span class="pl-c">#</span> J ∈ S is equivalent to I - J ∈ R</span></pre></div>
<p dir="auto">Integer-valued ranges can be shifted by an integer offset:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range (3:6) + 1    -&gt;  4:7    # (2:6) .+ 1    -&gt;  4:7
@range 1 + (3:6)    -&gt;  4:7    # (2:6) .+ 1    -&gt;  4:7
@range (2:4:10) + 1 -&gt;  3:4:11 # (2:4:10) .+ 1 -&gt;  3:4:11
@range (3:6) - 1    -&gt;  2:5    # (3:6) .- 1    -&gt;  2:5
@range 1 - (3:6)    -&gt; -5:-2   # 1 .- (3:6)    -&gt; -2:-1:-5"><pre><span class="pl-c1">@range</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span>    <span class="pl-k">-&gt;</span>  <span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">7</span>    <span class="pl-c"><span class="pl-c">#</span> (2:6) .+ 1    -&gt;  4:7</span>
<span class="pl-c1">@range</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>)    <span class="pl-k">-&gt;</span>  <span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">7</span>    <span class="pl-c"><span class="pl-c">#</span> (2:6) .+ 1    -&gt;  4:7</span>
<span class="pl-c1">@range</span> (<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">10</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">-&gt;</span>  <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">11</span> <span class="pl-c"><span class="pl-c">#</span> (2:4:10) .+ 1 -&gt;  3:4:11</span>
<span class="pl-c1">@range</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">-</span> <span class="pl-c1">1</span>    <span class="pl-k">-&gt;</span>  <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">5</span>    <span class="pl-c"><span class="pl-c">#</span> (3:6) .- 1    -&gt;  2:5</span>
<span class="pl-c1">@range</span> <span class="pl-c1">1</span> <span class="pl-k">-</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>)    <span class="pl-k">-&gt;</span> <span class="pl-k">-</span><span class="pl-c1">5</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> 1 .- (3:6)    -&gt; -2:-1:-5</span></pre></div>
<p dir="auto">This is like using the broadcasting operators <code>.+</code> and <code>.-</code> except that the
result is an <code>Int</code>-valued range and that the step sign is kept positive (as in
the last above example).</p>
<p dir="auto">The <code>@reverse_macro</code> yields ranges with negative steps:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@reverse_range (3:6) + 1 -&gt;  7:-1:4
@reverse_range 1 + (3:6) -&gt;  7:-1:4
@reverse_range (3:6) - 1 -&gt;  5:-1:1
@reverse_range 1 - (3:6) -&gt; -1:-1:-5"><pre><span class="pl-c1">@reverse_range</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">-&gt;</span>  <span class="pl-c1">7</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>
<span class="pl-c1">@reverse_range</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">-&gt;</span>  <span class="pl-c1">7</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>
<span class="pl-c1">@reverse_range</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">-&gt;</span>  <span class="pl-c1">5</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>
<span class="pl-c1">@reverse_range</span> <span class="pl-c1">1</span> <span class="pl-k">-</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-k">-</span><span class="pl-c1">5</span></pre></div>
<p dir="auto">Cartesian ranges can be shifted by a Cartesian index (without penalties on the
execution time and, usually, no extra allocations):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range CartesianIndices((2:6, -1:2)) + CartesianIndex(1,3)
# -&gt; CartesianIndices((3:7, 2:5))
@range CartesianIndex(1,3) + CartesianIndices((2:6, -1:2))
# -&gt; CartesianIndices((3:7, 2:5))
@range CartesianIndices((2:6, -1:2)) - CartesianIndex(1,3)
# -&gt; CartesianIndices((1:5, -4:-1))
@range CartesianIndex(1,3) - CartesianIndices((2:6, -1:2))
# -&gt; CartesianIndices((-5:-1, 1:4))"><pre><span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">6</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) <span class="pl-k">+</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>)
<span class="pl-c"><span class="pl-c">#</span> -&gt; CartesianIndices((3:7, 2:5))</span>
<span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>) <span class="pl-k">+</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">6</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>))
<span class="pl-c"><span class="pl-c">#</span> -&gt; CartesianIndices((3:7, 2:5))</span>
<span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">6</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) <span class="pl-k">-</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>)
<span class="pl-c"><span class="pl-c">#</span> -&gt; CartesianIndices((1:5, -4:-1))</span>
<span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>) <span class="pl-k">-</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">6</span>, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>))
<span class="pl-c"><span class="pl-c">#</span> -&gt; CartesianIndices((-5:-1, 1:4))</span></pre></div>
<p dir="auto">This is similar to the broadcasting operators <code>.+</code> and <code>.-</code> except that a
lightweight instance of <code>CartesianIndices</code> with positive increment is always
produced.</p>
<h3 dir="auto"><a id="user-content-intersecting" class="anchor" aria-hidden="true" href="#intersecting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Intersecting</h3>
<p dir="auto">In <code>@range</code> and <code>@reverse_range</code> expressions, the operator <code>∩</code> (obtained by
typing <code>\cap</code> and pressing the <code>[tab]</code> key at the REPL) and the method
<code>intersect</code> yield the intersection of ranges with ranges, of ranges with
indices, or of indices with indices.</p>
<p dir="auto">The intersection of indices, say <code>I</code> and <code>J</code>, yield a range <code>R</code> (empty if the
integers are different):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range I ∩ J -&gt; R   # R = {I} if I == J, R = {} else"><pre><span class="pl-c1">@range</span> I <span class="pl-k">∩</span> J <span class="pl-k">-&gt;</span> R   <span class="pl-c"><span class="pl-c">#</span> R = {I} if I == J, R = {} else</span></pre></div>
<p dir="auto">Examples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range 3 ∩ 3 -&gt; 3:3
@range 3 ∩ 2 -&gt; 1:0  # empty range
@range CartesianIndex(3,4) ∩ CartesianIndex(3,4) -&gt; CartesianIndices((3:3,4:4))"><pre><span class="pl-c1">@range</span> <span class="pl-c1">3</span> <span class="pl-k">∩</span> <span class="pl-c1">3</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">3</span>
<span class="pl-c1">@range</span> <span class="pl-c1">3</span> <span class="pl-k">∩</span> <span class="pl-c1">2</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>  <span class="pl-c"><span class="pl-c">#</span> empty range</span>
<span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">3</span>,<span class="pl-c1">4</span>) <span class="pl-k">∩</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">3</span>,<span class="pl-c1">4</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">3</span>,<span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">4</span>))</pre></div>
<p dir="auto">The intersection of an index range <code>R</code> and an index <code>I</code> yields an index range
<code>S</code> that is either the singleton <code>{I}</code> (if <code>I</code> belongs to <code>R</code>) or empty (if <code>I</code>
does not belong to <code>R</code>):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range R ∩ I -&gt; S   # S = {I} if I ∈ R, S = {} else
@range I ∩ R -&gt; S   # idem"><pre><span class="pl-c1">@range</span> R <span class="pl-k">∩</span> I <span class="pl-k">-&gt;</span> S   <span class="pl-c"><span class="pl-c">#</span> S = {I} if I ∈ R, S = {} else</span>
<span class="pl-c1">@range</span> I <span class="pl-k">∩</span> R <span class="pl-k">-&gt;</span> S   <span class="pl-c"><span class="pl-c">#</span> idem</span></pre></div>
<p dir="auto">Examples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range (2:6) ∩ 3     -&gt; 3:3 # a singleton range
@range 1 ∩ (2:6)     -&gt; 1:0 # an empty range
@range (2:6) ∩ (3:7) -&gt; 3:6 # intersection of ranges
@range CartesianIndices((2:4, 5:9)) ∩ CartesianIndex(3,7))
    -&gt; CartesianIndices((3:3, 7:7))"><pre><span class="pl-c1">@range</span> (<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">∩</span> <span class="pl-c1">3</span>     <span class="pl-k">-&gt;</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">3</span> <span class="pl-c"><span class="pl-c">#</span> a singleton range</span>
<span class="pl-c1">@range</span> <span class="pl-c1">1</span> <span class="pl-k">∩</span> (<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">6</span>)     <span class="pl-k">-&gt;</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span> <span class="pl-c"><span class="pl-c">#</span> an empty range</span>
<span class="pl-c1">@range</span> (<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">6</span>) <span class="pl-k">∩</span> (<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">7</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span> intersection of ranges</span>
<span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">4</span>, <span class="pl-c1">5</span><span class="pl-k">:</span><span class="pl-c1">9</span>)) <span class="pl-k">∩</span> <span class="pl-c1">CartesianIndex</span>(<span class="pl-c1">3</span>,<span class="pl-c1">7</span>))
    <span class="pl-k">-&gt;</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">3</span>, <span class="pl-c1">7</span><span class="pl-k">:</span><span class="pl-c1">7</span>))</pre></div>
<p dir="auto">These syntaxes are already supported by Julia, but the <code>@range</code> macro
guarantees to return an <code>Int</code>-valued range with a forward (positive) step.</p>
<h3 dir="auto"><a id="user-content-stretching" class="anchor" aria-hidden="true" href="#stretching"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stretching</h3>
<p dir="auto">In <code>@range</code> and <code>@reverse_range</code> expressions, the operator <code>±</code> (obtained by
typing <code>\pm</code> and pressing the <code>[tab]</code> key at the REPL) can be used to
<strong>stretch</strong> ranges or to produce <strong>centered ranges</strong>.</p>
<p dir="auto">The expression <code>R ± I</code> yields the index range <code>R</code> stretched by an amount
specified by index <code>I</code>.  Assuming <code>R</code> is unit range:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range R ± I -&gt; (first(R) - I):(last(R) + I)"><pre><span class="pl-c1">@range</span> R ± I <span class="pl-k">-&gt;</span> (<span class="pl-c1">first</span>(R) <span class="pl-k">-</span> I)<span class="pl-k">:</span>(<span class="pl-c1">last</span>(R) <span class="pl-k">+</span> I)</pre></div>
<p dir="auto">where, if <code>R</code> is a range of integers, <code>I</code> is an integer, and if <code>R</code> is a
<code>N</code>-dimensional Cartesian, <code>I</code> is a <code>N</code>-dimensional Cartesian index range.  Not
shown in the above expression, the range step is preserved by the operation
(except that the result has a positive step).</p>
<p dir="auto">The expression <code>I ± ΔI</code> with <code>I</code> an index and <code>ΔI</code> an index offset yields an
index range centered at <code>I</code>.  Assuming <code>R</code> is unit range:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range I ± ΔI -&gt; (I - ΔI):(I + ΔI)"><pre><span class="pl-c1">@range</span> I ± ΔI <span class="pl-k">-&gt;</span> (I <span class="pl-k">-</span> ΔI)<span class="pl-k">:</span>(I <span class="pl-k">+</span> ΔI)</pre></div>
<p dir="auto">There is no sign correction and the range may be empty.  If <code>I</code> and <code>ΔI</code> are
two integers, <code>I ± ΔI</code> is a range of integers.  If <code>I</code> is a <code>N</code>-dimensional
Cartesian index, then <code>I ± ΔI</code> is a range of Cartesian indices and <code>ΔI</code> can be
an integer, a <code>N</code>-tuple of integers, or a <code>N</code>-dimensional Cartesian index.
Specifying <code>ΔI</code> as a single integer for a <code>N</code>-dimensional Cartesian index <code>I</code>
is identical to specifying the same amount of stretching for each dimension.</p>
<h3 dir="auto"><a id="user-content-shrinking" class="anchor" aria-hidden="true" href="#shrinking"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Shrinking</h3>
<p dir="auto">In <code>@range</code> and <code>@reverse_range</code> expressions, the operator <code>∓</code> (obtained by
typing <code>\mp</code> and pressing the <code>[tab]</code> key at the REPL) can be used to
<strong>shrink</strong> ranges.</p>
<p dir="auto">The expression <code>R ∓ I</code> yields the same result as <code>@range R ± (-I)</code>, that is the
index range <code>R</code> shrink by an amount specified by index <code>I</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@range R ∓ I -&gt; (first(R) + I):(last(R) - I)"><pre><span class="pl-c1">@range</span> R ∓ I <span class="pl-k">-&gt;</span> (<span class="pl-c1">first</span>(R) <span class="pl-k">+</span> I)<span class="pl-k">:</span>(<span class="pl-c1">last</span>(R) <span class="pl-k">-</span> I)</pre></div>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">The <code>EasyRanges</code> package is an official Julia package and can be installed as
follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
pkg&quot;add EasyRanges&quot;"><pre><span class="pl-k">using</span> Pkg
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">pkg</span>"</span>add EasyRanges<span class="pl-pds">"</span></span></pre></div>
<h2 dir="auto"><a id="user-content-a-working-example" class="anchor" aria-hidden="true" href="#a-working-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A working example</h2>
<p dir="auto"><code>EasyRanges</code> may be very useful to write readable expressions in ranges used by
<code>for</code> loops.  For instance, suppose that you want to compute a <strong>discrete
correlation</strong> of <code>A</code> by <code>B</code> as follows:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="ea0fec0a7821bd3c3b4d5c3cec0af896">$$
C[i] = \sum_{j} A[j] B[j-i]
$$</math-renderer></p>
<p dir="auto">and for all valid indices <code>i</code> and <code>j</code>.  Assuming <code>A</code>, <code>B</code> and <code>C</code> are abstract
vectors, the Julia equivalent code is:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for i ∈ eachindex(C)
    s = zero(T)
    j_first = max(firstindex(A), firstindex(B) + i)
    j_last = min(lastindex(A), lastindex(B) + i)
    for j ∈ j_first:j_last
        s += A[j]*B[j-i]
    end
    C[i] = s
end"><pre><span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">eachindex</span>(C)
    s <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    j_first <span class="pl-k">=</span> <span class="pl-c1">max</span>(<span class="pl-c1">firstindex</span>(A), <span class="pl-c1">firstindex</span>(B) <span class="pl-k">+</span> i)
    j_last <span class="pl-k">=</span> <span class="pl-c1">min</span>(<span class="pl-c1">lastindex</span>(A), <span class="pl-c1">lastindex</span>(B) <span class="pl-k">+</span> i)
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> j_first<span class="pl-k">:</span>j_last
        s <span class="pl-k">+=</span> A[j]<span class="pl-k">*</span>B[j<span class="pl-k">-</span>i]
    <span class="pl-k">end</span>
    C[i] <span class="pl-k">=</span> s
<span class="pl-k">end</span></pre></div>
<p dir="auto">where <code>T</code> is a suitable type, say <code>T = promote_type(eltype(A), eltype(B))</code>.
The above expressions of <code>j_first</code> and <code>j_last</code> are to ensure that <code>A[j]</code> and
<code>B[j-i]</code> are in bounds.  The same code for multidimensional arrays writes:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for i ∈ CartesianIndices(C)
    s = zero(T)
    j_first = max(first(CartesianIndices(A)),
                  first(CartesianIndices(B)) + i)
    j_last = min(last(CartesianIndices(A)),
                 last(CartesianIndices(B)) + i)
    for j ∈ j_first:j_last
        s += A[j]*B[j-i]
    end
    C[i] = s
end"><pre><span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(C)
    s <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    j_first <span class="pl-k">=</span> <span class="pl-c1">max</span>(<span class="pl-c1">first</span>(<span class="pl-c1">CartesianIndices</span>(A)),
                  <span class="pl-c1">first</span>(<span class="pl-c1">CartesianIndices</span>(B)) <span class="pl-k">+</span> i)
    j_last <span class="pl-k">=</span> <span class="pl-c1">min</span>(<span class="pl-c1">last</span>(<span class="pl-c1">CartesianIndices</span>(A)),
                 <span class="pl-c1">last</span>(<span class="pl-c1">CartesianIndices</span>(B)) <span class="pl-k">+</span> i)
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> j_first<span class="pl-k">:</span>j_last
        s <span class="pl-k">+=</span> A[j]<span class="pl-k">*</span>B[j<span class="pl-k">-</span>i]
    <span class="pl-k">end</span>
    C[i] <span class="pl-k">=</span> s
<span class="pl-k">end</span></pre></div>
<p dir="auto">now <code>i</code> and <code>j</code> are multidimensional Cartesian indices and Julia already helps
a lot by making such a code applicable whatever the number of dimensions.  Note
that the syntax <code>j_first:j_last</code> is supported for Cartesian indices since Julia
1.1.  There is more such syntactic sugar and using the broadcasting operator
<code>.+</code> and the operator <code>∩</code> (a shortcut for the function <code>intersect</code>), the code
can be rewritten as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for i ∈ CartesianIndices(C)
    s = zero(T)
    for j ∈ CartesianIndices(A) ∩ (CartesianIndices(B) .+ i)
        s += A[j]*B[j-i]
    end
    C[i] = s
end"><pre><span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(C)
    s <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(A) <span class="pl-k">∩</span> (<span class="pl-c1">CartesianIndices</span>(B) <span class="pl-k">.+</span> i)
        s <span class="pl-k">+=</span> A[j]<span class="pl-k">*</span>B[j<span class="pl-k">-</span>i]
    <span class="pl-k">end</span>
    C[i] <span class="pl-k">=</span> s
<span class="pl-k">end</span></pre></div>
<p dir="auto">which is not less efficient and yet much more readable.  Indeed, the statement</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for j ∈ CartesianIndices(A) ∩ (CartesianIndices(B) .+ i)"><pre><span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(A) <span class="pl-k">∩</span> (<span class="pl-c1">CartesianIndices</span>(B) <span class="pl-k">.+</span> i)</pre></div>
<p dir="auto">makes it clear that the loop is for all indices <code>j</code> such that <code>j ∈ CartesianIndices(A)</code> and <code>j - i ∈ CartesianIndices(B)</code> which is required to
have <code>A[j]</code> and <code>B[j-i]</code> in bounds.   The same principles can be applied to the
uni-dimensional code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for i ∈ eachindex(C)
    s = zero(T)
    for j ∈ eachindex(A) ∩ (eachindex(B) .+ i)
        s += A[j]*B[j-i]
    end
    C[i] = s
end"><pre><span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">eachindex</span>(C)
    s <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">eachindex</span>(A) <span class="pl-k">∩</span> (<span class="pl-c1">eachindex</span>(B) <span class="pl-k">.+</span> i)
        s <span class="pl-k">+=</span> A[j]<span class="pl-k">*</span>B[j<span class="pl-k">-</span>i]
    <span class="pl-k">end</span>
    C[i] <span class="pl-k">=</span> s
<span class="pl-k">end</span></pre></div>
<p dir="auto">Now suppose that you want to compute the <strong>discrete convolution</strong> instead:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="ea0fec0a7821bd3c3b4d5c3cec0af896">$$
C[i] = \sum_{j} A[j] B[i-j]
$$</math-renderer></p>
<p dir="auto">Then, the code for multi-dimensional arrays writes:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for i ∈ CartesianIndices(C)
    s = zero(T)
    for j ∈ CartesianIndices(A) ∩ (i .- CartesianIndices(B))
        s += A[j]*B[i-j]
    end
    C[i] = s
end"><pre><span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(C)
    s <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(A) <span class="pl-k">∩</span> (i <span class="pl-k">.-</span> <span class="pl-c1">CartesianIndices</span>(B))
        s <span class="pl-k">+=</span> A[j]<span class="pl-k">*</span>B[i<span class="pl-k">-</span>j]
    <span class="pl-k">end</span>
    C[i] <span class="pl-k">=</span> s
<span class="pl-k">end</span></pre></div>
<p dir="auto">because you want to have <code>j ∈ CartesianIndices(A)</code> and <code>i - j ∈ CartesianIndices(B)</code>, the latter being equivalent to <code>j ∈ i - CartesianIndices(B)</code>.</p>
<p dir="auto">This simple change however results in <strong>a dramatic slowdown</strong> because the
expression <code>i .- CartesianIndices(B)</code> yields an array of Cartesian indices
while the expression <code>CartesianIndices(B) .- i</code> yields an instance of
<code>CartesianIndices</code>.</p>
<p dir="auto">Using the <code>@range</code> macro of <code>EasyRanges</code>, the discrete correlation and discrete
convolution write:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Discrete correlation.
for i ∈ CartesianIndices(C)
    s = zero(T)
    for j ∈ @range CartesianIndices(A) ∩ (CartesianIndices(B) + i)
        s += A[j]*B[j-i]
    end
    C[i] = s
end

# Discrete convolution.
for i ∈ CartesianIndices(C)
    s = zero(T)
    for j ∈ @range CartesianIndices(A) ∩ (i - CartesianIndices(B))
        s += A[j]*B[i-j]
    end
    C[i] = s
end"><pre><span class="pl-c"><span class="pl-c">#</span> Discrete correlation.</span>
<span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(C)
    s <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndices</span>(A) <span class="pl-k">∩</span> (<span class="pl-c1">CartesianIndices</span>(B) <span class="pl-k">+</span> i)
        s <span class="pl-k">+=</span> A[j]<span class="pl-k">*</span>B[j<span class="pl-k">-</span>i]
    <span class="pl-k">end</span>
    C[i] <span class="pl-k">=</span> s
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Discrete convolution.</span>
<span class="pl-k">for</span> i <span class="pl-k">∈</span> <span class="pl-c1">CartesianIndices</span>(C)
    s <span class="pl-k">=</span> <span class="pl-c1">zero</span>(T)
    <span class="pl-k">for</span> j <span class="pl-k">∈</span> <span class="pl-c1">@range</span> <span class="pl-c1">CartesianIndices</span>(A) <span class="pl-k">∩</span> (i <span class="pl-k">-</span> <span class="pl-c1">CartesianIndices</span>(B))
        s <span class="pl-k">+=</span> A[j]<span class="pl-k">*</span>B[i<span class="pl-k">-</span>j]
    <span class="pl-k">end</span>
    C[i] <span class="pl-k">=</span> s
<span class="pl-k">end</span></pre></div>
<p dir="auto">which do not require the broadcasting operators <code>.+</code> and <code>.-</code> and which do not
have the aforementioned issue.  Using the macros <code>@range</code> and <code>@reverse_range</code>
have other advantages:</p>
<ul dir="auto">
<li>
<p dir="auto">The result is guaranteed to be <code>Int</code>-valued (needed for efficient indexing).</p>
</li>
<li>
<p dir="auto">The <em>step</em>, that is the increment between consecutive indices, in the result
has a given direction: <code>@range</code> yields a positive step while <code>@reverse_range</code>
yields a negative step.</p>
</li>
<li>
<p dir="auto">The syntax of range expressions is simplified and extended for other
operators (like <code>±</code> for stretching or <code>∓</code> for shrinking) that are not
available in the base Julia.  This syntax can be extended as the package is
developed without disturbing other packages (i.e., no type-piracy).</p>
</li>
</ul>
</article></div>