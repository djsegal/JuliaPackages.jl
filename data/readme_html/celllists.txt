<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-celllistsjl" class="anchor" aria-hidden="true" href="#celllistsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>CellLists.jl</h1>
<p dir="auto"><a href="https://zenodo.org/badge/latestdoi/298188925" rel="nofollow"><img src="https://camo.githubusercontent.com/8cd4a2f988beb21b6adb820502fc548d9c48567205630cf370ef49eb72c515c8/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3239383138383932352e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/298188925.svg" style="max-width: 100%;"></a>
<a href="https://jaantollander.github.io/CellLists.jl/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Docs Image" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/jaantollander/CellLists.jl/actions/workflows/Runtests.yml"><img src="https://github.com/jaantollander/CellLists.jl/workflows/Runtests/badge.svg" alt="Runtests" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-description" class="anchor" aria-hidden="true" href="#description"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Description</h2>
<p dir="auto"><strong>Cell Lists</strong> is an algorithm that solves the fixed-radius near neighbors problem. That is, it finds all pairs of points that are within a fixed distance apart from each other. We can use the Cell Lists algorithm as a part of molecular dynamics or agent-based simulations where the interaction potential has a finite range.</p>
<p dir="auto">You can read more about it in the article <a href="https://jaantollander.com/post/searching-for-fixed-radius-near-neighbors-with-cell-lists-algorithm-in-julia-language/" rel="nofollow"><strong>Searching for Fixed-Radius Near Neighbors with Cell Lists Algorithm in Julia Language</strong></a>, which explores the Cell Lists algorithm and theory behind it more deeply. We also extended the algorithm to a multithreaded version, which we explain in the article <a href="https://jaantollander.com/post/multithreading-in-julia-language-applied-to-cell-lists-algorithm/" rel="nofollow"><strong>Multithreading in Julia Language in Julia Language Applied to Cell Lists Algorithm</strong></a>.</p>
<h2 dir="auto"><a id="user-content-citation" class="anchor" aria-hidden="true" href="#citation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citation</h2>
<p dir="auto">You can cite the <code>CellLists.jl</code> repository and code by navigating to the <a href="https://zenodo.org/badge/latestdoi/298188925" rel="nofollow"><strong>DOI</strong></a> provided by Zenodo and then choosing your preferred citation format from the <em>Export</em> section. For example, we can export <a href="https://zenodo.org/record/5075063/export/hx" rel="nofollow">BibTex</a> format. Alternatively, you can use the <em>Cite This Repository</em> button below the <em>About</em> section in the right sidebar.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">You can install <code>CellLists.jl</code> with the Julia package manager.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="pkg&gt; add CellLists"><pre class="notranslate"><code>pkg&gt; add CellLists
</code></pre></div>
<p dir="auto">Alternatively, you can install <code>CellLists.jl</code> directly from the GitHub repository.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="pkg&gt; add https://github.com/jaantollander/CellLists.jl"><pre class="notranslate"><code>pkg&gt; add https://github.com/jaantollander/CellLists.jl
</code></pre></div>
<h2 dir="auto"><a id="user-content-serial-algorithm" class="anchor" aria-hidden="true" href="#serial-algorithm"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Serial Algorithm</h2>
<p dir="auto">We can use <code>CellLists.jl</code> by supplying <code>n</code>, <code>d</code>-dimensional points, and fixed radius <code>r</code> to the <code>CellList</code> constructor.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CellLists: CellList, near_neighbors, distance_condition
n, d, r = 10, 2, 0.1
p = rand(n, d)
c = CellList(p, r)"><pre><span class="pl-k">using</span> CellLists<span class="pl-k">:</span> CellList, near_neighbors, distance_condition
n, d, r <span class="pl-k">=</span> <span class="pl-c1">10</span>, <span class="pl-c1">2</span>, <span class="pl-c1">0.1</span>
p <span class="pl-k">=</span> <span class="pl-c1">rand</span>(n, d)
c <span class="pl-k">=</span> <span class="pl-c1">CellList</span>(p, r)</pre></div>
<p dir="auto">By calling the <code>near_neighbors</code> function, we obtain a list of index pairs of points that are within <code>r</code> distance.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="indices = near_neighbors(c, p, r)"><pre>indices <span class="pl-k">=</span> <span class="pl-c1">near_neighbors</span>(c, p, r)</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="[(3, 6), (4, 5), ...]  # indices"><pre>[(<span class="pl-c1">3</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">5</span>), <span class="pl-k">...</span>]  <span class="pl-c"><span class="pl-c">#</span> indices</span></pre></div>
<p dir="auto">We can compare Cell Lists to the brute force method.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="indices2 = Vector{Tuple{Int, Int}}()
for i in 1:(n-1)
    for j in (i+1):n
        if distance_condition(p[i, :], p[j, :], r)
            push!(indices2, (i, j))
        end
    end
end"><pre>indices2 <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Tuple{Int, Int}}</span>()
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(n<span class="pl-k">-</span><span class="pl-c1">1</span>)
    <span class="pl-k">for</span> j <span class="pl-k">in</span> (i<span class="pl-k">+</span><span class="pl-c1">1</span>)<span class="pl-k">:</span>n
        <span class="pl-k">if</span> <span class="pl-c1">distance_condition</span>(p[i, :], p[j, :], r)
            <span class="pl-c1">push!</span>(indices2, (i, j))
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">The outputs should be equal as follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@assert Set(Set.(indices)) == Set(Set.(indices2))"><pre><span class="pl-c1">@assert</span> <span class="pl-c1">Set</span>(<span class="pl-c1">Set</span>.(indices)) <span class="pl-k">==</span> <span class="pl-c1">Set</span>(<span class="pl-c1">Set</span>.(indices2))</pre></div>
<p dir="auto">On average, the Cell List algorithm is more efficient than brute force when dimensions <code>d</code> is small, the number of points <code>n</code> is sufficiently large, and radius <code>r</code> is small compared to the bounding box of the points.</p>
<h2 dir="auto"><a id="user-content-multithreaded-algorithm" class="anchor" aria-hidden="true" href="#multithreaded-algorithm"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multithreaded Algorithm</h2>
<p dir="auto">We can use the multithreaded version of Cell Lists by dispatching with the <code>Val(:threads)</code> value type.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="c = CellLists(p, r, Val(:threads))"><pre>c <span class="pl-k">=</span> <span class="pl-c1">CellLists</span>(p, r, <span class="pl-c1">Val</span>(<span class="pl-c1">:threads</span>))</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="near_neighbors(c, p, r, Val(:threads))"><pre><span class="pl-c1">near_neighbors</span>(c, p, r, <span class="pl-c1">Val</span>(<span class="pl-c1">:threads</span>))</pre></div>
<h2 dir="auto"><a id="user-content-benchmarks" class="anchor" aria-hidden="true" href="#benchmarks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Benchmarks</h2>
<p dir="auto">You can find the benchmarking code from the <a href="https://github.com/jaantollander/CellListsBenchmarks.jl"><strong>CellListsBenchmarks.jl</strong></a> repository and scripts for running the benchmarks and plotting in the <a href="https://github.com/jaantollander/cell-lists-benchmarks"><strong>cell-lists-benchmarks</strong></a> repository.</p>
</article></div>