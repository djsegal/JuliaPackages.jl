<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a id="user-content-puiseux-polynomials"></a></p>
<p dir="auto"><a id="user-content-puiseux-polynomials-1"></a></p>
<h1 dir="auto"><a id="user-content-puiseux-polynomials" class="anchor" aria-hidden="true" href="#puiseux-polynomials"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Puiseux polynomials</h1>
<ul dir="auto">
<li><a href="index.md#Puiseux-polynomials">Puiseux polynomials</a></li>
</ul>
<p dir="auto"><a id="user-content-puiseuxpolynomials" href="#PuiseuxPolynomials">#</a>
<strong><code>PuiseuxPolynomials</code></strong> — <em>Module</em>.</p>
<p dir="auto">This package implements Puiseux polynomials, that is linear combinations of monomials  of the type <code>x₁^{a₁}… xₙ^{aₙ}</code> where <code>xᵢ</code> are variables and <code>aᵢ</code> are  exponents which can  be arbitrary rational  numbers. When the <code>aᵢ</code> are integers  we refer to "multivariate Laurent polynomials", and when tha <code>aᵢ</code> are  positive integers we refer then to "multivariate polynomials" (or true polynomials).</p>
<p dir="auto">This  package also implements  multivariate rational fractions, constructed as  the quotient of two Laurent  polynomials (which is normalized to become the  quotient of  two true  polynomials). This  package is  in particular a perfectly  usable (and  quite good  I hope)  implementation of multivariate polynomials  and multivariate rational fractions if you are only interested in that.</p>
<p dir="auto">The main use of Puiseux polynomials is they are the ring of integers of the algebraic closure of the the multivariate rational fractions. In particular cyclotomic  Hecke algebras take their  character values and representations in them.</p>
<p dir="auto">This  package depends only on the packages <code>Reexport</code>, <code>LaurentPolynomials</code> and <code>ModuleElts</code>s; the names defined by <code>LaurentPolynomials</code> are reexported by this package.</p>
<p dir="auto">Our  Puiseux polynomials have  the parametric type  <code>Mvp{C,E}</code> where <code>C</code> is the  type of the coefficients and <code>E</code> is the type of the exponents: <code>E=Int</code> for   Laurent  polynomials;  <code>E=Rational{Int}</code>  for  more  general  Puiseux polynomials.  When printing the  type of an  <code>Mvp</code>, only <code>C</code>  is printed if <code>E==Int</code>. Rational fractions are only defined for numerator and denominator true  polynomials and have type <code>Frac{Mvp{C,Int}}</code>  –- the quotient of two Laurent polynomials is normalized to a quotient of two true polynomials.</p>
<p dir="auto">We first look at how to make Puiseux polynomials.</p>
<p dir="auto"><code>@Mvp x₁,…,xₙ</code></p>
<p dir="auto">assigns  to each  Julia name  <code>xᵢ</code> an  <code>Mvp</code> representing  an indeterminate suitable   to  build   multivariate  polynomials   or  rational  fractions. <code>Mvp(:x₁)</code> creates the same <code>Mvp</code> without assigning it to variable <code>x₁</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y # creates the variables x,y

julia&gt; (x+y^-1)^3
Mvp{Int64}: x³+3x²y⁻¹+3xy⁻²+y⁻³

julia&gt; x+Mvp(:z)
Mvp{Int64}: x+z

julia&gt; x^(1//2)  # a Puiseux monomial
Mvp{Int64,Rational{Int64}}: x½

julia&gt; Mvp(3)  # convert a number to an Mvp with only a constant term
Mvp{Int64}: 3"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y # creates the variables x,y

julia&gt; (x+y^-1)^3
Mvp{Int64}: x³+3x²y⁻¹+3xy⁻²+y⁻³

julia&gt; x+Mvp(:z)
Mvp{Int64}: x+z

julia&gt; x^(1//2)  # a Puiseux monomial
Mvp{Int64,Rational{Int64}}: x½

julia&gt; Mvp(3)  # convert a number to an Mvp with only a constant term
Mvp{Int64}: 3
</code></pre></div>
<p dir="auto">It  is convenient to create <code>Mvp</code>s using variables such as <code>x,y</code> above. The functions  <code>repr</code> or <code>print</code> show an <code>Mvp</code> in a form which can be read back in  Julia – this  is also the  way an <code>Mvp</code>  is printed in another context than the repl, IJulia or pluto:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; repr(3x*y^-2+4)
&quot;Mvp{Int64, Int64}([:x=&gt;1,:y=&gt;-2]=&gt;3,[]=&gt;4)&quot;"><pre lang="julia-repl" class="notranslate"><code>julia&gt; repr(3x*y^-2+4)
"Mvp{Int64, Int64}([:x=&gt;1,:y=&gt;-2]=&gt;3,[]=&gt;4)"
</code></pre></div>
<p dir="auto">It  is better not to use this  form casually, since the arguments <em>must</em> be normalized (sorted by key, and no duplicate key).</p>
<p dir="auto">Only  monomials and one-term <code>Mvp</code>s can  be raised to a non-integral power; the  <code>Mvp</code> with one term constant <code>c</code>  times the monomial <code>m</code> can be raised to  a fractional  power of  denominator <code>d</code>  if and  only if <code>root(c,d)</code> is defined (this is equivalent to <code>c^{1//d}</code> for floats);</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; (4x)^(1//2)
Mvp{Int64,Rational{Int64}}: 2x½

julia&gt; (2.0x)^(1//2)
Mvp{Float64,Rational{Int64}}: 1.4142135623730951x½

julia&gt; root(2.0x)
Mvp{Float64,Rational{Int64}}: 1.4142135623730951x½"><pre lang="julia-repl" class="notranslate"><code>julia&gt; (4x)^(1//2)
Mvp{Int64,Rational{Int64}}: 2x½

julia&gt; (2.0x)^(1//2)
Mvp{Float64,Rational{Int64}}: 1.4142135623730951x½

julia&gt; root(2.0x)
Mvp{Float64,Rational{Int64}}: 1.4142135623730951x½
</code></pre></div>
<p dir="auto">One  may  want  to  define  <code>root</code>  differently;  for instance, in my other package   <code>CylotomicNumbers</code>  I   define  square   roots  of  rationals  as cyclotomics, and I also have implemented arbitrary roots of roots of unity.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; using CyclotomicNumbers

julia&gt; (2x)^(1//2)
Mvp{Cyc{Int64},Rational{Int64}}: √2x½

julia&gt; (E(3)*x)^(2//3)
Mvp{Cyc{Int64},Rational{Int64}}: ζ₉²x⅔"><pre lang="julia-rep1" class="notranslate"><code>julia&gt; using CyclotomicNumbers

julia&gt; (2x)^(1//2)
Mvp{Cyc{Int64},Rational{Int64}}: √2x½

julia&gt; (E(3)*x)^(2//3)
Mvp{Cyc{Int64},Rational{Int64}}: ζ₉²x⅔
</code></pre></div>
<p dir="auto">There  are various ways to take an  <code>Mvp</code> apart. Below are the most direct; look   also  at  the   functions  <code>coefficient</code>,  <code>coefficients</code>,  <code>pairs</code>, <code>monomials</code>, <code>variables</code> and <code>powers</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p=3x*y^-2+4
Mvp{Int64}: 3xy⁻²+4

julia&gt; term(p,1) # a term is a Pair monomial=&gt;coefficient
xy⁻² =&gt; 3

julia&gt; term(p,2) # the trivial monomial Monomial() prints as an empty string
 =&gt; 4

julia&gt; length(p) # the number of terms
2

julia&gt; term.(p,1:length(p)) # same as pairs(p)
2-element Vector{Pair{Monomial{Int64}, Int64}}:
 xy⁻² =&gt; 3
      =&gt; 4

julia&gt; last(term(p,1)) # same as first(coefficients(p))
3

julia&gt; m=first(term(p,1)) # same as first(monomials(p))
Monomial{Int64}:xy⁻²

julia&gt; length(m) # how many variables in m
2

julia&gt; map((x,y)-&gt;x=&gt;y,variables(m),powers(m)) # same as pairs(m)
2-element Vector{Pair{Symbol, Int64}}:
 :x =&gt; 1
 :y =&gt; -2

julia&gt; degree(m,:x) # power of x in m
1

julia&gt; degree(m,:y) # power of y in m
-2"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p=3x*y^-2+4
Mvp{Int64}: 3xy⁻²+4

julia&gt; term(p,1) # a term is a Pair monomial=&gt;coefficient
xy⁻² =&gt; 3

julia&gt; term(p,2) # the trivial monomial Monomial() prints as an empty string
 =&gt; 4

julia&gt; length(p) # the number of terms
2

julia&gt; term.(p,1:length(p)) # same as pairs(p)
2-element Vector{Pair{Monomial{Int64}, Int64}}:
 xy⁻² =&gt; 3
      =&gt; 4

julia&gt; last(term(p,1)) # same as first(coefficients(p))
3

julia&gt; m=first(term(p,1)) # same as first(monomials(p))
Monomial{Int64}:xy⁻²

julia&gt; length(m) # how many variables in m
2

julia&gt; map((x,y)-&gt;x=&gt;y,variables(m),powers(m)) # same as pairs(m)
2-element Vector{Pair{Symbol, Int64}}:
 :x =&gt; 1
 :y =&gt; -2

julia&gt; degree(m,:x) # power of x in m
1

julia&gt; degree(m,:y) # power of y in m
-2
</code></pre></div>
<p dir="auto">The valuation and degree of an Mvp can be inspected globally or variable by variable.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p
Mvp{Int64}: 3xy⁻²+4

julia&gt; variables(p)
2-element Vector{Symbol}:
 :x
 :y

julia&gt; degree(p),degree(p,:x),degree(p,:y)
(0, 1, 0)

julia&gt; valuation(p),valuation(p,:x),valuation(p,:y)
(-1, 0, -2)"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p
Mvp{Int64}: 3xy⁻²+4

julia&gt; variables(p)
2-element Vector{Symbol}:
 :x
 :y

julia&gt; degree(p),degree(p,:x),degree(p,:y)
(0, 1, 0)

julia&gt; valuation(p),valuation(p,:x),valuation(p,:y)
(-1, 0, -2)
</code></pre></div>
<p dir="auto">Terms  are totally ordered in an <code>Mvp</code>  by a monomial ordering (that is, an ordering  on  monomials  so  that  <code>x&lt;y</code>  implies <code>xz&lt;yz</code> for any monomials <code>x,y,z</code>).  The terms are in decreasing order, so that the first term is the highest.  By  default,  the  ordering  is  <code>lex</code>. The orderings <code>grlex</code> and <code>grevlex</code> are also implemented (see their docstring and <code>grobner_basis</code> for how to use them).</p>
<p dir="auto">An  <code>Mvp</code> is a <em>scalar</em>  if the valuation and  degree are <code>0</code>. The function <code>scalar</code>  returns the  constant coefficient  if the  <code>Mvp</code> is a scalar, and <code>nothing</code> otherwise.</p>
<p dir="auto">Usual  arithmetic (<code>+</code>, <code>-</code>,  <code>*</code>, <code>^</code>, <code>/</code>,  <code>//</code>, <code>one</code>, <code>isone</code>, <code>zero</code>, <code>iszero</code>,  <code>==</code>)  works.  Elements  of  type  <code>&lt;:Number</code>  are considered as scalars for scalar operations on the coefficients.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p
Mvp{Int64}: 3xy⁻²+4

julia&gt; p^2
Mvp{Int64}: 9x²y⁻⁴+24xy⁻²+16

julia&gt; p/2
Mvp{Float64}: 1.5xy⁻²+2.0

julia&gt; p//2
Mvp{Rational{Int64}}: (3//2)xy⁻²+2//1"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p
Mvp{Int64}: 3xy⁻²+4

julia&gt; p^2
Mvp{Int64}: 9x²y⁻⁴+24xy⁻²+16

julia&gt; p/2
Mvp{Float64}: 1.5xy⁻²+2.0

julia&gt; p//2
Mvp{Rational{Int64}}: (3//2)xy⁻²+2//1
</code></pre></div>
<p dir="auto">When  converting an <code>Mvp</code> to another type of <code>Mvp</code> one needs to specify the two  type parameters  (the type  of the  coefficients and  the type  of the exponents).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; Mvp{Float64,Rational{Int}}(p)
Mvp{Float64,Rational{Int64}}: 3.0xy⁻²+4.0"><pre lang="julia-repl" class="notranslate"><code>julia&gt; Mvp{Float64,Rational{Int}}(p)
Mvp{Float64,Rational{Int64}}: 3.0xy⁻²+4.0
</code></pre></div>
<p dir="auto">One  can evaluate an <code>Mvp</code>,  setting the value of  some variables, by using the  function call syntax.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p=x+y
Mvp{Int64}: x+y

julia&gt; p(x=2)    # evaluate p at x=2
Mvp{Int64}: y+2

julia&gt; value(p,:x=&gt;2) # there is also a more explicit `value` function.
Mvp{Int64}: y+2

julia&gt; p(x=2,y=x) # simultaneous evaluation
Mvp{Int64}: x+2

julia&gt; value(p,:x=&gt;2,:y=&gt;x)
Mvp{Int64}: x+2"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p=x+y
Mvp{Int64}: x+y

julia&gt; p(x=2)    # evaluate p at x=2
Mvp{Int64}: y+2

julia&gt; value(p,:x=&gt;2) # there is also a more explicit `value` function.
Mvp{Int64}: y+2

julia&gt; p(x=2,y=x) # simultaneous evaluation
Mvp{Int64}: x+2

julia&gt; value(p,:x=&gt;2,:y=&gt;x)
Mvp{Int64}: x+2
</code></pre></div>
<p dir="auto">Note  that  an  <code>Mvp</code>  always  evaluates  to an <code>Mvp</code>, for consistency. You should  use <code>scalar</code> on the  result of giving values  to all variables in a <code>Mvp</code> to get a number.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p(x=1,y=2)
Mvp{Int64}: 3

julia&gt; scalar(p(x=1,y=2))
3

julia&gt; v=(x^(1//2))(x=2.0)
Mvp{Float64,Rational{Int64}}: 1.4142135623730951

julia&gt; scalar(v)
1.4142135623730951"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p(x=1,y=2)
Mvp{Int64}: 3

julia&gt; scalar(p(x=1,y=2))
3

julia&gt; v=(x^(1//2))(x=2.0)
Mvp{Float64,Rational{Int64}}: 1.4142135623730951

julia&gt; scalar(v)
1.4142135623730951
</code></pre></div>
<p dir="auto">One  can divide an <code>Mvp</code> by another when the division is exact, compute the <code>gcd</code> and <code>lcm</code> of two <code>Mvp</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; LinearAlgebra.exactdiv(x^2-y^2,x-y) # errors if the division is not exact
Mvp{Int64}: x+y

julia&gt; (x+y)/(2x^2)   # divide by a monomial
Mvp{Float64}: 0.5x⁻¹+0.5x⁻²y

julia&gt; (x+y)//(2x^2)
Mvp{Rational{Int64}}: (1//2)x⁻¹+(1//2)x⁻²y

julia&gt; (x+y)/(x-y)   # if the division is not exact one gets a rational fraction
Frac{Mvp{Int64, Int64}}: (x+y)/(x-y)"><pre lang="julia-repl" class="notranslate"><code>julia&gt; LinearAlgebra.exactdiv(x^2-y^2,x-y) # errors if the division is not exact
Mvp{Int64}: x+y

julia&gt; (x+y)/(2x^2)   # divide by a monomial
Mvp{Float64}: 0.5x⁻¹+0.5x⁻²y

julia&gt; (x+y)//(2x^2)
Mvp{Rational{Int64}}: (1//2)x⁻¹+(1//2)x⁻²y

julia&gt; (x+y)/(x-y)   # if the division is not exact one gets a rational fraction
Frac{Mvp{Int64, Int64}}: (x+y)/(x-y)
</code></pre></div>
<p dir="auto">Raising  a non-monomial  Laurent polynomial  to a  negative power returns a rational   fraction.  Rational  fractions  are  normalized  such  that  the numerator  and denominators are true polynomials  prime to each other. They have  the  arithmetic  operations  <code>+</code>,  <code>-</code>  , <code>*</code>, <code>/</code>, <code>//</code>, <code>^</code>, <code>inv</code>, <code>one</code>,  <code>isone</code>, <code>zero</code>, <code>iszero</code> (these  operations can operate between an <code>Mvp</code> or a <code>Number</code> and a <code>Frac{&lt;:Mvp}</code>).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; (x+1)^-2
Frac{Mvp{Int64, Int64}}: 1/(x²+2x+1)

julia&gt; x+1/(y+1)
Frac{Mvp{Int64, Int64}}: (xy+x+1)/(y+1)

julia&gt; 1/(y-1)-1/(y+1)
Frac{Mvp{Int64, Int64}}: 2/(y²-1)"><pre lang="julia-repl" class="notranslate"><code>julia&gt; (x+1)^-2
Frac{Mvp{Int64, Int64}}: 1/(x²+2x+1)

julia&gt; x+1/(y+1)
Frac{Mvp{Int64, Int64}}: (xy+x+1)/(y+1)

julia&gt; 1/(y-1)-1/(y+1)
Frac{Mvp{Int64, Int64}}: 2/(y²-1)
</code></pre></div>
<p dir="auto">One  can evaluate a <code>Frac</code>,  setting the value of  some variables, by using the function call syntax or the <code>value</code> function:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; ((x+y)/(x-y))(x=y+1)
Mvp{Float64}: 2.0y+1.0

julia&gt; value((x+y)/(x-y),:x=&gt;y+1;Rational=true) # Rational=true says use //
Mvp{Int64}: 2y+1"><pre lang="julia-repl" class="notranslate"><code>julia&gt; ((x+y)/(x-y))(x=y+1)
Mvp{Float64}: 2.0y+1.0

julia&gt; value((x+y)/(x-y),:x=&gt;y+1;Rational=true) # Rational=true says use //
Mvp{Int64}: 2y+1
</code></pre></div>
<p dir="auto">A  <code>Frac</code> can be dissected using <code>numerator</code> and <code>denominator</code>. <code>Frac</code>s and <code>Mvp</code>s  are  scalars  for  broadcasting  and  can be sorted (have <code>cmp</code> and <code>isless</code> methods).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[x+y x-y;x+1 y+1]
2×2 Matrix{Mvp{Int64, Int64}}:
 x+y  x-y
 x+1  y+1

julia&gt; n=inv(Frac.(m))
2×2 Matrix{Frac{Mvp{Int64, Int64}}}:
 (-y-1)/(x²-2xy-y²-2y)  (x-y)/(x²-2xy-y²-2y)
 (x+1)/(x²-2xy-y²-2y)   (-x-y)/(x²-2xy-y²-2y)

julia&gt; lcm(denominator.(n))
Mvp{Int64}: x²-2xy-y²-2y"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[x+y x-y;x+1 y+1]
2×2 Matrix{Mvp{Int64, Int64}}:
 x+y  x-y
 x+1  y+1

julia&gt; n=inv(Frac.(m))
2×2 Matrix{Frac{Mvp{Int64, Int64}}}:
 (-y-1)/(x²-2xy-y²-2y)  (x-y)/(x²-2xy-y²-2y)
 (x+1)/(x²-2xy-y²-2y)   (-x-y)/(x²-2xy-y²-2y)

julia&gt; lcm(denominator.(n))
Mvp{Int64}: x²-2xy-y²-2y
</code></pre></div>
<p dir="auto">Finally,   <code>Mvp</code>s  have   methods  <code>conj</code>,   <code>adjoint</code>  which   operate  on coefficients,   a   <code>derivative</code>   method,   and  methods  <code>positive_part</code>, <code>negative_part</code> and <code>bar</code> (useful for Kazhdan-Lusztig theory).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp z
Mvp{Int64}: z

julia&gt; hessian(p,vars)=[derivative(derivative(p,x),y) for x in vars, y in vars]
hessian (generic function with 1 method)

julia&gt; hessian(x^2*y^2*z^2,[:x,:y,:z])
3×3 Matrix{Mvp{Int64, Int64}}:
 2y²z²  4xyz²  4xy²z
 4xyz²  2x²z²  4x²yz
 4xy²z  4x²yz  2x²y²

julia&gt; jacobian(pols,vars)=[derivative(p,v) for p in pols, v in vars]
jacobian (generic function with 1 method)

julia&gt; jacobian([x,y,z],[:x,:y,:z])
3×3 Matrix{Mvp{Int64, Int64}}:
 1  0  0
 0  1  0
 0  0  1

julia&gt; p=(x+y^-1)^4
Mvp{Int64}: x⁴+4x³y⁻¹+6x²y⁻²+4xy⁻³+y⁻⁴

julia&gt; positive_part(p)
Mvp{Int64}: x⁴

julia&gt; negative_part(p)
Mvp{Int64}: y⁻⁴

julia&gt; bar(p)
Mvp{Int64}: y⁴+4x⁻¹y³+6x⁻²y²+4x⁻³y+x⁻⁴"><pre lang="julia_repl" class="notranslate"><code>julia&gt; @Mvp z
Mvp{Int64}: z

julia&gt; hessian(p,vars)=[derivative(derivative(p,x),y) for x in vars, y in vars]
hessian (generic function with 1 method)

julia&gt; hessian(x^2*y^2*z^2,[:x,:y,:z])
3×3 Matrix{Mvp{Int64, Int64}}:
 2y²z²  4xyz²  4xy²z
 4xyz²  2x²z²  4x²yz
 4xy²z  4x²yz  2x²y²

julia&gt; jacobian(pols,vars)=[derivative(p,v) for p in pols, v in vars]
jacobian (generic function with 1 method)

julia&gt; jacobian([x,y,z],[:x,:y,:z])
3×3 Matrix{Mvp{Int64, Int64}}:
 1  0  0
 0  1  0
 0  0  1

julia&gt; p=(x+y^-1)^4
Mvp{Int64}: x⁴+4x³y⁻¹+6x²y⁻²+4xy⁻³+y⁻⁴

julia&gt; positive_part(p)
Mvp{Int64}: x⁴

julia&gt; negative_part(p)
Mvp{Int64}: y⁻⁴

julia&gt; bar(p)
Mvp{Int64}: y⁴+4x⁻¹y³+6x⁻²y²+4x⁻³y+x⁻⁴
</code></pre></div>
<p dir="auto">Despite  the degree of generality of our  polynomials, the speed is not too shabby.  For the Fateman test f(f+1)  where f=(1+x+y+z+t)^15, we take 3sec. According to the Nemo paper, Sagemath takes 10sec and Nemo takes 1.6sec.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1-L333">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.mvp" href="#PuiseuxPolynomials.Mvp">#</a>
<strong><code>PuiseuxPolynomials.Mvp</code></strong> — <em>Type</em>.</p>
<p dir="auto"><code>Mvp</code>s are implemented as a list of pairs <code>monomial=&gt;coefficient</code> sorted by the monomial order <code>lex</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L522-L525">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.@mvp-tuple{any}" href="#PuiseuxPolynomials.@Mvp-Tuple{Any}">#</a>
<strong><code>PuiseuxPolynomials.@Mvp</code></strong> — <em>Macro</em>.</p>
<p dir="auto"><code>@Mvp x,y</code></p>
<p dir="auto">is  equivalent to <code>x=Mvp(:x);y=Mvp(:y)</code>  excepted it creates  <code>x,y</code> in the  global scope of the current module, since it uses <code>eval</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L545-L550">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.mvp-tuple{symbol}" href="#PuiseuxPolynomials.Mvp-Tuple{Symbol}">#</a>
<strong><code>PuiseuxPolynomials.Mvp</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>Mvp(x::Symbol)</code> creates the <code>Mvp</code> with one term of degree one and coefficient 1 with variable <code>x</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L536-L539">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.valuation" href="#LaurentPolynomials.valuation">#</a>
<strong><code>LaurentPolynomials.valuation</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>valuation(m::Mvp[,v::Symbol])</code></p>
<p dir="auto">The <code>valuation</code> of an <code>Mvp</code> is the minimal degree of a monomial.</p>
<p dir="auto">With  second argument a variable name, <code>valuation</code> returns the valuation of the polynomial in that variable.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y; a=x^2+x*y
Mvp{Int64}: x²+xy

julia&gt; valuation(a), valuation(a,:y), valuation(a,:x)
(2, 0, 1)"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y; a=x^2+x*y
Mvp{Int64}: x²+xy

julia&gt; valuation(a), valuation(a,:y), valuation(a,:x)
(2, 0, 1)
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L730-L746">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.degree" href="#LaurentPolynomials.degree">#</a>
<strong><code>LaurentPolynomials.degree</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>degree(m::Mvp[,v::Symbol])</code></p>
<p dir="auto">The <code>degree</code> of a monomial is the sum of  the exponents of the variables. The <code>degree</code> of an <code>Mvp</code> is the largest degree of a monomial.</p>
<p dir="auto">With  second argument a  variable name, <code>degree</code>  returns the degree of the polynomial in that variable.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; a=x^2+x*y
Mvp{Int64}: x²+xy

julia&gt; degree(a), degree(a,:y), degree(a,:x)
(2, 1, 2)"><pre lang="julia-repl" class="notranslate"><code>julia&gt; a=x^2+x*y
Mvp{Int64}: x²+xy

julia&gt; degree(a), degree(a,:y), degree(a,:x)
(2, 1, 2)
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L710-L726">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.variables" href="#PuiseuxPolynomials.variables">#</a>
<strong><code>PuiseuxPolynomials.variables</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>variables(a::Monomial)</code> iterator on the variables of <code>a</code> (a sorted list of <code>Symbol</code>s)</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L381">source</a><br></p>
<p dir="auto"><code>variables(p::Mvp)</code></p>
<p dir="auto"><code>variables(v::AbstractArray)</code></p>
<p dir="auto">returns  the list of variables of <code>p</code> (resp. of all <code>p</code> in <code>v</code>) as a sorted list of <code>Symbol</code>s.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y,z

julia&gt; variables([z,[y+z],x])
3-element Vector{Symbol}:
 :x
 :y
 :z"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y,z

julia&gt; variables([z,[y+z],x])
3-element Vector{Symbol}:
 :x
 :y
 :z
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L954-L971">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.coefficients-union{tuple{n}, tuple{t}, tuple{mvp{t, n}, symbol}} where {t, n}" href="#LaurentPolynomials.coefficients-Union{Tuple{N}, Tuple{T}, Tuple{Mvp{T, N}, Symbol}} where {T, N}">#</a>
<strong><code>LaurentPolynomials.coefficients</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>coefficients(p::Mvp, var::Symbol)</code></p>
<p dir="auto">returns  a Dict with keys the degree  in <code>var</code> and values the corresponding coefficient of <code>p</code> with respect to <code>var</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p=(x+y+inv(y))^4
Mvp{Int64}: x⁴+4x³y+4x³y⁻¹+6x²y²+12x²+6x²y⁻²+4xy³+12xy+12xy⁻¹+4xy⁻³+y⁴+4y²+6+4y⁻²+y⁻⁴

julia&gt; coefficients(p,:x)
Dict{Int64, Mvp{Int64, Int64}} with 5 entries:
  0 =&gt; y⁴+4y²+6+4y⁻²+y⁻⁴
  4 =&gt; 1
  2 =&gt; 6y²+12+6y⁻²
  3 =&gt; 4y+4y⁻¹
  1 =&gt; 4y³+12y+12y⁻¹+4y⁻³

julia&gt; coefficients(p,:y)
Dict{Int64, Mvp{Int64, Int64}} with 9 entries:
  0  =&gt; x⁴+12x²+6
  4  =&gt; 1
  -1 =&gt; 4x³+12x
  2  =&gt; 6x²+4
  -3 =&gt; 4x
  -2 =&gt; 6x²+4
  -4 =&gt; 1
  3  =&gt; 4x
  1  =&gt; 4x³+12x"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p=(x+y+inv(y))^4
Mvp{Int64}: x⁴+4x³y+4x³y⁻¹+6x²y²+12x²+6x²y⁻²+4xy³+12xy+12xy⁻¹+4xy⁻³+y⁴+4y²+6+4y⁻²+y⁻⁴

julia&gt; coefficients(p,:x)
Dict{Int64, Mvp{Int64, Int64}} with 5 entries:
  0 =&gt; y⁴+4y²+6+4y⁻²+y⁻⁴
  4 =&gt; 1
  2 =&gt; 6y²+12+6y⁻²
  3 =&gt; 4y+4y⁻¹
  1 =&gt; 4y³+12y+12y⁻¹+4y⁻³

julia&gt; coefficients(p,:y)
Dict{Int64, Mvp{Int64, Int64}} with 9 entries:
  0  =&gt; x⁴+12x²+6
  4  =&gt; 1
  -1 =&gt; 4x³+12x
  2  =&gt; 6x²+4
  -3 =&gt; 4x
  -2 =&gt; 6x²+4
  -4 =&gt; 1
  3  =&gt; 4x
  1  =&gt; 4x³+12x
</code></pre></div>
<p dir="auto">The  same  caveat  is  applicable  to  <code>coefficients</code> as to evaluating: the values  are always <code>Mvp</code>s. To get a list of scalars for the coefficients of a  univariate polynomial represented as a <code>Mvp</code>, one should use <code>scalar</code> on the values of <code>coefficients</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L789-L824">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.coefficients-tuple{mvp}" href="#LaurentPolynomials.coefficients-Tuple{Mvp}">#</a>
<strong><code>LaurentPolynomials.coefficients</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>coefficients(p::Mvp)</code></p>
<p dir="auto">is an efficient iterator over the coefficients of the monomials in <code>p</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L782-L786">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.coefficient" href="#PuiseuxPolynomials.coefficient">#</a>
<strong><code>PuiseuxPolynomials.coefficient</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>coefficient(p::Mvp,m::Monomial)</code></p>
<p dir="auto">The coefficient of the polynomial <code>p</code> on the monomial <code>m</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y; p=(x-y)^3
Mvp{Int64}: x³-3x²y+3xy²-y³

julia&gt; coefficient(p,Monomial_(:x=&gt;2,:y=&gt;1)) # coefficient on x²y
-3

julia&gt; coefficient(p,Monomial()) # constant coefficient
0"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y; p=(x-y)^3
Mvp{Int64}: x³-3x²y+3xy²-y³

julia&gt; coefficient(p,Monomial_(:x=&gt;2,:y=&gt;1)) # coefficient on x²y
-3

julia&gt; coefficient(p,Monomial()) # constant coefficient
0
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L750-L765">source</a><br></p>
<p dir="auto"><code>coefficient(p::Mvp, var::Symbol, d)</code></p>
<p dir="auto">returns  the coefficient of degree <code>d</code> in the variable <code>var</code> in the <code>Mvp</code> <code>p</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y; p=(x+y^(1//2)+1)^3
Mvp{Int64,Rational{Int64}}: x³+3x²y½+3x²+3xy+6xy½+3x+y³⁄₂+3y+3y½+1

julia&gt; coefficient(p,:y,1//2)
Mvp{Int64,Rational{Int64}}: 3x²+6x+3

julia&gt; coefficient(p,:x,1)
Mvp{Int64,Rational{Int64}}: 3y+6y½+3"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y; p=(x+y^(1//2)+1)^3
Mvp{Int64,Rational{Int64}}: x³+3x²y½+3x²+3xy+6xy½+3x+y³⁄₂+3y+3y½+1

julia&gt; coefficient(p,:y,1//2)
Mvp{Int64,Rational{Int64}}: 3x²+6x+3

julia&gt; coefficient(p,:x,1)
Mvp{Int64,Rational{Int64}}: 3y+6y½+3
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L874-L889">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.monomial" href="#PuiseuxPolynomials.Monomial">#</a>
<strong><code>PuiseuxPolynomials.Monomial</code></strong> — <em>Type</em>.</p>
<p dir="auto"><code>Monomials</code>  are implemented as a  list of pairs <code>:variable=&gt;degree</code> sorted in  the  alphabetic  order  of  variables.  The  degree  can  be  <code>Int</code>  or <code>Rational{Int}</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L343-L347">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.monomials" href="#PuiseuxPolynomials.monomials">#</a>
<strong><code>PuiseuxPolynomials.monomials</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>monomials(p::Mvp)</code></p>
<p dir="auto">is an efficient iterator over the monomials of <code>p</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L775-L779">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.powers" href="#PuiseuxPolynomials.powers">#</a>
<strong><code>PuiseuxPolynomials.powers</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>powers(a::Monomial)</code> iterator on the powers of variables in <code>a</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L383">source</a><br></p>
<p dir="auto"><a id="user-content-base.pairs-tuple{monomial}" href="#Base.pairs-Tuple{Monomial}">#</a>
<strong><code>Base.pairs</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>pairs(a::Monomial)</code></p>
<p dir="auto">returns the pairs <code>:variable=&gt;power</code> in <code>a</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L385-L389">source</a><br></p>
<p dir="auto"><a id="user-content-base.isless-tuple{monomial, monomial}" href="#Base.isless-Tuple{Monomial, Monomial}">#</a>
<strong><code>Base.isless</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>isless(a::Monomial,b::Monomial)</code></p>
<p dir="auto">For  our implementation of <code>Mvp</code>s to  work, <code>isless</code> must define a monomial order (that is, for monomials <code>m,a,b</code> we have <code>a&lt;b =&gt; a*m&lt;b*m</code>). By default we  use the  "lex" ordering.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L491-L497">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.lex" href="#PuiseuxPolynomials.lex">#</a>
<strong><code>PuiseuxPolynomials.lex</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>lex(a::Monomial, b::Monomial)</code> The  "lex" ordering,  where <code>a&lt;b</code>  if the  first variable  in <code>a/b</code> occurs to a positive power.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L462-L466">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.grlex" href="#PuiseuxPolynomials.grlex">#</a>
<strong><code>PuiseuxPolynomials.grlex</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>grlex(a::Monomial, b::Monomial)</code> The "grlex" ordering, where <code>a&lt;b̀</code> if <code>degree(a)&gt;degree(b)</code> or the degrees are equal but <code>lex(a,b)</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L469-L473">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.grevlex" href="#PuiseuxPolynomials.grevlex">#</a>
<strong><code>PuiseuxPolynomials.grevlex</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>grevlex(a::Monomial, b::Monomial)</code> The "grevlex" ordering, where <code>a&lt;b̀</code> if <code>degree(a)&gt;degree(b)</code> or the degrees are equal but the last variable in <code>a/b</code> occurs to a negative power.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L480-L484">source</a><br></p>
<p dir="auto"><a id="user-content-base.pairs-tuple{mvp}" href="#Base.pairs-Tuple{Mvp}">#</a>
<strong><code>Base.pairs</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>pairs(p::Mvp)</code></p>
<p dir="auto">returns the pairs monomial=&gt;coefficient in <code>p</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L768-L772">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.pol-union{tuple{mvp{t}}, tuple{t}} where t" href="#LaurentPolynomials.Pol-Union{Tuple{Mvp{T}}, Tuple{T}} where T">#</a>
<strong><code>LaurentPolynomials.Pol</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>Pol(p::Mvp{T}) where T</code></p>
<p dir="auto">converts the one-variable <code>Mvp{T}</code> <code>p</code> to a <code>Pol{T}</code>. It is an error if <code>p</code> has  more  than  one  variable,  or  this  variable appears to non-integral powers.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x; @Pol q; Pol(x^2+x)
Pol{Int64}: q²+q"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x; @Pol q; Pol(x^2+x)
Pol{Int64}: q²+q
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L907-L918">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.pol-union{tuple{n}, tuple{t}, tuple{mvp{t, n}, symbol}} where {t, n}" href="#LaurentPolynomials.Pol-Union{Tuple{N}, Tuple{T}, Tuple{Mvp{T, N}, Symbol}} where {T, N}">#</a>
<strong><code>LaurentPolynomials.Pol</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>Pol(p::Mvp,v::Symbol)</code></p>
<p dir="auto">returns  a polynomial whose coefficients are  the coefficients of the <code>Mvp</code> <code>p</code>  with respect to the variable <code>v</code>  (as <code>Mvp</code>s). The variable <code>v</code> should appear only with integral powers in <code>p</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p=(x+y^(1//2))^3
Mvp{Int64,Rational{Int64}}: x³+3x²y½+3xy+y³⁄₂

julia&gt; Pol(:q); Pol(p,:x)
Pol{Mvp{Int64, Rational{Int64}}}: q³+3y½q²+3yq+y³⁄₂"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p=(x+y^(1//2))^3
Mvp{Int64,Rational{Int64}}: x³+3x²y½+3xy+y³⁄₂

julia&gt; Pol(:q); Pol(p,:x)
Pol{Mvp{Int64, Rational{Int64}}}: q³+3y½q²+3yq+y³⁄₂
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L841-L855">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.mvp-tuple{pol}" href="#PuiseuxPolynomials.Mvp-Tuple{Pol}">#</a>
<strong><code>PuiseuxPolynomials.Mvp</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>Mvp(p::Pol[,v])</code> converts <code>p</code> to  an  <code>Mvp</code>, with the same variable name   if <code>v</code> omitted or the variable name <code>v</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Pol q
Pol{Int64}: q

julia&gt; Mvp(q^2+q)
Mvp{Int64}: q²+q

julia&gt; Mvp(q^2+q,:x)
Mvp{Int64}: x²+x"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Pol q
Pol{Int64}: q

julia&gt; Mvp(q^2+q)
Mvp{Int64}: q²+q

julia&gt; Mvp(q^2+q,:x)
Mvp{Int64}: x²+x
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L929-L943">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.value" href="#PuiseuxPolynomials.value">#</a>
<strong><code>PuiseuxPolynomials.value</code></strong> — <em>Function</em>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="`value(p::Mvp,:x₁=&gt;v₁,:x₂=&gt;v₂,...)`
 ̀(p::Mvp)(x₁=v₁,…,xₙ=vₙ)`"><pre lang="julia" class="notranslate"><code>`value(p::Mvp,:x₁=&gt;v₁,:x₂=&gt;v₂,...)`
 ̀(p::Mvp)(x₁=v₁,…,xₙ=vₙ)`
</code></pre></div>
<p dir="auto">returns  the value of  <code>p</code> when doing  the simultaneous substitution of the variable <code>:x1</code> by <code>v1</code>, of <code>x2</code> by <code>v2</code>, …</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p=-2+7x^5*inv(y)
Mvp{Int64}: 7x⁵y⁻¹-2

julia&gt; p(x=2)
Mvp{Int64}: -2+224y⁻¹

julia&gt; p(y=1)
Mvp{Int64}: 7x⁵-2

julia&gt; p(x=2,y=1)
Mvp{Int64}: 222"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p=-2+7x^5*inv(y)
Mvp{Int64}: 7x⁵y⁻¹-2

julia&gt; p(x=2)
Mvp{Int64}: -2+224y⁻¹

julia&gt; p(y=1)
Mvp{Int64}: 7x⁵-2

julia&gt; p(x=2,y=1)
Mvp{Int64}: 222
</code></pre></div>
<p dir="auto">One should pay attention to the fact that the last value is not an integer, but  a constant <code>Mvp</code> (for consistency).  See the function <code>scalar</code> for how to convert such constants to their base ring.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p(x=y)
Mvp{Int64}: 7y⁴-2

julia&gt; p(x=y,y=x)
Mvp{Int64}: -2+7x⁻¹y⁵"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p(x=y)
Mvp{Int64}: 7y⁴-2

julia&gt; p(x=y,y=x)
Mvp{Int64}: -2+7x⁻¹y⁵
</code></pre></div>
<p dir="auto">Evaluating an <code>Mvp</code> which is a Puiseux polynomial may cause calls to <code>root</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p=x^(1//2)*y^(1//3)
Mvp{Int64,Rational{Int64}}: x½y⅓

julia&gt; p(;x=y)
Mvp{Int64,Rational{Int64}}: y⅚

julia&gt; p(;x=4)
Mvp{Int64,Rational{Int64}}: 2y⅓

julia&gt; p(;y=2.0)
Mvp{Float64,Rational{Int64}}: 1.2599210498948732x½"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p=x^(1//2)*y^(1//3)
Mvp{Int64,Rational{Int64}}: x½y⅓

julia&gt; p(;x=y)
Mvp{Int64,Rational{Int64}}: y⅚

julia&gt; p(;x=4)
Mvp{Int64,Rational{Int64}}: 2y⅓

julia&gt; p(;y=2.0)
Mvp{Float64,Rational{Int64}}: 1.2599210498948732x½
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1010-L1057">source</a><br></p>
<p dir="auto"><a id="user-content-base.conj" href="#Base.conj">#</a>
<strong><code>Base.conj</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>conj(p::Mvp)</code> acts on the coefficients of <code>p</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x;conj(im*x+1)
Mvp{Complex{Int64}}: (0 - 1im)x+1 + 0im"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x;conj(im*x+1)
Mvp{Complex{Int64}}: (0 - 1im)x+1 + 0im
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L688-L695">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.derivative" href="#LaurentPolynomials.derivative">#</a>
<strong><code>LaurentPolynomials.derivative</code></strong> — <em>Function</em>.</p>
<p dir="auto">The  function 'derivative(p,v₁,…,vₙ)' returns the  derivative of 'p' with  respect to  the variable given by the symbol 'v₁', then <code>v₂</code>, ...</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y;p=7x^5*y^-1-2
Mvp{Int64}: 7x⁵y⁻¹-2

julia&gt; derivative(p,:x)
Mvp{Int64}: 35x⁴y⁻¹

julia&gt; derivative(p,:y)
Mvp{Int64}: -7x⁵y⁻²

julia&gt; derivative(p,:x,:y)
Mvp{Int64}: -35x⁴y⁻²

julia&gt; p=x^(1//2)*y^(1//3)
Mvp{Int64,Rational{Int64}}: x½y⅓

julia&gt; derivative(p,:x)
Mvp{Rational{Int64},Rational{Int64}}: (1//2)x⁻½y⅓

julia&gt; derivative(p,:y)
Mvp{Rational{Int64},Rational{Int64}}: (1//3)x½y⁻⅔

julia&gt; derivative(p,:z)
Mvp{Rational{Int64},Rational{Int64}}: 0"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y;p=7x^5*y^-1-2
Mvp{Int64}: 7x⁵y⁻¹-2

julia&gt; derivative(p,:x)
Mvp{Int64}: 35x⁴y⁻¹

julia&gt; derivative(p,:y)
Mvp{Int64}: -7x⁵y⁻²

julia&gt; derivative(p,:x,:y)
Mvp{Int64}: -35x⁴y⁻²

julia&gt; p=x^(1//2)*y^(1//3)
Mvp{Int64,Rational{Int64}}: x½y⅓

julia&gt; derivative(p,:x)
Mvp{Rational{Int64},Rational{Int64}}: (1//2)x⁻½y⅓

julia&gt; derivative(p,:y)
Mvp{Rational{Int64},Rational{Int64}}: (1//3)x½y⁻⅔

julia&gt; derivative(p,:z)
Mvp{Rational{Int64},Rational{Int64}}: 0
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1145-L1174">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.laurent_denominator" href="#PuiseuxPolynomials.laurent_denominator">#</a>
<strong><code>PuiseuxPolynomials.laurent_denominator</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>laurent_denominator(p1,p2,…)</code></p>
<p dir="auto">returns  the unique  monomial <code>m</code>  of minimal  degree in each variable such that  for all  the Laurent  polynomials <code>p1,p2,…</code>  the product <code>m*pᵢ</code> has a positive degree in each variable.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; laurent_denominator(x^-1,y^-2+x^4)
Monomial{Int64}:xy²"><pre lang="julia-repl" class="notranslate"><code>julia&gt; laurent_denominator(x^-1,y^-2+x^4)
Monomial{Int64}:xy²
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1245-L1256">source</a><br></p>
<p dir="auto"><a id="user-content-base.gcd-tuple{mvp, mvp}" href="#Base.gcd-Tuple{Mvp, Mvp}">#</a>
<strong><code>Base.gcd</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>gcd(p::Mvp,  q::Mvp)</code>  computes  the  <code>gcd</code>  of  the  'Mvp' arguments. The arguments must be true polynomials.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; gcd((x+y)^2,x^2-y^2)
Mvp{Int64}: x+y"><pre lang="julia-repl" class="notranslate"><code>julia&gt; gcd((x+y)^2,x^2-y^2)
Mvp{Int64}: x+y
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1214-L1222">source</a><br></p>
<p dir="auto"><a id="user-content-base.lcm-tuple{mvp, mvp}" href="#Base.lcm-Tuple{Mvp, Mvp}">#</a>
<strong><code>Base.lcm</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>lcm(p1,p2,...)</code></p>
<p dir="auto">Returns  the Lcm  of the  <code>Mvp</code> arguments.  The arguments  must be  true polynomials.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; lcm(x^2-y^2,(x+y)^2)
Mvp{Int64}: -x³-x²y+xy²+y³"><pre lang="julia-repl" class="notranslate"><code>julia&gt; lcm(x^2-y^2,(x+y)^2)
Mvp{Int64}: -x³-x²y+xy²+y³
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1259-L1269">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.scalar" href="#LaurentPolynomials.scalar">#</a>
<strong><code>LaurentPolynomials.scalar</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>scalar(p::Mvp)</code></p>
<p dir="auto">If <code>p</code> is a scalar, return that scalar, otherwise return <code>nothing</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; p=Mvp(:x)+1
Mvp{Int64}: x+1

julia&gt; w=p(x=4)
Mvp{Int64}: 5

julia&gt; scalar(w)
5

julia&gt; typeof(scalar(w))
Int64"><pre lang="julia-repl" class="notranslate"><code>julia&gt; p=Mvp(:x)+1
Mvp{Int64}: x+1

julia&gt; w=p(x=4)
Mvp{Int64}: 5

julia&gt; scalar(w)
5

julia&gt; typeof(scalar(w))
Int64
</code></pre></div>
<p dir="auto">if  <code>p</code> is an array, then apply <code>scalar</code> to its elements and return <code>nothing</code> if it contains any <code>Mvp</code> which is not a scalar.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L976-L996">source</a><br></p>
<p dir="auto"><a id="user-content-base.:^-tuple{mvp, abstractmatrix}">#</a>
<strong><code>Base.:^</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>Base.:^(p,m;vars=variables(p))</code></p>
<p dir="auto">Implements  the action of  a matrix on  <code>Mvp</code>s. <code>vars</code> should  be a list of symbols   representing  variables.   The  polynomial   <code>p</code>  is  changed  by simultaneous  substitution in it of  <code>vᵢ</code> by <code>(v×m)ᵢ</code> where  <code>v</code> is the row vector  with entries  <code>Mvp(vᵢ)</code>. If  <code>vars</code> is  omitted, it  is taken to be <code>variables(p)</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y

julia&gt; (x+y)^[1 2;3 1]
Mvp{Int64}: 3x+4y"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y

julia&gt; (x+y)^[1 2;3 1]
Mvp{Int64}: 3x+4y
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1116-L1131">source</a><br></p>
<p dir="auto"><a id="user-content-laurentpolynomials.frac-tuple{t} where t&lt;:mvp">#</a>
<strong><code>LaurentPolynomials.Frac</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>Frac(a::Mvp,b::Mvp;pol=false,prime=false)</code></p>
<p dir="auto"><code>Mvp</code>s  <code>a</code> and <code>b</code> are promoted to  same coefficient type, and checked for being  true polynomials  without common  monomial factor (unless <code>pol=true</code> asserts  that this  is already  the case)  and unless <code>prime=true</code> they are made prime to each other by dividing by their gcd.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1304-L1311">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.grobner_basis" href="#PuiseuxPolynomials.grobner_basis">#</a>
<strong><code>PuiseuxPolynomials.grobner_basis</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>grobner_basis(F;lt=lex)</code></p>
<p dir="auto">computes  a Gröbner basis  of the polynomial  ideal generated by the <code>Mvp</code>s given  by the vector <code>F</code>. The  keyword <code>lt</code> describes the monomial ordering to use.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y,z; F=[x^2+y^2+z^2-1,x^2-y+z^2,x-z]
3-element Vector{Mvp{Int64, Int64}}:
 x²+y²+z²-1
 x²-y+z²
 x-z

julia&gt; grobner_basis(F)
3-element Vector{Mvp{Int64, Int64}}:
 x-z
 -y+2z²
 4z⁴+2z²-1

julia&gt; grobner_basis(F;lt=grlex)
3-element Vector{Mvp{Int64, Int64}}:
 x-z
 y²+y-1
 -y+2z²

julia&gt; grobner_basis(F;lt=grevlex)
3-element Vector{Mvp{Int64, Int64}}:
 x-z
 y²+y-1
 2x²-y"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y,z; F=[x^2+y^2+z^2-1,x^2-y+z^2,x-z]
3-element Vector{Mvp{Int64, Int64}}:
 x²+y²+z²-1
 x²-y+z²
 x-z

julia&gt; grobner_basis(F)
3-element Vector{Mvp{Int64, Int64}}:
 x-z
 -y+2z²
 4z⁴+2z²-1

julia&gt; grobner_basis(F;lt=grlex)
3-element Vector{Mvp{Int64, Int64}}:
 x-z
 y²+y-1
 -y+2z²

julia&gt; grobner_basis(F;lt=grevlex)
3-element Vector{Mvp{Int64, Int64}}:
 x-z
 y²+y-1
 2x²-y
</code></pre></div>
<p dir="auto">There is no keyword to change the ordering of the variables. We suggest to use <code>rename_variables</code> for this purpose.</p>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1479-L1512">source</a><br></p>
<p dir="auto"><a id="user-content-puiseuxpolynomials.rename_variables" href="#PuiseuxPolynomials.rename_variables">#</a>
<strong><code>PuiseuxPolynomials.rename_variables</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>rename_variables(p,v)</code> renames <code>variables(p)</code> to <code>v</code></p>
<p dir="auto"><code>rename_variables(p,l::Pair{Symbol,Symbol}...)</code> renames the  variables in <code>p</code> as indicated by the pairs in <code>l</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; @Mvp x,y,z; p=x+y+z
Mvp{Int64}: x+y+z

julia&gt; rename_variables(p,Symbol.('A':'Z'))
Mvp{Int64}: A+B+C

julia&gt; rename_variables(p,[:U,:V])
Mvp{Int64}: U+V+z

julia&gt; rename_variables(p,:x=&gt;:U,:z=&gt;:V) # faster than p(;x=Mvp(:U),z=Mvp(:V))
Mvp{Int64}: U+V+y"><pre lang="julia-repl" class="notranslate"><code>julia&gt; @Mvp x,y,z; p=x+y+z
Mvp{Int64}: x+y+z

julia&gt; rename_variables(p,Symbol.('A':'Z'))
Mvp{Int64}: A+B+C

julia&gt; rename_variables(p,[:U,:V])
Mvp{Int64}: U+V+z

julia&gt; rename_variables(p,:x=&gt;:U,:z=&gt;:V) # faster than p(;x=Mvp(:U),z=Mvp(:V))
Mvp{Int64}: U+V+y
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/PuiseuxPolynomials.jl/blob/e4e24df98e21c7502a7cf7706f2e954b537376d1/src/PuiseuxPolynomials.jl#L1538-L1557">source</a><br></p>
</article></div>