<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-lightbson" class="anchor" aria-hidden="true" href="#lightbson"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LightBSON</h1>
<p dir="auto"><a href="https://github.com/ancapdev/LightBSON.jl/actions"><img src="https://github.com/ancapdev/LightBSON.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/ancapdev/LightBSON.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f62fd023165fdb2faf9aee08690cc56e883a3790f8956f7e6eff86d8c80eb881/68747470733a2f2f636f6465636f762e696f2f67682f616e6361706465762f4c6967687442534f4e2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d3949454157564c50434e" alt="codecov" data-canonical-src="https://codecov.io/gh/ancapdev/LightBSON.jl/branch/master/graph/badge.svg?token=9IEAWVLPCN" style="max-width: 100%;"></a></p>
<p dir="auto">High performance encoding and decoding of <a href="https://bsonspec.org/" rel="nofollow">BSON</a> data.</p>
<h2 dir="auto"><a id="user-content-what-it-is" class="anchor" aria-hidden="true" href="#what-it-is"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What It Is</h2>
<ul dir="auto">
<li>Allocation free API for reading and writing BSON data.</li>
<li>Natural mapping of Julia types to corresponding BSON types.</li>
<li>Convenience API to read and write <code>Dict{String, Any}</code> or <code>OrderedDict{String, Any}</code> (default, for roundtrip consistency) as BSON.</li>
<li>Struct API tunable for tradeoffs between flexibility, performance, and evolution.</li>
<li>Configurable validation levels.</li>
<li>Light weight indexing for larger documents.</li>
<li><a href="https://github.com/JuliaFolds/Transducers.jl">Transducers.jl</a> compatible.</li>
<li>Tested for conformance against the <a href="https://github.com/mongodb/specifications/blob/master/source/bson-corpus/bson-corpus.rst">BSON corpus</a>.</li>
</ul>
<h2 dir="auto"><a id="user-content-what-it-is-not" class="anchor" aria-hidden="true" href="#what-it-is-not"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What It Is Not</h2>
<ul dir="auto">
<li>Generic serialization of all Julia types to BSON. See <a href="https://github.com/JuliaIO/BSON.jl">BSON.jl</a> for that functionality. <a href="#LightBSON">LightBSON.jl</a> aims for natural representations, suitable for interop with other languages and long term persistence.</li>
<li>Integrated with <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a>. <a href="https://github.com/JuliaIO/BSON.jl">BSON.jl</a> already is, and adding another with different semantics would be confusing.</li>
<li>A BSON mutation API. Reading and writing are entirely separate and only complete documents can be written.</li>
<li>Conversion to and from <a href="https://docs.mongodb.com/manual/reference/mongodb-extended-json/" rel="nofollow">Extended JSON</a>. This may be added later.</li>
</ul>
<h2 dir="auto"><a id="user-content-high-level-api" class="anchor" aria-hidden="true" href="#high-level-api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>High Level API</h2>
<p dir="auto">Performance sensitive use cases are the focus of this package, but a high level API is available for where performance is less of a concern. The high level API will also perform optimally when reading simple types without strings, arrays, or other fields that require allocation.</p>
<ul dir="auto">
<li><code>bson_read([T=Any], src)</code> reads <code>T</code> from <code>src</code> where <code>src</code> is either a <code>DenseVector{UInt8}</code>, an <code>IO</code>
object, or a path to a file.</li>
<li><code>bson_write(dst, x)</code> writes <code>x</code> to <code>dst</code> where <code>x</code> is a type that maps to fields (dictionary, struct, named tuple), and <code>dst</code> is a <code>DenseVector{UInt8}</code>, an <code>IO</code>, or a path to a file.</li>
<li><code>bson_write(dst, xs...)</code> writes <code>xs</code> to <code>dst</code> where <code>xs</code> is a list of <code>Pair{String, T}</code> mapping names to field values, and <code>dst</code> is as above.</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Write to a byte buffer and return the buffer
buf = bson_write(UInt8[], :x =&gt; Int64(1), :y =&gt; Int64(2))
# Read from a byte buffer as an OrderedDict{String, Any}
bson_read(buf)
# Read from a byte buffer as a specific type
x = bson_read(@NamedTuple{x::Int64, y::Int64}, buf)
path = joinpath(homedir(), &quot;test.bson&quot;)
# Write to a file
bson_write(path, x)
# Read from a file as an OrderedDict{String Any}
bson_read(path)"><pre><span class="pl-c"><span class="pl-c">#</span> Write to a byte buffer and return the buffer</span>
buf <span class="pl-k">=</span> <span class="pl-c1">bson_write</span>(UInt8[], <span class="pl-c1">:x</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">1</span>), <span class="pl-c1">:y</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">2</span>))
<span class="pl-c"><span class="pl-c">#</span> Read from a byte buffer as an OrderedDict{String, Any}</span>
<span class="pl-c1">bson_read</span>(buf)
<span class="pl-c"><span class="pl-c">#</span> Read from a byte buffer as a specific type</span>
x <span class="pl-k">=</span> <span class="pl-c1">bson_read</span>(<span class="pl-c1">@NamedTuple</span>{x<span class="pl-k">::</span><span class="pl-c1">Int64</span>, y<span class="pl-k">::</span><span class="pl-c1">Int64</span>}, buf)
path <span class="pl-k">=</span> <span class="pl-c1">joinpath</span>(<span class="pl-c1">homedir</span>(), <span class="pl-s"><span class="pl-pds">"</span>test.bson<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">#</span> Write to a file</span>
<span class="pl-c1">bson_write</span>(path, x)
<span class="pl-c"><span class="pl-c">#</span> Read from a file as an OrderedDict{String Any}</span>
<span class="pl-c1">bson_read</span>(path)</pre></div>
<h2 dir="auto"><a id="user-content-low-level-api" class="anchor" aria-hidden="true" href="#low-level-api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Low Level API</h2>
<ul dir="auto">
<li>Documents are read and written to and from byte arrays with <a href="src/reader.jl">BSONReader</a> and <a href="src/writer.jl">BSONWriter</a>.</li>
<li><a href="src/reader.jl">BSONReader</a> and <a href="src/writer.jl">BSONWriter</a> are immutable struct types with no state. They can be instantiated without allocation.</li>
<li><a href="src.writer.jl">BSONWriter</a> will append to the destination array. User is responsible for not writing duplicate fields.</li>
<li><code>reader["foo"]</code> or <code>reader[:foo]</code> finds <code>foo</code> and returns a new reader pointing to the field.</li>
<li><code>reader[T]</code> materializes a field to the type <code>T</code>.</li>
<li><code>writer["foo"] = x</code> or <code>writer[:foo] = x</code> appends a field with name <code>foo</code> and value <code>x</code>.</li>
<li><code>close(writer)</code> finalizes a document (writes the document length and terminating null byte).</li>
<li>Prefer strings for field names. Symbols in Julia unfortunately do not have a constant time length API.</li>
</ul>
<h3 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = Int64(123)
close(writer)
reader = BSONReader(buf)
reader[&quot;x&quot;][Int64] # 123"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">123</span>)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 123</span></pre></div>
<h3 dir="auto"><a id="user-content-nested-documents" class="anchor" aria-hidden="true" href="#nested-documents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Nested Documents</h3>
<p dir="auto">Nested documents are written by assigning a field with a function that takes a nested writer. Nested fields are read by index.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = nested_writer -&gt; begin
    nested_writer[&quot;a&quot;] = 1
    nested_writer[&quot;b&quot;] = 2
end
close(writer)
reader = BSONReader(buf)
reader[&quot;x&quot;][&quot;a&quot;][Int64] # 1
reader[&quot;x&quot;][&quot;b&quot;][Int64] # 2"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> nested_writer <span class="pl-k">-&gt;</span> <span class="pl-k">begin</span>
    nested_writer[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>
    nested_writer[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>
<span class="pl-k">end</span>
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 1</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 2</span></pre></div>
<h3 dir="auto"><a id="user-content-arrays" class="anchor" aria-hidden="true" href="#arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Arrays</h3>
<p dir="auto">Arrays are written by assigning array values, or by generators. Arrays can be materialized to Julia arrays, or be accessed by index.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = Int64[1, 2, 3]
writer[&quot;y&quot;] = (Int64(x * x) for x in 1:3)
close(writer)
reader = BSONReader(buf)
reader[&quot;x&quot;][Vector{Int64}] # [1, 2, 3]
reader[&quot;y&quot;][Vector{Int64}] # [1, 4, 9]
reader[&quot;x&quot;][2][Int64] # 2
reader[&quot;y&quot;][2][Int64] # 4"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> Int64[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
writer[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> (<span class="pl-c1">Int64</span>(x <span class="pl-k">*</span> x) <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][Vector{Int64}] <span class="pl-c"><span class="pl-c">#</span> [1, 2, 3]</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>][Vector{Int64}] <span class="pl-c"><span class="pl-c">#</span> [1, 4, 9]</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][<span class="pl-c1">2</span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 2</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>][<span class="pl-c1">2</span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 4</span></pre></div>
<h3 dir="auto"><a id="user-content-dict-and-any" class="anchor" aria-hidden="true" href="#dict-and-any"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Dict and Any</h3>
<p dir="auto">Where performance is not a concern, elements can be materialized to dictionaries (recursively) or to the most appropriate Julia type for leaf fields. Dictionaries can also be written directly.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[] = OrderedDict{String, Any}(&quot;x&quot; =&gt; Int64(1), &quot;y&quot; =&gt; &quot;foo&quot;)
close(writer)
reader = BSONReader(buf)
reader[Dict{String, Any}] # Dict{String, Any}(&quot;x&quot; =&gt; 1, &quot;y&quot; =&gt; &quot;foo&quot;)
reader[OrderedDict{String, Any}] # OrderedDict{String, Any}(&quot;x&quot; =&gt; 1, &quot;y&quot; =&gt; &quot;foo&quot;)
reader[Any] # OrderedDict{String, Any}(&quot;x&quot; =&gt; 1, &quot;y&quot; =&gt; &quot;foo&quot;)
reader[&quot;x&quot;][Any] # 1
reader[&quot;y&quot;][Any] # &quot;foo&quot;"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[] <span class="pl-k">=</span> <span class="pl-c1">OrderedDict</span><span class="pl-c1">{String, Any}</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">1</span>), <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[Dict{String, Any}] <span class="pl-c"><span class="pl-c">#</span> Dict{String, Any}("x" =&gt; 1, "y" =&gt; "foo")</span>
reader[OrderedDict{String, Any}] <span class="pl-c"><span class="pl-c">#</span> OrderedDict{String, Any}("x" =&gt; 1, "y" =&gt; "foo")</span>
reader[Any] <span class="pl-c"><span class="pl-c">#</span> OrderedDict{String, Any}("x" =&gt; 1, "y" =&gt; "foo")</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][Any] <span class="pl-c"><span class="pl-c">#</span> 1</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>][Any] <span class="pl-c"><span class="pl-c">#</span> "foo"</span></pre></div>
<h3 dir="auto"><a id="user-content-arrays-with-nested-documents" class="anchor" aria-hidden="true" href="#arrays-with-nested-documents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Arrays With Nested Documents</h3>
<p dir="auto">Generators can be used to directly write nested documents in arrays.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = (
    nested_writer -&gt; begin
        nested_writer[&quot;a&quot;] = Int64(x)
        nested_writer[&quot;b&quot;] = Int64(x * x)
    end
    for x in 1:3
)
close(writer)
reader = BSONReader(buf)
reader[&quot;x&quot;][Vector{Any}] # Any[OrderedDict{String, Any}(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 1), OrderedDict{String, Any}(&quot;a&quot; =&gt; 2, &quot;b&quot; =&gt; 4), OrderedDict{String, Any}(&quot;a&quot; =&gt; 3, &quot;b&quot; =&gt; 9)]
reader[&quot;x&quot;][3][&quot;b&quot;][Int64] # 9"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> (
    nested_writer <span class="pl-k">-&gt;</span> <span class="pl-k">begin</span>
        nested_writer[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(x)
        nested_writer[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(x <span class="pl-k">*</span> x)
    <span class="pl-k">end</span>
    <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>
)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][Vector{Any}] <span class="pl-c"><span class="pl-c">#</span> Any[OrderedDict{String, Any}("a" =&gt; 1, "b" =&gt; 1), OrderedDict{String, Any}("a" =&gt; 2, "b" =&gt; 4), OrderedDict{String, Any}("a" =&gt; 3, "b" =&gt; 9)]</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][<span class="pl-c1">3</span>][<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 9</span></pre></div>
<h3 dir="auto"><a id="user-content-read-abstract-types" class="anchor" aria-hidden="true" href="#read-abstract-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Read Abstract Types</h3>
<p dir="auto">The abstract types <code>Number</code>, <code>Integer</code>, and <code>AbstractFloat</code> can be used to materialize numeric fields to the most appropriate Julia type under the abstract type.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = Int32(123)
writer[&quot;y&quot;] = 1.25
close(writer)
reader = BSONReader(buf)
reader[&quot;x&quot;][Number] # 123
reader[&quot;x&quot;][Integer] # 123
reader[&quot;y&quot;][Number] # 1.25
reader[&quot;y&quot;][AbstractFloat] # 1.25"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int32</span>(<span class="pl-c1">123</span>)
writer[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1.25</span>
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][Number] <span class="pl-c"><span class="pl-c">#</span> 123</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][Integer] <span class="pl-c"><span class="pl-c">#</span> 123</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>][Number] <span class="pl-c"><span class="pl-c">#</span> 1.25</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>][AbstractFloat] <span class="pl-c"><span class="pl-c">#</span> 1.25</span></pre></div>
<h3 dir="auto"><a id="user-content-unsafe-string" class="anchor" aria-hidden="true" href="#unsafe-string"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unsafe String</h3>
<p dir="auto">String fields can be materialized as <code>WeakRefString{UInt8}</code>, aliased as <code>UnsafeBSONString</code>. This will create a string object with pointers to the underlying buffer without performing any allocations. User must take care of GC safety.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = &quot;foo&quot;
close(writer)
reader = BSONReader(buf)
s = reader[&quot;x&quot;][UnsafeBSONString]
GC.@preserve buf s == &quot;foo&quot; # true"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
s <span class="pl-k">=</span> reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][UnsafeBSONString]
GC<span class="pl-k">.</span><span class="pl-c1">@preserve</span> buf s <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<h3 dir="auto"><a id="user-content-binary" class="anchor" aria-hidden="true" href="#binary"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Binary</h3>
<p dir="auto">Binary fields are represented with <code>BSONBinary</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = BSONBinary([0x1, 0x2, 0x3], BSON_SUBTYPE_GENERIC_BINARY)
close(writer)
reader = BSONReader(buf)
x = reader[&quot;x&quot;][BSONBinary]
x.data # [0x1, 0x2, 0x3]
x.subtype # BSON_SUBTYPE_GENERIC_BINARY"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">BSONBinary</span>([<span class="pl-c1">0x1</span>, <span class="pl-c1">0x2</span>, <span class="pl-c1">0x3</span>], BSON_SUBTYPE_GENERIC_BINARY)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
x <span class="pl-k">=</span> reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][BSONBinary]
x<span class="pl-k">.</span>data <span class="pl-c"><span class="pl-c">#</span> [0x1, 0x2, 0x3]</span>
x<span class="pl-k">.</span>subtype <span class="pl-c"><span class="pl-c">#</span> BSON_SUBTYPE_GENERIC_BINARY</span></pre></div>
<h3 dir="auto"><a id="user-content-unsafe-binary" class="anchor" aria-hidden="true" href="#unsafe-binary"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unsafe Binary</h3>
<p dir="auto">Binary fields can be materialized as <code>UnsafeBSONBinary</code> for zero alocations, where the <code>data</code> field is an <code>UnsafeArray{UInt8, 1}</code> with pointers into the underlying buffer. User must take care of GC safety.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = BSONBinary([0x1, 0x2, 0x3], BSON_SUBTYPE_GENERIC_BINARY)
close(writer)
reader = BSONReader(buf)
x = reader[&quot;x&quot;][UnsafeBSONBinary]
GC.@preserve buf x.data == [0x1, 0x2, 0x3] # true
x.subtype # BSON_SUBTYPE_GENERIC_BINARY"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">BSONBinary</span>([<span class="pl-c1">0x1</span>, <span class="pl-c1">0x2</span>, <span class="pl-c1">0x3</span>], BSON_SUBTYPE_GENERIC_BINARY)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
x <span class="pl-k">=</span> reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][UnsafeBSONBinary]
GC<span class="pl-k">.</span><span class="pl-c1">@preserve</span> buf x<span class="pl-k">.</span>data <span class="pl-k">==</span> [<span class="pl-c1">0x1</span>, <span class="pl-c1">0x2</span>, <span class="pl-c1">0x3</span>] <span class="pl-c"><span class="pl-c">#</span> true</span>
x<span class="pl-k">.</span>subtype <span class="pl-c"><span class="pl-c">#</span> BSON_SUBTYPE_GENERIC_BINARY</span></pre></div>
<h3 dir="auto"><a id="user-content-iteration" class="anchor" aria-hidden="true" href="#iteration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Iteration</h3>
<p dir="auto">Fields can be iterated with <code>foreach()</code> or using the <a href="https://github.com/JuliaFolds/Transducers.jl">Transducers.jl</a> APIs. Fields are represented as <code>Pair{UnsafeBSONString, BSONReader}</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = Int64(1)
writer[&quot;y&quot;] = Int64(2)
writer[&quot;z&quot;] = Int64(3)
close(writer)
reader = BSONReader(buf)
reader |&gt; Map(x -&gt; x.second[Int64]) |&gt; sum # 6
foreach(x -&gt; println(x.second[Int64]), reader) # 1\n2\n3\n"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">1</span>)
writer[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">2</span>)
writer[<span class="pl-s"><span class="pl-pds">"</span>z<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader <span class="pl-k">|&gt;</span> <span class="pl-c1">Map</span>(x <span class="pl-k">-&gt;</span> x<span class="pl-k">.</span>second[Int64]) <span class="pl-k">|&gt;</span> sum <span class="pl-c"><span class="pl-c">#</span> 6</span>
<span class="pl-c1">foreach</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">println</span>(x<span class="pl-k">.</span>second[Int64]), reader) <span class="pl-c"><span class="pl-c">#</span> 1\n2\n3\n</span></pre></div>
<h2 dir="auto"><a id="user-content-indexing" class="anchor" aria-hidden="true" href="#indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Indexing</h2>
<p dir="auto">BSON field access involves a linear scan to find the matching field name. Depending on the size and structure of a document, and the fields being accessed, it migh be preferable to build an index over the fields first, to be re-used on every access.</p>
<p dir="auto"><a href="src/index.jl">BSONIndex</a> provides a very light weight partial (collisions evict previous entries) index over a document. It is designed to be re-used from document to document, by means of a constant time reset. <a href="src/indexed_reader.jl">IndexedBSONReader</a> wraps a reader and an index to accelerate field access in a document. Index misses fall back to the wrapped reader.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;x&quot;] = Int64(1)
writer[&quot;y&quot;] = Int64(2)
writer[&quot;z&quot;] = Int64(3)
close(writer)
index = BSONIndex(128)
# Index is built when IndexBSONReader is constructed
reader = IndexedBSONReader(index, BSONReader(buf))
reader[&quot;z&quot;][Int64] # 3 -- accessed by index

empty!(buf)
writer = BSONWriter(buf)
writer[&quot;a&quot;] = Int64(1)
writer[&quot;b&quot;] = Int64(2)
writer[&quot;c&quot;] = Int64(3)
close(writer)
# Index can be re-used
reader = IndexedBSONReader(index, BSONReader(buf))
reader[&quot;b&quot;][Int64] # 2 -- accessed by index
reader[&quot;x&quot;] # throws KeyError"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">1</span>)
writer[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">2</span>)
writer[<span class="pl-s"><span class="pl-pds">"</span>z<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">close</span>(writer)
index <span class="pl-k">=</span> <span class="pl-c1">BSONIndex</span>(<span class="pl-c1">128</span>)
<span class="pl-c"><span class="pl-c">#</span> Index is built when IndexBSONReader is constructed</span>
reader <span class="pl-k">=</span> <span class="pl-c1">IndexedBSONReader</span>(index, <span class="pl-c1">BSONReader</span>(buf))
reader[<span class="pl-s"><span class="pl-pds">"</span>z<span class="pl-pds">"</span></span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 3 -- accessed by index</span>

<span class="pl-c1">empty!</span>(buf)
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">1</span>)
writer[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">2</span>)
writer[<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">close</span>(writer)
<span class="pl-c"><span class="pl-c">#</span> Index can be re-used</span>
reader <span class="pl-k">=</span> <span class="pl-c1">IndexedBSONReader</span>(index, <span class="pl-c1">BSONReader</span>(buf))
reader[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 2 -- accessed by index</span>
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-c"><span class="pl-c">#</span> throws KeyError</span></pre></div>
<h2 dir="auto"><a id="user-content-validation" class="anchor" aria-hidden="true" href="#validation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Validation</h2>
<p dir="auto"><a href="src/reader.jl">BSONReader</a> can be configured with a validator to use during the processing of the input document; 3 are provided:</p>
<ul dir="auto">
<li><a href="src/validator.jl">StrictBSONValidator</a> - Validates all error cases presented in the <a href="https://github.com/mongodb/specifications/blob/master/source/bson-corpus/bson-corpus.rst">BSON corpus</a>.</li>
<li><a href="src/validator.jl">LightBSONValidator</a> - Validates field lengths against parent scope (document or buffer), to guard against invalid memory access. This is the default validator.</li>
<li><a href="src/validator.jl">UncheckedBSONValidator</a> - Performs no validation.</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="BSONReader(buf, StrictBSONValidator()) # Reader with strict validation
BSONReader(buf, LightBSONValidator())  # Reader with memory protected validation
BSONReader(buf, UncheckedBSONValidator()) # Reader with no validation"><pre><span class="pl-c1">BSONReader</span>(buf, <span class="pl-c1">StrictBSONValidator</span>()) <span class="pl-c"><span class="pl-c">#</span> Reader with strict validation</span>
<span class="pl-c1">BSONReader</span>(buf, <span class="pl-c1">LightBSONValidator</span>())  <span class="pl-c"><span class="pl-c">#</span> Reader with memory protected validation</span>
<span class="pl-c1">BSONReader</span>(buf, <span class="pl-c1">UncheckedBSONValidator</span>()) <span class="pl-c"><span class="pl-c">#</span> Reader with no validation</span></pre></div>
<h2 dir="auto"><a id="user-content-structs" class="anchor" aria-hidden="true" href="#structs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Structs</h2>
<p dir="auto">Structs can be automatically translated to and from BSON, provided all their fields can be represented in BSON. Traits functions are used to select the mode of conversion, and these serve as an extension point for user defined types.</p>
<ul dir="auto">
<li><code>bson_simple(T)::Bool</code> - Set this to true if fields to be serialized are given by <code>fieldnames(T)</code> and <code>T</code> can be constructed by fields in order of declaration. Defaults to <code>StructTypes.StructType(T) == StructTypes.NoStructType()</code>.</li>
</ul>
<h3 dir="auto"><a id="user-content-generic" class="anchor" aria-hidden="true" href="#generic"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Generic</h3>
<p dir="auto">Provided <code>bson_simple(T)</code> is false, serialization will use the <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> API to iterate fields of <code>T</code> and to construct <code>T</code>. See <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> for more details.</p>
<h3 dir="auto"><a id="user-content-simple" class="anchor" aria-hidden="true" href="#simple"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simple</h3>
<p dir="auto">For simple types using the <code>bson_simple(T)</code> trait will generate faster serialization code. This needs only be explicitly set if <code>StructTypes.StructType(T)</code> is also defined.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct NestedSimple
    a::Int64
    b::Float64
end

struct Simple
    x::String
    y::NestedSimple
end

StructTypes.StructType(::Type{Simple}) = StructTypes.Struct()
LightBSON.bson_simple(::Type{Simple}) = true

buf = UInt8[]
writer = BSONWriter(buf)
writer[&quot;simple&quot;] = Simple(&quot;foo&quot;, NestedSimple(123, 1.25))
close(writer)
reader = BSONReader(buf)
reader[&quot;simple&quot;][Simple] # Simple(&quot;foo&quot;, NestedSimple(123, 1.25))

# Structs can also be written to the root of the document
buf = UInt8[]
writer = BSONWriter(buf)
writer[] = Simple(&quot;foo&quot;, NestedSimple(123, 1.25))
close(writer)
reader = BSONReader(buf)
reader[Simple] # Simple(&quot;foo&quot;, NestedSimple(123, 1.25))"><pre><span class="pl-k">struct</span> NestedSimple
    a<span class="pl-k">::</span><span class="pl-c1">Int64</span>
    b<span class="pl-k">::</span><span class="pl-c1">Float64</span>
<span class="pl-k">end</span>

<span class="pl-k">struct</span> Simple
    x<span class="pl-k">::</span><span class="pl-c1">String</span>
    y<span class="pl-k">::</span><span class="pl-c1">NestedSimple</span>
<span class="pl-k">end</span>

StructTypes<span class="pl-k">.</span><span class="pl-en">StructType</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Simple}</span>) <span class="pl-k">=</span> StructTypes<span class="pl-k">.</span><span class="pl-c1">Struct</span>()
LightBSON<span class="pl-k">.</span><span class="pl-en">bson_simple</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Simple}</span>) <span class="pl-k">=</span> <span class="pl-c1">true</span>

buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>simple<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Simple</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">NestedSimple</span>(<span class="pl-c1">123</span>, <span class="pl-c1">1.25</span>))
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-s"><span class="pl-pds">"</span>simple<span class="pl-pds">"</span></span>][Simple] <span class="pl-c"><span class="pl-c">#</span> Simple("foo", NestedSimple(123, 1.25))</span>

<span class="pl-c"><span class="pl-c">#</span> Structs can also be written to the root of the document</span>
buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[] <span class="pl-k">=</span> <span class="pl-c1">Simple</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">NestedSimple</span>(<span class="pl-c1">123</span>, <span class="pl-c1">1.25</span>))
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[Simple] <span class="pl-c"><span class="pl-c">#</span> Simple("foo", NestedSimple(123, 1.25))</span></pre></div>
<h3 dir="auto"><a id="user-content-schema-evolution" class="anchor" aria-hidden="true" href="#schema-evolution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Schema Evolution</h3>
<p dir="auto">For long term persistence or long lived APIs, it may be advisable to encode information about schema versions in documents, and implement ways to evolve schemas through time. Specific strategies for schema evolution are beyond the scope of this package to advise or impose, rather extension points are provided for users to implement the mechanisms best fit to their use cases.</p>
<ul dir="auto">
<li><code>bson_schema_version(T)</code> -  The current schema version for <code>T</code>, can be any BSON compatible type, or <code>nothing</code> if <code>T</code> is unversioned. Defaults to <code>nothing</code>.</li>
<li><code>bson_schema_version_field(T)</code> - The field name to use in the BSON document for storing the schema version. Defaults to <code>"_v"</code>.</li>
<li><code>bson_read_versioned(T, v, reader)</code> - Handle version <code>v</code> with respect to current version of <code>T</code> and read <code>T</code> from <code>reader</code>. Defaults to error if the schema versions are mismatched, and otherwise read as-if unversioned.</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct Evolving1
    x::Int64
end

LightBSON.bson_schema_version(::Type{Evolving1}) = Int32(1)

struct Evolving2
    x::Int64
    y::Float64
end

# Construct from old version, defaulting new fields
Evolving2(old::Evolving1) = Evolving2(old.x, NaN)

LightBSON.bson_schema_version(::Type{Evolving2}) = Int32(2)

function LightBSON.bson_read_versioned(::Type{Evolving2}, v::Int32, reader::AbstractBSONReader)
    if v == 1
        Evolving2(bson_read_unversioned(Evolving1, reader))
    elseif v == 2
        bson_read_unversioned(Evolving2, reader)
    else
        # Real world application may instead want a mechanism to allow forward compatibility,
        # e.g., by encoding breaking vs non-breaking change info in the version
        error(&quot;Unsupported schema version $v for Evolving&quot;)
    end
end

const Evolving = Evolving2

buf = UInt8[]
writer = BSONWriter(buf)
# Write old version
writer[] = Evolving1(123)
close(writer)
reader = BSONReader(buf)
# Read as new version
reader[Evolving] # Evolving2(123, NaN)"><pre><span class="pl-k">struct</span> Evolving1
    x<span class="pl-k">::</span><span class="pl-c1">Int64</span>
<span class="pl-k">end</span>

LightBSON<span class="pl-k">.</span><span class="pl-en">bson_schema_version</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Evolving1}</span>) <span class="pl-k">=</span> <span class="pl-c1">Int32</span>(<span class="pl-c1">1</span>)

<span class="pl-k">struct</span> Evolving2
    x<span class="pl-k">::</span><span class="pl-c1">Int64</span>
    y<span class="pl-k">::</span><span class="pl-c1">Float64</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Construct from old version, defaulting new fields</span>
<span class="pl-en">Evolving2</span>(old<span class="pl-k">::</span><span class="pl-c1">Evolving1</span>) <span class="pl-k">=</span> <span class="pl-c1">Evolving2</span>(old<span class="pl-k">.</span>x, <span class="pl-c1">NaN</span>)

LightBSON<span class="pl-k">.</span><span class="pl-en">bson_schema_version</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Evolving2}</span>) <span class="pl-k">=</span> <span class="pl-c1">Int32</span>(<span class="pl-c1">2</span>)

<span class="pl-k">function</span> LightBSON<span class="pl-k">.</span><span class="pl-en">bson_read_versioned</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Evolving2}</span>, v<span class="pl-k">::</span><span class="pl-c1">Int32</span>, reader<span class="pl-k">::</span><span class="pl-c1">AbstractBSONReader</span>)
    <span class="pl-k">if</span> v <span class="pl-k">==</span> <span class="pl-c1">1</span>
        <span class="pl-c1">Evolving2</span>(<span class="pl-c1">bson_read_unversioned</span>(Evolving1, reader))
    <span class="pl-k">elseif</span> v <span class="pl-k">==</span> <span class="pl-c1">2</span>
        <span class="pl-c1">bson_read_unversioned</span>(Evolving2, reader)
    <span class="pl-k">else</span>
        <span class="pl-c"><span class="pl-c">#</span> Real world application may instead want a mechanism to allow forward compatibility,</span>
        <span class="pl-c"><span class="pl-c">#</span> e.g., by encoding breaking vs non-breaking change info in the version</span>
        <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Unsupported schema version <span class="pl-v">$v</span> for Evolving<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">const</span> Evolving <span class="pl-k">=</span> Evolving2

buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
<span class="pl-c"><span class="pl-c">#</span> Write old version</span>
writer[] <span class="pl-k">=</span> <span class="pl-c1">Evolving1</span>(<span class="pl-c1">123</span>)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
<span class="pl-c"><span class="pl-c">#</span> Read as new version</span>
reader[Evolving] <span class="pl-c"><span class="pl-c">#</span> Evolving2(123, NaN)</span></pre></div>
<h2 dir="auto"><a id="user-content-named-tuples" class="anchor" aria-hidden="true" href="#named-tuples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Named Tuples</h2>
<p dir="auto">Named tuples can be read and written like any struct type.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = UInt8[]
writer = BSONWriter(buf)
writer[] = (; x = &quot;foo&quot;, y = 1.25, z = (; a = Int64(123), b = Int64(456)))
close(writer)
reader = BSONReader(buf)
reader[@NamedTuple{x::String, y::Float64, z::@NamedTuple{a::Int64, b::Int64}}] # (x = &quot;foo&quot;, y = 1.25, z = (a = 123, b = 456))"><pre>buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[] <span class="pl-k">=</span> (; x <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, y <span class="pl-k">=</span> <span class="pl-c1">1.25</span>, z <span class="pl-k">=</span> (; a <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">123</span>), b <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">456</span>)))
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-c1">@NamedTuple</span>{x<span class="pl-k">::</span><span class="pl-c1">String</span>, y<span class="pl-k">::</span><span class="pl-c1">Float64</span>, z<span class="pl-k">:</span>:<span class="pl-c1">@NamedTuple</span>{a<span class="pl-k">::</span><span class="pl-c1">Int64</span>, b<span class="pl-k">::</span><span class="pl-c1">Int64</span>}}] <span class="pl-c"><span class="pl-c">#</span> (x = "foo", y = 1.25, z = (a = 123, b = 456))</span></pre></div>
<h2 dir="auto"><a id="user-content-faster-buffer" class="anchor" aria-hidden="true" href="#faster-buffer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Faster Buffer</h2>
<p dir="auto">Since <a href="src/writer.jl">BSONWriter</a> itself is immutable, it makes frequent calls to resize the underlying array to track the write head position. Unfortunately at present, this is not a well optimized operation in Julia, resolving to C-calls for manipulating the state of the array.</p>
<p dir="auto"><a href="src/write_buffer.jl">BSONWriteBuffer</a> wraps a <code>Vector{UInt8}</code> to track size purely in Julia and avoid most of these calls. It implements the minimum API necessary for use with <a href="src/reader.jl">BSONReader</a> and <a href="src/writer.jl">BSONWriter</a>, and is not for use as a general <code>Array</code> implementation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buf = BSONWriteBuffer()
writer = BSONWriter(buf)
writer[&quot;x&quot;] = Int64(123)
close(writer)
reader = BSONReader(buf)
reader[&quot;x&quot;][Int64] # 123
buf.data # Underlying array, may be longer than length(buf)"><pre>buf <span class="pl-k">=</span> <span class="pl-c1">BSONWriteBuffer</span>()
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">123</span>)
<span class="pl-c1">close</span>(writer)
reader <span class="pl-k">=</span> <span class="pl-c1">BSONReader</span>(buf)
reader[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>][Int64] <span class="pl-c"><span class="pl-c">#</span> 123</span>
buf<span class="pl-k">.</span>data <span class="pl-c"><span class="pl-c">#</span> Underlying array, may be longer than length(buf)</span></pre></div>
<h2 dir="auto"><a id="user-content-performance" class="anchor" aria-hidden="true" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance</h2>
<p dir="auto">Performance naturally will depend very much on the nature of data being processed. The main overarching goal with this package is to enable the highest possible performance where the user requires it and is willing to sacrifice some convenience to achieve their target.</p>
<p dir="auto">General advice for high performance BSON schema, such as short field names, avoiding long arrays or documents, and using nesting to reduce search complexity, all apply.</p>
<p dir="auto">For <a href="#LightBSON">LightBSON.jl</a> specifically, prefer strings over symbols for field names, use unsafe variants rather than allocating strings and buffers where possible, reuse buffers and indexes, use <a href="src/write_buffer.jl">BSONWriteBuffer</a> rather than plain <code>Vector{UInt8}</code>, and enable <code>bson_simple(T)</code> for all applicable types.</p>
<p dir="auto">Here's an example benchmark, reading and writing a named tuple with nesting (run on a Ryzen 5950X).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = (;
    f1 = 1.25,
    f2 = Int64(123),
    f3 = now(UTC),
    f4 = true,
    f5 = Int32(456),
    f6 = d128&quot;1.2&quot;,
    f7 = (; x = uuid4(), y = 2.5)
)

@btime begin
    buf = $(UInt8[])
    empty!(buf)
    writer = BSONWriter(buf)
    writer[] = $x
    close(writer)
end # 78.730 ns (0 allocations: 0 bytes)

@btime begin
    buf = $(BSONWriteBuffer())
    empty!(buf)
    writer = BSONWriter(buf)
    writer[] = $x
    close(writer)
end # 58.303 ns (0 allocations: 0 bytes)

buf = UInt8[]
writer = BSONWriter(buf)
writer[] = x
close(writer)
@btime BSONReader($buf)[$(typeof(x))] # 103.825 ns (0 allocations: 0 bytes)
@btime BSONReader($buf, UncheckedBSONValidator())[$(typeof(x))] # 102.549 ns (0 allocations: 0 bytes)
@btime IndexedBSONReader($(BSONIndex(128)), BSONReader($buf))[$(typeof(x))] # 86.876 ns (0 allocations: 0 bytes)
@btime IndexedBSONReader($(BSONIndex(128)), BSONReader($buf, UncheckedBSONValidator()))[$(typeof(x))] # 84.987 ns (0 allocations: 0 bytes)
@btime IndexedBSONReader($(BSONIndex(128)), BSONReader($buf)) # 47.896 ns (0 allocations: 0 bytes)
@btime $(IndexedBSONReader(BSONIndex(128), BSONReader(buf)))[$(typeof(x))] # 41.434 ns (0 allocations: 0 bytes)"><pre>x <span class="pl-k">=</span> (;
    f1 <span class="pl-k">=</span> <span class="pl-c1">1.25</span>,
    f2 <span class="pl-k">=</span> <span class="pl-c1">Int64</span>(<span class="pl-c1">123</span>),
    f3 <span class="pl-k">=</span> <span class="pl-c1">now</span>(UTC),
    f4 <span class="pl-k">=</span> <span class="pl-c1">true</span>,
    f5 <span class="pl-k">=</span> <span class="pl-c1">Int32</span>(<span class="pl-c1">456</span>),
    f6 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">d128</span>"</span>1.2<span class="pl-pds">"</span></span>,
    f7 <span class="pl-k">=</span> (; x <span class="pl-k">=</span> <span class="pl-c1">uuid4</span>(), y <span class="pl-k">=</span> <span class="pl-c1">2.5</span>)
)

<span class="pl-c1">@btime</span> <span class="pl-k">begin</span>
    buf <span class="pl-k">=</span> <span class="pl-k">$</span>(UInt8[])
    <span class="pl-c1">empty!</span>(buf)
    writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
    writer[] <span class="pl-k">=</span> <span class="pl-k">$</span>x
    <span class="pl-c1">close</span>(writer)
<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> 78.730 ns (0 allocations: 0 bytes)</span>

<span class="pl-c1">@btime</span> <span class="pl-k">begin</span>
    buf <span class="pl-k">=</span> <span class="pl-k">$</span>(<span class="pl-c1">BSONWriteBuffer</span>())
    <span class="pl-c1">empty!</span>(buf)
    writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
    writer[] <span class="pl-k">=</span> <span class="pl-k">$</span>x
    <span class="pl-c1">close</span>(writer)
<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> 58.303 ns (0 allocations: 0 bytes)</span>

buf <span class="pl-k">=</span> UInt8[]
writer <span class="pl-k">=</span> <span class="pl-c1">BSONWriter</span>(buf)
writer[] <span class="pl-k">=</span> x
<span class="pl-c1">close</span>(writer)
<span class="pl-c1">@btime</span> <span class="pl-c1">BSONReader</span>(<span class="pl-k">$</span>buf)[<span class="pl-k">$</span>(<span class="pl-c1">typeof</span>(x))] <span class="pl-c"><span class="pl-c">#</span> 103.825 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">BSONReader</span>(<span class="pl-k">$</span>buf, <span class="pl-c1">UncheckedBSONValidator</span>())[<span class="pl-k">$</span>(<span class="pl-c1">typeof</span>(x))] <span class="pl-c"><span class="pl-c">#</span> 102.549 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">IndexedBSONReader</span>(<span class="pl-k">$</span>(<span class="pl-c1">BSONIndex</span>(<span class="pl-c1">128</span>)), <span class="pl-c1">BSONReader</span>(<span class="pl-k">$</span>buf))[<span class="pl-k">$</span>(<span class="pl-c1">typeof</span>(x))] <span class="pl-c"><span class="pl-c">#</span> 86.876 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">IndexedBSONReader</span>(<span class="pl-k">$</span>(<span class="pl-c1">BSONIndex</span>(<span class="pl-c1">128</span>)), <span class="pl-c1">BSONReader</span>(<span class="pl-k">$</span>buf, <span class="pl-c1">UncheckedBSONValidator</span>()))[<span class="pl-k">$</span>(<span class="pl-c1">typeof</span>(x))] <span class="pl-c"><span class="pl-c">#</span> 84.987 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">IndexedBSONReader</span>(<span class="pl-k">$</span>(<span class="pl-c1">BSONIndex</span>(<span class="pl-c1">128</span>)), <span class="pl-c1">BSONReader</span>(<span class="pl-k">$</span>buf)) <span class="pl-c"><span class="pl-c">#</span> 47.896 ns (0 allocations: 0 bytes)</span>
<span class="pl-c1">@btime</span> <span class="pl-k">$</span>(<span class="pl-c1">IndexedBSONReader</span>(<span class="pl-c1">BSONIndex</span>(<span class="pl-c1">128</span>), <span class="pl-c1">BSONReader</span>(buf)))[<span class="pl-k">$</span>(<span class="pl-c1">typeof</span>(x))] <span class="pl-c"><span class="pl-c">#</span> 41.434 ns (0 allocations: 0 bytes)</span></pre></div>
<p dir="auto">We can observe <a href="src/write_buffer.jl">BSONWriteBuffer</a> makes a material difference to write performance, while indexing, in this case, has a reasonable effect on read performance even for this small document. In the final two lines we can see that indexing and reading the indexed document breaks down roughly half/half. Using the unchecked validator has a smaller impact, and must be used with caution.</p>
<h2 dir="auto"><a id="user-content-objectid" class="anchor" aria-hidden="true" href="#objectid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ObjectId</h2>
<p dir="auto"><a href="src/object_id.jl">BSONObjectId</a> implements the BSON ObjectId type in accordance with the <a href="https://github.com/mongodb/specifications/blob/master/source/objectid.rst">spec</a>. New IDs for the process can be generated by construction, or using <code>bson_object_id_range(n)</code> for more efficient batch generation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="id1 = BSONObjectId()
DateTime(id1) # The UTC timestamp for when id1 was generated, truncated to seconds
id2 = BSONObjectId()
id1 != id2 # true, IDs are unique
collect(bson_object_id_range(5)) # 5 IDs with equal timestamp and different sequence field"><pre>id1 <span class="pl-k">=</span> <span class="pl-c1">BSONObjectId</span>()
<span class="pl-c1">DateTime</span>(id1) <span class="pl-c"><span class="pl-c">#</span> The UTC timestamp for when id1 was generated, truncated to seconds</span>
id2 <span class="pl-k">=</span> <span class="pl-c1">BSONObjectId</span>()
id1 <span class="pl-k">!=</span> id2 <span class="pl-c"><span class="pl-c">#</span> true, IDs are unique</span>
<span class="pl-c1">collect</span>(<span class="pl-c1">bson_object_id_range</span>(<span class="pl-c1">5</span>)) <span class="pl-c"><span class="pl-c">#</span> 5 IDs with equal timestamp and different sequence field</span></pre></div>
<h2 dir="auto"><a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related Packages</h2>
<ul dir="auto">
<li><a href="https://github.com/JuliaIO/BSON.jl">BSON.jl</a> - Generic serialization of all Julia types to and from BSON.</li>
<li><a href="https://github.com/felipenoris/Mongoc.jl">Mongoc.jl</a> - Julia MongoDB client.</li>
<li><a href="https://github.com/JuliaMath/DecFP.jl">DecFP.jl</a> - Provides the <code>Dec128</code> type used for BSON <code>decimal128</code> fields.</li>
<li><a href="https://github.com/JuliaFolds/Transducers.jl">Transducers.jl</a> - Data iteration and transformation API.</li>
<li><a href="https://github.com/JuliaData/WeakRefStrings.jl">WeakRefStrings.jl</a> - Pointer based strings.</li>
<li><a href="https://github.com/JuliaArrays/UnsafeArrays.jl">UnsafeArrays.jl</a> - Pointer based arrays.</li>
<li><a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> - Serialization traits and utilities for user defined structures.</li>
</ul>
</article></div>