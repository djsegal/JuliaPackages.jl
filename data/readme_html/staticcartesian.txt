<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-staticcartesianjl" class="anchor" aria-hidden="true" href="#staticcartesianjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>StaticCartesian.jl</h1>
<p dir="auto">Proof-of-concept package exploring the advantages of statically-known Cartesian iterators.</p>
<h2 dir="auto"><a id="user-content-motivation" class="anchor" aria-hidden="true" href="#motivation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Motivation</h2>
<p dir="auto">Currently, indexing a <code>CartesianIndices</code> object with a linear index performs an integer
division:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; CartesianIndices((2, 3))

julia&gt; @code_llvm debuginfo=:none Is[1]"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">CartesianIndices</span>((<span class="pl-c1">2</span>, <span class="pl-c1">3</span>))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@code_llvm</span> debuginfo<span class="pl-k">=</span><span class="pl-c1">:none</span> Is[<span class="pl-c1">1</span>]</pre></div>
<div class="highlight highlight-source-llvm notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="define void @julia_getindex_137([1 x [2 x i64]]* noalias nocapture sret([1 x [2 x i64]]) %0, [1 x [2 x [1 x i64]]]* nocapture nonnull readonly align 8 dereferenceable(16) %1, i64 signext %2) #0 {
top:
  ...
  %17 = add nsw i64 %2, -1
  %18 = udiv i64 %17, %7
  %19 = mul i64 %18, %7
  %20 = sub i64 %2, %19
  %21 = add nuw nsw i64 %18, 1
  ...
  ret void
}"><pre><span class="pl-k">define</span> <span class="pl-k">void</span> <span class="pl-c1">@julia_getindex_137</span>([<span class="pl-c1">1</span> x [<span class="pl-c1">2</span> x <span class="pl-k">i64</span>]]* <span class="pl-k">noalias</span> <span class="pl-k">nocapture</span> <span class="pl-k">sret</span>([<span class="pl-c1">1</span> x [<span class="pl-c1">2</span> x <span class="pl-k">i64</span>]]) <span class="pl-c1">%0</span>, [<span class="pl-c1">1</span> x [<span class="pl-c1">2</span> x [<span class="pl-c1">1</span> x <span class="pl-k">i64</span>]]]* <span class="pl-k">nocapture</span> <span class="pl-k">nonnull</span> <span class="pl-k">readonly</span> <span class="pl-k">align</span> <span class="pl-c1">8</span> <span class="pl-k">dereferenceable</span>(<span class="pl-c1">16</span>) <span class="pl-c1">%1</span>, <span class="pl-k">i64</span> <span class="pl-k">signext</span> <span class="pl-c1">%2</span>) #<span class="pl-c1">0</span> {
top:
  ...
  <span class="pl-c1">%17</span> = <span class="pl-k">add</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%2</span>, -<span class="pl-c1">1</span>
  <span class="pl-c1">%18</span> = <span class="pl-k">udiv</span> <span class="pl-k">i64</span> <span class="pl-c1">%17</span>, <span class="pl-c1">%7</span>
  <span class="pl-c1">%19</span> = <span class="pl-k">mul</span> <span class="pl-k">i64</span> <span class="pl-c1">%18</span>, <span class="pl-c1">%7</span>
  <span class="pl-c1">%20</span> = <span class="pl-k">sub</span> <span class="pl-k">i64</span> <span class="pl-c1">%2</span>, <span class="pl-c1">%19</span>
  <span class="pl-c1">%21</span> = <span class="pl-k">add</span> <span class="pl-k">nuw</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%18</span>, <span class="pl-c1">1</span>
  ...
  <span class="pl-k">ret</span> <span class="pl-k">void</span>
}</pre></div>
<p dir="auto">On some platforms (notably GPUs) this is a very expensive operation. To avoid such
operations, this package provides the <code>StaticCartesianIndices</code> type that puts the iterator's
indices in the type domain so that they are known at compile time. This information can then
be used to avoid the integer division, as division by a constant can be expressed as a
series of bit operations:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @code_llvm debuginfo=:none StaticCartesian.fast_fldmod(100, Val(7))"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@code_llvm</span> debuginfo<span class="pl-k">=</span><span class="pl-c1">:none</span> StaticCartesian<span class="pl-k">.</span><span class="pl-c1">fast_fldmod</span>(<span class="pl-c1">100</span>, <span class="pl-c1">Val</span>(<span class="pl-c1">7</span>))</pre></div>
<div class="highlight highlight-source-llvm notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="define void @julia_fast_fldmod_300([2 x i64]* noalias nocapture sret([2 x i64]) %0, i64 signext %1) #0 {
top:
  ; mulhi
  %2 = and i64 %1, 4294967295
  %3 = ashr i64 %1, 32
  %4 = mul nuw nsw i64 %2, 613566757
  %5 = mul nsw i64 %3, 613566757
  %6 = lshr i64 %4, 32
  %7 = add nsw i64 %6, %5
  %8 = and i64 %7, 4294967295
  %9 = ashr i64 %7, 32
  %10 = mul nuw nsw i64 %2, 1227133513
  %11 = add nuw nsw i64 %8, %10
  %12 = mul nsw i64 %3, 1227133513
  %13 = lshr i64 %11, 32
  %14 = add nsw i64 %9, %12
  %15 = add nsw i64 %14, %13

  ; fldmod
  %16 = ashr i64 %15, 1
  %.lobit = lshr i64 %1, 63
  %value_phi = add nsw i64 %16, %.lobit
  %.neg = mul i64 %value_phi, -7
  %17 = add i64 %.neg, %1
  %.not = icmp eq i64 %17, 0
  %.not7 = icmp sgt i64 %1, -1
  %or.cond = or i1 %.not7, %.not
  %18 = add i64 %17, 7
  %value_phi1 = select i1 %or.cond, i64 %17, i64 %18
  %not.or.cond = xor i1 %or.cond, true
  %19 = sext i1 %not.or.cond to i64
  %value_phi2 = add nsw i64 %value_phi, %19
  %.sroa.0.0..sroa_idx = getelementptr inbounds [2 x i64], [2 x i64]* %0, i64 0, i64 0
  store i64 %value_phi2, i64* %.sroa.0.0..sroa_idx, align 8
  %.sroa.2.0..sroa_idx3 = getelementptr inbounds [2 x i64], [2 x i64]* %0, i64 0, i64 1
  store i64 %value_phi1, i64* %.sroa.2.0..sroa_idx3, align 8
  ret void
}"><pre><span class="pl-k">define</span> <span class="pl-k">void</span> <span class="pl-c1">@julia_fast_fldmod_300</span>([<span class="pl-c1">2</span> x <span class="pl-k">i64</span>]* <span class="pl-k">noalias</span> <span class="pl-k">nocapture</span> <span class="pl-k">sret</span>([<span class="pl-c1">2</span> x <span class="pl-k">i64</span>]) <span class="pl-c1">%0</span>, <span class="pl-k">i64</span> <span class="pl-k">signext</span> <span class="pl-c1">%1</span>) #<span class="pl-c1">0</span> {
top:
  <span class="pl-c">; mulhi</span>
  <span class="pl-c1">%2</span> = <span class="pl-k">and</span> <span class="pl-k">i64</span> <span class="pl-c1">%1</span>, <span class="pl-c1">4294967295</span>
  <span class="pl-c1">%3</span> = <span class="pl-k">ashr</span> <span class="pl-k">i64</span> <span class="pl-c1">%1</span>, <span class="pl-c1">32</span>
  <span class="pl-c1">%4</span> = <span class="pl-k">mul</span> <span class="pl-k">nuw</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%2</span>, <span class="pl-c1">613566757</span>
  <span class="pl-c1">%5</span> = <span class="pl-k">mul</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%3</span>, <span class="pl-c1">613566757</span>
  <span class="pl-c1">%6</span> = <span class="pl-k">lshr</span> <span class="pl-k">i64</span> <span class="pl-c1">%4</span>, <span class="pl-c1">32</span>
  <span class="pl-c1">%7</span> = <span class="pl-k">add</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%6</span>, <span class="pl-c1">%5</span>
  <span class="pl-c1">%8</span> = <span class="pl-k">and</span> <span class="pl-k">i64</span> <span class="pl-c1">%7</span>, <span class="pl-c1">4294967295</span>
  <span class="pl-c1">%9</span> = <span class="pl-k">ashr</span> <span class="pl-k">i64</span> <span class="pl-c1">%7</span>, <span class="pl-c1">32</span>
  <span class="pl-c1">%10</span> = <span class="pl-k">mul</span> <span class="pl-k">nuw</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%2</span>, <span class="pl-c1">1227133513</span>
  <span class="pl-c1">%11</span> = <span class="pl-k">add</span> <span class="pl-k">nuw</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%8</span>, <span class="pl-c1">%10</span>
  <span class="pl-c1">%12</span> = <span class="pl-k">mul</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%3</span>, <span class="pl-c1">1227133513</span>
  <span class="pl-c1">%13</span> = <span class="pl-k">lshr</span> <span class="pl-k">i64</span> <span class="pl-c1">%11</span>, <span class="pl-c1">32</span>
  <span class="pl-c1">%14</span> = <span class="pl-k">add</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%9</span>, <span class="pl-c1">%12</span>
  <span class="pl-c1">%15</span> = <span class="pl-k">add</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%14</span>, <span class="pl-c1">%13</span>

  <span class="pl-c">; fldmod</span>
  <span class="pl-c1">%16</span> = <span class="pl-k">ashr</span> <span class="pl-k">i64</span> <span class="pl-c1">%15</span>, <span class="pl-c1">1</span>
  <span class="pl-c1">%.lobit</span> = <span class="pl-k">lshr</span> <span class="pl-k">i64</span> <span class="pl-c1">%1</span>, <span class="pl-c1">63</span>
  <span class="pl-c1">%value_phi</span> = <span class="pl-k">add</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%16</span>, <span class="pl-c1">%.lobit</span>
  <span class="pl-c1">%.neg</span> = <span class="pl-k">mul</span> <span class="pl-k">i64</span> <span class="pl-c1">%value_phi</span>, -<span class="pl-c1">7</span>
  <span class="pl-c1">%17</span> = <span class="pl-k">add</span> <span class="pl-k">i64</span> <span class="pl-c1">%.neg</span>, <span class="pl-c1">%1</span>
  <span class="pl-c1">%.not</span> = <span class="pl-k">icmp</span> <span class="pl-k">eq</span> <span class="pl-k">i64</span> <span class="pl-c1">%17</span>, <span class="pl-c1">0</span>
  <span class="pl-c1">%.not7</span> = <span class="pl-k">icmp</span> <span class="pl-k">sgt</span> <span class="pl-k">i64</span> <span class="pl-c1">%1</span>, -<span class="pl-c1">1</span>
  <span class="pl-c1">%or.cond</span> = <span class="pl-k">or</span> <span class="pl-k">i1</span> <span class="pl-c1">%.not7</span>, <span class="pl-c1">%.not</span>
  <span class="pl-c1">%18</span> = <span class="pl-k">add</span> <span class="pl-k">i64</span> <span class="pl-c1">%17</span>, <span class="pl-c1">7</span>
  <span class="pl-c1">%value_phi1</span> = <span class="pl-k">select</span> <span class="pl-k">i1</span> <span class="pl-c1">%or.cond</span>, <span class="pl-k">i64</span> <span class="pl-c1">%17</span>, <span class="pl-k">i64</span> <span class="pl-c1">%18</span>
  <span class="pl-c1">%not.or.cond</span> = <span class="pl-k">xor</span> <span class="pl-k">i1</span> <span class="pl-c1">%or.cond</span>, <span class="pl-k">true</span>
  <span class="pl-c1">%19</span> = <span class="pl-k">sext</span> <span class="pl-k">i1</span> <span class="pl-c1">%not.or.cond</span> <span class="pl-k">to</span> <span class="pl-k">i64</span>
  <span class="pl-c1">%value_phi2</span> = <span class="pl-k">add</span> <span class="pl-k">nsw</span> <span class="pl-k">i64</span> <span class="pl-c1">%value_phi</span>, <span class="pl-c1">%19</span>
  <span class="pl-c1">%.sroa.0.0..sroa_idx</span> = <span class="pl-k">getelementptr</span> <span class="pl-k">inbounds</span> [<span class="pl-c1">2</span> x <span class="pl-k">i64</span>], [<span class="pl-c1">2</span> x <span class="pl-k">i64</span>]* <span class="pl-c1">%0</span>, <span class="pl-k">i64</span> <span class="pl-c1">0</span>, <span class="pl-k">i64</span> <span class="pl-c1">0</span>
  <span class="pl-k">store</span> <span class="pl-k">i64</span> <span class="pl-c1">%value_phi2</span>, <span class="pl-k">i64*</span> <span class="pl-c1">%.sroa.0.0..sroa_idx</span>, <span class="pl-k">align</span> <span class="pl-c1">8</span>
  <span class="pl-c1">%.sroa.2.0..sroa_idx3</span> = <span class="pl-k">getelementptr</span> <span class="pl-k">inbounds</span> [<span class="pl-c1">2</span> x <span class="pl-k">i64</span>], [<span class="pl-c1">2</span> x <span class="pl-k">i64</span>]* <span class="pl-c1">%0</span>, <span class="pl-k">i64</span> <span class="pl-c1">0</span>, <span class="pl-k">i64</span> <span class="pl-c1">1</span>
  <span class="pl-k">store</span> <span class="pl-k">i64</span> <span class="pl-c1">%value_phi1</span>, <span class="pl-k">i64*</span> <span class="pl-c1">%.sroa.2.0..sroa_idx3</span>, <span class="pl-k">align</span> <span class="pl-c1">8</span>
  <span class="pl-k">ret</span> <span class="pl-k">void</span>
}</pre></div>
<p dir="auto">Ideally LLVM would be able to perform this operation, but it currently does not.</p>
<p dir="auto">Note that much of the code above originates from the <code>mulhi</code> function, which computes the
upper bits of a wide multiplication. On some platforms (again, GPUs) this operation can be
performed using a single instuction, further reducing the cost of the division.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using StaticCartesian

obj = rand(2, 2)    # whatever you want to index

function expensive_computation(obj, Is)
    i = rand(1:length(obj)) # get an actual index here, e.g., CUDA.threadIdx()
    I = Is[i]
    @inbounds obj[I]
end

# pass the iterator to the function so that it can get specialized
expensive_computation(obj, StaticCartesianIndices(obj))"><pre><span class="pl-k">using</span> StaticCartesian

obj <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)    <span class="pl-c"><span class="pl-c">#</span> whatever you want to index</span>

<span class="pl-k">function</span> <span class="pl-en">expensive_computation</span>(obj, Is)
    i <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(obj)) <span class="pl-c"><span class="pl-c">#</span> get an actual index here, e.g., CUDA.threadIdx()</span>
    I <span class="pl-k">=</span> Is[i]
    <span class="pl-c1">@inbounds</span> obj[I]
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> pass the iterator to the function so that it can get specialized</span>
<span class="pl-c1">expensive_computation</span>(obj, <span class="pl-c1">StaticCartesianIndices</span>(obj))</pre></div>
<h2 dir="auto"><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgements</h2>
<p dir="auto">The implementation of integer-division-by-constant is based on the <a href="https://en.wikipedia.org/wiki/Hacker%27s_Delight" rel="nofollow">Hacker's
Delight</a> book by Henry S. Warren, Jr.</p>
</article></div>