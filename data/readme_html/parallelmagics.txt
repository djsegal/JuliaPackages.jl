<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-parallelmagics-safe-parallelism-using-compiler-analysis" class="anchor" aria-hidden="true" href="#parallelmagics-safe-parallelism-using-compiler-analysis"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ParallelMagics: Safe parallelism using compiler analysis</h1>
<p dir="auto">ParallelMagics.jl is aiming at providing safe parallelism to Julia programmers such that</p>
<ul dir="auto">
<li>"No-brainer" parallelism using compiler analysis; i.e., the code is parallelized only if
the compiler guarantees the safety.</li>
<li>(Wishlist) Static and dynamic detection of programs that are worth parallelizing.</li>
<li>(Wishlist) Diagnosis mechanisms for understanding and fixing parallelizability of a
program.</li>
</ul>
<p dir="auto">This package is very incomplete.  It is still rather a party trick than a usable library.</p>
<h2 dir="auto"><a id="user-content-demo" class="anchor" aria-hidden="true" href="#demo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Demo</h2>
<p dir="auto">ParallelMagics.jl provides APIs such as <code>ParallelMagics.sum</code> that may auto-parallelize an
invocation.  It also provides a macro <code>@importall</code> that is equivalent to <code>using ParallelMagics: sum, reduce, map, ...</code> to auto-parallelize all supported functions in the
current lexical scope or a REPL session.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using ParallelMagics

julia&gt; ParallelMagics.@importall  # Use ParallelMagics's version of `sum` etc.

julia&gt; sum === ParallelMagics.sum
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> ParallelMagics

julia<span class="pl-k">&gt;</span> ParallelMagics<span class="pl-k">.</span><span class="pl-c1">@importall</span>  <span class="pl-c"><span class="pl-c">#</span> Use ParallelMagics's version of `sum` etc.</span>

julia<span class="pl-k">&gt;</span> sum <span class="pl-k">===</span> ParallelMagics<span class="pl-k">.</span>sum
<span class="pl-c1">true</span></pre></div>
<p dir="auto">To make it clear when ParallelMagics.jl works, let us enable the remark:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ParallelMagics.enable_remark()"><pre>julia<span class="pl-k">&gt;</span> ParallelMagics<span class="pl-k">.</span><span class="pl-c1">enable_remark</span>()</pre></div>
<p dir="auto">Calling ParallelMagics functions now automagically parallelize function</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; sum(sin, 1:2^20)
[ Info: Auto-parallelized
0.21667559252423674"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(sin, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">20</span>)
[ Info<span class="pl-k">:</span> Auto<span class="pl-k">-</span>parallelized
<span class="pl-c1">0.21667559252423674</span></pre></div>
<p dir="auto">Since SinceParallelMagics.jl uses the compiler analysis, it can "see through" user-defined
functions and iterator comprehensions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; user_defined_function(x) = sin(x);

julia&gt; sum((user_defined_function(x) for x in 1:2^20 if isodd(x)))
[ Info: Auto-parallelized
0.03338891483674633"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">user_defined_function</span>(x) <span class="pl-k">=</span> <span class="pl-c1">sin</span>(x);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>((<span class="pl-c1">user_defined_function</span>(x) <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">20</span> <span class="pl-k">if</span> <span class="pl-c1">isodd</span>(x)))
[ Info<span class="pl-k">:</span> Auto<span class="pl-k">-</span>parallelized
<span class="pl-c1">0.03338891483674633</span></pre></div>
<p dir="auto">ParallelMagics.jl refuses to parallelize an invocation of its API if the compiler cannot
prove that the functions for computing the result and accessing the objects provided by the
user are all effect-free.  For example, writing to a global variable is considered
effectful.  Thus, ParallelMagics.jl refuses to call a function that updates a global
variable in parallel:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; EVIL = 0;

julia&gt; sum(1:2^20) do x
           global EVIL += 1
           sin(x)
       end
[ Info: Failed to auto-parallelize
0.2166755925243159"><pre>julia<span class="pl-k">&gt;</span> EVIL <span class="pl-k">=</span> <span class="pl-c1">0</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">20</span>) <span class="pl-k">do</span> x
           <span class="pl-k">global</span> EVIL <span class="pl-k">+=</span> <span class="pl-c1">1</span>
           <span class="pl-c1">sin</span>(x)
       <span class="pl-k">end</span>
[ Info<span class="pl-k">:</span> Failed to auto<span class="pl-k">-</span>parallelize
<span class="pl-c1">0.2166755925243159</span></pre></div>
<p dir="auto">(<strong>Known bug:</strong> Note that the result is different when not parallelized since the
computation tree is different for parallel and sequential implementations at the moment.)</p>
<p dir="auto">ParallelMagics.jl also exports <code>MagicEx</code> executor.  It can be used with various JuliaFolds
packages such as <a href="https://github.com/JuliaFolds/FLoops.jl">FLoops.jl</a>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FLoops
using ParallelMagics

function good(xs)
    @floop MagicEx() for x in xs
        @reduce y += sin(x)
    end
    return y
end

EVIL = 0

function bad(xs)
    @floop MagicEx() for x in xs
        global EVIL += 1
        @reduce y += sin(x)
    end
    return y
end"><pre><span class="pl-k">using</span> FLoops
<span class="pl-k">using</span> ParallelMagics

<span class="pl-k">function</span> <span class="pl-en">good</span>(xs)
    <span class="pl-c1">@floop</span> <span class="pl-c1">MagicEx</span>() <span class="pl-k">for</span> x <span class="pl-k">in</span> xs
        <span class="pl-c1">@reduce</span> y <span class="pl-k">+=</span> <span class="pl-c1">sin</span>(x)
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> y
<span class="pl-k">end</span>

EVIL <span class="pl-k">=</span> <span class="pl-c1">0</span>

<span class="pl-k">function</span> <span class="pl-en">bad</span>(xs)
    <span class="pl-c1">@floop</span> <span class="pl-c1">MagicEx</span>() <span class="pl-k">for</span> x <span class="pl-k">in</span> xs
        <span class="pl-k">global</span> EVIL <span class="pl-k">+=</span> <span class="pl-c1">1</span>
        <span class="pl-c1">@reduce</span> y <span class="pl-k">+=</span> <span class="pl-c1">sin</span>(x)
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> y
<span class="pl-k">end</span></pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; good(1:2^20)
[ Info: Auto-parallelized
0.21667559252423674

julia&gt; bad(1:2^20)
[ Info: Failed to auto-parallelize
0.2166755925243159"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">good</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">20</span>)
[ Info<span class="pl-k">:</span> Auto<span class="pl-k">-</span>parallelized
<span class="pl-c1">0.21667559252423674</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">bad</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">20</span>)
[ Info<span class="pl-k">:</span> Failed to auto<span class="pl-k">-</span>parallelize
<span class="pl-c1">0.2166755925243159</span></pre></div>
<h2 dir="auto"><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgements</h2>
<p dir="auto">This approach heavily relies on the various improvements in the Julia compiler made by Keno
Fischer (ref: <a href="https://github.com/JuliaLang/julia/pull/43852" data-hovercard-type="pull_request" data-hovercard-url="/JuliaLang/julia/pull/43852/hovercard">JuliaLang/julia#43852</a>) and
Shuhei Kadowaki (ref:
<a href="https://github.com/JuliaLang/julia/pull/44822" data-hovercard-type="pull_request" data-hovercard-url="/JuliaLang/julia/pull/44822/hovercard">JuliaLang/julia#44822</a>).</p>
</article></div>