<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-structequality" class="anchor" aria-hidden="true" href="#structequality"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>StructEquality</h1>
<p dir="auto"><a href="https://github.com/jolin-io/StructEquality.jl/actions"><img src="https://github.com/jolin-io/StructEquality.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jolin-io/StructEquality.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ca52ab3f7a0505607587bff92f912be1d9bfa70354c11be6eb17667430ee6b1a/68747470733a2f2f636f6465636f762e696f2f67682f6a6f6c696e2d696f2f537472756374457175616c6974792e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/jolin-io/StructEquality.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">install like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
pkg&quot;add StructEquality&quot;"><pre><span class="pl-k">using</span> Pkg
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">pkg</span>"</span>add StructEquality<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">load like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using StructEquality"><pre><span class="pl-k">using</span> StructEquality</pre></div>
<p dir="auto">which let's you easily define <code>hash</code> and <code>==</code> for your custom struct.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@struct_hash_equal struct MyStruct
  one
  two
end

MyStruct(&quot;1&quot;, [2]) == MyStruct(&quot;1&quot;, [2])  # true"><pre><span class="pl-c1">@struct_hash_equal</span> <span class="pl-k">struct</span> MyStruct
  one
  two
<span class="pl-k">end</span>

<span class="pl-c1">MyStruct</span>(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, [<span class="pl-c1">2</span>]) <span class="pl-k">==</span> <span class="pl-c1">MyStruct</span>(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, [<span class="pl-c1">2</span>])  <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<h2 dir="auto"><a id="user-content-api-overview" class="anchor" aria-hidden="true" href="#api-overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>API Overview</h2>
<table>
<thead>
<tr>
<th>macro</th>
<th>defines ... for your struct</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@struct_hash</code></td>
<td><code>hash</code></td>
</tr>
<tr>
<td><code>@struct_equal</code></td>
<td><code>==</code></td>
</tr>
<tr>
<td><code>@struct_isequal</code></td>
<td><code>isequal</code></td>
</tr>
<tr>
<td><code>@struct_isapprox</code></td>
<td><code>isapprox</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>combined macro</th>
<th>defines ... for your struct</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@struct_hash_equal</code></td>
<td><code>hash</code>, <code>==</code></td>
</tr>
<tr>
<td><code>@struct_hash_equal_isapprox</code></td>
<td><code>hash</code>, <code>==</code>, <code>isapprox</code></td>
</tr>
<tr>
<td><code>@struct_hash_equal_isequal</code></td>
<td><code>hash</code>, <code>==</code>, <code>isequal</code></td>
</tr>
<tr>
<td><code>@struct_hash_equal_isequal_isapprox</code></td>
<td><code>hash</code>, <code>==</code>, <code>isequal</code>, <code>isapprox</code></td>
</tr>
</tbody>
</table>
<p dir="auto">If you don't like macros, you can directly use the underlying generated functions and implement the definitions yourself.</p>
<table>
<thead>
<tr>
<th>generated functions</th>
<th>use for custom implementation like ...</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>struct_hash</code></td>
<td><code>Base.hash(a::YourStructType, h::UInt) = struct_hash(a, h)</code></td>
</tr>
<tr>
<td><code>struct_equal</code></td>
<td><code>Base.:(==)(a::YourStructType, b::YourStructType) = struct_equal(a, b)</code></td>
</tr>
<tr>
<td><code>struct_isequal</code></td>
<td><code>Base.isequal(a::YourStructType, b::YourStructType) = struct_isequal(a, b)</code></td>
</tr>
<tr>
<td><code>struct_isapprox</code></td>
<td><code>Base.isapprox(a::YourStructType, b::YourStructType; kwargs...) = struct_isapprox(a, b; kwargs...)</code></td>
</tr>
</tbody>
</table>
<h2 dir="auto"><a id="user-content-motivation--usage" class="anchor" aria-hidden="true" href="#motivation--usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Motivation &amp; Usage</h2>
<p dir="auto">Struct types have an <code>==</code> implementation by default which uses <code>===</code>, i.e. object identity, on the underlying components, in order to compare structs. (The same holds true for <code>hash</code>, which should always follow the implementation of <code>==</code>)</p>
<p dir="auto">Let's define a struct</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct MyStruct
  a::Int
  b::Vector
end"><pre><span class="pl-k">struct</span> MyStruct
  a<span class="pl-k">::</span><span class="pl-c1">Int</span>
  b<span class="pl-k">::</span><span class="pl-c1">Vector</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">The default <code>==</code> fails to compare two structs with the same content</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="MyStruct(1, [2,3]) == MyStruct(1, [2,3])  # false"><pre><span class="pl-c1">MyStruct</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]) <span class="pl-k">==</span> <span class="pl-c1">MyStruct</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>])  <span class="pl-c"><span class="pl-c">#</span> false</span></pre></div>
<p dir="auto">To fix this use the supplied macro <code>@struct_hash_equal</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@struct_hash_equal MyStruct
MyStruct(1, [2,3]) == MyStruct(1, [2,3])  # true"><pre><span class="pl-c1">@struct_hash_equal</span> MyStruct
<span class="pl-c1">MyStruct</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]) <span class="pl-k">==</span> <span class="pl-c1">MyStruct</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>])  <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<p dir="auto">Alternatively you can use the macro right on struct definition</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@struct_hash_equal struct MyStruct2
  a::Int
  b::Vector
end
MyStruct2(1, [2,3]) == MyStruct2(1, [2,3])  # true"><pre><span class="pl-c1">@struct_hash_equal</span> <span class="pl-k">struct</span> MyStruct2
  a<span class="pl-k">::</span><span class="pl-c1">Int</span>
  b<span class="pl-k">::</span><span class="pl-c1">Vector</span>
<span class="pl-k">end</span>
<span class="pl-c1">MyStruct2</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]) <span class="pl-k">==</span> <span class="pl-c1">MyStruct2</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>])  <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<p dir="auto">You could also merely use <code>@struct_equal</code> instead of <code>@struct_hash_equal</code>, however it is recommended to always implement <code>hash</code> and <code>==</code> together.</p>
<h2 dir="auto"><a id="user-content-implementation" class="anchor" aria-hidden="true" href="#implementation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementation</h2>
<p dir="auto">The implementation uses generated functions, which generate optimal code, specified to your custom struct type.</p>
<p dir="auto">Inspecting the macro with</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@macroexpand @struct_hash_equal MyStruct"><pre><span class="pl-c1">@macroexpand</span> <span class="pl-c1">@struct_hash_equal</span> MyStruct</pre></div>
<p dir="auto">returns the following</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="quote
    Base.hash(a::MyStruct, h::UInt) = begin
        StructEquality.struct_hash(a, h)
    end
    Base.:(==)(a::MyStruct, b::MyStruct) = begin
        StructEquality.struct_equal(a, b)
    end
end"><pre><span class="pl-k">quote</span>
    Base<span class="pl-k">.</span><span class="pl-en">hash</span>(a<span class="pl-k">::</span><span class="pl-c1">MyStruct</span>, h<span class="pl-k">::</span><span class="pl-c1">UInt</span>) <span class="pl-k">=</span> <span class="pl-k">begin</span>
        StructEquality<span class="pl-k">.</span><span class="pl-c1">struct_hash</span>(a, h)
    <span class="pl-k">end</span>
    Base.:(<span class="pl-k">==</span>)(a<span class="pl-k">::</span><span class="pl-c1">MyStruct</span>, b<span class="pl-k">::</span><span class="pl-c1">MyStruct</span>) <span class="pl-k">=</span> <span class="pl-k">begin</span>
        StructEquality<span class="pl-k">.</span><span class="pl-c1">struct_equal</span>(a, b)
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">In order to inspect generated functions, the <code>@code_lowered</code> macro is best.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct MyStruct
  a::Int
  b::Vector
end

@code_lowered struct_equal(MyStruct(1, [2,3]), MyStruct(1, [2,3]))"><pre><span class="pl-k">struct</span> MyStruct
  a<span class="pl-k">::</span><span class="pl-c1">Int</span>
  b<span class="pl-k">::</span><span class="pl-c1">Vector</span>
<span class="pl-k">end</span>

<span class="pl-c1">@code_lowered</span> <span class="pl-c1">struct_equal</span>(<span class="pl-c1">MyStruct</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]), <span class="pl-c1">MyStruct</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]))</pre></div>
<p dir="auto">which returns</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="    @ /path/to/StructEquality/src/StructEquality.jl:15 within `struct_equal`
   ┌ @ /path/to/StructEquality/src/StructEquality.jl within `macro expansion`
1 ─│ %1 = Base.getproperty(e1, :a)
│  │ %2 = Base.getproperty(e2, :a)
│  │ %3 = %1 == %2
└──│      goto #3 if not %3
2 ─│ %5 = Base.getproperty(e1, :b)
│  │ %6 = Base.getproperty(e2, :b)
│  │ %7 = %5 == %6
└──│      return %7
3 ─│      return false
   └
)"><pre>    @ <span class="pl-k">/</span>path<span class="pl-k">/</span>to<span class="pl-k">/</span>StructEquality<span class="pl-k">/</span>src<span class="pl-k">/</span>StructEquality<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">15</span> within <span class="pl-s"><span class="pl-pds">`</span>struct_equal<span class="pl-pds">`</span></span>
   ┌ @ <span class="pl-k">/</span>path<span class="pl-k">/</span>to<span class="pl-k">/</span>StructEquality<span class="pl-k">/</span>src<span class="pl-k">/</span>StructEquality<span class="pl-k">.</span>jl within <span class="pl-s"><span class="pl-pds">`</span>macro expansion<span class="pl-pds">`</span></span>
<span class="pl-c1">1</span> ─│ <span class="pl-k">%</span><span class="pl-c1">1</span> <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">getproperty</span>(e1, <span class="pl-c1">:a</span>)
│  │ <span class="pl-k">%</span><span class="pl-c1">2</span> <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">getproperty</span>(e2, <span class="pl-c1">:a</span>)
│  │ <span class="pl-k">%</span><span class="pl-c1">3</span> <span class="pl-k">=</span> <span class="pl-k">%</span><span class="pl-c1">1</span> <span class="pl-k">==</span> <span class="pl-k">%</span><span class="pl-c1">2</span>
└──│      goto <span class="pl-c"><span class="pl-c">#</span>3 if not %3</span>
<span class="pl-c1">2</span> ─│ <span class="pl-k">%</span><span class="pl-c1">5</span> <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">getproperty</span>(e1, <span class="pl-c1">:b</span>)
│  │ <span class="pl-k">%</span><span class="pl-c1">6</span> <span class="pl-k">=</span> Base<span class="pl-k">.</span><span class="pl-c1">getproperty</span>(e2, <span class="pl-c1">:b</span>)
│  │ <span class="pl-k">%</span><span class="pl-c1">7</span> <span class="pl-k">=</span> <span class="pl-k">%</span><span class="pl-c1">5</span> <span class="pl-k">==</span> <span class="pl-k">%</span><span class="pl-c1">6</span>
└──│      <span class="pl-k">return</span> <span class="pl-k">%</span><span class="pl-c1">7</span>
<span class="pl-c1">3</span> ─│      <span class="pl-k">return</span> <span class="pl-c1">false</span>
   └
)</pre></div>
<p dir="auto">It is like you would expect. the generated function extracts the field names and defines <code>==</code> by referring to <code>==</code> comparison of the fields.</p>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">For more details to this topic, please see this discourse thread
<a href="https://discourse.julialang.org/t/surprising-struct-equality-test/4890/9" rel="nofollow">https://discourse.julialang.org/t/surprising-struct-equality-test/4890/9</a> and this issue <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="21639099" data-permission-text="Title is private" data-url="https://github.com/JuliaLang/julia/issues/4648" data-hovercard-type="issue" data-hovercard-url="/JuliaLang/julia/issues/4648/hovercard" href="https://github.com/JuliaLang/julia/issues/4648">JuliaLang/julia#4648</a></p>
</article></div>