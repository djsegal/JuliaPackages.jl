<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-woodburymatrices" class="anchor" aria-hidden="true" href="#woodburymatrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>WoodburyMatrices</h1>
<p><a href="https://travis-ci.org/timholy/WoodburyMatrices.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ce09cc4f31e8d225c3d7ee81b9f252d4716a62395cb947337d8dd8ba34b32647/68747470733a2f2f7472617669732d63692e6f72672f74696d686f6c792f576f6f64627572794d617472696365732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/timholy/WoodburyMatrices.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://coveralls.io/r/timholy/WoodburyMatrices.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/014ac0a6eb65f5fa76081df5f1605f99a3f047f58c9fdb420b89c4ecf81a5ed0/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f74696d686f6c792f576f6f64627572794d617472696365732e6a6c2f62616467652e737667" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/timholy/WoodburyMatrices.jl/badge.svg" style="max-width:100%;"></a></p>
<p>This package provides support for the <a href="http://en.wikipedia.org/wiki/Woodbury_matrix_identity" rel="nofollow">Woodbury matrix identity</a> for the Julia programming language.  This is a generalization of the <a href="http://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula" rel="nofollow">Sherman-Morrison formula</a>. Note that the Woodbury matrix identity is notorious for floating-point roundoff errors, so be prepared for a certain amount of inaccuracy in the result.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<h3><a id="user-content-woodbury-matrices" class="anchor" aria-hidden="true" href="#woodbury-matrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Woodbury Matrices</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using WoodburyMatrices
W = Woodbury(A, U, C, V)
"><pre><span class="pl-k">using</span> WoodburyMatrices
W <span class="pl-k">=</span> <span class="pl-c1">Woodbury</span>(A, U, C, V)</pre></div>
<p>creates a <code>Woodbury</code> matrix from the <code>A</code>, <code>U</code>, <code>C</code>, and <code>V</code> matrices representing <code>A + U*C*V</code>. These matrices can be dense or sparse (or generally any type of <code>AbstractMatrix</code>), with the caveat that
<code>inv(inv(C) + V*(A\U))</code> will be calculated explicitly and hence needs to be representable with the available resources.
(In many applications, this is a fairly small matrix.)</p>
<p>Here are some of the things you can do with a Woodbury matrix:</p>
<ul>
<li><code>Matrix(W)</code> converts to its dense representation.</li>
<li><code>W\b</code> solves the equation <code>W*x = b</code> for <code>x</code>.</li>
<li><code>W*x</code> computes the product.</li>
<li><code>det(W)</code> computes the determinant of <code>W</code>.</li>
<li><code>Î±*W</code> and <code>W1 + W2</code>.</li>
</ul>
<p>It's worth emphasizing that <code>A</code> can be supplied as a factorization, which makes <code>W\b</code> and <code>det(W)</code> more efficient.</p>
<h3><a id="user-content-symwoodbury-matrices" class="anchor" aria-hidden="true" href="#symwoodbury-matrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SymWoodbury Matrices</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using WoodburyMatrices
W = SymWoodbury(A, B, D)
"><pre><span class="pl-k">using</span> WoodburyMatrices
W <span class="pl-k">=</span> <span class="pl-c1">SymWoodbury</span>(A, B, D)</pre></div>
<p>creates a <code>SymWoodbury</code> matrix, a symmetric version of a Woodbury matrix representing <code>A + B*D*B'</code>. In addition to the features above, <code>SymWoodbury</code> also supports "squaring" <code>W*W</code>.</p>
</article></div>