<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-functors" class="anchor" aria-hidden="true" href="#functors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functors</h1>
<p>Functors.jl provides a mechanism – really more of a design pattern – for dealing with large structures containing numerical parameters, as in machine learning and optimisation. For large models it can be cumbersome or inefficient to work with parameters as one big, flat vector, and structs help manage complexity; but you also want to easily operate over all parameters at once, e.g. for changing precision or applying an optimiser update step.</p>
<p>Functors.jl provides <code>fmap</code> to make those things easy, acting as a 'map over parameters':</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Functors

julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Foo
         x
         y
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@functor</span> Foo

julia<span class="pl-k">&gt;</span> model <span class="pl-k">=</span> <span class="pl-c1">Foo</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>])
<span class="pl-c1">Foo</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>])

julia<span class="pl-k">&gt;</span> <span class="pl-c1">fmap</span>(float, model)
<span class="pl-c1">Foo</span>(<span class="pl-c1">1.0</span>, [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>])</pre></div>
<p>It works also with deeply-nested models:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Bar
         x
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@functor</span> Bar

julia<span class="pl-k">&gt;</span> model <span class="pl-k">=</span> <span class="pl-c1">Bar</span>(<span class="pl-c1">Foo</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]))
<span class="pl-c1">Bar</span>(<span class="pl-c1">Foo</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">fmap</span>(float, model)
<span class="pl-c1">Bar</span>(<span class="pl-c1">Foo</span>(<span class="pl-c1">1.0</span>, [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>]))</pre></div>
<p>The workhorse of <code>fmap</code> is actually a lower level function, <code>functor</code>:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> xs, re <span class="pl-k">=</span> <span class="pl-c1">functor</span>(<span class="pl-c1">Foo</span>(<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]))
((x <span class="pl-k">=</span> <span class="pl-c1">1</span>, y <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]), <span class="pl-s"><span class="pl-pds"><span class="pl-c1">var</span>"</span>#21#22<span class="pl-pds">"</span></span>())

julia<span class="pl-k">&gt;</span> <span class="pl-c1">re</span>(<span class="pl-c1">map</span>(float, xs))
<span class="pl-c1">Foo</span>(<span class="pl-c1">1.0</span>, [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>])</pre></div>
<p><code>functor</code> returns the parts of the object that can be inspected, as well as a <code>re</code> function that takes those values and restructures them back into an object of the original type.</p>
<p>For a discussion regarding implementing functors for which only a subset of the fields are "seen" by <code>functor</code>, see <a href="https://github.com/FluxML/Functors.jl/issues/3#issuecomment-626747663">here</a>.</p>
<p>For a discussion regarding the need for a <code>cache</code> in the implementation of <code>fmap</code>, see <a href="https://github.com/FluxML/Functors.jl/issues/2">here</a>.</p>
</article></div>