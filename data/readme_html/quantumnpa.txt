<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-quantumnpa" class="anchor" aria-hidden="true" href="#quantumnpa"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>QuantumNPA</h1>
<p dir="auto">Code to do NPA in Julia. In development - names of important functions or
even the entire project could change.</p>
<p dir="auto">Prerequisites:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg; Pkg.add([&quot;Combinatorics&quot;, &quot;JuMP&quot;, &quot;SCS&quot;, &quot;BlockDiagonals&quot;])"><pre><span class="pl-k">using</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>([<span class="pl-s"><span class="pl-pds">"</span>Combinatorics<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>JuMP<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>SCS<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>BlockDiagonals<span class="pl-pds">"</span></span>])</pre></div>
<p dir="auto">Then to use or try out:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="include(&quot;QuantumNPA.jl&quot;);
using .QuantumNPA"><pre><span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>QuantumNPA.jl<span class="pl-pds">"</span></span>);
<span class="pl-k">using</span> <span class="pl-k">.</span>QuantumNPA</pre></div>
<p dir="auto">(The dot in the second line isn't a typo.)</p>
<p dir="auto">If you are working on the code and want to be able to call internal functions
more conveniently you can instead do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="include(&quot;qnpa.jl&quot;)"><pre><span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>qnpa.jl<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">This will load every function and global variable into the main module.</p>
<h2 dir="auto"><a id="user-content-working-examples" class="anchor" aria-hidden="true" href="#working-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Working examples</h2>
<p dir="auto">Maximise CHSH at level 2 of the hierarchy:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @dichotomic A1 A2 B1 B2;

julia&gt; S = A1*(B1 + B2) + A2*(B1 - B2)
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; npa_max(S, 2)
2.828227712681755"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@dichotomic</span> A1 A2 B1 B2;

julia<span class="pl-k">&gt;</span> S <span class="pl-k">=</span> A1<span class="pl-k">*</span>(B1 <span class="pl-k">+</span> B2) <span class="pl-k">+</span> A2<span class="pl-k">*</span>(B1 <span class="pl-k">-</span> B2)
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(S, <span class="pl-c1">2</span>)
<span class="pl-c1">2.828227712681755</span></pre></div>
<p dir="auto">Maximise Svetlichny at level 1 + A B + A C + B C:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @dichotomic A[1:2] B[1:2] C[1:2];

julia&gt; E(x,y,z) = A[x]*B[y]*C[z]
E (generic function with 1 method)

julia&gt; S = -E(1,1,1) + E(1,1,2) + E(1,2,1) + E(1,2,2) + E(2,1,1) + E(2,1,2) + E(2,2,1) - E(2,2,2)
-A1 B1 C1 + A1 B1 C2 + A1 B2 C1 + A1 B2 C2 + A2 B1 C1 + A2 B1 C2 + A2 B2 C1 - A2 B2 C2

julia&gt; npa_max(S, &quot;1 + A B + A C + B C&quot;)
5.656854315137034"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@dichotomic</span> A[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>] B[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>] C[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>];

julia<span class="pl-k">&gt;</span> <span class="pl-en">E</span>(x,y,z) <span class="pl-k">=</span> A[x]<span class="pl-k">*</span>B[y]<span class="pl-k">*</span>C[z]
E (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> S <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">E</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">E</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">E</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">E</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">E</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">E</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">E</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">1</span>) <span class="pl-k">-</span> <span class="pl-c1">E</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)
<span class="pl-k">-</span>A1 B1 C1 <span class="pl-k">+</span> A1 B1 C2 <span class="pl-k">+</span> A1 B2 C1 <span class="pl-k">+</span> A1 B2 C2 <span class="pl-k">+</span> A2 B1 C1 <span class="pl-k">+</span> A2 B1 C2 <span class="pl-k">+</span> A2 B2 C1 <span class="pl-k">-</span> A2 B2 C2

julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(S, <span class="pl-s"><span class="pl-pds">"</span>1 + A B + A C + B C<span class="pl-pds">"</span></span>)
<span class="pl-c1">5.656854315137034</span></pre></div>
<p dir="auto">(note that the spaces e.g. between A and B are necessary in the string, since
party labels go from A to Z then AA to ZZ then AAA to ZZZ...)</p>
<p dir="auto">Maximise a modified CHSH at level 1 + A B + A^2 B:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; npa_max(0.3 * A1 + 0.6 * A1*(B1 + B2) + A2*(B1 - B2), &quot;1 + A B + A^2 B&quot;)
2.3584761820283977"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(<span class="pl-c1">0.3</span> <span class="pl-k">*</span> A1 <span class="pl-k">+</span> <span class="pl-c1">0.6</span> <span class="pl-k">*</span> A1<span class="pl-k">*</span>(B1 <span class="pl-k">+</span> B2) <span class="pl-k">+</span> A2<span class="pl-k">*</span>(B1 <span class="pl-k">-</span> B2), <span class="pl-s"><span class="pl-pds">"</span>1 + A B + A^2 B<span class="pl-pds">"</span></span>)
<span class="pl-c1">2.3584761820283977</span></pre></div>
<p dir="auto">You can specify both equality and inequality arguments using the <code>eq</code> and
<code>ge</code> keyword arguments. These should be lists of operators whose expectation
values you want, respectively, to set to and lower bound by zero. For
example, to maximise <code>&lt;A1&gt;</code> subject to <code>&lt;A1*(B1 + B2)&gt; = 1.4</code> and <code>&lt;A2*(B1 - B2)&gt; = 1.4</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; npa_max(A1, 2, eq=[A1*(B1 + B2) - 1.4*Id, A2*(B1 - B2) - 1.4*Id])
0.19800616634180992"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(A1, <span class="pl-c1">2</span>, eq<span class="pl-k">=</span>[A1<span class="pl-k">*</span>(B1 <span class="pl-k">+</span> B2) <span class="pl-k">-</span> <span class="pl-c1">1.4</span><span class="pl-k">*</span>Id, A2<span class="pl-k">*</span>(B1 <span class="pl-k">-</span> B2) <span class="pl-k">-</span> <span class="pl-c1">1.4</span><span class="pl-k">*</span>Id])
<span class="pl-c1">0.19800616634180992</span></pre></div>
<p dir="auto">Maximise <code>&lt;A1 + A2&gt;</code> subject to <code>&lt;A1 + 2*A2&gt; &lt;= 1 </code> and <code>&lt;2*A1 + A2&gt; &lt;= 1</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; npa_max(A1 + A2, 1, ge=[Id - A1 - 2*A2, Id - 2*A1 - A2])
0.6666666597867417"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(A1 <span class="pl-k">+</span> A2, <span class="pl-c1">1</span>, ge<span class="pl-k">=</span>[Id <span class="pl-k">-</span> A1 <span class="pl-k">-</span> <span class="pl-c1">2</span><span class="pl-k">*</span>A2, Id <span class="pl-k">-</span> <span class="pl-c1">2</span><span class="pl-k">*</span>A1 <span class="pl-k">-</span> A2])
<span class="pl-c1">0.6666666597867417</span></pre></div>
<p dir="auto">Maximise <code>&lt;A1 + A2&gt;</code> subject to <code>&lt;A1&gt; = &lt;A2&gt;</code> and <code>&lt;A1 + 2*A2&gt; &lt;= 1 </code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; npa_max(A1 + A2, 1, eq=[A1 - A2], ge=[1 - A1 - 2*A2])
0.666642228695571"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(A1 <span class="pl-k">+</span> A2, <span class="pl-c1">1</span>, eq<span class="pl-k">=</span>[A1 <span class="pl-k">-</span> A2], ge<span class="pl-k">=</span>[<span class="pl-c1">1</span> <span class="pl-k">-</span> A1 <span class="pl-k">-</span> <span class="pl-c1">2</span><span class="pl-k">*</span>A2])
<span class="pl-c1">0.666642228695571</span></pre></div>
<p dir="auto">The above examples all use dichotomic variables, but projectors are also
supported. Here we maximise the CH74 form of CHSH:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; PA11, PA12 = projector(1,1,1:2);

julia&gt; PB11, PB12 = projector(2,1,1:2);

julia&gt; npa_max(-PA11 - PB11 + PA11*(PB11 + PB12) + PA12*(PB11 - PB12), 1)
0.20701116471401693

julia&gt; (sqrt(2) - 1)/2
0.20710678118654757"><pre>julia<span class="pl-k">&gt;</span> PA11, PA12 <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> PB11, PB12 <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(<span class="pl-k">-</span>PA11 <span class="pl-k">-</span> PB11 <span class="pl-k">+</span> PA11<span class="pl-k">*</span>(PB11 <span class="pl-k">+</span> PB12) <span class="pl-k">+</span> PA12<span class="pl-k">*</span>(PB11 <span class="pl-k">-</span> PB12), <span class="pl-c1">1</span>)
<span class="pl-c1">0.20701116471401693</span>

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">sqrt</span>(<span class="pl-c1">2</span>) <span class="pl-k">-</span> <span class="pl-c1">1</span>)<span class="pl-k">/</span><span class="pl-c1">2</span>
<span class="pl-c1">0.20710678118654757</span></pre></div>
<p dir="auto">Maximise CGLMP with d=3 at level 1 + A B:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; npa_max(cglmp(3), &quot;1 + A B&quot;)
2.914945976226541

julia&gt; 1 + sqrt(11/3)
2.914854215512676"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(<span class="pl-c1">cglmp</span>(<span class="pl-c1">3</span>), <span class="pl-s"><span class="pl-pds">"</span>1 + A B<span class="pl-pds">"</span></span>)
<span class="pl-c1">2.914945976226541</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">11</span><span class="pl-k">/</span><span class="pl-c1">3</span>)
<span class="pl-c1">2.914854215512676</span></pre></div>
<p dir="auto">This uses a function <code>cglmp()</code> already defined in <code>qnpa.jl</code> to construct the
CGLMP operator.</p>
<p dir="auto">Maximise the global guessing probability Pg(A1,B1|E) in the CHSH setting
using full statistics:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Create projectors. The keyword argument 'full=true' means that the
# operator corresponding to the highest-numbered output is directly set to
# the identity minus the other ones. For example,
#
#   PA[2,1] = Id - PA[1,1]
#
# and
#
#   PE[4] = Id - PE[1] - PE[2] - PE[3]
#
# This is meant to make working in the Collins-Gisin projection (which the
# NPA code uses) more convenient.
PA = projector(1, 1:2, 1:2, full=true)
PB = projector(2, 1:2, 1:2, full=true)
PE = projector(5, 1:4, 1, full=true)

# CHSH = 2*sqrt(2) * p
p = 0.9

# Expectation value of G is the probability that Eve correctly guesses
# Alice's and Bob's joint outcome.
G = sum(PA[a,1] * PB[b,1] * PE[2*(a-1) + b]
        for a in 1:2 for b in 1:2)

# Ideal CHSH-violating correlations mixed with noise. N.B., the actual
# constraints imposed are on the expectation values of the operators
# in the array.
constraints = [PA[1,1] - 0.5*Id,
               PA[1,2] - 0.5*Id,
               PB[1,1] - 0.5*Id,
               PB[1,2] - 0.5*Id,
               PA[1,1]*PB[1,1] - 0.25*(1 + p/sqrt(2))*Id,
               PA[1,1]*PB[1,2] - 0.25*(1 + p/sqrt(2))*Id,
               PA[1,2]*PB[1,1] - 0.25*(1 + p/sqrt(2))*Id,
               PA[1,2]*PB[1,2] - 0.25*(1 - p/sqrt(2))*Id]

# This returns about 0.7467 for p = 0.9 at level 2 using the default SCS
# solver.
npa_max(G, 2, eq=constraints)"><pre><span class="pl-c"><span class="pl-c">#</span> Create projectors. The keyword argument 'full=true' means that the</span>
<span class="pl-c"><span class="pl-c">#</span> operator corresponding to the highest-numbered output is directly set to</span>
<span class="pl-c"><span class="pl-c">#</span> the identity minus the other ones. For example,</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>   PA[2,1] = Id - PA[1,1]</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> and</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>   PE[4] = Id - PE[1] - PE[2] - PE[3]</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> This is meant to make working in the Collins-Gisin projection (which the</span>
<span class="pl-c"><span class="pl-c">#</span> NPA code uses) more convenient.</span>
PA <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, full<span class="pl-k">=</span><span class="pl-c1">true</span>)
PB <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, full<span class="pl-k">=</span><span class="pl-c1">true</span>)
PE <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">5</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>, <span class="pl-c1">1</span>, full<span class="pl-k">=</span><span class="pl-c1">true</span>)

<span class="pl-c"><span class="pl-c">#</span> CHSH = 2*sqrt(2) * p</span>
p <span class="pl-k">=</span> <span class="pl-c1">0.9</span>

<span class="pl-c"><span class="pl-c">#</span> Expectation value of G is the probability that Eve correctly guesses</span>
<span class="pl-c"><span class="pl-c">#</span> Alice's and Bob's joint outcome.</span>
G <span class="pl-k">=</span> <span class="pl-c1">sum</span>(PA[a,<span class="pl-c1">1</span>] <span class="pl-k">*</span> PB[b,<span class="pl-c1">1</span>] <span class="pl-k">*</span> PE[<span class="pl-c1">2</span><span class="pl-k">*</span>(a<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">+</span> b]
        <span class="pl-k">for</span> a <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span> <span class="pl-k">for</span> b <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)

<span class="pl-c"><span class="pl-c">#</span> Ideal CHSH-violating correlations mixed with noise. N.B., the actual</span>
<span class="pl-c"><span class="pl-c">#</span> constraints imposed are on the expectation values of the operators</span>
<span class="pl-c"><span class="pl-c">#</span> in the array.</span>
constraints <span class="pl-k">=</span> [PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">-</span> <span class="pl-c1">0.5</span><span class="pl-k">*</span>Id,
               PA[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">-</span> <span class="pl-c1">0.5</span><span class="pl-k">*</span>Id,
               PB[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">-</span> <span class="pl-c1">0.5</span><span class="pl-k">*</span>Id,
               PB[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">-</span> <span class="pl-c1">0.5</span><span class="pl-k">*</span>Id,
               PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]<span class="pl-k">*</span>PB[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">-</span> <span class="pl-c1">0.25</span><span class="pl-k">*</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> p<span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">2</span>))<span class="pl-k">*</span>Id,
               PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]<span class="pl-k">*</span>PB[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">-</span> <span class="pl-c1">0.25</span><span class="pl-k">*</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> p<span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">2</span>))<span class="pl-k">*</span>Id,
               PA[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]<span class="pl-k">*</span>PB[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">-</span> <span class="pl-c1">0.25</span><span class="pl-k">*</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> p<span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">2</span>))<span class="pl-k">*</span>Id,
               PA[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]<span class="pl-k">*</span>PB[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>] <span class="pl-k">-</span> <span class="pl-c1">0.25</span><span class="pl-k">*</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span> p<span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">2</span>))<span class="pl-k">*</span>Id]

<span class="pl-c"><span class="pl-c">#</span> This returns about 0.7467 for p = 0.9 at level 2 using the default SCS</span>
<span class="pl-c"><span class="pl-c">#</span> solver.</span>
<span class="pl-c1">npa_max</span>(G, <span class="pl-c1">2</span>, eq<span class="pl-k">=</span>constraints)</pre></div>
<p dir="auto">QuantumNPA calls the SCS solver by default (since it doesn't require a
license) to solve the NPA relaxation of a quantum optimisation problem, but a
keyword argument <code>solver</code> lets you specify a different one. E.g., solve a
problem using Mosek (which you need a license file to use):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using MosekTools

julia&gt; npa_max(S, 2, solver=Mosek.Optimizer)
2.82842711211242"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> MosekTools

julia<span class="pl-k">&gt;</span> <span class="pl-c1">npa_max</span>(S, <span class="pl-c1">2</span>, solver<span class="pl-k">=</span>Mosek<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">2.82842711211242</span></pre></div>
<p dir="auto">You can also change the default solver if you don't want to specify it every
time, e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; set_solver!(Mosek.Optimizer)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">set_solver!</span>(Mosek<span class="pl-k">.</span>Optimizer)</pre></div>
<p dir="auto">If you want to construct a JuMP model and solve it separately:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; model = npa2jump(S, &quot;1 + A B&quot;, solver=SCS.Optimizer)
A JuMP Model
Minimization problem with:
Variables: 45
Objective function type: AffExpr
`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 16 constraints
`Vector{VariableRef}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: EMPTY_OPTIMIZER
Solver name: SCS

julia&gt; optimize!(model)
------------------------------------------------------------------
               SCS v3.2.0 - Splitting Conic Solver
        (c) Brendan O'Donoghue, Stanford University, 2012
------------------------------------------------------------------
problem:  variables n: 45, constraints m: 61
cones:    z: primal zero / dual free vars: 16
          s: psd vars: 45, ssize: 1
settings: eps_abs: 1.0e-04, eps_rel: 1.0e-04, eps_infeas: 1.0e-07
          alpha: 1.50, scale: 1.00e-01, adaptive_scale: 1
          max_iters: 100000, normalize: 1, rho_x: 1.00e-06
          acceleration_lookback: 10, acceleration_interval: 10
lin-sys:  sparse-direct
          nnz(A): 81, nnz(P): 0
------------------------------------------------------------------
 iter | pri res | dua res |   gap   |   obj   |  scale  | time (s)
------------------------------------------------------------------
     0| 2.22e+01  1.00e+00  2.00e+02 -9.98e+01  1.00e-01  1.40e-04 
    75| 1.51e-05  5.94e-08  5.35e-08  2.83e+00  1.00e-01  3.10e-03 
------------------------------------------------------------------
status:  solved
timings: total: 3.48e-03s = setup: 3.66e-04s + solve: 3.11e-03s
         lin-sys: 2.47e-04s, cones: 2.58e-03s, accel: 1.57e-05s
------------------------------------------------------------------
objective = 2.828427
------------------------------------------------------------------

julia&gt; objective_value(model)
2.8284273129779325"><pre>julia<span class="pl-k">&gt;</span> model <span class="pl-k">=</span> <span class="pl-c1">npa2jump</span>(S, <span class="pl-s"><span class="pl-pds">"</span>1 + A B<span class="pl-pds">"</span></span>, solver<span class="pl-k">=</span>SCS<span class="pl-k">.</span>Optimizer)
A JuMP Model
Minimization problem with<span class="pl-k">:</span>
Variables<span class="pl-k">:</span> <span class="pl-c1">45</span>
Objective <span class="pl-k">function</span> type<span class="pl-k">:</span> AffExpr
<span class="pl-s"><span class="pl-pds">`</span>AffExpr<span class="pl-pds">`</span></span><span class="pl-k">-</span>in<span class="pl-k">-</span><span class="pl-s"><span class="pl-pds">`</span>MathOptInterface.EqualTo{Float64}<span class="pl-pds">`</span></span>: <span class="pl-c1">16</span> constraints
<span class="pl-s"><span class="pl-pds">`</span>Vector{VariableRef}<span class="pl-pds">`</span></span><span class="pl-k">-</span>in<span class="pl-k">-</span><span class="pl-s"><span class="pl-pds">`</span>MathOptInterface.PositiveSemidefiniteConeTriangle<span class="pl-pds">`</span></span>: <span class="pl-c1">1</span> constraint
Model mode<span class="pl-k">:</span> AUTOMATIC
CachingOptimizer state<span class="pl-k">:</span> EMPTY_OPTIMIZER
Solver name<span class="pl-k">:</span> SCS

julia<span class="pl-k">&gt;</span> <span class="pl-c1">optimize!</span>(model)
<span class="pl-k">------------------------------------------------------------------</span>
               SCS v3.<span class="pl-c1">2.0</span> <span class="pl-k">-</span> Splitting Conic Solver
        (c) Brendan O<span class="pl-k">'</span>Donoghue, Stanford University, <span class="pl-c1">2012</span>
<span class="pl-k">------------------------------------------------------------------</span>
problem<span class="pl-k">:</span>  variables n<span class="pl-k">:</span> <span class="pl-c1">45</span>, constraints m<span class="pl-k">:</span> <span class="pl-c1">61</span>
cones<span class="pl-k">:</span>    z<span class="pl-k">:</span> primal zero <span class="pl-k">/</span> dual free vars<span class="pl-k">:</span> <span class="pl-c1">16</span>
          s<span class="pl-k">:</span> psd vars<span class="pl-k">:</span> <span class="pl-c1">45</span>, ssize<span class="pl-k">:</span> <span class="pl-c1">1</span>
settings<span class="pl-k">:</span> eps_abs<span class="pl-k">:</span> <span class="pl-c1">1.0e-04</span>, eps_rel<span class="pl-k">:</span> <span class="pl-c1">1.0e-04</span>, eps_infeas<span class="pl-k">:</span> <span class="pl-c1">1.0e-07</span>
          alpha<span class="pl-k">:</span> <span class="pl-c1">1.50</span>, scale<span class="pl-k">:</span> <span class="pl-c1">1.00e-01</span>, adaptive_scale<span class="pl-k">:</span> <span class="pl-c1">1</span>
          max_iters<span class="pl-k">:</span> <span class="pl-c1">100000</span>, normalize<span class="pl-k">:</span> <span class="pl-c1">1</span>, rho_x<span class="pl-k">:</span> <span class="pl-c1">1.00e-06</span>
          acceleration_lookback<span class="pl-k">:</span> <span class="pl-c1">10</span>, acceleration_interval<span class="pl-k">:</span> <span class="pl-c1">10</span>
lin<span class="pl-k">-</span>sys<span class="pl-k">:</span>  sparse<span class="pl-k">-</span>direct
          <span class="pl-c1">nnz</span>(A)<span class="pl-k">:</span> <span class="pl-c1">81</span>, <span class="pl-c1">nnz</span>(P)<span class="pl-k">:</span> <span class="pl-c1">0</span>
<span class="pl-k">------------------------------------------------------------------</span>
 iter <span class="pl-k">|</span> pri res <span class="pl-k">|</span> dua res <span class="pl-k">|</span>   gap   <span class="pl-k">|</span>   obj   <span class="pl-k">|</span>  scale  <span class="pl-k">|</span> time (s)
<span class="pl-k">------------------------------------------------------------------</span>
     <span class="pl-c1">0</span><span class="pl-k">|</span> <span class="pl-c1">2.22e+01</span>  <span class="pl-c1">1.00e+00</span>  <span class="pl-c1">2.00e+02</span> <span class="pl-k">-</span><span class="pl-c1">9.98e+01</span>  <span class="pl-c1">1.00e-01</span>  <span class="pl-c1">1.40e-04</span> 
    <span class="pl-c1">75</span><span class="pl-k">|</span> <span class="pl-c1">1.51e-05</span>  <span class="pl-c1">5.94e-08</span>  <span class="pl-c1">5.35e-08</span>  <span class="pl-c1">2.83e+00</span>  <span class="pl-c1">1.00e-01</span>  <span class="pl-c1">3.10e-03</span> 
<span class="pl-k">------------------------------------------------------------------</span>
status<span class="pl-k">:</span>  solved
timings<span class="pl-k">:</span> total<span class="pl-k">:</span> <span class="pl-c1">3.48e-03</span>s <span class="pl-k">=</span> setup<span class="pl-k">:</span> <span class="pl-c1">3.66e-04</span>s <span class="pl-k">+</span> solve<span class="pl-k">:</span> <span class="pl-c1">3.11e-03</span>s
         lin<span class="pl-k">-</span>sys<span class="pl-k">:</span> <span class="pl-c1">2.47e-04</span>s, cones<span class="pl-k">:</span> <span class="pl-c1">2.58e-03</span>s, accel<span class="pl-k">:</span> <span class="pl-c1">1.57e-05</span>s
<span class="pl-k">------------------------------------------------------------------</span>
objective <span class="pl-k">=</span> <span class="pl-c1">2.828427</span>
<span class="pl-k">------------------------------------------------------------------</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">objective_value</span>(model)
<span class="pl-c1">2.8284273129779325</span></pre></div>
<p dir="auto">If you call <code>npa2jump()</code> without the <code>solver</code> keyword argument then a solver
isn't assigned, and you will have to assign one to the JuMP model using
JuMP's <code>set_optimizer()</code> function. You can also suppress the output of the
solver by either calling <code>npa2jump()</code> with the keyword argument <code>verbose</code> set
to false or by using JuMP's <code>set_silent()</code> function on the returned JuMP
model.</p>
<h2 dir="auto"><a id="user-content-basic-features" class="anchor" aria-hidden="true" href="#basic-features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic features</h2>
<p dir="auto">We can do arithmetic with and take conjugates of some different types of
operators that we associate to different parties. At the moment:</p>
<ul dir="auto">
<li>dichotomic,</li>
<li>fourier,</li>
<li>projector,</li>
<li>unitary,</li>
<li>zbff (operators for Brown-Fawzi-Fawzi method).</li>
</ul>
<p dir="auto">The identity is represented by a variable <code>Id</code> that is predefined.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Id
Id

julia&gt; projector(1, 2, 3)
PA2|3

julia&gt; PA = projector(1, 1:2, 1:2);

julia&gt; PB = projector(2, 1:2, 1:2);

julia&gt; PA[1,1]
PA1|1

julia&gt; PA[1,1]*PB[1,1]
PA1|1 PB1|1

julia&gt; PB[1,1]*PA[1,1]
PA1|1 PB1|1

julia&gt; PA[1,1]*PA[2,1]
0

julia&gt; PA[1,1]*PA[1,1]
PA1|1

julia&gt; UA = unitary(1, 1:3);

julia&gt; V = UA[1]*conj(UA[2])*UA[3]
UA1 UA*2 UA3

julia&gt; P = PA[1,1] + V
PA1|1 + UA1 UA*2 UA3

julia&gt; conj(P)
PA1|1 + UA*3 UA2 UA*1

julia&gt; P*P
PA1|1 + PA1|1 UA1 UA*2 UA3 + UA1 UA*2 UA3 PA1|1 + UA1 UA*2 UA3 UA1 UA*2 UA3

julia&gt; conj(P)*P
Id + PA1|1 + PA1|1 UA1 UA*2 UA3 + UA*3 UA2 UA*1 PA1|1

julia&gt; Q = Id + V*PA[1,1]
Id + UA1 UA*2 UA3 PA1|1

julia&gt; Q*Q
Id + 2 UA1 UA*2 UA3 PA1|1 + UA1 UA*2 UA3 PA1|1 UA1 UA*2 UA3 PA1|1

julia&gt; conj(Q)*Q
Id + PA1|1 + PA1|1 UA*3 UA2 UA*1 + UA1 UA*2 UA3 PA1|1

julia&gt; ZE = zbff(5, 1:2);

julia&gt; R = PA[1,1]*PB[2,2]*ZE[1]*ZE[2]
PA1|1 PB2|2 ZE1 ZE2

julia&gt; conj(R)
PA1|1 PB2|2 ZE*2 ZE*1

julia&gt; FA = fourier(1, 9, 1, 5)
A9^1

julia&gt; FA^0
Id

julia&gt; FA^3
A9^3

julia&gt; conj(FA^3)
A9^2

julia&gt; FA^5
Id

julia&gt; FA^6
A9^1

julia&gt; conj(FA^3)*FA^3
Id

julia&gt; FA*FA
A9^2

julia&gt; conj((FA*FA)^4)
A9^2

julia&gt; A1, A2 = dichotomic(1, 1:2);

julia&gt; B1, B2 = dichotomic(2, 1:2);

julia&gt; S = A1*(B1 + B2) + A2*(B1 - B2)
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; S^2
4 Id - A1 A2 B1 B2 + A1 A2 B2 B1 + A2 A1 B1 B2 - A2 A1 B2 B1"><pre>julia<span class="pl-k">&gt;</span> Id
Id

julia<span class="pl-k">&gt;</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
PA2<span class="pl-k">|</span><span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> PA <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> PB <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]
PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]<span class="pl-k">*</span>PB[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]
PA1<span class="pl-k">|</span><span class="pl-c1">1</span> PB1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> PB[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]<span class="pl-k">*</span>PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]
PA1<span class="pl-k">|</span><span class="pl-c1">1</span> PB1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]<span class="pl-k">*</span>PA[<span class="pl-c1">2</span>,<span class="pl-c1">1</span>]
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]<span class="pl-k">*</span>PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]
PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> UA <span class="pl-k">=</span> <span class="pl-c1">unitary</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> V <span class="pl-k">=</span> UA[<span class="pl-c1">1</span>]<span class="pl-k">*</span><span class="pl-c1">conj</span>(UA[<span class="pl-c1">2</span>])<span class="pl-k">*</span>UA[<span class="pl-c1">3</span>]
UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3

julia<span class="pl-k">&gt;</span> P <span class="pl-k">=</span> PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-k">+</span> V
PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">+</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(P)
PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">+</span> UA<span class="pl-k">*</span><span class="pl-c1">3</span> UA2 UA<span class="pl-k">*</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> P<span class="pl-k">*</span>P
PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">+</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 <span class="pl-k">+</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">+</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(P)<span class="pl-k">*</span>P
Id <span class="pl-k">+</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">+</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 <span class="pl-k">+</span> UA<span class="pl-k">*</span><span class="pl-c1">3</span> UA2 UA<span class="pl-k">*</span><span class="pl-c1">1</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> Q <span class="pl-k">=</span> Id <span class="pl-k">+</span> V<span class="pl-k">*</span>PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]
Id <span class="pl-k">+</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> Q<span class="pl-k">*</span>Q
Id <span class="pl-k">+</span> <span class="pl-c1">2</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">+</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 PA1<span class="pl-k">|</span><span class="pl-c1">1</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(Q)<span class="pl-k">*</span>Q
Id <span class="pl-k">+</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">+</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span> UA<span class="pl-k">*</span><span class="pl-c1">3</span> UA2 UA<span class="pl-k">*</span><span class="pl-c1">1</span> <span class="pl-k">+</span> UA1 UA<span class="pl-k">*</span><span class="pl-c1">2</span> UA3 PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> ZE <span class="pl-k">=</span> <span class="pl-c1">zbff</span>(<span class="pl-c1">5</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> R <span class="pl-k">=</span> PA[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]<span class="pl-k">*</span>PB[<span class="pl-c1">2</span>,<span class="pl-c1">2</span>]<span class="pl-k">*</span>ZE[<span class="pl-c1">1</span>]<span class="pl-k">*</span>ZE[<span class="pl-c1">2</span>]
PA1<span class="pl-k">|</span><span class="pl-c1">1</span> PB2<span class="pl-k">|</span><span class="pl-c1">2</span> ZE1 ZE2

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(R)
PA1<span class="pl-k">|</span><span class="pl-c1">1</span> PB2<span class="pl-k">|</span><span class="pl-c1">2</span> ZE<span class="pl-k">*</span><span class="pl-c1">2</span> ZE<span class="pl-k">*</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> FA <span class="pl-k">=</span> <span class="pl-c1">fourier</span>(<span class="pl-c1">1</span>, <span class="pl-c1">9</span>, <span class="pl-c1">1</span>, <span class="pl-c1">5</span>)
A9<span class="pl-k">^</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> FA<span class="pl-k">^</span><span class="pl-c1">0</span>
Id

julia<span class="pl-k">&gt;</span> FA<span class="pl-k">^</span><span class="pl-c1">3</span>
A9<span class="pl-k">^</span><span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(FA<span class="pl-k">^</span><span class="pl-c1">3</span>)
A9<span class="pl-k">^</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> FA<span class="pl-k">^</span><span class="pl-c1">5</span>
Id

julia<span class="pl-k">&gt;</span> FA<span class="pl-k">^</span><span class="pl-c1">6</span>
A9<span class="pl-k">^</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(FA<span class="pl-k">^</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>FA<span class="pl-k">^</span><span class="pl-c1">3</span>
Id

julia<span class="pl-k">&gt;</span> FA<span class="pl-k">*</span>FA
A9<span class="pl-k">^</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>((FA<span class="pl-k">*</span>FA)<span class="pl-k">^</span><span class="pl-c1">4</span>)
A9<span class="pl-k">^</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> A1, A2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> B1, B2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> S <span class="pl-k">=</span> A1<span class="pl-k">*</span>(B1 <span class="pl-k">+</span> B2) <span class="pl-k">+</span> A2<span class="pl-k">*</span>(B1 <span class="pl-k">-</span> B2)
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> S<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-c1">4</span> Id <span class="pl-k">-</span> A1 A2 B1 B2 <span class="pl-k">+</span> A1 A2 B2 B1 <span class="pl-k">+</span> A2 A1 B1 B2 <span class="pl-k">-</span> A2 A1 B2 B1</pre></div>
<p dir="auto">The above examples illustrate basic manipulation of monomials and polynomials
of different kinds of operator expressions. Note that polynomials can also
have matrix coefficients:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; P = [1 0; 0 1] * Id + [0 1; 1 0] * A1
[1 0; 0 1] Id + [0 1; 1 0] A1

julia&gt; Q = [1 2; 3 4] * Id + [5 6; 7 8] * B1
[1 2; 3 4] Id + [5 6; 7 8] B1

julia&gt; P*Q
[1 2; 3 4] Id + [3 4; 1 2] A1 + [5 6; 7 8] B1 + [7 8; 5 6] A1 B1"><pre>julia<span class="pl-k">&gt;</span> P <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">0</span>; <span class="pl-c1">0</span> <span class="pl-c1">1</span>] <span class="pl-k">*</span> Id <span class="pl-k">+</span> [<span class="pl-c1">0</span> <span class="pl-c1">1</span>; <span class="pl-c1">1</span> <span class="pl-c1">0</span>] <span class="pl-k">*</span> A1
[<span class="pl-c1">1</span> <span class="pl-c1">0</span>; <span class="pl-c1">0</span> <span class="pl-c1">1</span>] Id <span class="pl-k">+</span> [<span class="pl-c1">0</span> <span class="pl-c1">1</span>; <span class="pl-c1">1</span> <span class="pl-c1">0</span>] A1

julia<span class="pl-k">&gt;</span> Q <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span>; <span class="pl-c1">3</span> <span class="pl-c1">4</span>] <span class="pl-k">*</span> Id <span class="pl-k">+</span> [<span class="pl-c1">5</span> <span class="pl-c1">6</span>; <span class="pl-c1">7</span> <span class="pl-c1">8</span>] <span class="pl-k">*</span> B1
[<span class="pl-c1">1</span> <span class="pl-c1">2</span>; <span class="pl-c1">3</span> <span class="pl-c1">4</span>] Id <span class="pl-k">+</span> [<span class="pl-c1">5</span> <span class="pl-c1">6</span>; <span class="pl-c1">7</span> <span class="pl-c1">8</span>] B1

julia<span class="pl-k">&gt;</span> P<span class="pl-k">*</span>Q
[<span class="pl-c1">1</span> <span class="pl-c1">2</span>; <span class="pl-c1">3</span> <span class="pl-c1">4</span>] Id <span class="pl-k">+</span> [<span class="pl-c1">3</span> <span class="pl-c1">4</span>; <span class="pl-c1">1</span> <span class="pl-c1">2</span>] A1 <span class="pl-k">+</span> [<span class="pl-c1">5</span> <span class="pl-c1">6</span>; <span class="pl-c1">7</span> <span class="pl-c1">8</span>] B1 <span class="pl-k">+</span> [<span class="pl-c1">7</span> <span class="pl-c1">8</span>; <span class="pl-c1">5</span> <span class="pl-c1">6</span>] A1 B1</pre></div>
<p dir="auto">In this case, the dimensions of the coefficients of expressions that are
added to, subtracted from, or multiplied with each other must
match. (Polynomials with matrix coefficients are used by this library to
represent the NPA moment matrix.)</p>
<p dir="auto">The functions that create monomials and their parameters are</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="dichotomic(party, input)
fourier(party, input, power, d)
projector(party, output, input, full=false)
unitary(party, index, conj=false)
zbff(party, index, conj=false)"><pre><span class="pl-c1">dichotomic</span>(party, input)
<span class="pl-c1">fourier</span>(party, input, power, d)
<span class="pl-c1">projector</span>(party, output, input, full<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c1">unitary</span>(party, index, conj<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c1">zbff</span>(party, index, conj<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto">In these:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>party</code> is either:</p>
<ul dir="auto">
<li>a strictly positive integer, e.g., <code>1</code>,</li>
<li>a vector of strictly positive integers in strictly increasing order,
e.g., <code>[1, 3, 4]</code>, representing an operator associated to more than one
party,</li>
<li>an uppercase alphabetic character, e.g. <code>'A'</code>, or</li>
<li>a string of alphabetic characters corresponding to parties in increasing
order separated by underscores, e.g., <code>"A"</code> (same as party number <code>1</code>),
<code>"AB"</code> (party <code>28</code>), <code>"A_B"</code> (party vector <code>[1, 2]</code>), <code>"A_BC"</code> (party
vector <code>[1, 55]</code>).</li>
</ul>
<p dir="auto">Parties are always converted to and stored internally inside monomials in
the vector-of-integers form. Operators associated to different parties are
considered to commute if and only if the intersection of the party vectors
is empty.</p>
</li>
<li>
<p dir="auto">The parameters called <code>input</code>, <code>output</code>, and <code>index</code> can be either integers
or arrays or ranges of integers.</p>
</li>
<li>
<p dir="auto">The parameter <code>conj</code> is optional and defaults to <code>false</code> if it is omitted.</p>
</li>
<li>
<p dir="auto">For projectors, if you give a range of inputs you can also give a value for
a fourth parameter <code>full</code>, which defaults to <code>false</code>. Setting it to <code>true</code>
indicates that you intend for the range of outputs to represent the full
set of measurement outcomes. In that case, in place of the last projector
you are given the identity minus the sum of all the preceding projectors.</p>
</li>
</ul>
<p dir="auto">Party labels go from A to Z for parties 1 to 26, then AA to ZZ starting from
party 27, then AAA to ZZZ, and so on. Because of this, be aware that it is
possible for different operators to end up being printed the same way:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x = unitary(1, 3)
UA3

julia&gt; y = dichotomic(547, 3)
UA3

julia&gt; y*y
Id

julia&gt; x*x
UA3 UA3

julia&gt; conj(x)*x
Id

julia&gt; x*y
UA3 UA3

julia&gt; conj(x)*y
UA*3 UA3"><pre>julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">unitary</span>(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>)
UA3

julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">547</span>, <span class="pl-c1">3</span>)
UA3

julia<span class="pl-k">&gt;</span> y<span class="pl-k">*</span>y
Id

julia<span class="pl-k">&gt;</span> x<span class="pl-k">*</span>x
UA3 UA3

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(x)<span class="pl-k">*</span>x
Id

julia<span class="pl-k">&gt;</span> x<span class="pl-k">*</span>y
UA3 UA3

julia<span class="pl-k">&gt;</span> <span class="pl-c1">conj</span>(x)<span class="pl-k">*</span>y
UA<span class="pl-k">*</span><span class="pl-c1">3</span> UA3</pre></div>
<p dir="auto">A few examples illustrating different ways of calling the <code>projector()</code>
function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; projector(1, 1:2, 1:2)
2×2 Array{Monomial,2}:
 PA1|1  PA1|2
 PA2|1  PA2|2

julia&gt; projector(1, 1:3, 1:2, full=true)
3×2 Array{Any,2}:
 PA1|1               PA1|2
 PA2|1               PA2|2
 Id - PA1|1 - PA2|1  Id - PA1|2 - PA2|2

julia&gt; zbff(1, 1:3)
3-element Array{Monomial,1}:
 ZA1
 ZA2
 ZA3"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Monomial,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 PA1<span class="pl-k">|</span><span class="pl-c1">1</span>  PA1<span class="pl-k">|</span><span class="pl-c1">2</span>
 PA2<span class="pl-k">|</span><span class="pl-c1">1</span>  PA2<span class="pl-k">|</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, full<span class="pl-k">=</span><span class="pl-c1">true</span>)
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Any,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 PA1<span class="pl-k">|</span><span class="pl-c1">1</span>               PA1<span class="pl-k">|</span><span class="pl-c1">2</span>
 PA2<span class="pl-k">|</span><span class="pl-c1">1</span>               PA2<span class="pl-k">|</span><span class="pl-c1">2</span>
 Id <span class="pl-k">-</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span> <span class="pl-k">-</span> PA2<span class="pl-k">|</span><span class="pl-c1">1</span>  Id <span class="pl-k">-</span> PA1<span class="pl-k">|</span><span class="pl-c1">2</span> <span class="pl-k">-</span> PA2<span class="pl-k">|</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">zbff</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{Monomial,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 ZA1
 ZA2
 ZA3</pre></div>
<p dir="auto">Examples illustrating commutation relations with dichotomic operators:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A1, A2 = dichotomic(1, 1:2);

julia&gt; B1, B2 = dichotomic(2, 1:2);

julia&gt; A_C1 = dichotomic([1,3], 1);

julia&gt; A1*B1
A1 B1

julia&gt; B1*A1
A1 B1

julia&gt; A1*A_C1
A1 A_C1

julia&gt; A_C1*A1
A_C1 A1

julia&gt; A1*B1*A_C1
A1 B1 A_C1

julia&gt; A1*B1*A_C1*A2*B2
A1 B1 B2 A_C1 A2

julia&gt; A1*B1*A_C1*A1*B1
A1 A_C1 A1

julia&gt; X = A1*B1
A1 B1

julia&gt; Y = A_C1*X
B1 A_C1 A1

julia&gt; A_C1*Y
A1 B1"><pre>julia<span class="pl-k">&gt;</span> A1, A2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> B1, B2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> A_C1 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>([<span class="pl-c1">1</span>,<span class="pl-c1">3</span>], <span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> A1<span class="pl-k">*</span>B1
A1 B1

julia<span class="pl-k">&gt;</span> B1<span class="pl-k">*</span>A1
A1 B1

julia<span class="pl-k">&gt;</span> A1<span class="pl-k">*</span>A_C1
A1 A_C1

julia<span class="pl-k">&gt;</span> A_C1<span class="pl-k">*</span>A1
A_C1 A1

julia<span class="pl-k">&gt;</span> A1<span class="pl-k">*</span>B1<span class="pl-k">*</span>A_C1
A1 B1 A_C1

julia<span class="pl-k">&gt;</span> A1<span class="pl-k">*</span>B1<span class="pl-k">*</span>A_C1<span class="pl-k">*</span>A2<span class="pl-k">*</span>B2
A1 B1 B2 A_C1 A2

julia<span class="pl-k">&gt;</span> A1<span class="pl-k">*</span>B1<span class="pl-k">*</span>A_C1<span class="pl-k">*</span>A1<span class="pl-k">*</span>B1
A1 A_C1 A1

julia<span class="pl-k">&gt;</span> X <span class="pl-k">=</span> A1<span class="pl-k">*</span>B1
A1 B1

julia<span class="pl-k">&gt;</span> Y <span class="pl-k">=</span> A_C1<span class="pl-k">*</span>X
B1 A_C1 A1

julia<span class="pl-k">&gt;</span> A_C1<span class="pl-k">*</span>Y
A1 B1</pre></div>
<p dir="auto">In the last few evaluations, notice how <code>B1</code> starts behind <code>A1</code>, but then
moves to the front of the expression when <code>A_C1</code> is added, then ends up
behind <code>A1</code> again after the <code>A_C1</code> is cancelled out.</p>
<p dir="auto">I am working on writing macros to automatically create variables using
"standard" names. At the moment you can do, e.g., this to create some
dichotomic variables:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@dichotomic A1 A2 B1 B2 C[1:3]"><pre><span class="pl-c1">@dichotomic</span> A1 A2 B1 B2 C[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>]</pre></div>
<p dir="auto">The above macro invocation does essentially the same as running the
following:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A1 = dichotomic(1, 1)
A2 = dichotomic(1, 2)
B1 = dichotomic(2, 1)
B2 = dichotomic(2, 2)
C = dichotomic(3, 1:3)"><pre>A1 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
A2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
B1 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>)
B2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
C <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">3</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)</pre></div>
<p dir="auto">There are no special relations (at least, at the moment) between the
different types of operators, so you shouldn't, for example, mix projectors
and dichotomic operators unless you consider them to be unrelated to each
other:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; dichotomic(1, 1) * projector(1, 1, 1)
A1 PA1|1

julia&gt; dichotomic(1, 1) - (2*projector(1, 1, 1) - Id)
Id + A1 - 2 PA1|1"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>) <span class="pl-k">*</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
A1 PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>) <span class="pl-k">-</span> (<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>) <span class="pl-k">-</span> Id)
Id <span class="pl-k">+</span> A1 <span class="pl-k">-</span> <span class="pl-c1">2</span> PA1<span class="pl-k">|</span><span class="pl-c1">1</span></pre></div>
<p dir="auto">Finally, it may be worth stressing that operators are objects that can be
manipulated in the same sorts of ways as other types of objects in Julia,
such as putting them in arrays or other data structures. For example,
<code>dichotomic(p, 1:n)</code> returns a one-dimensional array of dichotomic operators,
which we can then use in vector expressions such as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A = dichotomic(1, 1:2)
2-element Vector{Monomial}:
 A1
 A2

julia&gt; B = dichotomic(2, 1:2)
2-element Vector{Monomial}:
 B1
 B2

julia&gt; M = [1 1; 1 -1]
2×2 Matrix{Int64}:
 1   1
 1  -1

julia&gt; A'*M*B
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; kron(A, B)
4-element Vector{Union{Monomial, Polynomial}}:
 A1 B1
 A1 B2
 A2 B1
 A2 B2
 
julia&gt; [1,1,1,-1]'*kron(A, B)
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; V = [Id; A; B; kron(A, B)]'
1×9 adjoint(::Vector{Union{Monomial, Polynomial}}) with eltype Union{Monomial, Polynomial}:
 Id  A1  A2  B1  B2  A1 B1  A1 B2  A2 B1  A2 B2

julia&gt; V'*V
9×9 Matrix{Monomial}:
 Id     A1        A2        B1        B2        …  A2 B1        A2 B2
 A1     Id        A1 A2     A1 B1     A1 B2        A1 A2 B1     A1 A2 B2
 A2     A2 A1     Id        A2 B1     A2 B2        B1           B2
 B1     A1 B1     A2 B1     Id        B1 B2        A2           A2 B1 B2
 B2     A1 B2     A2 B2     B2 B1     Id           A2 B2 B1     A2
 A1 B1  B1        A1 A2 B1  A1        A1 B1 B2  …  A1 A2        A1 A2 B1 B2
 A1 B2  B2        A1 A2 B2  A1 B2 B1  A1           A1 A2 B2 B1  A1 A2
 A2 B1  A2 A1 B1  B1        A2        A2 B1 B2     Id           B1 B2
 A2 B2  A2 A1 B2  B2        A2 B2 B1  A2           B2 B1        Id"><pre>julia<span class="pl-k">&gt;</span> A <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Monomial}<span class="pl-k">:</span>
 A1
 A2

julia<span class="pl-k">&gt;</span> B <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Monomial}<span class="pl-k">:</span>
 B1
 B2

julia<span class="pl-k">&gt;</span> M <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">1</span>; <span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{Int64}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>   <span class="pl-c1">1</span>
 <span class="pl-c1">1</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> A<span class="pl-k">'</span><span class="pl-k">*</span>M<span class="pl-k">*</span>B
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> <span class="pl-c1">kron</span>(A, B)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Vector{Union{Monomial, Polynomial}}<span class="pl-k">:</span>
 A1 B1
 A1 B2
 A2 B1
 A2 B2
 
julia<span class="pl-k">&gt;</span> [<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">'</span><span class="pl-k">*</span><span class="pl-c1">kron</span>(A, B)
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> V <span class="pl-k">=</span> [Id; A; B; <span class="pl-c1">kron</span>(A, B)]<span class="pl-k">'</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">9</span> <span class="pl-c1">adjoint</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Union{Monomial, Polynomial}}</span>) with eltype Union{Monomial, Polynomial}<span class="pl-k">:</span>
 Id  A1  A2  B1  B2  A1 B1  A1 B2  A2 B1  A2 B2

julia<span class="pl-k">&gt;</span> V<span class="pl-k">'</span><span class="pl-k">*</span>V
<span class="pl-c1">9</span><span class="pl-k">×</span><span class="pl-c1">9</span> Matrix{Monomial}<span class="pl-k">:</span>
 Id     A1        A2        B1        B2        …  A2 B1        A2 B2
 A1     Id        A1 A2     A1 B1     A1 B2        A1 A2 B1     A1 A2 B2
 A2     A2 A1     Id        A2 B1     A2 B2        B1           B2
 B1     A1 B1     A2 B1     Id        B1 B2        A2           A2 B1 B2
 B2     A1 B2     A2 B2     B2 B1     Id           A2 B2 B1     A2
 A1 B1  B1        A1 A2 B1  A1        A1 B1 B2  …  A1 A2        A1 A2 B1 B2
 A1 B2  B2        A1 A2 B2  A1 B2 B1  A1           A1 A2 B2 B1  A1 A2
 A2 B1  A2 A1 B1  B1        A2        A2 B1 B2     Id           B1 B2
 A2 B2  A2 A1 B2  B2        A2 B2 B1  A2           B2 B1        Id</pre></div>
<h2 dir="auto"><a id="user-content-analysing-modifying-and-deconstructing-operators" class="anchor" aria-hidden="true" href="#analysing-modifying-and-deconstructing-operators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Analysing, modifying, and deconstructing operators</h2>
<p dir="auto">Monomials and polynomials are objects of different types, although a
polynomial consisting of a single monomial multiplied by 1 is printed the
same as a monomial:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; P = projector(1, 1, 1)
PA1|1

julia&gt; typeof(P)
Monomial

julia&gt; Q = 1*P
PA1|1

julia&gt; typeof(Q)
Polynomial

julia&gt; S
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; typeof(S)
Polynomial"><pre>julia<span class="pl-k">&gt;</span> P <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(P)
Monomial

julia<span class="pl-k">&gt;</span> Q <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">*</span>P
PA1<span class="pl-k">|</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(Q)
Polynomial

julia<span class="pl-k">&gt;</span> S
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(S)
Polynomial</pre></div>
<p dir="auto">If you need to ensure a given object is a polynomial you can "promote" it by
calling <code>Polynomial()</code> on it. This does nothing if the argument is already a
polynomial:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x = Polynomial(1)
Id

julia&gt; y = Polynomial(Id)
Id

julia&gt; z = Polynomial(S)
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; typeof.([x, y, z])
3-element Array{DataType,1}:
 Polynomial
 Polynomial
 Polynomial"><pre>julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">Polynomial</span>(<span class="pl-c1">1</span>)
Id

julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">Polynomial</span>(Id)
Id

julia<span class="pl-k">&gt;</span> z <span class="pl-k">=</span> <span class="pl-c1">Polynomial</span>(S)
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>.([x, y, z])
<span class="pl-c1">3</span><span class="pl-k">-</span>element Array{DataType,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 Polynomial
 Polynomial
 Polynomial</pre></div>
<p dir="auto">Note that, in the last case, the polynomial returned is the same as (and not
a copy of) the original, which means that modifying <code>z</code> here will modify <code>S</code>
since they are the same object:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; z === S
true

julia&gt; z[A1] = 7
7

julia&gt; S
7 A1 + A1 B1 + A1 B2 + A2 B1 - A2 B2"><pre>julia<span class="pl-k">&gt;</span> z <span class="pl-k">===</span> S
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> z[A1] <span class="pl-k">=</span> <span class="pl-c1">7</span>
<span class="pl-c1">7</span>

julia<span class="pl-k">&gt;</span> S
<span class="pl-c1">7</span> A1 <span class="pl-k">+</span> A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2</pre></div>
<p dir="auto">If you want to create a copy of a polynomial that you can safely modify
without changing the original you can call the <code>copy()</code> function to do this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; S = A1*(B1 + B2) + A2*(B1 - B2)
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; z = copy(S)
A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; z === S
false

julia&gt; z[A1] = 7
7

julia&gt; z
7 A1 + A1 B1 + A1 B2 + A2 B1 - A2 B2

julia&gt; S
A1 B1 + A1 B2 + A2 B1 - A2 B2"><pre>julia<span class="pl-k">&gt;</span> S <span class="pl-k">=</span> A1<span class="pl-k">*</span>(B1 <span class="pl-k">+</span> B2) <span class="pl-k">+</span> A2<span class="pl-k">*</span>(B1 <span class="pl-k">-</span> B2)
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> z <span class="pl-k">=</span> <span class="pl-c1">copy</span>(S)
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> z <span class="pl-k">===</span> S
<span class="pl-c1">false</span>

julia<span class="pl-k">&gt;</span> z[A1] <span class="pl-k">=</span> <span class="pl-c1">7</span>
<span class="pl-c1">7</span>

julia<span class="pl-k">&gt;</span> z
<span class="pl-c1">7</span> A1 <span class="pl-k">+</span> A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2

julia<span class="pl-k">&gt;</span> S
A1 B1 <span class="pl-k">+</span> A1 B2 <span class="pl-k">+</span> A2 B1 <span class="pl-k">-</span> A2 B2</pre></div>
<p dir="auto">As the two above examples suggest, you can access and/or modify the
coefficient associated to a given monomial using <code>[]</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; S[A1*B1]
1

julia&gt; S[A1]
0"><pre>julia<span class="pl-k">&gt;</span> S[A1<span class="pl-k">*</span>B1]
<span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> S[A1]
<span class="pl-c1">0</span></pre></div>
<p dir="auto">You can get all the monomials in a polynomial by calling the <code>monomials()</code>
function on it:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; monomials(S)
Base.KeySet for a Dict{Monomial,Number} with 4 entries. Keys:
  A1 B2
  A1 B1
  A2 B1
  A2 B2"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">monomials</span>(S)
Base<span class="pl-k">.</span>KeySet <span class="pl-k">for</span> a Dict{Monomial,Number} with <span class="pl-c1">4</span> entries. Keys<span class="pl-k">:</span>
  A1 B2
  A1 B1
  A2 B1
  A2 B2</pre></div>
<p dir="auto">Polynomials will also act as iterators over pairs of their nonzero
coefficients and monomials in contexts where an iterator is expected:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; collect(S)
4-element Vector{Any}:
 Pair{Number,Monomial}(-1, A2 B2)
 Pair{Number,Monomial}(1, A1 B2)
 Pair{Number,Monomial}(1, A2 B1)
 Pair{Number,Monomial}(1, A1 B1)

julia&gt; for (c, m) in S
           @printf &quot;%s  =&gt;  %2d\n&quot; m c
       end
A2 B1  =&gt;   1
A1 B2  =&gt;   1
A2 B2  =&gt;  -1
A1 B1  =&gt;   1"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(S)
<span class="pl-c1">4</span><span class="pl-k">-</span>element Vector{Any}<span class="pl-k">:</span>
 <span class="pl-c1">Pair</span><span class="pl-c1">{Number,Monomial}</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>, A2 B2)
 <span class="pl-c1">Pair</span><span class="pl-c1">{Number,Monomial}</span>(<span class="pl-c1">1</span>, A1 B2)
 <span class="pl-c1">Pair</span><span class="pl-c1">{Number,Monomial}</span>(<span class="pl-c1">1</span>, A2 B1)
 <span class="pl-c1">Pair</span><span class="pl-c1">{Number,Monomial}</span>(<span class="pl-c1">1</span>, A1 B1)

julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> (c, m) <span class="pl-k">in</span> S
           <span class="pl-c1">@printf</span> <span class="pl-s"><span class="pl-pds">"</span>%s  =&gt;  %2d<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> m c
       <span class="pl-k">end</span>
A2 B1  <span class="pl-k">=&gt;</span>   <span class="pl-c1">1</span>
A1 B2  <span class="pl-k">=&gt;</span>   <span class="pl-c1">1</span>
A2 B2  <span class="pl-k">=&gt;</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>
A1 B1  <span class="pl-k">=&gt;</span>   <span class="pl-c1">1</span></pre></div>
<p dir="auto">If you want to iterate over the monomials in lexicographical order you can
just call <code>sort()</code> on the polynomial first:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; for (c, m) in sort(S)
           @printf &quot;%s  =&gt;  %2d\n&quot; m c
       end
A1 B1  =&gt;   1
A1 B2  =&gt;   1
A2 B1  =&gt;   1
A2 B2  =&gt;  -1"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> (c, m) <span class="pl-k">in</span> <span class="pl-c1">sort</span>(S)
           <span class="pl-c1">@printf</span> <span class="pl-s"><span class="pl-pds">"</span>%s  =&gt;  %2d<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> m c
       <span class="pl-k">end</span>
A1 B1  <span class="pl-k">=&gt;</span>   <span class="pl-c1">1</span>
A1 B2  <span class="pl-k">=&gt;</span>   <span class="pl-c1">1</span>
A2 B1  <span class="pl-k">=&gt;</span>   <span class="pl-c1">1</span>
A2 B2  <span class="pl-k">=&gt;</span>  <span class="pl-k">-</span><span class="pl-c1">1</span></pre></div>
<p dir="auto">In order to help analyse a problem, there is a function <code>operators()</code> that
can find and return all the individual (order 1) operators in one or more
monomials and polynomials or collections of such operators. For instance, if
we wanted to maximise the local guessing probability in the CHSH setting
using full statistics we might represent the problem by an objective
polynomial and a list of constraint polynomials whose expectation values we
want to set to zero:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A1, A2 = dichotomic(1, 1:2)
B1, B2 = dichotomic(2, 1:2)
E1 = dichotomic(5, 1)

objective = (1 + A1*E1)/2

constraints = [A1, A2, B1, B2,
               A1*B1 - 0.7*Id,
               A1*B2 - 0.7*Id,
               A2*B1 - 0.7*Id,
               A2*B2 + 0.7*Id]"><pre>A1, A2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)
B1, B2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)
E1 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">5</span>, <span class="pl-c1">1</span>)

objective <span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">+</span> A1<span class="pl-k">*</span>E1)<span class="pl-k">/</span><span class="pl-c1">2</span>

constraints <span class="pl-k">=</span> [A1, A2, B1, B2,
               A1<span class="pl-k">*</span>B1 <span class="pl-k">-</span> <span class="pl-c1">0.7</span><span class="pl-k">*</span>Id,
               A1<span class="pl-k">*</span>B2 <span class="pl-k">-</span> <span class="pl-c1">0.7</span><span class="pl-k">*</span>Id,
               A2<span class="pl-k">*</span>B1 <span class="pl-k">-</span> <span class="pl-c1">0.7</span><span class="pl-k">*</span>Id,
               A2<span class="pl-k">*</span>B2 <span class="pl-k">+</span> <span class="pl-c1">0.7</span><span class="pl-k">*</span>Id]</pre></div>
<p dir="auto">Assuming these variable definitions, we can use the <code>operators()</code> function to
immediately find all the level-one operators in the problem:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; operators(objective, constraints)
Set{Monomial} with 5 elements:
  A2
  A1
  B1
  B2
  E1"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">operators</span>(objective, constraints)
Set{Monomial} with <span class="pl-c1">5</span> elements<span class="pl-k">:</span>
  A2
  A1
  B1
  B2
  E1</pre></div>
<p dir="auto"><code>operators()</code> can optionally take a keyword argument <code>by_party</code> which is set
to <code>false</code> by default. Setting it to <code>true</code> groups the level-one operators by
party and returns a dictionary of the parties and operators associated to
those parties:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; operators(objective, constraints, by_party=true)
Dict{Integer,Set{Monomial}} with 3 entries:
  2 =&gt; Set(Monomial[B1, B2])
  5 =&gt; Set(Monomial[E1])
  1 =&gt; Set(Monomial[A2, A1])"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">operators</span>(objective, constraints, by_party<span class="pl-k">=</span><span class="pl-c1">true</span>)
Dict{Integer,Set{Monomial}} with <span class="pl-c1">3</span> entries<span class="pl-k">:</span>
  <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Set</span>(Monomial[B1, B2])
  <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Set</span>(Monomial[E1])
  <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Set</span>(Monomial[A2, A1])</pre></div>
<p dir="auto">This is useful for constructing operators at intermediate levels of the
NPA hierarchy like "1 + A B + A E + B E".</p>
<h2 dir="auto"><a id="user-content-npa-example" class="anchor" aria-hidden="true" href="#npa-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NPA example</h2>
<p dir="auto">This short example finds what operators appear and where in the NPA moment
matrix at level 2 for the CHSH problem. It covers only the upper triangular
part and treats monomials and their conjugates as the same.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A1, A2 = dichotomic(1, 1:2)
B1, B2 = dichotomic(2, 1:2)
ops1 = [Id, A1, A2, B1, B2]
ops2 = sort(Set(O1*O2 for O1 in ops1 for O2 in ops1))

indices = Dict()

indexed_ops = collect(enumerate(ops2))

for (i, x) in indexed_ops
    for (j, y) in indexed_ops[i:end]
        m = conj(x)*y
        m = min(m, conj(m))

        if haskey(indices, m)
            push!(indices[m], (i, j))
        else
            indices[m] = [(i, j)]
        end
    end
end"><pre>A1, A2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)
B1, B2 <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)
ops1 <span class="pl-k">=</span> [Id, A1, A2, B1, B2]
ops2 <span class="pl-k">=</span> <span class="pl-c1">sort</span>(<span class="pl-c1">Set</span>(O1<span class="pl-k">*</span>O2 <span class="pl-k">for</span> O1 <span class="pl-k">in</span> ops1 <span class="pl-k">for</span> O2 <span class="pl-k">in</span> ops1))

indices <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()

indexed_ops <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">enumerate</span>(ops2))

<span class="pl-k">for</span> (i, x) <span class="pl-k">in</span> indexed_ops
    <span class="pl-k">for</span> (j, y) <span class="pl-k">in</span> indexed_ops[i<span class="pl-k">:</span><span class="pl-c1">end</span>]
        m <span class="pl-k">=</span> <span class="pl-c1">conj</span>(x)<span class="pl-k">*</span>y
        m <span class="pl-k">=</span> <span class="pl-c1">min</span>(m, <span class="pl-c1">conj</span>(m))

        <span class="pl-k">if</span> <span class="pl-c1">haskey</span>(indices, m)
            <span class="pl-c1">push!</span>(indices[m], (i, j))
        <span class="pl-k">else</span>
            indices[m] <span class="pl-k">=</span> [(i, j)]
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">This gives:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; for (m, l) in sort!(collect(indices), by=first)
           @printf &quot;%11s  =&gt;  %s\n&quot; m l
       end
         Id  =&gt;  [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13)]
         A1  =&gt;  [(1, 2), (3, 7), (4, 8), (5, 9)]
         A2  =&gt;  [(1, 3), (2, 6), (4, 10), (5, 11)]
         B1  =&gt;  [(1, 4), (2, 8), (3, 10), (5, 13)]
         B2  =&gt;  [(1, 5), (2, 9), (3, 11), (4, 12)]
      A1 A2  =&gt;  [(1, 6), (1, 7), (2, 3), (8, 10), (9, 11)]
      A1 B1  =&gt;  [(1, 8), (2, 4), (7, 10), (9, 13)]
      A1 B2  =&gt;  [(1, 9), (2, 5), (7, 11), (8, 12)]
      A2 B1  =&gt;  [(1, 10), (3, 4), (6, 8), (11, 13)]
      A2 B2  =&gt;  [(1, 11), (3, 5), (6, 9), (10, 12)]
      B1 B2  =&gt;  [(1, 12), (1, 13), (4, 5), (8, 9), (10, 11)]
   A1 A2 A1  =&gt;  [(2, 7)]
   A2 A1 A2  =&gt;  [(3, 6)]
   A1 A2 B1  =&gt;  [(2, 10), (3, 8), (4, 6), (4, 7)]
   A1 A2 B2  =&gt;  [(2, 11), (3, 9), (5, 6), (5, 7)]
   A1 B1 B2  =&gt;  [(2, 12), (2, 13), (4, 9), (5, 8)]
   A2 B1 B2  =&gt;  [(3, 12), (3, 13), (4, 11), (5, 10)]
   B1 B2 B1  =&gt;  [(4, 13)]
   B2 B1 B2  =&gt;  [(5, 12)]
A1 A2 A1 A2  =&gt;  [(6, 7)]
A1 A2 A1 B1  =&gt;  [(7, 8)]
A1 A2 A1 B2  =&gt;  [(7, 9)]
A2 A1 A2 B1  =&gt;  [(6, 10)]
A2 A1 A2 B2  =&gt;  [(6, 11)]
A1 A2 B1 B2  =&gt;  [(6, 13), (7, 12), (8, 11)]
A1 A2 B2 B1  =&gt;  [(6, 12), (7, 13), (9, 10)]
A1 B1 B2 B1  =&gt;  [(8, 13)]
A1 B2 B1 B2  =&gt;  [(9, 12)]
A2 B1 B2 B1  =&gt;  [(10, 13)]
A2 B2 B1 B2  =&gt;  [(11, 12)]
B1 B2 B1 B2  =&gt;  [(12, 13)]"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">for</span> (m, l) <span class="pl-k">in</span> <span class="pl-c1">sort!</span>(<span class="pl-c1">collect</span>(indices), by<span class="pl-k">=</span>first)
           <span class="pl-c1">@printf</span> <span class="pl-s"><span class="pl-pds">"</span>%11s  =&gt;  %s<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> m l
       <span class="pl-k">end</span>
         Id  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">6</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">7</span>, <span class="pl-c1">7</span>), (<span class="pl-c1">8</span>, <span class="pl-c1">8</span>), (<span class="pl-c1">9</span>, <span class="pl-c1">9</span>), (<span class="pl-c1">10</span>, <span class="pl-c1">10</span>), (<span class="pl-c1">11</span>, <span class="pl-c1">11</span>), (<span class="pl-c1">12</span>, <span class="pl-c1">12</span>), (<span class="pl-c1">13</span>, <span class="pl-c1">13</span>)]
         A1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">7</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">8</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">9</span>)]
         A2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">10</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">11</span>)]
         B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">8</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">10</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">13</span>)]
         B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">9</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">11</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">12</span>)]
      A1 A2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">7</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">3</span>), (<span class="pl-c1">8</span>, <span class="pl-c1">10</span>), (<span class="pl-c1">9</span>, <span class="pl-c1">11</span>)]
      A1 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">8</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">7</span>, <span class="pl-c1">10</span>), (<span class="pl-c1">9</span>, <span class="pl-c1">13</span>)]
      A1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">9</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">7</span>, <span class="pl-c1">11</span>), (<span class="pl-c1">8</span>, <span class="pl-c1">12</span>)]
      A2 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">10</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">4</span>), (<span class="pl-c1">6</span>, <span class="pl-c1">8</span>), (<span class="pl-c1">11</span>, <span class="pl-c1">13</span>)]
      A2 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">11</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">6</span>, <span class="pl-c1">9</span>), (<span class="pl-c1">10</span>, <span class="pl-c1">12</span>)]
      B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">1</span>, <span class="pl-c1">12</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">13</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">5</span>), (<span class="pl-c1">8</span>, <span class="pl-c1">9</span>), (<span class="pl-c1">10</span>, <span class="pl-c1">11</span>)]
   A1 A2 A1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">2</span>, <span class="pl-c1">7</span>)]
   A2 A1 A2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">3</span>, <span class="pl-c1">6</span>)]
   A1 A2 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">2</span>, <span class="pl-c1">10</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">8</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">7</span>)]
   A1 A2 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">2</span>, <span class="pl-c1">11</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">9</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">6</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">7</span>)]
   A1 B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">2</span>, <span class="pl-c1">12</span>), (<span class="pl-c1">2</span>, <span class="pl-c1">13</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">9</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">8</span>)]
   A2 B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">3</span>, <span class="pl-c1">12</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">13</span>), (<span class="pl-c1">4</span>, <span class="pl-c1">11</span>), (<span class="pl-c1">5</span>, <span class="pl-c1">10</span>)]
   B1 B2 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">4</span>, <span class="pl-c1">13</span>)]
   B2 B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">5</span>, <span class="pl-c1">12</span>)]
A1 A2 A1 A2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">6</span>, <span class="pl-c1">7</span>)]
A1 A2 A1 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">7</span>, <span class="pl-c1">8</span>)]
A1 A2 A1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">7</span>, <span class="pl-c1">9</span>)]
A2 A1 A2 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">6</span>, <span class="pl-c1">10</span>)]
A2 A1 A2 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">6</span>, <span class="pl-c1">11</span>)]
A1 A2 B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">6</span>, <span class="pl-c1">13</span>), (<span class="pl-c1">7</span>, <span class="pl-c1">12</span>), (<span class="pl-c1">8</span>, <span class="pl-c1">11</span>)]
A1 A2 B2 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">6</span>, <span class="pl-c1">12</span>), (<span class="pl-c1">7</span>, <span class="pl-c1">13</span>), (<span class="pl-c1">9</span>, <span class="pl-c1">10</span>)]
A1 B1 B2 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">8</span>, <span class="pl-c1">13</span>)]
A1 B2 B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">9</span>, <span class="pl-c1">12</span>)]
A2 B1 B2 B1  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">10</span>, <span class="pl-c1">13</span>)]
A2 B2 B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">11</span>, <span class="pl-c1">12</span>)]
B1 B2 B1 B2  <span class="pl-k">=&gt;</span>  [(<span class="pl-c1">12</span>, <span class="pl-c1">13</span>)]</pre></div>
<p dir="auto">The example above uses <code>min(m, conj(m))</code> to find which of <code>m</code> or its
conjugate comes first lexicographically. It works because comparisons between
monomials are defined:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A1 == A1
true

julia&gt; A1 &lt; A1
false

julia&gt; A1 &lt; A2
true

julia&gt; A2 &lt; A1*A2
true"><pre>julia<span class="pl-k">&gt;</span> A1 <span class="pl-k">==</span> A1
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> A1 <span class="pl-k">&lt;</span> A1
<span class="pl-c1">false</span>

julia<span class="pl-k">&gt;</span> A1 <span class="pl-k">&lt;</span> A2
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> A2 <span class="pl-k">&lt;</span> A1<span class="pl-k">*</span>A2
<span class="pl-c1">true</span></pre></div>
<p dir="auto"><code>sort</code> used above works for the same reason. <code>==</code> and <code>!=</code> (but not the
inequalities) can also be used to compare monomials with polynomials or
polynomials with each other:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A1 == 1*A1
true

julia&gt; A1 &lt; 1*A1
ERROR: MethodError: no method matching isless(::Monomial, ::Polynomial)
[...]"><pre>julia<span class="pl-k">&gt;</span> A1 <span class="pl-k">==</span> <span class="pl-c1">1</span><span class="pl-k">*</span>A1
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> A1 <span class="pl-k">&lt;</span> <span class="pl-c1">1</span><span class="pl-k">*</span>A1
ERROR<span class="pl-k">:</span> MethodError<span class="pl-k">:</span> no method matching <span class="pl-c1">isless</span>(<span class="pl-k">::</span><span class="pl-c1">Monomial</span>, <span class="pl-k">::</span><span class="pl-c1">Polynomial</span>)
[<span class="pl-k">...</span>]</pre></div>
<h2 dir="auto"><a id="user-content-comments-on-implementation" class="anchor" aria-hidden="true" href="#comments-on-implementation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Comments on implementation</h2>
<p dir="auto">This last section gives some details about how operators are
implemented. This is mainly of interest to people who want to better
understand what the code does and how it works or want to modify it.</p>
<p dir="auto">The basic idea behind this whole library is that the NPA hierarchy method
itself is pretty straightforward if the types of operators you need are
supported. One then just has to compute all the operator products appearing
in the upper triangular part of the moment matrix and check for relations
between the results that translate to constraints on the moment matrix. So
the main thing this library aims to do is add support to Julia for doing
arithmetic and automatically simplifying products of certain types of
operators commonly encountered in quantum optimisation problems that can be
handled with the NPA hierarchy.</p>
<p dir="auto">There are three main types of operator defined in the code. They are:</p>
<ul dir="auto">
<li>
<p dir="auto">The abstract <code>Operator</code> type, defined in <code>src/ops_primitive.jl</code>, which has
several concrete subtypes (<code>Dichotomic</code>, etc.) defined in
<code>src/ops_predefined.jl</code> corresponding to the different types of supported
operator. These types and objects of these types are used internally. They
are not meant to be created or manipulated directly by the user.</p>
</li>
<li>
<p dir="auto"><code>Monomial</code>, defined in <code>src/ops_monomial.jl</code>, to represent products of
operators associated to different parties.</p>
</li>
<li>
<p dir="auto"><code>Polynomial</code>, defined in <code>src/ops_polynomial.jl</code>, to represent linear
combinations of monomials.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-operator" class="anchor" aria-hidden="true" href="#operator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>Operator</code></h3>
<p dir="auto"><code>Operator</code> is an abstract type. This essentially means it is a collective
name for several concrete types that, throughout the code, are assumed to
have certain common properties making them interchangeable to a significant
extent. In particular, they can be passed as arguments to certain functions
such as <code>conj()</code> and <code>Base.:*</code>. The concrete subtypes, such as <code>Dichotomic</code>,
are structs representing the different types of operators supported. What
fields they have depends on the type. For example, <code>Dichotomic</code> objects have
one field <code>index</code> for the index, <code>Projector</code>s have two for the output and
input, and unitaries have an integer <code>index</code> and boolean <code>conj</code> field
tracking whether they are conjugated or not.</p>
<p dir="auto">Objects of the different basic operator types are structs containing data
about them. They are created by calling their constructors, which are
functions with the same (capitalised) names as the types. For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x = Dichotomic(2)
/2

julia&gt; fieldnames(Dichotomic)
(:input,)

julia&gt; x.input
2

julia&gt; y = Projector(2, 3)
P2|3

julia&gt; fieldnames(Projector)
(:output, :input)

julia&gt; (y.output, y.input)
(2, 3)

julia&gt; u = Unitary(3, true)
U*3

julia&gt; fieldnames(Unitary)
(:index, :conj)

julia&gt; (u.index, u.conj)
(3, true)"><pre>julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">Dichotomic</span>(<span class="pl-c1">2</span>)
<span class="pl-k">/</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">fieldnames</span>(Dichotomic)
(<span class="pl-c1">:input</span>,)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">.</span>input
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> y <span class="pl-k">=</span> <span class="pl-c1">Projector</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
P2<span class="pl-k">|</span><span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">fieldnames</span>(Projector)
(<span class="pl-c1">:output</span>, <span class="pl-c1">:input</span>)

julia<span class="pl-k">&gt;</span> (y<span class="pl-k">.</span>output, y<span class="pl-k">.</span>input)
(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> u <span class="pl-k">=</span> <span class="pl-c1">Unitary</span>(<span class="pl-c1">3</span>, <span class="pl-c1">true</span>)
U<span class="pl-k">*</span><span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">fieldnames</span>(Unitary)
(<span class="pl-c1">:index</span>, <span class="pl-c1">:conj</span>)

julia<span class="pl-k">&gt;</span> (u<span class="pl-k">.</span>index, u<span class="pl-k">.</span>conj)
(<span class="pl-c1">3</span>, <span class="pl-c1">true</span>)</pre></div>
<p dir="auto">(Note that these constructors are not exported by the <code>QuantumNPA</code> module;
you either need to prefix their names, e.g., <code>QuantumNPA.Dichotomic</code>, or load
the codebase with <code>include("qnpa.jl")</code> to call them.)</p>
<p dir="auto">The file <code>src/ops_primitive.jl</code> defines default implementations of certain
key functions that have to be supported for all operators, which can then be
overriden when the default behaviour is not correct. For example, <code>conj()</code> is
defined generically for operators to just return the original operator:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Base.conj(o::Operator) = o"><pre>Base<span class="pl-k">.</span><span class="pl-en">conj</span>(o<span class="pl-k">::</span><span class="pl-c1">Operator</span>) <span class="pl-k">=</span> o</pre></div>
<p dir="auto">This is fine for operators that are meant to be Hermitian:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; cx = conj(x)
/2

julia&gt; cx === x
true"><pre>julia<span class="pl-k">&gt;</span> cx <span class="pl-k">=</span> <span class="pl-c1">conj</span>(x)
<span class="pl-k">/</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> cx <span class="pl-k">===</span> x
<span class="pl-c1">true</span></pre></div>
<p dir="auto">But non-Hermitian types have conjugates that have to be determined in
different ways depending on the type and therefore need their own specialised
versions of <code>conj()</code>. For instance, <code>Unitary</code> objects have a <code>conj</code> field and
a version of <code>conj()</code> specialised for unitaries just toggles it. Its
definition is generated by a macro and amounts to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Base.conj(u::Unitary) = Unitary(u.index, !u.conj)"><pre>Base<span class="pl-k">.</span><span class="pl-en">conj</span>(u<span class="pl-k">::</span><span class="pl-c1">Unitary</span>) <span class="pl-k">=</span> <span class="pl-c1">Unitary</span>(u<span class="pl-k">.</span>index, <span class="pl-k">!</span>u<span class="pl-k">.</span>conj)</pre></div>
<p dir="auto">It is this version that gets called if <code>conj()</code> is called with a unitary
argument:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; u.conj
true

julia&gt; v = conj(u)
U3

julia&gt; v.conj
false"><pre>julia<span class="pl-k">&gt;</span> u<span class="pl-k">.</span>conj
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> v <span class="pl-k">=</span> <span class="pl-c1">conj</span>(u)
U3

julia<span class="pl-k">&gt;</span> v<span class="pl-k">.</span>conj
<span class="pl-c1">false</span></pre></div>
<p dir="auto">How to multiply operators and, especially, when the product of two operators
can be simplified is determined by a generic and specialised versions of
<code>Base.:*</code>. The generic version is:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Base.:*(x::Operator, y::Operator) = (1, [x, y])"><pre>Base.:<span class="pl-k">*</span>(x<span class="pl-k">::</span><span class="pl-c1">Operator</span>, y<span class="pl-k">::</span><span class="pl-c1">Operator</span>) <span class="pl-k">=</span> (<span class="pl-c1">1</span>, [x, y])</pre></div>
<p dir="auto">This just means that the default rule is to concatenate operators that are
multiplied together, represented by the list <code>[x, y]</code>. The number <code>1</code> above
is a multiplicative coefficient. This allows for the possibility of scaling
factors appearing in multiplications in the future (such as something like an
unnormalised projector that squares to a multiple of itself). Currently there
are no such operators defined in the codebase and the coefficient is always
zero or one.</p>
<p dir="auto">The implementation above is not sufficient for most of the operator types
and, in practice, the generic multiplication rule is usually fallen back on
to multiply operators of different types, e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x*y
(1, Operator[/2, P2|3])"><pre>julia<span class="pl-k">&gt;</span> x<span class="pl-k">*</span>y
(<span class="pl-c1">1</span>, Operator[<span class="pl-k">/</span><span class="pl-c1">2</span>, P2<span class="pl-k">|</span><span class="pl-c1">3</span>])</pre></div>
<p dir="auto">while multiplication of operators of the same type is usually handled by
specialised versions. Among these, <code>Dichotomic</code> objects have among the
simplest nontrivial multiplication rules: the product of two dichotomic
operators is the identity if their <code>input</code> fields are the same, otherwise
they just concatenate. The implementation is:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function Base.:*(x::Dichotomic, y::Dichotomic)
    return (x.input == y.input) ? (1, []) : (1, [x, y])
end"><pre><span class="pl-k">function</span> Base.:<span class="pl-k">*</span>(x<span class="pl-k">::</span><span class="pl-c1">Dichotomic</span>, y<span class="pl-k">::</span><span class="pl-c1">Dichotomic</span>)
    <span class="pl-k">return</span> (x<span class="pl-k">.</span>input <span class="pl-k">==</span> y<span class="pl-k">.</span>input) <span class="pl-k">?</span> (<span class="pl-c1">1</span>, []) <span class="pl-k">:</span> (<span class="pl-c1">1</span>, [x, y])
<span class="pl-k">end</span></pre></div>
<p dir="auto">with the empty vector <code>[]</code> used to represent the identity.</p>
<p dir="auto">Products are represented by vectors (one-dimensional arrays) of operators. A
function <code>join_ops()</code>, defined near the beginning of <code>src/ops_primitive.jl</code>,
determines how to multiply products. It takes two vectors of operators,
<code>opsx</code> and <code>opsy</code>, and basically takes out and multiplies the last element of
<code>opsx</code> and <code>opsy</code>, repeats this if the result is <code>[]</code> (representing the
identity), and then returns the concatenation of the remaining elements of
<code>opsx</code>, the last non-empty product, and the remaining <code>opsy</code>. An example
invocation:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; p = [u, x]
2-element Vector{Operator}:
 U*3
 /2

julia&gt; q = [x, y]
2-element Vector{Operator}:
 /2
 P2|3

julia&gt; join_ops(p, q)
(1, Operator[U*3, P2|3])"><pre>julia<span class="pl-k">&gt;</span> p <span class="pl-k">=</span> [u, x]
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Operator}<span class="pl-k">:</span>
 U<span class="pl-k">*</span><span class="pl-c1">3</span>
 <span class="pl-k">/</span><span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> q <span class="pl-k">=</span> [x, y]
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Operator}<span class="pl-k">:</span>
 <span class="pl-k">/</span><span class="pl-c1">2</span>
 P2<span class="pl-k">|</span><span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">join_ops</span>(p, q)
(<span class="pl-c1">1</span>, Operator[U<span class="pl-k">*</span><span class="pl-c1">3</span>, P2<span class="pl-k">|</span><span class="pl-c1">3</span>])</pre></div>
<h3 dir="auto"><a id="user-content-monomial" class="anchor" aria-hidden="true" href="#monomial"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>Monomial</code></h3>
<p dir="auto"><code>Monomial</code>s are the most basic type of operator that are meant to be created
and manipulated in normal use of QuantumNPA. They represent products of
operators grouped into different parties. They are structs whose only field,
<code>word</code>, contains a vector <code>[(p1, ops1), (p2, ops2), ...]</code> of pairs of party
vectors <code>p1</code>, <code>p2</code>, etc. and vectors of operators <code>ops1</code>, <code>ops2</code> (of the type
used by the <code>join_ops()</code> function described above) associated to those
parties. Thus, we can look at the contents of a <code>Monomial</code> by accessing its
<code>word</code> field:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; (A1, A2) = dichotomic(1, 1:2);

julia&gt; PB11 = projector(2, 1, 1);

julia&gt; (UE1, UE2) = unitary(5, 1:2);

julia&gt; M = A1*A2*PB11*UE1*UE2
A1 A2 PB1|1 UE1 UE2

julia&gt; M.word
3-element Vector{Tuple{Vector{Int64}, Vector{Operator}}}:
 ([1], [/1, /2])
 ([2], [P1|1])
 ([5], [U1, U2])"><pre>julia<span class="pl-k">&gt;</span> (A1, A2) <span class="pl-k">=</span> <span class="pl-c1">dichotomic</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> PB11 <span class="pl-k">=</span> <span class="pl-c1">projector</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> (UE1, UE2) <span class="pl-k">=</span> <span class="pl-c1">unitary</span>(<span class="pl-c1">5</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> M <span class="pl-k">=</span> A1<span class="pl-k">*</span>A2<span class="pl-k">*</span>PB11<span class="pl-k">*</span>UE1<span class="pl-k">*</span>UE2
A1 A2 PB1<span class="pl-k">|</span><span class="pl-c1">1</span> UE1 UE2

julia<span class="pl-k">&gt;</span> M<span class="pl-k">.</span>word
<span class="pl-c1">3</span><span class="pl-k">-</span>element Vector{Tuple{Vector{Int64}, Vector{Operator}}}<span class="pl-k">:</span>
 ([<span class="pl-c1">1</span>], [<span class="pl-k">/</span><span class="pl-c1">1</span>, <span class="pl-k">/</span><span class="pl-c1">2</span>])
 ([<span class="pl-c1">2</span>], [P1<span class="pl-k">|</span><span class="pl-c1">1</span>])
 ([<span class="pl-c1">5</span>], [U1, U2])</pre></div>
<p dir="auto">Party vectors (on the left of the example above) are vectors of integers
representing which party or parties a group of operators are associated
to. Valid party vectors are vectors of integers, such as <code>[1, 2, 4]</code>, in
which all the integers are in strictly increasing order and the first (and
smallest) integer is at least one. One party vector <code>p</code> is considered to
lexicographically precede another <code>q</code> if <code>length(p) &lt; length(q)</code> or if
<code>length(p) == length(q)</code> and <code>p &lt; q</code>. Often, they will just contain a single
party, e.g. , <code>[1]</code>, but this isn't required. Operators associated to
different parties are taken to commute if the intersection of the party
vectors is empty. Thus <code>[1]</code> commutes with <code>[2]</code> and <code>[1,3]</code> commutes with
<code>[2,4]</code>, but <code>[1,2]</code> does not commute with, for example, <code>[2]</code> or <code>[2,3]</code></p>
<p dir="auto"><code>Monomial</code> objects are meant to represent monomials in a certain reduced
canonical form. A monomial is considered in correctly reduced form if:</p>
<ol dir="auto">
<li>
<p dir="auto">The party vectors are valid and appear in lexicographic order as much as
commutation relations between them allow. This basically means that if a
party vector <code>p</code> is immediately followed by a party vector <code>q</code> then either
<code>p</code> must precede <code>q</code> lexicographically or they must have nonzero
intersection.</p>
</li>
<li>
<p dir="auto">The vectors of operators are nonempty and reduced as much as possible. For
example, a valid vector should not contain the same dichotomic operator
twice, or a unitary and its conjucate, directly following one another.</p>
</li>
</ol>
<p dir="auto">A few key functions, particularly <code>Base.:*()</code>, <code>conj()</code>, and <code>adjoint()</code>, are
responsible for maintaining these conventions, i.e., they should return
monomials in the above-described canonical form assuming their inputs are in
canonical form. So the recommended way to build monomials in most cases is to
start with monomials containing a single operator and multiply them to
construct longer monomials. A monomial containing just one operator can be
created by calling the <code>Monomial</code> function with a party vector and operator
as arguments, e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; M = Monomial([1], Dichotomic(2))
A2

julia&gt; M.word
1-element Vector{Tuple{Vector{Int64}, Vector{Operator}}}:
 ([1], [/2])"><pre>julia<span class="pl-k">&gt;</span> M <span class="pl-k">=</span> <span class="pl-c1">Monomial</span>([<span class="pl-c1">1</span>], <span class="pl-c1">Dichotomic</span>(<span class="pl-c1">2</span>))
A2

julia<span class="pl-k">&gt;</span> M<span class="pl-k">.</span>word
<span class="pl-c1">1</span><span class="pl-k">-</span>element Vector{Tuple{Vector{Int64}, Vector{Operator}}}<span class="pl-k">:</span>
 ([<span class="pl-c1">1</span>], [<span class="pl-k">/</span><span class="pl-c1">2</span>])</pre></div>
<p dir="auto">It is also possible to construct a <code>Monomial</code> by calling <code>Monomial()</code> with an
array of pairs of party vectors and vectors of operators as an argument, but
this way isn't very readable and makes it easy to generate invalid monomials,
and so should be avoided.</p>
<h3 dir="auto"><a id="user-content-polynomial" class="anchor" aria-hidden="true" href="#polynomial"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>Polynomial</code></h3>
<p dir="auto"><code>Polynomial</code> objects represent linear combinations of monomials, such as
<code>A1 + 2 A2 B1</code>. They have a single field, <code>terms</code>, which is a dictionary
mapping monomials to coefficients:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; P = 3*Id + 2*A1*A2
3 Id + 2 A1 A2

julia&gt; P.terms
Dict{Monomial, Number} with 2 entries:
  Id    =&gt; 3
  A1 A2 =&gt; 2"><pre>julia<span class="pl-k">&gt;</span> P <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">*</span>Id <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>A1<span class="pl-k">*</span>A2
<span class="pl-c1">3</span> Id <span class="pl-k">+</span> <span class="pl-c1">2</span> A1 A2

julia<span class="pl-k">&gt;</span> P<span class="pl-k">.</span>terms
Dict{Monomial, Number} with <span class="pl-c1">2</span> entries<span class="pl-k">:</span>
  Id    <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span>
  A1 A2 <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span></pre></div>
<p dir="auto">Only terms with nonzero coeffients should be stored. The arithmetic functions
and indexed assignment (<code>setindex!()</code>, which makes <code>p[p] = c</code> work) don't
create or remove pairs for which the coefficient is zero. So setting a term
to zero deletes it from the dictionary:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; P
3 Id + 2 A1 A2

julia&gt; P[A1*A2] = 0
0

julia&gt; P
3 Id

julia&gt; P.terms
Dict{Monomial, Number} with 1 entry:
  Id =&gt; 3"><pre>julia<span class="pl-k">&gt;</span> P
<span class="pl-c1">3</span> Id <span class="pl-k">+</span> <span class="pl-c1">2</span> A1 A2

julia<span class="pl-k">&gt;</span> P[A1<span class="pl-k">*</span>A2] <span class="pl-k">=</span> <span class="pl-c1">0</span>
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> P
<span class="pl-c1">3</span> Id

julia<span class="pl-k">&gt;</span> P<span class="pl-k">.</span>terms
Dict{Monomial, Number} with <span class="pl-c1">1</span> entry<span class="pl-k">:</span>
  Id <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span></pre></div>
<p dir="auto">The zero polynomial is represented by an empty dictionary.</p>
<p dir="auto">There are a few different versions of the <code>Polynomial()</code> constructor. The
basic one takes a dictionary mapping monomials to coefficients and simply
uses that as the <code>terms</code> field. This is only meant to be used internally, and
with care, since it can be used to create "invalid" polynomials that break
assumptions made elsewhere in the library:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Q = Polynomial(Dict(A1*A2 =&gt; 0))
0 A1 A2

julia&gt; Q == 0
false"><pre>julia<span class="pl-k">&gt;</span> Q <span class="pl-k">=</span> <span class="pl-c1">Polynomial</span>(<span class="pl-c1">Dict</span>(A1<span class="pl-k">*</span>A2 <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>))
<span class="pl-c1">0</span> A1 A2

julia<span class="pl-k">&gt;</span> Q <span class="pl-k">==</span> <span class="pl-c1">0</span>
<span class="pl-c1">false</span></pre></div>
<p dir="auto">Other versions create a polynomial with no input argument (returns the zero
polynomial), or a number, a monomial, a number and monomial, or a polynomial:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Polynomial()
0

julia&gt; Polynomial(3)
3 Id

julia&gt; Polynomial(A1)
A1

julia&gt; Polynomial(3, A1)
3 A1

julia&gt; Polynomial(P)
3 Id"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Polynomial</span>()
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Polynomial</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">3</span> Id

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Polynomial</span>(A1)
A1

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Polynomial</span>(<span class="pl-c1">3</span>, A1)
<span class="pl-c1">3</span> A1

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Polynomial</span>(P)
<span class="pl-c1">3</span> Id</pre></div>
<p dir="auto">As mentioned above, the latter just returns the polynomial given as input.
The fourth one is used to define multiplication of a number by a monomial in
<code>src/ops_polynomial.jl</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Base.:*(x::Number, y::Monomial) = Polynomial(x, y)
Base.:*(x::Monomial, y::Number) = Polynomial(y, x)"><pre>Base.:<span class="pl-k">*</span>(x<span class="pl-k">::</span><span class="pl-c1">Number</span>, y<span class="pl-k">::</span><span class="pl-c1">Monomial</span>) <span class="pl-k">=</span> <span class="pl-c1">Polynomial</span>(x, y)
Base.:<span class="pl-k">*</span>(x<span class="pl-k">::</span><span class="pl-c1">Monomial</span>, y<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">=</span> <span class="pl-c1">Polynomial</span>(y, x)</pre></div>
<h2 dir="auto"><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgements</h2>
<p dir="auto">I started development of this library while a postdoc in the <a href="https://liq.ulb.ac.be" rel="nofollow">Laboratoire
d'Information Quantique</a> at the Université libre de
Bruxelles in Belgium. Since November 2022 I have continued work on this
project at <a href="https://www.quantinuum.com" rel="nofollow">Quantinuum</a>.</p>
</article></div>