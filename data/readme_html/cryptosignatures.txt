<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-cryptosignaturesjl" class="anchor" aria-hidden="true" href="#cryptosignaturesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>CryptoSignatures.jl</h1>
<p dir="auto"><a href="https://travis-ci.com/PeaceFounder/CryptoSignatures.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d60f1045616c6463ab9810d042b1677de6ea8fd8d31505ef03717d3c321491ef/68747470733a2f2f7472617669732d63692e636f6d2f5065616365466f756e6465722f43727970746f5369676e6174757265732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/PeaceFounder/CryptoSignatures.jl.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto"><code>CryptoSignatures.jl</code> aims to be a versatile cryptographic signature library in Julia. Currently supports digital signature algorithm for all available elliptic curves in X9.62 specification. Implementation for modular prime groups is coming shortly.</p>
<h2 dir="auto"><a id="user-content-ecdsa" class="anchor" aria-hidden="true" href="#ecdsa"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ECDSA</h2>
<p dir="auto">The first step is to select a curve to make a cryptographic signature with an elliptic curve digital signature algorithm (ECDSA). Curves from X9.62 specification are already available in <code>CryptoGroups.Specs</code> module. For instance, an elliptic prime group with 192-bit length prime modulus, also known as <code>secp192r1</code>,  can be instantiated as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CryptoSignatures
import CryptoGroups

curve = CryptoGroups.curve(&quot;secp192r1&quot;)
ctx = ECDSAContext(curve, &quot;sha1&quot;)"><pre><span class="pl-k">using</span> CryptoSignatures
<span class="pl-k">import</span> CryptoGroups

curve <span class="pl-k">=</span> CryptoGroups<span class="pl-k">.</span><span class="pl-c1">curve</span>(<span class="pl-s"><span class="pl-pds">"</span>secp192r1<span class="pl-pds">"</span></span>)
ctx <span class="pl-k">=</span> <span class="pl-c1">ECDSAContext</span>(curve, <span class="pl-s"><span class="pl-pds">"</span>sha1<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">where <code>ctx</code> stores all relevant parameters on how to make and verify signatures. The second argument specifies a hash function name, which is forwarded to <code>Nettle</code>. In case hashing is done externally to avoid hashing twice, nothing can be passed as an argument like <code>ECDSAContext(Curve_P_192, nothing)</code>.</p>
<p dir="auto">To make a signature, first, we need to pick a key and calculate a corresponding public key:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="private_key = CryptoSignatures.generate_key(ctx)
public_key = CryptoSignatures.public_key(ctx, private_key; mode = :uncompressed)"><pre>private_key <span class="pl-k">=</span> CryptoSignatures<span class="pl-k">.</span><span class="pl-c1">generate_key</span>(ctx)
public_key <span class="pl-k">=</span> CryptoSignatures<span class="pl-k">.</span><span class="pl-c1">public_key</span>(ctx, private_key; mode <span class="pl-k">=</span> <span class="pl-c1">:uncompressed</span>)</pre></div>
<p dir="auto">where <code>public_key</code> is stored as an octet in uncompressed notation, available are <code>uncompressed</code>, <code>:compressed</code> and <code>:hybrid</code> modes. Note that compressed mode for binary curves is limited as decompression is not implemented.</p>
<p dir="auto">Let's say our message is <code>M = "abc"</code>. That we can sign with a private key:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="signature = CryptoSignatures.sign(ctx, Vector{UInt8}(M), private_key)"><pre>signature <span class="pl-k">=</span> CryptoSignatures<span class="pl-k">.</span><span class="pl-c1">sign</span>(ctx, <span class="pl-c1">Vector</span><span class="pl-c1">{UInt8}</span>(M), private_key)</pre></div>
<p dir="auto">Note that the signature is issued with a <code>k</code> value derived deterministically with a pseudorandom number generator where a seed contains a message, private key and a global seed <code>CryptoSignatures.SEED</code> computed when module is loaded. A signature on a relative generator which can be done by passing it as an argument behind the message <code>sign(ctx, message, generator, private_key)</code>.</p>
<p dir="auto">The message can be verified with <code>verify</code> method using the public key and the issued signature:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CryptoSignatures.verify(ctx, Vector{UInt8}(M), public_key, signature) == true"><pre>CryptoSignatures<span class="pl-k">.</span><span class="pl-c1">verify</span>(ctx, <span class="pl-c1">Vector</span><span class="pl-c1">{UInt8}</span>(M), public_key, signature) <span class="pl-k">==</span> <span class="pl-c1">true</span></pre></div>
<p dir="auto">returning <code>true</code> if the message had been issued by the owner of a <code>public_key</code>. In case the signature had been issued with a relative generator, it is verified as <code>verify(ctx, message, generator, public_key)</code>.</p>
<h2 dir="auto"><a id="user-content-dsa" class="anchor" aria-hidden="true" href="#dsa"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DSA</h2>
<p dir="auto">To use an ordinary DSA with modular arithmetics, we need to instantiate the <code>DSAContext</code>. To do so, we need to select a prime modulus <code>p</code> for which we know group order <code>q</code> and generator <code>g</code>. With <code>CryptoGroups</code> we can generate those parameters and then use them for creating <code>DSAContext</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CryptoSignatures
import CryptoGroups.Specs: generate_pq, generate_g, MODP

p, q = generate_qp(100) # group order with 100 bits as an example (use &gt; 2000)!
g = generate_g(p, q)

group = MODP(; p, q, g)

ctx = DSAContext(group, &quot;sha1&quot;)"><pre><span class="pl-k">using</span> CryptoSignatures
<span class="pl-k">import</span> CryptoGroups<span class="pl-k">.</span>Specs<span class="pl-k">:</span> generate_pq, generate_g, MODP

p, q <span class="pl-k">=</span> <span class="pl-c1">generate_qp</span>(<span class="pl-c1">100</span>) <span class="pl-c"><span class="pl-c">#</span> group order with 100 bits as an example (use &gt; 2000)!</span>
g <span class="pl-k">=</span> <span class="pl-c1">generate_g</span>(p, q)

group <span class="pl-k">=</span> <span class="pl-c1">MODP</span>(; p, q, g)

ctx <span class="pl-k">=</span> <span class="pl-c1">DSAContext</span>(group, <span class="pl-s"><span class="pl-pds">"</span>sha1<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">As for <code>ECDSA</code> context, we generate a private key and a public key:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="private_key = CryptoSignatures.generate_key(ctx)
public_key = CryptoSignatures.public_key(ctx, private_key)"><pre>private_key <span class="pl-k">=</span> CryptoSignatures<span class="pl-k">.</span><span class="pl-c1">generate_key</span>(ctx)
public_key <span class="pl-k">=</span> CryptoSignatures<span class="pl-k">.</span><span class="pl-c1">public_key</span>(ctx, private_key)</pre></div>
<p dir="auto">Which can be used to sign and verify messages as before:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="M = &quot;abc&quot;

signature = CryptoSignatures.sign(ctx, Vector{UInt8}(M), private_key)

verify(ctx, Vector{UInt8}(M), public_key, signature) == true"><pre>M <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>

signature <span class="pl-k">=</span> CryptoSignatures<span class="pl-k">.</span><span class="pl-c1">sign</span>(ctx, <span class="pl-c1">Vector</span><span class="pl-c1">{UInt8}</span>(M), private_key)

<span class="pl-c1">verify</span>(ctx, <span class="pl-c1">Vector</span><span class="pl-c1">{UInt8}</span>(M), public_key, signature) <span class="pl-k">==</span> <span class="pl-c1">true</span></pre></div>
<h2 dir="auto"><a id="user-content-security-considerations" class="anchor" aria-hidden="true" href="#security-considerations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Security Considerations</h2>
<p dir="auto">It's important to state that the underlying implementation does not use constant time operations, thus making it vulnerable to side-channel attacks where the adversary can measure the time that it takes to make different signatures.</p>
<p dir="auto">Another concern is that the implementation is slow, around 10...100 times more than state-of-the-art implementations in C. This can quickly become a bottleneck and attractive avenue for adversaries performing DDOS attacks.</p>
<p dir="auto">It is also essential to state that only two tests are available for the signature algorithm. In practice, there are many attack vectors on how to fool improperly implemented verify function, which needs to be tested in detail.</p>
<p dir="auto">In a nutshell, use it for small projects, but when you become big, don't shy away from the responsibility of including this library in your security audit to make it better.</p>
<h2 dir="auto"><a id="user-content-further-work" class="anchor" aria-hidden="true" href="#further-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Further Work</h2>
<p dir="auto">The performance could be addressed by wrapping the OpenSSL libcrypto library for doing operations on elliptic curves. RSA signatures could be something to add, as well as a blind signature algorithm.</p>
</article></div>