<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-approxfunjl" class="anchor" aria-hidden="true" href="#approxfunjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ApproxFun.jl</h1>
<p dir="auto"><a href="https://JuliaApproximation.github.io/ApproxFun.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://JuliaApproximation.github.io/ApproxFun.jl/latest" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaApproximation/ApproxFun.jl/actions/workflows/ci.yml"><img src="https://github.com/JuliaApproximation/ApproxFun.jl/actions/workflows/ci.yml/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/JuliaApproximation/ApproxFun.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e202ebf49be1fc8fc3d6f75525b253574d89dee28aa07ac1a9fc3268a48cad8c/68747470733a2f2f636f6465636f762e696f2f67682f4a756c6961417070726f78696d6174696f6e2f417070726f7846756e2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/JuliaApproximation/ApproxFun.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/ApproxFun/jGqLz?t=2" rel="nofollow"><img src="https://camo.githubusercontent.com/fc03fe6edb7c639fd4561129becf3b5f00467df6d2534968eb638afb1f2fb62e/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f417070726f7846756e2f646570732e737667" alt="deps" data-canonical-src="https://juliahub.com/docs/ApproxFun/deps.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/ApproxFun/jGqLz" rel="nofollow"><img src="https://camo.githubusercontent.com/eae8e07657a1fc1eb1690ce350b65815fa192d43cab85e67acd732e15ba5d293/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f417070726f7846756e2f76657273696f6e2e737667" alt="version" data-canonical-src="https://juliahub.com/docs/ApproxFun/version.svg" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg" alt="Aqua QA" style="max-width: 100%;"></a>
<a href="https://gitter.im/JuliaApproximation/ApproxFun.jl?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" rel="nofollow"><img src="https://camo.githubusercontent.com/2815fd70e4563beb1802aa5af8b8e913b7ca5a2db0e8c5b7da45f3f3a1d2d3fd/68747470733a2f2f6261646765732e6769747465722e696d2f4a756c6961417070726f78696d6174696f6e2f417070726f7846756e2e6a6c2e737667" alt="Join the chat at https://gitter.im/JuliaApproximation/ApproxFun.jl" data-canonical-src="https://badges.gitter.im/JuliaApproximation/ApproxFun.jl.svg" style="max-width: 100%;"></a></p>
<p dir="auto">ApproxFun is a package for approximating functions. It is in a similar vein to the Matlab
package <a href="http://www.chebfun.org" rel="nofollow"><code>Chebfun</code></a> and the Mathematica package <a href="https://github.com/dlfivefifty/RHPackage"><code>RHPackage</code></a>.</p>
<p dir="auto">The  <a href="https://JuliaApproximation.github.io/ApproxFun.jl/latest" rel="nofollow"><code>ApproxFun Documentation</code></a> contains detailed information, or read on for a brief overview of the package. The documentation contains examples of usage, such as solving ordinary and partial differential equations.</p>
<p dir="auto">The  <a href="https://github.com/JuliaApproximation/ApproxFunExamples"><code>ApproxFun Examples</code></a> repo contains many examples of
using this package, in Jupyter notebooks and Julia scripts. Note that this is independently maintained, so it might not always be in sync with the latest version of <code>ApproxFun</code>. We recommend checking the examples in the documentation first, as these will always be compatible with the latest version of the package.</p>
<h2 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h2>
<h3 dir="auto"><a id="user-content-approximating-functions" class="anchor" aria-hidden="true" href="#approximating-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Approximating Functions</h3>
<p dir="auto">Take your two favourite functions on an interval and create approximations to them as simply as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra, SpecialFunctions, Plots, ApproxFun
x = Fun(identity,0..10)
f = sin(x^2)
g = cos(x)"><pre><span class="pl-k">using</span> LinearAlgebra, SpecialFunctions, Plots, ApproxFun
x <span class="pl-k">=</span> <span class="pl-c1">Fun</span>(identity,<span class="pl-c1">0</span><span class="pl-k">..</span><span class="pl-c1">10</span>)
f <span class="pl-k">=</span> <span class="pl-c1">sin</span>(x<span class="pl-k">^</span><span class="pl-c1">2</span>)
g <span class="pl-k">=</span> <span class="pl-c1">cos</span>(x)</pre></div>
<p dir="auto">Evaluating <code>f(.1)</code> will return a high
accuracy approximation to <code>sin(0.01)</code>. All the algebraic manipulations of functions
are supported and more.  For example, we can add <code>f</code> and <code>g^2</code> together and compute
the roots and extrema:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="h = f + g^2
r = roots(h)
rp = roots(h')

plot(h; label=&quot;f + g^2&quot;)
scatter!(r, h.(r); label=&quot;roots&quot;)
scatter!(rp, h.(rp); label=&quot;extrema&quot;)"><pre>h <span class="pl-k">=</span> f <span class="pl-k">+</span> g<span class="pl-k">^</span><span class="pl-c1">2</span>
r <span class="pl-k">=</span> <span class="pl-c1">roots</span>(h)
rp <span class="pl-k">=</span> <span class="pl-c1">roots</span>(h<span class="pl-k">'</span>)

<span class="pl-c1">plot</span>(h; label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>f + g^2<span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter!</span>(r, <span class="pl-c1">h</span>.(r); label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>roots<span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter!</span>(rp, <span class="pl-c1">h</span>.(rp); label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>extrema<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/JuliaApproximation/ApproxFun.jl/raw/master/images/extrema.png"><img src="https://github.com/JuliaApproximation/ApproxFun.jl/raw/master/images/extrema.png" width="500" height="400" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-differentiation-and-integration" class="anchor" aria-hidden="true" href="#differentiation-and-integration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Differentiation and integration</h3>
<p dir="auto">Notice from above that to find the extrema, we used <code>'</code> overridden for the <code>differentiate</code> function. Several other <code>Julia</code>
base functions are overridden for the purposes of calculus. We may check that the exponential is its own derivative, by evaluating the norm of the difference and checking that it is small:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f = Fun(exp, -1..1)
norm(f-f')  # 4.4391656415701095e-14"><pre>f <span class="pl-k">=</span> <span class="pl-c1">Fun</span>(exp, <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">1</span>)
<span class="pl-c1">norm</span>(f<span class="pl-k">-</span>f<span class="pl-k">'</span>)  <span class="pl-c"><span class="pl-c">#</span> 4.4391656415701095e-14</span></pre></div>
<p dir="auto">Similarly, <code>cumsum</code> defines an indefinite integration operator:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g = cumsum(f)
g = g + f(-1)
norm(f-g) # 3.4989733283850415e-15d"><pre>g <span class="pl-k">=</span> <span class="pl-c1">cumsum</span>(f)
g <span class="pl-k">=</span> g <span class="pl-k">+</span> <span class="pl-c1">f</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>)
<span class="pl-c1">norm</span>(f<span class="pl-k">-</span>g) <span class="pl-c"><span class="pl-c">#</span> 3.4989733283850415e-15d</span></pre></div>
<p dir="auto">Algebraic and differential operations are also implemented where possible, and most of Julia's built-in functions (and special functions from <a href="https://github.com/JuliaMath/SpecialFunctions.jl"><code>SpecialFunctions.jl</code></a>) are overridden to accept <code>Fun</code>s:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = Fun()
f = erf(x)
g = besselj(3,exp(f))
h = airyai(10asin(f)+2g)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">Fun</span>()
f <span class="pl-k">=</span> <span class="pl-c1">erf</span>(x)
g <span class="pl-k">=</span> <span class="pl-c1">besselj</span>(<span class="pl-c1">3</span>,<span class="pl-c1">exp</span>(f))
h <span class="pl-k">=</span> <span class="pl-c1">airyai</span>(<span class="pl-c1">10</span><span class="pl-c1">asin</span>(f)<span class="pl-k">+</span><span class="pl-c1">2</span>g)</pre></div>
<h2 dir="auto"><a id="user-content-examples-of-usage" class="anchor" aria-hidden="true" href="#examples-of-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples of Usage</h2>
<p dir="auto">Check the <a href="https://JuliaApproximation.github.io/ApproxFun.jl/latest" rel="nofollow">documentation</a> for examples of usage.</p>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">J. L. Aurentz &amp; R. M. Slevinsky (2019), On symmetrizing the ultraspherical spectral method for self-adjoint problems, arxiv:1903.08538</p>
<p dir="auto">S. Olver &amp; A. Townsend (2014), A practical framework for infinite-dimensional linear algebra, Proceedings of the 1st First Workshop for High Performance Technical Computing in Dynamic Languages, 57–62</p>
<p dir="auto">A. Townsend &amp; S. Olver (2014), The automatic solution of partial differential equations using a global spectral method,  J. Comp. Phys., 299: 106–123</p>
<p dir="auto">S. Olver &amp; A. Townsend (2013), Fast inverse transform sampling in one and two dimensions, arXiv:1307.1223</p>
<p dir="auto">S. Olver &amp; A. Townsend (2013), A fast and well-conditioned spectral method, SIAM Review, 55:462–489</p>
</article></div>