<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-dataflowtasksjl" class="anchor" aria-hidden="true" href="#dataflowtasksjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DataFlowTasks.jl</h1>
<p dir="auto"><a href="https://maltezfaria.github.io/DataFlowTasks.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://maltezfaria.github.io/DataFlowTasks.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/maltezfaria/DataFlowTasks.jl/actions"><img src="https://github.com/maltezfaria/DataFlowTasks.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/maltezfaria/DataFlowTasks.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d582d10fc31f840733e957776cf525a5df398d5718e8d88be5f1ded24c6d8035/68747470733a2f2f636f6465636f762e696f2f67682f6d616c74657a66617269612f44617461466c6f775461736b732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d554f5755363931575747" alt="codecov" data-canonical-src="https://codecov.io/gh/maltezfaria/DataFlowTasks.jl/branch/main/graph/badge.svg?token=UOWU691WWG" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/84b0d27f8df4fc6c45103c6f951fdaaac5171efe4c4a633c3912085fc078d95d/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d626c75652e737667"><img src="https://camo.githubusercontent.com/84b0d27f8df4fc6c45103c6f951fdaaac5171efe4c4a633c3912085fc078d95d/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d626c75652e737667" alt="Lifecycle" data-canonical-src="https://img.shields.io/badge/lifecycle-experimental-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><code>DataFlowTasks.jl</code> is a Julia package dedicated to parallel programming on
multi-core shared memory CPUs. From user annotations (READ, WRITE, READWRITE)
on program data, <code>DataFlowTasks.jl</code> automatically infers dependencies between
parallel tasks.</p>
<p dir="auto">This <code>README</code> is also available in notebook form:
<a href="docs/readme/README.ipynb"><img src="https://camo.githubusercontent.com/b851b441d8d073ecd85165bc6be45911b5b4e7fba1028ee533d39801d1d76c30/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f776e6c6f61642d6970796e622d626c7565" alt="ipynb" data-canonical-src="https://img.shields.io/badge/download-ipynb-blue" style="max-width: 100%;"></a>
<a href="https://nbviewer.jupyter.org/github/maltezfaria/DataFlowTasks.jl/blob/main/docs/readme/README.ipynb" rel="nofollow"><img src="https://camo.githubusercontent.com/d79c59425fcd4d8507620ef78922e4939d47b0bc52d329865a0ed6b60ea074af/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f73686f772d6e627669657765722d626c75652e737667" alt="nbviewer" data-canonical-src="https://img.shields.io/badge/show-nbviewer-blue.svg" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkd.add(&quot;https://github.com/maltezfaria/DataFlowTasks.jl.git&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkd<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/maltezfaria/DataFlowTasks.jl.git<span class="pl-pds">"</span></span>)</pre></div>
<h2 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic Usage</h2>
<p dir="auto">This package defines a <code>DataFlowTask</code> type which behaves very much like a
Julia native <code>Task</code>, except that it allows the user to specify explicit <em>data
dependencies</em>. This information is then be used to automatically infer <em>task
dependencies</em> by constructing and analyzing a directed acyclic graph based on
how tasks access the underlying data. The premise is that it is sometimes
simpler to specify how <em>tasks depend on data</em> than to specify how <em>tasks
depend on each other</em>.</p>
<p dir="auto">The use of a <code>DataFlowTask</code> object is intended to be as similar as possible to
a Julia native <code>Task</code>. The API implements three macros :</p>
<ul dir="auto">
<li><code>@dspawn</code></li>
<li><code>@dtask</code></li>
<li><code>@dasync</code></li>
</ul>
<p dir="auto">which behave like their <code>Base</code> counterparts, except they take additional
annotations that declare how each <em>task</em> affects the <em>data</em> it accesses:</p>
<ul dir="auto">
<li>read-only: <code>@R</code> or <code>@READ</code></li>
<li>write-only: <code>@W</code> or <code>@WRITE</code></li>
<li>read-write: <code>@RW</code> or <code>@READWRITE</code></li>
</ul>
<p dir="auto">Anywhere in the task body, a <code>@R(A)</code> annotation for example implies that <em>data</em> <code>A</code> will be accessed in read-only mode by the <em>task</em>.</p>
<p dir="auto">Let's look at a simple example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DataFlowTasks
A = Vector{Float64}(undef, 4)
result = let
    @dspawn fill!(@W(A), 0)           # task 1: accesses everything
    @dspawn @RW(view(A, 1:2)) .+= 2   # task 2: modifies the first half
    @dspawn @RW(view(A, 3:4)) .+= 3   # task 3: modifies the second half
    @dspawn @R(A)                     # task 4: get the result
end
fetch(result)"><pre><span class="pl-k">using</span> DataFlowTasks
A <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Float64}</span>(undef, <span class="pl-c1">4</span>)
result <span class="pl-k">=</span> <span class="pl-k">let</span>
    <span class="pl-c1">@dspawn</span> <span class="pl-c1">fill!</span>(<span class="pl-c1">@W</span>(A), <span class="pl-c1">0</span>)           <span class="pl-c"><span class="pl-c">#</span> task 1: accesses everything</span>
    <span class="pl-c1">@dspawn</span> <span class="pl-c1">@RW</span>(<span class="pl-c1">view</span>(A, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) <span class="pl-k">.+</span><span class="pl-k">=</span> <span class="pl-c1">2</span>   <span class="pl-c"><span class="pl-c">#</span> task 2: modifies the first half</span>
    <span class="pl-c1">@dspawn</span> <span class="pl-c1">@RW</span>(<span class="pl-c1">view</span>(A, <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">4</span>)) <span class="pl-k">.+</span><span class="pl-k">=</span> <span class="pl-c1">3</span>   <span class="pl-c"><span class="pl-c">#</span> task 3: modifies the second half</span>
    <span class="pl-c1">@dspawn</span> <span class="pl-c1">@R</span>(A)                     <span class="pl-c"><span class="pl-c">#</span> task 4: get the result</span>
<span class="pl-k">end</span>
<span class="pl-c1">fetch</span>(result)</pre></div>
<p dir="auto">From annotations describing task-data dependencies, <code>DataFlowTasks.jl</code> infers
dependencies between tasks. Internally, this set of dependencies is
represented as a Directed Acyclic Graph. Reconstructing the <code>DAG</code> (as well as
the parallalel traces) can be done using the <code>@log</code> macro:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using GraphViz # triggers additional code loading, powered by Requires.jl
log_info = DataFlowTasks.@log let
    @dspawn fill!(@W(A), 0)             label=&quot;write whole&quot;
    @dspawn @RW(view(A, 1:2)) .+= 2     label=&quot;write 1:2&quot;
    @dspawn @RW(view(A, 3:4)) .+= 3     label=&quot;write 3:4&quot;
    res = @dspawn @R(A)                 label=&quot;read whole&quot;
    fetch(res)
end
dag = DataFlowTasks.plot_dag(log_info)"><pre><span class="pl-k">using</span> GraphViz <span class="pl-c"><span class="pl-c">#</span> triggers additional code loading, powered by Requires.jl</span>
log_info <span class="pl-k">=</span> DataFlowTasks<span class="pl-k">.</span><span class="pl-c1">@log</span> <span class="pl-k">let</span>
    <span class="pl-c1">@dspawn</span> <span class="pl-c1">fill!</span>(<span class="pl-c1">@W</span>(A), <span class="pl-c1">0</span>)             label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>write whole<span class="pl-pds">"</span></span>
    <span class="pl-c1">@dspawn</span> <span class="pl-c1">@RW</span>(<span class="pl-c1">view</span>(A, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>)) <span class="pl-k">.+</span><span class="pl-k">=</span> <span class="pl-c1">2</span>     label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>write 1:2<span class="pl-pds">"</span></span>
    <span class="pl-c1">@dspawn</span> <span class="pl-c1">@RW</span>(<span class="pl-c1">view</span>(A, <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">4</span>)) <span class="pl-k">.+</span><span class="pl-k">=</span> <span class="pl-c1">3</span>     label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>write 3:4<span class="pl-pds">"</span></span>
    res <span class="pl-k">=</span> <span class="pl-c1">@dspawn</span> <span class="pl-c1">@R</span>(A)                 label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>read whole<span class="pl-pds">"</span></span>
    <span class="pl-c1">fetch</span>(res)
<span class="pl-k">end</span>
dag <span class="pl-k">=</span> DataFlowTasks<span class="pl-k">.</span><span class="pl-c1">plot_dag</span>(log_info)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/readme/example_dag.svg"><img src="docs/readme/example_dag.svg" alt="" style="max-width: 100%;"></a></p>
<p dir="auto">In the example above, the tasks <em>write 1:2</em> and <em>write 3:4</em> access
different parts of the array <code>A</code> and are
therefore independant, as shown in the DAG.</p>
<h2 dir="auto"><a id="user-content-example--parallel-cholesky-factorization" class="anchor" aria-hidden="true" href="#example--parallel-cholesky-factorization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example : Parallel Cholesky Factorization</h2>
<p dir="auto">As a less contrived example, we illustrate below the use of <code>DataFlowTasks</code> to
parallelize a tiled Cholesky factorization. The implementation shown here is
delibarately made as simple as possible; a more complex and more efficient
implementation can be found in the
<a href="https://github.com/maltezfaria/TiledFactorization">TiledFactorization</a>
package.</p>
<p dir="auto">The Cholesky factorization algorithm takes a symmetric positive definite
matrix A and finds a lower triangular matrix L such that <code>A = LLᵀ</code>. The tiled
version of this algorithm decomposes the matrix A into tiles (of even sizes,
in this simplified version). At each step of the algorithm, we do a Cholesky
factorization on the diagonal tile, use a triangular solve to update all of
the tiles at the right of the diagonal tile, and finally update all the tiles
of the submatrix with a schur complement.</p>
<p dir="auto">If we have a matrix A decomposed in <code>n x n</code> tiles, then the algorithm will
have <code>n</code> steps. The <code>i</code>-th step (with <code>i ∈ [1:n]</code>) will perform</p>
<ul dir="auto">
<li><code>1</code> cholesky factorization of the (i,i) block,</li>
<li><code>(i-1)</code> triangular solves (one for each block in the <code>i</code>-th row),</li>
<li><code>i*(i-1)/2</code> matrix multiplications to update the submatrix.</li>
</ul>
<p dir="auto">The following image illustrates the 2nd step of the algorithm:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/readme/Cholesky_2ndStep.png"><img src="docs/readme/Cholesky_2ndStep.png" alt="" style="max-width: 100%;"></a></p>
<p dir="auto">A sequential tiled factorization algorithm can be implemented as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra

tilerange(ti, ts) = (ti-1)*ts+1:ti*ts

function cholesky_tiled!(A, ts)
    m = size(A, 1); @assert m==size(A, 2)
    m%ts != 0 &amp;&amp; error(&quot;Tilesize doesn't fit the matrix&quot;)
    n = m÷ts  # number of tiles in each dimension

    T = [view(A, tilerange(i, ts), tilerange(j, ts)) for i in 1:n, j in 1:n]

    for i in 1:n
        # Diagonal cholesky serial factorization
        cholesky!(T[i,i])

        # Left blocks update
        U = UpperTriangular(T[i,i])
        for j in i+1:n
            ldiv!(U', T[i,j])
        end

        # Submatrix update
        for j in i+1:n
            for k in j:n
                mul!(T[j,k], T[i,j]', T[i,k], -1, 1)
            end
        end
    end

    # Construct the factorized object
    return Cholesky(A, 'U', zero(LinearAlgebra.BlasInt))
end"><pre><span class="pl-k">using</span> LinearAlgebra

<span class="pl-en">tilerange</span>(ti, ts) <span class="pl-k">=</span> (ti<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>ts<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span>ti<span class="pl-k">*</span>ts

<span class="pl-k">function</span> <span class="pl-en">cholesky_tiled!</span>(A, ts)
    m <span class="pl-k">=</span> <span class="pl-c1">size</span>(A, <span class="pl-c1">1</span>); <span class="pl-c1">@assert</span> m<span class="pl-k">==</span><span class="pl-c1">size</span>(A, <span class="pl-c1">2</span>)
    m<span class="pl-k">%</span>ts <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Tilesize doesn't fit the matrix<span class="pl-pds">"</span></span>)
    n <span class="pl-k">=</span> m<span class="pl-k">÷</span>ts  <span class="pl-c"><span class="pl-c">#</span> number of tiles in each dimension</span>

    T <span class="pl-k">=</span> [<span class="pl-c1">view</span>(A, <span class="pl-c1">tilerange</span>(i, ts), <span class="pl-c1">tilerange</span>(j, ts)) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n, j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n]

    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n
        <span class="pl-c"><span class="pl-c">#</span> Diagonal cholesky serial factorization</span>
        <span class="pl-c1">cholesky!</span>(T[i,i])

        <span class="pl-c"><span class="pl-c">#</span> Left blocks update</span>
        U <span class="pl-k">=</span> <span class="pl-c1">UpperTriangular</span>(T[i,i])
        <span class="pl-k">for</span> j <span class="pl-k">in</span> i<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span>n
            <span class="pl-c1">ldiv!</span>(U<span class="pl-k">'</span>, T[i,j])
        <span class="pl-k">end</span>

        <span class="pl-c"><span class="pl-c">#</span> Submatrix update</span>
        <span class="pl-k">for</span> j <span class="pl-k">in</span> i<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span>n
            <span class="pl-k">for</span> k <span class="pl-k">in</span> j<span class="pl-k">:</span>n
                <span class="pl-c1">mul!</span>(T[j,k], T[i,j]<span class="pl-k">'</span>, T[i,k], <span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    <span class="pl-c"><span class="pl-c">#</span> Construct the factorized object</span>
    <span class="pl-k">return</span> <span class="pl-c1">Cholesky</span>(A, <span class="pl-s"><span class="pl-pds">'</span>U<span class="pl-pds">'</span></span>, <span class="pl-c1">zero</span>(LinearAlgebra<span class="pl-k">.</span>BlasInt))
<span class="pl-k">end</span></pre></div>
<p dir="auto">Parallelizing the code with <code>DataFlowTasks.jl</code> is as easy as wrapping function calls within <code>@dspawn</code>, and adding annotations describing data access modes:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DataFlowTasks

function cholesky_dft!(A, ts)
    m = size(A, 1); @assert m==size(A, 2)
    m%ts != 0 &amp;&amp; error(&quot;Tilesize doesn't fit the matrix&quot;)
    n = m÷ts  # number of tiles in each dimension

    T = [view(A, tilerange(i, ts), tilerange(j, ts)) for i in 1:n, j in 1:n]

    for i in 1:n
        # Diagonal cholesky serial factorization
        @dspawn cholesky!(@RW(T[i,i])) label=&quot;chol ($i,$i)&quot;

        # Left blocks update
        U = UpperTriangular(T[i,i])
        for j in i+1:n
            @dspawn ldiv!(@R(U)', @RW(T[i,j])) label=&quot;ldiv ($i,$j)&quot;
        end

        # Submatrix update
        for j in i+1:n
            for k in j:n
                @dspawn mul!(@RW(T[j,k]), @R(T[i,j])', @R(T[i,k]), -1, 1) label=&quot;schur ($j,$k)&quot;
            end
        end
    end

    # Construct the factorized object
    r = @dspawn Cholesky(@R(A), 'U', zero(LinearAlgebra.BlasInt)) label=&quot;result&quot;
    return fetch(r)
end"><pre><span class="pl-k">using</span> DataFlowTasks

<span class="pl-k">function</span> <span class="pl-en">cholesky_dft!</span>(A, ts)
    m <span class="pl-k">=</span> <span class="pl-c1">size</span>(A, <span class="pl-c1">1</span>); <span class="pl-c1">@assert</span> m<span class="pl-k">==</span><span class="pl-c1">size</span>(A, <span class="pl-c1">2</span>)
    m<span class="pl-k">%</span>ts <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Tilesize doesn't fit the matrix<span class="pl-pds">"</span></span>)
    n <span class="pl-k">=</span> m<span class="pl-k">÷</span>ts  <span class="pl-c"><span class="pl-c">#</span> number of tiles in each dimension</span>

    T <span class="pl-k">=</span> [<span class="pl-c1">view</span>(A, <span class="pl-c1">tilerange</span>(i, ts), <span class="pl-c1">tilerange</span>(j, ts)) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n, j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n]

    <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n
        <span class="pl-c"><span class="pl-c">#</span> Diagonal cholesky serial factorization</span>
        <span class="pl-c1">@dspawn</span> <span class="pl-c1">cholesky!</span>(<span class="pl-c1">@RW</span>(T[i,i])) label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>chol (<span class="pl-v">$i</span>,<span class="pl-v">$i</span>)<span class="pl-pds">"</span></span>

        <span class="pl-c"><span class="pl-c">#</span> Left blocks update</span>
        U <span class="pl-k">=</span> <span class="pl-c1">UpperTriangular</span>(T[i,i])
        <span class="pl-k">for</span> j <span class="pl-k">in</span> i<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span>n
            <span class="pl-c1">@dspawn</span> <span class="pl-c1">ldiv!</span>(<span class="pl-c1">@R</span>(U)<span class="pl-k">'</span>, <span class="pl-c1">@RW</span>(T[i,j])) label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>ldiv (<span class="pl-v">$i</span>,<span class="pl-v">$j</span>)<span class="pl-pds">"</span></span>
        <span class="pl-k">end</span>

        <span class="pl-c"><span class="pl-c">#</span> Submatrix update</span>
        <span class="pl-k">for</span> j <span class="pl-k">in</span> i<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">:</span>n
            <span class="pl-k">for</span> k <span class="pl-k">in</span> j<span class="pl-k">:</span>n
                <span class="pl-c1">@dspawn</span> <span class="pl-c1">mul!</span>(<span class="pl-c1">@RW</span>(T[j,k]), <span class="pl-c1">@R</span>(T[i,j])<span class="pl-k">'</span>, <span class="pl-c1">@R</span>(T[i,k]), <span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span>) label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>schur (<span class="pl-v">$j</span>,<span class="pl-v">$k</span>)<span class="pl-pds">"</span></span>
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    <span class="pl-c"><span class="pl-c">#</span> Construct the factorized object</span>
    r <span class="pl-k">=</span> <span class="pl-c1">@dspawn</span> <span class="pl-c1">Cholesky</span>(<span class="pl-c1">@R</span>(A), <span class="pl-s"><span class="pl-pds">'</span>U<span class="pl-pds">'</span></span>, <span class="pl-c1">zero</span>(LinearAlgebra<span class="pl-k">.</span>BlasInt)) label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>result<span class="pl-pds">"</span></span>
    <span class="pl-k">return</span> <span class="pl-c1">fetch</span>(r)
<span class="pl-k">end</span></pre></div>
<p dir="auto">(Also note how extra annotations were added in the code, in order to attach
meaningful labels to the tasks. These will later be useful to interpret the
output of debugging &amp; profiling tools.)</p>
<p dir="auto">The code below shows how to use this <code>cholesky_tiled!</code> function, as well as
how to profile the program and get information about how tasks were scheduled:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# DataFlowTasks environnement setup

# Context
n  = 2048
ts = 512
A = rand(n, n)
A = (A + adjoint(A))/2
A = A + n*I;"><pre><span class="pl-c"><span class="pl-c">#</span> DataFlowTasks environnement setup</span>

<span class="pl-c"><span class="pl-c">#</span> Context</span>
n  <span class="pl-k">=</span> <span class="pl-c1">2048</span>
ts <span class="pl-k">=</span> <span class="pl-c1">512</span>
A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(n, n)
A <span class="pl-k">=</span> (A <span class="pl-k">+</span> <span class="pl-c1">adjoint</span>(A))<span class="pl-k">/</span><span class="pl-c1">2</span>
A <span class="pl-k">=</span> A <span class="pl-k">+</span> n<span class="pl-k">*</span>I;</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
# First run to trigger compilation
F = cholesky_dft!(copy(A), ts)

# Check results
err = norm(F.L*F.U-A,Inf)/max(norm(A),norm(F.L*F.U))"><pre><span class="pl-c"><span class="pl-c">#</span> First run to trigger compilation</span>
F <span class="pl-k">=</span> <span class="pl-c1">cholesky_dft!</span>(<span class="pl-c1">copy</span>(A), ts)

<span class="pl-c"><span class="pl-c">#</span> Check results</span>
err <span class="pl-k">=</span> <span class="pl-c1">norm</span>(F<span class="pl-k">.</span>L<span class="pl-k">*</span>F<span class="pl-k">.</span>U<span class="pl-k">-</span>A,<span class="pl-c1">Inf</span>)<span class="pl-k">/</span><span class="pl-c1">max</span>(<span class="pl-c1">norm</span>(A),<span class="pl-c1">norm</span>(F<span class="pl-k">.</span>L<span class="pl-k">*</span>F<span class="pl-k">.</span>U))</pre></div>
<h2 dir="auto"><a id="user-content-debugging-and-profiling" class="anchor" aria-hidden="true" href="#debugging-and-profiling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Debugging and Profiling</h2>
<p dir="auto">DataFlowTasks comes with debugging and profiling tools which help
understanding how task dependencies were inferred, and how tasks were
scheduled during execution.</p>
<p dir="auto">As usual when profiling code, it is recommended to start from a state where
all code has already been compiled, and all previous profiling information has
been discarded:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Manually call GC to avoid noise from previous runs
GC.gc()

# Profile the code and return a `LogInfo` object:
log_info = DataFlowTasks.@log cholesky_dft!(A ,ts);"><pre><span class="pl-c"><span class="pl-c">#</span> Manually call GC to avoid noise from previous runs</span>
GC<span class="pl-k">.</span><span class="pl-c1">gc</span>()

<span class="pl-c"><span class="pl-c">#</span> Profile the code and return a `LogInfo` object:</span>
log_info <span class="pl-k">=</span> DataFlowTasks<span class="pl-k">.</span><span class="pl-c1">@log</span> <span class="pl-c1">cholesky_dft!</span>(A ,ts);</pre></div>
<p dir="auto">Visualizing the DAG can be helpful. When debugging, this representation of
dependencies between tasks as inferred by <code>DataFlowTasks</code> can help identify
missing or erroneous data dependency annotations. When profiling, identifying
the critical path (plotted in red in the DAG) can help understand the
performances of the implementation.</p>
<p dir="auto">In this more complex example, we can see how quickly the DAG complexity
increases (even though the test case only has 4x4 blocks here):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="dag = DataFlowTasks.plot_dag(log_info)"><pre>dag <span class="pl-k">=</span> DataFlowTasks<span class="pl-k">.</span><span class="pl-c1">plot_dag</span>(log_info)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/readme/cholesky_dag.svg"><img src="docs/readme/cholesky_dag.svg" alt="" style="max-width: 100%;"></a></p>
<p dir="auto">The parallel trace plot shows a timeline of the tasks execution on available
threads. It helps understanding how tasks were scheduled. The same window also
carries other general information allowing to better understand the
performance limiting factors:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CairoMakie # or GLMakie in order to have more interactivity
trace = DataFlowTasks.plot_traces(log_info; categories=[&quot;chol&quot;, &quot;ldiv&quot;, &quot;schur&quot;])"><pre><span class="pl-k">using</span> CairoMakie <span class="pl-c"><span class="pl-c">#</span> or GLMakie in order to have more interactivity</span>
trace <span class="pl-k">=</span> DataFlowTasks<span class="pl-k">.</span><span class="pl-c1">plot_traces</span>(log_info; categories<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>chol<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>ldiv<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>schur<span class="pl-pds">"</span></span>])</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/readme/cholesky_trace.svg"><img src="docs/readme/cholesky_trace.svg" alt="" style="max-width: 100%;"></a></p>
<p dir="auto">We see here that the execution time is bounded by the length of the critical
path: with this block size and matrix size, the algorithm does not expose
enough parallelism to occupy all threads without waiting periods.</p>
<p dir="auto">We'll cover in details the usage and possibilities of the visualization in the
documentation.</p>
<p dir="auto">Note that the debugging &amp; profiling tools need additional dependencies such as
<code>Makie</code> and <code>GraphViz</code>, which are only meant to be used interactively during
the development process. These packages are therefore only considered as
optional depdendencies; assuming they are available in your work environment,
calling e.g. <code>using GraphViz</code> will load some additional code from
<code>DataFlowTasks</code> (see also the documentation of <code>DataFlowTasks.@using_opt</code> if
you prefer an alternative way of handling these extra dependencies).</p>
<h1 dir="auto"><a id="user-content-performances" class="anchor" aria-hidden="true" href="#performances"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performances</h1>
<p dir="auto">The performance of this example can be improved by using better
implementations for the sequential building blocks operating on tiles:</p>
<ul dir="auto">
<li><code>LoopVectorization.jl</code> can improve the performance of the sequential
cholesky factorization of diagonal blocks as well as the <code>schur_complement</code></li>
<li><code>TriangularSolve.jl</code> provides a high-performance <code>ldiv!</code> implementation</li>
</ul>
<p dir="auto">This approach is pursued in
<a href="https://github.com/maltezfaria/TiledFactorization"><code>TiledFactorization.jl</code></a>,
where all the above mentioned building blocks are combined with the
parallelization strategy presented here to create a <em>pure Julia</em>
implementation of the matrix factorizations. The performances of this
implementation is assessed in the following plot, by comparison to MKL on a
the case of a 5000x5000 matrix decomposed in tiles of size 256x256.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/readme/cholesky_scaling.png"><img src="docs/readme/cholesky_scaling.png" alt="" style="max-width: 100%;"></a></p>
<p dir="auto">The figure above was generated by running <a href="https://github.com/maltezfaria/TiledFactorization/blob/daafed7b6981853b6c71e7441fd9b212582836db/benchmarks/cholesky_scaling.sh">this
script</a>
on a machine with 2x10 Intel Xeon Silver 4114 cores (2.20GHz) with the following topology:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="docs/readme/lfaria-precision-7920-tower-lstopo.png"><img src="docs/readme/lfaria-precision-7920-tower-lstopo.png" alt="" style="max-width: 100%;"></a></p>
<hr>
<p dir="auto"><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p>
</article></div>