<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/44394955/58797326-085dd580-8600-11e9-958c-b1698e1d370e.png"><img src="https://user-images.githubusercontent.com/44394955/58797326-085dd580-8600-11e9-958c-b1698e1d370e.png" alt="fem" width="400" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-a-minimal-finite-element-tool-for-demonstration-and-teaching" class="anchor" aria-hidden="true" href="#a-minimal-finite-element-tool-for-demonstration-and-teaching"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A minimal finite element tool for demonstration and teaching.</h2>
<ul dir="auto">
<li>
<p dir="auto">The purpose of this package is to provide an easy and minimalistic introdcution to the finite element method.</p>
</li>
<li>
<p dir="auto">We restrict ourselves to linear finite elements on tetrahedral grids in 1D, 2D and 3D.</p>
</li>
<li>
<p dir="auto">This code imports meshes in GMSH v1, v2 and v4 format and outputs VTK format for Paraview.</p>
</li>
</ul>
<p dir="auto">First we need to add the MinFEM package to our Julia installation.
Thus, open the julia REPL, hit the <strong>]</strong> key and type</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add MinFEM
test MinFEM"><pre class="notranslate"><code>add MinFEM
test MinFEM
</code></pre></div>
<p dir="auto">Lets go through a code for the Poisson equation on a unit square with homogeneous Dirichlet boundary conditions.</p>
<p dir="auto">First we have to load the package MinFEM and WriteVTK. The latter is used to write the results in a format suitable for Paraview. We then generate a uniform, triangular 30x30 mesh for the unit square.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MinFEM

mesh = unit_square(30)"><pre><span class="pl-k">using</span> MinFEM

mesh <span class="pl-k">=</span> <span class="pl-c1">unit_square</span>(<span class="pl-c1">30</span>)</pre></div>
<p dir="auto">As an alternative: Download the package from github to obtain the examples and meshes and navigate, within the julia console, to the <strong>examples</strong> folder. Then import one of the mesh files generated with GMSH.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mesh = import_mesh(&quot;../meshes/square.msh&quot;)"><pre>mesh <span class="pl-k">=</span> <span class="pl-c1">import_mesh</span>(<span class="pl-s"><span class="pl-pds">"</span>../meshes/square.msh<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">The next step is to assemble the matrices which discretize the weak formulation:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="L = assemble_laplacian(mesh)
M = assemble_massmatrix(mesh)"><pre>L <span class="pl-k">=</span> <span class="pl-c1">assemble_laplacian</span>(mesh)
M <span class="pl-k">=</span> <span class="pl-c1">assemble_massmatrix</span>(mesh)</pre></div>
<p dir="auto">We now want to set s as an eigenfunction of the Laplacian multiplied with the corresponding eigenvalue:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n=3
m=2
f(x) = ((n*pi)^2 + (m*pi)^2) *sin(n*x[1]*pi)*sin(m*x[2]*pi)
s = evaluate_mesh_function(mesh, f)"><pre>n<span class="pl-k">=</span><span class="pl-c1">3</span>
m<span class="pl-k">=</span><span class="pl-c1">2</span>
<span class="pl-en">f</span>(x) <span class="pl-k">=</span> ((n<span class="pl-k">*</span><span class="pl-c1">pi</span>)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> (m<span class="pl-k">*</span><span class="pl-c1">pi</span>)<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">*</span><span class="pl-c1">sin</span>(n<span class="pl-k">*</span>x[<span class="pl-c1">1</span>]<span class="pl-k">*</span><span class="pl-c1">pi</span>)<span class="pl-k">*</span><span class="pl-c1">sin</span>(m<span class="pl-k">*</span>x[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-c1">pi</span>)
s <span class="pl-k">=</span> <span class="pl-c1">evaluate_mesh_function</span>(mesh, f)</pre></div>
<p dir="auto">The next step is to set up a PDESystem structure, which holds all necessary information for the PDE. These are the stiffness matrix, the load vector, Dirichlet values and indices of the boundary nodes:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="boundary = select_boundaries(mesh, 1001, 1002, 1003, 1004)
boundaryNodes = extract_nodes(boundary)

pde = PDESystem(A=L, b=M*s, bc=zeros(mesh.nnodes), DI=boundaryNodes)"><pre>boundary <span class="pl-k">=</span> <span class="pl-c1">select_boundaries</span>(mesh, <span class="pl-c1">1001</span>, <span class="pl-c1">1002</span>, <span class="pl-c1">1003</span>, <span class="pl-c1">1004</span>)
boundaryNodes <span class="pl-k">=</span> <span class="pl-c1">extract_nodes</span>(boundary)

pde <span class="pl-k">=</span> <span class="pl-c1">PDESystem</span>(A<span class="pl-k">=</span>L, b<span class="pl-k">=</span>M<span class="pl-k">*</span>s, bc<span class="pl-k">=</span><span class="pl-c1">zeros</span>(mesh<span class="pl-k">.</span>nnodes), DI<span class="pl-k">=</span>boundaryNodes)</pre></div>
<p dir="auto">Note that the mesh is designed to have four physical boundaries identified by the indices 1001-1004.</p>
<p dir="auto">Finally, we solve the PDE and write the solution in a file for visualization with Paraview:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="solve!(pde)

write_to_vtk([pde.state, s], mesh, [&quot;Y&quot;,&quot;S&quot;], &quot;poisson&quot;)"><pre><span class="pl-c1">solve!</span>(pde)

<span class="pl-c1">write_to_vtk</span>([pde<span class="pl-k">.</span>state, s], mesh, [<span class="pl-s"><span class="pl-pds">"</span>Y<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>S<span class="pl-pds">"</span></span>], <span class="pl-s"><span class="pl-pds">"</span>poisson<span class="pl-pds">"</span></span>)</pre></div>
</article></div>