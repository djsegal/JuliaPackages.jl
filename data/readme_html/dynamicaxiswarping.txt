<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-dynamicaxiswarpingjl" class="anchor" aria-hidden="true" href="#dynamicaxiswarpingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DynamicAxisWarping.jl</h1>
<p dir="auto"><a href="https://github.com/baggepinnen/DynamicAxisWarping.jl/actions"><img src="https://github.com/baggepinnen/DynamicAxisWarping.jl/workflows/CI/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/baggepinnen/DynamicAxisWarping.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/424b35397cf4ffc54e4beb2f04d68858a99760c3ea5491319b256caf55be6368/68747470733a2f2f636f6465636f762e696f2f67682f626167676570696e6e656e2f44796e616d69634178697357617270696e672e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/baggepinnen/DynamicAxisWarping.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/docs/DynamicAxisWarping/" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="Documentation, latest" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Dynamic Time Warping (DTW), matrix profile and related algorithms in Julia.</p>
<p dir="auto"><a href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="nofollow">Dynamic Time Warping</a> is a method used to compare, or measure the "distance" between two signals. Contrary to, e.g., the Euclidean distance between two signals, which operates point-wise, DTW compares the signals by warping them in time to produce the closest possible match, with the constraint that the warping is monotonic. Underneath the hood, DTW solves an <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="01fe66a4d522554e9471a05a3b46c6b7">$\mathcal{O}(n^2)$</math-renderer> dynamic-programming problem, and can thus be computationally expensive if implemented and used naively. This package attempts at providing a fairly well-optimized implementation, and further supports some well-known tricks to reduce the computational complexity, such as limiting the maximum allowed warping (radius) etc., effectively reducing the complexity to <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="01fe66a4d522554e9471a05a3b46c6b7">$\mathcal{O}(nr)$</math-renderer> where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="01fe66a4d522554e9471a05a3b46c6b7">$r$</math-renderer> is the radius. DTW does not require the two signals under comparison to have the same length, making it a widely applicable measure of (dis)similarity.</p>
<p dir="auto">This package supports arbitrary metrics and arbitrary "spaces", i.e., as long as you are passing a vector or higher dimensional array of something that your distance can operate on, you're good to go. Time is always considered to be the last dimension.</p>
<p dir="auto">This package is registered and can be installed with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
pkg&quot;add DynamicAxisWarping&quot;"><pre><span class="pl-k">using</span> Pkg
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">pkg</span>"</span>add DynamicAxisWarping<span class="pl-pds">"</span></span></pre></div>
<h2 dir="auto">
<a id="user-content-simple-usage" class="anchor" aria-hidden="true" href="#simple-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simple usage</h2>
<p dir="auto">Inputs of dimension larger than 1 will be treated as sequences where time is in the last dimension. When using higher-dimensional series, make sure the provided distance accepts them.</p>
<p dir="auto">Any distance implementing the <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> interface works, as well as functions on the form <code>dist(x,y) -&gt; ℝ</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DynamicAxisWarping, Distances, Plots
cost, i1, i2 = dtw(a,b, [dist=SqEuclidean()]; transportcost = 1)
cost, i1, i2 = fastdtw(a,b, dist, radius) # note https://arxiv.org/abs/2003.11246
cost = dtw_cost(a, b, dist, radius) # Optimized method that only returns cost. Supports early stopping, see docstring. Can be made completely allocation free.

# dtw supports arbitrary upper and lower bound vectors constraining the warping path.
imin,imax = radiuslimits(5,20,20), plot([imin imax])
dtw(a, b, dist, imin, imax) # Cost equivalent to dtw_cost(a, b, dist, 5)

# The Distances.jl interface is supported
d = DTW(radius=5)
d(a,b)"><pre><span class="pl-k">using</span> DynamicAxisWarping, Distances, Plots
cost, i1, i2 <span class="pl-k">=</span> <span class="pl-c1">dtw</span>(a,b, [dist<span class="pl-k">=</span><span class="pl-c1">SqEuclidean</span>()]; transportcost <span class="pl-k">=</span> <span class="pl-c1">1</span>)
cost, i1, i2 <span class="pl-k">=</span> <span class="pl-c1">fastdtw</span>(a,b, dist, radius) <span class="pl-c"><span class="pl-c">#</span> note https://arxiv.org/abs/2003.11246</span>
cost <span class="pl-k">=</span> <span class="pl-c1">dtw_cost</span>(a, b, dist, radius) <span class="pl-c"><span class="pl-c">#</span> Optimized method that only returns cost. Supports early stopping, see docstring. Can be made completely allocation free.</span>

<span class="pl-c"><span class="pl-c">#</span> dtw supports arbitrary upper and lower bound vectors constraining the warping path.</span>
imin,imax <span class="pl-k">=</span> <span class="pl-c1">radiuslimits</span>(<span class="pl-c1">5</span>,<span class="pl-c1">20</span>,<span class="pl-c1">20</span>), <span class="pl-c1">plot</span>([imin imax])
<span class="pl-c1">dtw</span>(a, b, dist, imin, imax) <span class="pl-c"><span class="pl-c">#</span> Cost equivalent to dtw_cost(a, b, dist, 5)</span>

<span class="pl-c"><span class="pl-c">#</span> The Distances.jl interface is supported</span>
d <span class="pl-k">=</span> <span class="pl-c1">DTW</span>(radius<span class="pl-k">=</span><span class="pl-c1">5</span>)
<span class="pl-c1">d</span>(a,b)</pre></div>
<h2 dir="auto">
<a id="user-content-plotting" class="anchor" aria-hidden="true" href="#plotting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Plotting</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="dtwplot(a, b, [dist=SqEuclidean()]; transportcost = 1)
matchplot(a, b, [dist=SqEuclidean()])
matchplot2(a, b, [dist=SqEuclidean()])"><pre><span class="pl-c1">dtwplot</span>(a, b, [dist<span class="pl-k">=</span><span class="pl-c1">SqEuclidean</span>()]; transportcost <span class="pl-k">=</span> <span class="pl-c1">1</span>)
<span class="pl-c1">matchplot</span>(a, b, [dist<span class="pl-k">=</span><span class="pl-c1">SqEuclidean</span>()])
<span class="pl-c1">matchplot2</span>(a, b, [dist<span class="pl-k">=</span><span class="pl-c1">SqEuclidean</span>()])</pre></div>
<p dir="auto">Example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DynamicAxisWarping, Plots

fs = 70
t  = range(0,stop=1,step=1/fs)
y0 = sin.(2pi .*t)
y1 = sin.(3pi .*t)
y  = [y0;y1[2:end]] .+ 0.01 .* randn.()
q  = [y0;y0[2:end]] .+ 0.01 .* randn.()
y[10:15] .+= 0.5
q[13:25] .+= 0.5

f1 = plot([q y])
f2 = dtwplot(q,y,lc=:green, lw=1)
f3 = matchplot(q,y,ds=3,separation=1)
plot(f1,f2,f3, legend=false, layout=3, grid=false)"><pre><span class="pl-k">using</span> DynamicAxisWarping, Plots

fs <span class="pl-k">=</span> <span class="pl-c1">70</span>
t  <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>,stop<span class="pl-k">=</span><span class="pl-c1">1</span>,step<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">/</span>fs)
y0 <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">2pi</span> <span class="pl-k">.*</span>t)
y1 <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">3pi</span> <span class="pl-k">.*</span>t)
y  <span class="pl-k">=</span> [y0;y1[<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">end</span>]] <span class="pl-k">.+</span> <span class="pl-c1">0.01</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.()
q  <span class="pl-k">=</span> [y0;y0[<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">end</span>]] <span class="pl-k">.+</span> <span class="pl-c1">0.01</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.()
y[<span class="pl-c1">10</span><span class="pl-k">:</span><span class="pl-c1">15</span>] <span class="pl-k">.+</span><span class="pl-k">=</span> <span class="pl-c1">0.5</span>
q[<span class="pl-c1">13</span><span class="pl-k">:</span><span class="pl-c1">25</span>] <span class="pl-k">.+</span><span class="pl-k">=</span> <span class="pl-c1">0.5</span>

f1 <span class="pl-k">=</span> <span class="pl-c1">plot</span>([q y])
f2 <span class="pl-k">=</span> <span class="pl-c1">dtwplot</span>(q,y,lc<span class="pl-k">=</span><span class="pl-c1">:green</span>, lw<span class="pl-k">=</span><span class="pl-c1">1</span>)
f3 <span class="pl-k">=</span> <span class="pl-c1">matchplot</span>(q,y,ds<span class="pl-k">=</span><span class="pl-c1">3</span>,separation<span class="pl-k">=</span><span class="pl-c1">1</span>)
<span class="pl-c1">plot</span>(f1,f2,f3, legend<span class="pl-k">=</span><span class="pl-c1">false</span>, layout<span class="pl-k">=</span><span class="pl-c1">3</span>, grid<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="examples/doppler.svg"><img src="examples/doppler.svg" alt="figure" style="max-width: 100%;"></a></p>
<p dir="auto">Example, two-dimension timeseries, simple example</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DynamicAxisWarping, Plots, Distances

# Create signals q(u) ∈ ℜ², y(u) ∈ ℜ²
fs = 70
u  = collect(range(0,stop=1,step=1/fs))
# Create a template query signal
q, tq = [sin.(2pi .* u) cos.(2pi .* u)] .+ 0.01 .* randn.(), u
# Create a similar signal
y = [sin.(3pi .*u)  cos.(3pi .* u)] .+ 0.01 .* randn.()
last_peak = findlast(isapprox.(y[:,2], maximum(y[:,2]),atol=0.05))
y, ty = y[1:last_peak, :], u[1:last_peak]
y[end-10:end,:] .+= q[end-10:end,:]
y[10:13] .+= 0.5

# Plot signals
kws = (;linewidth=3, zlabel=&quot;index&quot;, xlabel=&quot;signal comp. 1&quot;, ylabel=&quot;signal comp. 2&quot;,
	   xticks=-1:1:1, yticks=-1:1:1, asepct_ratio=1, legend=nothing)
cs, cq = theme_palette(:auto).colors.colors[1:2]
orig= plot(eachcol(q)...,1:size(q,1); c=cq, label=&quot;query&quot;, kws...)
plot!(eachcol(y)..., 1:size(y,1) ; c=cs, label=&quot;similar signal&quot;, kws...)

# Warp 2D time signals and visualize
cost, i1, i2 = dtw(y', q', SqEuclidean(); transportcost = 1)
kws=(;kws..., legend=nothing)
warped=plot(eachcol(q[i2,:])..., 1:length(i2); c=cq, label=&quot;query&quot;, kws...);
plot!(eachcol(y[i1,:])..., 1:length(i1); c=cs, label=&quot;signal&quot;, kws..., linewidth=1);
plot(orig, warped)"><pre><span class="pl-k">using</span> DynamicAxisWarping, Plots, Distances

<span class="pl-c"><span class="pl-c">#</span> Create signals q(u) ∈ ℜ², y(u) ∈ ℜ²</span>
fs <span class="pl-k">=</span> <span class="pl-c1">70</span>
u  <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">range</span>(<span class="pl-c1">0</span>,stop<span class="pl-k">=</span><span class="pl-c1">1</span>,step<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">/</span>fs))
<span class="pl-c"><span class="pl-c">#</span> Create a template query signal</span>
q, tq <span class="pl-k">=</span> [<span class="pl-c1">sin</span>.(<span class="pl-c1">2pi</span> <span class="pl-k">.*</span> u) <span class="pl-c1">cos</span>.(<span class="pl-c1">2pi</span> <span class="pl-k">.*</span> u)] <span class="pl-k">.+</span> <span class="pl-c1">0.01</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.(), u
<span class="pl-c"><span class="pl-c">#</span> Create a similar signal</span>
y <span class="pl-k">=</span> [<span class="pl-c1">sin</span>.(<span class="pl-c1">3pi</span> <span class="pl-k">.*</span>u)  <span class="pl-c1">cos</span>.(<span class="pl-c1">3pi</span> <span class="pl-k">.*</span> u)] <span class="pl-k">.+</span> <span class="pl-c1">0.01</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.()
last_peak <span class="pl-k">=</span> <span class="pl-c1">findlast</span>(<span class="pl-c1">isapprox</span>.(y[:,<span class="pl-c1">2</span>], <span class="pl-c1">maximum</span>(y[:,<span class="pl-c1">2</span>]),atol<span class="pl-k">=</span><span class="pl-c1">0.05</span>))
y, ty <span class="pl-k">=</span> y[<span class="pl-c1">1</span><span class="pl-k">:</span>last_peak, :], u[<span class="pl-c1">1</span><span class="pl-k">:</span>last_peak]
y[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">10</span><span class="pl-k">:</span><span class="pl-c1">end</span>,:] <span class="pl-k">.+</span><span class="pl-k">=</span> q[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">10</span><span class="pl-k">:</span><span class="pl-c1">end</span>,:]
y[<span class="pl-c1">10</span><span class="pl-k">:</span><span class="pl-c1">13</span>] <span class="pl-k">.+</span><span class="pl-k">=</span> <span class="pl-c1">0.5</span>

<span class="pl-c"><span class="pl-c">#</span> Plot signals</span>
kws <span class="pl-k">=</span> (;linewidth<span class="pl-k">=</span><span class="pl-c1">3</span>, zlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>index<span class="pl-pds">"</span></span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>signal comp. 1<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>signal comp. 2<span class="pl-pds">"</span></span>,
	   xticks<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, yticks<span class="pl-k">=</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span>, asepct_ratio<span class="pl-k">=</span><span class="pl-c1">1</span>, legend<span class="pl-k">=</span><span class="pl-c1">nothing</span>)
cs, cq <span class="pl-k">=</span> <span class="pl-c1">theme_palette</span>(<span class="pl-c1">:auto</span>)<span class="pl-k">.</span>colors<span class="pl-k">.</span>colors[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>]
orig<span class="pl-k">=</span> <span class="pl-c1">plot</span>(<span class="pl-c1">eachcol</span>(q)<span class="pl-k">...</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(q,<span class="pl-c1">1</span>); c<span class="pl-k">=</span>cq, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>query<span class="pl-pds">"</span></span>, kws<span class="pl-k">...</span>)
<span class="pl-c1">plot!</span>(<span class="pl-c1">eachcol</span>(y)<span class="pl-k">...</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(y,<span class="pl-c1">1</span>) ; c<span class="pl-k">=</span>cs, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>similar signal<span class="pl-pds">"</span></span>, kws<span class="pl-k">...</span>)

<span class="pl-c"><span class="pl-c">#</span> Warp 2D time signals and visualize</span>
cost, i1, i2 <span class="pl-k">=</span> <span class="pl-c1">dtw</span>(y<span class="pl-k">'</span>, q<span class="pl-k">'</span>, <span class="pl-c1">SqEuclidean</span>(); transportcost <span class="pl-k">=</span> <span class="pl-c1">1</span>)
kws<span class="pl-k">=</span>(;kws<span class="pl-k">...</span>, legend<span class="pl-k">=</span><span class="pl-c1">nothing</span>)
warped<span class="pl-k">=</span><span class="pl-c1">plot</span>(<span class="pl-c1">eachcol</span>(q[i2,:])<span class="pl-k">...</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(i2); c<span class="pl-k">=</span>cq, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>query<span class="pl-pds">"</span></span>, kws<span class="pl-k">...</span>);
<span class="pl-c1">plot!</span>(<span class="pl-c1">eachcol</span>(y[i1,:])<span class="pl-k">...</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(i1); c<span class="pl-k">=</span>cs, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>signal<span class="pl-pds">"</span></span>, kws<span class="pl-k">...</span>, linewidth<span class="pl-k">=</span><span class="pl-c1">1</span>);
<span class="pl-c1">plot</span>(orig, warped)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="examples/R2_signals.svg"><img src="examples/R2_signals.svg" alt="figure" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Visualizing matched ℜ² signal points in ℜ²
kws=(;kws..., legend=nothing, ds=3, separation=0, xlabel=&quot;signal comp. 1&quot;, ylabel=&quot;signal comp. 2&quot;)
mp1 = matchplot2(y', q'; kws...)
# Or in ℜ³ with a signal index axis
mp2 = matchplot2(y', q'; showindex=true, zlabel=&quot;warped signal index&quot;, kws...)
plot(mp1, mp2)"><pre><span class="pl-c"><span class="pl-c">#</span> Visualizing matched ℜ² signal points in ℜ²</span>
kws<span class="pl-k">=</span>(;kws<span class="pl-k">...</span>, legend<span class="pl-k">=</span><span class="pl-c1">nothing</span>, ds<span class="pl-k">=</span><span class="pl-c1">3</span>, separation<span class="pl-k">=</span><span class="pl-c1">0</span>, xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>signal comp. 1<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>signal comp. 2<span class="pl-pds">"</span></span>)
mp1 <span class="pl-k">=</span> <span class="pl-c1">matchplot2</span>(y<span class="pl-k">'</span>, q<span class="pl-k">'</span>; kws<span class="pl-k">...</span>)
<span class="pl-c"><span class="pl-c">#</span> Or in ℜ³ with a signal index axis</span>
mp2 <span class="pl-k">=</span> <span class="pl-c1">matchplot2</span>(y<span class="pl-k">'</span>, q<span class="pl-k">'</span>; showindex<span class="pl-k">=</span><span class="pl-c1">true</span>, zlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>warped signal index<span class="pl-pds">"</span></span>, kws<span class="pl-k">...</span>)
<span class="pl-c1">plot</span>(mp1, mp2)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="examples/R2_matchplot_signals.svg"><img src="examples/R2_matchplot_signals.svg" alt="figure" style="max-width: 100%;"></a></p>
<h2 dir="auto">
<a id="user-content-find-a-short-pattern-in-a-long-time-series" class="anchor" aria-hidden="true" href="#find-a-short-pattern-in-a-long-time-series"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Find a short pattern in a long time series</h2>
<p dir="auto">The function <code>dtwnn</code> searches for a pattern in a long time series. By default, it <em>does not normalize</em> the data over each window, to do this, pass, e.g., <code>ZNormalizer</code> as the fifth argument.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DynamicAxisWarping, Distances
radius = 5
a      = sin.(0.1 .* (1:100))     .+ 0.1 .* randn.()
b      = sin.(0.1 .* (1:100_000)) .+ 0.1 .* randn.()
res    = dtwnn(a, b, SqEuclidean(), radius, saveall=false, bsf_multiplier=1) # takes &lt; 0.1s # DynamicAxisWarping.DTWSearchResult(0.4625287975222824, 73452, (prune_end = 79108, prune_env = 0))
plot([a b[eachindex(a) .+ (res.loc-1)]])"><pre><span class="pl-k">using</span> DynamicAxisWarping, Distances
radius <span class="pl-k">=</span> <span class="pl-c1">5</span>
a      <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">0.1</span> <span class="pl-k">.*</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>))     <span class="pl-k">.+</span> <span class="pl-c1">0.1</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.()
b      <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">0.1</span> <span class="pl-k">.*</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100_000</span>)) <span class="pl-k">.+</span> <span class="pl-c1">0.1</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.()
res    <span class="pl-k">=</span> <span class="pl-c1">dtwnn</span>(a, b, <span class="pl-c1">SqEuclidean</span>(), radius, saveall<span class="pl-k">=</span><span class="pl-c1">false</span>, bsf_multiplier<span class="pl-k">=</span><span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> takes &lt; 0.1s # DynamicAxisWarping.DTWSearchResult(0.4625287975222824, 73452, (prune_end = 79108, prune_env = 0))</span>
<span class="pl-c1">plot</span>([a b[<span class="pl-c1">eachindex</span>(a) <span class="pl-k">.+</span> (res<span class="pl-k">.</span>loc<span class="pl-k">-</span><span class="pl-c1">1</span>)]])</pre></div>
<ul dir="auto">
<li>
<code>saveall</code> causes the entire distance profile to be computed. This will take longer time to compute. It is stored in <code>res.dists</code>.</li>
<li>
<code>bsf_multiplier = 1</code>: If &gt; 1, require lower bound to exceed <code>bsf_multiplier*best_so_far</code>. This allows you to find several nearby points without having to compute the entire distance profile.</li>
<li>Available normalizers are: <code>ZNormalizer, DiagonalZNormalizer, NormNormalizer</code>
</li>
</ul>
<h3 dir="auto">
<a id="user-content-multi-threaded-search" class="anchor" aria-hidden="true" href="#multi-threaded-search"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multi-threaded search</h3>
<p dir="auto">Below is an example of how several long series <code>y ∈ Y</code> can be searched for the occurance of query <code>q</code> in a multithreaded fashion, using <code>tmap</code> from <a href="https://github.com/baggepinnen/ThreadTools.jl">ThreadTools.jl</a>. In this example, we first create a unique workspace object for each thread to save on allocations</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ThreadTools
const workspaces = map(1:Threads.nthreads()) do i
    DTWWorkspace(q, dist, radius)
end
@time results = tmap(Y) do y
    dtwnn(workspaces[Threads.threadid()], y, showprogress = false)
end
mincost, minind = findmin(results) # special method for Vector{DTWSearchResult}"><pre><span class="pl-k">using</span> ThreadTools
<span class="pl-k">const</span> workspaces <span class="pl-k">=</span> <span class="pl-c1">map</span>(<span class="pl-c1">1</span><span class="pl-k">:</span>Threads<span class="pl-k">.</span><span class="pl-c1">nthreads</span>()) <span class="pl-k">do</span> i
    <span class="pl-c1">DTWWorkspace</span>(q, dist, radius)
<span class="pl-k">end</span>
<span class="pl-c1">@time</span> results <span class="pl-k">=</span> <span class="pl-c1">tmap</span>(Y) <span class="pl-k">do</span> y
    <span class="pl-c1">dtwnn</span>(workspaces[Threads<span class="pl-k">.</span><span class="pl-c1">threadid</span>()], y, showprogress <span class="pl-k">=</span> <span class="pl-c1">false</span>)
<span class="pl-k">end</span>
mincost, minind <span class="pl-k">=</span> <span class="pl-c1">findmin</span>(results) <span class="pl-c"><span class="pl-c">#</span> special method for Vector{DTWSearchResult}</span></pre></div>
<h3 dir="auto">
<a id="user-content-optimizations" class="anchor" aria-hidden="true" href="#optimizations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Optimizations</h3>
<p dir="auto">The following optimizations are implemented.</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Endpoint lower bound pruning</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Envelope lower bound pruning</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> DTW early termination</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> Online normalization (see <code>ZNormalizer</code>)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> Sorting of query series</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> All algorithms operate on arbitrary precision numbers. If you pass them <code>Float32</code> instead of <code>Float64</code>, they can become up to twice as fast.</li>
</ul>
<p dir="auto"><code>dtwnn</code> is fairly performant, below is a small benchmark performed on a 2014 laptop</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="a = sin.(0.1f0 .* (1:100))    .+ 0.1f0 .* randn.(Float32)
b = sin.(0.1f0 .* (1:1000_000)) .+ 0.1f0 .* randn.(Float32)
@btime dtwnn($a, $b, SqEuclidean(), 5, ZNormalizer, prune_endpoints = true, prune_envelope = true)
# 853.336 ms (25519 allocations: 5.00 MiB)"><pre>a <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">0.1f0</span> <span class="pl-k">.*</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>))    <span class="pl-k">.+</span> <span class="pl-c1">0.1f0</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.(Float32)
b <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">0.1f0</span> <span class="pl-k">.*</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1000_000</span>)) <span class="pl-k">.+</span> <span class="pl-c1">0.1f0</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.(Float32)
<span class="pl-c1">@btime</span> <span class="pl-c1">dtwnn</span>(<span class="pl-k">$</span>a, <span class="pl-k">$</span>b, <span class="pl-c1">SqEuclidean</span>(), <span class="pl-c1">5</span>, ZNormalizer, prune_endpoints <span class="pl-k">=</span> <span class="pl-c1">true</span>, prune_envelope <span class="pl-k">=</span> <span class="pl-c1">true</span>)
<span class="pl-c"><span class="pl-c">#</span> 853.336 ms (25519 allocations: 5.00 MiB)</span></pre></div>
<h2 dir="auto">
<a id="user-content-differentiable-soft-dtw" class="anchor" aria-hidden="true" href="#differentiable-soft-dtw"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Differentiable Soft-DTW</h2>
<p dir="auto">The <a href="https://arxiv.org/pdf/1703.01541.pdf" rel="nofollow">Soft-DTW</a> algorithm is provided through the function</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="soft_dtw_cost(a, b, [SqEuclidean()]; γ = 1, transportcost = 1)"><pre><span class="pl-c1">soft_dtw_cost</span>(a, b, [<span class="pl-c1">SqEuclidean</span>()]; γ <span class="pl-k">=</span> <span class="pl-c1">1</span>, transportcost <span class="pl-k">=</span> <span class="pl-c1">1</span>)</pre></div>
<p dir="auto"><code>γ</code> is the smoothing parameters and a smaller value of <code>γ</code> makes the distance closer to the standard DTW distance.</p>
<p dir="auto">To differentiate w.r.t. the first argument, try</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ReverseDiff
da = ReverseDiff.gradient(a-&gt;soft_dtw_cost(a,b; γ=1), a)"><pre><span class="pl-k">using</span> ReverseDiff
da <span class="pl-k">=</span> ReverseDiff<span class="pl-k">.</span><span class="pl-c1">gradient</span>(a<span class="pl-k">-&gt;</span><span class="pl-c1">soft_dtw_cost</span>(a,b; γ<span class="pl-k">=</span><span class="pl-c1">1</span>), a)</pre></div>
<p dir="auto">Zygote.jl will not work due to the array-mutation limitation.
See also function <code>soft_dtw_cost_matrix</code>.</p>
<p dir="auto">The following <a href="https://github.com/baggepinnen/DynamicAxisWarping.jl/blob/master/examples/softDTW.jl">example</a> illustrates how to calculate a barycenter (generalized average) using Soft DTW and <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>, the result is shown below, together with three instances of the input series</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="examples/barycenter.svg"><img src="examples/barycenter.svg" alt="barycenter" style="max-width: 100%;"></a></p>
<h2 dir="auto">
<a id="user-content-generalized-dtw" class="anchor" aria-hidden="true" href="#generalized-dtw"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Generalized DTW</h2>
<p dir="auto">The <code>gdtw</code> function implements the algorithm from <a href="https://arxiv.org/abs/1905.12893" rel="nofollow"><em>A General Optimization Framework for Dynamic Time Warping</em></a>, which takes two continuous-time signals <code>x</code> and <code>y</code> on the interval <code>[0,1]</code>, and warps them by means of warping functions <code>ϕ, ψ</code>, so that <code>x ∘ ϕ ≈ y ∘ ψ</code>, where either
<code>ψ(s) = 2s - ϕ(s)</code> (both signals warped symmetrically, the default), or <code>ψ(s)=s</code> (only the <code>x</code> signal is warped). The method allows regularization by imposing penalties on <code>ϕ(t) - t</code> (the "cumulative warping") and on <code>ϕ'(t) - 1</code> (the "instantaneous warping").</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra
ts = range(0, stop=4π, length=128)
x = LinearInterpolation(sin.(ts) .+ 0.1 .* randn.())
y = LinearInterpolation(sin.(1.1 .* ts))

norm(x.(ts) - y.(ts)) # 1.7184237220575787

cost, ϕ, ψ = gdtw(x,y)

norm(x.(ϕ.(ts)) - y.(ψ.(ts))) # 0.9266090849096682
"><pre><span class="pl-k">using</span> LinearAlgebra
ts <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, stop<span class="pl-k">=</span><span class="pl-c1">4</span>π, length<span class="pl-k">=</span><span class="pl-c1">128</span>)
x <span class="pl-k">=</span> <span class="pl-c1">LinearInterpolation</span>(<span class="pl-c1">sin</span>.(ts) <span class="pl-k">.+</span> <span class="pl-c1">0.1</span> <span class="pl-k">.*</span> <span class="pl-c1">randn</span>.())
y <span class="pl-k">=</span> <span class="pl-c1">LinearInterpolation</span>(<span class="pl-c1">sin</span>.(<span class="pl-c1">1.1</span> <span class="pl-k">.*</span> ts))

<span class="pl-c1">norm</span>(<span class="pl-c1">x</span>.(ts) <span class="pl-k">-</span> <span class="pl-c1">y</span>.(ts)) <span class="pl-c"><span class="pl-c">#</span> 1.7184237220575787</span>

cost, ϕ, ψ <span class="pl-k">=</span> <span class="pl-c1">gdtw</span>(x,y)

<span class="pl-c1">norm</span>(<span class="pl-c1">x</span>.(<span class="pl-c1">ϕ</span>.(ts)) <span class="pl-k">-</span> <span class="pl-c1">y</span>.(<span class="pl-c1">ψ</span>.(ts))) <span class="pl-c"><span class="pl-c">#</span> 0.9266090849096682</span>
</pre></div>
<h2 dir="auto">
<a id="user-content-clustering-and-barycenter-averaging" class="anchor" aria-hidden="true" href="#clustering-and-barycenter-averaging"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Clustering and barycenter averaging</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="barycenter = dba(vector_of_arrays)
result     = dbaclust(data, nclust, DTW())"><pre>barycenter <span class="pl-k">=</span> <span class="pl-c1">dba</span>(vector_of_arrays)
result     <span class="pl-k">=</span> <span class="pl-c1">dbaclust</span>(data, nclust, <span class="pl-c1">DTW</span>())</pre></div>
<p dir="auto">Note that <code>dba</code> is known to not always produce the best barycenters. See, e.g., <code>soft_dtw_cost</code> above and <a href="https://arxiv.org/pdf/1703.01541.pdf" rel="nofollow">"Soft-DTW: a Differentiable Loss Function for Time-Series"</a> or <a href="https://arxiv.org/pdf/1910.03860.pdf" rel="nofollow">"Spatio-Temporal Alignments: Optimal transport through space and time"</a> for a method that produces better barycenters at the expense of a much higher computational cost.</p>
<h2 dir="auto">
<a id="user-content-sparse-distance-matrix" class="anchor" aria-hidden="true" href="#sparse-distance-matrix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sparse distance matrix</h2>
<p dir="auto">The early termination and some of the stopping heuristics can be used to efficiently calculate a sparse distance matrix where only the k nearest neighbors are fully caluclated and stored. To this end, we have the function</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="dists, inds = sparse_distmat(y::Vector{Vector}, k, dist, radius)"><pre>dists, inds <span class="pl-k">=</span> <span class="pl-c1">sparse_distmat</span>(y<span class="pl-k">::</span><span class="pl-c1">Vector{Vector}</span>, k, dist, radius)</pre></div>
<h2 dir="auto">
<a id="user-content-matrix-profile" class="anchor" aria-hidden="true" href="#matrix-profile"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Matrix Profile</h2>
<p dir="auto">This package defines specialized methods for <a href="https://github.com/baggepinnen/MatrixProfile.jl"><code>MatrixProfile</code></a><code>.matrix_profile</code>, making use of early stopping to accelerate the computation of the matrix profile. The interface is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="profile = matrix_profile(y, m, DTW(radius, [transportcost]))"><pre>profile <span class="pl-k">=</span> <span class="pl-c1">matrix_profile</span>(y, m, <span class="pl-c1">DTW</span>(radius, [transportcost]))</pre></div>
<h2 dir="auto">
<a id="user-content-transportcost" class="anchor" aria-hidden="true" href="#transportcost"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>transportcost</code>
</h2>
<p dir="auto"><code>transportcost</code> adds an additional penalty multiplier for "transporting", i.e., deviations from the Euclidean matching. The standard DTW distance does not consider this added cost and the default is 1. A value greater than 1 multiplies the cost of moving horizontally or vertically in the coupling matrix, promoting a diagonal move, corresponding to the standard Euclidean matching. The influence of the transport cost can be visualized with</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="a = sin.(1:100); b = sin.(1:100) .+ randn.();
dtwplot(a,b, transportcost=1)    # Default
dtwplot(a,b, transportcost=1.01) # Should be &quot;more diagonal&quot;
dtwplot(a,b, transportcost=1.1)  # Should be almost completely diagonal"><pre>a <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>); b <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>) <span class="pl-k">.+</span> <span class="pl-c1">randn</span>.();
<span class="pl-c1">dtwplot</span>(a,b, transportcost<span class="pl-k">=</span><span class="pl-c1">1</span>)    <span class="pl-c"><span class="pl-c">#</span> Default</span>
<span class="pl-c1">dtwplot</span>(a,b, transportcost<span class="pl-k">=</span><span class="pl-c1">1.01</span>) <span class="pl-c"><span class="pl-c">#</span> Should be "more diagonal"</span>
<span class="pl-c1">dtwplot</span>(a,b, transportcost<span class="pl-k">=</span><span class="pl-c1">1.1</span>)  <span class="pl-c"><span class="pl-c">#</span> Should be almost completely diagonal</span></pre></div>
<p dir="auto">You can try a <code>transportcost &lt; 1</code> as well, but then it is preferable to make weird alignments and I'm not sure how much sense that would make.</p>
<p dir="auto">See also the keyword argument <code>postprocess</code> that allows you to pass a function <code>D_modified = f(D)</code> that is used to filter/post-process the cost matrix. Low-pass filtering can be used to effectively remove small-scale warping.</p>
<h2 dir="auto">
<a id="user-content-combine-with-optimal-transport" class="anchor" aria-hidden="true" href="#combine-with-optimal-transport"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Combine with optimal transport</h2>
<p dir="auto">The distance between two datapoints can be any distance supporting the <a href="https://github.com/JuliaStats/Distances.jl/">Distances.jl</a> interface.</p>
<p dir="auto">See the file <a href="https://github.com/baggepinnen/DynamicAxisWarping.jl/blob/master/examples/frequency_warping.jl"><code>frequency_warping.jl</code></a> (<a href="https://nbviewer.jupyter.org/github/baggepinnen/julia_examples/blob/master/frequency_warping.ipynb" rel="nofollow">notebook</a>) for an example combining dynamic time warping with optimal transport along the frequency axis for spectrograms. This example makes use of <a href="https://github.com/baggepinnen/SpectralDistances.jl">SpectralDistances.jl</a>.</p>
<h2 dir="auto">
<a id="user-content-distancesjl-interface" class="anchor" aria-hidden="true" href="#distancesjl-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Distances.jl interface</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d = DTW(radius=radius, dist=SqEuclidean()) # Or FastDTW / SoftDTW
d(a,b)"><pre>d <span class="pl-k">=</span> <span class="pl-c1">DTW</span>(radius<span class="pl-k">=</span>radius, dist<span class="pl-k">=</span><span class="pl-c1">SqEuclidean</span>()) <span class="pl-c"><span class="pl-c">#</span> Or FastDTW / SoftDTW</span>
<span class="pl-c1">d</span>(a,b)</pre></div>
<h2 dir="auto">
<a id="user-content-signal-alignment" class="anchor" aria-hidden="true" href="#signal-alignment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Signal alignment</h2>
<p dir="auto">See <a href="https://github.com/baggepinnen/SignalAlignment.jl">SignalAlignment.jl</a> which uses this package to align out-of-sync signals and signals with different sample rates.</p>
<h2 dir="auto">
<a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgements</h2>
<p dir="auto">This package is a fork of <a href="https://github.com/ahwillia/TimeWarp.jl">https://github.com/ahwillia/TimeWarp.jl</a> which is no longer maintained.</p>
<p dir="auto">Special thanks to Joseph Fowler (<a href="https://github.com/joefowler">@joefowler</a>) who contributed a substantial portion of the initial code for TimeWarp.jl</p>
</article></div>