<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-delaunay--dəlɔˈnɛ--find-the-delaunay-triangulation-for-a-set-of-points" class="anchor" aria-hidden="true" href="#delaunay--dəlɔˈnɛ--find-the-delaunay-triangulation-for-a-set-of-points"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Delaunay / də lɔˈnɛ /: Find the Delaunay triangulation for a set of points</h1>
<ul dir="auto">
<li><a href="https://github.com/eschnett/Delaunay.jl">GitHub</a>: Source code
repository</li>
<li><a href="https://github.com/eschnett/Delaunay.jl/actions"><img src="https://github.com/eschnett/Delaunay.jl/workflows/CI/badge.svg" alt="GitHub CI" style="max-width: 100%;"></a></li>
</ul>
<p dir="auto">This package finds the <a href="https://en.wikipedia.org/wiki/Delaunay_triangulation" rel="nofollow">Delaunay
triangulation</a>
for a set of points in arbitrary dimensions. It uses the Python
package
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.html" rel="nofollow"><code>scipy.spatial.Delaunay</code></a>
to perform the actual calculation.</p>
<p dir="auto">This package is inspired by
<a href="https://github.com/JuliaPolyhedra/QHull.jl">QHull.jl</a>, which uses the
same Python library.</p>
<h2 dir="auto"><a id="user-content-example-in-2d" class="anchor" aria-hidden="true" href="#example-in-2d"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example in 2D</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Delaunay
points = rand(10, 2)
mesh = delaunay(points)

mesh.points                      # the points
mesh.simplices                   # the simplices (triangles in 2d)
mesh.neighbors                   # neighbouring simplices of a simplex
mesh.vertex_to_simplex           # find a simplex for a point
mesh.convex_hull                 # convex hull of the domain
mesh.vertex_neighbor_vertices    # neighbouring vertices of a vertex

using GLMakie # or CairoMakie/WGLMakie/RPRMakie
color = rand(size(mesh.points, 1))
fig, ax, pl = Makie.poly(mesh.points, mesh.simplices, color=color, strokewidth=2, figure=(resolution=(800, 400),))
points = randn(100, 2)
mesh = delaunay(points)
color = rand(size(mesh.points, 1))
poly(fig[1, 2], mesh.points, mesh.simplices, color=color, strokewidth=2)
save(&quot;delaunay2d.png&quot;, fig) "><pre><span class="pl-k">using</span> Delaunay
points <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10</span>, <span class="pl-c1">2</span>)
mesh <span class="pl-k">=</span> <span class="pl-c1">delaunay</span>(points)

mesh<span class="pl-k">.</span>points                      <span class="pl-c"><span class="pl-c">#</span> the points</span>
mesh<span class="pl-k">.</span>simplices                   <span class="pl-c"><span class="pl-c">#</span> the simplices (triangles in 2d)</span>
mesh<span class="pl-k">.</span>neighbors                   <span class="pl-c"><span class="pl-c">#</span> neighbouring simplices of a simplex</span>
mesh<span class="pl-k">.</span>vertex_to_simplex           <span class="pl-c"><span class="pl-c">#</span> find a simplex for a point</span>
mesh<span class="pl-k">.</span>convex_hull                 <span class="pl-c"><span class="pl-c">#</span> convex hull of the domain</span>
mesh<span class="pl-k">.</span>vertex_neighbor_vertices    <span class="pl-c"><span class="pl-c">#</span> neighbouring vertices of a vertex</span>

<span class="pl-k">using</span> GLMakie <span class="pl-c"><span class="pl-c">#</span> or CairoMakie/WGLMakie/RPRMakie</span>
color <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">size</span>(mesh<span class="pl-k">.</span>points, <span class="pl-c1">1</span>))
fig, ax, pl <span class="pl-k">=</span> Makie<span class="pl-k">.</span><span class="pl-c1">poly</span>(mesh<span class="pl-k">.</span>points, mesh<span class="pl-k">.</span>simplices, color<span class="pl-k">=</span>color, strokewidth<span class="pl-k">=</span><span class="pl-c1">2</span>, figure<span class="pl-k">=</span>(resolution<span class="pl-k">=</span>(<span class="pl-c1">800</span>, <span class="pl-c1">400</span>),))
points <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">100</span>, <span class="pl-c1">2</span>)
mesh <span class="pl-k">=</span> <span class="pl-c1">delaunay</span>(points)
color <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">size</span>(mesh<span class="pl-k">.</span>points, <span class="pl-c1">1</span>))
<span class="pl-c1">poly</span>(fig[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], mesh<span class="pl-k">.</span>points, mesh<span class="pl-k">.</span>simplices, color<span class="pl-k">=</span>color, strokewidth<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-c1">save</span>(<span class="pl-s"><span class="pl-pds">"</span>delaunay2d.png<span class="pl-pds">"</span></span>, fig) </pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/1010467/167169390-4c6b80b5-1370-424c-a495-8413996bdf68.png"><img src="https://user-images.githubusercontent.com/1010467/167169390-4c6b80b5-1370-424c-a495-8413996bdf68.png" alt="delaunay2d" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-example-in-3d" class="anchor" aria-hidden="true" href="#example-in-3d"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example in 3D</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Delaunay
points = rand(100, 3)
mesh = delaunay(points)

using GeometryBasics
# Convert to tetrahedra faces
tetras = [GeometryBasics.TetrahedronFace(mesh.simplices[i, :]...) for i in 1:size(mesh.simplices, 1)]
points = Makie.to_vertices(mesh.points) # Use Makie to convert to Vector{Point3f}
m = GeometryBasics.Mesh(points, tetras) # create tetrahedra mesh
# Triangulate it, since Makie's mesh conversion currently doesn't handle tetrahedras itself 
tris = GeometryBasics.triangle_mesh(m)
fig, ax, pl = Makie.mesh(tris, color=rand(length(tris.position)), colormap=(:viridis, 0.5), transparency=true)
# add wireframe plot, which actually supports tetrahedras...
wireframe!(ax, m, color=:white, transparency=true)
save(&quot;delaunay3d.png&quot;, fig)"><pre><span class="pl-k">using</span> Delaunay
points <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">3</span>)
mesh <span class="pl-k">=</span> <span class="pl-c1">delaunay</span>(points)

<span class="pl-k">using</span> GeometryBasics
<span class="pl-c"><span class="pl-c">#</span> Convert to tetrahedra faces</span>
tetras <span class="pl-k">=</span> [GeometryBasics<span class="pl-k">.</span><span class="pl-c1">TetrahedronFace</span>(mesh<span class="pl-k">.</span>simplices[i, :]<span class="pl-k">.</span><span class="pl-k">..</span>) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">size</span>(mesh<span class="pl-k">.</span>simplices, <span class="pl-c1">1</span>)]
points <span class="pl-k">=</span> Makie<span class="pl-k">.</span><span class="pl-c1">to_vertices</span>(mesh<span class="pl-k">.</span>points) <span class="pl-c"><span class="pl-c">#</span> Use Makie to convert to Vector{Point3f}</span>
m <span class="pl-k">=</span> GeometryBasics<span class="pl-k">.</span><span class="pl-c1">Mesh</span>(points, tetras) <span class="pl-c"><span class="pl-c">#</span> create tetrahedra mesh</span>
<span class="pl-c"><span class="pl-c">#</span> Triangulate it, since Makie's mesh conversion currently doesn't handle tetrahedras itself </span>
tris <span class="pl-k">=</span> GeometryBasics<span class="pl-k">.</span><span class="pl-c1">triangle_mesh</span>(m)
fig, ax, pl <span class="pl-k">=</span> Makie<span class="pl-k">.</span><span class="pl-c1">mesh</span>(tris, color<span class="pl-k">=</span><span class="pl-c1">rand</span>(<span class="pl-c1">length</span>(tris<span class="pl-k">.</span>position)), colormap<span class="pl-k">=</span>(<span class="pl-c1">:viridis</span>, <span class="pl-c1">0.5</span>), transparency<span class="pl-k">=</span><span class="pl-c1">true</span>)
<span class="pl-c"><span class="pl-c">#</span> add wireframe plot, which actually supports tetrahedras...</span>
<span class="pl-c1">wireframe!</span>(ax, m, color<span class="pl-k">=</span><span class="pl-c1">:white</span>, transparency<span class="pl-k">=</span><span class="pl-c1">true</span>)
<span class="pl-c1">save</span>(<span class="pl-s"><span class="pl-pds">"</span>delaunay3d.png<span class="pl-pds">"</span></span>, fig)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/1010467/167170353-4b27537a-e3e7-4df7-9eb2-c49229b0f70d.png"><img src="https://user-images.githubusercontent.com/1010467/167170353-4b27537a-e3e7-4df7-9eb2-c49229b0f70d.png" alt="delaunay3d" style="max-width: 100%;"></a></p>
<p dir="auto">The test cases contain also examples in higher dimensions.</p>
</article></div>