<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-the-nlopt-module-for-julia" class="anchor" aria-hidden="true" href="#the-nlopt-module-for-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The NLopt module for Julia</h1>
<p dir="auto"><a href="https://github.com/JuliaOpt/NLopt.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaOpt/NLopt.jl/workflows/CI/badge.svg" alt="CI" style="max-width: 100%;"></a></p>
<p dir="auto">This module provides a <a href="http://julialang.org/" rel="nofollow">Julia-language</a> interface to
the free/open-source <a href="http://ab-initio.mit.edu/nlopt" rel="nofollow">NLopt library</a> for
nonlinear optimization. NLopt provides a common interface for many different
optimization algorithms, including:</p>
<ul dir="auto">
<li>Both global and local optimization</li>
<li>Algorithms using function values only (derivative-free) and also algorithms
exploiting user-supplied gradients.</li>
<li>Algorithms for unconstrained optimization, bound-constrained optimization,
and general nonlinear inequality/equality constraints.</li>
</ul>
<p dir="auto">See the <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Introduction" rel="nofollow">NLopt introduction</a>
for a further overview of the types of problems it addresses.</p>
<p dir="auto">NLopt can be used either by accessing it's specialized API or by using the generic <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface</a> or <a href="https://github.com/JuliaOpt/MathProgBase.jl">MathProgBase</a> interfaces for nonlinear
optimization. Both methods are documented below.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Within Julia, you can install the NLopt.jl package with the package manager: <code>Pkg.add("NLopt")</code></p>
<p dir="auto">On Windows and OS X platforms, NLopt binaries will be automatically installed.
On other platforms, Julia will attempt to build NLopt from source;
be sure to have a compiler installed.</p>
<h2 dir="auto"><a id="user-content-using-with-mathoptinterface" class="anchor" aria-hidden="true" href="#using-with-mathoptinterface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using with MathOptInterface</h2>
<p dir="auto">NLopt implements the <a href="https://jump.dev/MathOptInterface.jl/stable/reference/nonlinear/" rel="nofollow">MathOptInterface interface</a> for nonlinear optimization, which means that it can be used interchangeably with other optimization packages from modeling packages like <a href="https://github.com/jump-dev/JuMP.jl">JuMP</a> or when providing hand-written derivatives. Note that NLopt does not exploit sparsity of Jacobians.</p>
<p dir="auto">The NLopt solver is named <code>NLopt.Optimizer</code> and takes parameters:</p>
<ul dir="auto">
<li><code>algorithm</code></li>
<li><code>stopval</code></li>
<li><code>ftol_rel</code></li>
<li><code>ftol_abs</code></li>
<li><code>xtol_rel</code></li>
<li><code>xtol_abs</code></li>
<li><code>constrtol_abs</code></li>
<li><code>maxeval</code></li>
<li><code>maxtime</code></li>
<li><code>initial_step</code></li>
<li><code>population</code></li>
<li><code>seed</code></li>
<li><code>vector_storage</code></li>
</ul>
<p dir="auto">The <code>algorithm</code> parameter is required, and all others are optional. The meaning and acceptable values of all parameters, except <code>constrtol_abs</code>, match the descriptions below from the specialized NLopt API. The <code>constrtol_abs</code> parameter is an absolute feasibility tolerance applied to all constraints.</p>
<h2 dir="auto"><a id="user-content-tutorial" class="anchor" aria-hidden="true" href="#tutorial"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorial</h2>
<p dir="auto">The following example code solves the nonlinearly constrained minimization
problem from the <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Tutorial" rel="nofollow">NLopt Tutorial</a>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using NLopt

function myfunc(x::Vector, grad::Vector)
    if length(grad) &gt; 0
        grad[1] = 0
        grad[2] = 0.5/sqrt(x[2])
    end
    return sqrt(x[2])
end

function myconstraint(x::Vector, grad::Vector, a, b)
    if length(grad) &gt; 0
        grad[1] = 3a * (a*x[1] + b)^2
        grad[2] = -1
    end
    (a*x[1] + b)^3 - x[2]
end

opt = Opt(:LD_MMA, 2)
opt.lower_bounds = [-Inf, 0.]
opt.xtol_rel = 1e-4

opt.min_objective = myfunc
inequality_constraint!(opt, (x,g) -&gt; myconstraint(x,g,2,0), 1e-8)
inequality_constraint!(opt, (x,g) -&gt; myconstraint(x,g,-1,1), 1e-8)

(minf,minx,ret) = optimize(opt, [1.234, 5.678])
numevals = opt.numevals # the number of function evaluations
println(&quot;got $minf at $minx after $numevals iterations (returned $ret)&quot;)"><pre><span class="pl-k">using</span> NLopt

<span class="pl-k">function</span> <span class="pl-en">myfunc</span>(x<span class="pl-k">::</span><span class="pl-c1">Vector</span>, grad<span class="pl-k">::</span><span class="pl-c1">Vector</span>)
    <span class="pl-k">if</span> <span class="pl-c1">length</span>(grad) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
        grad[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span>
        grad[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">0.5</span><span class="pl-k">/</span><span class="pl-c1">sqrt</span>(x[<span class="pl-c1">2</span>])
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> <span class="pl-c1">sqrt</span>(x[<span class="pl-c1">2</span>])
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">myconstraint</span>(x<span class="pl-k">::</span><span class="pl-c1">Vector</span>, grad<span class="pl-k">::</span><span class="pl-c1">Vector</span>, a, b)
    <span class="pl-k">if</span> <span class="pl-c1">length</span>(grad) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
        grad[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">3</span>a <span class="pl-k">*</span> (a<span class="pl-k">*</span>x[<span class="pl-c1">1</span>] <span class="pl-k">+</span> b)<span class="pl-k">^</span><span class="pl-c1">2</span>
        grad[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
    <span class="pl-k">end</span>
    (a<span class="pl-k">*</span>x[<span class="pl-c1">1</span>] <span class="pl-k">+</span> b)<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]
<span class="pl-k">end</span>

opt <span class="pl-k">=</span> <span class="pl-c1">Opt</span>(<span class="pl-c1">:LD_MMA</span>, <span class="pl-c1">2</span>)
opt<span class="pl-k">.</span>lower_bounds <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">Inf</span>, <span class="pl-c1">0.</span>]
opt<span class="pl-k">.</span>xtol_rel <span class="pl-k">=</span> <span class="pl-c1">1e-4</span>

opt<span class="pl-k">.</span>min_objective <span class="pl-k">=</span> myfunc
<span class="pl-c1">inequality_constraint!</span>(opt, (x,g) <span class="pl-k">-&gt;</span> <span class="pl-c1">myconstraint</span>(x,g,<span class="pl-c1">2</span>,<span class="pl-c1">0</span>), <span class="pl-c1">1e-8</span>)
<span class="pl-c1">inequality_constraint!</span>(opt, (x,g) <span class="pl-k">-&gt;</span> <span class="pl-c1">myconstraint</span>(x,g,<span class="pl-k">-</span><span class="pl-c1">1</span>,<span class="pl-c1">1</span>), <span class="pl-c1">1e-8</span>)

(minf,minx,ret) <span class="pl-k">=</span> <span class="pl-c1">optimize</span>(opt, [<span class="pl-c1">1.234</span>, <span class="pl-c1">5.678</span>])
numevals <span class="pl-k">=</span> opt<span class="pl-k">.</span>numevals <span class="pl-c"><span class="pl-c">#</span> the number of function evaluations</span>
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>got <span class="pl-v">$minf</span> at <span class="pl-v">$minx</span> after <span class="pl-v">$numevals</span> iterations (returned <span class="pl-v">$ret</span>)<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">The output should be:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="got 0.5443310476200902 at [0.3333333346933468,0.29629628940318486] after 11 iterations (returned XTOL_REACHED)"><pre class="notranslate"><code>got 0.5443310476200902 at [0.3333333346933468,0.29629628940318486] after 11 iterations (returned XTOL_REACHED)
</code></pre></div>
<p dir="auto">Much like the NLopt interfaces in other languages, you create an
<code>Opt</code> object (analogous to <code>nlopt_opt</code> in C) which encapsulates the
dimensionality of your problem (here, 2) and the algorithm to be used
(here, <code>LD_MMA</code>) and use various functions to specify the constraints
and stopping criteria (along with any other aspects of the problem).</p>
<p dir="auto">The same problem can be solved by using the JuMP interface to NLopt:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP
using NLopt

model = Model(NLopt.Optimizer)
set_optimizer_attribute(model, &quot;algorithm&quot;, :LD_MMA)

a1 = 2
b1 = 0
a2 = -1
b2 = 1

@variable(model, x1)
@variable(model, x2 &gt;= 0)

@NLobjective(model, Min, sqrt(x2))
@NLconstraint(model, x2 &gt;= (a1*x1+b1)^3)
@NLconstraint(model, x2 &gt;= (a2*x1+b2)^3)

set_start_value(x1, 1.234)
set_start_value(x2, 5.678)

JuMP.optimize!(model)

println(&quot;got &quot;, objective_value(model), &quot; at &quot;, [value(x1), value(x2)])"><pre><span class="pl-k">using</span> JuMP
<span class="pl-k">using</span> NLopt

model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(NLopt<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">set_optimizer_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>algorithm<span class="pl-pds">"</span></span>, <span class="pl-c1">:LD_MMA</span>)

a1 <span class="pl-k">=</span> <span class="pl-c1">2</span>
b1 <span class="pl-k">=</span> <span class="pl-c1">0</span>
a2 <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
b2 <span class="pl-k">=</span> <span class="pl-c1">1</span>

<span class="pl-c1">@variable</span>(model, x1)
<span class="pl-c1">@variable</span>(model, x2 <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>)

<span class="pl-c1">@NLobjective</span>(model, Min, <span class="pl-c1">sqrt</span>(x2))
<span class="pl-c1">@NLconstraint</span>(model, x2 <span class="pl-k">&gt;=</span> (a1<span class="pl-k">*</span>x1<span class="pl-k">+</span>b1)<span class="pl-k">^</span><span class="pl-c1">3</span>)
<span class="pl-c1">@NLconstraint</span>(model, x2 <span class="pl-k">&gt;=</span> (a2<span class="pl-k">*</span>x1<span class="pl-k">+</span>b2)<span class="pl-k">^</span><span class="pl-c1">3</span>)

<span class="pl-c1">set_start_value</span>(x1, <span class="pl-c1">1.234</span>)
<span class="pl-c1">set_start_value</span>(x2, <span class="pl-c1">5.678</span>)

JuMP<span class="pl-k">.</span><span class="pl-c1">optimize!</span>(model)

<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>got <span class="pl-pds">"</span></span>, <span class="pl-c1">objective_value</span>(model), <span class="pl-s"><span class="pl-pds">"</span> at <span class="pl-pds">"</span></span>, [<span class="pl-c1">value</span>(x1), <span class="pl-c1">value</span>(x2)])</pre></div>
<p dir="auto">The output should be:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="got 0.5443310477213124 at [0.3333333342139688,0.29629628951338166]"><pre class="notranslate"><code>got 0.5443310477213124 at [0.3333333342139688,0.29629628951338166]
</code></pre></div>
<p dir="auto">Note that the MathOptInterface interface sets slightly different convergence tolerances by default (these default values are given by the <code>NLopt.DEFAULT_OPTIONS</code> dictionary),
so the outputs from the two problems are not identical.</p>
<p dir="auto">Some algorithms need a local optimizer. These are set with <code>local_optimizer</code>, e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="model = Model(NLopt.Optimizer)
set_optimizer_attribute(model, &quot;algorithm&quot;, :AUGLAG)
set_optimizer_attribute(model, &quot;local_optimizer&quot;, :LD_LBFGS)"><pre>model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(NLopt<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">set_optimizer_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>algorithm<span class="pl-pds">"</span></span>, <span class="pl-c1">:AUGLAG</span>)
<span class="pl-c1">set_optimizer_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>local_optimizer<span class="pl-pds">"</span></span>, <span class="pl-c1">:LD_LBFGS</span>)</pre></div>
<p dir="auto">To parametrize the local optimizer, pass use the <code>NLopt.Opt</code> interface, e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="model = Model(NLopt.Optimizer)
set_optimizer_attribute(model, &quot;algorithm&quot;, :AUGLAG)
local_optimizer = NLopt.Opt(:LD_LBFGS, num_variables)
local_optimizer.xtol_rel = 1e-4
set_optimizer_attribute(model, &quot;local_optimizer&quot;, local_optimizer)"><pre>model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(NLopt<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">set_optimizer_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>algorithm<span class="pl-pds">"</span></span>, <span class="pl-c1">:AUGLAG</span>)
local_optimizer <span class="pl-k">=</span> NLopt<span class="pl-k">.</span><span class="pl-c1">Opt</span>(<span class="pl-c1">:LD_LBFGS</span>, num_variables)
local_optimizer<span class="pl-k">.</span>xtol_rel <span class="pl-k">=</span> <span class="pl-c1">1e-4</span>
<span class="pl-c1">set_optimizer_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>local_optimizer<span class="pl-pds">"</span></span>, local_optimizer)</pre></div>
<p dir="auto">where <code>num_variables</code> is the number of variables of the optimization problem.</p>
<h2 dir="auto"><a id="user-content-reference" class="anchor" aria-hidden="true" href="#reference"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reference</h2>
<p dir="auto">The main purpose of this section is to document the syntax and unique
features of the Julia interface; for more detail on the underlying
features, please refer to the C documentation in the <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Reference" rel="nofollow">NLopt
Reference</a>.</p>
<h3 dir="auto"><a id="user-content-using-the-julia-api" class="anchor" aria-hidden="true" href="#using-the-julia-api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using the Julia API</h3>
<p dir="auto">To use NLopt in Julia, your Julia program should include the line:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using NLopt"><pre><span class="pl-k">using</span> NLopt</pre></div>
<p dir="auto">which imports the NLopt module and its symbols.  (Alternatively, you
can use <code>import NLopt</code> if you want to keep all the NLopt symbols in
their own namespace.  You would then prefix all functions below with
<code>NLopt.</code>, e.g. <code>NLopt.Opt</code> and so on.)</p>
<h3 dir="auto"><a id="user-content-the-opt-type" class="anchor" aria-hidden="true" href="#the-opt-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>Opt</code> type</h3>
<p dir="auto">The NLopt API revolves around an object of type <code>Opt</code>. Via functions
acting on this object, all of the parameters of the optimization are
specified (dimensions, algorithm, stopping criteria, constraints,
objective function, etcetera), and then one finally calls the
<code>optimize</code> function in order to perform the optimization. The object
should normally be created via the constructor:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt = Opt(algorithm, n)"><pre>opt <span class="pl-k">=</span> <span class="pl-c1">Opt</span>(algorithm, n)</pre></div>
<p dir="auto">given an algorithm (see <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Algorithms" rel="nofollow">NLopt
Algorithms</a>
for possible values) and the dimensionality of the problem (<code>n</code>, the
number of optimization parameters). Whereas in C the algorithms are
specified by <code>nlopt_algorithm</code> constants of the form <code>NLOPT_LD_MMA</code>,
<code>NLOPT_LN_COBYLA</code>, etcetera, the Julia <code>algorithm</code> values are symbols
of the form <code>:LD_MMA</code>, <code>:LN_COBYLA</code>, etcetera (with the <code>NLOPT_</code> prefix
replaced by <code>:</code> to create a Julia symbol).</p>
<p dir="auto">There is also a <code>copy(opt::Opt)</code> function to make a copy of a given
object (equivalent to <code>nlopt_copy</code> in the C API).</p>
<p dir="auto">If there is an error in these functions, an exception is thrown.</p>
<p dir="auto">The algorithm and dimension parameters of the object are immutable (cannot be changed without constructing a new object), but you can query them for a given object by:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ndims(opt)
opt.algorithm"><pre><span class="pl-c1">ndims</span>(opt)
opt<span class="pl-k">.</span>algorithm</pre></div>
<p dir="auto">You can get a string description of the algorithm via:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="algorithm_name(opt::Opt)"><pre><span class="pl-c1">algorithm_name</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>)</pre></div>
<h3 dir="auto"><a id="user-content-objective-function" class="anchor" aria-hidden="true" href="#objective-function"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Objective function</h3>
<p dir="auto">The objective function is specified by setting one of the properties:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.min_objective = f
opt.max_objective = f"><pre>opt<span class="pl-k">.</span>min_objective <span class="pl-k">=</span> f
opt<span class="pl-k">.</span>max_objective <span class="pl-k">=</span> f</pre></div>
<p dir="auto">depending on whether one wishes to minimize or maximize the objective function <code>f</code>, respectively. The function <code>f</code> should be of the form:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function f(x::Vector, grad::Vector)
    if length(grad) &gt; 0
        ...set grad to gradient, in-place...
    end
    return ...value of f(x)...
end"><pre><span class="pl-k">function</span> <span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">Vector</span>, grad<span class="pl-k">::</span><span class="pl-c1">Vector</span>)
    <span class="pl-k">if</span> <span class="pl-c1">length</span>(grad) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
        <span class="pl-k">...</span>set grad to gradient, in<span class="pl-k">-</span>place<span class="pl-k">...</span>
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> <span class="pl-k">...</span>value of <span class="pl-c1">f</span>(x)<span class="pl-k">...</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">The return value should be the value of the function at the point <code>x</code>,
where <code>x</code> is a (<code>Float64</code>) array of length <code>n</code> of the optimization
parameters (the same as the dimension passed to the <code>Opt</code> constructor).</p>
<p dir="auto">In addition, if the argument <code>grad</code> is not empty [i.e. <code>length(grad)</code>&gt;0],
then <code>grad</code> is a (<code>Float64</code>) array of length <code>n</code> which should (upon return) be
set to the gradient of the function with respect to the optimization
parameters at <code>x</code>. That is, <code>grad[i]</code> should upon return contain the
partial derivative ∂<code>f</code>/∂<code>x</code><sub><code>i</code></sub>, for 1≤<code>i</code>≤<code>n</code>, if
<code>grad</code> is non-empty. Not all of the optimization algorithms (below) use
the gradient information: for algorithms listed as "derivative-free,"
the <code>grad</code> argument will always be empty and need never be
computed. (For algorithms that do use gradient information, however,
<code>grad</code> may still be empty for some calls.)</p>
<p dir="auto">Note that <code>grad</code> must be modified <em>in-place</em> by your function <code>f</code>. Generally, this means using indexing operations <code>grad[...] = ...</code> to overwrite the contents of <code>grad</code>.  For example <code>grad = 2x</code> will <em>not</em> work, because it points <code>grad</code> to a new array <code>2x</code> rather than overwriting the old contents; instead, use an explicit loop or use <code>grad[:] = 2x</code>.</p>
<h3 dir="auto"><a id="user-content-bound-constraints" class="anchor" aria-hidden="true" href="#bound-constraints"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Bound constraints</h3>
<p dir="auto">The bound constraints can be specified by setting one of the properties:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.lower_bounds = lb::Union{AbstractVector,Real}
opt.upper_bounds = ub::Union{AbstractVector,Real}"><pre>opt<span class="pl-k">.</span>lower_bounds <span class="pl-k">=</span> lb<span class="pl-k">::</span><span class="pl-c1">Union{AbstractVector,Real}</span>
opt<span class="pl-k">.</span>upper_bounds <span class="pl-k">=</span> ub<span class="pl-k">::</span><span class="pl-c1">Union{AbstractVector,Real}</span></pre></div>
<p dir="auto">where <code>lb</code> and <code>ub</code> are real arrays of length <code>n</code> (the same as the
dimension passed to the <code>Opt</code> constructor). For convenience, you can
instead use a single scalar for <code>lb</code> or <code>ub</code> in
order to set the lower/upper bounds for all optimization parameters to
a single constant.</p>
<p dir="auto">To retrieve the values of the lower/upper bounds, you can use the properties</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.lower_bounds
opt.upper_bounds"><pre>opt<span class="pl-k">.</span>lower_bounds
opt<span class="pl-k">.</span>upper_bounds</pre></div>
<p dir="auto">both of which return <code>Vector{Float64}</code> arrays.</p>
<p dir="auto">To specify an unbounded dimension, you can use <code>±Inf</code>.</p>
<h3 dir="auto"><a id="user-content-nonlinear-constraints" class="anchor" aria-hidden="true" href="#nonlinear-constraints"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Nonlinear constraints</h3>
<p dir="auto">Just as for nonlinear constraints in C, you can specify nonlinear
inequality and equality constraints by the functions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="inequality_constraint!(opt::Opt, fc, tol=0)
equality_constraint!(opt::Opt, h, tol=0)"><pre><span class="pl-c1">inequality_constraint!</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>, fc, tol<span class="pl-k">=</span><span class="pl-c1">0</span>)
<span class="pl-c1">equality_constraint!</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>, h, tol<span class="pl-k">=</span><span class="pl-c1">0</span>)</pre></div>
<p dir="auto">where the arguments <code>fc</code> and <code>h</code> have the same form as the objective
function above. The optional <code>tol</code> arguments specify a tolerance
(which defaults to zero) in judging feasibility for the purposes of
stopping the optimization, as in C.   For the default <code>tol=0</code>, you can
also use <code>opt.inequality_constraint = fc</code> or <code>opt.equality_constraint = hc</code>.</p>
<p dir="auto">Each call to these function <em>adds</em> a new constraint to the set of constraints,
rather than replacing the constraints.
To remove all of the inequality and equality constraints from a given problem, you can call the following functions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="remove_constraints!(opt::Opt)"><pre><span class="pl-c1">remove_constraints!</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>)</pre></div>
<h3 dir="auto"><a id="user-content-vector-valued-constraints" class="anchor" aria-hidden="true" href="#vector-valued-constraints"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Vector-valued constraints</h3>
<p dir="auto">Just as for nonlinear constraints in C, you can specify vector-valued
nonlinear inequality and equality constraints by the functions</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="inequality_constraint!(opt::Opt, c, tol::AbstractVector)
equality_constraint!(opt::Opt, c, tol::AbstractVector)"><pre><span class="pl-c1">inequality_constraint!</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>, c, tol<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>)
<span class="pl-c1">equality_constraint!</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>, c, tol<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>)</pre></div>
<p dir="auto">Here, <code>tol</code> is an array of the tolerances in each constraint
dimension; the dimensionality <code>m</code> of the constraint is determined by
<code>length(tol)</code>. The constraint function <code>c</code> must be of the form:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function c(result::Vector, x::Vector, grad::Matrix)
    if length(grad) &gt; 0
        ...set grad to gradient, in-place...
    end
    result[1] = ...value of c1(x)...
    result[2] = ...value of c2(x)...
    ..."><pre><span class="pl-k">function</span> <span class="pl-en">c</span>(result<span class="pl-k">::</span><span class="pl-c1">Vector</span>, x<span class="pl-k">::</span><span class="pl-c1">Vector</span>, grad<span class="pl-k">::</span><span class="pl-c1">Matrix</span>)
    <span class="pl-k">if</span> <span class="pl-c1">length</span>(grad) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
        <span class="pl-k">...</span>set grad to gradient, in<span class="pl-k">-</span>place<span class="pl-k">...</span>
    <span class="pl-k">end</span>
    result[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">...</span>value of <span class="pl-c1">c1</span>(x)<span class="pl-k">...</span>
    result[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-k">...</span>value of <span class="pl-c1">c2</span>(x)<span class="pl-k">...</span>
    <span class="pl-k">...</span></pre></div>
<p dir="auto"><code>result</code> is a (<code>Float64</code>) array whose length equals the dimensionality
<code>m</code> of the constraint (same as the length of <code>tol</code> above), which upon
return should be set <em>in-place</em> (see also above) to the constraint
results at the point <code>x</code> (a <code>Float64</code> array whose length <code>n</code> is the
same as the dimension passed to the <code>Opt</code> constructor). Any return value of
the function is ignored.</p>
<p dir="auto">In addition, if the argument <code>grad</code> is not empty
[i.e. <code>length(grad)</code>&gt;0], then <code>grad</code> is a 2d array of size
<code>n</code>×<code>m</code> which should (upon return) be set in-place (see above)
to the gradient of the function with respect to the optimization
parameters at <code>x</code>. That is, <code>grad[j,i]</code> should upon return contain the
partial derivative ∂c<sub><code>i</code></sub>/∂x<sub><code>j</code></sub> if
<code>grad</code> is non-empty. Not all of the optimization algorithms (below)
use the gradient information: for algorithms listed as
"derivative-free," the <code>grad</code> argument will always be empty and need
never be computed. (For algorithms that do use gradient information,
however, <code>grad</code> may still be empty for some calls.)</p>
<p dir="auto">An inequality constraint corresponds to c<sub><code>i</code></sub>≤0 for
1≤<code>i</code>≤<code>m</code>, and an equality constraint corresponds to
c<sub>i</sub>=0, in both cases with tolerance <code>tol[i]</code> for purposes of
termination criteria.</p>
<p dir="auto">(You can add multiple vector-valued constraints and/or scalar
constraints in the same problem.)</p>
<h3 dir="auto"><a id="user-content-stopping-criteria" class="anchor" aria-hidden="true" href="#stopping-criteria"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stopping criteria</h3>
<p dir="auto">As explained in the <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Reference" rel="nofollow">C API
Reference</a>
and the
<a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Introduction" rel="nofollow">Introduction</a>),
you have multiple options for different stopping criteria that you can
specify. (Unspecified stopping criteria are disabled; i.e., they have
innocuous defaults.)</p>
<p dir="auto">For each stopping criteria, there is a property of the <code>opt::Opt</code> object
that you can use to get/set the value of the stopping criterion.
The meanings of each criterion are exactly the same as in the C API:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.stopval"><pre>opt<span class="pl-k">.</span>stopval</pre></div>
<p dir="auto">Stop when an objective value of at least <code>stopval</code> is found.
(Defaults to <code>-Inf</code>.)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.ftol_rel
opt.ftol_abs"><pre>opt<span class="pl-k">.</span>ftol_rel
opt<span class="pl-k">.</span>ftol_abs</pre></div>
<p dir="auto">Relative or absolute tolerance on function value. (Defaults to <code>0</code>.)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.xtol_rel
opt.xtol_abs"><pre>opt<span class="pl-k">.</span>xtol_rel
opt<span class="pl-k">.</span>xtol_abs</pre></div>
<p dir="auto">Absolute or relative tolerances on the optimization parameters.
(Both default to <code>0</code>.)
In the case of <code>xtol_abs</code>, you can either set it to a scalar
(to use the same tolerance for all inputs) or a vector of
length <code>n</code> (the dimension specified in the <code>Opt</code> constructor)
to use a different tolerance for each parameter.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.maxeval"><pre>opt<span class="pl-k">.</span>maxeval</pre></div>
<p dir="auto">Stop when the number of function evaluations exceeds <code>mev</code>. (0 or
negative for no limit, which is the default.)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.maxtime"><pre>opt<span class="pl-k">.</span>maxtime</pre></div>
<p dir="auto">Stop when the optimization time (in seconds) exceeds <code>t</code>. (0 or
negative for no limit, which is the default.)</p>
<h3 dir="auto"><a id="user-content-forced-termination" class="anchor" aria-hidden="true" href="#forced-termination"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Forced termination</h3>
<p dir="auto">In certain cases, the caller may wish to force the optimization to
halt, for some reason unknown to NLopt. For example, if the user
presses Ctrl-C, or there is an error of some sort in the objective
function. You can do this by throwing any exception inside your
objective/constraint functions: the optimization will be halted
gracefully, and the same exception will be thrown to the caller. See
below regarding exceptions. The Julia equivalent of <code>nlopt_forced_stop</code>
from the C API is to throw a <code>ForcedStop</code> exception.</p>
<h3 dir="auto"><a id="user-content-performing-the-optimization" class="anchor" aria-hidden="true" href="#performing-the-optimization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performing the optimization</h3>
<p dir="auto">Once all of the desired optimization parameters have been specified in
a given object <code>opt::Opt</code>, you can perform the optimization by calling:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(optf,optx,ret) = optimize(opt::Opt, x::AbstractVector)"><pre>(optf,optx,ret) <span class="pl-k">=</span> <span class="pl-c1">optimize</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>, x<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>)</pre></div>
<p dir="auto">On input, <code>x</code> is an array of length <code>n</code> (the dimension of the problem
from the <code>Opt</code> constructor) giving an initial guess for the
optimization parameters. The return value <code>optx</code> is a array containing
the optimized values of the optimization parameters. <code>optf</code> contains
the optimized value of the objective function, and <code>ret</code> contains a
symbol indicating the NLopt return code (below).</p>
<p dir="auto">Alternatively,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(optf,optx,ret) = optimize!(opt::Opt, x::Vector{Float64})"><pre>(optf,optx,ret) <span class="pl-k">=</span> <span class="pl-c1">optimize!</span>(opt<span class="pl-k">::</span><span class="pl-c1">Opt</span>, x<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>)</pre></div>
<p dir="auto">is the same but modifies <code>x</code> in-place (as well as returning <code>optx=x</code>).</p>
<p dir="auto">On failure (negative return codes), optimize() throws an
exception (see Exceptions, below).</p>
<h3 dir="auto"><a id="user-content-return-values" class="anchor" aria-hidden="true" href="#return-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Return values</h3>
<p dir="auto">The possible return values are the same as the <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Reference#Return_values" rel="nofollow">return values in the C
API</a>,
except that the <code>NLOPT_</code> prefix is replaced with <code>:</code>.  That is, the return values are <code>:SUCCESS</code>, <code>:XTOL_REACHED</code>, etcetera (instead of <code>NLOPT_SUCCESS</code> etcetera).</p>
<h3 dir="auto"><a id="user-content-exceptions" class="anchor" aria-hidden="true" href="#exceptions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Exceptions</h3>
<p dir="auto">The error codes in the C API are replaced in the Julia API by thrown
exceptions. The following exceptions are thrown by the various
routines:</p>
<p dir="auto">If your objective/constraint functions throw any exception during the
execution of <code>optimize</code>, it will be caught by NLopt and the
optimization will be halted gracefully, and opt.optimize will re-throw
the same exception to its caller.</p>
<h3 dir="auto"><a id="user-content-localsubsidiary-optimization-algorithm" class="anchor" aria-hidden="true" href="#localsubsidiary-optimization-algorithm"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Local/subsidiary optimization algorithm</h3>
<p dir="auto">Some of the algorithms, especially MLSL and AUGLAG, use a different
optimization algorithm as a subroutine, typically for local
optimization. You can change the local search algorithm and its
tolerances by setting:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.local_optimizer = local_opt::Opt"><pre>opt<span class="pl-k">.</span>local_optimizer <span class="pl-k">=</span> local_opt<span class="pl-k">::</span><span class="pl-c1">Opt</span></pre></div>
<p dir="auto">Here, <code>local_opt</code> is another <code>Opt</code> object whose parameters are used to determine the local search algorithm, its stopping criteria, and other algorithm parameters. (However, the objective function, bounds, and nonlinear-constraint parameters of <code>local_opt</code> are ignored.) The dimension <code>n</code> of <code>local_opt</code> must match that of <code>opt</code>.</p>
<p dir="auto">This makes a copy of the <code>local_opt</code> object, so you can freely change your original <code>local_opt</code> afterwards without affecting <code>opt</code>.</p>
<h3 dir="auto"><a id="user-content-initial-step-size" class="anchor" aria-hidden="true" href="#initial-step-size"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Initial step size</h3>
<p dir="auto">Just <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Reference#Initial_step_size" rel="nofollow">as in the C
API</a>,
you can set the initial step sizes for derivative-free
optimization algorithms via the <code>opt.initial_step</code> property:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.initial_step = dx"><pre>opt<span class="pl-k">.</span>initial_step <span class="pl-k">=</span> dx</pre></div>
<p dir="auto">Here, <code>dx</code> is an array of the (nonzero) initial steps for each
dimension, or a single number if you wish to use the same initial
steps for all dimensions. <code>initial_step(opt::Opt, x::AbstractVector)</code> returns the initial step that will be used for a
starting guess of <code>x</code> in <code>optimize(opt,x)</code>.</p>
<h3 dir="auto"><a id="user-content-stochastic-population" class="anchor" aria-hidden="true" href="#stochastic-population"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stochastic population</h3>
<p dir="auto">Just <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Reference#Stochastic_population" rel="nofollow">as in the C
API</a>,
you can get and set the initial population for stochastic optimization
algorithms by the property</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.population"><pre>opt<span class="pl-k">.</span>population</pre></div>
<p dir="auto">(A <code>population</code> of zero, the default, implies that the heuristic default will be used as decided upon by individual algorithms.)</p>
<h3 dir="auto"><a id="user-content-pseudorandom-numbers" class="anchor" aria-hidden="true" href="#pseudorandom-numbers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Pseudorandom numbers</h3>
<p dir="auto">For stochastic optimization algorithms, NLopt uses pseudorandom numbers
generated by the Mersenne Twister algorithm, based on code from Makoto
Matsumoto. By default, the seed for the random numbers is generated
from the system time, so that you will get a different sequence of
pseudorandom numbers each time you run your program. If you want to
use a "deterministic" sequence of pseudorandom numbers, i.e. the same
sequence from run to run, you can set the seed by calling:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="NLopt.srand(seed::Integer)"><pre>NLopt<span class="pl-k">.</span><span class="pl-c1">srand</span>(seed<span class="pl-k">::</span><span class="pl-c1">Integer</span>)</pre></div>
<p dir="auto">To reset the seed based on the system time, you can call <code>NLopt.srand_time()</code>.</p>
<p dir="auto">(Normally, you don't need to call this as it is called
automatically. However, it might be useful if you want to
"re-randomize" the pseudorandom numbers after calling <code>nlopt.srand</code> to
set a deterministic seed.)</p>
<h3 dir="auto"><a id="user-content-vector-storage-for-limited-memory-quasi-newton-algorithms" class="anchor" aria-hidden="true" href="#vector-storage-for-limited-memory-quasi-newton-algorithms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Vector storage for limited-memory quasi-Newton algorithms</h3>
<p dir="auto">Just <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt_Reference#Vector_storage_for_limited-memory_quasi-Newton_algorithms" rel="nofollow">as in the C API</a>, you can get and set the number M of stored vectors for limited-memory quasi-Newton algorithms, via integer-valued property</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="opt.vector_storage"><pre>opt<span class="pl-k">.</span>vector_storage</pre></div>
<p dir="auto">(The default is <code>0</code>, in which case NLopt uses a heuristic nonzero value as
determined by individual algorithms.)</p>
<h3 dir="auto"><a id="user-content-version-number" class="anchor" aria-hidden="true" href="#version-number"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Version number</h3>
<p dir="auto">The version number of NLopt is given by the global variable:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="NLOPT_VERSION::VersionNumber"><pre>NLOPT_VERSION<span class="pl-k">::</span><span class="pl-c1">VersionNumber</span></pre></div>
<p dir="auto">where <code>VersionNumber</code> is a built-in Julia type from the Julia standard library.</p>
<h2 dir="auto"><a id="user-content-author" class="anchor" aria-hidden="true" href="#author"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Author</h2>
<p dir="auto">This module was initially written by <a href="http://math.mit.edu/~stevenj/" rel="nofollow">Steven G. Johnson</a>,
with subsequent contributions by several other authors (see the git history).</p>
</article></div>