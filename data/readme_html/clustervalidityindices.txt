<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-clustervalidityindices" class="anchor" aria-hidden="true" href="#clustervalidityindices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ClusterValidityIndices</h1>
<p>A Julia package for Cluster Validity Indices (CVI) algorithms.</p>
<table>
<thead>
<tr>
<th align="center"><strong>Documentation</strong></th>
<th align="center"><strong>Build Status</strong></th>
<th align="center"><strong>Coverage</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://AP6YC.github.io/ClusterValidityIndices.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://github.com/AP6YC/ClusterValidityIndices.jl/actions?query=workflow%3ACI"><img src="https://github.com/AP6YC/ClusterValidityIndices.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width:100%;"></a></td>
<td align="center"><a href="https://codecov.io/gh/AP6YC/ClusterValidityIndices.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c9fd41fc7caebc5d7eced2203b2af45202b3c0a1ea75de0232d41a717714cca0/68747470733a2f2f636f6465636f762e696f2f67682f41503659432f436c757374657256616c6964697479496e64696365732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/AP6YC/ClusterValidityIndices.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></td>
</tr>
<tr>
<td align="center"><a href="https://AP6YC.github.io/ClusterValidityIndices.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://ci.appveyor.com/project/AP6YC/ClusterValidityIndices-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/640c18cf1194d1a7b8942b0723a742786b14cdfdc65fb70e8e1bad1bd7311d78/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f41503659432f436c757374657256616c6964697479496e64696365732e6a6c3f7376673d74727565" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/AP6YC/ClusterValidityIndices.jl?svg=true" style="max-width:100%;"></a></td>
<td align="center"><a href="https://coveralls.io/github/AP6YC/ClusterValidityIndices.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/345c695436b039c0210bc700440d8171b1a9bbea5e04adff22639f88d5725c71/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f41503659432f436c757374657256616c6964697479496e64696365732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coveralls" data-canonical-src="https://coveralls.io/repos/github/AP6YC/ClusterValidityIndices.jl/badge.svg?branch=master" style="max-width:100%;"></a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center"><strong>Dependents</strong></th>
<th align="center"><strong>Date</strong></th>
<th align="center"><strong>Status</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://juliahub.com/ui/Packages/ClusterValidityIndices/Z19r6?t=2" rel="nofollow"><img src="https://camo.githubusercontent.com/a293ed7fe14bfcaf0f3dece99f9e2d21a0454cec203070e9ef87c5f641dcd4ed/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f436c757374657256616c6964697479496e64696365732f646570732e737667" alt="deps" data-canonical-src="https://juliahub.com/docs/ClusterValidityIndices/deps.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://juliahub.com/ui/Packages/ClusterValidityIndices/Z19r6" rel="nofollow"><img src="https://camo.githubusercontent.com/219b9aa1004bd5fe0fac7f18ebc81639c07dfdc90995f6d99e8f5ec56153814c/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f436c757374657256616c6964697479496e64696365732f76657273696f6e2e737667" alt="version" data-canonical-src="https://juliahub.com/docs/ClusterValidityIndices/version.svg" style="max-width:100%;"></a></td>
<td align="center"><a href="https://juliahub.com/ui/Packages/ClusterValidityIndices/Z19r6" rel="nofollow"><img src="https://camo.githubusercontent.com/cb89ac92195b57029603ed1b3a7527f25ec9b2e8174b61fb3c714507184da5e6/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f436c757374657256616c6964697479496e64696365732f706b676576616c2e737667" alt="pkgeval" data-canonical-src="https://juliahub.com/docs/ClusterValidityIndices/pkgeval.svg" style="max-width:100%;"></a></td>
</tr>
</tbody>
</table>



<p>This package is developed and maintained by <a href="https://github.com/AP6YC">Sasha Petrenko</a> with sponsorship by the <a href="https://acil.mst.edu/" rel="nofollow">Applied Computational Intelligence Laboratory (ACIL)</a>. This project is supported by grants from the <a href="https://c5isr.ccdc.army.mil/inside_c5isr_center/nvesd/" rel="nofollow">Night Vision Electronic Sensors Directorate</a>, the <a href="https://www.darpa.mil/program/lifelong-learning-machines" rel="nofollow">DARPA Lifelong Learning Machines (L2M) program</a>, <a href="http://www.teledyne.com/" rel="nofollow">Teledyne Technologies</a>, and the <a href="https://www.nsf.gov/" rel="nofollow">National Science Foundation</a>.
The material, findings, and conclusions here do not necessarily reflect the views of these entities.</p>
<p>Please read the <a href="https://ap6yc.github.io/ClusterValidityIndices.jl/dev/" rel="nofollow">documentation</a> for detailed usage and tutorials.</p>
<h2><a id="user-content-table-of-contents" class="anchor" aria-hidden="true" href="#table-of-contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Table of Contents</h2>
<ul>
<li><a href="#clustervalidityindices">ClusterValidityIndices</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#outline">Outline</a></li>
<li><a href="#quickstart">Quickstart</a></li>
<li><a href="#structure">Structure</a></li>
<li><a href="#usage">Usage</a>
<ul>
<li><a href="#data">Data</a></li>
<li><a href="#instantiation">Instantiation</a></li>
<li><a href="#incremental-vs-batch">Incremental vs. Batch</a></li>
<li><a href="#updating">Updating</a></li>
<li><a href="#criterion-values">Criterion Values</a></li>
<li><a href="#porcelain">Porcelain</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a id="user-content-outline" class="anchor" aria-hidden="true" href="#outline"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Outline</h2>
<p>This Julia project contains an outline of the conceptual usage of CVIs along with many example scripts.
<a href="##Quickstart">Quickstart</a> provides an overview of how to use this project, while <a href="##Structure">Structure</a> outlines the project file structure, giving context to the locations of every component of the project.
<a href="##Usage">Usage</a> outlines the general syntax and workflow of the ICVIs, while <a href="##Authors">Authors</a> gives credit to the author(s).</p>
<h2><a id="user-content-quickstart" class="anchor" aria-hidden="true" href="#quickstart"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Quickstart</h2>
<p>This section provides a quick overview of how to use the project.
For more detailed code usage, please see <a href="##Usage">Usage</a>.</p>
<p>This project has several example scripts to demonstrate the functionality of CVIs in the ClusterValidityIndices.jl package.
In <code>ICVI-Examples/src/examples/</code>, the scripts <code>db.jl</code>, <code>ps.jl</code>, and <code>xb.jl</code> demonstrate usage of the Davies-Boudin (DB), Partition Separation (PS), and Xie-Beni (XB) metrics, respectively.</p>
<p><strong>NOTE</strong> Each of these scripts must be run at the top level of the project to correctly point to the datasets.
For example, they can be run in the shell with</p>
<div class="highlight highlight-source-shell position-relative" data-snippet-clipboard-copy-content="julia src/examples/db.jl
"><pre>julia src/examples/db.jl</pre></div>
<p>or in a Julia REPL session with</p>
<div class="highlight highlight-source-shell position-relative" data-snippet-clipboard-copy-content="include(&quot;src/examples/db.jl&quot;)
"><pre>include(<span class="pl-s"><span class="pl-pds">"</span>src/examples/db.jl<span class="pl-pds">"</span></span>)</pre></div>
<p>Three preprocessed datasets are provided under <code>data/</code> to demonstrate the correct partitioning, over partitioning, and under partitioning of samples by a clustering algorithm to illustrate how the CVIs behave in each case.
The data consists of 2000 samples of 2-element features with the clustering label appended in the third column.
You can change which dataset is used in each script above.</p>
<p>Lastly, there is a large experiment script <code>src/examples/combined.jl</code> that runs every CVI with all three datasets.
The common code for all scripts is contained under <code>src/common.jl</code>, while the experiment subroutines referenced in these scripts are under <code>src/experiments.jl</code>, so feel free to modify them to further explore the behavior and usage of these CVIs.</p>
<h2><a id="user-content-structure" class="anchor" aria-hidden="true" href="#structure"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Structure</h2>
<div class="highlight highlight-text-shell-session position-relative" data-snippet-clipboard-copy-content="ICVI-Examples
├── .github/workflows       // GitHub: workflows for testing and documentation.
├── data                    // Data: CI and example data location.
├── src                     // Source: scripts and common helper functions.
│   └───examples            //      Example scripts for CVI usage.
├── test                    // Test: unit, integration, and environment tests.
├── .gitignore              // Git: .gitignore for the whole project.
├── LICENSE                 // Doc: the license to the project.
├── Manifest.toml           // Julia: the explicit package versions used.
├── Project.toml            // Julia: the Pkg.jl dependencies of the project.
└── README.md               // Doc: this document.
"><pre><span class="pl-c1">ICVI-Examples</span>
<span class="pl-c1">├── .github/workflows       // GitHub: workflows for testing and documentation.</span>
<span class="pl-c1">├── data                    // Data: CI and example data location.</span>
<span class="pl-c1">├── src                     // Source: scripts and common helper functions.</span>
<span class="pl-c1">│   └───examples            //      Example scripts for CVI usage.</span>
<span class="pl-c1">├── test                    // Test: unit, integration, and environment tests.</span>
<span class="pl-c1">├── .gitignore              // Git: .gitignore for the whole project.</span>
<span class="pl-c1">├── LICENSE                 // Doc: the license to the project.</span>
<span class="pl-c1">├── Manifest.toml           // Julia: the explicit package versions used.</span>
<span class="pl-c1">├── Project.toml            // Julia: the Pkg.jl dependencies of the project.</span>
<span class="pl-c1">└── README.md               // Doc: this document.</span></pre></div>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The usage of these CVIs requires an understanding of:</p>
<ul>
<li><a href="###Data">Data</a> assumptions of the CVIs.</li>
<li><a href="###Instantiation">How to instantiate</a> the CVIs.</li>
<li><a href="###Incremental-vs.-Batch">Incremental vs. batch</a> evaluation.</li>
<li><a href="###Updating">Updating</a> internal CVI parameters.</li>
<li><a href="###Criterion-Values">Computing and extracting</a> the criterion values.</li>
<li><a href="###Porcelain">Porcelain functions</a> that are available to simplify operation.</li>
</ul>
<h3><a id="user-content-data" class="anchor" aria-hidden="true" href="#data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Data</h3>
<p>Because Julia is programmed in a column-major fashion, all CVIs make the assumption that the first dimension (columns) contains features, while the second dimension (rows) contains samples.
This is more important for batch operation, as incremental operation accepts 1-D sample of features at each time step by definition.</p>
<p>For example,</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Load data from somewhere
data = load_data()
# The data shape is dimsion x samples
dim, n_samples = size(data)
"><pre><span class="pl-c"><span class="pl-c">#</span> Load data from somewhere</span>
data <span class="pl-k">=</span> <span class="pl-c1">load_data</span>()
<span class="pl-c"><span class="pl-c">#</span> The data shape is dimsion x samples</span>
dim, n_samples <span class="pl-k">=</span> <span class="pl-c1">size</span>(data)</pre></div>
<p><strong>NOTE</strong>: As of ClusterValidityIndices.jl v0.1.3, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...).
You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior.
In this project, this is ameliorated with the function</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="relabel_cvi_data(labels::Array{M, 1}) where {M&lt;:Int}
"><pre><span class="pl-c1">relabel_cvi_data</span>(labels<span class="pl-k">::</span><span class="pl-c1">Array{M, 1}</span>) <span class="pl-k">where</span> {M<span class="pl-k">&lt;:</span><span class="pl-c1">Int</span>}</pre></div>
<p>For example,</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="data_file = &quot;path/to/data.csv&quot;
data, labels = get_cvi_data(data_file)
labels = relabel_cvi_data(labels)
"><pre>data_file <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>path/to/data.csv<span class="pl-pds">"</span></span>
data, labels <span class="pl-k">=</span> <span class="pl-c1">get_cvi_data</span>(data_file)
labels <span class="pl-k">=</span> <span class="pl-c1">relabel_cvi_data</span>(labels)</pre></div>
<p>Alternatively, you may pairwise sort the entirety of the data with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sort_cvi_data(data::Array{N, 2}, labels::Array{M, 1}) where {N&lt;:Real, M&lt;:Int}
"><pre><span class="pl-c1">sort_cvi_data</span>(data<span class="pl-k">::</span><span class="pl-c1">Array{N, 2}</span>, labels<span class="pl-k">::</span><span class="pl-c1">Array{M, 1}</span>) <span class="pl-k">where</span> {N<span class="pl-k">&lt;:</span><span class="pl-c1">Real</span>, M<span class="pl-k">&lt;:</span><span class="pl-c1">Int</span>}</pre></div>
<p><strong>NOTE</strong>* <code>sort_cvi_data</code> reorders the input data as well, which will lead to different ICVI results than with <code>relabel_cvi_data</code>.</p>
<h3><a id="user-content-instantiation" class="anchor" aria-hidden="true" href="#instantiation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Instantiation</h3>
<p>The names of each CVI are capital abbreviations of their literature names, often based upon the surname of the principal authors of the papers that introduce the metrics.
All CVIs are implemented with the default constructor, such as</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="cvi = DB()
"><pre>cvi <span class="pl-k">=</span> <span class="pl-c1">DB</span>()</pre></div>
<h3><a id="user-content-incremental-vs-batch" class="anchor" aria-hidden="true" href="#incremental-vs-batch"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Incremental vs. Batch</h3>
<p>The CVIs in this project all contain <em>incremental</em> and <em>batch</em> implementations.
When evaluated in incremental mode, they are often called ICVIs (incremental cluster validity indices).
In documentation, CVI refers to both modalities (as in the literature), but in code, CVI means batch and ICVI means incremental.</p>
<p>The funtions that differ between the two modes are how they are updated</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Incremental
param_inc!(...)
# Batch
param_batch!(...)
"><pre><span class="pl-c"><span class="pl-c">#</span> Incremental</span>
<span class="pl-c1">param_inc!</span>(<span class="pl-k">...</span>)
<span class="pl-c"><span class="pl-c">#</span> Batch</span>
<span class="pl-c1">param_batch!</span>(<span class="pl-k">...</span>)</pre></div>
<p>and their respective porcelain functions</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Incremental
get_icvi!(...)
# Batch
get_cvi!(...)
"><pre><span class="pl-c"><span class="pl-c">#</span> Incremental</span>
<span class="pl-c1">get_icvi!</span>(<span class="pl-k">...</span>)
<span class="pl-c"><span class="pl-c">#</span> Batch</span>
<span class="pl-c1">get_cvi!</span>(<span class="pl-k">...</span>)</pre></div>
<p>They both compute their most recent criterion values with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="evaluate!(...)
"><pre><span class="pl-c1">evaluate!</span>(<span class="pl-k">...</span>)</pre></div>
<p><strong>NOTE</strong>: Any CVI can switch to be updated incrementally or in batch, as the CVI data structs are update mode agnostic.</p>
<h3><a id="user-content-updating" class="anchor" aria-hidden="true" href="#updating"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Updating</h3>
<p>The CVIs in this project all contain internal <em>parameters</em> that must be updated.
Each update function modifies the CVI, so they use the Julia nomenclature convention of appending an exclamation point to indicate as much.</p>
<p>In both incremental and batch modes, the parameter update requires:</p>
<ul>
<li>The CVI being updates</li>
<li>The sample (or array of samples)</li>
<li>The label(s) that was/were prescribed by the clustering algorithm to the sample(s)</li>
</ul>
<p>More concretely, they are</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Incremental updating
param_inc!(cvi::C, sample::Array{T, 1}, label::I) where {C&lt;:AbstractCVI, T&lt;:Real, I&lt;:Int}
# Batch updating
param_batch!(cvi::C, data::Array{T, 2}, labels::Array{I, 1}) where {C&lt;:AbstractCVI, T&lt;:Real, I&lt;:Int}
"><pre><span class="pl-c"><span class="pl-c">#</span> Incremental updating</span>
<span class="pl-c1">param_inc!</span>(cvi<span class="pl-k">::</span><span class="pl-c1">C</span>, sample<span class="pl-k">::</span><span class="pl-c1">Array{T, 1}</span>, label<span class="pl-k">::</span><span class="pl-c1">I</span>) <span class="pl-k">where</span> {C<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractCVI</span>, T<span class="pl-k">&lt;:</span><span class="pl-c1">Real</span>, I<span class="pl-k">&lt;:</span><span class="pl-c1">Int</span>}
<span class="pl-c"><span class="pl-c">#</span> Batch updating</span>
<span class="pl-c1">param_batch!</span>(cvi<span class="pl-k">::</span><span class="pl-c1">C</span>, data<span class="pl-k">::</span><span class="pl-c1">Array{T, 2}</span>, labels<span class="pl-k">::</span><span class="pl-c1">Array{I, 1}</span>) <span class="pl-k">where</span> {C<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractCVI</span>, T<span class="pl-k">&lt;:</span><span class="pl-c1">Real</span>, I<span class="pl-k">&lt;:</span><span class="pl-c1">Int</span>}</pre></div>
<p>Every CVI is a subtype of the abstract type <code>AbstractCVI</code>.
For example, we may instantiate and load our data</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="cvi = DB()
data = load_data()
labels = get_cluster_labels(data)
dim, n_samples = size(data)
"><pre>cvi <span class="pl-k">=</span> <span class="pl-c1">DB</span>()
data <span class="pl-k">=</span> <span class="pl-c1">load_data</span>()
labels <span class="pl-k">=</span> <span class="pl-c1">get_cluster_labels</span>(data)
dim, n_samples <span class="pl-k">=</span> <span class="pl-c1">size</span>(data)</pre></div>
<p>then update the parameters incrementally with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Iterate over all samples
for ix = 1:n_samples
    sample = data[:, ix]
    label = labels[ix]
    param_inc!(cvi, sample, labels)
end
"><pre><span class="pl-c"><span class="pl-c">#</span> Iterate over all samples</span>
<span class="pl-k">for</span> ix <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n_samples
    sample <span class="pl-k">=</span> data[:, ix]
    label <span class="pl-k">=</span> labels[ix]
    <span class="pl-c1">param_inc!</span>(cvi, sample, labels)
<span class="pl-k">end</span></pre></div>
<p>or in batch with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="param_batch!(cvi, data, labels)
"><pre><span class="pl-c1">param_batch!</span>(cvi, data, labels)</pre></div>
<p>Furthermore, any CVI can alternate between being updated in incremental or batch modes, such as</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Create a new CVI
cvi_mixed = DB()

# Update on half of the data incrementally
i_split = n_samples/2
for ix = 1:i_split
    param_inc!(cvi, data[:, ix], labels[ix])
end

# Update on the other half all at once
param_batch!(cvi, data[:, (i_split+1):end])
"><pre><span class="pl-c"><span class="pl-c">#</span> Create a new CVI</span>
cvi_mixed <span class="pl-k">=</span> <span class="pl-c1">DB</span>()

<span class="pl-c"><span class="pl-c">#</span> Update on half of the data incrementally</span>
i_split <span class="pl-k">=</span> n_samples<span class="pl-k">/</span><span class="pl-c1">2</span>
<span class="pl-k">for</span> ix <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>i_split
    <span class="pl-c1">param_inc!</span>(cvi, data[:, ix], labels[ix])
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Update on the other half all at once</span>
<span class="pl-c1">param_batch!</span>(cvi, data[:, (i_split<span class="pl-k">+</span><span class="pl-c1">1</span>)<span class="pl-k">:</span><span class="pl-c1">end</span>])</pre></div>
<h3><a id="user-content-criterion-values" class="anchor" aria-hidden="true" href="#criterion-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Criterion Values</h3>
<p>The CVI parameters are separate from the criterion values that they produce.
This is partly because in batch mode computing the criterion value is only relevant at the last step, which eliminates unnecessarily computing it at every step.
This is also provide granularity to the user that may only which to extract the criterion value occasionally during incremental mode.</p>
<p>Because the criterion values only depend on the internal CVI parameters, they are computed (and internally stored) with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="evaluate!(cvi::C) where {C&lt;:AbstractCVI}
"><pre><span class="pl-c1">evaluate!</span>(cvi<span class="pl-k">::</span><span class="pl-c1">C</span>) <span class="pl-k">where</span> {C<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractCVI</span>}</pre></div>
<p>To extract them, you must then simply grab the criterion value from the CVI struct with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="criterion_value = cvi.criterion_value
"><pre>criterion_value <span class="pl-k">=</span> cvi<span class="pl-k">.</span>criterion_value</pre></div>
<p>For example, after loading the data</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="cvi = DB()
data = load_data()
labels = get_cluster_labels(data)
dim, n_samples = size(data)
"><pre>cvi <span class="pl-k">=</span> <span class="pl-c1">DB</span>()
data <span class="pl-k">=</span> <span class="pl-c1">load_data</span>()
labels <span class="pl-k">=</span> <span class="pl-c1">get_cluster_labels</span>(data)
dim, n_samples <span class="pl-k">=</span> <span class="pl-c1">size</span>(data)</pre></div>
<p>we may extract and return the criterion value at every step with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="criterion_values = zeros(n_samples)
for ix = 1:n_samples
    param_inc!(cvi, data[:, ix], labels[ix])
    evaluate!(cvi)
    criterion_values[ix] = cvi.criterion_value
end
"><pre>criterion_values <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(n_samples)
<span class="pl-k">for</span> ix <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n_samples
    <span class="pl-c1">param_inc!</span>(cvi, data[:, ix], labels[ix])
    <span class="pl-c1">evaluate!</span>(cvi)
    criterion_values[ix] <span class="pl-k">=</span> cvi<span class="pl-k">.</span>criterion_value
<span class="pl-k">end</span></pre></div>
<p>or we may get it at the end in batch mode with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="param_batch!(cvi, data, labels)
evaluate!(cvi)
criterion_value = cvi.criterion_value
"><pre><span class="pl-c1">param_batch!</span>(cvi, data, labels)
<span class="pl-c1">evaluate!</span>(cvi)
criterion_value <span class="pl-k">=</span> cvi<span class="pl-k">.</span>criterion_value</pre></div>
<h3><a id="user-content-porcelain" class="anchor" aria-hidden="true" href="#porcelain"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Porcelain</h3>
<p>Taken from the <code>git</code> convention of calling low-level operations <em>plumbing</em> and high-level user-land functions <em>porcelain</em>, the package comes with a small set of <em>porcelain</em> function that do common operations all at once for the user.</p>
<p>For example, you may compute, evalute, and return the criterion value all at once with the functions</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Incremental
get_icvi!(...)
# Batch
get_cvi!(...)
"><pre><span class="pl-c"><span class="pl-c">#</span> Incremental</span>
<span class="pl-c1">get_icvi!</span>(<span class="pl-k">...</span>)
<span class="pl-c"><span class="pl-c">#</span> Batch</span>
<span class="pl-c1">get_cvi!</span>(<span class="pl-k">...</span>)</pre></div>
<p>Exactly as in the usage for updating the parameters, the functions take the cvi, sample(s), and clustered label(s) as input:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Incremental
get_icvi!(cvi::C, x::Array{N, 1}, y::M) where {C&lt;:AbstractCVI, N&lt;:Real, M&lt;:Int}
# Batch
get_cvi!(cvi::C, x::Array{N, 2}, y::Array{M, 1}) where {C&lt;:AbstractCVI, N&lt;:Real, M&lt;:Int}
"><pre><span class="pl-c"><span class="pl-c">#</span> Incremental</span>
<span class="pl-c1">get_icvi!</span>(cvi<span class="pl-k">::</span><span class="pl-c1">C</span>, x<span class="pl-k">::</span><span class="pl-c1">Array{N, 1}</span>, y<span class="pl-k">::</span><span class="pl-c1">M</span>) <span class="pl-k">where</span> {C<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractCVI</span>, N<span class="pl-k">&lt;:</span><span class="pl-c1">Real</span>, M<span class="pl-k">&lt;:</span><span class="pl-c1">Int</span>}
<span class="pl-c"><span class="pl-c">#</span> Batch</span>
<span class="pl-c1">get_cvi!</span>(cvi<span class="pl-k">::</span><span class="pl-c1">C</span>, x<span class="pl-k">::</span><span class="pl-c1">Array{N, 2}</span>, y<span class="pl-k">::</span><span class="pl-c1">Array{M, 1}</span>) <span class="pl-k">where</span> {C<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractCVI</span>, N<span class="pl-k">&lt;:</span><span class="pl-c1">Real</span>, M<span class="pl-k">&lt;:</span><span class="pl-c1">Int</span>}</pre></div>
<p>For example, after loading the data you may get the criterion value at each step with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="criterion_values = zeros(n_samples)
for ix = 1:n_samples
    criterion_values[ix] = get_icvi!(cvi, data[:, ix], labels[ix])
end
"><pre>criterion_values <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(n_samples)
<span class="pl-k">for</span> ix <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n_samples
    criterion_values[ix] <span class="pl-k">=</span> <span class="pl-c1">get_icvi!</span>(cvi, data[:, ix], labels[ix])
<span class="pl-k">end</span></pre></div>
<p>or you may get the final criterion value in batch mode with</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="criterion_value = get_cvi!(cvi, data, labels)
"><pre>criterion_value <span class="pl-k">=</span> <span class="pl-c1">get_cvi!</span>(cvi, data, labels)</pre></div>
</article></div>