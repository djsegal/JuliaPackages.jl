<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-daggerfluxjl" class="anchor" aria-hidden="true" href="#daggerfluxjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DaggerFlux.jl</h1>
<p dir="auto">This is currently an early stage integration between <a href="https://github.com/JuliaParallel/Dagger.jl"><code>Dagger.jl</code></a> and <a href="https://github.com/FluxML/Flux.jl"><code>Flux.jl</code></a> to allow for distributed computation of differentiation pipelines to use multiple workers, devices, GPUs etc. This package enables model parallelism for Flux models.</p>
<h2 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic Usage</h2>
<p dir="auto">To see the package in action, we would have to start julia with multiple workers.</p>
<p dir="auto">Also make sure that the workers have access to the environment and code that is going to be run. This is typically done with the help of the <code>exeflags</code> keyword in <code>addprocs</code>. Something like <code>addprocs(2, exeflags = "--project")</code> is usually enough. Please ensure that the environment has access to <code>DaggerFlux</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using DaggerFlux, Dagger, Flux, Zygote

julia&gt; @everywhere function layer(x)
         @show myid()
         x
       end

julia&gt; ip = rand(3,3);

julia&gt; c = Chain(layer, layer, layer, layer)
Chain(layer, layer, layer, layer)

julia&gt; dc = DaggerChain(c)
DaggerChain(Chain(layer, layer, layer, layer))

julia&gt; dc(ip) # notice the output is a Dagger Thunk rather than an eager evaluation
Thunk[4](layer, (Thunk[3](layer, ...),))

julia&gt; collect(dc(ip))
      From worker 2:    myid() = 2
      From worker 3:    myid() = 3
      From worker 2:    myid() = 2
      From worker 3:    myid() = 3
3×3 Matrix{Float64}:
 0.813575   0.828228  0.0630336
 0.0755053  0.215495  0.64503
 0.462957   0.345485  0.83312"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> DaggerFlux, Dagger, Flux, Zygote

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@everywhere</span> <span class="pl-k">function</span> <span class="pl-en">layer</span>(x)
         <span class="pl-c1">@show</span> <span class="pl-c1">myid</span>()
         x
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> ip <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>,<span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> c <span class="pl-k">=</span> <span class="pl-c1">Chain</span>(layer, layer, layer, layer)
<span class="pl-c1">Chain</span>(layer, layer, layer, layer)

julia<span class="pl-k">&gt;</span> dc <span class="pl-k">=</span> <span class="pl-c1">DaggerChain</span>(c)
<span class="pl-c1">DaggerChain</span>(<span class="pl-c1">Chain</span>(layer, layer, layer, layer))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">dc</span>(ip) <span class="pl-c"><span class="pl-c">#</span> notice the output is a Dagger Thunk rather than an eager evaluation</span>
Thunk[<span class="pl-c1">4</span>](layer, (Thunk[<span class="pl-c1">3</span>](layer, <span class="pl-k">...</span>),))

julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(<span class="pl-c1">dc</span>(ip))
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
      From worker <span class="pl-c1">3</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">3</span>
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
      From worker <span class="pl-c1">3</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">3</span>
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.813575</span>   <span class="pl-c1">0.828228</span>  <span class="pl-c1">0.0630336</span>
 <span class="pl-c1">0.0755053</span>  <span class="pl-c1">0.215495</span>  <span class="pl-c1">0.64503</span>
 <span class="pl-c1">0.462957</span>   <span class="pl-c1">0.345485</span>  <span class="pl-c1">0.83312</span></pre></div>
<p dir="auto">Notice that the model was now evaluated across multiple workers.</p>
<h2 dir="auto"><a id="user-content-flux-models" class="anchor" aria-hidden="true" href="#flux-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Flux models</h2>
<p dir="auto">This is basically the same as before, but we will demo how to differentiate through Flux models.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; y, back = Zygote.pullback((m,x) -&gt; m(x), dc, ip)
(Thunk[135](layer, (Thunk[131](layer, ...),)), Zygote.var&quot;#46#47&quot;{typeof(∂(#11))}(∂(#11)))

julia&gt; collect(y)
      From worker 3:    myid() = 3
      From worker 3:    myid() = 3
      From worker 2:    myid() = 2
      From worker 2:    myid() = 2
3×3 Matrix{Float64}:
 0.813575   0.828228  0.0630336
 0.0755053  0.215495  0.64503
 0.462957   0.345485  0.83312

julia&gt; back(one.(y))
      From worker 2:    myid() = 2
      From worker 2:    myid() = 2
      From worker 3:    myid() = 3
      [...]
      From worker 2:    myid() = 2
      From worker 3:    myid() = 3
      From worker 2:    myid() = 2
((chain = (layers = (nothing, nothing, nothing, nothing),),), [1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0])"><pre>julia<span class="pl-k">&gt;</span> y, back <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">pullback</span>((m,x) <span class="pl-k">-&gt;</span> <span class="pl-c1">m</span>(x), dc, ip)
(Thunk[<span class="pl-c1">135</span>](layer, (Thunk[<span class="pl-c1">131</span>](layer, <span class="pl-k">...</span>),)), Zygote<span class="pl-k">.</span><span class="pl-c1">var"#46#47"</span>{<span class="pl-c1">typeof</span>(<span class="pl-c1">∂</span>(<span class="pl-c"><span class="pl-c">#</span>11))}(∂(#11)))</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">collect</span>(y)
      From worker <span class="pl-c1">3</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">3</span>
      From worker <span class="pl-c1">3</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">3</span>
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
<span class="pl-c1">3</span><span class="pl-k">×</span><span class="pl-c1">3</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.813575</span>   <span class="pl-c1">0.828228</span>  <span class="pl-c1">0.0630336</span>
 <span class="pl-c1">0.0755053</span>  <span class="pl-c1">0.215495</span>  <span class="pl-c1">0.64503</span>
 <span class="pl-c1">0.462957</span>   <span class="pl-c1">0.345485</span>  <span class="pl-c1">0.83312</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">back</span>(<span class="pl-c1">one</span>.(y))
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
      From worker <span class="pl-c1">3</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">3</span>
      [<span class="pl-k">...</span>]
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
      From worker <span class="pl-c1">3</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">3</span>
      From worker <span class="pl-c1">2</span><span class="pl-k">:</span>    <span class="pl-en">myid</span>() <span class="pl-k">=</span> <span class="pl-c1">2</span>
((chain <span class="pl-k">=</span> (layers <span class="pl-k">=</span> (<span class="pl-c1">nothing</span>, <span class="pl-c1">nothing</span>, <span class="pl-c1">nothing</span>, <span class="pl-c1">nothing</span>),),), [<span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span>; <span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span>; <span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span>])</pre></div>
<p dir="auto">And now one can optimise over entire models!</p>
<p dir="auto">Of course one can substitute our dummy model here with more routine models such as ResNet from Metalhead.jl. Here's a slightly simpler model for an example.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; m = Chain(Dense(2,2), Dense(2,2))
Chain(
  Dense(2, 2),                          # 6 parameters
  Dense(2, 2),                          # 6 parameters
)                   # Total: 4 arrays, 12 parameters, 304 bytes.

julia&gt; dm = DaggerChain(m)
DaggerChain(Chain(Dense(2, 2), Dense(2, 2)))

julia&gt; y, b = Zygote.pullback((m,x) -&gt; m(x), dm, rand(Float32, 2
,2))
(Thunk[150](Dense(2, 2), (Thunk[149](Dense(2, 2), ...),)), Zygote.var&quot;#46#47&quot;{typeof(∂(#13))}(∂(#13)))

julia&gt; b(one.(y))
((chain = (layers = ((weight = Float32[1.0398567 0.45392603; 0.4867683 0.21248773], bias = Float32[1.6065784, 0.75205684], σ = nothing), (weight = Float32[-1.247205 1.2783735; -1.247205 1.278
735], bias = Float32[2.0, 2.0], σ = nothing)),),), Float32[-0.14533046 -0.14533046; -0.58934844 -0.58934844])"><pre>julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> <span class="pl-c1">Chain</span>(<span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>), <span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>))
<span class="pl-c1">Chain</span>(
  <span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>),                          <span class="pl-c"><span class="pl-c">#</span> 6 parameters</span>
  <span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>),                          <span class="pl-c"><span class="pl-c">#</span> 6 parameters</span>
)                   <span class="pl-c"><span class="pl-c">#</span> Total: 4 arrays, 12 parameters, 304 bytes.</span>

julia<span class="pl-k">&gt;</span> dm <span class="pl-k">=</span> <span class="pl-c1">DaggerChain</span>(m)
<span class="pl-c1">DaggerChain</span>(<span class="pl-c1">Chain</span>(<span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)))

julia<span class="pl-k">&gt;</span> y, b <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">pullback</span>((m,x) <span class="pl-k">-&gt;</span> <span class="pl-c1">m</span>(x), dm, <span class="pl-c1">rand</span>(Float32, <span class="pl-c1">2</span>
,<span class="pl-c1">2</span>))
(Thunk[<span class="pl-c1">150</span>](<span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>), (Thunk[<span class="pl-c1">149</span>](<span class="pl-c1">Dense</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>), <span class="pl-k">...</span>),)), Zygote<span class="pl-k">.</span><span class="pl-c1">var"#46#47"</span>{<span class="pl-c1">typeof</span>(<span class="pl-c1">∂</span>(<span class="pl-c"><span class="pl-c">#</span>13))}(∂(#13)))</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">b</span>(<span class="pl-c1">one</span>.(y))
((chain <span class="pl-k">=</span> (layers <span class="pl-k">=</span> ((weight <span class="pl-k">=</span> Float32[<span class="pl-c1">1.0398567</span> <span class="pl-c1">0.45392603</span>; <span class="pl-c1">0.4867683</span> <span class="pl-c1">0.21248773</span>], bias <span class="pl-k">=</span> Float32[<span class="pl-c1">1.6065784</span>, <span class="pl-c1">0.75205684</span>], σ <span class="pl-k">=</span> <span class="pl-c1">nothing</span>), (weight <span class="pl-k">=</span> Float32[<span class="pl-k">-</span><span class="pl-c1">1.247205</span> <span class="pl-c1">1.2783735</span>; <span class="pl-k">-</span><span class="pl-c1">1.247205</span> <span class="pl-c1">1.278</span>
<span class="pl-c1">735</span>], bias <span class="pl-k">=</span> Float32[<span class="pl-c1">2.0</span>, <span class="pl-c1">2.0</span>], σ <span class="pl-k">=</span> <span class="pl-c1">nothing</span>)),),), Float32[<span class="pl-k">-</span><span class="pl-c1">0.14533046</span> <span class="pl-k">-</span><span class="pl-c1">0.14533046</span>; <span class="pl-k">-</span><span class="pl-c1">0.58934844</span> <span class="pl-k">-</span><span class="pl-c1">0.58934844</span>])</pre></div>
<p dir="auto">Contributions welcome to the GitHub repository!</p>
</article></div>