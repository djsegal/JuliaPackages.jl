<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-charlotte" class="anchor" aria-hidden="true" href="#charlotte"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Charlotte</h1>
<p dir="auto"><em>This package was a not-particularly-functional prototype that hasn't been touched since 2018. I'm not sure how you got here, but if you want to run Julia on wasm, you should probably go <a href="https://github.com/Keno/julia-wasm">here</a>.</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Pkg.clone(&quot;https://github.com/MikeInnes/WebAssembly.jl&quot;)
Pkg.clone(&quot;https://github.com/MikeInnes/Charlotte.jl&quot;)"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">clone</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/MikeInnes/WebAssembly.jl<span class="pl-pds">"</span></span>)
Pkg<span class="pl-k">.</span><span class="pl-c1">clone</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/MikeInnes/Charlotte.jl<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Charlotte is an experimental compiler for the <a href="https://julialang.org/" rel="nofollow">Julia</a> language that targets web browsers, via JavaScript and <a href="https://github.com/MikeInnes/WebAssembly.jl">WebAssembly</a>.</p>
<p dir="auto">Charlotte's WebAssembly backend currently supports simple numerical kernels, and could be productively used as a sort of scripting language over WASM.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; relu(x) = ifelse(x &lt; 0, 0, x)
relu (generic function with 1 method)

julia&gt; @code_wasm relu(1)
(func (param i64) (result i64)
  (i64.const 0)
  (get_local 0)
  (get_local 0)
  (i64.const 0)
  (i64.lt_s)
  (select)
  (return))"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-en">relu</span>(x) <span class="pl-k">=</span> <span class="pl-c1">ifelse</span>(x <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, x)
relu (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@code_wasm</span> <span class="pl-c1">relu</span>(<span class="pl-c1">1</span>)
(func (param i64) (result i64)
  (i64<span class="pl-k">.</span><span class="pl-k">const</span> <span class="pl-c1">0</span>)
  (get_local <span class="pl-c1">0</span>)
  (get_local <span class="pl-c1">0</span>)
  (i64<span class="pl-k">.</span><span class="pl-k">const</span> <span class="pl-c1">0</span>)
  (i64<span class="pl-k">.</span>lt_s)
  (select)
  (<span class="pl-k">return</span>))</pre></div>
<h2 dir="auto"><a id="user-content-design" class="anchor" aria-hidden="true" href="#design"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Design</h2>
<p dir="auto">Julia code secretly comes in two dialects:</p>
<ol dir="auto">
<li><em>Dynamic</em> Julia is used like JavaScript; it makes heavy use of GC, untyped data and dynamic dispatch. Tracing JIT compilers and runtimes, like V8, are extremely good at handling this kind of code.</li>
<li><em>Static</em> Julia is more like C, with tight numerical loops that operate over arrays and other well-typed containers. This code can be aggressively optimised by ahead-of-time compilers, like LLVM.</li>
</ol>
<p dir="auto">In both cases, it's important to use the right tool for the job; tracing static code, or specialising dynamic code ahead of time, would lead to unnecessary work being done by the browser. Charlotte therefore uses a hybrid approach, compiling Julia code to a mix of JavaScript <em>and</em> WebAssembly. This way we can get the best of both worlds, supporting both flexible DOM-manipulation code and tight numerical loops in one language, and getting good performance and code size everywhere.</p>
<p dir="auto">In early prototypes the difference between the dialects will be fairly stark; the dynamic subset is essentially a syntax layer over JS, while the static subset only supports basic numerics. As more features are added both should converge to standard Julia, and the difference will become seamless for most users.</p>
<p dir="auto">See <a href="wasm.md">here</a> for a more detailed outline of the static compile pipeline.</p>
</article></div>