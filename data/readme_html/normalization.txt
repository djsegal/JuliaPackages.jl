<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-normalizationjl" class="anchor" aria-hidden="true" href="#normalizationjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Normalization.jl</h1>
<p dir="auto"><a href="https://github.com/brendanjohnharris/Normalization.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/brendanjohnharris/Normalization.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/brendanjohnharris/Normalization.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/53f65c9e11bd5b9c85709144c2b09f7fe0b7ab3db72626795492d01d80edb102/68747470733a2f2f636f6465636f762e696f2f67682f6272656e64616e6a6f686e6861727269732f4e6f726d616c697a6174696f6e2e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/brendanjohnharris/Normalization.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package allows you to easily normalize an array over any dimensions.
It also provides a bunch of normalization methods, such as the z-score, sigmoid, robust, mixed, and NaN-safe normalizations.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">Each normalization method is a subtype of <code>AbstractNormalization</code>. Instances of a normalization, including any parameters (such as the mean of a dataset) are stored in a variable of the <code>AbstractNormalization</code> type.
For example, to normalize a 2D array using the <code>ZScore</code> normalization method (or any other <code>&lt;: AbstractNormalization</code>) over all dimensions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X = rand(100, 100)
N = ZScore(X) # A normalization fit to X, NOT the normalized array
N = ZScore()(X) # An alternative to the line above
Y = N(X) # The normalized array
Z = N(rand(100, 100)) # Apply a normalization with parameters fit to X on a new array"><pre>X <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>)
N <span class="pl-k">=</span> <span class="pl-c1">ZScore</span>(X) <span class="pl-c"><span class="pl-c">#</span> A normalization fit to X, NOT the normalized array</span>
N <span class="pl-k">=</span> <span class="pl-c1">ZScore</span>()(X) <span class="pl-c"><span class="pl-c">#</span> An alternative to the line above</span>
Y <span class="pl-k">=</span> <span class="pl-c1">N</span>(X) <span class="pl-c"><span class="pl-c">#</span> The normalized array</span>
Z <span class="pl-k">=</span> <span class="pl-c1">N</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>)) <span class="pl-c"><span class="pl-c">#</span> Apply a normalization with parameters fit to X on a new array</span></pre></div>
<p dir="auto">There is also an alternative, preferred, syntax:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Statistics
N = fit(ZScore, X)
Y = normalize(X, N)
normalize!(X, N) # In place, writing over X"><pre><span class="pl-k">using</span> Statistics
N <span class="pl-k">=</span> <span class="pl-c1">fit</span>(ZScore, X)
Y <span class="pl-k">=</span> <span class="pl-c1">normalize</span>(X, N)
<span class="pl-c1">normalize!</span>(X, N) <span class="pl-c"><span class="pl-c">#</span> In place, writing over X</span></pre></div>
<p dir="auto">A normalization can also be reversed:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="_X = denormalize(X, N) # Apply the inverse normalization
denormalize!(X, N) # Or do the inverse in place"><pre>_X <span class="pl-k">=</span> <span class="pl-c1">denormalize</span>(X, N) <span class="pl-c"><span class="pl-c">#</span> Apply the inverse normalization</span>
<span class="pl-c1">denormalize!</span>(X, N) <span class="pl-c"><span class="pl-c">#</span> Or do the inverse in place</span></pre></div>
<p dir="auto">Both syntaxes allow you to specify the dimensions to normalize over. For example, to normalize each 2D slice (i.e. iterating over the 3rd dimension) of a 3D array:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X = rand(100, 100, 10)
N = fit(ZScore, X; dims=[1, 2])
normalize!(X, N) # Each [1, 2] slice is normalized independently
all(std(X; dims=[1, 2]) .‚âà 1) # true"><pre>X <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>, <span class="pl-c1">10</span>)
N <span class="pl-k">=</span> <span class="pl-c1">fit</span>(ZScore, X; dims<span class="pl-k">=</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>])
<span class="pl-c1">normalize!</span>(X, N) <span class="pl-c"><span class="pl-c">#</span> Each [1, 2] slice is normalized independently</span>
<span class="pl-c1">all</span>(<span class="pl-c1">std</span>(X; dims<span class="pl-k">=</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>]) <span class="pl-k">.‚âà</span> <span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<h2 dir="auto"><a id="user-content-normalization-methods" class="anchor" aria-hidden="true" href="#normalization-methods"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Normalization methods</h2>
<p dir="auto">Any of these normalizations will work in place of <code>ZScore</code> in the examples above:</p>
<table>
<thead>
<tr>
<th>Normalization</th>
<th>Formula</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ZScore</code></td>
<td><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$(x - \mu)/\sigma$</math-renderer></td>
<td>Subtract the mean and scale by the standard deviation (aka standardisation)</td>
</tr>
<tr>
<td><code>Sigmoid</code></td>
<td><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$(1 + \exp(-\frac{x-\mu}{\sigma}))^{-1}$</math-renderer></td>
<td>Map to the interval <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$(0, 1)$</math-renderer> by applying a sigmoid transformation</td>
</tr>
<tr>
<td><code>MinMax</code></td>
<td><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$(x-\inf{x})/(\sup{x}-\inf{x})$</math-renderer></td>
<td>Scale to the unit interval</td>
</tr>
<tr>
<td><code>Center</code></td>
<td><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$x - \mu$</math-renderer></td>
<td>Subtract the mean</td>
</tr>
<tr>
<td><code>UnitEnergy</code></td>
<td><math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$x/\sum x^2$</math-renderer></td>
<td>Scale to have unit energy</td>
</tr>
</tbody>
</table>
<h3 dir="auto">
<a id="user-content-robust-normalizations" class="anchor" aria-hidden="true" href="#robust-normalizations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Robust normalizations</h3>
<p dir="auto">This package also defines robust versions of any normalization methods that have <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$\mu$</math-renderer> (the mean) and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="23f7dfbf964676c4c097e158ebbaa66c">$\sigma$</math-renderer> (the standard deviation) parameters.
<code>Robust</code> normalizations, including <code>RobustZScore</code> and <code>RobustSigmoid</code>, use the <code>median</code> and <code>iqr/1.35</code> rather than the <code>mean</code> and <code>std</code> for a normalization that is less sensitive to outliers.
There are also <code>Mixed</code> methods, such as <code>MixedZScore</code> and <code>MixedSigmoid</code>, that default to the <code>Robust</code> versions but use the regular parameters (<code>mean</code> and <code>std</code>) if the <code>iqr</code> is 0.</p>
<h3 dir="auto">
<a id="user-content-nan-safe-normalizations" class="anchor" aria-hidden="true" href="#nan-safe-normalizations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NaN-safe normalizations</h3>
<p dir="auto">If the input array contains any <code>NaN</code> values, the normalizations given above will fit with <code>NaN</code> parameters and return <code>NaN</code> arrays. To circumvent this, any normalization can be made '<code>NaN</code>-safe', meaning it ignores <code>NaN</code> values in the input array. Using the <code>ZScore</code> example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="N = nansafe(ZScore)
fit!(N, X)
Y = N(X)"><pre>N <span class="pl-k">=</span> <span class="pl-c1">nansafe</span>(ZScore)
<span class="pl-c1">fit!</span>(N, X)
Y <span class="pl-k">=</span> <span class="pl-c1">N</span>(X)</pre></div>
<h3 dir="auto">
<a id="user-content-new-normalizations" class="anchor" aria-hidden="true" href="#new-normalizations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>New normalizations</h3>
<p dir="auto">Finally, there is also a macro to define your own normalization (honestly you could just make the <code>struct</code> directly). For example, the <code>ZScore</code> is defined as:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@_Normalization ZScore (mean, std)  (x, ùúá, ùúé) -&gt; x .= (x .- ùúá)./ùúé  #=
                                 =# (y, ùúá, ùúé) -&gt; y .= y.*ùúé .+ ùúá"><pre><span class="pl-c1">@_Normalization</span> ZScore (mean, std)  (x, ùúá, ùúé) <span class="pl-k">-&gt;</span> x <span class="pl-k">.=</span> (x <span class="pl-k">.-</span> ùúá)<span class="pl-k">.</span><span class="pl-k">/</span>ùúé  <span class="pl-c"><span class="pl-c">#=</span></span>
<span class="pl-c">                                 <span class="pl-c">=#</span></span> (y, ùúá, ùúé) <span class="pl-k">-&gt;</span> y <span class="pl-k">.=</span> y<span class="pl-k">.*</span>ùúé <span class="pl-k">.+</span> ùúá</pre></div>
<p dir="auto">Here, the first argument is a name for the normalization, the second is a tuple of parameter functions, the third is a vectorised, in-place function of an array <code>x</code> and any parameters, and the fourth is a function for the inverse transformation.</p>
</article></div>