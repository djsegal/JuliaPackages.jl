<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-polyagammadistribution" class="anchor" aria-hidden="true" href="#polyagammadistribution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PolyaGammaDistribution</h1>
<p dir="auto"><a href="https://github.com/currymj/PolyaGammaDistribution.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/currymj/PolyaGammaDistribution.jl/actions/workflows/CI.yml/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/currymj/PolyaGammaDistribution.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/26181ea58d84ad20f41d6ec6e2678e61225e7adb0c6d81171dd786e2324058ca/68747470733a2f2f636f6465636f762e696f2f67682f63757272796d6a2f506f6c796147616d6d61446973747269627574696f6e2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/currymj/PolyaGammaDistribution.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-what-is-this" class="anchor" aria-hidden="true" href="#what-is-this"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What is this?</h1>
<p dir="auto">This repository is still under active development, but when it's done it will provide tools for sampling from and computing moments of the Pólya-Gamma distribution, as described in <a href="http://www.tandfonline.com/doi/abs/10.1080/01621459.2013.829001" rel="nofollow">this paper by Polson et al</a>. They provide the <a href="https://cran.r-project.org/web/packages/BayesLogit/index.html" rel="nofollow">BayesLogit R package</a> which my code at the moment essentially copies from, hence the GPL license.</p>
<p dir="auto">It uses the <a href="https://github.com/JuliaStats/Distributions.jl.git">Distributions.jl</a> interface.</p>
<p dir="auto">As far as I can tell, it works correctly right now, for distributions PG(b, c) with integer-valued b parameter. Work remains to ensure this is true, and to optimize the code and make it more Julian and less of a literal
translation of the R code.</p>
<p dir="auto">The integer-valued case is what's needed for almost all of the statistical applications. It is possible to generalize, less efficiently, and this may be implemented as well.</p>
<h1 dir="auto"><a id="user-content-how-to-use-it" class="anchor" aria-hidden="true" href="#how-to-use-it"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use it</h1>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PolyaGammaDistribution

pgdist = PolyaGamma(1,3.0)

singlesample = rand(pgdist)
manysamples = rand(pgdist, 10)"><pre><span class="pl-k">using</span> PolyaGammaDistribution

pgdist <span class="pl-k">=</span> <span class="pl-c1">PolyaGamma</span>(<span class="pl-c1">1</span>,<span class="pl-c1">3.0</span>)

singlesample <span class="pl-k">=</span> <span class="pl-c1">rand</span>(pgdist)
manysamples <span class="pl-k">=</span> <span class="pl-c1">rand</span>(pgdist, <span class="pl-c1">10</span>)</pre></div>
<h1 dir="auto"><a id="user-content-what-is-the-point-of-this" class="anchor" aria-hidden="true" href="#what-is-the-point-of-this"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What is the point of this?</h1>
<p dir="auto">Suppose we have some function, often some sort of distance between two points, that outputs a real value. We'd like a probability, so we push it through a function that squashes from 0 to 1. Often the logistic aka sigmoid function is used, as in logistic regression or the common activations on the end of a neural network. This is an easy thing to do, although it usually ends up requiring some kind of numerical method to maximize the output.</p>
<p dir="auto">However, if you have a model where you'd like to use a sampler to approximate a posterior distribution (rather than just maximizing) then it becomes much trickier. The Polson et al paper lays out an efficient scheme for sampling in these situations by adding some Pólya-Gamma distributed latent variables.</p>
<h1 dir="auto"><a id="user-content-acknowledgments-etc" class="anchor" aria-hidden="true" href="#acknowledgments-etc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgments, etc.</h1>
<p dir="auto">Apologies to George Pólya for misspelling his name, but it seemed like putting non-ASCII characters in a package/module name was asking for trouble down the line.</p>
<p dir="auto">N. G. Polson, J. G. Scott, and J. Windle, “Bayesian Inference for Logistic Models Using Pólya–Gamma Latent Variables,” Journal of the American Statistical Association, vol. 108, no. 504, pp. 1339–1349, Dec. 2013.</p>
</article></div>