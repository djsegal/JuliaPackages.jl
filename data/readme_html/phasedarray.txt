<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a href="https://github.com/JuliaGNSS/PhasedArray.jl/actions"><img src="https://github.com/JuliaGNSS/PhasedArray.jl/actions/workflows/ci.yml/badge.svg" alt="Tests" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/JuliaGNSS/PhasedArray.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/6ebb519154d49541236c640acc2e3fe8b9e9d8355ecfc56d207ff33a90de315f/68747470733a2f2f636f6465636f762e696f2f67682f4a756c6961474e53532f50686173656441727261792e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d59365344303747335148" alt="codecov" data-canonical-src="https://codecov.io/gh/JuliaGNSS/PhasedArray.jl/branch/master/graph/badge.svg?token=Y6SD07G3QH" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-phasedarrayjl" class="anchor" aria-hidden="true" href="#phasedarrayjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PhasedArray.jl</h1>
<p dir="auto">This module provides common functions associated with antenna arrays.
Currently it provides the creation of antenna array manifolds of ideal antennas and / or of measured steering vectors based on Look-up-Tables (LUT).</p>
<h2 dir="auto"><a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features</h2>
<ul dir="auto">
<li>Easy access to antenna array manifolds either ideal or real</li>
<li>Create patterns</li>
</ul>
<h2 dir="auto"><a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting started</h2>
<p dir="auto">Install:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ]
pkg&gt; add PhasedArray"><pre>julia<span class="pl-k">&gt;</span> ]
pkg<span class="pl-k">&gt;</span> add PhasedArray</pre></div>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<h3 dir="auto"><a id="user-content-ideal-manifold" class="anchor" aria-hidden="true" href="#ideal-manifold"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Ideal manifold</h3>
<p dir="auto">You can either create an ideal manifold based on antenna positions and center frequency</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PhasedArray, StaticArrays
antenna_positions = 0.1904 / 4 *
    @SMatrix [1 -1  1 -1;
              1  1 -1 -1;
              0  0  0  0]
manifold = IdealManifold(1575420e3, antenna_positions)
doa = @SVector [0, 0, 1]
steer_vec = get_steer_vec(manifold, doa)"><pre><span class="pl-k">using</span> PhasedArray, StaticArrays
antenna_positions <span class="pl-k">=</span> <span class="pl-c1">0.1904</span> <span class="pl-k">/</span> <span class="pl-c1">4</span> <span class="pl-k">*</span>
    <span class="pl-c1">@SMatrix</span> [<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>  <span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
              <span class="pl-c1">1</span>  <span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
              <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>]
manifold <span class="pl-k">=</span> <span class="pl-c1">IdealManifold</span>(<span class="pl-c1">1575420e3</span>, antenna_positions)
doa <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> [<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>]
steer_vec <span class="pl-k">=</span> <span class="pl-c1">get_steer_vec</span>(manifold, doa)</pre></div>
<h3 dir="auto"><a id="user-content-real-manifold" class="anchor" aria-hidden="true" href="#real-manifold"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Real manifold</h3>
<p dir="auto">or you can create a real manifold based on a measured LUT:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PhasedArray, StaticArrays
manifold = RealManifold(lut, PhasedArray.NumAnts(4))
steer_vec = get_steer_vec(manifold, SVector(0, 0, 1))"><pre><span class="pl-k">using</span> PhasedArray, StaticArrays
manifold <span class="pl-k">=</span> <span class="pl-c1">RealManifold</span>(lut, PhasedArray<span class="pl-k">.</span><span class="pl-c1">NumAnts</span>(<span class="pl-c1">4</span>))
steer_vec <span class="pl-k">=</span> <span class="pl-c1">get_steer_vec</span>(manifold, <span class="pl-c1">SVector</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>))</pre></div>
<p dir="auto">The LUT can either be a 3D Array, where the first dimension holds the antenna channels, the second dimension the elevations and the third dimension the azimuths, or it can be a <code>SVector</code> of a matrices, where each matrix holds the elevations on the first dimension and the azimuths on the second dimension per antenna channel.
If you pass a 3D Array, you must also provide the <code>NumAnts(num_ants)</code> argument.</p>
<p dir="auto">The interpolation can be set with the interpolation argument. The default one is <code>Constant</code>. You can change that to <code>Linear</code> or <code>Quadratic</code>, if you'd like to.</p>
<p dir="auto">By default the LUT is normalized to its highest gain. If you don't want that, you can pass the argument <code>normalize = false</code> to the <code>RealManifold</code> function.</p>
<p dir="auto">The function <code>get_steer_vec</code> has an optional third argument for a rotation matrix, if you'd like to rotate the Direction of Arrival (DoA) before looking up the steering vector.</p>
<h2 dir="auto"><a id="user-content-plotting" class="anchor" aria-hidden="true" href="#plotting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Plotting</h2>
<p dir="auto">This module also provides some helping functions, if you'd like to plot a pattern</p>
<h3 dir="auto"><a id="user-content-2d-pattern" class="anchor" aria-hidden="true" href="#2d-pattern"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>2D Pattern</h3>
<p dir="auto">A 2D pattern can be generated with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="reduce_ant_function = norm
pattern = Pattern(manifold, reduce_ant_function, num_az = 360, num_el = 91, max_el = π / 2)"><pre>reduce_ant_function <span class="pl-k">=</span> norm
pattern <span class="pl-k">=</span> <span class="pl-c1">Pattern</span>(manifold, reduce_ant_function, num_az <span class="pl-k">=</span> <span class="pl-c1">360</span>, num_el <span class="pl-k">=</span> <span class="pl-c1">91</span>, max_el <span class="pl-k">=</span> π <span class="pl-k">/</span> <span class="pl-c1">2</span>)</pre></div>
<p dir="auto">The <code>reduce_ant_function</code> can be any function, that reduces the antenna channels to a scalar real value.</p>
<p dir="auto">This pattern can be plotted with Plots.jl in the following way:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Plots
plot(pattern)"><pre><span class="pl-k">using</span> Plots
<span class="pl-c1">plot</span>(pattern)</pre></div>
<p dir="auto">Alternatively you can plot it with PGFPlotsX:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PGFPlotsX
@pgf PolarAxis(
    {
        ymin = 0,
        ymax = pattern.max_el * 180 / π,
        &quot;colormap/viridis&quot;,
        &quot;axis on top&quot;,
        &quot;colorbar style={title=Amplification (dB)}&quot;,
        xticklabel = &quot;{\$\\pgfmathparse{Mod(90-\\tick,360)}\\pgfmathprintnumber{\\pgfmathresult}\$}&quot;,
        yticklabel = &quot;{\$\\pgfmathparse{90-\\tick}\\pgfmathprintnumber{\\pgfmathresult}\$}&quot;,
    },
    Plot3({surf, shader=&quot;interp&quot;},
        Coordinates(pattern.azs .* 180 ./ π, pattern.els .* 180 ./ π, pattern.values')
    )
)"><pre><span class="pl-k">using</span> PGFPlotsX
<span class="pl-c1">@pgf</span> <span class="pl-c1">PolarAxis</span>(
    {
        ymin <span class="pl-k">=</span> <span class="pl-c1">0</span>,
        ymax <span class="pl-k">=</span> pattern<span class="pl-k">.</span>max_el <span class="pl-k">*</span> <span class="pl-c1">180</span> <span class="pl-k">/</span> π,
        <span class="pl-s"><span class="pl-pds">"</span>colormap/viridis<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>axis on top<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>colorbar style={title=Amplification (dB)}<span class="pl-pds">"</span></span>,
        xticklabel <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>{<span class="pl-cce">\$\\</span>pgfmathparse{Mod(90-<span class="pl-cce">\\</span>tick,360)}<span class="pl-cce">\\</span>pgfmathprintnumber{<span class="pl-cce">\\</span>pgfmathresult}<span class="pl-cce">\$</span>}<span class="pl-pds">"</span></span>,
        yticklabel <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>{<span class="pl-cce">\$\\</span>pgfmathparse{90-<span class="pl-cce">\\</span>tick}<span class="pl-cce">\\</span>pgfmathprintnumber{<span class="pl-cce">\\</span>pgfmathresult}<span class="pl-cce">\$</span>}<span class="pl-pds">"</span></span>,
    },
    <span class="pl-c1">Plot3</span>({surf, shader<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>interp<span class="pl-pds">"</span></span>},
        <span class="pl-c1">Coordinates</span>(pattern<span class="pl-k">.</span>azs <span class="pl-k">.*</span> <span class="pl-c1">180</span> <span class="pl-k">./</span> π, pattern<span class="pl-k">.</span>els <span class="pl-k">.*</span> <span class="pl-c1">180</span> <span class="pl-k">./</span> π, pattern<span class="pl-k">.</span>values<span class="pl-k">'</span>)
    )
)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="media/pattern2d.png"><img src="media/pattern2d.png" alt="Example Pattern" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-3d-pattern" class="anchor" aria-hidden="true" href="#3d-pattern"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3D Pattern</h3>
<p dir="auto">If you'd like to plot a 3D figure, this can be done with the following code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="reduce_ant_function = norm
pattern = Pattern3D(manifold, reduce_ant_function, num_az = 360, num_el = 181, max_el = π)"><pre>reduce_ant_function <span class="pl-k">=</span> norm
pattern <span class="pl-k">=</span> <span class="pl-c1">Pattern3D</span>(manifold, reduce_ant_function, num_az <span class="pl-k">=</span> <span class="pl-c1">360</span>, num_el <span class="pl-k">=</span> <span class="pl-c1">181</span>, max_el <span class="pl-k">=</span> π)</pre></div>
<p dir="auto">Again, this can be plotted with Plots.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Plots
plot(pattern)
# If you use plotlyjs() you can also plot the gain correctly:
# plot(pattern, fill_z = pattern.gains)"><pre><span class="pl-k">using</span> Plots
<span class="pl-c1">plot</span>(pattern)
<span class="pl-c"><span class="pl-c">#</span> If you use plotlyjs() you can also plot the gain correctly:</span>
<span class="pl-c"><span class="pl-c">#</span> plot(pattern, fill_z = pattern.gains)</span></pre></div>
<p dir="auto">Alternatively you can plots the pattern with PGFPlotsX in the following way:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PGFPlotsX
@pgf Axis({&quot;colormap/viridis&quot;},
    Plot3({surf, &quot;z buffer=sort&quot;, &quot;opacity=0.5&quot;, &quot;point meta=sqrt(x^2+y^2+z^2)&quot;},
        Table([:x=&gt;vec(pattern.X), :y=&gt;vec(pattern.Y), :z=&gt;vec(pattern.Z)]; scanlines = size(pattern.X,1))
    )
)"><pre><span class="pl-k">using</span> PGFPlotsX
<span class="pl-c1">@pgf</span> <span class="pl-c1">Axis</span>({<span class="pl-s"><span class="pl-pds">"</span>colormap/viridis<span class="pl-pds">"</span></span>},
    <span class="pl-c1">Plot3</span>({surf, <span class="pl-s"><span class="pl-pds">"</span>z buffer=sort<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>opacity=0.5<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>point meta=sqrt(x^2+y^2+z^2)<span class="pl-pds">"</span></span>},
        <span class="pl-c1">Table</span>([<span class="pl-c1">:x</span><span class="pl-k">=&gt;</span><span class="pl-c1">vec</span>(pattern<span class="pl-k">.</span>X), <span class="pl-c1">:y</span><span class="pl-k">=&gt;</span><span class="pl-c1">vec</span>(pattern<span class="pl-k">.</span>Y), <span class="pl-c1">:z</span><span class="pl-k">=&gt;</span><span class="pl-c1">vec</span>(pattern<span class="pl-k">.</span>Z)]; scanlines <span class="pl-k">=</span> <span class="pl-c1">size</span>(pattern<span class="pl-k">.</span>X,<span class="pl-c1">1</span>))
    )
)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="media/pattern3d.png"><img src="media/pattern3d.png" alt="Example Pattern" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-license" class="anchor" aria-hidden="true" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>License</h2>
<p dir="auto">MIT License</p>
</article></div>