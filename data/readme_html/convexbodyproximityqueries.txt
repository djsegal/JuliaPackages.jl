<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-convexbodyproximityqueries" class="anchor" aria-hidden="true" href="#convexbodyproximityqueries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ConvexBodyProximityQueries</h1>
<p><a href="https://travis-ci.org/arlk/ConvexBodyProximityQueries.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/6b803943ee26972e6f9d1e37400d0b50e11915b5/68747470733a2f2f7472617669732d63692e6f72672f61726c6b2f436f6e766578426f647950726f78696d697479517565726965732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/arlk/ConvexBodyProximityQueries.jl.svg?branch=master" style="max-width:100%;"></a> <a href="https://codecov.io/gh/arlk/ConvexBodyProximityQueries.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/71523d78d6429f7c02a65d7f40aab7a219517e56/68747470733a2f2f636f6465636f762e696f2f67682f61726c6b2f436f6e766578426f647950726f78696d697479517565726965732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/arlk/ConvexBodyProximityQueries.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/arlk/ConvexBodyProximityQueries.jl/raw/master/readme/logo.gif"><img src="https://github.com/arlk/ConvexBodyProximityQueries.jl/raw/master/readme/logo.gif" alt="" style="max-width:100%;"></a></p>
<p>ConvexBodyProximityQueries.jl implements the Gilber-Johnson-Keerthi (GJK) Algorithm from their seminal paper on fast collision detection. The following query types are available for two convex objects:</p>
<ul>
<li>Closest Points</li>
<li>Minimum Distance</li>
<li>Tolerance Verification</li>
<li>Collision Detection</li>
</ul>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>The package (by default) allows you to work with polytopes defined as an array of vertices, for example:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> StaticArrays
julia<span class="pl-k">&gt;</span> polyA <span class="pl-k">=</span> <span class="pl-c1">@SMatrix</span> <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>, <span class="pl-c1">8</span>)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">8</span> SArray{Tuple{<span class="pl-c1">2</span>,<span class="pl-c1">8</span>},Float64,<span class="pl-c1">2</span>,<span class="pl-c1">16</span>}<span class="pl-k">:</span>
 <span class="pl-c1">0.732619</span>   <span class="pl-c1">0.327745</span>   <span class="pl-c1">0.0390878</span>  <span class="pl-c1">0.477455</span>  <span class="pl-c1">0.627223</span>  <span class="pl-c1">0.502666</span>  <span class="pl-c1">0.0529193</span>  <span class="pl-c1">0.0523722</span>
 <span class="pl-c1">0.0513408</span>  <span class="pl-c1">0.0634308</span>  <span class="pl-c1">0.892253</span>   <span class="pl-c1">0.88009</span>   <span class="pl-c1">0.100901</span>  <span class="pl-c1">0.564782</span>  <span class="pl-c1">0.789238</span>   <span class="pl-c1">0.307813</span>

julia<span class="pl-k">&gt;</span> polyB <span class="pl-k">=</span> <span class="pl-c1">@SMatrix</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>, <span class="pl-c1">8</span>)) <span class="pl-k">.+</span> <span class="pl-c1">1.5</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">8</span> SArray{Tuple{<span class="pl-c1">2</span>,<span class="pl-c1">8</span>},Float64,<span class="pl-c1">2</span>,<span class="pl-c1">16</span>}<span class="pl-k">:</span>
 <span class="pl-c1">2.18993</span>  <span class="pl-c1">1.75404</span>  <span class="pl-c1">1.51373</span>  <span class="pl-c1">1.60674</span>  <span class="pl-c1">1.67257</span>  <span class="pl-c1">2.14208</span>  <span class="pl-c1">1.97779</span>  <span class="pl-c1">2.24657</span>
 <span class="pl-c1">2.32708</span>  <span class="pl-c1">1.92212</span>  <span class="pl-c1">2.32769</span>  <span class="pl-c1">1.69457</span>  <span class="pl-c1">1.85003</span>  <span class="pl-c1">1.57441</span>  <span class="pl-c1">1.93884</span>  <span class="pl-c1">2.45361</span>

julia<span class="pl-k">&gt;</span> dir <span class="pl-k">=</span> <span class="pl-c1">@SVector</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>)) <span class="pl-k">.-</span> <span class="pl-c1">0.5</span>
<span class="pl-c1">2</span><span class="pl-k">-</span>element SArray{Tuple{<span class="pl-c1">2</span>},Float64,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
<span class="pl-k">-</span><span class="pl-c1">0.4673435693835293</span>
 <span class="pl-c1">0.4242237214159814</span></pre></div>
<p>Or if you prefer to use <a href="https://github.com/JuliaReach/LazySets.jl">LazySets</a> to represent bounded convex sets, then simply import it into your workspace.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> LazySets
julia<span class="pl-k">&gt;</span> vp <span class="pl-k">=</span> <span class="pl-c1">rand</span>(VPolytope, dim<span class="pl-k">=</span><span class="pl-c1">3</span>, num_vertices<span class="pl-k">=</span><span class="pl-c1">5</span>)
<span class="pl-c1">VPolytope</span><span class="pl-c1">{Float64}</span>(Array{Float64,<span class="pl-c1">1</span>}[[<span class="pl-c1">0.10865726649792662</span>, <span class="pl-c1">0.5724776430968089</span>, <span class="pl-k">-</span><span class="pl-c1">0.4410130831362367</span>], [<span class="pl-k">-</span><span class="pl-c1">0.8567759573657892</span>, <span class="pl-c1">0.07322903371223476</span>, <span class="pl-c1">0.34838985370789005</span>], [<span class="pl-c1">0.03333527704052754</span>, <span class="pl-k">-</span><span class="pl-c1">1.974401966811797</span>, <span class="pl-c1">0.6174108419158255</span>], [<span class="pl-k">-</span><span class="pl-c1">0.4904624889544439</span>, <span class="pl-k">-</span><span class="pl-c1">0.3210835102598013</span>, <span class="pl-k">-</span><span class="pl-c1">1.1688696283212616</span>], [<span class="pl-k">-</span><span class="pl-c1">0.4369808677028199</span>, <span class="pl-k">-</span><span class="pl-c1">1.3570945645627628</span>, <span class="pl-k">-</span><span class="pl-c1">0.7506142537189342</span>]])

julia<span class="pl-k">&gt;</span> e <span class="pl-k">=</span> <span class="pl-c1">Ellipsoid</span>([<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>], <span class="pl-c1">diagm</span>([<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>]))
<span class="pl-c1">Ellipsoid</span><span class="pl-c1">{Float64}</span>([<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>], [<span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">2.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">3.0</span>])</pre></div>
<p>All the proximity queries can be performed simply by providing the polytope information and an initial searchdirection. In addition, <code>tolerance_verfication</code> requires an argument specifying the minimum tolerance of speration between two objects. :</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> BenchmarkTools
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">closest_points</span>(<span class="pl-k">$</span>polyA, <span class="pl-k">$</span>polyB, <span class="pl-k">$</span>dir)
  <span class="pl-c1">172.901</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
([<span class="pl-c1">0.477455</span>, <span class="pl-c1">0.88009</span>], [<span class="pl-c1">1.60674</span>, <span class="pl-c1">1.69457</span>])

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">minimum_distance</span>(<span class="pl-k">$</span>polyA, <span class="pl-k">$</span>polyB, <span class="pl-k">$</span>dir)
  <span class="pl-c1">165.554</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">1.3923553706117722</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">tolerance_verification</span>(<span class="pl-k">$</span>polyA, <span class="pl-k">$</span>polyB, <span class="pl-k">$</span>dir, <span class="pl-k">$</span><span class="pl-c1">1.0</span>)
  <span class="pl-c1">99.324</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-c1">collision_detection</span>(<span class="pl-k">$</span>polyA, <span class="pl-k">$</span>polyB, <span class="pl-k">$</span>dir)
  <span class="pl-c1">96.386</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">false</span></pre></div>
<p>If you want to use your custom convex objects, you can do so by extending the support function as:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">import</span> ConvexBodyProximityQueries<span class="pl-k">.</span>support
<span class="pl-k">function</span> ConvexBodyProximityQueries<span class="pl-k">.</span><span class="pl-en">support</span>(obj<span class="pl-k">::</span><span class="pl-c1">MyFancyShape</span>, dir<span class="pl-k">::</span><span class="pl-c1">SVector{N}</span>) <span class="pl-k">where</span> {N}
  <span class="pl-c"><span class="pl-c">#</span> do something</span>
  <span class="pl-k">return</span> supporting_point<span class="pl-k">::</span><span class="pl-c1">SVector{N}</span>
<span class="pl-k">end</span></pre></div>
<p><em>Note:</em> This is how I intended the package to be used, the vanilla <code>support</code> function is quite naive and only works for a StaticArray of vertices. Here are some examples for some geometries found in <a href="https://github.com/JuliaGeometry/GeometryTypes.jl">GeometryTypes.jl</a>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">import</span> ConvexBodyProximityQueries<span class="pl-k">.</span>support
<span class="pl-k">using</span> GeometryTypes<span class="pl-k">:</span> HyperSphere, HyperRectangle, HyperCube

<span class="pl-k">function</span> ConvexBodyProximityQueries<span class="pl-k">.</span><span class="pl-en">support</span>(sphere<span class="pl-k">::</span><span class="pl-c1">HyperSphere{N, T}</span>, dir<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>) <span class="pl-k">where</span> {N, T}
    <span class="pl-c1">SVector</span><span class="pl-c1">{N}</span>(sphere<span class="pl-k">.</span>center <span class="pl-k">+</span> sphere<span class="pl-k">.</span>r<span class="pl-k">*</span><span class="pl-c1">normalize</span>(dir, <span class="pl-c1">2</span>))
<span class="pl-k">end</span>

<span class="pl-c1">@generated</span> <span class="pl-k">function</span> ConvexBodyProximityQueries<span class="pl-k">.</span><span class="pl-en">support</span>(rect<span class="pl-k">::</span><span class="pl-c1">HyperRectangle{N, T}</span>, dir<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>) <span class="pl-k">where</span> {N, T}
    exprs <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{Expr}</span>(undef, (N,))
    <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        exprs[i] <span class="pl-k">=</span> :(rect<span class="pl-k">.</span>widths[<span class="pl-k">$</span>i]<span class="pl-k">*</span>(dir[<span class="pl-k">$</span>i] <span class="pl-k">≥</span> <span class="pl-c1">0.0</span> ? <span class="pl-c1">1.0</span> : <span class="pl-k">-</span><span class="pl-c1">1.0</span>)<span class="pl-k">/</span><span class="pl-c1">2.0</span> <span class="pl-k">+</span> rect<span class="pl-k">.</span>origin[<span class="pl-k">$</span>i])
    <span class="pl-k">end</span>

    <span class="pl-k">return</span> <span class="pl-k">quote</span>
        Base<span class="pl-k">.</span><span class="pl-c1">@_inline_meta</span>
        <span class="pl-c1">@inbounds</span> elements <span class="pl-k">=</span> <span class="pl-c1">tuple</span>(<span class="pl-k">$</span>(exprs<span class="pl-k">...</span>))
        <span class="pl-c1">@inbounds</span> <span class="pl-k">return</span> <span class="pl-c1">SVector</span><span class="pl-c1">{N, T}</span>(elements)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">@generated</span> <span class="pl-k">function</span> ConvexBodyProximityQueries<span class="pl-k">.</span><span class="pl-en">support</span>(cube<span class="pl-k">::</span><span class="pl-c1">HyperCube{N, T}</span>, dir<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>) <span class="pl-k">where</span> {N, T}
    exprs <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{Expr}</span>(undef, (N,))
    <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        exprs[i] <span class="pl-k">=</span> :(cube<span class="pl-k">.</span>width<span class="pl-k">*</span>(dir[<span class="pl-k">$</span>i] <span class="pl-k">≥</span> <span class="pl-c1">0.0</span> ? <span class="pl-c1">1.0</span> : <span class="pl-k">-</span><span class="pl-c1">1.0</span>)<span class="pl-k">/</span><span class="pl-c1">2.0</span> <span class="pl-k">+</span> cube<span class="pl-k">.</span>origin[<span class="pl-k">$</span>i])
    <span class="pl-k">end</span>

    <span class="pl-k">return</span> <span class="pl-k">quote</span>
        Base<span class="pl-k">.</span><span class="pl-c1">@_inline_meta</span>
        <span class="pl-c1">@inbounds</span> elements <span class="pl-k">=</span> <span class="pl-c1">tuple</span>(<span class="pl-k">$</span>(exprs<span class="pl-k">...</span>))
        <span class="pl-c1">@inbounds</span> <span class="pl-k">return</span> <span class="pl-c1">SVector</span><span class="pl-c1">{N, T}</span>(elements)
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<h3><a id="user-content-obstacle-types" class="anchor" aria-hidden="true" href="#obstacle-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Obstacle Types</h3>
<p>Here are some additional types that are constructed for convenience:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@point</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>)
<span class="pl-c1">ConvexPolygon</span><span class="pl-c1">{3,1,Float64}</span>(SArray{Tuple{<span class="pl-c1">3</span>},Float64,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>}[[<span class="pl-c1">0.135678</span>, <span class="pl-c1">0.840508</span>, <span class="pl-c1">0.140532</span>]])
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@line</span> [<span class="pl-c1">0.</span>,<span class="pl-c1">1.</span>,<span class="pl-c1">1.</span>], [<span class="pl-c1">1.</span>,<span class="pl-c1">2.</span>,<span class="pl-c1">1.</span>] <span class="pl-c"><span class="pl-c">#</span> point A, point B</span>
<span class="pl-c1">ConvexPolygon</span><span class="pl-c1">{3,2,Float64}</span>(SArray{Tuple{<span class="pl-c1">3</span>},Float64,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>}[[<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>], [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">1.0</span>]])
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@rect</span> [<span class="pl-c1">0.</span>,<span class="pl-c1">0.</span>], <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> center, widths</span>
<span class="pl-c1">ConvexPolygon</span><span class="pl-c1">{2,4,Float64}</span>(SArray{Tuple{<span class="pl-c1">2</span>},Float64,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>}[[<span class="pl-c1">0.395191</span>, <span class="pl-c1">0.174093</span>], [<span class="pl-k">-</span><span class="pl-c1">0.395191</span>, <span class="pl-c1">0.174093</span>], [<span class="pl-k">-</span><span class="pl-c1">0.395191</span>, <span class="pl-k">-</span><span class="pl-c1">0.174093</span>], [<span class="pl-c1">0.395191</span>, <span class="pl-k">-</span><span class="pl-c1">0.174093</span>]])
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@square</span> <span class="pl-c1">ones</span>(<span class="pl-c1">3</span>), <span class="pl-c1">1.0</span> <span class="pl-c"><span class="pl-c">#</span> center, width</span>
<span class="pl-c1">ConvexPolygon</span><span class="pl-c1">{3,8,Float64}</span>(SArray{Tuple{<span class="pl-c1">3</span>},Float64,<span class="pl-c1">1</span>,<span class="pl-c1">3</span>}[[<span class="pl-c1">1.5</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">1.5</span>], [<span class="pl-c1">0.5</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">1.5</span>], [<span class="pl-c1">0.5</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">1.5</span>], [<span class="pl-c1">1.5</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">1.5</span>], [<span class="pl-c1">1.5</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">0.5</span>], [<span class="pl-c1">0.5</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">0.5</span>], [<span class="pl-c1">0.5</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">0.5</span>], [<span class="pl-c1">1.5</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">0.5</span>]])</pre></div>
<p>Random convex polygons can be constructed for 2D:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> obs <span class="pl-k">=</span> <span class="pl-c1">randpoly</span>([<span class="pl-c1">1.</span>, <span class="pl-c1">2.</span>], <span class="pl-c1">0.5</span>; scale<span class="pl-k">=</span><span class="pl-c1">1.0</span>, n<span class="pl-k">=</span><span class="pl-c1">20</span>) <span class="pl-c"><span class="pl-c">#</span> center, rotation; scale, number of vertices</span>
<span class="pl-c1">ConvexPolygon</span><span class="pl-c1">{2,20,Float64}</span>(SArray{Tuple{<span class="pl-c1">2</span>},Float64,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>}[[<span class="pl-c1">0.642686</span>, <span class="pl-c1">2.36248</span>], [<span class="pl-c1">0.622121</span>, <span class="pl-c1">2.34973</span>], [<span class="pl-c1">0.42866</span>, <span class="pl-c1">2.06399</span>], [<span class="pl-c1">0.412454</span>, <span class="pl-c1">2.0344</span>], [<span class="pl-c1">0.454968</span>, <span class="pl-c1">1.98069</span>], [<span class="pl-c1">0.499506</span>, <span class="pl-c1">1.92797</span>], [<span class="pl-c1">0.599317</span>, <span class="pl-c1">1.82251</span>], [<span class="pl-c1">0.62982</span>, <span class="pl-c1">1.79366</span>], [<span class="pl-c1">0.659987</span>, <span class="pl-c1">1.76526</span>], [<span class="pl-c1">0.733777</span>, <span class="pl-c1">1.71118</span>], [<span class="pl-c1">0.87861</span>, <span class="pl-c1">1.63702</span>], [<span class="pl-c1">1.07313</span>, <span class="pl-c1">1.54129</span>], [<span class="pl-c1">1.46142</span>, <span class="pl-c1">1.68951</span>], [<span class="pl-c1">1.46817</span>, <span class="pl-c1">1.72673</span>], [<span class="pl-c1">1.48588</span>, <span class="pl-c1">1.85669</span>], [<span class="pl-c1">1.46772</span>, <span class="pl-c1">2.06245</span>], [<span class="pl-c1">1.3987</span>, <span class="pl-c1">2.23026</span>], [<span class="pl-c1">1.30631</span>, <span class="pl-c1">2.4218</span>], [<span class="pl-c1">1.20662</span>, <span class="pl-c1">2.61294</span>], [<span class="pl-c1">0.88346</span>, <span class="pl-c1">2.47282</span>]])</pre></div>
<h3><a id="user-content-speed" class="anchor" aria-hidden="true" href="#speed"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Speed</h3>
<p>As the core routines use StaticArrays, they are very well optimized and run quickly with no memory allocations. However, it is upto to the user to provide efficient code for the <code>support</code> and a good <code>init_dir</code> vector to squeeze the best performance from the functions.</p>
<h2><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Examples</h2>
<p>Minimum distance computation in 2D:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/arlk/ConvexBodyProximityQueries.jl/raw/master/readme/collision2d.png"><img src="https://github.com/arlk/ConvexBodyProximityQueries.jl/raw/master/readme/collision2d.png" alt="" style="max-width:100%;"></a></p>
<p>Minimum distance computation in 3D:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/arlk/ConvexBodyProximityQueries.jl/raw/master/readme/collision3d.png"><img src="https://github.com/arlk/ConvexBodyProximityQueries.jl/raw/master/readme/collision3d.png" alt="" style="max-width:100%;"></a></p>
<h2><a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Related Packages</h2>
<p><a href="https://github.com/rdeits/EnhancedGJK.jl">EnhancedGJK.jl</a></p>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>References</h2>
<p>Gilbert, E. G., D. W. Johnson, and S. S. Keerthi. “A Fast Procedure for Computing the Distance between Complex Objects in Three-Dimensional Space.” IEEE Journal on Robotics and Automation 4, no. 2 (April 1988): 193–203. <a href="https://doi.org/10.1109/56.2083" rel="nofollow">https://doi.org/10.1109/56.2083</a>.</p>
</article></div>