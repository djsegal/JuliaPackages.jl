<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-qml" class="anchor" aria-hidden="true" href="#qml"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QML</h1>
<p><a href="https://travis-ci.org/barche/QML.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/209053f62d2843a303faebd4331aae8b28a887df/68747470733a2f2f7472617669732d63692e6f72672f6261726368652f514d4c2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/barche/QML.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/barche/qml-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/6fe6a694a085b6b946341acddae6b415ae4a6d65/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f37656475643477333867386d313779773f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/7edud4w38g8m17yw?svg=true" style="max-width:100%;"></a></p>
<p>This package provides an interface to <a href="http://qt.io/" rel="nofollow">Qt5 QML</a>. It uses the <a href="https://github.com/barche/CxxWrap.jl"><code>CxxWrap</code></a> package to expose C++ classes. Current functionality allows interaction between QML and Julia using basic numerical and string types, as well as display of PNG images and a very experimental OpenGL rendering element (see <code>example/gltriangle.jl</code>).</p>
<p><a target="_blank" rel="noopener noreferrer" href="example/plot.png?raw=true"><img src="example/plot.png?raw=true" alt="QML plots example" title="Plots example" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="example/gltriangle.gif?raw=true"><img src="example/gltriangle.gif?raw=true" alt="OpenGL example" title="OpenGL example, using GLAbstraction.jl" style="max-width:100%;"></a></p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>The current master version is experimental for Julia 1.0, and no binaries are available yet. Please build the binary part from <a href="https://github.com/barche/jlqml">JlQml</a> first, and then set the <code>JLQML_DIR</code> environment variable to the path to the jlqml build directory. After that, run, in pkg mode:</p>
<pre lang="text"><code>add QML#master
</code></pre>
<p>On Linux and macOS, compilation should be automatic, with dependencies installed by the packagemanager or Homebrew.jl. On Windows, binaries are downloaded. To use a non-standard Qt, set the environment variable <code>QT_ROOT</code> to the base Qt directory (the one containing <code>lib</code> and <code>bin</code> on macOS and linux, or the directory containing <code>msvc2015_64</code> or <code>msvc2015</code> on Windows).</p>
<p>You can check that the correct Qt version is used using the <code>qt_prefix_path()</code> function.</p>
<h3><a id="user-content-raspberry-pi" class="anchor" aria-hidden="true" href="#raspberry-pi"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Raspberry Pi</h3>
<p>Because of issues with LLVM library compatibility between the graphics driver on the Raspberry Pi and Julia, QML.jl will only work if you build Julia from source, using the system LLVM version 3.9. Install the <code>llvm-3.9-dev</code> package, and then build Julia with the following Make.user:</p>
<pre><code>override LLVM_CONFIG=llvm-config-3.9
override USE_SYSTEM_LLVM=1
</code></pre>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<h3><a id="user-content-running-examples" class="anchor" aria-hidden="true" href="#running-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Running examples</h3>
<p>To run the included examples, execute:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">include</span>(<span class="pl-c1">joinpath</span>(Pkg<span class="pl-k">.</span><span class="pl-c1">dir</span>(<span class="pl-s"><span class="pl-pds">"</span>QML<span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">"</span>example<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>runexamples.jl<span class="pl-pds">"</span></span>))</pre></div>
<p>The examples require some additional packages to be described by the manifest and project files in the examples directory, so from the examples directory you should
start Julia with <code>julia --project</code> and then run <code>instantiate</code> from the pkg shell.</p>
<h3><a id="user-content-loading-a-qml-file" class="anchor" aria-hidden="true" href="#loading-a-qml-file"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Loading a QML file</h3>
<p>We support three methods of loading a QML file: <code>QQmlApplicationEngine</code>, <code>QQuickView</code> and <code>QQmlComponent</code>. These behave equivalently to the corresponding Qt classes.</p>
<h4><a id="user-content-qqmlapplicationengine" class="anchor" aria-hidden="true" href="#qqmlapplicationengine"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QQmlApplicationEngine</h4>
<p>The easiest way to run the QML file <code>main.qml</code> from the current directory is using the <code>load</code> function, which will create and return a <code>QQmlApplicationEngine</code> and load the supplied QML file:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> QML
<span class="pl-c1">load</span>(<span class="pl-s"><span class="pl-pds">"</span>main.qml<span class="pl-pds">"</span></span>)
<span class="pl-c1">exec</span>()</pre></div>
<p>The lifetime of the <code>QQmlApplicationEngine</code> is managed from C++ and it gets cleaned up when the application quits. This means it is not necessary to keep a reference to the engine to prevent it from being garbage collected prematurely.</p>
<h4><a id="user-content-qquickview" class="anchor" aria-hidden="true" href="#qquickview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QQuickView</h4>
<p>The <code>QQuickView</code> creates a window, so it's not necessary to wrap the QML in <code>ApplicationWindow</code>. A QML file is loaded as follows:</p>
<div class="highlight highlight-source-julia"><pre>qview <span class="pl-k">=</span> <span class="pl-c1">init_qquickview</span>()
<span class="pl-c1">set_source</span>(qview, <span class="pl-s"><span class="pl-pds">"</span>main.qml<span class="pl-pds">"</span></span>)
QML<span class="pl-k">.</span><span class="pl-c1">show</span>(qview)
<span class="pl-c1">exec</span>()</pre></div>
<h4><a id="user-content-qqmlcomponent" class="anchor" aria-hidden="true" href="#qqmlcomponent"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QQmlComponent</h4>
<p>Using <code>QQmlComponent</code> the QML code can be set from a Julia string wrapped in <code>QByteArray</code>:</p>
<div class="highlight highlight-source-julia"><pre>qml_data <span class="pl-k">=</span> <span class="pl-c1">QByteArray</span>(<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">import ...</span>
<span class="pl-s"></span>
<span class="pl-s">ApplicationWindow {</span>
<span class="pl-s">  ...</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>)

qengine <span class="pl-k">=</span> <span class="pl-c1">init_qmlengine</span>()
qcomp <span class="pl-k">=</span> <span class="pl-c1">QQmlComponent</span>(qengine)
<span class="pl-c1">set_data</span>(qcomp, qml_data, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
<span class="pl-c1">create</span>(qcomp, <span class="pl-c1">qmlcontext</span>());

<span class="pl-c"><span class="pl-c">#</span> Run the application</span>
<span class="pl-c1">exec</span>()</pre></div>
<h2><a id="user-content-interacting-with-julia" class="anchor" aria-hidden="true" href="#interacting-with-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Interacting with Julia</h2>
<p>Interaction with Julia happens through the following mechanisms:</p>
<ul>
<li>Call Julia functions from QML</li>
<li>Read and set context properties from Julia and QML</li>
<li>Emit signals from Julia to QML</li>
<li>Use data models</li>
</ul>
<p>Note that Julia slots appear missing, but they are not needed since it is possible to directly connect a Julia function to a QML signal in the QML code (see the QTimer example below).</p>
<h3><a id="user-content-calling-julia-functions" class="anchor" aria-hidden="true" href="#calling-julia-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Calling Julia functions</h3>
<p>In Julia, functions are registered using the <code>qmlfunction</code> function:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">my_function</span>() <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello from Julia<span class="pl-pds">"</span></span>
<span class="pl-en">my_other_function</span>(a, b) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hi from Julia<span class="pl-pds">"</span></span>

<span class="pl-c1">qmlfunction</span>(<span class="pl-s"><span class="pl-pds">"</span>my_function<span class="pl-pds">"</span></span>, my_function)
<span class="pl-c1">qmlfunction</span>(<span class="pl-s"><span class="pl-pds">"</span>my_other_function<span class="pl-pds">"</span></span>, my_other_function)</pre></div>
<p>For convenience, there is also a macro that registers any number of functions that are in scope and will have the same name in QML as in Julia:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@qmlfunction</span> my_function my_other_function</pre></div>
<p>However, the macro cannot be used in the case of non-exported functions from a different module or in case the function contains a <code>!</code> character.</p>
<p>In QML, include the Julia API:</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-k">import</span> <span class="pl-en">org.julialang</span> <span class="pl-c1">1.0</span></pre></div>
<p>Then call a Julia function in QML using:</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-c1">Julia</span>.<span class="pl-en">my_function</span>()
<span class="pl-c1">Julia</span>.<span class="pl-en">my_other_function</span>(arg1, arg2)</pre></div>
<h3><a id="user-content-context-properties" class="anchor" aria-hidden="true" href="#context-properties"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Context properties</h3>
<p>Context properties are set using the context object method. To dynamically add properties from Julia, a <code>QQmlPropertyMap</code> is used, setting e.g. a property named <code>a</code>:</p>
<div class="highlight highlight-source-julia"><pre>propmap <span class="pl-k">=</span> QML<span class="pl-k">.</span><span class="pl-c1">QQmlPropertyMap</span>()
propmap[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1</span></pre></div>
<p>This sets the QML context property named <code>property_name</code> to value <code>julia_value</code>.</p>
<p>The value of a property can be queried from Julia like this:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@test</span> propmap[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">==</span> <span class="pl-c1">1</span></pre></div>
<p>To pass these properties to the QML side, the property map can be the second argument to <code>load</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">load</span>(qml_file, propmap)</pre></div>
<p>There is also a shorthand notation using keywords:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">load</span>(qml_file, a<span class="pl-k">=</span><span class="pl-c1">1</span>, b<span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>
<p>This will create context properties <code>a</code> and <code>b</code>, initialized to <code>1</code> and <code>2</code>.</p>
<h4><a id="user-content-observable-properties" class="anchor" aria-hidden="true" href="#observable-properties"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Observable properties</h4>
<p>When an <a href="https://github.com/JuliaGizmos/Observables.jl"><code>Observable</code></a> is set in a <code>QQmlPropertyMap</code>, bi-directional change notification is enabled. For example, using the Julia code:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> QML
<span class="pl-k">using</span> Observables

<span class="pl-k">const</span> qml_file <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>observable.qml<span class="pl-pds">"</span></span>
<span class="pl-k">const</span> input <span class="pl-k">=</span> <span class="pl-c1">Observable</span>(<span class="pl-c1">1.0</span>)
<span class="pl-k">const</span> output <span class="pl-k">=</span> <span class="pl-c1">Observable</span>(<span class="pl-c1">0.0</span>)

<span class="pl-c1">on</span>(output) <span class="pl-k">do</span> x
  <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Output changed to <span class="pl-pds">"</span></span>, x)
<span class="pl-k">end</span>

<span class="pl-c1">load</span>(qml_file, input<span class="pl-k">=</span>input, output<span class="pl-k">=</span>output)
<span class="pl-c1">exec_async</span>() <span class="pl-c"><span class="pl-c">#</span> run from REPL for async execution</span></pre></div>
<p>In QML we add a slider for the input and display the output, which is twice the input (computed in QML here):</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-k">import</span> <span class="pl-en">QtQuick</span> <span class="pl-c1">2.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Controls</span> <span class="pl-c1">1.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Layouts</span> <span class="pl-c1">1.0</span>

<span class="pl-c1">ApplicationWindow</span> {
  id<span class="pl-k">:</span> root
  title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Observables<span class="pl-pds">"</span></span>
  width<span class="pl-k">:</span> <span class="pl-c1">512</span>
  height<span class="pl-k">:</span> <span class="pl-c1">200</span>
  visible<span class="pl-k">:</span> <span class="pl-c1">true</span>

  ColumnLayout {
    spacing<span class="pl-k">:</span> <span class="pl-c1">6</span>
    <span class="pl-smi">anchors</span>.<span class="pl-smi">fill</span><span class="pl-k">:</span> parent

    Slider {
      value<span class="pl-k">:</span> input
      <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
      <span class="pl-smi">Layout</span>.<span class="pl-smi">fillWidth</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
      minimumValue<span class="pl-k">:</span> <span class="pl-c1">0.0</span>
      maximumValue<span class="pl-k">:</span> <span class="pl-c1">100.0</span>
      stepSize<span class="pl-k">:</span> <span class="pl-c1">1.0</span>
      tickmarksEnabled<span class="pl-k">:</span> <span class="pl-c1">true</span>
      onValueChanged<span class="pl-k">:</span> {
        input <span class="pl-k">=</span> value;
        output <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>input;
      }
    }

    <span class="pl-c1">Text</span> {
      <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
      text<span class="pl-k">:</span> output
      <span class="pl-smi">font</span>.<span class="pl-smi">pixelSize</span><span class="pl-k">:</span> <span class="pl-c1">0.1</span><span class="pl-k">*</span><span class="pl-smi">root</span>.<span class="pl-c1">height</span>
    }
  }

}</pre></div>
<p>Moving the slider will print the output on Julia. The input can also be set from the REPL using e.g. <code>input[] = 3.0</code>, and the slider will move accordingly and call QML to compute the output, which can be queried using <code>output[]</code>.</p>
<h4><a id="user-content-type-conversion" class="anchor" aria-hidden="true" href="#type-conversion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Type conversion</h4>
<p>Most fundamental types are converted implicitly. Mind that the default integer type in QML corresponds to <code>Int32</code> in Julia.</p>
<p>We also convert <code>QVariantMap</code>, exposing the indexing operator <code>[]</code> to access element by a string key. This mostly to deal with arguments passed to the QML <code>append</code> function in list models.</p>
<h3><a id="user-content-emitting-signals-from-julia" class="anchor" aria-hidden="true" href="#emitting-signals-from-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Emitting signals from Julia</h3>
<p>Defining signals must be done in QML in the JuliaSignals block, following the instructions from the <a href="http://doc.qt.io/qt-5/qtqml-syntax-objectattributes.html#signal-attributes" rel="nofollow">QML manual</a>. Example signal with connection:</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-c1">JuliaSignals</span> {
  signal <span class="pl-en">fizzBuzzFound</span>(int fizzbuzzvalue)
  onFizzBuzzFound<span class="pl-k">:</span> <span class="pl-smi">lastFizzBuzz</span>.<span class="pl-c1">text</span> <span class="pl-k">=</span> fizzbuzzvalue
}</pre></div>
<p>The above signal is emitted from Julia using simply:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@emit</span> <span class="pl-c1">fizzBuzzFound</span>(i)</pre></div>
<p><strong>There must never be more than one JuliaSignals block in QML</strong></p>
<h3><a id="user-content-using-data-models" class="anchor" aria-hidden="true" href="#using-data-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using data models</h3>
<h4><a id="user-content-listmodel" class="anchor" aria-hidden="true" href="#listmodel"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ListModel</h4>
<p>The <code>ListModel</code> type allows using data in QML views such as <code>ListView</code> and <code>Repeater</code>, providing a two-way synchronization of the data. The <a href="http://doc.qt.io/qt-5/qtquick-views-listview-dynamiclist-qml.html" rel="nofollow">dynamiclist</a> example from Qt has been translated to Julia in <code>example/dynamiclist.jl</code>. As can be seen from <a href="https://github.com/barche/QML.jl/commit/5f3e64579180fb913c47d92a438466b67098ee52">this commit</a>, the only required change was moving the model data from QML to Julia, otherwise the Qt-provided QML file is left unchanged.</p>
<p>A ListModel is constructed from a 1D Julia array. In Qt, each of the elements of a model has a series of roles, available as properties in the delegate that is used to display each item. The roles can be added using the <code>addrole</code> function, for example:</p>
<div class="highlight highlight-source-julia"><pre>julia_array <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>, <span class="pl-c1">2.2</span>]
<span class="pl-en">myrole</span>(x<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>) <span class="pl-k">=</span> <span class="pl-c1">lowercase</span>(x)
<span class="pl-en">myrole</span>(x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">=</span> <span class="pl-c1">Int</span>(<span class="pl-c1">round</span>(x))

array_model <span class="pl-k">=</span> <span class="pl-c1">ListModel</span>(julia_array)
<span class="pl-c1">addrole</span>(array_model, <span class="pl-s"><span class="pl-pds">"</span>myrole<span class="pl-pds">"</span></span>, myrole, setindex!)</pre></div>
<p>adds the role named <code>myrole</code> to <code>array_model</code>, using the function <code>myrole</code> to access the value. The <code>setindex!</code> argument is a function used to set the value for that role from QML. This argument is optional, if it is not provided the role will be read-only. The arguments of this setter are <code>collection, new_value, key</code> as in the standard <code>setindex!</code> function.</p>
<p>To use the model from QML, it can be exposed as a context attribute, e.g:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">load</span>(qml_file, array_model<span class="pl-k">=</span>array_model)</pre></div>
<p>And then in QML:</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-c1">ListView</span> {
  width<span class="pl-k">:</span> <span class="pl-c1">200</span>
  height<span class="pl-k">:</span> <span class="pl-c1">125</span>
  model<span class="pl-k">:</span> array_model
  delegate<span class="pl-k">:</span> <span class="pl-c1">Text</span> { text<span class="pl-k">:</span> myrole }
}</pre></div>
<p>If no roles are added, one default role named <code>string</code> is exposed, calling the Julia function <code>string</code> to convert whatever value in the array to a string.</p>
<p>If new elements need to be constructed from QML, a constructor can also be provided, using the <code>setconstructor</code> method, taking a <code>ListModel</code> and a Julia function as arguments, e.g. just setting identity to return the constructor argument:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">setconstructor</span>(array_model, identity)</pre></div>
<p>In the dynamiclist example, the entries in the model are all "fruits", having the roles name, cost and attributes. In Julia, this can be encapsulated in a composite type:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">mutable struct</span> Fruit
  name<span class="pl-k">::</span><span class="pl-c1">String</span>
  cost<span class="pl-k">::</span><span class="pl-c1">Float64</span>
  attributes<span class="pl-k">::</span><span class="pl-c1">ListModel</span>
<span class="pl-k">end</span></pre></div>
<p>When an array composed only of <code>Fruit</code> elements is passed to a listmodel, setters and getters for the roles and the constructor are all passed to QML automatically, i.e. this will automatically expose the roles <code>name</code>, <code>cost</code> and <code>attributes</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Our initial data</span>
fruitlist <span class="pl-k">=</span> [
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Apple<span class="pl-pds">"</span></span>, <span class="pl-c1">2.45</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Core<span class="pl-pds">"</span></span>), <span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Deciduous<span class="pl-pds">"</span></span>)])),
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Banana<span class="pl-pds">"</span></span>, <span class="pl-c1">1.95</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Tropical<span class="pl-pds">"</span></span>), <span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Seedless<span class="pl-pds">"</span></span>)])),
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Cumquat<span class="pl-pds">"</span></span>, <span class="pl-c1">3.25</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Citrus<span class="pl-pds">"</span></span>)])),
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Durian<span class="pl-pds">"</span></span>, <span class="pl-c1">9.95</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Tropical<span class="pl-pds">"</span></span>), <span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Smelly<span class="pl-pds">"</span></span>)]))]

<span class="pl-c"><span class="pl-c">#</span> Set a context property with our listmodel</span>
propmap[<span class="pl-s"><span class="pl-pds">"</span>fruitModel<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">ListModel</span>(fruitlist)</pre></div>
<p>See the full example for more details, including the addition of an extra constructor to deal with the nested <code>ListModel</code> for the attributes.</p>
<h2><a id="user-content-using-qtimer" class="anchor" aria-hidden="true" href="#using-qtimer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using QTimer</h2>
<p><code>QTimer</code> can be used to simulate running Julia code in the background. Excerpts from <a href="test/gui.jl"><code>test/gui.jl</code></a>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">const</span> bg_counter <span class="pl-k">=</span> <span class="pl-c1">Observable</span>(<span class="pl-c1">0</span>)

<span class="pl-k">function</span> <span class="pl-en">counter_slot</span>()
  <span class="pl-k">global</span> bg_counter
  bg_counter[] <span class="pl-k">+=</span> <span class="pl-c1">1</span>
<span class="pl-k">end</span>

<span class="pl-c1">@qmlfunction</span> counter_slot

<span class="pl-c1">load</span>(qml_file, timer<span class="pl-k">=</span><span class="pl-c1">QTimer</span>(), bg_counter<span class="pl-k">=</span>bg_counter)</pre></div>
<p>Use in QML like this:</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-k">import</span> <span class="pl-en">QtQuick</span> <span class="pl-c1">2.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Controls</span> <span class="pl-c1">1.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Layouts</span> <span class="pl-c1">1.0</span>
<span class="pl-k">import</span> <span class="pl-en">org.julialang</span> <span class="pl-c1">1.0</span>

<span class="pl-c1">ApplicationWindow</span> {
    title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>My Application<span class="pl-pds">"</span></span>
    width<span class="pl-k">:</span> <span class="pl-c1">480</span>
    height<span class="pl-k">:</span> <span class="pl-c1">640</span>
    visible<span class="pl-k">:</span> <span class="pl-c1">true</span>

    Connections {
      target<span class="pl-k">:</span> timer
      onTimeout<span class="pl-k">:</span> <span class="pl-smi">Julia</span>.<span class="pl-en">counter_slot</span>()
    }

    ColumnLayout {
      spacing<span class="pl-k">:</span> <span class="pl-c1">6</span>
      <span class="pl-smi">anchors</span>.<span class="pl-smi">centerIn</span><span class="pl-k">:</span> parent

      Button {
          <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
          text<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Start counting<span class="pl-pds">"</span></span>
          onClicked<span class="pl-k">:</span> <span class="pl-smi">timer</span>.<span class="pl-c1">start</span>()
      }

      <span class="pl-c1">Text</span> {
          <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
          text<span class="pl-k">:</span> <span class="pl-smi">bg_counter</span>.<span class="pl-c1">toString</span>()
      }

      Button {
          <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
          text<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Stop counting<span class="pl-pds">"</span></span>
          onClicked<span class="pl-k">:</span> <span class="pl-smi">timer</span>.<span class="pl-c1">stop</span>()
      }
  }
}
</pre></div>
<p>Note that QML provides the infrastructure to connect to the <code>QTimer</code> signal through the <code>Connections</code> item.</p>
<h2><a id="user-content-juliadisplay" class="anchor" aria-hidden="true" href="#juliadisplay"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>JuliaDisplay</h2>
<p>QML.jl provides a custom QML type named <code>JuliaDisplay</code> that acts as a standard Julia multimedia <code>Display</code>. Currently, only the <code>image/png</code> mime type is supported. Example use in QML from the <code>plot</code> example:</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-c1">JuliaDisplay</span> {
  id<span class="pl-k">:</span> jdisp
  <span class="pl-smi">Layout</span>.<span class="pl-smi">fillWidth</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
  <span class="pl-smi">Layout</span>.<span class="pl-smi">fillHeight</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
  onHeightChanged<span class="pl-k">:</span> <span class="pl-smi">root</span>.<span class="pl-en">do_plot</span>()
  onWidthChanged<span class="pl-k">:</span> <span class="pl-smi">root</span>.<span class="pl-en">do_plot</span>()
}</pre></div>
<p>The function <code>do_plot</code> is defined in the parent QML component and calls the Julia plotting routine, passing the display as an argument:</p>
<div class="highlight highlight-source-qml"><pre><span class="pl-k">function</span> <span class="pl-en">do_plot</span>()
{
  <span class="pl-k">if</span>(jdisp <span class="pl-k">===</span> <span class="pl-c1">null</span>)
    <span class="pl-k">return</span>;

  <span class="pl-smi">Julia</span>.<span class="pl-en">plotsin</span>(jdisp, <span class="pl-smi">jdisp</span>.<span class="pl-c1">width</span>, <span class="pl-smi">jdisp</span>.<span class="pl-c1">height</span>, <span class="pl-smi">amplitude</span>.<span class="pl-c1">value</span>, <span class="pl-smi">frequency</span>.<span class="pl-c1">value</span>);
}</pre></div>
<p>Of course the display can also be added using <code>pushdisplay!</code>, but passing by value can be more convenient when defining multiple displays in QML.</p>
<h2><a id="user-content-combination-with-the-repl" class="anchor" aria-hidden="true" href="#combination-with-the-repl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Combination with the REPL</h2>
<p>When launching the application using <code>exec</code>, execution in the REPL will block until the GUI is closed. If you want to continue using the REPL with an active QML gui, <code>exec_async</code> provides an alternative. This method keeps the REPL active and polls the QML interface periodically for events, using a timer in the Julia event loop. An example (requiring packages Plots.jl and PyPlot.jl) can be found in <code>example/repl-background.jl</code>, to be used as:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>example/repl-background.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>],[<span class="pl-c1">3</span>,<span class="pl-c1">4</span>])</pre></div>
<p>This should display the result of the plotting command in the QML window.</p>
<h2><a id="user-content-breaking-changes" class="anchor" aria-hidden="true" href="#breaking-changes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Breaking changes</h2>
<ul>
<li>Signals in <code>JuliaSignals</code> must have arguments of type <code>var</code></li>
<li>Role indices are 1-based now on the Julia side</li>
<li>The interface of some functions has changed because of the way CxxWrap handles references and pointers more strictly now</li>
<li>No more automatic conversion from <code>String</code> to <code>QUrl</code>, use the <code>QUrl("mystring")</code> constructor</li>
</ul>
</article></div>