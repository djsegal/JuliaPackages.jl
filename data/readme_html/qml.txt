<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-qml" class="anchor" aria-hidden="true" href="#qml"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QML</h1>
<p><a href="https://barche.github.io/QML.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Latest" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/barche/QML.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/fe77086188e51b02103c84552957cd89cf86e99d573f4dc848a07154e3b9c5a8/68747470733a2f2f636f6465636f762e696f2f67682f6261726368652f514d4c2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="CodeCov" data-canonical-src="https://codecov.io/gh/barche/QML.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a>
<a href="https://github.com/barche/QML.jl/actions?query=workflow%3Atest-linux"><img src="https://github.com/barche/QML.jl/workflows/test-linux/badge.svg" alt="test-linux" style="max-width:100%;"></a>
<a href="https://github.com/barche/QML.jl/actions?query=workflow%3Atest-win-mac"><img src="https://github.com/barche/QML.jl/workflows/test-win-mac/badge.svg" alt="test-win-mac" style="max-width:100%;"></a></p>
<p>This package provides an interface to <a href="http://qt.io/" rel="nofollow">Qt5 QML</a>. It uses the <a href="https://github.com/barche/CxxWrap.jl"><code>CxxWrap</code></a> package to expose C++ classes. Current functionality allows interaction between QML and Julia using <a href="https://github.com/JuliaGizmos/Observables.jl">Observables</a>, ListModels and function calling. There is also a generic Julia display, as well as specialized integration for image drawing, GR plots and Makie.</p>
<p><a target="_blank" rel="noopener noreferrer" href="docs/src/qml.gif?raw=true"><img src="docs/src/qml.gif?raw=true" alt="QML demo" title="QML demo" style="max-width:100%;"></a></p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>Installation on Linux, Mac and Windows should be as easy as: (in pkg mode, hit <code>]</code> in the Julia REPL):</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="add QML
"><pre><code>add QML
</code></pre></div>
<h2><a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Documentation</h2>
<p>See <a href="https://barche.github.io/QML.jl/dev" rel="nofollow">https://barche.github.io/QML.jl/dev</a></p>
<h2><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basic usage</h2>
<h3><a id="user-content-running-examples" class="anchor" aria-hidden="true" href="#running-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Running examples</h3>
<p>To run the included examples, execute:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="include(joinpath(dirname(pathof(QML)), &quot;..&quot;, &quot;example&quot;, &quot;runexamples.jl&quot;))
"><pre><span class="pl-c1">include</span>(<span class="pl-c1">joinpath</span>(<span class="pl-c1">dirname</span>(<span class="pl-c1">pathof</span>(QML)), <span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>example<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>runexamples.jl<span class="pl-pds">"</span></span>))</pre></div>
<p>The examples require some additional packages to be described by the manifest and project files in the examples directory, so from the examples directory you should
start Julia with <code>julia --project</code> and then run <code>instantiate</code> from the pkg shell.</p>
<h3><a id="user-content-loading-a-qml-file" class="anchor" aria-hidden="true" href="#loading-a-qml-file"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Loading a QML file</h3>
<p>We support three methods of loading a QML file: <code>QQmlApplicationEngine</code>, <code>QQuickView</code> and <code>QQmlComponent</code>. These behave equivalently to the corresponding Qt classes.</p>
<h4><a id="user-content-qqmlapplicationengine" class="anchor" aria-hidden="true" href="#qqmlapplicationengine"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QQmlApplicationEngine</h4>
<p>The easiest way to run the QML file <code>main.qml</code> from the current directory is using the <code>load</code> function, which will create and return a <code>QQmlApplicationEngine</code> and load the supplied QML file:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using QML
load(&quot;main.qml&quot;)
exec()
"><pre><span class="pl-k">using</span> QML
<span class="pl-c1">load</span>(<span class="pl-s"><span class="pl-pds">"</span>main.qml<span class="pl-pds">"</span></span>)
<span class="pl-c1">exec</span>()</pre></div>
<p>The lifetime of the <code>QQmlApplicationEngine</code> is managed from C++ and it gets cleaned up when the application quits. This means it is not necessary to keep a reference to the engine to prevent it from being garbage collected prematurely.</p>
<h4><a id="user-content-qquickview" class="anchor" aria-hidden="true" href="#qquickview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QQuickView</h4>
<p>The <code>QQuickView</code> creates a window, so it's not necessary to wrap the QML in <code>ApplicationWindow</code>. A QML file is loaded as follows:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="qview = init_qquickview()
set_source(qview, &quot;main.qml&quot;)
QML.show(qview)
exec()
"><pre>qview <span class="pl-k">=</span> <span class="pl-c1">init_qquickview</span>()
<span class="pl-c1">set_source</span>(qview, <span class="pl-s"><span class="pl-pds">"</span>main.qml<span class="pl-pds">"</span></span>)
QML<span class="pl-k">.</span><span class="pl-c1">show</span>(qview)
<span class="pl-c1">exec</span>()</pre></div>
<h4><a id="user-content-qqmlcomponent" class="anchor" aria-hidden="true" href="#qqmlcomponent"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QQmlComponent</h4>
<p>Using <code>QQmlComponent</code> the QML code can be set from a Julia string wrapped in <code>QByteArray</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="qml_data = QByteArray(&quot;&quot;&quot;
import ...

ApplicationWindow {
  ...
}
&quot;&quot;&quot;)

qengine = init_qmlengine()
qcomp = QQmlComponent(qengine)
set_data(qcomp, qml_data, &quot;&quot;)
create(qcomp, qmlcontext());

# Run the application
exec()
"><pre>qml_data <span class="pl-k">=</span> <span class="pl-c1">QByteArray</span>(<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">import ...</span>
<span class="pl-s"></span>
<span class="pl-s">ApplicationWindow {</span>
<span class="pl-s">  ...</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>)

qengine <span class="pl-k">=</span> <span class="pl-c1">init_qmlengine</span>()
qcomp <span class="pl-k">=</span> <span class="pl-c1">QQmlComponent</span>(qengine)
<span class="pl-c1">set_data</span>(qcomp, qml_data, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
<span class="pl-c1">create</span>(qcomp, <span class="pl-c1">qmlcontext</span>());

<span class="pl-c"><span class="pl-c">#</span> Run the application</span>
<span class="pl-c1">exec</span>()</pre></div>
<h2><a id="user-content-interacting-with-julia" class="anchor" aria-hidden="true" href="#interacting-with-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Interacting with Julia</h2>
<p>Interaction with Julia happens through the following mechanisms:</p>
<ul>
<li>Call Julia functions from QML</li>
<li>Read and set context properties from Julia and QML</li>
<li>Emit signals from Julia to QML</li>
<li>Use data models</li>
</ul>
<p>Note that Julia slots appear missing, but they are not needed since it is possible to directly connect a Julia function to a QML signal in the QML code (see the QTimer example below).</p>
<h3><a id="user-content-calling-julia-functions" class="anchor" aria-hidden="true" href="#calling-julia-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Calling Julia functions</h3>
<p>In Julia, functions are registered using the <code>qmlfunction</code> function:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="my_function() = &quot;Hello from Julia&quot;
my_other_function(a, b) = &quot;Hi from Julia&quot;

qmlfunction(&quot;my_function&quot;, my_function)
qmlfunction(&quot;my_other_function&quot;, my_other_function)
"><pre><span class="pl-en">my_function</span>() <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello from Julia<span class="pl-pds">"</span></span>
<span class="pl-en">my_other_function</span>(a, b) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hi from Julia<span class="pl-pds">"</span></span>

<span class="pl-c1">qmlfunction</span>(<span class="pl-s"><span class="pl-pds">"</span>my_function<span class="pl-pds">"</span></span>, my_function)
<span class="pl-c1">qmlfunction</span>(<span class="pl-s"><span class="pl-pds">"</span>my_other_function<span class="pl-pds">"</span></span>, my_other_function)</pre></div>
<p>For convenience, there is also a macro that registers any number of functions that are in scope and will have the same name in QML as in Julia:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@qmlfunction my_function my_other_function
"><pre><span class="pl-c1">@qmlfunction</span> my_function my_other_function</pre></div>
<p>However, the macro cannot be used in the case of non-exported functions from a different module or in case the function contains a <code>!</code> character.</p>
<p>In QML, include the Julia API:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="import org.julialang 1.0
"><pre><span class="pl-k">import</span> <span class="pl-en">org.julialang</span> <span class="pl-c1">1.0</span></pre></div>
<p>Then call a Julia function in QML using:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="Julia.my_function()
Julia.my_other_function(arg1, arg2)
"><pre><span class="pl-c1">Julia</span>.<span class="pl-en">my_function</span>()
<span class="pl-c1">Julia</span>.<span class="pl-en">my_other_function</span>(arg1, arg2)</pre></div>
<h3><a id="user-content-context-properties" class="anchor" aria-hidden="true" href="#context-properties"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Context properties</h3>
<p>Context properties are set using the context object method. To dynamically add properties from Julia, a <code>QQmlPropertyMap</code> is used, setting e.g. a property named <code>a</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="propmap = QML.QQmlPropertyMap()
propmap[&quot;a&quot;] = 1
"><pre>propmap <span class="pl-k">=</span> QML<span class="pl-k">.</span><span class="pl-c1">QQmlPropertyMap</span>()
propmap[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">1</span></pre></div>
<p>This sets the QML context property named <code>property_name</code> to value <code>julia_value</code>.</p>
<p>The value of a property can be queried from Julia like this:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@test propmap[&quot;a&quot;] == 1
"><pre><span class="pl-c1">@test</span> propmap[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">==</span> <span class="pl-c1">1</span></pre></div>
<p>To pass these properties to the QML side, the property map can be the second argument to <code>load</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="load(qml_file, propmap)
"><pre><span class="pl-c1">load</span>(qml_file, propmap)</pre></div>
<p>There is also a shorthand notation using keywords:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="load(qml_file, a=1, b=2)
"><pre><span class="pl-c1">load</span>(qml_file, a<span class="pl-k">=</span><span class="pl-c1">1</span>, b<span class="pl-k">=</span><span class="pl-c1">2</span>)</pre></div>
<p>This will create context properties <code>a</code> and <code>b</code>, initialized to <code>1</code> and <code>2</code>.</p>
<h4><a id="user-content-observable-properties" class="anchor" aria-hidden="true" href="#observable-properties"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Observable properties</h4>
<p>When an <a href="https://github.com/JuliaGizmos/Observables.jl"><code>Observable</code></a> is set in a <code>QQmlPropertyMap</code>, bi-directional change notification is enabled. For example, using the Julia code:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using QML
using Qt5QuickControls_jll
using Observables

const qml_file = &quot;observable.qml&quot;
const input = Observable(1.0)
const output = Observable(0.0)

on(output) do x
  println(&quot;Output changed to &quot;, x)
end

load(qml_file, input=input, output=output)
exec_async() # run from REPL for async execution
"><pre><span class="pl-k">using</span> QML
<span class="pl-k">using</span> Qt5QuickControls_jll
<span class="pl-k">using</span> Observables

<span class="pl-k">const</span> qml_file <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>observable.qml<span class="pl-pds">"</span></span>
<span class="pl-k">const</span> input <span class="pl-k">=</span> <span class="pl-c1">Observable</span>(<span class="pl-c1">1.0</span>)
<span class="pl-k">const</span> output <span class="pl-k">=</span> <span class="pl-c1">Observable</span>(<span class="pl-c1">0.0</span>)

<span class="pl-c1">on</span>(output) <span class="pl-k">do</span> x
  <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Output changed to <span class="pl-pds">"</span></span>, x)
<span class="pl-k">end</span>

<span class="pl-c1">load</span>(qml_file, input<span class="pl-k">=</span>input, output<span class="pl-k">=</span>output)
<span class="pl-c1">exec_async</span>() <span class="pl-c"><span class="pl-c">#</span> run from REPL for async execution</span></pre></div>
<p>In QML we add a slider for the input and display the output, which is twice the input (computed in QML here):</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="import QtQuick 2.0
import QtQuick.Controls 1.0
import QtQuick.Layouts 1.0

ApplicationWindow {
  id: root
  title: &quot;Observables&quot;
  width: 512
  height: 200
  visible: true

  ColumnLayout {
    spacing: 6
    anchors.fill: parent

    Slider {
      value: input
      Layout.alignment: Qt.AlignCenter
      Layout.fillWidth: true
      minimumValue: 0.0
      maximumValue: 100.0
      stepSize: 1.0
      tickmarksEnabled: true
      onValueChanged: {
        input = value;
        output = 2*input;
      }
    }

    Text {
      Layout.alignment: Qt.AlignCenter
      text: output
      font.pixelSize: 0.1*root.height
    }
  }

}
"><pre><span class="pl-k">import</span> <span class="pl-en">QtQuick</span> <span class="pl-c1">2.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Controls</span> <span class="pl-c1">1.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Layouts</span> <span class="pl-c1">1.0</span>

<span class="pl-c1">ApplicationWindow</span> {
  id<span class="pl-k">:</span> root
  title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Observables<span class="pl-pds">"</span></span>
  width<span class="pl-k">:</span> <span class="pl-c1">512</span>
  height<span class="pl-k">:</span> <span class="pl-c1">200</span>
  visible<span class="pl-k">:</span> <span class="pl-c1">true</span>

  ColumnLayout {
    spacing<span class="pl-k">:</span> <span class="pl-c1">6</span>
    <span class="pl-smi">anchors</span>.<span class="pl-smi">fill</span><span class="pl-k">:</span> parent

    Slider {
      value<span class="pl-k">:</span> input
      <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
      <span class="pl-smi">Layout</span>.<span class="pl-smi">fillWidth</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
      minimumValue<span class="pl-k">:</span> <span class="pl-c1">0.0</span>
      maximumValue<span class="pl-k">:</span> <span class="pl-c1">100.0</span>
      stepSize<span class="pl-k">:</span> <span class="pl-c1">1.0</span>
      tickmarksEnabled<span class="pl-k">:</span> <span class="pl-c1">true</span>
      onValueChanged<span class="pl-k">:</span> {
        input <span class="pl-k">=</span> value;
        output <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>input;
      }
    }

    <span class="pl-c1">Text</span> {
      <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
      text<span class="pl-k">:</span> output
      <span class="pl-smi">font</span>.<span class="pl-smi">pixelSize</span><span class="pl-k">:</span> <span class="pl-c1">0.1</span><span class="pl-k">*</span><span class="pl-smi">root</span>.<span class="pl-c1">height</span>
    }
  }

}</pre></div>
<p>Moving the slider will print the output on Julia. The input can also be set from the REPL using e.g. <code>input[] = 3.0</code>, and the slider will move accordingly and call QML to compute the output, which can be queried using <code>output[]</code>.</p>
<h4><a id="user-content-type-conversion" class="anchor" aria-hidden="true" href="#type-conversion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Type conversion</h4>
<p>Most fundamental types are converted implicitly. Mind that the default integer type in QML corresponds to <code>Int32</code> in Julia.</p>
<p>We also convert <code>QVariantMap</code>, exposing the indexing operator <code>[]</code> to access element by a string key. This mostly to deal with arguments passed to the QML <code>append</code> function in list models.</p>
<h3><a id="user-content-emitting-signals-from-julia" class="anchor" aria-hidden="true" href="#emitting-signals-from-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Emitting signals from Julia</h3>
<p>Defining signals must be done in QML in the JuliaSignals block, following the instructions from the <a href="http://doc.qt.io/qt-5/qtqml-syntax-objectattributes.html#signal-attributes" rel="nofollow">QML manual</a>. Example signal with connection:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="JuliaSignals {
  signal fizzBuzzFound(int fizzbuzzvalue)
  onFizzBuzzFound: lastFizzBuzz.text = fizzbuzzvalue
}
"><pre><span class="pl-c1">JuliaSignals</span> {
  signal <span class="pl-en">fizzBuzzFound</span>(int fizzbuzzvalue)
  onFizzBuzzFound<span class="pl-k">:</span> <span class="pl-smi">lastFizzBuzz</span>.<span class="pl-c1">text</span> <span class="pl-k">=</span> fizzbuzzvalue
}</pre></div>
<p>The above signal is emitted from Julia using simply:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@emit fizzBuzzFound(i)
"><pre><span class="pl-c1">@emit</span> <span class="pl-c1">fizzBuzzFound</span>(i)</pre></div>
<p><strong>There must never be more than one JuliaSignals block in QML</strong></p>
<h3><a id="user-content-using-data-models" class="anchor" aria-hidden="true" href="#using-data-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using data models</h3>
<h4><a id="user-content-listmodel" class="anchor" aria-hidden="true" href="#listmodel"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ListModel</h4>
<p>The <code>ListModel</code> type allows using data in QML views such as <code>ListView</code> and <code>Repeater</code>, providing a two-way synchronization of the data. The <a href="http://doc.qt.io/qt-5/qtquick-views-listview-dynamiclist-qml.html" rel="nofollow">dynamiclist</a> example from Qt has been translated to Julia in <code>example/dynamiclist.jl</code>. As can be seen from <a href="https://github.com/barche/QML.jl/commit/5f3e64579180fb913c47d92a438466b67098ee52">this commit</a>, the only required change was moving the model data from QML to Julia, otherwise the Qt-provided QML file is left unchanged.</p>
<p>A ListModel is constructed from a 1D Julia array. In Qt, each of the elements of a model has a series of roles, available as properties in the delegate that is used to display each item. The roles can be added using the <code>addrole</code> function, for example:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia_array = [&quot;A&quot;, 1, 2.2]
myrole(x::AbstractString) = lowercase(x)
myrole(x::Number) = Int(round(x))

array_model = ListModel(julia_array)
addrole(array_model, &quot;myrole&quot;, myrole, setindex!)
"><pre>julia_array <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>, <span class="pl-c1">2.2</span>]
<span class="pl-en">myrole</span>(x<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>) <span class="pl-k">=</span> <span class="pl-c1">lowercase</span>(x)
<span class="pl-en">myrole</span>(x<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">=</span> <span class="pl-c1">Int</span>(<span class="pl-c1">round</span>(x))

array_model <span class="pl-k">=</span> <span class="pl-c1">ListModel</span>(julia_array)
<span class="pl-c1">addrole</span>(array_model, <span class="pl-s"><span class="pl-pds">"</span>myrole<span class="pl-pds">"</span></span>, myrole, setindex!)</pre></div>
<p>adds the role named <code>myrole</code> to <code>array_model</code>, using the function <code>myrole</code> to access the value. The <code>setindex!</code> argument is a function used to set the value for that role from QML. This argument is optional, if it is not provided the role will be read-only. The arguments of this setter are <code>collection, new_value, key</code> as in the standard <code>setindex!</code> function.</p>
<p>To use the model from QML, it can be exposed as a context attribute, e.g:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="load(qml_file, array_model=array_model)
"><pre><span class="pl-c1">load</span>(qml_file, array_model<span class="pl-k">=</span>array_model)</pre></div>
<p>And then in QML:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="ListView {
  width: 200
  height: 125
  model: array_model
  delegate: Text { text: myrole }
}
"><pre><span class="pl-c1">ListView</span> {
  width<span class="pl-k">:</span> <span class="pl-c1">200</span>
  height<span class="pl-k">:</span> <span class="pl-c1">125</span>
  model<span class="pl-k">:</span> array_model
  delegate<span class="pl-k">:</span> <span class="pl-c1">Text</span> { text<span class="pl-k">:</span> myrole }
}</pre></div>
<p>If no roles are added, one default role named <code>string</code> is exposed, calling the Julia function <code>string</code> to convert whatever value in the array to a string.</p>
<p>If new elements need to be constructed from QML, a constructor can also be provided, using the <code>setconstructor</code> method, taking a <code>ListModel</code> and a Julia function as arguments, e.g. just setting identity to return the constructor argument:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="setconstructor(array_model, identity)
"><pre><span class="pl-c1">setconstructor</span>(array_model, identity)</pre></div>
<p>In the dynamiclist example, the entries in the model are all "fruits", having the roles name, cost and attributes. In Julia, this can be encapsulated in a composite type:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="mutable struct Fruit
  name::String
  cost::Float64
  attributes::ListModel
end
"><pre><span class="pl-k">mutable struct</span> Fruit
  name<span class="pl-k">::</span><span class="pl-c1">String</span>
  cost<span class="pl-k">::</span><span class="pl-c1">Float64</span>
  attributes<span class="pl-k">::</span><span class="pl-c1">ListModel</span>
<span class="pl-k">end</span></pre></div>
<p>When an array composed only of <code>Fruit</code> elements is passed to a listmodel, setters and getters for the roles and the constructor are all passed to QML automatically, i.e. this will automatically expose the roles <code>name</code>, <code>cost</code> and <code>attributes</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Our initial data
fruitlist = [
  Fruit(&quot;Apple&quot;, 2.45, ListModel([Attribute(&quot;Core&quot;), Attribute(&quot;Deciduous&quot;)])),
  Fruit(&quot;Banana&quot;, 1.95, ListModel([Attribute(&quot;Tropical&quot;), Attribute(&quot;Seedless&quot;)])),
  Fruit(&quot;Cumquat&quot;, 3.25, ListModel([Attribute(&quot;Citrus&quot;)])),
  Fruit(&quot;Durian&quot;, 9.95, ListModel([Attribute(&quot;Tropical&quot;), Attribute(&quot;Smelly&quot;)]))]

# Set a context property with our listmodel
propmap[&quot;fruitModel&quot;] = ListModel(fruitlist)
"><pre><span class="pl-c"><span class="pl-c">#</span> Our initial data</span>
fruitlist <span class="pl-k">=</span> [
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Apple<span class="pl-pds">"</span></span>, <span class="pl-c1">2.45</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Core<span class="pl-pds">"</span></span>), <span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Deciduous<span class="pl-pds">"</span></span>)])),
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Banana<span class="pl-pds">"</span></span>, <span class="pl-c1">1.95</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Tropical<span class="pl-pds">"</span></span>), <span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Seedless<span class="pl-pds">"</span></span>)])),
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Cumquat<span class="pl-pds">"</span></span>, <span class="pl-c1">3.25</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Citrus<span class="pl-pds">"</span></span>)])),
  <span class="pl-c1">Fruit</span>(<span class="pl-s"><span class="pl-pds">"</span>Durian<span class="pl-pds">"</span></span>, <span class="pl-c1">9.95</span>, <span class="pl-c1">ListModel</span>([<span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Tropical<span class="pl-pds">"</span></span>), <span class="pl-c1">Attribute</span>(<span class="pl-s"><span class="pl-pds">"</span>Smelly<span class="pl-pds">"</span></span>)]))]

<span class="pl-c"><span class="pl-c">#</span> Set a context property with our listmodel</span>
propmap[<span class="pl-s"><span class="pl-pds">"</span>fruitModel<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">ListModel</span>(fruitlist)</pre></div>
<p>See the full example for more details, including the addition of an extra constructor to deal with the nested <code>ListModel</code> for the attributes.</p>
<h2><a id="user-content-using-qtimer" class="anchor" aria-hidden="true" href="#using-qtimer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using QTimer</h2>
<p><code>QTimer</code> can be used to simulate running Julia code in the background. Excerpts from <a href="test/gui.jl"><code>test/gui.jl</code></a>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="const bg_counter = Observable(0)

function counter_slot()
  global bg_counter
  bg_counter[] += 1
end

@qmlfunction counter_slot

load(qml_file, timer=QTimer(), bg_counter=bg_counter)
"><pre><span class="pl-k">const</span> bg_counter <span class="pl-k">=</span> <span class="pl-c1">Observable</span>(<span class="pl-c1">0</span>)

<span class="pl-k">function</span> <span class="pl-en">counter_slot</span>()
  <span class="pl-k">global</span> bg_counter
  bg_counter[] <span class="pl-k">+=</span> <span class="pl-c1">1</span>
<span class="pl-k">end</span>

<span class="pl-c1">@qmlfunction</span> counter_slot

<span class="pl-c1">load</span>(qml_file, timer<span class="pl-k">=</span><span class="pl-c1">QTimer</span>(), bg_counter<span class="pl-k">=</span>bg_counter)</pre></div>
<p>Use in QML like this:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="import QtQuick 2.0
import QtQuick.Controls 1.0
import QtQuick.Layouts 1.0
import org.julialang 1.0

ApplicationWindow {
    title: &quot;My Application&quot;
    width: 480
    height: 640
    visible: true

    Connections {
      target: timer
      onTimeout: Julia.counter_slot()
    }

    ColumnLayout {
      spacing: 6
      anchors.centerIn: parent

      Button {
          Layout.alignment: Qt.AlignCenter
          text: &quot;Start counting&quot;
          onClicked: timer.start()
      }

      Text {
          Layout.alignment: Qt.AlignCenter
          text: bg_counter.toString()
      }

      Button {
          Layout.alignment: Qt.AlignCenter
          text: &quot;Stop counting&quot;
          onClicked: timer.stop()
      }
  }
}

"><pre><span class="pl-k">import</span> <span class="pl-en">QtQuick</span> <span class="pl-c1">2.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Controls</span> <span class="pl-c1">1.0</span>
<span class="pl-k">import</span> <span class="pl-en">QtQuick.Layouts</span> <span class="pl-c1">1.0</span>
<span class="pl-k">import</span> <span class="pl-en">org.julialang</span> <span class="pl-c1">1.0</span>

<span class="pl-c1">ApplicationWindow</span> {
    title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>My Application<span class="pl-pds">"</span></span>
    width<span class="pl-k">:</span> <span class="pl-c1">480</span>
    height<span class="pl-k">:</span> <span class="pl-c1">640</span>
    visible<span class="pl-k">:</span> <span class="pl-c1">true</span>

    Connections {
      target<span class="pl-k">:</span> timer
      onTimeout<span class="pl-k">:</span> <span class="pl-smi">Julia</span>.<span class="pl-en">counter_slot</span>()
    }

    ColumnLayout {
      spacing<span class="pl-k">:</span> <span class="pl-c1">6</span>
      <span class="pl-smi">anchors</span>.<span class="pl-smi">centerIn</span><span class="pl-k">:</span> parent

      Button {
          <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
          text<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Start counting<span class="pl-pds">"</span></span>
          onClicked<span class="pl-k">:</span> <span class="pl-smi">timer</span>.<span class="pl-c1">start</span>()
      }

      <span class="pl-c1">Text</span> {
          <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
          text<span class="pl-k">:</span> <span class="pl-smi">bg_counter</span>.<span class="pl-c1">toString</span>()
      }

      Button {
          <span class="pl-smi">Layout</span>.<span class="pl-smi">alignment</span><span class="pl-k">:</span> <span class="pl-smi">Qt</span>.<span class="pl-smi">AlignCenter</span>
          text<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Stop counting<span class="pl-pds">"</span></span>
          onClicked<span class="pl-k">:</span> <span class="pl-smi">timer</span>.<span class="pl-c1">stop</span>()
      }
  }
}
</pre></div>
<p>Note that QML provides the infrastructure to connect to the <code>QTimer</code> signal through the <code>Connections</code> item.</p>
<h2><a id="user-content-juliadisplay" class="anchor" aria-hidden="true" href="#juliadisplay"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>JuliaDisplay</h2>
<p>QML.jl provides a custom QML type named <code>JuliaDisplay</code> that acts as a standard Julia multimedia <code>Display</code>. Currently, only the <code>image/png</code> mime type is supported. Example use in QML from the <code>plot</code> example:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="JuliaDisplay {
  id: jdisp
  Layout.fillWidth: true
  Layout.fillHeight: true
  onHeightChanged: root.do_plot()
  onWidthChanged: root.do_plot()
}
"><pre><span class="pl-c1">JuliaDisplay</span> {
  id<span class="pl-k">:</span> jdisp
  <span class="pl-smi">Layout</span>.<span class="pl-smi">fillWidth</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
  <span class="pl-smi">Layout</span>.<span class="pl-smi">fillHeight</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
  onHeightChanged<span class="pl-k">:</span> <span class="pl-smi">root</span>.<span class="pl-en">do_plot</span>()
  onWidthChanged<span class="pl-k">:</span> <span class="pl-smi">root</span>.<span class="pl-en">do_plot</span>()
}</pre></div>
<p>The function <code>do_plot</code> is defined in the parent QML component and calls the Julia plotting routine, passing the display as an argument:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="function do_plot()
{
  if(jdisp === null)
    return;

  Julia.plotsin(jdisp, jdisp.width, jdisp.height, amplitude.value, frequency.value);
}
"><pre><span class="pl-k">function</span> <span class="pl-en">do_plot</span>()
{
  <span class="pl-k">if</span>(jdisp <span class="pl-k">===</span> <span class="pl-c1">null</span>)
    <span class="pl-k">return</span>;

  <span class="pl-smi">Julia</span>.<span class="pl-en">plotsin</span>(jdisp, <span class="pl-smi">jdisp</span>.<span class="pl-c1">width</span>, <span class="pl-smi">jdisp</span>.<span class="pl-c1">height</span>, <span class="pl-smi">amplitude</span>.<span class="pl-c1">value</span>, <span class="pl-smi">frequency</span>.<span class="pl-c1">value</span>);
}</pre></div>
<p>Of course the display can also be added using <code>pushdisplay!</code>, but passing by value can be more convenient when defining multiple displays in QML.</p>
<h2><a id="user-content-juliacanvas" class="anchor" aria-hidden="true" href="#juliacanvas"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>JuliaCanvas</h2>
<p>QML.jl provides a custom QML type named <code>JuliaCanvas</code> which presents a canvas to be painted via a julia callback function.  This approach avoids the MIME content encoding overhead of the JuliaDisplay approach.</p>
<p>Example use in QML from the <code>canvas</code> example:</p>
<div class="highlight highlight-source-qml position-relative" data-snippet-clipboard-copy-content="JuliaCanvas {
  id: circle_canvas
  paintFunction: paint_cfunction
  Layout.fillWidth: true
  Layout.fillHeight: true
  Layout.minimumWidth: 100
  Layout.minimumHeight: 100
}
"><pre><span class="pl-c1">JuliaCanvas</span> {
  id<span class="pl-k">:</span> circle_canvas
  paintFunction<span class="pl-k">:</span> paint_cfunction
  <span class="pl-smi">Layout</span>.<span class="pl-smi">fillWidth</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
  <span class="pl-smi">Layout</span>.<span class="pl-smi">fillHeight</span><span class="pl-k">:</span> <span class="pl-c1">true</span>
  <span class="pl-smi">Layout</span>.<span class="pl-smi">minimumWidth</span><span class="pl-k">:</span> <span class="pl-c1">100</span>
  <span class="pl-smi">Layout</span>.<span class="pl-smi">minimumHeight</span><span class="pl-k">:</span> <span class="pl-c1">100</span>
}</pre></div>
<p>The callback function <code>paint_cfunction</code> is defined in julia:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="
# fix callback arguments (TODO: macro this?)
function paint_circle(buffer::Array{UInt32, 1},
                      width32::Int32,
                      height32::Int32)
   width::Int = width32
   height::Int = height32
   buffer = reshape(buffer, width, height)
   buffer = reinterpret(ARGB32, buffer)
   paint_circle(buffer)
end

# callback to paint circle
function paint_circle(buffer)
   width, height = size(buffer)
   for x in 1:width
       for y in 1:height
           # paint here..., e.g.
           buffer[x,y] = ARGB32(1, 0, 0, 1) #red
       end
   end
end

load(qmlfile,
     #...
     paint_cfunction = CxxWrap.@safe_cfunction(paint_circle, Cvoid, (Array{UInt32,1}, Int32, Int32))
)
"><pre><span class="pl-c"><span class="pl-c">#</span> fix callback arguments (TODO: macro this?)</span>
<span class="pl-k">function</span> <span class="pl-en">paint_circle</span>(buffer<span class="pl-k">::</span><span class="pl-c1">Array{UInt32, 1}</span>,
                      width32<span class="pl-k">::</span><span class="pl-c1">Int32</span>,
                      height32<span class="pl-k">::</span><span class="pl-c1">Int32</span>)
   width<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> width32
   height<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> height32
   buffer <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(buffer, width, height)
   buffer <span class="pl-k">=</span> <span class="pl-c1">reinterpret</span>(ARGB32, buffer)
   <span class="pl-c1">paint_circle</span>(buffer)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> callback to paint circle</span>
<span class="pl-k">function</span> <span class="pl-en">paint_circle</span>(buffer)
   width, height <span class="pl-k">=</span> <span class="pl-c1">size</span>(buffer)
   <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>width
       <span class="pl-k">for</span> y <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>height
           <span class="pl-c"><span class="pl-c">#</span> paint here..., e.g.</span>
           buffer[x,y] <span class="pl-k">=</span> <span class="pl-c1">ARGB32</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span>red</span>
       <span class="pl-k">end</span>
   <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">load</span>(qmlfile,
     <span class="pl-c"><span class="pl-c">#</span>...</span>
     paint_cfunction <span class="pl-k">=</span> CxxWrap<span class="pl-k">.</span><span class="pl-c1">@safe_cfunction</span>(paint_circle, Cvoid, (Array{UInt32,<span class="pl-c1">1</span>}, Int32, Int32))
)</pre></div>
<p>Note that the canvas buffer is allocated (and freed) in the C++ code.  A new unitialized buffer is allocated for each frame (this could change).</p>
<p>At the moment, only the 32-bit QImage::Format_RGB32 (alpha, red, green, blue) image format is supported.</p>
<p>See the example for details on emitting an update signal from julia to force redrawing the JuliaCanvas.</p>
<hr>
<p><strong>NOTE</strong></p>
<p>Set</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ENV[&quot;QSG_RENDER_LOOP&quot;] = &quot;basic&quot;
"><pre><span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>QSG_RENDER_LOOP<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>basic<span class="pl-pds">"</span></span></pre></div>
<p>at the top of your Julia file to avoid crashes or infinite loops when using JuliaCanvas.</p>
<hr>
<h2><a id="user-content-combination-with-the-repl" class="anchor" aria-hidden="true" href="#combination-with-the-repl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Combination with the REPL</h2>
<p>When launching the application using <code>exec</code>, execution in the REPL will block until the GUI is closed. If you want to continue using the REPL with an active QML gui, <code>exec_async</code> provides an alternative. This method keeps the REPL active and polls the QML interface periodically for events, using a timer in the Julia event loop. An example (requiring packages Plots.jl and PyPlot.jl) can be found in <code>example/repl-background.jl</code>, to be used as:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="include(&quot;example/repl-background.jl&quot;)
plot([1,2],[3,4])
"><pre><span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>example/repl-background.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>],[<span class="pl-c1">3</span>,<span class="pl-c1">4</span>])</pre></div>
<p>This should display the result of the plotting command in the QML window.</p>
<p>For further examples, see the <a href="https://barche.github.io/QML.jl/dev" rel="nofollow"><code>documentation</code></a>.</p>
<h2><a id="user-content-breaking-changes" class="anchor" aria-hidden="true" href="#breaking-changes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Breaking changes</h2>
<h3><a id="user-content-upgrade-from-v06-to-v07" class="anchor" aria-hidden="true" href="#upgrade-from-v06-to-v07"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Upgrade from v0.6 to v0.7</h3>
<ul>
<li>Julia 1.6 minimal requirement</li>
<li>Need to specifically add and load Julia packages for <code>Controls</code> and <code>Controls 2</code>, i.e. <code>Qt5QuickControls_jll</code> and <code>Qt5QuickControls2_jll</code></li>
</ul>
<h3><a id="user-content-upgrade-from-v04-to-v06" class="anchor" aria-hidden="true" href="#upgrade-from-v04-to-v06"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Upgrade from v0.4 to v0.6</h3>
<ul>
<li>Signals in <code>JuliaSignals</code> must have arguments of type <code>var</code></li>
<li>Role indices are 1-based now on the Julia side</li>
<li>The interface of some functions has changed because of the way CxxWrap handles references and pointers more strictly now</li>
<li>No more automatic conversion from <code>String</code> to <code>QUrl</code>, use the <code>QUrl("mystring")</code> constructor</li>
<li>Setting a <code>QQmlPropertyMap</code> as context object is not supported as of Qt 5.12</li>
</ul>
</article></div>