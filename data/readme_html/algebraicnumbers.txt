<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h2 dir="auto"><a id="user-content-algebraicnumbersjl" class="anchor" aria-hidden="true" href="#algebraicnumbersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>AlgebraicNumbers.jl</h2>
<p dir="auto"><a href="https://github.com/anj1/AlgebraicNumbers.jl/actions"><img src="https://github.com/anj1/AlgebraicNumbers.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/anj1/AlgebraicNumbers.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/a30d8ca50fe02941a85722dee392429ba90c4a7138a05530e7bbbf57909938d0/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f616e6a312f416c676562726169634e756d626572732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/anj1/AlgebraicNumbers.jl/badge.svg?branch=master" style="max-width: 100%;"></a></p>
<h4 dir="auto"><a id="user-content-sqrt22--2" class="anchor" aria-hidden="true" href="#sqrt22--2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>sqrt(2)^2 == 2</code></h4>
<p dir="auto">This package provides a way of dealing with real and complex numbers exactly and with infinite precision. To see how this works, it's useful to compare with familiar number types like integers and so on. Integer arithmetic (e.g. 2+2==4) is exact but is limited to the operations +, -, and *. While adding, subtracting, or multiplying two integers always produces another integer, that's not always true with division. With <a href="http://docs.julialang.org/en/release-0.4/manual/complex-and-rational-numbers/#rational-numbers" rel="nofollow"><em>rational</em> numbers</a>, division is included as well. Since many numerical operations can be reduced to sequences of the four elementary operations, this allows a wider range of exact arithmetic to be carried out. <em>Algebraic</em> numbers take this further, including not only the four elementary operations, but also <em>root-taking</em> operations, for example sqrt() and cbrt(). More generally, the <em>n</em>th root of an algebraic number <code>x</code> can be taken with:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="root(x, n)"><pre><span class="pl-c1">root</span>(x, n)</pre></div>
<p dir="auto">And this will be represented exactly. For instance, you can see for yourself that:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# sqrt(x) is defined as root(x, 2)
sqrt(AlgebraicNumber(2))^2 == 2"><pre><span class="pl-c"><span class="pl-c">#</span> sqrt(x) is defined as root(x, 2)</span>
<span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">2</span>))<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">2</span></pre></div>
<p dir="auto">And this is true for any integer:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# x = any integer
sqrt(AlgebraicNumber(x))^2 == x"><pre><span class="pl-c"><span class="pl-c">#</span> x = any integer</span>
<span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(x))<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">==</span> x</pre></div>
<p dir="auto">Here, <code>AlgebraicNumber</code> is just a constructor that takes a number (either an integer or a rational number) and produces an algebraic number.</p>
<p dir="auto">You can do arithmetic on algebraic numbers and all results will be represented exactly:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sqrt2 = sqrt(AlgebraicNumber(2))
sqrt3 = sqrt(AlgebraicNumber(3))
sqrt6 = sqrt2*sqrt3
# a simple example
assert(sqrt6 == sqrt(AlgebraicNumber(6)))

# slightly more complicated
x = 1 + sqrt6
assert((x - 1)^2 == 6)

# even more complicated
assert(sqrt6 == sqrt(x^2 - 2*sqrt6 - 1))

# and here's another one
y = sqrt(x)
assert((y^2 - 1)^2 == 6)"><pre>sqrt2 <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">2</span>))
sqrt3 <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">3</span>))
sqrt6 <span class="pl-k">=</span> sqrt2<span class="pl-k">*</span>sqrt3
<span class="pl-c"><span class="pl-c">#</span> a simple example</span>
<span class="pl-c1">assert</span>(sqrt6 <span class="pl-k">==</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">6</span>)))

<span class="pl-c"><span class="pl-c">#</span> slightly more complicated</span>
x <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> sqrt6
<span class="pl-c1">assert</span>((x <span class="pl-k">-</span> <span class="pl-c1">1</span>)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">6</span>)

<span class="pl-c"><span class="pl-c">#</span> even more complicated</span>
<span class="pl-c1">assert</span>(sqrt6 <span class="pl-k">==</span> <span class="pl-c1">sqrt</span>(x<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">2</span><span class="pl-k">*</span>sqrt6 <span class="pl-k">-</span> <span class="pl-c1">1</span>))

<span class="pl-c"><span class="pl-c">#</span> and here's another one</span>
y <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(x)
<span class="pl-c1">assert</span>((y<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>)<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">6</span>)</pre></div>
<p dir="auto">Even <em>more</em> generally, arbitrary root-taking operations are possible. That is, you can represent the root of any polynomial (with integer, rational, or algebraic coefficients) as an algebraic number, even if that root doesn't have a representation in terms of a sequence of +, -, /, *, and root-taking operations.</p>
<h4 dir="auto"><a id="user-content-displaying-algebraic-numbers" class="anchor" aria-hidden="true" href="#displaying-algebraic-numbers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Displaying algebraic numbers</h4>
<p dir="auto">Note that sometimes when displaying an algebraic number, you might get a '≈' symbol, like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; sqrt(AlgebraicNumber(2))
≈1.4142135623730951 + 0.0im"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">2</span>))
<span class="pl-k">≈</span><span class="pl-c1">1.4142135623730951</span> <span class="pl-k">+</span> <span class="pl-c1">0.0im</span></pre></div>
<p dir="auto">That is, something that looks like an approximate complex number, not an exact number. This is <em>only</em> the library's way of <em>displaying</em> algebraic numbers, and it's simply because in general it is impossible to represent an algebraic number exactly in decimal notation no matter how many digits you display! Internally, algebraic numbers are represented exactly, but they are not represented using decimal or floating-point representation (more on internal representation below).</p>
<p dir="auto">When displaying algebraic numbers that <em>can</em> be represented exactly, they are shown as-is:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; AlgebraicNumber(2)
2.0 + 0.0im"><pre class="notranslate"><code>julia&gt; AlgebraicNumber(2)
2.0 + 0.0im
</code></pre></div>
<h4 dir="auto"><a id="user-content-internal-implementation" class="anchor" aria-hidden="true" href="#internal-implementation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Internal implementation</h4>
<p dir="auto">Computer algebra systems (CASes) also allow you to represent algebraic numbers, but the method they use is somewhat different. In CAS systems, numbers are typically represented using the expressions used to generate them. So <code>sqrt(2)</code> would be literally represented as <code>sqrt(2)</code>. Thus <code>^2</code> and <code>sqrt</code> cancel out to give <code>2</code>. That approach is flexible but it has a fairly large computational cost. The way algebraic numbers are represented here is different - they are represented as discrete roots of minimal polynomials. This approach is a bit more limiting (for example, the <code>exp()</code> of an algebraic number is not necessarily an algebraic number) but it is more computationally efficient and allows doing things like equality testing very rapidly and in a way that is always guaranteed to give the correct result, no matter how complicated the algebraic number is. This is something that CAS systems often cannot do.</p>
<p dir="auto">The tradeoff in using the minimal polynomial representation is that operations like addition and multiplication become non-trivial to compute, since we need to compute a new minimal polynomial, and this involves computation of <a href="http://specfun.inria.fr/bostan/publications/BoFlSaSc06.pdf" rel="nofollow">resultants</a> and polynomial factoring. The code for computing resultants has been written in pure julia (in <code>newton.jl</code>) and the polynomial factorization is done using the FLINT library, wrapped with the excellent <a href="https://github.com/wbhart/Nemo.jl">Nemo.jl</a> package. If you are just using this package, though, you usually do not need to worry about any of this.</p>
<p dir="auto">See <a href="https://pseudoprofound.wordpress.com/2016/07/09/some-fun-with-algebraic-numbers/" rel="nofollow">this blog post</a> for some more description and some neat examples.</p>
<h4 dir="auto"><a id="user-content-extra-functions" class="anchor" aria-hidden="true" href="#extra-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Extra functions</h4>
<p dir="auto">There are a few extra utility functions. For example, <code>exp_alg(x)</code> returns exp(iπx), which, assuming x is a rational number, is algebraic. For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# calculate exp(im*pi*2/3) as an algebraic number
x = exp_alg(2//3)
assert(x == sqrt(AlgebraicNumber(-3))/2 - AlgebraicNumber(1)/2)"><pre><span class="pl-c"><span class="pl-c">#</span> calculate exp(im*pi*2/3) as an algebraic number</span>
x <span class="pl-k">=</span> <span class="pl-c1">exp_alg</span>(<span class="pl-c1">2</span><span class="pl-k">//</span><span class="pl-c1">3</span>)
<span class="pl-c1">assert</span>(x <span class="pl-k">==</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-k">-</span><span class="pl-c1">3</span>))<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">1</span>)<span class="pl-k">/</span><span class="pl-c1">2</span>)</pre></div>
<p dir="auto">Similarly, <code>cos_alg(x)</code> and <code>sin_alg(x)</code> return the cosine and sine of πx, which is algebraic if x is rational. These numbers are known as the <a href="https://en.wikipedia.org/wiki/Trigonometric_number" rel="nofollow">trigonometric</a> <a href="https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#2.25.C2.B0:_regular_octacontagon_.2880-sided_polygon.29" rel="nofollow">numbers</a>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# An example trigonometric number
x = sin_alg(1//8)
y = sqrt(2 - sqrt(AlgebraicNumber(2)))/2
assert(x == y)

# Another example
x = cos_alg(2//5)
y = (sqrt(AlgebraicNumber(5))-1)/4
assert(x == y)"><pre><span class="pl-c"><span class="pl-c">#</span> An example trigonometric number</span>
x <span class="pl-k">=</span> <span class="pl-c1">sin_alg</span>(<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">8</span>)
y <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">2</span>)))<span class="pl-k">/</span><span class="pl-c1">2</span>
<span class="pl-c1">assert</span>(x <span class="pl-k">==</span> y)

<span class="pl-c"><span class="pl-c">#</span> Another example</span>
x <span class="pl-k">=</span> <span class="pl-c1">cos_alg</span>(<span class="pl-c1">2</span><span class="pl-k">//</span><span class="pl-c1">5</span>)
y <span class="pl-k">=</span> (<span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">5</span>))<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">/</span><span class="pl-c1">4</span>
<span class="pl-c1">assert</span>(x <span class="pl-k">==</span> y)</pre></div>
<p dir="auto">The inverse of these functions also exist. <code>log_alg(x)</code> returns log(x)/iπ, which, assuming x is a root of unity, is rational. If x is not a root of unity, this function returns <code>Nothing</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = exp_alg(3//7)
y = log_alg(x)
assert(y == 3//7)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">exp_alg</span>(<span class="pl-c1">3</span><span class="pl-k">//</span><span class="pl-c1">7</span>)
y <span class="pl-k">=</span> <span class="pl-c1">log_alg</span>(x)
<span class="pl-c1">assert</span>(y <span class="pl-k">==</span> <span class="pl-c1">3</span><span class="pl-k">//</span><span class="pl-c1">7</span>)</pre></div>
<p dir="auto">There are also inverse trigonometric functions <code>acos_alg</code> and <code>asin_alg</code>. If the input is a trigonometric number, the output will be a rational fraction of π, otherwise the return value will be <code>Nothing</code>. These functions are useful when doing various geometric computations.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = sqrt(AlgebraicNumber(3))/2
assert(acos_alg(x) == 1//6)
assert(asin_alg(x) == 1//3)

# More complicated example.
x = sqrt(10 + 2*sqrt(AlgebraicNumber(5)))/4
assert(acos_alg(x) == 1//10)
assert(asin_alg(x) == 4//10)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">3</span>))<span class="pl-k">/</span><span class="pl-c1">2</span>
<span class="pl-c1">assert</span>(<span class="pl-c1">acos_alg</span>(x) <span class="pl-k">==</span> <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">6</span>)
<span class="pl-c1">assert</span>(<span class="pl-c1">asin_alg</span>(x) <span class="pl-k">==</span> <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> More complicated example.</span>
x <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">10</span> <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">AlgebraicNumber</span>(<span class="pl-c1">5</span>)))<span class="pl-k">/</span><span class="pl-c1">4</span>
<span class="pl-c1">assert</span>(<span class="pl-c1">acos_alg</span>(x) <span class="pl-k">==</span> <span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">10</span>)
<span class="pl-c1">assert</span>(<span class="pl-c1">asin_alg</span>(x) <span class="pl-k">==</span> <span class="pl-c1">4</span><span class="pl-k">//</span><span class="pl-c1">10</span>)</pre></div>
<p dir="auto">Internally, these functions work by calling <code>log_alg</code>. <code>log_alg</code> then checks if the polynomial coefficients for the algebraic number are cyclotomic. If this polynomial is the nth cyclotomic polynomial, then the denominator of the result is simply n. The numerator can be calculated by taking the approximate floating-point log of the number and then multiplying by the denominator and rounding to the nearest integer.</p>
</article></div>