<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-cplexjl" class="anchor" aria-hidden="true" href="#cplexjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>CPLEX.jl</h1>
<p dir="auto"><a href="https://github.com/jump-dev/CPLEX.jl/actions?query=workflow%3ACI"><img src="https://github.com/jump-dev/CPLEX.jl/workflows/CI/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jump-dev/CPLEX.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/46013d113d28ea52b62101582bd2d85dac2e5c6a1aad26c25642c5d291e10533/68747470733a2f2f636f6465636f762e696f2f67682f6a756d702d6465762f43504c45582e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/jump-dev/CPLEX.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/jump-dev/CPLEX.jl">CPLEX.jl</a> is a wrapper for the
<a href="https://www.ibm.com/products/ilog-cplex-optimization-studio" rel="nofollow">IBM® ILOG® CPLEX® Optimization Studio</a>.</p>
<p dir="auto">CPLEX.jl has two components:</p>
<ul dir="auto">
<li>a thin wrapper around the complete C API</li>
<li>an interface to <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface</a></li>
</ul>
<p dir="auto">The C API can be accessed via <code>CPLEX.CPXxx</code> functions, where the names and
arguments are identical to the C API. See the <a href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.10.0/COS_KC_home.html" rel="nofollow">CPLEX documentation</a>
for details.</p>
<h2 dir="auto"><a id="user-content-affiliation" class="anchor" aria-hidden="true" href="#affiliation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Affiliation</h2>
<p dir="auto">This wrapper is maintained by the JuMP community and is not officially supported
by IBM. However, we thank IBM for providing us with a CPLEX license to test
<code>CPLEX.jl</code> on GitHub. If you are a commercial customer interested in official
support for CPLEX in Julia, let them know.</p>
<h2 dir="auto"><a id="user-content-license" class="anchor" aria-hidden="true" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>License</h2>
<p dir="auto"><code>CPLEX.jl</code> is licensed under the <a href="https://github.com/jump-dev/CPLEX.jl/blob/master/LICENSE.md">MIT License</a>.</p>
<p dir="auto">The underlying solver is a closed-source commercial product for which you must
<a href="https://www.ibm.com/analytics/cplex-optimizer" rel="nofollow">purchase a license</a>.</p>
<p dir="auto">Free CPLEX licenses are available for <a href="http://ibm.biz/Bdzvqw" rel="nofollow">academics and students</a>.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">CPLEX.jl requires CPLEX version 12.10, 20.1, or 22.1.</p>
<p dir="auto">First, obtain a license of CPLEX and install CPLEX solver, following the
instructions on <a href="https://www.ibm.com/analytics/cplex-optimizer" rel="nofollow">IBM's website</a>.</p>
<p dir="auto">Once installed, set the <code>CPLEX_STUDIO_BINARIES</code> environment variable as
appropriate and run <code>Pkg.add("CPLEX")</code>. For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# On Windows, this might be:
ENV[&quot;CPLEX_STUDIO_BINARIES&quot;] = &quot;C:\\Program Files\\CPLEX_Studio1210\\cplex\\bin\\x86-64_win\\&quot;
# On OSX, this might be:
ENV[&quot;CPLEX_STUDIO_BINARIES&quot;] = &quot;/Applications/CPLEX_Studio1210/cplex/bin/x86-64_osx/&quot;
# On Unix, this might be:
ENV[&quot;CPLEX_STUDIO_BINARIES&quot;] = &quot;/opt/CPLEX_Studio1210/cplex/bin/x86-64_linux/&quot;

import Pkg
Pkg.add(&quot;CPLEX&quot;)"><pre><span class="pl-c"><span class="pl-c">#</span> On Windows, this might be:</span>
<span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>CPLEX_STUDIO_BINARIES<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>C:<span class="pl-cce">\\</span>Program Files<span class="pl-cce">\\</span>CPLEX_Studio1210<span class="pl-cce">\\</span>cplex<span class="pl-cce">\\</span>bin<span class="pl-cce">\\</span>x86-64_win<span class="pl-cce">\\</span><span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> On OSX, this might be:</span>
<span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>CPLEX_STUDIO_BINARIES<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>/Applications/CPLEX_Studio1210/cplex/bin/x86-64_osx/<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> On Unix, this might be:</span>
<span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>CPLEX_STUDIO_BINARIES<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>/opt/CPLEX_Studio1210/cplex/bin/x86-64_linux/<span class="pl-pds">"</span></span>

<span class="pl-k">import</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>CPLEX<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">!!! note
The exact path may differ. Check which folder you installed CPLEX in, and
update the path accordingly.</p>
<h2 dir="auto"><a id="user-content-use-with-jump" class="anchor" aria-hidden="true" href="#use-with-jump"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Use with JuMP</h2>
<p dir="auto">Use <code>CPLEX.jl</code> with JuMP as follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP, CPLEX
model = Model(CPLEX.Optimizer)
set_attribute(model, &quot;CPX_PARAM_EPINT&quot;, 1e-8)"><pre><span class="pl-k">using</span> JuMP, CPLEX
model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(CPLEX<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">set_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>CPX_PARAM_EPINT<span class="pl-pds">"</span></span>, <span class="pl-c1">1e-8</span>)</pre></div>
<h2 dir="auto"><a id="user-content-mathoptinterface-api" class="anchor" aria-hidden="true" href="#mathoptinterface-api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MathOptInterface API</h2>
<p dir="auto">The CPLEX optimizer supports the following constraints and attributes.</p>
<p dir="auto">List of supported objective functions:</p>
<ul dir="auto">
<li><a href="@ref"><code>MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}</code></a></li>
<li><a href="@ref"><code>MOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}</code></a></li>
<li><a href="@ref"><code>MOI.ObjectiveFunction{MOI.VariableIndex}</code></a></li>
<li><a href="@ref"><code>MOI.ObjectiveFunction{MOI.VectorAffineFunction{Float64}}</code></a></li>
</ul>
<p dir="auto">List of supported variable types:</p>
<ul dir="auto">
<li><a href="@ref"><code>MOI.Reals</code></a></li>
</ul>
<p dir="auto">List of supported constraint types:</p>
<ul dir="auto">
<li><a href="@ref"><code>MOI.ScalarAffineFunction{Float64}</code></a> in <a href="@ref"><code>MOI.EqualTo{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.ScalarAffineFunction{Float64}</code></a> in <a href="@ref"><code>MOI.GreaterThan{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.ScalarAffineFunction{Float64}</code></a> in <a href="@ref"><code>MOI.LessThan{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.ScalarQuadraticFunction{Float64}</code></a> in <a href="@ref"><code>MOI.GreaterThan{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.ScalarQuadraticFunction{Float64}</code></a> in <a href="@ref"><code>MOI.LessThan{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.EqualTo{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.GreaterThan{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.Integer</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.Interval{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.LessThan{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.Semicontinuous{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.Semiinteger{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VariableIndex</code></a> in <a href="@ref"><code>MOI.ZeroOne</code></a></li>
<li><a href="@ref"><code>MOI.VectorOfVariables</code></a> in <a href="@ref"><code>MOI.SOS1{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VectorOfVariables</code></a> in <a href="@ref"><code>MOI.SOS2{Float64}</code></a></li>
<li><a href="@ref"><code>MOI.VectorOfVariables</code></a> in <a href="@ref"><code>MOI.SecondOrderCone</code></a></li>
</ul>
<p dir="auto">List of supported model attributes:</p>
<ul dir="auto">
<li><a href="@ref"><code>MOI.ConflictStatus()</code></a></li>
<li><a href="@ref"><code>MOI.HeuristicCallback()</code></a></li>
<li><a href="@ref"><code>MOI.LazyConstraintCallback()</code></a></li>
<li><a href="@ref"><code>MOI.Name()</code></a></li>
<li><a href="@ref"><code>MOI.ObjectiveSense()</code></a></li>
<li><a href="@ref"><code>MOI.UserCutCallback()</code></a></li>
</ul>
<h2 dir="auto"><a id="user-content-options" class="anchor" aria-hidden="true" href="#options"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Options</h2>
<p dir="auto">Options match those of the C API in the <a href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.10.0/ilog.odms.cplex.help/CPLEX/Parameters/topics/introListAlpha.html" rel="nofollow">CPLEX documentation</a>.</p>
<h2 dir="auto"><a id="user-content-callbacks" class="anchor" aria-hidden="true" href="#callbacks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Callbacks</h2>
<p dir="auto">CPLEX.jl provides a solver-specific callback to CPLEX:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP, CPLEX, Test

model = direct_model(CPLEX.Optimizer())
set_silent(model)

# This is very, very important!!! Only use callbacks in single-threaded mode.
MOI.set(model, MOI.NumberOfThreads(), 1)

@variable(model, 0 &lt;= x &lt;= 2.5, Int)
@variable(model, 0 &lt;= y &lt;= 2.5, Int)
@objective(model, Max, y)
cb_calls = Clong[]
function my_callback_function(cb_data::CPLEX.CallbackContext, context_id::Clong)
    # You can reference variables outside the function as normal
    push!(cb_calls, context_id)
    # You can select where the callback is run
    if context_id != CPX_CALLBACKCONTEXT_CANDIDATE
        return
    end
    ispoint_p = Ref{Cint}()
    ret = CPXcallbackcandidateispoint(cb_data, ispoint_p)
    if ret != 0 || ispoint_p[] == 0
        return  # No candidate point available or error
    end
    # You can query CALLBACKINFO items
    valueP = Ref{Cdouble}()
    ret = CPXcallbackgetinfodbl(cb_data, CPXCALLBACKINFO_BEST_BND, valueP)
    @info &quot;Best bound is currently: $(valueP[])&quot;
    # As well as any other C API
    x_p = Vector{Cdouble}(undef, 2)
    obj_p = Ref{Cdouble}()
    ret = CPXcallbackgetincumbent(cb_data, x_p, 0, 1, obj_p)
    if ret == 0
        @info &quot;Objective incumbent is: $(obj_p[])&quot;
        @info &quot;Incumbent solution is: $(x_p)&quot;
        # Use CPLEX.column to map between variable references and the 1-based
        # column.
        x_col = CPLEX.column(cb_data, index(x))
        @info &quot;x = $(x_p[x_col])&quot;
    else
        # Unable to query incumbent.
    end

    # Before querying `callback_value`, you must call:
    CPLEX.load_callback_variable_primal(cb_data, context_id)
    x_val = callback_value(cb_data, x)
    y_val = callback_value(cb_data, y)
    # You can submit solver-independent MathOptInterface attributes such as
    # lazy constraints, user-cuts, and heuristic solutions.
    if y_val - x_val &gt; 1 + 1e-6
        con = @build_constraint(y - x &lt;= 1)
        MOI.submit(model, MOI.LazyConstraint(cb_data), con)
    elseif y_val + x_val &gt; 3 + 1e-6
        con = @build_constraint(y + x &lt;= 3)
        MOI.submit(model, MOI.LazyConstraint(cb_data), con)
    end
end
MOI.set(model, CPLEX.CallbackFunction(), my_callback_function)
optimize!(model)
@test termination_status(model) == MOI.OPTIMAL
@test primal_status(model) == MOI.FEASIBLE_POINT
@test value(x) == 1
@test value(y) == 2"><pre><span class="pl-k">using</span> JuMP, CPLEX, Test

model <span class="pl-k">=</span> <span class="pl-c1">direct_model</span>(CPLEX<span class="pl-k">.</span><span class="pl-c1">Optimizer</span>())
<span class="pl-c1">set_silent</span>(model)

<span class="pl-c"><span class="pl-c">#</span> This is very, very important!!! Only use callbacks in single-threaded mode.</span>
MOI<span class="pl-k">.</span><span class="pl-c1">set</span>(model, MOI<span class="pl-k">.</span><span class="pl-c1">NumberOfThreads</span>(), <span class="pl-c1">1</span>)

<span class="pl-c1">@variable</span>(model, <span class="pl-c1">0</span> <span class="pl-k">&lt;=</span> x <span class="pl-k">&lt;=</span> <span class="pl-c1">2.5</span>, Int)
<span class="pl-c1">@variable</span>(model, <span class="pl-c1">0</span> <span class="pl-k">&lt;=</span> y <span class="pl-k">&lt;=</span> <span class="pl-c1">2.5</span>, Int)
<span class="pl-c1">@objective</span>(model, Max, y)
cb_calls <span class="pl-k">=</span> Clong[]
<span class="pl-k">function</span> <span class="pl-en">my_callback_function</span>(cb_data<span class="pl-k">::</span><span class="pl-c1">CPLEX.CallbackContext</span>, context_id<span class="pl-k">::</span><span class="pl-c1">Clong</span>)
    <span class="pl-c"><span class="pl-c">#</span> You can reference variables outside the function as normal</span>
    <span class="pl-c1">push!</span>(cb_calls, context_id)
    <span class="pl-c"><span class="pl-c">#</span> You can select where the callback is run</span>
    <span class="pl-k">if</span> context_id <span class="pl-k">!=</span> CPX_CALLBACKCONTEXT_CANDIDATE
        <span class="pl-k">return</span>
    <span class="pl-k">end</span>
    ispoint_p <span class="pl-k">=</span> <span class="pl-c1">Ref</span><span class="pl-c1">{Cint}</span>()
    ret <span class="pl-k">=</span> <span class="pl-c1">CPXcallbackcandidateispoint</span>(cb_data, ispoint_p)
    <span class="pl-k">if</span> ret <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> ispoint_p[] <span class="pl-k">==</span> <span class="pl-c1">0</span>
        <span class="pl-k">return</span>  <span class="pl-c"><span class="pl-c">#</span> No candidate point available or error</span>
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span> You can query CALLBACKINFO items</span>
    valueP <span class="pl-k">=</span> <span class="pl-c1">Ref</span><span class="pl-c1">{Cdouble}</span>()
    ret <span class="pl-k">=</span> <span class="pl-c1">CPXcallbackgetinfodbl</span>(cb_data, CPXCALLBACKINFO_BEST_BND, valueP)
    <span class="pl-c1">@info</span> <span class="pl-s"><span class="pl-pds">"</span>Best bound is currently: <span class="pl-v">$(valueP[])</span><span class="pl-pds">"</span></span>
    <span class="pl-c"><span class="pl-c">#</span> As well as any other C API</span>
    x_p <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Cdouble}</span>(undef, <span class="pl-c1">2</span>)
    obj_p <span class="pl-k">=</span> <span class="pl-c1">Ref</span><span class="pl-c1">{Cdouble}</span>()
    ret <span class="pl-k">=</span> <span class="pl-c1">CPXcallbackgetincumbent</span>(cb_data, x_p, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, obj_p)
    <span class="pl-k">if</span> ret <span class="pl-k">==</span> <span class="pl-c1">0</span>
        <span class="pl-c1">@info</span> <span class="pl-s"><span class="pl-pds">"</span>Objective incumbent is: <span class="pl-v">$(obj_p[])</span><span class="pl-pds">"</span></span>
        <span class="pl-c1">@info</span> <span class="pl-s"><span class="pl-pds">"</span>Incumbent solution is: <span class="pl-v">$(x_p)</span><span class="pl-pds">"</span></span>
        <span class="pl-c"><span class="pl-c">#</span> Use CPLEX.column to map between variable references and the 1-based</span>
        <span class="pl-c"><span class="pl-c">#</span> column.</span>
        x_col <span class="pl-k">=</span> CPLEX<span class="pl-k">.</span><span class="pl-c1">column</span>(cb_data, <span class="pl-c1">index</span>(x))
        <span class="pl-c1">@info</span> <span class="pl-s"><span class="pl-pds">"</span>x = <span class="pl-v">$(x_p[x_col])</span><span class="pl-pds">"</span></span>
    <span class="pl-k">else</span>
        <span class="pl-c"><span class="pl-c">#</span> Unable to query incumbent.</span>
    <span class="pl-k">end</span>

    <span class="pl-c"><span class="pl-c">#</span> Before querying `callback_value`, you must call:</span>
    CPLEX<span class="pl-k">.</span><span class="pl-c1">load_callback_variable_primal</span>(cb_data, context_id)
    x_val <span class="pl-k">=</span> <span class="pl-c1">callback_value</span>(cb_data, x)
    y_val <span class="pl-k">=</span> <span class="pl-c1">callback_value</span>(cb_data, y)
    <span class="pl-c"><span class="pl-c">#</span> You can submit solver-independent MathOptInterface attributes such as</span>
    <span class="pl-c"><span class="pl-c">#</span> lazy constraints, user-cuts, and heuristic solutions.</span>
    <span class="pl-k">if</span> y_val <span class="pl-k">-</span> x_val <span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">1e-6</span>
        con <span class="pl-k">=</span> <span class="pl-c1">@build_constraint</span>(y <span class="pl-k">-</span> x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>)
        MOI<span class="pl-k">.</span><span class="pl-c1">submit</span>(model, MOI<span class="pl-k">.</span><span class="pl-c1">LazyConstraint</span>(cb_data), con)
    <span class="pl-k">elseif</span> y_val <span class="pl-k">+</span> x_val <span class="pl-k">&gt;</span> <span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">1e-6</span>
        con <span class="pl-k">=</span> <span class="pl-c1">@build_constraint</span>(y <span class="pl-k">+</span> x <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>)
        MOI<span class="pl-k">.</span><span class="pl-c1">submit</span>(model, MOI<span class="pl-k">.</span><span class="pl-c1">LazyConstraint</span>(cb_data), con)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>
MOI<span class="pl-k">.</span><span class="pl-c1">set</span>(model, CPLEX<span class="pl-k">.</span><span class="pl-c1">CallbackFunction</span>(), my_callback_function)
<span class="pl-c1">optimize!</span>(model)
<span class="pl-c1">@test</span> <span class="pl-c1">termination_status</span>(model) <span class="pl-k">==</span> MOI<span class="pl-k">.</span>OPTIMAL
<span class="pl-c1">@test</span> <span class="pl-c1">primal_status</span>(model) <span class="pl-k">==</span> MOI<span class="pl-k">.</span>FEASIBLE_POINT
<span class="pl-c1">@test</span> <span class="pl-c1">value</span>(x) <span class="pl-k">==</span> <span class="pl-c1">1</span>
<span class="pl-c1">@test</span> <span class="pl-c1">value</span>(y) <span class="pl-k">==</span> <span class="pl-c1">2</span></pre></div>
<h2 dir="auto"><a id="user-content-annotations-for-automatic-benders-decomposition" class="anchor" aria-hidden="true" href="#annotations-for-automatic-benders-decomposition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Annotations for automatic Benders' decomposition</h2>
<p dir="auto">Here is an example of using the annotation feature for automatic Benders'
decomposition:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP, CPLEX

function add_annotation(
    model::JuMP.Model,
    variable_classification::Dict;
    all_variables::Bool = true,
)
    num_variables = sum(length(it) for it in values(variable_classification))
    if all_variables
        @assert num_variables == JuMP.num_variables(model)
    end
    indices, annotations = CPXINT[], CPXLONG[]
    for (key, value) in variable_classification
        for variable_ref in value
            push!(indices, variable_ref.index.value - 1)
            push!(annotations, CPX_BENDERS_MASTERVALUE + key)
        end
    end
    cplex = backend(model)
    index_p = Ref{CPXINT}()
    CPXnewlongannotation(
        cplex.env,
        cplex.lp,
        CPX_BENDERS_ANNOTATION,
        CPX_BENDERS_MASTERVALUE,
    )
    CPXgetlongannotationindex(
        cplex.env,
        cplex.lp,
        CPX_BENDERS_ANNOTATION,
        index_p,
    )
    CPXsetlongannotations(
        cplex.env,
        cplex.lp,
        index_p[],
        CPX_ANNOTATIONOBJ_COL,
        length(indices),
        indices,
        annotations,
    )
    return
end

# Problem

function illustrate_full_annotation()
    c_1, c_2 = [1, 4], [2, 3]
    dim_x, dim_y = length(c_1), length(c_2)
    b = [-2; -3]
    A_1, A_2 = [1 -3; -1 -3], [1 -2; -1 -1]
    model = JuMP.direct_model(CPLEX.Optimizer())
    set_optimizer_attribute(model, &quot;CPXPARAM_Benders_Strategy&quot;, 1)
    @variable(model, x[1:dim_x] &gt;= 0, Bin)
    @variable(model, y[1:dim_y] &gt;= 0)
    variable_classification = Dict(0 =&gt; [x[1], x[2]], 1 =&gt; [y[1], y[2]])
    @constraint(model, A_2 * y + A_1 * x .&lt;= b)
    @objective(model, Min, c_1' * x + c_2' * y)
    add_annotation(model, variable_classification)
    optimize!(model)
    x_optimal = value.(x)
    y_optimal = value.(y)
    println(&quot;x: $(x_optimal), y: $(y_optimal)&quot;)
end

function illustrate_partial_annotation()
    c_1, c_2 = [1, 4], [2, 3]
    dim_x, dim_y = length(c_1), length(c_2)
    b = [-2; -3]
    A_1, A_2 = [1 -3; -1 -3], [1 -2; -1 -1]
    model = JuMP.direct_model(CPLEX.Optimizer())
    # Note that the &quot;CPXPARAM_Benders_Strategy&quot; has to be set to 2 if partial
    # annotation is provided. If &quot;CPXPARAM_Benders_Strategy&quot; is set to 1, then
    # the following error will be thrown:
    # `CPLEX Error  2002: Invalid Benders decomposition.`
    set_optimizer_attribute(model, &quot;CPXPARAM_Benders_Strategy&quot;, 2)
    @variable(model, x[1:dim_x] &gt;= 0, Bin)
    @variable(model, y[1:dim_y] &gt;= 0)
    variable_classification = Dict(0 =&gt; [x[1]], 1 =&gt; [y[1], y[2]])
    @constraint(model, A_2 * y + A_1 * x .&lt;= b)
    @objective(model, Min, c_1' * x + c_2' * y)
    add_annotation(model, variable_classification; all_variables = false)
    optimize!(model)
    x_optimal = value.(x)
    y_optimal = value.(y)
    println(&quot;x: $(x_optimal), y: $(y_optimal)&quot;)
end"><pre><span class="pl-k">using</span> JuMP, CPLEX

<span class="pl-k">function</span> <span class="pl-en">add_annotation</span>(
    model<span class="pl-k">::</span><span class="pl-c1">JuMP.Model</span>,
    variable_classification<span class="pl-k">::</span><span class="pl-c1">Dict</span>;
    all_variables<span class="pl-k">::</span><span class="pl-c1">Bool</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>,
)
    num_variables <span class="pl-k">=</span> <span class="pl-c1">sum</span>(<span class="pl-c1">length</span>(it) <span class="pl-k">for</span> it <span class="pl-k">in</span> <span class="pl-c1">values</span>(variable_classification))
    <span class="pl-k">if</span> all_variables
        <span class="pl-c1">@assert</span> num_variables <span class="pl-k">==</span> JuMP<span class="pl-k">.</span><span class="pl-c1">num_variables</span>(model)
    <span class="pl-k">end</span>
    indices, annotations <span class="pl-k">=</span> CPXINT[], CPXLONG[]
    <span class="pl-k">for</span> (key, value) <span class="pl-k">in</span> variable_classification
        <span class="pl-k">for</span> variable_ref <span class="pl-k">in</span> value
            <span class="pl-c1">push!</span>(indices, variable_ref<span class="pl-k">.</span>index<span class="pl-k">.</span>value <span class="pl-k">-</span> <span class="pl-c1">1</span>)
            <span class="pl-c1">push!</span>(annotations, CPX_BENDERS_MASTERVALUE <span class="pl-k">+</span> key)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    cplex <span class="pl-k">=</span> <span class="pl-c1">backend</span>(model)
    index_p <span class="pl-k">=</span> <span class="pl-c1">Ref</span><span class="pl-c1">{CPXINT}</span>()
    <span class="pl-c1">CPXnewlongannotation</span>(
        cplex<span class="pl-k">.</span>env,
        cplex<span class="pl-k">.</span>lp,
        CPX_BENDERS_ANNOTATION,
        CPX_BENDERS_MASTERVALUE,
    )
    <span class="pl-c1">CPXgetlongannotationindex</span>(
        cplex<span class="pl-k">.</span>env,
        cplex<span class="pl-k">.</span>lp,
        CPX_BENDERS_ANNOTATION,
        index_p,
    )
    <span class="pl-c1">CPXsetlongannotations</span>(
        cplex<span class="pl-k">.</span>env,
        cplex<span class="pl-k">.</span>lp,
        index_p[],
        CPX_ANNOTATIONOBJ_COL,
        <span class="pl-c1">length</span>(indices),
        indices,
        annotations,
    )
    <span class="pl-k">return</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Problem</span>

<span class="pl-k">function</span> <span class="pl-en">illustrate_full_annotation</span>()
    c_1, c_2 <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">4</span>], [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
    dim_x, dim_y <span class="pl-k">=</span> <span class="pl-c1">length</span>(c_1), <span class="pl-c1">length</span>(c_2)
    b <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">2</span>; <span class="pl-k">-</span><span class="pl-c1">3</span>]
    A_1, A_2 <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">3</span>; <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">3</span>], [<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">2</span>; <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
    model <span class="pl-k">=</span> JuMP<span class="pl-k">.</span><span class="pl-c1">direct_model</span>(CPLEX<span class="pl-k">.</span><span class="pl-c1">Optimizer</span>())
    <span class="pl-c1">set_optimizer_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>CPXPARAM_Benders_Strategy<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>)
    <span class="pl-c1">@variable</span>(model, x[<span class="pl-c1">1</span><span class="pl-k">:</span>dim_x] <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>, Bin)
    <span class="pl-c1">@variable</span>(model, y[<span class="pl-c1">1</span><span class="pl-k">:</span>dim_y] <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>)
    variable_classification <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> [x[<span class="pl-c1">1</span>], x[<span class="pl-c1">2</span>]], <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> [y[<span class="pl-c1">1</span>], y[<span class="pl-c1">2</span>]])
    <span class="pl-c1">@constraint</span>(model, A_2 <span class="pl-k">*</span> y <span class="pl-k">+</span> A_1 <span class="pl-k">*</span> x <span class="pl-k">.&lt;=</span> b)
    <span class="pl-c1">@objective</span>(model, Min, c_1<span class="pl-k">'</span> <span class="pl-k">*</span> x <span class="pl-k">+</span> c_2<span class="pl-k">'</span> <span class="pl-k">*</span> y)
    <span class="pl-c1">add_annotation</span>(model, variable_classification)
    <span class="pl-c1">optimize!</span>(model)
    x_optimal <span class="pl-k">=</span> <span class="pl-c1">value</span>.(x)
    y_optimal <span class="pl-k">=</span> <span class="pl-c1">value</span>.(y)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>x: <span class="pl-v">$(x_optimal)</span>, y: <span class="pl-v">$(y_optimal)</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">illustrate_partial_annotation</span>()
    c_1, c_2 <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">4</span>], [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
    dim_x, dim_y <span class="pl-k">=</span> <span class="pl-c1">length</span>(c_1), <span class="pl-c1">length</span>(c_2)
    b <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">2</span>; <span class="pl-k">-</span><span class="pl-c1">3</span>]
    A_1, A_2 <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">3</span>; <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">3</span>], [<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">2</span>; <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>]
    model <span class="pl-k">=</span> JuMP<span class="pl-k">.</span><span class="pl-c1">direct_model</span>(CPLEX<span class="pl-k">.</span><span class="pl-c1">Optimizer</span>())
    <span class="pl-c"><span class="pl-c">#</span> Note that the "CPXPARAM_Benders_Strategy" has to be set to 2 if partial</span>
    <span class="pl-c"><span class="pl-c">#</span> annotation is provided. If "CPXPARAM_Benders_Strategy" is set to 1, then</span>
    <span class="pl-c"><span class="pl-c">#</span> the following error will be thrown:</span>
    <span class="pl-c"><span class="pl-c">#</span> `CPLEX Error  2002: Invalid Benders decomposition.`</span>
    <span class="pl-c1">set_optimizer_attribute</span>(model, <span class="pl-s"><span class="pl-pds">"</span>CPXPARAM_Benders_Strategy<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>)
    <span class="pl-c1">@variable</span>(model, x[<span class="pl-c1">1</span><span class="pl-k">:</span>dim_x] <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>, Bin)
    <span class="pl-c1">@variable</span>(model, y[<span class="pl-c1">1</span><span class="pl-k">:</span>dim_y] <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>)
    variable_classification <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> [x[<span class="pl-c1">1</span>]], <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> [y[<span class="pl-c1">1</span>], y[<span class="pl-c1">2</span>]])
    <span class="pl-c1">@constraint</span>(model, A_2 <span class="pl-k">*</span> y <span class="pl-k">+</span> A_1 <span class="pl-k">*</span> x <span class="pl-k">.&lt;=</span> b)
    <span class="pl-c1">@objective</span>(model, Min, c_1<span class="pl-k">'</span> <span class="pl-k">*</span> x <span class="pl-k">+</span> c_2<span class="pl-k">'</span> <span class="pl-k">*</span> y)
    <span class="pl-c1">add_annotation</span>(model, variable_classification; all_variables <span class="pl-k">=</span> <span class="pl-c1">false</span>)
    <span class="pl-c1">optimize!</span>(model)
    x_optimal <span class="pl-k">=</span> <span class="pl-c1">value</span>.(x)
    y_optimal <span class="pl-k">=</span> <span class="pl-c1">value</span>.(y)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>x: <span class="pl-v">$(x_optimal)</span>, y: <span class="pl-v">$(y_optimal)</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span></pre></div>
</article></div>