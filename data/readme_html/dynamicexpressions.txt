<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div align="center" dir="auto">
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/7593028/196523542-305f3fc2-18d2-41e5-9252-1f96c3d0b7e7.png"><img src="https://user-images.githubusercontent.com/7593028/196523542-305f3fc2-18d2-41e5-9252-1f96c3d0b7e7.png" height="50%" width="50%" style="max-width: 100%;"></a></p>
<p dir="auto"><em>Ridiculously fast dynamic expressions.</em></p>
<p dir="auto"><a href="https://symbolicml.org/DynamicExpressions.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a> <a href="https://github.com/SymbolicML/DynamicExpressions.jl/actions/workflows/CI.yml"><img src="https://github.com/SymbolicML/DynamicExpressions.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a> <a href="https://coveralls.io/github/SymbolicML/DynamicExpressions.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/a76fb81b35ae71c3f21697543a606d79ec637b1d0f08f25913a90640f45cf4b2/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f53796d626f6c69634d4c2f44796e616d696345787072657373696f6e732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/SymbolicML/DynamicExpressions.jl/badge.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">DynamicExpressions.jl is the backbone of <a href="https://github.com/MilesCranmer/SymbolicRegression.jl">SymbolicRegression.jl</a> and
<a href="https://github.com/MilesCranmer/PySR">PySR</a>.</p>
</div>
<h2 dir="auto"><a id="user-content-summary" class="anchor" aria-hidden="true" href="#summary"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Summary</h2>
<p dir="auto">A dynamic expression is a snippet of code that can change throughout runtime - compilation is not possible! <strong>DynamicExpressions.jl does the following:</strong></p>
<ol dir="auto">
<li>Defines an enum over user-specified operators.</li>
<li>Using this enum, it defines a <a href="https://symbolicml.org/DynamicExpressions.jl/dev/types/#DynamicExpressions.EquationModule.Node" rel="nofollow">very lightweight and type-stable data structure</a> for arbitrary expressions.</li>
<li>It then generates specialized <a href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/fe8e6dfa160d12485fb77c226d22776dd6ed697a/src/EvaluateEquation.jl#L29-L66">evaluation kernels</a> for the space of potential operators.</li>
<li>It also generates kernels for the <a href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/fe8e6dfa160d12485fb77c226d22776dd6ed697a/src/EvaluateEquationDerivative.jl#L139-L175">first-order derivatives</a>, using <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>.</li>
<li>DynamicExpressions.jl can also operate on arbitrary other types (vectors, tensors, symbols, strings, or even unions) - see last part below.</li>
</ol>
<p dir="auto">It also has import and export functionality with <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils.jl</a>, so you can move your runtime expression into a CAS!</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DynamicExpressions

operators = OperatorEnum(; binary_operators=[+, -, *], unary_operators=[cos])

x1 = Node(; feature=1)
x2 = Node(; feature=2)

expression = x1 * cos(x2 - 3.2)

X = randn(Float64, 2, 100);
expression(X, operators) # 100-element Vector{Float64}"><pre><span class="pl-k">using</span> DynamicExpressions

operators <span class="pl-k">=</span> <span class="pl-c1">OperatorEnum</span>(; binary_operators<span class="pl-k">=</span>[<span class="pl-k">+</span>, <span class="pl-k">-</span>, <span class="pl-k">*</span>], unary_operators<span class="pl-k">=</span>[cos])

x1 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(; feature<span class="pl-k">=</span><span class="pl-c1">1</span>)
x2 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(; feature<span class="pl-k">=</span><span class="pl-c1">2</span>)

expression <span class="pl-k">=</span> x1 <span class="pl-k">*</span> <span class="pl-c1">cos</span>(x2 <span class="pl-k">-</span> <span class="pl-c1">3.2</span>)

X <span class="pl-k">=</span> <span class="pl-c1">randn</span>(Float64, <span class="pl-c1">2</span>, <span class="pl-c1">100</span>);
<span class="pl-c1">expression</span>(X, operators) <span class="pl-c"><span class="pl-c">#</span> 100-element Vector{Float64}</span></pre></div>
<p dir="auto">(We can construct this expression with normal operators, since calling <code>OperatorEnum()</code> will <code>@eval</code> new functions on <code>Node</code> that use the specified enum.)</p>
<h2 dir="auto"><a id="user-content-speed" class="anchor" aria-hidden="true" href="#speed"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Speed</h2>
<p dir="auto">First, what happens if we naively use Julia symbols to define and then evaluate this expression?</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime eval(:(X[1, :] .* cos.(X[2, :] .- 3.2)))
# 117,000 ns"><pre><span class="pl-c1">@btime</span> <span class="pl-c1">eval</span>(:(X[<span class="pl-c1">1</span>, :] <span class="pl-k">.*</span> <span class="pl-c1">cos</span>.(X[<span class="pl-c1">2</span>, :] <span class="pl-k">.-</span> <span class="pl-c1">3.2</span>)))
<span class="pl-c"><span class="pl-c">#</span> 117,000 ns</span></pre></div>
<p dir="auto">This is quite slow, meaning it will be hard to quickly search over the space of expressions. Let's see how DynamicExpressions.jl compares:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime expression(X, operators)
# 693 ns"><pre><span class="pl-c1">@btime</span> <span class="pl-c1">expression</span>(X, operators)
<span class="pl-c"><span class="pl-c">#</span> 693 ns</span></pre></div>
<p dir="auto">Much faster! And we didn't even need to compile it. (Internally, this is calling <code>eval_tree_array(expression, X, operators)</code>).</p>
<p dir="auto">If we change <code>expression</code> dynamically with a random number generator, it will have the same performance:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime begin
    expression.op = rand(1:3)  # random operator in [+, -, *]
    expression(X, operators)
end
# 842 ns"><pre><span class="pl-c1">@btime</span> <span class="pl-k">begin</span>
    expression<span class="pl-k">.</span>op <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> random operator in [+, -, *]</span>
    <span class="pl-c1">expression</span>(X, operators)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> 842 ns</span></pre></div>
<p dir="auto">Now, let's see the performance if we had hard-coded these expressions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f(X) = X[1, :] .* cos.(X[2, :] .- 3.2)
@btime f(X)
# 708 ns"><pre><span class="pl-en">f</span>(X) <span class="pl-k">=</span> X[<span class="pl-c1">1</span>, :] <span class="pl-k">.*</span> <span class="pl-c1">cos</span>.(X[<span class="pl-c1">2</span>, :] <span class="pl-k">.-</span> <span class="pl-c1">3.2</span>)
<span class="pl-c1">@btime</span> <span class="pl-c1">f</span>(X)
<span class="pl-c"><span class="pl-c">#</span> 708 ns</span></pre></div>
<p dir="auto">So, our dynamic expression evaluation is about the same (or even a bit faster) as evaluating a basic hard-coded expression! Let's see if we can optimize the speed of the hard-coded version:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f_optimized(X) = begin
    y = Vector{Float64}(undef, 100)
    @inbounds @simd for i=1:100
        y[i] = X[1, i] * cos(X[2, i] - 3.2)
    end
    y
end
@btime f_optimized(X)
# 526 ns"><pre><span class="pl-en">f_optimized</span>(X) <span class="pl-k">=</span> <span class="pl-k">begin</span>
    y <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Float64}</span>(undef, <span class="pl-c1">100</span>)
    <span class="pl-c1">@inbounds</span> <span class="pl-c1">@simd</span> <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>
        y[i] <span class="pl-k">=</span> X[<span class="pl-c1">1</span>, i] <span class="pl-k">*</span> <span class="pl-c1">cos</span>(X[<span class="pl-c1">2</span>, i] <span class="pl-k">-</span> <span class="pl-c1">3.2</span>)
    <span class="pl-k">end</span>
    y
<span class="pl-k">end</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">f_optimized</span>(X)
<span class="pl-c"><span class="pl-c">#</span> 526 ns</span></pre></div>
<p dir="auto">The <code>DynamicExpressions.jl</code> version is only 25% slower than one which has been optimized by hand into a single SIMD kernel! Not bad at all.</p>
<p dir="auto">More importantly: we can change <code>expression</code> throughout runtime, and expect the same performance. This makes this data structure ideal for symbolic regression and other evaluation-based searches over expression trees.</p>
<h2 dir="auto"><a id="user-content-derivatives" class="anchor" aria-hidden="true" href="#derivatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Derivatives</h2>
<p dir="auto">We can also compute gradients with the same speed:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="operators = OperatorEnum(;
    binary_operators=[+, -, *],
    unary_operators=[cos],
    enable_autodiff=true,
)
x1 = Node(; feature=1)
x2 = Node(; feature=2)
expression = x1 * cos(x2 - 3.2)"><pre>operators <span class="pl-k">=</span> <span class="pl-c1">OperatorEnum</span>(;
    binary_operators<span class="pl-k">=</span>[<span class="pl-k">+</span>, <span class="pl-k">-</span>, <span class="pl-k">*</span>],
    unary_operators<span class="pl-k">=</span>[cos],
    enable_autodiff<span class="pl-k">=</span><span class="pl-c1">true</span>,
)
x1 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(; feature<span class="pl-k">=</span><span class="pl-c1">1</span>)
x2 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(; feature<span class="pl-k">=</span><span class="pl-c1">2</span>)
expression <span class="pl-k">=</span> x1 <span class="pl-k">*</span> <span class="pl-c1">cos</span>(x2 <span class="pl-k">-</span> <span class="pl-c1">3.2</span>)</pre></div>
<p dir="auto">We can take the gradient with respect to inputs with simply the <code>'</code> character:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="grad = expression'(X, operators)"><pre>grad <span class="pl-k">=</span> expression<span class="pl-k">'</span>(X, operators)</pre></div>
<p dir="auto">This is quite fast:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime expression'(X, operators)
# 2894 ns"><pre><span class="pl-c1">@btime</span> expression<span class="pl-k">'</span>(X, operators)
<span class="pl-c"><span class="pl-c">#</span> 2894 ns</span></pre></div>
<p dir="auto">and again, we can change this expression at runtime, without loss in performance!</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime begin
    expression.op = rand(1:3)
    expression'(X, operators)
end
# 3198 ns"><pre><span class="pl-c1">@btime</span> <span class="pl-k">begin</span>
    expression<span class="pl-k">.</span>op <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>)
    expression<span class="pl-k">'</span>(X, operators)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> 3198 ns</span></pre></div>
<p dir="auto">Internally, this is calling the <code>eval_grad_tree_array</code> function, which performs forward-mode automatic differentiation on the expression tree with Zygote-compiled kernels. We can also compute the derivative with respect to constants:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="result, grad, did_finish = eval_grad_tree_array(expression, X, operators; variable=false)"><pre>result, grad, did_finish <span class="pl-k">=</span> <span class="pl-c1">eval_grad_tree_array</span>(expression, X, operators; variable<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto">or with respect to variables, and only in a single direction:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="feature = 2
result, grad, did_finish = eval_diff_tree_array(expression, X, operators, feature)"><pre>feature <span class="pl-k">=</span> <span class="pl-c1">2</span>
result, grad, did_finish <span class="pl-k">=</span> <span class="pl-c1">eval_diff_tree_array</span>(expression, X, operators, feature)</pre></div>
<h2 dir="auto"><a id="user-content-generic-types" class="anchor" aria-hidden="true" href="#generic-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Generic types</h2>
<blockquote>
<p dir="auto">Does this work for only scalar operators on real numbers, or will it work for <code>MyCrazyType</code>?</p>
</blockquote>
<p dir="auto">I'm so glad you asked. <code>DynamicExpressions.jl</code> actually will work for <strong>arbitrary types</strong>! However, to work on operators other than real scalars, you need to use the <code>GenericOperatorEnum &lt;: AbstractOperatorEnum</code> instead of the normal <code>OperatorEnum</code>. Let's try it with strings!</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x1 = Node(String; feature=1) "><pre>x1 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(String; feature<span class="pl-k">=</span><span class="pl-c1">1</span>) </pre></div>
<p dir="auto">This node, will be used to index input data (whatever it may be) with either <code>data[feature]</code> (1D abstract arrays) or <code>selectdim(data, 1, feature)</code> (ND abstract arrays). Let's now define some operators to use:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="my_string_func(x::String) = &quot;ello $x&quot;

operators = GenericOperatorEnum(;
    binary_operators=[*],
    unary_operators=[my_string_func]
)"><pre><span class="pl-en">my_string_func</span>(x<span class="pl-k">::</span><span class="pl-c1">String</span>) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ello <span class="pl-v">$x</span><span class="pl-pds">"</span></span>

operators <span class="pl-k">=</span> <span class="pl-c1">GenericOperatorEnum</span>(;
    binary_operators<span class="pl-k">=</span>[<span class="pl-k">*</span>],
    unary_operators<span class="pl-k">=</span>[my_string_func]
)</pre></div>
<p dir="auto">Now, let's extend our operators to work with the
expression types used by <code>DynamicExpressions.jl</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@extend_operators operators"><pre><span class="pl-c1">@extend_operators</span> operators</pre></div>
<p dir="auto">Now, let's create an expression:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="tree = &quot;H&quot; * my_string_func(x1)
# ^ `(H * my_string_func(x1))`

tree([&quot;World!&quot;, &quot;Me?&quot;], operators)
# Hello World!"><pre>tree <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>H<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">my_string_func</span>(x1)
<span class="pl-c"><span class="pl-c">#</span> ^ `(H * my_string_func(x1))`</span>

<span class="pl-c1">tree</span>([<span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Me?<span class="pl-pds">"</span></span>], operators)
<span class="pl-c"><span class="pl-c">#</span> Hello World!</span></pre></div>
<p dir="auto">So indeed it works for arbitrary types. It is a bit slower due to the potential for type instability, but it's not too bad:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime tree([&quot;Hello&quot;, &quot;Me?&quot;], operators)
# 1738 ns"><pre><span class="pl-c1">@btime</span> <span class="pl-c1">tree</span>([<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Me?<span class="pl-pds">"</span></span>], operators)
<span class="pl-c"><span class="pl-c">#</span> 1738 ns</span></pre></div>
<h2 dir="auto"><a id="user-content-tensors" class="anchor" aria-hidden="true" href="#tensors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tensors</h2>
<blockquote>
<p dir="auto">Does this work for tensors, or even unions of scalars and tensors?</p>
</blockquote>
<p dir="auto">Also yes! Let's see:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using DynamicExpressions

T = Union{Float64,Vector{Float64}}

c1 = Node(T; val=0.0)  # Scalar constant
c2 = Node(T; val=[1.0, 2.0, 3.0])  # Vector constant
x1 = Node(T; feature=1)

# Some operators on tensors (multiple dispatch can be used for different behavior!)
vec_add(x, y) = x .+ y
vec_square(x) = x .* x

# Set up an operator enum:
operators = GenericOperatorEnum(;binary_operators=[vec_add], unary_operators=[vec_square])
@extend_operators operators

# Construct the expression:
tree = vec_add(vec_add(vec_square(x1), c2), c1)

X = [[-1.0, 5.2, 0.1], [0.0, 0.0, 0.0]]

# Evaluate!
tree(X, operators)  # [2.0, 29.04, 3.01]"><pre><span class="pl-k">using</span> DynamicExpressions

T <span class="pl-k">=</span> Union{Float64,Vector{Float64}}

c1 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(T; val<span class="pl-k">=</span><span class="pl-c1">0.0</span>)  <span class="pl-c"><span class="pl-c">#</span> Scalar constant</span>
c2 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(T; val<span class="pl-k">=</span>[<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>])  <span class="pl-c"><span class="pl-c">#</span> Vector constant</span>
x1 <span class="pl-k">=</span> <span class="pl-c1">Node</span>(T; feature<span class="pl-k">=</span><span class="pl-c1">1</span>)

<span class="pl-c"><span class="pl-c">#</span> Some operators on tensors (multiple dispatch can be used for different behavior!)</span>
<span class="pl-en">vec_add</span>(x, y) <span class="pl-k">=</span> x <span class="pl-k">.+</span> y
<span class="pl-en">vec_square</span>(x) <span class="pl-k">=</span> x <span class="pl-k">.*</span> x

<span class="pl-c"><span class="pl-c">#</span> Set up an operator enum:</span>
operators <span class="pl-k">=</span> <span class="pl-c1">GenericOperatorEnum</span>(;binary_operators<span class="pl-k">=</span>[vec_add], unary_operators<span class="pl-k">=</span>[vec_square])
<span class="pl-c1">@extend_operators</span> operators

<span class="pl-c"><span class="pl-c">#</span> Construct the expression:</span>
tree <span class="pl-k">=</span> <span class="pl-c1">vec_add</span>(<span class="pl-c1">vec_add</span>(<span class="pl-c1">vec_square</span>(x1), c2), c1)

X <span class="pl-k">=</span> [[<span class="pl-k">-</span><span class="pl-c1">1.0</span>, <span class="pl-c1">5.2</span>, <span class="pl-c1">0.1</span>], [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>]]

<span class="pl-c"><span class="pl-c">#</span> Evaluate!</span>
<span class="pl-c1">tree</span>(X, operators)  <span class="pl-c"><span class="pl-c">#</span> [2.0, 29.04, 3.01]</span></pre></div>
<p dir="auto">Note that if an operator is not defined for the particular input, <code>nothing</code> will be returned instead.</p>
<p dir="auto">This is all still pretty fast, too:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@btime tree(X, operators)
# 2,949 ns
@btime eval(:(vec_add(vec_add(vec_square(X[1]), [1.0, 2.0, 3.0]), 0.0)))
# 115,000 ns"><pre><span class="pl-c1">@btime</span> <span class="pl-c1">tree</span>(X, operators)
<span class="pl-c"><span class="pl-c">#</span> 2,949 ns</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">eval</span>(:(<span class="pl-c1">vec_add</span>(<span class="pl-c1">vec_add</span>(<span class="pl-c1">vec_square</span>(X[<span class="pl-c1">1</span>]), [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>]), <span class="pl-c1">0.0</span>)))
<span class="pl-c"><span class="pl-c">#</span> 115,000 ns</span></pre></div>
</article></div>