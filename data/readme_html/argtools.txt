<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-argtools" class="anchor" aria-hidden="true" href="#argtools"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ArgTools</h1>
<p><a href="https://travis-ci.org/JuliaIO/ArgTools.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/afea9f5c1df87063a6340c4b3d7ab3a130f8242d5ea3d7080900fcf5e2ef344c/68747470733a2f2f7472617669732d63692e6f72672f4a756c6961494f2f417267546f6f6c732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaIO/ArgTools.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/JuliaIO/ArgTools.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f0359dacbd370110b2b1a35470dfcb3968fe1f2d305819c08074a0f4b2d78153/68747470733a2f2f636f6465636f762e696f2f67682f4a756c6961494f2f417267546f6f6c732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/JuliaIO/ArgTools.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p><code>ArgTools</code> provides tools for creating consistent, flexible APIs that work with
various kinds of function arguments. In the current version, it helps deal with
arguments that are, at their core, IO handles, but which you'd like to allow the
user to specify directly as file names, commands, pipelines, or, of course, as
raw IO handles. For write arguments, it's also possible to use <code>nothing</code> and
write to a temporary file whose path is returned.</p>
<h2><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API</h2>
<p>There are two parts to the <code>ArgTools</code> API:</p>
<ol>
<li>Functions and types for helping define flexible function APIs.</li>
<li>Functions for helping to test APIs defined with above.</li>
</ol>
<p>While it's great to be able to define a flexible API, if you're not sure that
it works the way it's supposed to, what's the benefit. Since it's can be quite
verbose to test such a combinatorial explosion of methods, <code>ArgTools</code> also
provides tools to help testing all the ways your tools can be called to make
sure everything is working as intended.</p>
<h3><a id="user-content-argument-handling" class="anchor" aria-hidden="true" href="#argument-handling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Argument Handling</h3>
<p>The API for helping defining flexible function signatures consists of two types
and four helper functions: <code>ArgRead</code> and <code>ArgWrite</code>; <code>arg_read</code>, <code>arg_write</code>,
<code>arg_isdir</code> and <code>arg_mkdir</code>.</p>

<h4><a id="user-content-argread" class="anchor" aria-hidden="true" href="#argread"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ArgRead</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ArgRead = Union{AbstractString, AbstractCmd, IO}
"><pre>ArgRead <span class="pl-k">=</span> Union{AbstractString, AbstractCmd, IO}</pre></div>
<p>The <code>ArgRead</code> types is a union of the types that the <code>arg_read</code> function knows
how to convert into readable IO handles. See <a href="@ref"><code>arg_read</code></a> for details.</p>
<h4><a id="user-content-argwrite" class="anchor" aria-hidden="true" href="#argwrite"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ArgWrite</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ArgWrite = Union{AbstractString, AbstractCmd, IO}
"><pre>ArgWrite <span class="pl-k">=</span> Union{AbstractString, AbstractCmd, IO}</pre></div>
<p>The <code>ArgWrite</code> types is a union of the types that the <code>arg_write</code> function knows
how to convert into writeable IO handles, except for <code>Nothing</code> which <code>arg_write</code>
handles by generating a temporary file. See <a href="@ref"><code>arg_write</code></a> for details.</p>
<h4><a id="user-content-arg_read" class="anchor" aria-hidden="true" href="#arg_read"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>arg_read</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="arg_read(f::Function, arg::ArgRead) -&gt; f(arg_io)
"><pre><span class="pl-c1">arg_read</span>(f<span class="pl-k">::</span><span class="pl-c1">Function</span>, arg<span class="pl-k">::</span><span class="pl-c1">ArgRead</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f</span>(arg_io)</pre></div>
<p>The <code>arg_read</code> function accepts an argument <code>arg</code> that can be any of these:</p>
<ul>
<li><code>AbstractString</code>: a file path to be opened for reading</li>
<li><code>AbstractCmd</code>: a command to be run, reading from its standard output</li>
<li><code>IO</code>: an open IO handle to be read from</li>
</ul>
<p>Whether the body returns normally or throws an error, a path which is opened
will be closed before returning from <code>arg_read</code> and an <code>IO</code> handle will be
flushed but not closed before returning from <code>arg_read</code>.</p>
<h4><a id="user-content-arg_write" class="anchor" aria-hidden="true" href="#arg_write"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>arg_write</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="arg_write(f::Function, arg::ArgWrite) -&gt; arg
arg_write(f::Function, arg::Nothing) -&gt; tempname()
"><pre><span class="pl-c1">arg_write</span>(f<span class="pl-k">::</span><span class="pl-c1">Function</span>, arg<span class="pl-k">::</span><span class="pl-c1">ArgWrite</span>) <span class="pl-k">-&gt;</span> arg
<span class="pl-c1">arg_write</span>(f<span class="pl-k">::</span><span class="pl-c1">Function</span>, arg<span class="pl-k">::</span><span class="pl-c1">Nothing</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">tempname</span>()</pre></div>
<p>The <code>arg_write</code> function accepts an argument <code>arg</code> that can be any of these:</p>
<ul>
<li><code>AbstractString</code>: a file path to be opened for writing</li>
<li><code>AbstractCmd</code>: a command to be run, writing to its standard input</li>
<li><code>IO</code>: an open IO handle to be written to</li>
<li><code>Nothing</code>: a temporary path should be written to</li>
</ul>
<p>If the body returns normally, a path that is opened will be closed upon
completion; an IO handle argument is left open but flushed before return. If the
argument is <code>nothing</code> then a temporary path is opened for writing and closed
open completion and the path is returned from <code>arg_write</code>. In all other cases,
<code>arg</code> itself is returned. This is a useful pattern since you can consistently
return whatever was written, whether an argument was passed or not.</p>
<p>If there is an error during the evaluation of the body, a path that is opened by
<code>arg_write</code> for writing will be deleted, whether it's passed in as a string or a
temporary path generated when <code>arg</code> is <code>nothing</code>.</p>
<h4><a id="user-content-arg_isdir" class="anchor" aria-hidden="true" href="#arg_isdir"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>arg_isdir</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="arg_isdir(f::Function, arg::AbstractString) -&gt; f(arg)
"><pre><span class="pl-c1">arg_isdir</span>(f<span class="pl-k">::</span><span class="pl-c1">Function</span>, arg<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f</span>(arg)</pre></div>
<p>The <code>arg_isdir</code> function takes <code>arg</code> which must be the path to an existing
directory (an error is raised otherwise) and passes that path to <code>f</code> finally
returning the result of <code>f(arg)</code>. This is definitely the least useful tool
offered by <code>ArgTools</code> and mostly exists for symmetry with <code>arg_mkdir</code> and to
give consistent error messages.</p>
<h4><a id="user-content-arg_mkdir" class="anchor" aria-hidden="true" href="#arg_mkdir"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>arg_mkdir</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="arg_mkdir(f::Function, arg::AbstractString) -&gt; arg
arg_mkdir(f::Function, arg::Nothing) -&gt; mktempdir()
"><pre><span class="pl-c1">arg_mkdir</span>(f<span class="pl-k">::</span><span class="pl-c1">Function</span>, arg<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>) <span class="pl-k">-&gt;</span> arg
<span class="pl-c1">arg_mkdir</span>(f<span class="pl-k">::</span><span class="pl-c1">Function</span>, arg<span class="pl-k">::</span><span class="pl-c1">Nothing</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">mktempdir</span>()</pre></div>
<p>The <code>arg_mkdir</code> function takes <code>arg</code> which must either be one of:</p>
<ul>
<li>a path to an already existing empty directory,</li>
<li>a non-existent path which can be created as a directory, or</li>
<li><code>nothing</code> in which case a temporary directory is created.</li>
</ul>
<p>In all cases the path to the directory is returned. If an error occurs during
<code>f(arg)</code>, the directory is returned to its original state: if it already existed
but was empty, it will be emptied; if it did not exist it will be deleted.</p>

<h3><a id="user-content-function-testing" class="anchor" aria-hidden="true" href="#function-testing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Function Testing</h3>
<p>Using <code>ArgTools</code> is easy; thoroughly testing flexible functions defined using
<code>ArgTools</code> is a bit trickier, but the package includes testing tools that help.
The API for testing functions defined with the argument handling API consists
of two functions and a macro: <code>arg_readers</code>, <code>arg_writers</code> and <code>@arg_test</code>.</p>

<h4><a id="user-content-arg_readers" class="anchor" aria-hidden="true" href="#arg_readers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>arg_readers</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="arg_readers(arg :: AbstractString, [ type = ArgRead ]) do arg::Function
    ## pre-test setup ##
    @arg_test arg begin
        arg :: ArgRead
        ## test using `arg` ##
    end
    ## post-test cleanup ##
end
"><pre><span class="pl-c1">arg_readers</span>(arg <span class="pl-k">::</span> <span class="pl-c1">AbstractString</span>, [ type <span class="pl-k">=</span> ArgRead ]) <span class="pl-k">do</span> arg<span class="pl-k">::</span><span class="pl-c1">Function</span>
    <span class="pl-c"><span class="pl-c">#</span># pre-test setup ##</span>
    <span class="pl-c1">@arg_test</span> arg <span class="pl-k">begin</span>
        arg <span class="pl-k">::</span> <span class="pl-c1">ArgRead</span>
        <span class="pl-c"><span class="pl-c">#</span># test using `arg` ##</span>
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span># post-test cleanup ##</span>
<span class="pl-k">end</span></pre></div>
<p>The <code>arg_readers</code> function takes a path to be read and a single-argument do
block, which is invoked once for each test reader type that <code>arg_read</code> can
handle. If the optional <code>type</code> argument is given then the do block is only
invoked for readers that produce arguments of that type.</p>
<p>The <code>arg</code> passed to the do block is not the argument value itself, because some
of test argument types need to be initialized and finalized for each test case.
Consider an open file handle argument: once you've used it for one test, you
can't use it again; you need to close it and open the file again for the next
test. This function <code>arg</code> can be converted into an <code>ArgRead</code> instance using
<code>@arg_test arg begin ... end</code>.</p>
<h4><a id="user-content-arg_writers" class="anchor" aria-hidden="true" href="#arg_writers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>arg_writers</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="arg_writers([ type = ArgWrite ]) do path::String, arg::Function
    ## pre-test setup ##
    @arg_test arg begin
        arg :: ArgWrite
        ## test using `arg` ##
    end
    ## post-test cleanup ##
end
"><pre><span class="pl-c1">arg_writers</span>([ type <span class="pl-k">=</span> ArgWrite ]) <span class="pl-k">do</span> path<span class="pl-k">::</span><span class="pl-c1">String</span>, arg<span class="pl-k">::</span><span class="pl-c1">Function</span>
    <span class="pl-c"><span class="pl-c">#</span># pre-test setup ##</span>
    <span class="pl-c1">@arg_test</span> arg <span class="pl-k">begin</span>
        arg <span class="pl-k">::</span> <span class="pl-c1">ArgWrite</span>
        <span class="pl-c"><span class="pl-c">#</span># test using `arg` ##</span>
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span># post-test cleanup ##</span>
<span class="pl-k">end</span></pre></div>
<p>The <code>arg_writers</code> function takes a do block, which is invoked once for each test
writer type that <code>arg_write</code> can handle with a temporary (non-existent) <code>path</code>
and <code>arg</code> which can be converted into various writable argument types which
write to <code>path</code>. If the optional <code>type</code> argument is given then the do block is
only invoked for writers that produce arguments of that type.</p>
<p>The <code>arg</code> passed to the do block is not the argument value itself, because some
of test argument types need to be initialized and finalized for each test case.
Consider an open file handle argument: once you've used it for one test, you
can't use it again; you need to close it and open the file again for the next
test. This function <code>arg</code> can be converted into an <code>ArgWrite</code> instance using
<code>@arg_test arg begin ... end</code>.</p>
<p>There is also an <code>arg_writers</code> method that takes a path name like <code>arg_readers</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="arg_writers(path::AbstractString, [ type = ArgWrite ]) do arg::Function
    ## pre-test setup ##
    @arg_test arg begin
        arg :: ArgWrite
        ## test using `arg` ##
    end
    ## post-test cleanup ##
end
"><pre><span class="pl-c1">arg_writers</span>(path<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>, [ type <span class="pl-k">=</span> ArgWrite ]) <span class="pl-k">do</span> arg<span class="pl-k">::</span><span class="pl-c1">Function</span>
    <span class="pl-c"><span class="pl-c">#</span># pre-test setup ##</span>
    <span class="pl-c1">@arg_test</span> arg <span class="pl-k">begin</span>
        arg <span class="pl-k">::</span> <span class="pl-c1">ArgWrite</span>
        <span class="pl-c"><span class="pl-c">#</span># test using `arg` ##</span>
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span># post-test cleanup ##</span>
<span class="pl-k">end</span></pre></div>
<p>This method is useful if you need to specify <code>path</code> instead of using path name
generated by <code>tempname()</code>. Since <code>path</code> is passed from outside of <code>arg_writers</code>,
the path is not an argument to the do block in this form.</p>
<h4><a id="user-content-arg_test" class="anchor" aria-hidden="true" href="#arg_test"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>@arg_test</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@arg_test arg1 arg2 ... body
"><pre><span class="pl-c1">@arg_test</span> arg1 arg2 <span class="pl-k">...</span> body</pre></div>
<p>The <code>@arg_test</code> macro is used to convert <code>arg</code> functions provided by
<code>arg_readers</code> and <code>arg_writers</code> into actual argument values. When you write
<code>@arg_test arg body</code> it is equivalent to <code>arg(arg -&gt; body)</code>.</p>

<h2><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<p>The examples, like the API, are split into two parts:</p>
<ol>
<li>An example of defining a function with a flexible API using the main API;</li>
<li>Examples of how to thoroughly test that function using the test utilities.</li>
</ol>
<h3><a id="user-content-usage-example" class="anchor" aria-hidden="true" href="#usage-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage Example</h3>
<p>The best explanation may be an example, which is also used for testing:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using ArgTools

function send_data(src::ArgRead, dst::Union{ArgWrite, Nothing} = nothing)
    arg_read(src) do src_io
        arg_write(dst) do dst_io
            buffer = Vector{UInt8}(undef, 2*1024*1024)
            while !eof(src_io)
                n = readbytes!(src_io, buffer)
                write(dst_io, view(buffer, 1:n))
            end
        end
    end
end
"><pre><span class="pl-k">using</span> ArgTools

<span class="pl-k">function</span> <span class="pl-en">send_data</span>(src<span class="pl-k">::</span><span class="pl-c1">ArgRead</span>, dst<span class="pl-k">::</span><span class="pl-c1">Union{ArgWrite, Nothing}</span> <span class="pl-k">=</span> <span class="pl-c1">nothing</span>)
    <span class="pl-c1">arg_read</span>(src) <span class="pl-k">do</span> src_io
        <span class="pl-c1">arg_write</span>(dst) <span class="pl-k">do</span> dst_io
            buffer <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{UInt8}</span>(undef, <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">1024</span><span class="pl-k">*</span><span class="pl-c1">1024</span>)
            <span class="pl-k">while</span> <span class="pl-k">!</span><span class="pl-c1">eof</span>(src_io)
                n <span class="pl-k">=</span> <span class="pl-c1">readbytes!</span>(src_io, buffer)
                <span class="pl-c1">write</span>(dst_io, <span class="pl-c1">view</span>(buffer, <span class="pl-c1">1</span><span class="pl-k">:</span>n))
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p>This defines the <code>send_data</code> function which reads data from a source and writes
it to a destination, specified by the <code>src</code> and <code>dst</code> arguments, respectively.
Thanks to <code>ArgTools</code>, this relatively simple definition acts as a swiss-army
knife for sending data from a source to a destination. Here are some examples:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; cd(mktempdir())

julia&gt; write(&quot;hello.txt&quot;, &quot;Hello, world.\n&quot;)
14

julia&gt; run(`cat hello.txt`);
Hello, world.

julia&gt; send_data(&quot;hello.txt&quot;, &quot;hello_copy.txt&quot;)
&quot;hello_copy.txt&quot;

julia&gt; run(`cat $ans`);
Hello, world.

julia&gt; rm(&quot;hello_copy.txt&quot;)

julia&gt; send_data(&quot;hello.txt&quot;, stdout);
Hello, world.

julia&gt; send_data(&quot;hello.txt&quot;, pipeline(`gzip -9`, &quot;hello.gz&quot;));

julia&gt; run(`gzcat hello.gz`);
Hello, world.

julia&gt; hello_copy = send_data(`gzcat hello.gz`)
&quot;/var/folders/4g/b8p546px3nd550b3k288mhp80000gp/T/jl_cguepi&quot;

julia&gt; run(`cat $hello_copy`);
Hello, world.
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">cd</span>(<span class="pl-c1">mktempdir</span>())

julia<span class="pl-k">&gt;</span> <span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>hello.txt<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Hello, world.<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>)
<span class="pl-c1">14</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>cat hello.txt<span class="pl-pds">`</span></span>);
Hello, world.

julia<span class="pl-k">&gt;</span> <span class="pl-c1">send_data</span>(<span class="pl-s"><span class="pl-pds">"</span>hello.txt<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>hello_copy.txt<span class="pl-pds">"</span></span>)
<span class="pl-s"><span class="pl-pds">"</span>hello_copy.txt<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>cat $ans<span class="pl-pds">`</span></span>);
Hello, world.

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rm</span>(<span class="pl-s"><span class="pl-pds">"</span>hello_copy.txt<span class="pl-pds">"</span></span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">send_data</span>(<span class="pl-s"><span class="pl-pds">"</span>hello.txt<span class="pl-pds">"</span></span>, <span class="pl-c1">stdout</span>);
Hello, world.

julia<span class="pl-k">&gt;</span> <span class="pl-c1">send_data</span>(<span class="pl-s"><span class="pl-pds">"</span>hello.txt<span class="pl-pds">"</span></span>, <span class="pl-c1">pipeline</span>(<span class="pl-s"><span class="pl-pds">`</span>gzip -9<span class="pl-pds">`</span></span>, <span class="pl-s"><span class="pl-pds">"</span>hello.gz<span class="pl-pds">"</span></span>));

julia<span class="pl-k">&gt;</span> <span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>gzcat hello.gz<span class="pl-pds">`</span></span>);
Hello, world.

julia<span class="pl-k">&gt;</span> hello_copy <span class="pl-k">=</span> <span class="pl-c1">send_data</span>(<span class="pl-s"><span class="pl-pds">`</span>gzcat hello.gz<span class="pl-pds">`</span></span>)
<span class="pl-s"><span class="pl-pds">"</span>/var/folders/4g/b8p546px3nd550b3k288mhp80000gp/T/jl_cguepi<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">run</span>(<span class="pl-s"><span class="pl-pds">`</span>cat $hello_copy<span class="pl-pds">`</span></span>);
Hello, world.</pre></div>
<p>To understand the definition of <code>send_data</code>, let's work from the inside out:</p>
<ul>
<li>
<p>The main body of the function operates on the <code>src_io</code> and <code>dst_io</code> IO
handles, using a buffer to read data from the former to the latter in 2MiB
blocks.</p>
</li>
<li>
<p>The calls to <code>arg_read</code> and <code>arg_write</code> transform the <code>src</code> and <code>dst</code>
arguments from various types to <code>src_io</code> and <code>dst_io</code> IO handles. This allows
the inner body to handle the core case of dealing with IO handles, without
having to worry about the various possible incoming argument types. See the API
section below for more details about how <code>arg_read</code> and <code>arg_write</code> work on
different types.</p>
</li>
<li>
<p>The arguments to <code>send_data</code> are <code>src::ArgRead</code> and <code>dst::ArgWrite</code> where
<code>dst</code> is optional and defaults to <code>nothing</code> if not given. The <code>ArgRead</code> type is
a union including all the types that <code>arg_read</code> knows how to handle. Similarly,
the <code>ArgWrite</code> type is a union including the types that <code>arg_write</code> knows how to
handle, except for <code>nothing</code> which must be explicitly opted into, for which
<code>arg_write</code> creates a temporary file and returns its path.</p>
</li>
</ul>
<p>Taken altogether, this allows the <code>send_data</code> function to work with a combinatorial
explosion of type signatures:</p>
<ul>
<li><code>send_data(src::AbstractString)</code></li>
<li><code>send_data(src::AbstractCmd)</code></li>
<li><code>send_data(src::IO)</code></li>
<li><code>send_data(src::AbstractString, dst::AbstractString)</code></li>
<li><code>send_data(src::AbstractCmd,    dst::AbstractString)</code></li>
<li><code>send_data(src::IO,             dst::AbstractString)</code></li>
<li><code>send_data(src::AbstractString, dst::AbstractCmd)</code></li>
<li><code>send_data(src::AbstractCmd,    dst::AbstractCmd)</code></li>
<li><code>send_data(src::IO,             dst::AbstractCmd)</code></li>
<li><code>send_data(src::AbstractString, dst::IO)</code></li>
<li><code>send_data(src::AbstractCmd,    dst::IO)</code></li>
<li><code>send_data(src::IO,             dst::IO)</code></li>
</ul>
<p>Each combination guarantees the proper initialization and cleanup of its
arguments whether it is opening a file and closing it upon completion or error,
or creating a temporary output file and returning it upon completion or deleting
it on error. If the arguments are commands or pipelines, those are correctly
opened with the necessary read/write options.</p>
<h3><a id="user-content-testing-example" class="anchor" aria-hidden="true" href="#testing-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Testing Example</h3>
<p>Now that we've defined the <code>send_data</code> function, we must test it. But it has so
many different kinds of arguments that it can accept, how do we produce tests
for all of these combinations? <code>ArgTools</code> also offers tools to help with testing
APIs that it lets you define. The example tests assume that the above definition
of <code>send_data</code> has already been evaluated in the same Julia session.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using Test

# create a source file
src_file = tempname()
data = rand(UInt8, 666)
write(src_file, data)

print_sig(args...) =
    println(&quot;send_data(&quot;, join(map(typeof, args), &quot;, &quot;), &quot;)&quot;)

arg_readers(src_file) do src
    # test 1-arg methods
    @arg_test src begin
        print_sig(src)
        dst_file = send_data(src)
        @test data == read(dst_file)
        rm(dst_file)
    end

    # test 2-arg methods
    arg_writers() do dst_file, dst
        @arg_test src dst begin
            print_sig(src, dst)
            @test dst == send_data(src, dst)
        end
        @test data == read(dst_file)
    end
end

# cleanup
rm(src_file)
"><pre><span class="pl-k">using</span> Test

<span class="pl-c"><span class="pl-c">#</span> create a source file</span>
src_file <span class="pl-k">=</span> <span class="pl-c1">tempname</span>()
data <span class="pl-k">=</span> <span class="pl-c1">rand</span>(UInt8, <span class="pl-c1">666</span>)
<span class="pl-c1">write</span>(src_file, data)

<span class="pl-en">print_sig</span>(args<span class="pl-k">...</span>) <span class="pl-k">=</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>send_data(<span class="pl-pds">"</span></span>, <span class="pl-c1">join</span>(<span class="pl-c1">map</span>(typeof, args), <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">"</span>)<span class="pl-pds">"</span></span>)

<span class="pl-c1">arg_readers</span>(src_file) <span class="pl-k">do</span> src
    <span class="pl-c"><span class="pl-c">#</span> test 1-arg methods</span>
    <span class="pl-c1">@arg_test</span> src <span class="pl-k">begin</span>
        <span class="pl-c1">print_sig</span>(src)
        dst_file <span class="pl-k">=</span> <span class="pl-c1">send_data</span>(src)
        <span class="pl-c1">@test</span> data <span class="pl-k">==</span> <span class="pl-c1">read</span>(dst_file)
        <span class="pl-c1">rm</span>(dst_file)
    <span class="pl-k">end</span>

    <span class="pl-c"><span class="pl-c">#</span> test 2-arg methods</span>
    <span class="pl-c1">arg_writers</span>() <span class="pl-k">do</span> dst_file, dst
        <span class="pl-c1">@arg_test</span> src dst <span class="pl-k">begin</span>
            <span class="pl-c1">print_sig</span>(src, dst)
            <span class="pl-c1">@test</span> dst <span class="pl-k">==</span> <span class="pl-c1">send_data</span>(src, dst)
        <span class="pl-k">end</span>
        <span class="pl-c1">@test</span> data <span class="pl-k">==</span> <span class="pl-c1">read</span>(dst_file)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> cleanup</span>
<span class="pl-c1">rm</span>(src_file)</pre></div>
<p>Evaluating this testing code prints the following output:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="send_data(String)
send_data(String, String)
send_data(String, Cmd)
send_data(String, Base.CmdRedirect)
send_data(String, IOStream)
send_data(String, Base.Process)
send_data(Cmd)
send_data(Cmd, String)
send_data(Cmd, Cmd)
send_data(Cmd, Base.CmdRedirect)
send_data(Cmd, IOStream)
send_data(Cmd, Base.Process)
send_data(Base.CmdRedirect)
send_data(Base.CmdRedirect, String)
send_data(Base.CmdRedirect, Cmd)
send_data(Base.CmdRedirect, Base.CmdRedirect)
send_data(Base.CmdRedirect, IOStream)
send_data(Base.CmdRedirect, Base.Process)
send_data(IOStream)
send_data(IOStream, String)
send_data(IOStream, Cmd)
send_data(IOStream, Base.CmdRedirect)
send_data(IOStream, IOStream)
send_data(IOStream, Base.Process)
send_data(Base.Process)
send_data(Base.Process, String)
send_data(Base.Process, Cmd)
send_data(Base.Process, Base.CmdRedirect)
send_data(Base.Process, IOStream)
send_data(Base.Process, Base.Process)
"><pre><span class="pl-c1">send_data</span>(String)
<span class="pl-c1">send_data</span>(String, String)
<span class="pl-c1">send_data</span>(String, Cmd)
<span class="pl-c1">send_data</span>(String, Base<span class="pl-k">.</span>CmdRedirect)
<span class="pl-c1">send_data</span>(String, IOStream)
<span class="pl-c1">send_data</span>(String, Base<span class="pl-k">.</span>Process)
<span class="pl-c1">send_data</span>(Cmd)
<span class="pl-c1">send_data</span>(Cmd, String)
<span class="pl-c1">send_data</span>(Cmd, Cmd)
<span class="pl-c1">send_data</span>(Cmd, Base<span class="pl-k">.</span>CmdRedirect)
<span class="pl-c1">send_data</span>(Cmd, IOStream)
<span class="pl-c1">send_data</span>(Cmd, Base<span class="pl-k">.</span>Process)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>CmdRedirect)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>CmdRedirect, String)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>CmdRedirect, Cmd)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>CmdRedirect, Base<span class="pl-k">.</span>CmdRedirect)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>CmdRedirect, IOStream)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>CmdRedirect, Base<span class="pl-k">.</span>Process)
<span class="pl-c1">send_data</span>(IOStream)
<span class="pl-c1">send_data</span>(IOStream, String)
<span class="pl-c1">send_data</span>(IOStream, Cmd)
<span class="pl-c1">send_data</span>(IOStream, Base<span class="pl-k">.</span>CmdRedirect)
<span class="pl-c1">send_data</span>(IOStream, IOStream)
<span class="pl-c1">send_data</span>(IOStream, Base<span class="pl-k">.</span>Process)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>Process)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>Process, String)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>Process, Cmd)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>Process, Base<span class="pl-k">.</span>CmdRedirect)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>Process, IOStream)
<span class="pl-c1">send_data</span>(Base<span class="pl-k">.</span>Process, Base<span class="pl-k">.</span>Process)</pre></div>
<p>Test code doesn't isn't normally this verbose, but for this example it may be
helpful to understand what's happening. What this output shows is the various
ways in which this short bit of code tests invoking the <code>send_data</code> function.
Here are some details about what's happening:</p>
<ul>
<li>
<p>The call to <code>arg_readers(src_file)</code> evaluates the attached do block with five
different <code>arg</code> values, which can be converted to readable arguments of the
types: <code>String</code>, <code>Cmd</code>, <code>CmdRedirect</code>, <code>IOStream</code> and <code>Process</code>.</p>
</li>
<li>
<p>The call to <code>@arg_test src begin ... end</code> converts <code>src</code> into a readable
arguments of those same types and closes or finalizes each at the end.</p>
</li>
<li>
<p>The call to <code>arg_writers()</code> evaluates the attached do block with five
different <code>arg</code> values, which can be converted to writable arguments of the
types: <code>String</code>, <code>Cmd</code>, <code>CmdRedirect</code>, <code>IOStream</code> and <code>Process</code>.</p>
</li>
<li>
<p>The call to <code>@arg_test src dst begin ... end</code> converts <code>src</code> into a readable
arguments and <code>dst</code> into writeable arguments of the same set of types, and
closes or otherwise finalizes each one at the end of the block.</p>
</li>
</ul>
<p>This example test code illustrates some of the reasoning features of the testing
API which might initially seem puzzling. For example, it shows why <code>arg_readers</code>
and <code>arg_writers</code> don't simply produce argument values that can be passed to the
function being tested, instead requiring conversion by the <code>@arg_test</code> macro.
There are two reasons:</p>
<ol>
<li>
<p>The same value returned from <code>arg_readers</code> or <code>arg_writers</code> may need to be
used in multiple tests and some argument types, such as IO handles, need to
be initialized before each test and finalized after. The <code>@arg_test</code> block
delimits where initialization and finalization occur.</p>
</li>
<li>
<p>Sometimes operations need to be done after the <code>@arg_test</code> block but before
the end of the enclosing <code>arg_readers</code> or <code>arg_writers</code> block. Testing that
<code>dst_file</code> has the expected contents, i.e. <code>@test data == read(dst_file)</code>,
will not work reliably inside of the <code>@arg_test</code> block: data is not guaranteed
to have been fully written to <code>dst_file</code> until <code>dst</code> is finalized. This is an
issue when <code>dst</code> is an already-opened process, for example: <code>arg_write</code> leaves
the process open since it received it that way (you might want to write more
data to it), and while it does flush the handle, there is no guarantee that
the process will get data to its final destination until the process has
exited. Putting the test after the <code>@arg_test</code> block ensures that the process
has terminated, so we can reliably test the contents of <code>dst_file</code>.</p>
</li>
</ol>
</article></div>