<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h2 dir="auto"><a id="user-content-matlab" class="anchor" aria-hidden="true" href="#matlab"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MATLAB</h2>
<table>
<thead>
<tr>
<th><g-emoji class="g-emoji" alias="exclamation" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png">❗</g-emoji>  ** MATLAB versions 2022a and 2022b trigger a segfault and do not work with <code>MATLAB.jl</code>. Maintainers are attempting to diagnose the cause and fix the issue. **</th>
</tr>
</thead>
</table>
<p dir="auto">The <code>MATLAB.jl</code> package provides an interface for using <a href="http://www.mathworks.com/products/matlab/" rel="nofollow">MATLAB®</a> from <a href="http://julialang.org" rel="nofollow">Julia</a> using the MATLAB C api.  In other words, this package allows users to call MATLAB functions within Julia, thus making it easy to interoperate with MATLAB from the Julia language.</p>
<p dir="auto">You cannot use <code>MATLAB.jl</code> without having purchased and installed a copy of MATLAB® from <a href="http://www.mathworks.com/" rel="nofollow">MathWorks</a>. This package is available free of charge and in no way replaces or alters any functionality of MathWorks's MATLAB product.</p>
<h2 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h2>
<p dir="auto">This package is composed of two aspects:</p>
<ul dir="auto">
<li>
<p dir="auto">Creating and manipulating mxArrays (the data structure that MATLAB used to represent arrays and other kinds of data)</p>
</li>
<li>
<p dir="auto">Communicating with MATLAB engine sessions</p>
</li>
</ul>
<p dir="auto"><strong>Warning</strong>:</p>
<ul dir="auto">
<li>
<p dir="auto">MATLAB string arrays are not supported, and will throw an error exception. This also applies if they are nested within a MATLAB struct. This is a limitation of the MATLAB C api. The MATLAB function <code>convertContainedStringsToChars</code> may be used to facilitate conversion to a compatible format for use with <code>MATLAB.jl</code>.</p>
</li>
<li>
<p dir="auto">Threading is also not supported within Julia when using the MATLAB.jl library.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto"><strong>Important</strong>: The procedure to setup this package consists of the following steps.</p>
<p dir="auto">By default, <code>MATLAB.jl</code> uses the MATLAB installation with the greatest version number. To specify that a specific MATLAB installation should be used, set the environment variable <code>MATLAB_ROOT</code>.</p>
<h3 dir="auto"><a id="user-content-windows" class="anchor" aria-hidden="true" href="#windows"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Windows</h3>
<ol dir="auto">
<li>
<p dir="auto">For Matlab R2020a onwards, you should be able to go directly to step 2. If you encounter issues, run <code>matlab -batch "comserver('register')"</code> in the command prompt. For earlier versions of Matlab, start a command prompt as an administrator and enter <code>matlab /regserver</code>.</p>
</li>
<li>
<p dir="auto">From Julia run: <code>Pkg.add("MATLAB")</code></p>
</li>
</ol>
<h3 dir="auto"><a id="user-content-linux" class="anchor" aria-hidden="true" href="#linux"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Linux</h3>
<ol dir="auto">
<li>
<p dir="auto">Make sure <code>matlab</code> is in executable path.</p>
</li>
<li>
<p dir="auto">Make sure <code>csh</code> is installed. (Note: MATLAB for Linux relies on <code>csh</code> to open an engine session.)</p>
<p dir="auto">To install <code>csh</code> in Debian/Ubuntu/Linux Mint, you may type in the following command in terminal:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sudo apt-get install csh"><pre>sudo apt-get install csh</pre></div>
</li>
<li>
<p dir="auto">From Julia run: <code>Pkg.add("MATLAB")</code></p>
</li>
</ol>
<h3 dir="auto"><a id="user-content-mac-os-x" class="anchor" aria-hidden="true" href="#mac-os-x"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Mac OS X</h3>
<ol dir="auto">
<li>
<p dir="auto">Ensure that MATLAB is installed in <code>/Applications</code> (for example, if you are using MATLAB R2012b, you may add the following command to <code>.profile</code>:  <code>export MATLAB_HOME=/Applications/MATLAB_R2012b.app</code>).</p>
</li>
<li>
<p dir="auto">From Julia run: <code>Pkg.add("MATLAB")</code></p>
</li>
</ol>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<h3 dir="auto"><a id="user-content-mxarray-class" class="anchor" aria-hidden="true" href="#mxarray-class"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MxArray class</h3>
<p dir="auto">An instance of <code>MxArray</code> encapsulates a MATLAB variable. This package provides a series of functions to manipulate such instances.</p>
<h4 dir="auto"><a id="user-content-create-matlab-variables-in-julia" class="anchor" aria-hidden="true" href="#create-matlab-variables-in-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Create MATLAB variables in Julia</h4>
<p dir="auto">One can use the function <code>mxarray</code> to create MATLAB variables (of type <code>MxArray</code>), as follows</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mxarray(Float64, n)   # creates an n-by-1 MATLAB zero array of double valued type
mxarray(Int32, m, n)  # creates an m-by-n MATLAB zero array of int32 valued type
mxarray(Bool, m, n)   # creates a MATLAB logical array of size m-by-n

mxarray(Float64, (n1, n2, n3))  # creates a MATLAB array of size n1-by-n2-by-n3

mxcellarray(m, n)        # creates a MATLAB cell array
mxstruct(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)  # creates a MATLAB struct with given fields"><pre><span class="pl-c1">mxarray</span>(Float64, n)   <span class="pl-c"><span class="pl-c">#</span> creates an n-by-1 MATLAB zero array of double valued type</span>
<span class="pl-c1">mxarray</span>(Int32, m, n)  <span class="pl-c"><span class="pl-c">#</span> creates an m-by-n MATLAB zero array of int32 valued type</span>
<span class="pl-c1">mxarray</span>(Bool, m, n)   <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB logical array of size m-by-n</span>

<span class="pl-c1">mxarray</span>(Float64, (n1, n2, n3))  <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB array of size n1-by-n2-by-n3</span>

<span class="pl-c1">mxcellarray</span>(m, n)        <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB cell array</span>
<span class="pl-c1">mxstruct</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB struct with given fields</span></pre></div>
<p dir="auto">You may also convert a Julia variable to MATLAB variable</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="a = rand(m, n)

x = mxarray(a)     # converts a to a MATLAB array
x = mxarray(1.2)   # converts a scalar 1.2 to a MATLAB variable

a = sprand(m, n, 0.1)
x = mxarray(a)     # converts a sparse matrix to a MATLAB sparse matrix

x = mxarray(&quot;abc&quot;) # converts a string to a MATLAB char array

x = mxarray([&quot;a&quot;, 1, 2.3])  # converts a Julia array to a MATLAB cell array

x = mxarray(Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;&quot;string&quot;, &quot;c&quot;=&gt;[1,2,3])) # converts a Julia dictionary to a MATLAB struct"><pre>a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(m, n)

x <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>(a)     <span class="pl-c"><span class="pl-c">#</span> converts a to a MATLAB array</span>
x <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>(<span class="pl-c1">1.2</span>)   <span class="pl-c"><span class="pl-c">#</span> converts a scalar 1.2 to a MATLAB variable</span>

a <span class="pl-k">=</span> <span class="pl-c1">sprand</span>(m, n, <span class="pl-c1">0.1</span>)
x <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>(a)     <span class="pl-c"><span class="pl-c">#</span> converts a sparse matrix to a MATLAB sparse matrix</span>

x <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span> converts a string to a MATLAB char array</span>

x <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>, <span class="pl-c1">2.3</span>])  <span class="pl-c"><span class="pl-c">#</span> converts a Julia array to a MATLAB cell array</span>

x <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>(<span class="pl-c1">Dict</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>])) <span class="pl-c"><span class="pl-c">#</span> converts a Julia dictionary to a MATLAB struct</span></pre></div>
<p dir="auto">The function <code>mxarray</code> can also convert a compound type to a Julia struct:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct S
    x::Float64
    y::Vector{Int32}
    z::Bool
end

s = S(1.2, Int32[1, 2], false)

x = mxarray(s)   # creates a MATLAB struct with three fields: x, y, z
xc = mxarray([s, s])  # creates a MATLAB cell array, each cell is a struct.
xs = mxstructarray([s, s])  # creates a MATLAB array of structs"><pre><span class="pl-k">struct</span> S
    x<span class="pl-k">::</span><span class="pl-c1">Float64</span>
    y<span class="pl-k">::</span><span class="pl-c1">Vector{Int32}</span>
    z<span class="pl-k">::</span><span class="pl-c1">Bool</span>
<span class="pl-k">end</span>

s <span class="pl-k">=</span> <span class="pl-c1">S</span>(<span class="pl-c1">1.2</span>, Int32[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], <span class="pl-c1">false</span>)

x <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>(s)   <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB struct with three fields: x, y, z</span>
xc <span class="pl-k">=</span> <span class="pl-c1">mxarray</span>([s, s])  <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB cell array, each cell is a struct.</span>
xs <span class="pl-k">=</span> <span class="pl-c1">mxstructarray</span>([s, s])  <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB array of structs</span></pre></div>
<p dir="auto"><strong>Note:</strong> For safety, the conversation between MATLAB and Julia variables uses deep copy.</p>
<p dir="auto">When you finish using a MATLAB variable, you may call <code>delete</code> to free the memory. But this is optional, it will be deleted when reclaimed by the garbage collector.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="delete(x)"><pre><span class="pl-c1">delete</span>(x)</pre></div>
<p dir="auto"><em>Note:</em> if you put a MATLAB variable <code>x</code> to MATLAB engine session, then the MATLAB engine will take over the management of its life cylce, and you don't have to delete it explicitly.</p>
<h4 dir="auto"><a id="user-content-access-matlab-variables" class="anchor" aria-hidden="true" href="#access-matlab-variables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Access MATLAB variables</h4>
<p dir="auto">You may access attributes and data of a MATLAB variable through the functions provided by this package.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# suppose x is of type MxArray
nrows(x)    # returns number of rows in x
ncols(x)    # returns number of columns in x
nelems(x)   # returns number of elements in x
ndims(x)    # returns number of dimensions in x
size(x)     # returns the size of x as a tuple
size(x, d)  # returns the size of x along a specific dimension

eltype(x)   # returns element type of x (in Julia Type)
elsize(x)   # return number of bytes per element

data_ptr(x)   # returns pointer to data (in Ptr{T}), where T is eltype(x)

# suppose s is a MATLAB struct
mxnfields(s)	# returns the number of fields in struct s
"><pre><span class="pl-c"><span class="pl-c">#</span> suppose x is of type MxArray</span>
<span class="pl-c1">nrows</span>(x)    <span class="pl-c"><span class="pl-c">#</span> returns number of rows in x</span>
<span class="pl-c1">ncols</span>(x)    <span class="pl-c"><span class="pl-c">#</span> returns number of columns in x</span>
<span class="pl-c1">nelems</span>(x)   <span class="pl-c"><span class="pl-c">#</span> returns number of elements in x</span>
<span class="pl-c1">ndims</span>(x)    <span class="pl-c"><span class="pl-c">#</span> returns number of dimensions in x</span>
<span class="pl-c1">size</span>(x)     <span class="pl-c"><span class="pl-c">#</span> returns the size of x as a tuple</span>
<span class="pl-c1">size</span>(x, d)  <span class="pl-c"><span class="pl-c">#</span> returns the size of x along a specific dimension</span>

<span class="pl-c1">eltype</span>(x)   <span class="pl-c"><span class="pl-c">#</span> returns element type of x (in Julia Type)</span>
<span class="pl-c1">elsize</span>(x)   <span class="pl-c"><span class="pl-c">#</span> return number of bytes per element</span>

<span class="pl-c1">data_ptr</span>(x)   <span class="pl-c"><span class="pl-c">#</span> returns pointer to data (in Ptr{T}), where T is eltype(x)</span>

<span class="pl-c"><span class="pl-c">#</span> suppose s is a MATLAB struct</span>
<span class="pl-c1">mxnfields</span>(s)	<span class="pl-c"><span class="pl-c">#</span> returns the number of fields in struct s</span>
</pre></div>
<p dir="auto">You may also make tests on a MATLAB variable.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="is_double(x)   # returns whether x is a double array
is_sparse(x)   # returns whether x is sparse
is_complex(x)  # returns whether x is complex
is_cell(x)     # returns whether x is a cell array
is_struct(x)   # returns whether x is a struct
is_empty(x)    # returns whether x is empty

...            # there are many more there"><pre><span class="pl-c1">is_double</span>(x)   <span class="pl-c"><span class="pl-c">#</span> returns whether x is a double array</span>
<span class="pl-c1">is_sparse</span>(x)   <span class="pl-c"><span class="pl-c">#</span> returns whether x is sparse</span>
<span class="pl-c1">is_complex</span>(x)  <span class="pl-c"><span class="pl-c">#</span> returns whether x is complex</span>
<span class="pl-c1">is_cell</span>(x)     <span class="pl-c"><span class="pl-c">#</span> returns whether x is a cell array</span>
<span class="pl-c1">is_struct</span>(x)   <span class="pl-c"><span class="pl-c">#</span> returns whether x is a struct</span>
<span class="pl-c1">is_empty</span>(x)    <span class="pl-c"><span class="pl-c">#</span> returns whether x is empty</span>

<span class="pl-k">...</span>            <span class="pl-c"><span class="pl-c">#</span> there are many more there</span></pre></div>
<h4 dir="auto"><a id="user-content-convert-matlab-variables-to-julia" class="anchor" aria-hidden="true" href="#convert-matlab-variables-to-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Convert MATLAB variables to Julia</h4>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="a = jarray(x)   # converts x to a Julia array
a = jvector(x)  # converts x to a Julia vector (1D array) when x is a vector
a = jscalar(x)  # converts x to a Julia scalar
a = jmatrix(x)  # converts x to a Julia matrix
a = jstring(x)  # converts x to a Julia string
a = jdict(x)    # converts a MATLAB struct to a Julia dictionary (using fieldnames as keys)

a = jvalue(x)  # converts x to a Julia value in default manner"><pre>a <span class="pl-k">=</span> <span class="pl-c1">jarray</span>(x)   <span class="pl-c"><span class="pl-c">#</span> converts x to a Julia array</span>
a <span class="pl-k">=</span> <span class="pl-c1">jvector</span>(x)  <span class="pl-c"><span class="pl-c">#</span> converts x to a Julia vector (1D array) when x is a vector</span>
a <span class="pl-k">=</span> <span class="pl-c1">jscalar</span>(x)  <span class="pl-c"><span class="pl-c">#</span> converts x to a Julia scalar</span>
a <span class="pl-k">=</span> <span class="pl-c1">jmatrix</span>(x)  <span class="pl-c"><span class="pl-c">#</span> converts x to a Julia matrix</span>
a <span class="pl-k">=</span> <span class="pl-c1">jstring</span>(x)  <span class="pl-c"><span class="pl-c">#</span> converts x to a Julia string</span>
a <span class="pl-k">=</span> <span class="pl-c1">jdict</span>(x)    <span class="pl-c"><span class="pl-c">#</span> converts a MATLAB struct to a Julia dictionary (using fieldnames as keys)</span>

a <span class="pl-k">=</span> <span class="pl-c1">jvalue</span>(x)  <span class="pl-c"><span class="pl-c">#</span> converts x to a Julia value in default manner</span></pre></div>
<h3 dir="auto"><a id="user-content-readwrite-mat-files" class="anchor" aria-hidden="true" href="#readwrite-mat-files"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Read/Write MAT Files</h3>
<p dir="auto">This package provides functions to manipulate MATLAB's mat files:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mf = MatFile(filename, mode)    # opens a MAT file using a specific mode, and returns a handle
mf = MatFile(filename)          # opens a MAT file for reading, equivalent to MatFile(filename, &quot;r&quot;)
close(mf)                       # closes a MAT file.

get_mvariable(mf, name)   # gets a variable and returns an mxArray
get_variable(mf, name)    # gets a variable, but converts it to a Julia value using `jvalue`

put_variable(mf, name, v)   # puts a variable v to the MAT file
                            # v can be either an MxArray instance or normal variable
                            # If v is not an MxArray, it will be converted using `mxarray`

put_variables(mf; name1=v1, name2=v2, ...)  # put multiple variables using keyword arguments

variable_names(mf)   # get a vector of all variable names in a MAT file"><pre>mf <span class="pl-k">=</span> <span class="pl-c1">MatFile</span>(filename, mode)    <span class="pl-c"><span class="pl-c">#</span> opens a MAT file using a specific mode, and returns a handle</span>
mf <span class="pl-k">=</span> <span class="pl-c1">MatFile</span>(filename)          <span class="pl-c"><span class="pl-c">#</span> opens a MAT file for reading, equivalent to MatFile(filename, "r")</span>
<span class="pl-c1">close</span>(mf)                       <span class="pl-c"><span class="pl-c">#</span> closes a MAT file.</span>

<span class="pl-c1">get_mvariable</span>(mf, name)   <span class="pl-c"><span class="pl-c">#</span> gets a variable and returns an mxArray</span>
<span class="pl-c1">get_variable</span>(mf, name)    <span class="pl-c"><span class="pl-c">#</span> gets a variable, but converts it to a Julia value using `jvalue`</span>

<span class="pl-c1">put_variable</span>(mf, name, v)   <span class="pl-c"><span class="pl-c">#</span> puts a variable v to the MAT file</span>
                            <span class="pl-c"><span class="pl-c">#</span> v can be either an MxArray instance or normal variable</span>
                            <span class="pl-c"><span class="pl-c">#</span> If v is not an MxArray, it will be converted using `mxarray`</span>

<span class="pl-c1">put_variables</span>(mf; name1<span class="pl-k">=</span>v1, name2<span class="pl-k">=</span>v2, <span class="pl-k">...</span>)  <span class="pl-c"><span class="pl-c">#</span> put multiple variables using keyword arguments</span>

<span class="pl-c1">variable_names</span>(mf)   <span class="pl-c"><span class="pl-c">#</span> get a vector of all variable names in a MAT file</span></pre></div>
<p dir="auto">There are also convenient functions that can get/put all variables in one call:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="read_matfile(filename)    # returns a dictionary that maps each variable name
                          # to an MxArray instance

write_matfile(filename; name1=v1, name2=v2, ...)  # writes all variables given in the
                                                  # keyword argument list to a MAT file"><pre><span class="pl-c1">read_matfile</span>(filename)    <span class="pl-c"><span class="pl-c">#</span> returns a dictionary that maps each variable name</span>
                          <span class="pl-c"><span class="pl-c">#</span> to an MxArray instance</span>

<span class="pl-c1">write_matfile</span>(filename; name1<span class="pl-k">=</span>v1, name2<span class="pl-k">=</span>v2, <span class="pl-k">...</span>)  <span class="pl-c"><span class="pl-c">#</span> writes all variables given in the</span>
                                                  <span class="pl-c"><span class="pl-c">#</span> keyword argument list to a MAT file</span></pre></div>
<p dir="auto">Both <code>read_matfile</code> and <code>write_matfile</code> will close the MAT file handle before returning.</p>
<p dir="auto"><strong>Examples:</strong></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct S
    x::Float64
    y::Bool
    z::Vector{Float64}
end

write_matfile(&quot;test.mat&quot;;
    a = Int32[1 2 3; 4 5 6],
    b = [1.2, 3.4, 5.6, 7.8],
    c = [[0.0, 1.0], [1.0, 2.0], [1.0, 2.0, 3.0]],
    d = Dict(&quot;name&quot;=&gt;&quot;MATLAB&quot;, &quot;score&quot;=&gt;100.0),
    s = &quot;abcde&quot;,
    ss = [S(1.0, true, [1., 2.]), S(2.0, false, [3., 4.])] )"><pre><span class="pl-k">struct</span> S
    x<span class="pl-k">::</span><span class="pl-c1">Float64</span>
    y<span class="pl-k">::</span><span class="pl-c1">Bool</span>
    z<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>
<span class="pl-k">end</span>

<span class="pl-c1">write_matfile</span>(<span class="pl-s"><span class="pl-pds">"</span>test.mat<span class="pl-pds">"</span></span>;
    a <span class="pl-k">=</span> Int32[<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>; <span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span>],
    b <span class="pl-k">=</span> [<span class="pl-c1">1.2</span>, <span class="pl-c1">3.4</span>, <span class="pl-c1">5.6</span>, <span class="pl-c1">7.8</span>],
    c <span class="pl-k">=</span> [[<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>], [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>], [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>]],
    d <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-s"><span class="pl-pds">"</span>MATLAB<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>score<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">100.0</span>),
    s <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abcde<span class="pl-pds">"</span></span>,
    ss <span class="pl-k">=</span> [<span class="pl-c1">S</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">true</span>, [<span class="pl-c1">1.</span>, <span class="pl-c1">2.</span>]), <span class="pl-c1">S</span>(<span class="pl-c1">2.0</span>, <span class="pl-c1">false</span>, [<span class="pl-c1">3.</span>, <span class="pl-c1">4.</span>])] )</pre></div>
<p dir="auto">This example will create a MAT file called <code>test.mat</code>, which contains six MATLAB variables:</p>
<ul dir="auto">
<li><code>a</code>: a 2-by-3 int32 array</li>
<li><code>b</code>: a 4-by-1 double array</li>
<li><code>c</code>: a 3-by-1 cell array, each cell contains a double vector</li>
<li><code>d</code>: a struct with two fields: name and score</li>
<li><code>s</code>: a string (i.e. char array)</li>
<li><code>ss</code>: an array of structs with two elements, and three fields: x, y, and z.</li>
</ul>
<h3 dir="auto"><a id="user-content-use-matlab-engine" class="anchor" aria-hidden="true" href="#use-matlab-engine"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Use MATLAB Engine</h3>
<h4 dir="auto"><a id="user-content-basic-use" class="anchor" aria-hidden="true" href="#basic-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic Use</h4>
<p dir="auto">To evaluate expressions in MATLAB, one may open a MATLAB engine session and communicate with it. There are three ways to call MATLAB from Julia:</p>
<ul dir="auto">
<li>The <code>mat""</code> custom string literal allows you to write MATLAB syntax inside Julia and use Julia variables directly from MATLAB via interpolation</li>
<li>The <code>eval_string</code> evaluate a string containing MATLAB expressions (typically used with the helper macros <code>@mget</code> and <code>@mput</code></li>
<li>The <code>mxcall</code> function calls a given MATLAB function and returns the result</li>
</ul>
<p dir="auto">In general, the <code>mat""</code> custom string literal is the preferred method to interact with the MATLAB engine.</p>
<p dir="auto"><em>Note:</em> There can be multiple (reasonable) ways to convert a MATLAB variable to Julia array. For example, MATLAB represents a scalar using a 1-by-1 matrix. Here we have two choices in terms of converting such a matrix back to Julia: (1) convert to a scalar number, or (2) convert to a matrix of size 1-by-1.</p>
<h5 dir="auto"><a id="user-content-the-mat-custom-string-literal" class="anchor" aria-hidden="true" href="#the-mat-custom-string-literal"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>mat""</code> custom string literal</h5>
<p dir="auto">Text inside the <code>mat""</code> custom string literal is in MATLAB syntax. Variables from Julia can be "interpolated" into MATLAB code by prefixing them with a dollar sign as you would interpolate them into an ordinary string.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MATLAB

x = range(-10.0, stop=10.0, length=500)
mat&quot;plot($x, sin($x))&quot;  # evaluate a MATLAB function

y = range(2.0, stop=3.0, length=500)
mat&quot;&quot;&quot;
    $u = $x + $y
	$v = $x - $y
&quot;&quot;&quot;
@show u v               # u and v are accessible from Julia"><pre><span class="pl-k">using</span> MATLAB

x <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">10.0</span>, stop<span class="pl-k">=</span><span class="pl-c1">10.0</span>, length<span class="pl-k">=</span><span class="pl-c1">500</span>)
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">mat</span>"</span>plot($x, sin($x))<span class="pl-pds">"</span></span>  <span class="pl-c"><span class="pl-c">#</span> evaluate a MATLAB function</span>

y <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">2.0</span>, stop<span class="pl-k">=</span><span class="pl-c1">3.0</span>, length<span class="pl-k">=</span><span class="pl-c1">500</span>)
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">mat</span>"""</span></span>
<span class="pl-s">    $u = $x + $y</span>
<span class="pl-s">	$v = $x - $y</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-c1">@show</span> u v               <span class="pl-c"><span class="pl-c">#</span> u and v are accessible from Julia</span></pre></div>
<p dir="auto">As with ordinary string literals, you can also interpolate whole Julia expressions, e.g. <code>mat"$(x[1]) = $(x[2]) + $(binomial(5, 2))"</code>.</p>
<h5 dir="auto"><a id="user-content-eval_string" class="anchor" aria-hidden="true" href="#eval_string"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>eval_string</code></h5>
<p dir="auto">You may also use the <code>eval_string</code> function to evaluate MATLAB code as follows</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="eval_string(&quot;a = sum([1,2,3])&quot;)"><pre><span class="pl-c1">eval_string</span>(<span class="pl-s"><span class="pl-pds">"</span>a = sum([1,2,3])<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">The <code>eval_string</code> function also takes an optional argument that specifies which MATLAB session to evaluate the code in, e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; s = MSession();
julia&gt; eval_string(s, &quot;a = sum([1,2,3])&quot;)
a =
     6"><pre>julia<span class="pl-k">&gt;</span> s <span class="pl-k">=</span> <span class="pl-c1">MSession</span>();
julia<span class="pl-k">&gt;</span> <span class="pl-c1">eval_string</span>(s, <span class="pl-s"><span class="pl-pds">"</span>a = sum([1,2,3])<span class="pl-pds">"</span></span>)
a <span class="pl-k">=</span>
     <span class="pl-c1">6</span></pre></div>
<h5 dir="auto"><a id="user-content-mxcall" class="anchor" aria-hidden="true" href="#mxcall"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>mxcall</code></h5>
<p dir="auto">You may also directly call a MATLAB function on Julia variables using <code>mxcall</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = -10.0:0.1:10.0
y = -10.0:0.1:10.0
xx, yy = mxcall(:meshgrid, 2, x, y)"><pre>x <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">10.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>
y <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">10.0</span><span class="pl-k">:</span><span class="pl-c1">0.1</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>
xx, yy <span class="pl-k">=</span> <span class="pl-c1">mxcall</span>(<span class="pl-c1">:meshgrid</span>, <span class="pl-c1">2</span>, x, y)</pre></div>
<p dir="auto"><em>Note:</em> Since MATLAB functions behavior depends on the number of outputs, you have to specify the number of output arguments in <code>mxcall</code> as the second argument.</p>
<p dir="auto"><code>mxcall</code> puts the input arguments to the MATLAB workspace (using mangled names), evaluates the function call in MATLAB, and retrieves the variable from the MATLAB session. This function is mainly provided for convenience. However, you should keep in mind that it may incur considerable overhead due to the communication between MATLAB and Julia domain.</p>
<h5 dir="auto"><a id="user-content-mget-and-mput" class="anchor" aria-hidden="true" href="#mget-and-mput"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>@mget</code> and <code>@mput</code></h5>
<p dir="auto">The macro <code>@mget</code> can be used to extract the value of a MATLAB variable into Julia</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; mat&quot;a = 6&quot;
julia&gt; @mget a
6.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">mat</span>"</span>a = 6<span class="pl-pds">"</span></span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@mget</span> a
<span class="pl-c1">6.0</span></pre></div>
<p dir="auto">The macro <code>@mput</code> can be used to translate a Julia variable into MATLAB</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x = [1,2,3]
julia&gt; @mput x
julia&gt; eval_string(&quot;y = sum(x)&quot;)
julia&gt; @mget y
6.0
julia&gt; @show y
a = 63.0"><pre>julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@mput</span> x
julia<span class="pl-k">&gt;</span> <span class="pl-c1">eval_string</span>(<span class="pl-s"><span class="pl-pds">"</span>y = sum(x)<span class="pl-pds">"</span></span>)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@mget</span> y
<span class="pl-c1">6.0</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">@show</span> y
a <span class="pl-k">=</span> <span class="pl-c1">63.0</span></pre></div>
<h4 dir="auto"><a id="user-content-calling-custom-matlab-function" class="anchor" aria-hidden="true" href="#calling-custom-matlab-function"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calling custom MATLAB function</h4>
<p dir="auto">If the MATLAB function is not in the current directory, we need to first add it to the MATLAB path before calling through Julia:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mat&quot;addpath('/path/to/folder')&quot;
val = mat&quot;myfunction($arg1, $arg2)&quot;"><pre><span class="pl-s"><span class="pl-pds"><span class="pl-c1">mat</span>"</span>addpath('/path/to/folder')<span class="pl-pds">"</span></span>
val <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">mat</span>"</span>myfunction($arg1, $arg2)<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">For example, if there is a MATLAB file located at <code>/path/to/folder</code> with contents:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function [r,u] = test(x, y)
	r = x + y;
	u = x - y;
end"><pre><span class="pl-k">function</span> [<span class="pl-v">r</span>,<span class="pl-v">u</span>] <span class="pl-k">=</span> <span class="pl-en">test</span>(<span class="pl-v">x</span>, <span class="pl-v">y</span>)
	r <span class="pl-k">=</span> <span class="pl-smi">x</span> <span class="pl-k">+</span> <span class="pl-smi">y</span>;
	u <span class="pl-k">=</span> <span class="pl-smi">x</span> <span class="pl-k">-</span> <span class="pl-smi">y</span>;
<span class="pl-k">end</span></pre></div>
<p dir="auto">We can call this function as follows in Julia:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MATLAB

x = range(-10.0, stop=10.0, length=500)
y = range(2.0, stop=3.0, length=500)

mat&quot;addpath('/path/to/folder')&quot;

r, u = mxcall(:test,2,x,y)"><pre><span class="pl-k">using</span> MATLAB

x <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">10.0</span>, stop<span class="pl-k">=</span><span class="pl-c1">10.0</span>, length<span class="pl-k">=</span><span class="pl-c1">500</span>)
y <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">2.0</span>, stop<span class="pl-k">=</span><span class="pl-c1">3.0</span>, length<span class="pl-k">=</span><span class="pl-c1">500</span>)

<span class="pl-s"><span class="pl-pds"><span class="pl-c1">mat</span>"</span>addpath('/path/to/folder')<span class="pl-pds">"</span></span>

r, u <span class="pl-k">=</span> <span class="pl-c1">mxcall</span>(<span class="pl-c1">:test</span>,<span class="pl-c1">2</span>,x,y)</pre></div>
<h4 dir="auto"><a id="user-content-viewing-the-matlab-session-windows-only" class="anchor" aria-hidden="true" href="#viewing-the-matlab-session-windows-only"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Viewing the MATLAB Session (Windows only)</h4>
<p dir="auto">To open an interactive window for the MATLAB session, use the command <code>show_msession()</code> and to hide the window, use <code>hide_msession()</code>. <em>Warning: manually closing this window will result in an error or result in a segfault; it is advised that you only use the <code>hide_msession()</code> command to hide the interactive window.</em></p>
<p dir="auto">Note that this feature only works on Windows.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# default
show_msession() # open the default MATLAB session interactive window
get_msession_visiblity() # get the session's visibility state
hide_msession() # hide the default MATLAB session interactive window

# similarily
s = MSession()
show_msession(s)
get_msession_visiblity(a)
hide_msession(s)"><pre><span class="pl-c"><span class="pl-c">#</span> default</span>
<span class="pl-c1">show_msession</span>() <span class="pl-c"><span class="pl-c">#</span> open the default MATLAB session interactive window</span>
<span class="pl-c1">get_msession_visiblity</span>() <span class="pl-c"><span class="pl-c">#</span> get the session's visibility state</span>
<span class="pl-c1">hide_msession</span>() <span class="pl-c"><span class="pl-c">#</span> hide the default MATLAB session interactive window</span>

<span class="pl-c"><span class="pl-c">#</span> similarily</span>
s <span class="pl-k">=</span> <span class="pl-c1">MSession</span>()
<span class="pl-c1">show_msession</span>(s)
<span class="pl-c1">get_msession_visiblity</span>(a)
<span class="pl-c1">hide_msession</span>(s)</pre></div>
<h4 dir="auto"><a id="user-content-advanced-use-of-matlab-engines" class="anchor" aria-hidden="true" href="#advanced-use-of-matlab-engines"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Advanced use of MATLAB Engines</h4>
<p dir="auto">This package provides a series of functions for users to control the communication with MATLAB sessions.</p>
<p dir="auto">Here is an example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="s1 = MSession()    # creates a MATLAB session
s2 = MSession(0)   # creates a MATLAB session without recording output

x = rand(3, 4)
put_variable(s1, :x, x)  # put x to session s1

y = rand(2, 3)
put_variable(s2, :y, y)  # put y to session s2

eval_string(s1, &quot;r = sin(x)&quot;)  # evaluate sin(x) in session s1
eval_string(s2, &quot;r = sin(y)&quot;)  # evaluate sin(y) in session s2

r1_mx = get_mvariable(s1, :r)  # get r from s1
r2_mx = get_mvariable(s2, :r)  # get r from s2

r1 = jarray(r1_mx)
r2 = jarray(r2_mx)

# ... do other stuff on r1 and r2

close(s1)  # close session s1
close(s2)  # close session s2"><pre>s1 <span class="pl-k">=</span> <span class="pl-c1">MSession</span>()    <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB session</span>
s2 <span class="pl-k">=</span> <span class="pl-c1">MSession</span>(<span class="pl-c1">0</span>)   <span class="pl-c"><span class="pl-c">#</span> creates a MATLAB session without recording output</span>

x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>)
<span class="pl-c1">put_variable</span>(s1, <span class="pl-c1">:x</span>, x)  <span class="pl-c"><span class="pl-c">#</span> put x to session s1</span>

y <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
<span class="pl-c1">put_variable</span>(s2, <span class="pl-c1">:y</span>, y)  <span class="pl-c"><span class="pl-c">#</span> put y to session s2</span>

<span class="pl-c1">eval_string</span>(s1, <span class="pl-s"><span class="pl-pds">"</span>r = sin(x)<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> evaluate sin(x) in session s1</span>
<span class="pl-c1">eval_string</span>(s2, <span class="pl-s"><span class="pl-pds">"</span>r = sin(y)<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> evaluate sin(y) in session s2</span>

r1_mx <span class="pl-k">=</span> <span class="pl-c1">get_mvariable</span>(s1, <span class="pl-c1">:r</span>)  <span class="pl-c"><span class="pl-c">#</span> get r from s1</span>
r2_mx <span class="pl-k">=</span> <span class="pl-c1">get_mvariable</span>(s2, <span class="pl-c1">:r</span>)  <span class="pl-c"><span class="pl-c">#</span> get r from s2</span>

r1 <span class="pl-k">=</span> <span class="pl-c1">jarray</span>(r1_mx)
r2 <span class="pl-k">=</span> <span class="pl-c1">jarray</span>(r2_mx)

<span class="pl-c"><span class="pl-c">#</span> ... do other stuff on r1 and r2</span>

<span class="pl-c1">close</span>(s1)  <span class="pl-c"><span class="pl-c">#</span> close session s1</span>
<span class="pl-c1">close</span>(s2)  <span class="pl-c"><span class="pl-c">#</span> close session s2</span></pre></div>
</article></div>