<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-staralgebras" class="anchor" aria-hidden="true" href="#staralgebras"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>StarAlgebras</h1>


<p dir="auto"><a href="https://github.com/kalmarek/StarAlgebras.jl/actions?query=workflow%3ACI"><img src="https://github.com/kalmarek/StarAlgebras.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/kalmarek/StarAlgebras.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/336068a7c62cdde0a44e225f1d98f0b931a94e59e6c66465fd85719881d3cadf/68747470733a2f2f636f6465636f762e696f2f67682f6b616c6d6172656b2f53746172416c6765627261732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d6a704856645952783847" alt="codecov" data-canonical-src="https://codecov.io/gh/kalmarek/StarAlgebras.jl/branch/main/graph/badge.svg?token=jpHVdYRx8G" style="max-width: 100%;"></a></p>
<hr>
<p dir="auto">The package implements <code>*</code>-algebras with basis. The prime example use is group/monoid algebras (or rings) (or their finite dimensional subspaces). An example usage can be as follows.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using StarAlgebras

julia&gt; using PermutationGroups

julia&gt; G = PermGroup(perm&quot;(1,2)&quot;, perm&quot;(1,2,3)&quot;)
Permutation group on 2 generators generated by
 (1,2)
 (1,2,3)

julia&gt; b = StarAlgebras.Basis{UInt8}(collect(G))
6-element StarAlgebras.Basis{Permutation{Int64, …}, UInt8, Vector{Permutation{Int64, …}}}:
 ()
 (2,3)
 (1,2)
 (1,3,2)
 (1,3)
 (1,2,3)

julia&gt; RG = StarAlgebra(G, b)
*-algebra of Permutation group on 2 generators of order 6
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> StarAlgebras

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> PermutationGroups

julia<span class="pl-k">&gt;</span> G <span class="pl-k">=</span> <span class="pl-c1">PermGroup</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">perm</span>"</span>(1,2)<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">perm</span>"</span>(1,2,3)<span class="pl-pds">"</span></span>)
Permutation group on <span class="pl-c1">2</span> generators generated by
 (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)
 (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> StarAlgebras<span class="pl-k">.</span><span class="pl-c1">Basis</span><span class="pl-c1">{UInt8}</span>(<span class="pl-c1">collect</span>(G))
<span class="pl-c1">6</span><span class="pl-k">-</span>element StarAlgebras<span class="pl-k">.</span>Basis{Permutation{Int64, …}, UInt8, Vector{Permutation{Int64, …}}}<span class="pl-k">:</span>
 ()
 (<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)
 (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)
 (<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)
 (<span class="pl-c1">1</span>,<span class="pl-c1">3</span>)
 (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> RG <span class="pl-k">=</span> <span class="pl-c1">StarAlgebra</span>(G, b)
<span class="pl-k">*-</span>algebra of Permutation group on <span class="pl-c1">2</span> generators of order <span class="pl-c1">6</span>
</pre></div>
<p dir="auto">This creates the group algebra of the symmetric group. How do we compute inside the group algebra? There are a few ways to comstruct elements:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; zero(RG)
0·()

julia&gt; one(RG) # the canonical unit
1·()

julia&gt; RG(1) # the same
1·()

julia&gt; RG(-5.0) # coerce a scalar to the ring
-5.0·()

julia&gt; RG(rand(G)) # the indicator function on a random element of G
1·(1,3,2)

julia&gt; f = AlgebraElement(rand(-3:3, length(b)), RG) # an element given by vectors of coefficients in the basis
1·() -1·(2,3) +3·(1,2) -1·(1,3,2) -3·(1,3) +3·(1,2,3)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">zero</span>(RG)
<span class="pl-c1">0</span>·()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">one</span>(RG) <span class="pl-c"><span class="pl-c">#</span> the canonical unit</span>
<span class="pl-c1">1</span>·()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">RG</span>(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> the same</span>
<span class="pl-c1">1</span>·()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">RG</span>(<span class="pl-k">-</span><span class="pl-c1">5.0</span>) <span class="pl-c"><span class="pl-c">#</span> coerce a scalar to the ring</span>
<span class="pl-k">-</span><span class="pl-c1">5.0</span>·()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">RG</span>(<span class="pl-c1">rand</span>(G)) <span class="pl-c"><span class="pl-c">#</span> the indicator function on a random element of G</span>
<span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> f <span class="pl-k">=</span> <span class="pl-c1">AlgebraElement</span>(<span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">3</span>, <span class="pl-c1">length</span>(b)), RG) <span class="pl-c"><span class="pl-c">#</span> an element given by vectors of coefficients in the basis</span>
<span class="pl-c1">1</span>·() <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>) <span class="pl-k">+</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>) <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>) <span class="pl-k">-</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>) <span class="pl-k">+</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)
</pre></div>
<p dir="auto">One may work with such element using the following functions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; StarAlgebras.coeffs(f)
6-element Vector{Int64}:
  1
 -1
  3
 -1
 -3
  3

julia&gt; StarAlgebras.star(p::PermutationGroups.AbstractPerm) = inv(p); star(f) # the star involution
1·() -1·(2,3) +3·(1,2) +3·(1,3,2) -3·(1,3) -1·(1,2,3)

julia&gt; f' # the same
1·() -1·(2,3) +3·(1,2) +3·(1,3,2) -3·(1,3) -1·(1,2,3)

julia&gt; g = rand(G); g
(1,2,3)

julia&gt; StarAlgebras.coeffs(RG(g)) # note the type of coefficients
6-element SparseArrays.SparseVector{Int64, UInt8} with 1 stored entry:
  [6]  =  1

julia&gt; x = one(RG) - 3RG(g); supp(x) # support of the funtion
2-element Vector{Permutation{...}:
 ()
 (1,2,3)

julia&gt; x(g) # value of x at g
-3

julia&gt; x[g] += 3; x # modification of x in-place
1·()

julia&gt; aug(f) # sum of coefficients
2

julia&gt; using LinearAlgebra; norm(f, 2) # 2-norm
5.477225575051661"><pre>julia<span class="pl-k">&gt;</span> StarAlgebras<span class="pl-k">.</span><span class="pl-c1">coeffs</span>(f)
<span class="pl-c1">6</span><span class="pl-k">-</span>element Vector{Int64}<span class="pl-k">:</span>
  <span class="pl-c1">1</span>
 <span class="pl-k">-</span><span class="pl-c1">1</span>
  <span class="pl-c1">3</span>
 <span class="pl-k">-</span><span class="pl-c1">1</span>
 <span class="pl-k">-</span><span class="pl-c1">3</span>
  <span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> StarAlgebras<span class="pl-k">.</span><span class="pl-en">star</span>(p<span class="pl-k">::</span><span class="pl-c1">PermutationGroups.AbstractPerm</span>) <span class="pl-k">=</span> <span class="pl-c1">inv</span>(p); <span class="pl-c1">star</span>(f) <span class="pl-c"><span class="pl-c">#</span> the star involution</span>
<span class="pl-c1">1</span>·() <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>) <span class="pl-k">+</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>) <span class="pl-k">-</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>) <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> f<span class="pl-k">'</span> <span class="pl-c"><span class="pl-c">#</span> the same</span>
<span class="pl-c1">1</span>·() <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>) <span class="pl-k">+</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>) <span class="pl-k">-</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>) <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> g <span class="pl-k">=</span> <span class="pl-c1">rand</span>(G); g
(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> StarAlgebras<span class="pl-k">.</span><span class="pl-c1">coeffs</span>(<span class="pl-c1">RG</span>(g)) <span class="pl-c"><span class="pl-c">#</span> note the type of coefficients</span>
<span class="pl-c1">6</span><span class="pl-k">-</span>element SparseArrays<span class="pl-k">.</span>SparseVector{Int64, UInt8} with <span class="pl-c1">1</span> stored entry<span class="pl-k">:</span>
  [<span class="pl-c1">6</span>]  <span class="pl-k">=</span>  <span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">one</span>(RG) <span class="pl-k">-</span> <span class="pl-c1">3</span><span class="pl-c1">RG</span>(g); <span class="pl-c1">supp</span>(x) <span class="pl-c"><span class="pl-c">#</span> support of the funtion</span>
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Permutation{<span class="pl-k">...</span>}<span class="pl-k">:</span>
 ()
 (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">x</span>(g) <span class="pl-c"><span class="pl-c">#</span> value of x at g</span>
<span class="pl-k">-</span><span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> x[g] <span class="pl-k">+=</span> <span class="pl-c1">3</span>; x <span class="pl-c"><span class="pl-c">#</span> modification of x in-place</span>
<span class="pl-c1">1</span>·()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">aug</span>(f) <span class="pl-c"><span class="pl-c">#</span> sum of coefficients</span>
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> LinearAlgebra; <span class="pl-c1">norm</span>(f, <span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> 2-norm</span>
<span class="pl-c1">5.477225575051661</span></pre></div>
<p dir="auto">Using this we can define e.g. a few projections in <code>RG</code> and check their orthogonality:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using Test

julia&gt; Base.sign(p::PermutationGroups.Permutation) = sign(p.perm);

julia&gt; l = length(b)
6

julia&gt; P = sum(RG(g) for g in b) // l # projection to the subspace fixed by G
1//6·() +1//6·(2,3) +1//6·(1,2) +1//6·(1,3,2) +1//6·(1,3) +1//6·(1,2,3)

julia&gt; @test P * P == P
Test Passed

julia&gt; P3 = 2 * sum(RG(g) for g in b if sign(g) &gt; 0) // l # projection to the subspace fixed by Alt(3) = C₃
1//3·() +1//3·(1,3,2) +1//3·(1,2,3)

julia&gt; @test P3 * P3 == P3
Test Passed

julia&gt; P2 = (RG(1) + RG(b[2])) // 2 # projection to the C₂-fixed subspace
1//2·() +1//2·(2,3)

julia&gt; @test P2 * P2 == P2
Test Passed

julia&gt; @test P2 * P3 == P3 * P2 == P # their intersection is precisely the same as the one for G
Test Passed

julia&gt; P2m = (RG(1) - RG(b[2])) // 2 # orthogonal C₂-fixed subspace
1//2·() -1//2·(2,3)

julia&gt; @test P2m * P2m == P2m
Test Passed

julia&gt; @test iszero(P2m * P2) # indeed P2 and P2m are orthogonal
Test Passed
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Test

julia<span class="pl-k">&gt;</span> Base<span class="pl-k">.</span><span class="pl-en">sign</span>(p<span class="pl-k">::</span><span class="pl-c1">PermutationGroups.Permutation</span>) <span class="pl-k">=</span> <span class="pl-c1">sign</span>(p<span class="pl-k">.</span>perm);

julia<span class="pl-k">&gt;</span> l <span class="pl-k">=</span> <span class="pl-c1">length</span>(b)
<span class="pl-c1">6</span>

julia<span class="pl-k">&gt;</span> P <span class="pl-k">=</span> <span class="pl-c1">sum</span>(<span class="pl-c1">RG</span>(g) <span class="pl-k">for</span> g <span class="pl-k">in</span> b) <span class="pl-k">//</span> l <span class="pl-c"><span class="pl-c">#</span> projection to the subspace fixed by G</span>
<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">6</span>·() <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">6</span>·(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>) <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">6</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">6</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">6</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>) <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">6</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> P <span class="pl-k">*</span> P <span class="pl-k">==</span> P
Test Passed

julia<span class="pl-k">&gt;</span> P3 <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">sum</span>(<span class="pl-c1">RG</span>(g) <span class="pl-k">for</span> g <span class="pl-k">in</span> b <span class="pl-k">if</span> <span class="pl-c1">sign</span>(g) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-k">//</span> l <span class="pl-c"><span class="pl-c">#</span> projection to the subspace fixed by Alt(3) = C₃</span>
<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">3</span>·() <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>) <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">3</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> P3 <span class="pl-k">*</span> P3 <span class="pl-k">==</span> P3
Test Passed

julia<span class="pl-k">&gt;</span> P2 <span class="pl-k">=</span> (<span class="pl-c1">RG</span>(<span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">RG</span>(b[<span class="pl-c1">2</span>])) <span class="pl-k">//</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> projection to the C₂-fixed subspace</span>
<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>·() <span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>·(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> P2 <span class="pl-k">*</span> P2 <span class="pl-k">==</span> P2
Test Passed

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> P2 <span class="pl-k">*</span> P3 <span class="pl-k">==</span> P3 <span class="pl-k">*</span> P2 <span class="pl-k">==</span> P <span class="pl-c"><span class="pl-c">#</span> their intersection is precisely the same as the one for G</span>
Test Passed

julia<span class="pl-k">&gt;</span> P2m <span class="pl-k">=</span> (<span class="pl-c1">RG</span>(<span class="pl-c1">1</span>) <span class="pl-k">-</span> <span class="pl-c1">RG</span>(b[<span class="pl-c1">2</span>])) <span class="pl-k">//</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> orthogonal C₂-fixed subspace</span>
<span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>·() <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">//</span><span class="pl-c1">2</span>·(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> P2m <span class="pl-k">*</span> P2m <span class="pl-k">==</span> P2m
Test Passed

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> <span class="pl-c1">iszero</span>(P2m <span class="pl-k">*</span> P2) <span class="pl-c"><span class="pl-c">#</span> indeed P2 and P2m are orthogonal</span>
Test Passed
</pre></div>
<p dir="auto">This package originated as a tool to compute sum of hermitian squares in <code>*</code>-algebras. These consist not of standard <code>f*f</code> summands, but rather <code>star(f)*f</code>. You may think of semi-definite matrices: their Cholesky decomposition determines <code>P = Q'·Q</code>, where <code>Q'</code> denotes transpose. Algebra of matrices with transpose is an (the?) example of a <code>*</code>-algebra. To compute such sums of squares one may either sprinkle the code with <code>star</code>s, or <code>'</code> (aka <code>Base.adjoint</code> postfix symbol):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x = RG(G(perm&quot;(1,2,3)&quot;))
1·(1,2,3)

julia&gt; X = one(RG) - x
1·() -1·(1,2,3)

julia&gt; X'
1·() -1·(1,3,2)

julia&gt; X'*X
2·() -1·(1,3,2) -1·(1,2,3)

julia&gt; @test X'*X == star(X)*X == 2one(X) - x - star(x)
Test Passed
"><pre>julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">RG</span>(<span class="pl-c1">G</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">perm</span>"</span>(1,2,3)<span class="pl-pds">"</span></span>))
<span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> X <span class="pl-k">=</span> <span class="pl-c1">one</span>(RG) <span class="pl-k">-</span> x
<span class="pl-c1">1</span>·() <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> X<span class="pl-k">'</span>
<span class="pl-c1">1</span>·() <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>)

julia<span class="pl-k">&gt;</span> X<span class="pl-k">'</span><span class="pl-k">*</span>X
<span class="pl-c1">2</span>·() <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>) <span class="pl-k">-</span><span class="pl-c1">1</span>·(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> X<span class="pl-k">'</span><span class="pl-k">*</span>X <span class="pl-k">==</span> <span class="pl-c1">star</span>(X)<span class="pl-k">*</span>X <span class="pl-k">==</span> <span class="pl-c1">2</span><span class="pl-c1">one</span>(X) <span class="pl-k">-</span> x <span class="pl-k">-</span> <span class="pl-c1">star</span>(x)
Test Passed
</pre></div>
<h3 dir="auto"><a id="user-content-more-advanced-use" class="anchor" aria-hidden="true" href="#more-advanced-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>More advanced use</h3>
<p dir="auto"><code>RG = StarAlgebra(G, b)</code> creates the algebra with <code>TrivialMStructure</code>, i.e. a multiplicative structure which computes product of basis elements every time it needs it. This of course may be wastefull, e.g. the computed products could be stored in a cache for future use. There are two options here:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; mt = StarAlgebras.MTable(b, table_size=(length(b), length(b)))
6×6 StarAlgebras.MTable{UInt8, false, Matrix{UInt8}}:
 0x01  0x02  0x03  0x04  0x05  0x06
 0x02  0x01  0x06  0x05  0x04  0x03
 0x03  0x04  0x01  0x02  0x06  0x05
 0x04  0x03  0x05  0x06  0x02  0x01
 0x05  0x06  0x04  0x03  0x01  0x02
 0x06  0x05  0x02  0x01  0x03  0x04
"><pre>julia<span class="pl-k">&gt;</span> mt <span class="pl-k">=</span> StarAlgebras<span class="pl-k">.</span><span class="pl-c1">MTable</span>(b, table_size<span class="pl-k">=</span>(<span class="pl-c1">length</span>(b), <span class="pl-c1">length</span>(b)))
<span class="pl-c1">6</span><span class="pl-k">×</span><span class="pl-c1">6</span> StarAlgebras<span class="pl-k">.</span>MTable{UInt8, <span class="pl-c1">false</span>, Matrix{UInt8}}<span class="pl-k">:</span>
 <span class="pl-c1">0x01</span>  <span class="pl-c1">0x02</span>  <span class="pl-c1">0x03</span>  <span class="pl-c1">0x04</span>  <span class="pl-c1">0x05</span>  <span class="pl-c1">0x06</span>
 <span class="pl-c1">0x02</span>  <span class="pl-c1">0x01</span>  <span class="pl-c1">0x06</span>  <span class="pl-c1">0x05</span>  <span class="pl-c1">0x04</span>  <span class="pl-c1">0x03</span>
 <span class="pl-c1">0x03</span>  <span class="pl-c1">0x04</span>  <span class="pl-c1">0x01</span>  <span class="pl-c1">0x02</span>  <span class="pl-c1">0x06</span>  <span class="pl-c1">0x05</span>
 <span class="pl-c1">0x04</span>  <span class="pl-c1">0x03</span>  <span class="pl-c1">0x05</span>  <span class="pl-c1">0x06</span>  <span class="pl-c1">0x02</span>  <span class="pl-c1">0x01</span>
 <span class="pl-c1">0x05</span>  <span class="pl-c1">0x06</span>  <span class="pl-c1">0x04</span>  <span class="pl-c1">0x03</span>  <span class="pl-c1">0x01</span>  <span class="pl-c1">0x02</span>
 <span class="pl-c1">0x06</span>  <span class="pl-c1">0x05</span>  <span class="pl-c1">0x02</span>  <span class="pl-c1">0x01</span>  <span class="pl-c1">0x03</span>  <span class="pl-c1">0x04</span>
</pre></div>
<p dir="auto">creates an eagerly computed multiplication table on elements of <code>b</code>. Keyword <code>table_size</code> is used to specify the table size (above: it's the whole multiplication table). Since <code>MTable&lt;:AbstractMatrix</code>, one can use the indexing syntax <code>mt[i,j]</code> to compute the <strong>index</strong> of the product of <code>i</code>-th and <code>j</code>-th elements of the basis. For example</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; g = G(perm&quot;(1,2,3)&quot;); h = G(perm&quot;(2,3)&quot;);

julia&gt; i, j = b[g], b[h] # indices of g and h in basis b
(0x06, 0x02)

julia&gt; k = mt[i,j] # the index of the product
0x05

julia&gt; @test b[k] == g*h
Test Passed
"><pre>julia<span class="pl-k">&gt;</span> g <span class="pl-k">=</span> <span class="pl-c1">G</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">perm</span>"</span>(1,2,3)<span class="pl-pds">"</span></span>); h <span class="pl-k">=</span> <span class="pl-c1">G</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">perm</span>"</span>(2,3)<span class="pl-pds">"</span></span>);

julia<span class="pl-k">&gt;</span> i, j <span class="pl-k">=</span> b[g], b[h] <span class="pl-c"><span class="pl-c">#</span> indices of g and h in basis b</span>
(<span class="pl-c1">0x06</span>, <span class="pl-c1">0x02</span>)

julia<span class="pl-k">&gt;</span> k <span class="pl-k">=</span> mt[i,j] <span class="pl-c"><span class="pl-c">#</span> the index of the product</span>
<span class="pl-c1">0x05</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> b[k] <span class="pl-k">==</span> g<span class="pl-k">*</span>h
Test Passed
</pre></div>
<p dir="auto">The second option is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; cmt = StarAlgebras.CachedMTable(b, table_size=(length(b), length(b)));"><pre>julia<span class="pl-k">&gt;</span> cmt <span class="pl-k">=</span> StarAlgebras<span class="pl-k">.</span><span class="pl-c1">CachedMTable</span>(b, table_size<span class="pl-k">=</span>(<span class="pl-c1">length</span>(b), <span class="pl-c1">length</span>(b)));</pre></div>
<p dir="auto">This multiplication table is lazy, i.e. products will be computed and stored only when actually needed. Additionally, one may call</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using SparseArrays

julia&gt; StarAlgebras.CachedMTable(b, spzeros(UInt8, length(b), length(b)));
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> SparseArrays

julia<span class="pl-k">&gt;</span> StarAlgebras<span class="pl-k">.</span><span class="pl-c1">CachedMTable</span>(b, <span class="pl-c1">spzeros</span>(UInt8, <span class="pl-c1">length</span>(b), <span class="pl-c1">length</span>(b)));
</pre></div>
<p dir="auto">to specify storage type of the matrix (by default it's a simple dense <code>Matrix</code>).
This may be advisable when a few products are computed repeatedly on a quite large basis.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; RGc = StarAlgebra(G, b, cmt)
*-algebra of Permutation group on 2 generators of order 6
"><pre>julia<span class="pl-k">&gt;</span> RGc <span class="pl-k">=</span> <span class="pl-c1">StarAlgebra</span>(G, b, cmt)
<span class="pl-k">*-</span>algebra of Permutation group on <span class="pl-c1">2</span> generators of order <span class="pl-c1">6</span>
</pre></div>
<p dir="auto">should be functinally equivalent to <code>RG</code> above, however it will cache computation of products lazily. A word of caution is needed here though. Even though <code>RGc</code> and <code>RG</code> are functionally equivalent, they are not <strong>comparable</strong> in the sense that e.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @test one(RGc) != one(RG)
Test Passed
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> <span class="pl-c1">one</span>(RGc) <span class="pl-k">!=</span> <span class="pl-c1">one</span>(RG)
Test Passed
</pre></div>
<p dir="auto">This is a conscious decision on our part, as comparing algebraic structures is easier said than done ;) To avoid solving this conundrum (are bases equal? are multiplicative structures equal? are these permuted by a compatible permutation? or maybe a linear transformation was applied to the basis, resulting in a different, but equivalent multiplicative structure?), elements could be mixed together <strong>only if their parents are identically</strong> (i.e. <code>===</code>) <strong>equal</strong>.</p>
<p dir="auto">Finally, if the group is infinite (or just too large), but we need specific products, we may reduce the table_size to the required size (it doesn't have to be <code>length(b) × length(b)</code>). Note that in such case asking for a product outside of multiplication table will rise <code>ProductNotDefined</code> exception.</p>
<h3 dir="auto"><a id="user-content-even-more-advanced-use-for-experts-only" class="anchor" aria-hidden="true" href="#even-more-advanced-use-for-experts-only"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Even more advanced use (for experts only)</h3>
<p dir="auto">For low-level usage <code>MultiplicativeStructures</code> follow the sign convention:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; mt = StarAlgebras.CachedMTable(b, table_size=(length(b), length(b)));

```julia
julia&gt; k = mt[-i,j]
0x06

julia&gt; @test star(b[i])*b[j] == b[k]
Test Passed
"><pre>julia<span class="pl-k">&gt;</span> mt <span class="pl-k">=</span> StarAlgebras<span class="pl-k">.</span><span class="pl-c1">CachedMTable</span>(b, table_size<span class="pl-k">=</span>(<span class="pl-c1">length</span>(b), <span class="pl-c1">length</span>(b)));

<span class="pl-s"><span class="pl-pds">```</span>julia</span>
<span class="pl-s">julia&gt; k = mt[-i,j]</span>
<span class="pl-s">0x06</span>
<span class="pl-s"></span>
<span class="pl-s">julia&gt; @test star(b[i])*b[j] == b[k]</span>
<span class="pl-s">Test Passed</span>
<span class="pl-s"></span></pre></div>
<p dir="auto">Note that this (minus-twisted) "product" is no longer associative! Observe:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @test mt[mt[3, 5], 4] == mt[3, mt[5, 4]] # (b[3]*b[4])*b[5] == b[3]*(b[4]*b[5])
Test Passed

julia&gt; @test mt[-signed(mt[-3, 5]), 4] == 0x06 # star(star(b[3])*b[5])*b[4] = star(b[5])*b[3]*b[4]
Test Passed

julia&gt; @test mt[-3, mt[-5, 4]] == 0x01 # star(b[3])*star(b[5])*b[4]
Test Passed"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> mt[mt[<span class="pl-c1">3</span>, <span class="pl-c1">5</span>], <span class="pl-c1">4</span>] <span class="pl-k">==</span> mt[<span class="pl-c1">3</span>, mt[<span class="pl-c1">5</span>, <span class="pl-c1">4</span>]] <span class="pl-c"><span class="pl-c">#</span> (b[3]*b[4])*b[5] == b[3]*(b[4]*b[5])</span>
Test Passed

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> mt[<span class="pl-k">-</span><span class="pl-c1">signed</span>(mt[<span class="pl-k">-</span><span class="pl-c1">3</span>, <span class="pl-c1">5</span>]), <span class="pl-c1">4</span>] <span class="pl-k">==</span> <span class="pl-c1">0x06</span> <span class="pl-c"><span class="pl-c">#</span> star(star(b[3])*b[5])*b[4] = star(b[5])*b[3]*b[4]</span>
Test Passed

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@test</span> mt[<span class="pl-k">-</span><span class="pl-c1">3</span>, mt[<span class="pl-k">-</span><span class="pl-c1">5</span>, <span class="pl-c1">4</span>]] <span class="pl-k">==</span> <span class="pl-c1">0x01</span> <span class="pl-c"><span class="pl-c">#</span> star(b[3])*star(b[5])*b[4]</span>
Test Passed</pre></div>
<hr>
<p dir="auto">If you happen to use this package please cite either <a href="https://arxiv.org/abs/1712.07167" rel="nofollow">1712.07167</a> or <a href="https://arxiv.org/abs/1812.03456" rel="nofollow">1812.03456</a>. This package superseeds <a href="https://github.com/kalmarek/GroupRings.jl">GroupRings.jl</a> which was developed and used there. It served its purpose well. Let it rest peacefully.</p>
</article></div>