<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-voronoigraph" class="anchor" aria-hidden="true" href="#voronoigraph"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>VoronoiGraph</h1>
<p dir="auto"><a href="https://zenodo.org/badge/latestdoi/417525067" rel="nofollow"><img src="https://camo.githubusercontent.com/c7097864f3e206575731ff91f590a2f86312a4173daf5ec590a6431c15221ecb/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3431373532353036372e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/417525067.svg" style="max-width: 100%;"></a>
<a href="https://axsk.github.io/VoronoiGraph.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/axsk/VoronoiGraph.jl/actions"><img src="https://github.com/axsk/VoronoiGraph.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/axsk/VoronoiGraph.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/cb3002ba30803a5bd39d676c6d0be9fec1697a1d18d2ba5869121003e1de7015/68747470733a2f2f636f6465636f762e696f2f67682f6178736b2f566f726f6e6f6947726170682e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d4f59485a4b594f453248" alt="codecov" data-canonical-src="https://codecov.io/gh/axsk/VoronoiGraph.jl/branch/main/graph/badge.svg?token=OYHZKYOE2H" style="max-width: 100%;"></a></p>
<p dir="auto">This Package implements a variation of the Voronoi Graph Traversal algorithm by Polianskii and Pokorny <a href="https://dl.acm.org/doi/10.1145/3394486.3403266" rel="nofollow">[1]</a>.
It constructs a <a href="https://en.wikipedia.org/wiki/Voronoi_diagram" rel="nofollow">Voronoi Diagram</a> from a set of points by performing a random walk on the graph of the vertices of the diagram.
Unlike many other Voronoi implementations this algorithm is not limited to 2 or 3 dimensions and promises good performance even in higher dimensions.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">We can compute the Voronoi diagram with a simple call of <code>voronoi</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; data = rand(4, 100)  # 100 points in 4D space
julia&gt; v, P = voronoi(data)"><pre>julia<span class="pl-k">&gt;</span> data <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">4</span>, <span class="pl-c1">100</span>)  <span class="pl-c"><span class="pl-c">#</span> 100 points in 4D space</span>
julia<span class="pl-k">&gt;</span> v, P <span class="pl-k">=</span> <span class="pl-c1">voronoi</span>(data)</pre></div>
<p dir="auto">which returns the vertices <code>v::Dict</code>. <code>keys(v)</code> returns the simplicial complex of the diagram,
wheras <code>v[xs]</code> returns the coordinates of the vertex inbetween the generators <code>data[xs]</code>.
Additionally <code>P</code> contains the data in a vector-of-vectors format, used for further computations.</p>
<p dir="auto">It also exports the random walk variant (returning only a subset of vertices):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; v, P = voronoi_random(data, 1000)  # perform 1000 iterations of the random walk"><pre>julia<span class="pl-k">&gt;</span> v, P <span class="pl-k">=</span> <span class="pl-c1">voronoi_random</span>(data, <span class="pl-c1">1000</span>)  <span class="pl-c"><span class="pl-c">#</span> perform 1000 iterations of the random walk</span></pre></div>
<h2 dir="auto"><a id="user-content-area--volume-computation" class="anchor" aria-hidden="true" href="#area--volume-computation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Area / Volume computation</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A,V = volumes(v, P)"><pre>julia<span class="pl-k">&gt;</span> A,V <span class="pl-k">=</span> <span class="pl-c1">volumes</span>(v, P)</pre></div>
<p dir="auto">computes the (deterministic) areas of the boundaries of neighbouring cells (as sparse array <code>A</code>)
as well as the volume of the cells themselves (vector <code>V</code>) by falling back onto the Polyhedra.jl volume computation.</p>
<h2 dir="auto"><a id="user-content-monte-carlo" class="anchor" aria-hidden="true" href="#monte-carlo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Monte Carlo</h2>
<p dir="auto">Combining the raycasting approach with Monte Carlo estimates we can approximate the areas and volumes effectively:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A, V = mc_volumes(P, 1000)  # cast 1000 Monte Carlo rays per cell"><pre>julia<span class="pl-k">&gt;</span> A, V <span class="pl-k">=</span> <span class="pl-c1">mc_volumes</span>(P, <span class="pl-c1">1000</span>)  <span class="pl-c"><span class="pl-c">#</span> cast 1000 Monte Carlo rays per cell</span></pre></div>
<p dir="auto">If the simplicial complex of vertices is already known we can speed up the process:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A, V = mc_volumes(v, P, 1000)  # use the neighbourhood infromation contained in v"><pre>julia<span class="pl-k">&gt;</span> A, V <span class="pl-k">=</span> <span class="pl-c1">mc_volumes</span>(v, P, <span class="pl-c1">1000</span>)  <span class="pl-c"><span class="pl-c">#</span> use the neighbourhood infromation contained in v</span></pre></div>
<p dir="auto">We furthermore can integrate any function <code>f</code> over a cell <code>i</code> and its boundaries:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; y, δy, V, A = mc_integrate(x-&gt;x^2, 1, P, 100, 10) # integrate cell 1 with 100 boundary and 100*10 volume samples"><pre>julia<span class="pl-k">&gt;</span> y, δy, V, A <span class="pl-k">=</span> <span class="pl-c1">mc_integrate</span>(x<span class="pl-k">-&gt;</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span>, P, <span class="pl-c1">100</span>, <span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> integrate cell 1 with 100 boundary and 100*10 volume samples</span></pre></div>
<p dir="auto">Here <code>y</code> and the vector <code>δy</code> contain the integrals over the cell and its boundaries. V and A get computed as a byproduct.</p>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto"><a href="https://dl.acm.org/doi/10.1145/3394486.3403266" rel="nofollow">[1]</a> V. Polianskii, F. T. Pokorny - Voronoi Graph Traversal in High Dimensions with Applications to Topological Data Analysis and Piecewise Linear Interpolation (2020, Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining)</p>
</article></div>