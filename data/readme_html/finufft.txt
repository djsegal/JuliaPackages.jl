<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-finufftjl" class="anchor" aria-hidden="true" href="#finufftjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FINUFFT.jl</h1>
<p dir="auto"><a href="https://github.com/ludvigak/FINUFFT.jl/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/ludvigak/FINUFFT.jl/workflows/CI/badge.svg?branch=master" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/ludvigak/FINUFFT.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d303031004cc1c5fbd3782441758dffe550baf26ec64acc7deebaf57f46df65d/68747470733a2f2f636f6465636f762e696f2f67682f6c7564766967616b2f46494e554646542e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d546b78376b6d6131384a" alt="codecov" data-canonical-src="https://codecov.io/gh/ludvigak/FINUFFT.jl/branch/master/graph/badge.svg?token=Tkx7kma18J" style="max-width: 100%;"></a>
<a href="https://ludvigak.github.io/FINUFFT.jl/latest/" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This is a full-featured Julia interface to <a href="https://github.com/flatironinstitute/finufft">FINUFFT</a>, which is a lightweight and fast parallel nonuniform fast Fourier transform (NUFFT) library released by the Flatiron Institute. This interface stands at v3.x, and it uses FINUFFT version 2.1.0 (note that the interface version number is distinct from the version of the wrapped binary FINUFFT library).</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">FINUFFT.jl requires Julia v1.3 or later, and has been tested up to v1.7.1. From the Pkg REPL mode (hit <code>]</code> in REPL to enter), run</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add FINUFFT"><pre>add FINUFFT</pre></div>
<p dir="auto">This installs the stable registered version and its dependencies, including our multi-platform precompiled
binaries <a href="https://github.com/JuliaBinaryWrappers/finufft_jll.jl">finufft_jll.jl</a>, which are now microarchitecture-specific (including <code>avx2</code>) for better performance.
You may be able to squeeze a little more performance via locally-compiled binaries; see below.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">This module now provides the functions <code>nufft1d1</code>, <code>nufft1d2</code>, ..., <code>nufft3d3</code>, <code>nufft1d1!</code>, <code>nufft1d2!</code>, ..., <code>nufft3d3!</code>, that now wrap the
simple and vectorized interfaces in a unified way,
as well as
<code>finufft_makeplan</code>, <code>finufft_setpts!</code>, <code>finufft_exec</code>, <code>finufft_exec!</code> and <code>finufft_destroy!</code> that wrap the guru interface.
This brings the Julia interface up to the standards of the
FINUFFT's <a href="https://finufft.readthedocs.io/en/latest/matlab.html" rel="nofollow">MATLAB/Octave</a>
and <a href="https://finufft.readthedocs.io/en/latest/python.html" rel="nofollow">Python</a> interfaces.
The underlying C++ routines that are called have full documentation
<a href="https://finufft.readthedocs.io/en/latest/c.html" rel="nofollow">here</a>.</p>
<p dir="auto">An auto-generated reference for all provided Julia functions is <a href="https://ludvigak.github.io/FINUFFT.jl/latest/" rel="nofollow">here</a>.</p>
<blockquote>
<p dir="auto"><strong>Warning:</strong> On 10/28/21 (v2.1.0) and 1/5/22 (v3.0.0), the interface has changed (improved) significantly,
breaking some backward compatibility, as follows. Please also read the documentation.</p>
</blockquote>
<ul dir="auto">
<li>Function calls mimic the C/C++ interface, with the exception that you don't need to pass the dimensions of any arrays in the argument (they are inferred using <code>size()</code>).</li>
<li>A vectorized call (performing multiple transforms, each with different coefficient vectors but the same set of nonuniform points) can now be performed using the same functions as the single-transform interface, detected from the size of the input arrays.</li>
<li>Both 64-bit and 32-bit precision calls are now supported using a single
set of function names. Which precision to use is inferred from the type of the input arrays, except for in the guru interface where the <code>dtype</code> argument is required for <code>finufft_makeplan</code>. (NOTE: The use of the <code>dtype</code> argument in the simple interface is deprecated as of v3.1.0)</li>
<li>The functions named <code>nufftDdN</code> return the output array.</li>
<li>In contrast, the functions named <code>nufftDdN!</code> take the output array as an argument. This needs to be preallocated with the correct size.</li>
<li>Likewise, in the guru interface, <code>finufft_exec</code> returns the output array,
while <code>finufft_exec!</code> takes the output array as an argument that needs to be preallocated. The methods <code>finufft_setpts!</code> and <code>finufft_destroy!</code> now include explamation points in Julian style, since they both change the plan.</li>
<li>Options differing from their default values are now set using keyword arguments both in the simple interfaces, or in <code>finufft_makeplan</code> for the guru interface.</li>
</ul>
<h3 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FINUFFT

# Here we demo a Float64 1D type 1 transform
nj = 1000000
x = pi*(1.0 .- 2.0*rand(nj))      # nonuniform points
c = rand(nj) + 1im*rand(nj)       # their strengths

ms = 2000000      # output size (number of Fourier modes)
tol = 1e-9        # requested relative tolerance

# Output as return value (1e6 pts to 2e6 modes takes about 0.1 sec)...
fk = nufft1d1(x, c, 1, tol, ms)

# Or, output into preallocated array, whose size determines ms...
out = Array{ComplexF64}(undef, ms)
nufft1d1!(x, c, 1, tol, out)

# Demo using keyword args to change options from defaults...
fk_fftord = nufft1d1(x, c, 1, tol, ms, debug=1, modeord=1, nthreads=4)"><pre><span class="pl-k">using</span> FINUFFT

<span class="pl-c"><span class="pl-c">#</span> Here we demo a Float64 1D type 1 transform</span>
nj <span class="pl-k">=</span> <span class="pl-c1">1000000</span>
x <span class="pl-k">=</span> <span class="pl-c1">pi</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">.-</span> <span class="pl-c1">2.0</span><span class="pl-k">*</span><span class="pl-c1">rand</span>(nj))      <span class="pl-c"><span class="pl-c">#</span> nonuniform points</span>
c <span class="pl-k">=</span> <span class="pl-c1">rand</span>(nj) <span class="pl-k">+</span> <span class="pl-c1">1im</span><span class="pl-k">*</span><span class="pl-c1">rand</span>(nj)       <span class="pl-c"><span class="pl-c">#</span> their strengths</span>

ms <span class="pl-k">=</span> <span class="pl-c1">2000000</span>      <span class="pl-c"><span class="pl-c">#</span> output size (number of Fourier modes)</span>
tol <span class="pl-k">=</span> <span class="pl-c1">1e-9</span>        <span class="pl-c"><span class="pl-c">#</span> requested relative tolerance</span>

<span class="pl-c"><span class="pl-c">#</span> Output as return value (1e6 pts to 2e6 modes takes about 0.1 sec)...</span>
fk <span class="pl-k">=</span> <span class="pl-c1">nufft1d1</span>(x, c, <span class="pl-c1">1</span>, tol, ms)

<span class="pl-c"><span class="pl-c">#</span> Or, output into preallocated array, whose size determines ms...</span>
out <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{ComplexF64}</span>(undef, ms)
<span class="pl-c1">nufft1d1!</span>(x, c, <span class="pl-c1">1</span>, tol, out)

<span class="pl-c"><span class="pl-c">#</span> Demo using keyword args to change options from defaults...</span>
fk_fftord <span class="pl-k">=</span> <span class="pl-c1">nufft1d1</span>(x, c, <span class="pl-c1">1</span>, tol, ms, debug<span class="pl-k">=</span><span class="pl-c1">1</span>, modeord<span class="pl-k">=</span><span class="pl-c1">1</span>, nthreads<span class="pl-k">=</span><span class="pl-c1">4</span>)</pre></div>
<p dir="auto">The above code may be found in <a href="examples/demo1d1.jl">examples/demo1d1.jl</a></p>
<h3 dir="auto"><a id="user-content-more-examples" class="anchor" aria-hidden="true" href="#more-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>More examples</h3>
<p dir="auto">For a 2D type 1 with timing benchmark,
see <a href="examples/time2d1.jl">examples/time2d1.jl</a></p>
<p dir="auto">Finally, the more involved code <a href="test/test_nufft.jl">test/test_nufft.jl</a>
tests <code>dtype=Float64</code> and <code>dtype=Float32</code> precisions
for all nine transform types.
The outputs are tested there for mathematical correctness.
In the 1D type 1 it also tests a vectorized simple, a guru call and
a vectorized guru call.
The help documentation for each function will also gradually be populated
with examples.</p>
<h2 dir="auto"><a id="user-content-advanced-installation-and-locally-compiling-binaries" class="anchor" aria-hidden="true" href="#advanced-installation-and-locally-compiling-binaries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Advanced installation and locally compiling binaries</h2>
<p dir="auto">To get the latest version of this interface do <code>add FINUFFT#master</code>, but note this still uses the precompiled binaries from <code>finufft_jll</code>.</p>
<p dir="auto">You may get a little more performance by locally compiling binaries as follows. This has only been tested on ubuntu linux, so YMMV. First install the source
<a href="https://github.com/flatironinstitute/finufft">FINUFFT</a>,
<code>cd</code> to its top directory (which we'll call <code>YOURFINUFFT</code>),
<code>make test</code> and check that gives no errors. You may need to create a
<code>make.inc</code> for your system, as per its documentation.
Now start Julia and install the latest interface in develop mode:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; dev https://github.com/ludvigak/FINUFFT.jl"><pre>pkg<span class="pl-k">&gt;</span> dev https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>ludvigak<span class="pl-k">/</span>FINUFFT<span class="pl-k">.</span>jl</pre></div>
<p dir="auto">This should create <code>~/.julia/dev/FINUFFT/src/FINUFFT.jl</code> which you should edit,
following the simple instructions to set</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="const libfinufft = &quot;YOURFINUFFT/lib/libfinufft.so&quot;"><pre class="notranslate"><code>const libfinufft = "YOURFINUFFT/lib/libfinufft.so"
</code></pre></div>
<p dir="auto">Restart Julia, and <code>pkg&gt; test FINUFFT</code> to check it worked.
You may find that <code>julia&gt; include("examples/time2d1.jl")</code> runs faster
than before (however, since we included <code>avx2</code> in our binaries, it is
unlikely to run faster on an x86_64 CPU).
Now proceed by <code>using FINUFFT</code> as usual.
You may do <code>pkg&gt; free FINUFFT</code> and restart to return to the registered package
with generic binaries.
Here's <a href="https://pkgdocs.julialang.org/v1/managing-packages" rel="nofollow">general info about packages</a>.</p>
<p dir="auto">Finally, older versions of the package are available also for Julia v1.0-v1.2, but the user needs to have a recent version of GCC installed.</p>
<h2 dir="auto"><a id="user-content-developers-of-this-julia-wrapper" class="anchor" aria-hidden="true" href="#developers-of-this-julia-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Developers of this Julia wrapper</h2>
<p dir="auto">Main authors:</p>
<ul dir="auto">
<li>Ludvig af Klinteberg (old interface)</li>
<li>Libin Lu (new full-featured interface)</li>
<li>Jonas Krimmer (many contributions to full-featured interface)</li>
</ul>
<p dir="auto">Additional authors:</p>
<ul dir="auto">
<li>Alex Barnett (guidance/tweaks/docs/examples)</li>
<li>Mose Giordano (packaging, binaries)</li>
</ul>
<h3 dir="auto"><a id="user-content-to-do-please-help" class="anchor" aria-hidden="true" href="#to-do-please-help"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>To do (please help)</h3>
<ul dir="auto">
<li>populate the docstrings each with a working example</li>
<li>add more <code>examples/</code> with math tests</li>
<li>more extensive tests, including more "dumb inputs" as in C++</li>
</ul>
</article></div>