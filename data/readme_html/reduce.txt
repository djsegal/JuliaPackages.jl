<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p align="center">
  <a target="_blank" rel="noopener noreferrer" href="./docs/src/assets/logo.png"><img src="./docs/src/assets/logo.png" alt="Reduce.jl" style="max-width:100%;"></a>
</p>
<h1><a id="user-content-reducejl" class="anchor" aria-hidden="true" href="#reducejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reduce.jl</h1>
<p><em>Symbolic parser generator for Julia language expressions using REDUCE algebra term rewriter</em></p>
<p><a href="https://zenodo.org/badge/latestdoi/90334073" rel="nofollow"><img src="https://camo.githubusercontent.com/91b8aa2f44d27ccbacebba18fa073ef12129dbcb/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f39303333343037332e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/90334073.svg" style="max-width:100%;"></a>
<a href="https://reduce.crucialflow.com/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/f7b92a177c912c1cc007fc9b40f17ff3ee3bb414/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Docs Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a>
<a href="https://reduce.crucialflow.com/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/3e353c26ddfe819150acbc732248f4f2a37f5175/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Docs Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a>
<a href="https://gitter.im/Reduce-jl/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" rel="nofollow"><img src="https://camo.githubusercontent.com/8777687e0e86f5ae3b44d1b5ae8b6c73bbe57fb4/68747470733a2f2f6261646765732e6769747465722e696d2f5265647563652d6a6c2f4c6f6262792e737667" alt="Join the chat at gitter" data-canonical-src="https://badges.gitter.im/Reduce-jl/Lobby.svg" style="max-width:100%;"></a>
<a href="https://travis-ci.org/chakravala/Reduce.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/123d1b702e5a068842c13e85c095662c838f8884/68747470733a2f2f7472617669732d63692e6f72672f6368616b726176616c612f5265647563652e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/chakravala/Reduce.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/chakravala/reduce-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/aaaa483bbb89d534423a1e18d2f4a39c26360ae1/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6b61717532797269347678797236336e3f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/kaqu2yri4vxyr63n?svg=true" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/chakravala/Reduce.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/0a2783df8ef28f727dc10499f31c4ea1b72cc506/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6368616b726176616c612f5265647563652e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/chakravala/Reduce.jl/badge.svg?branch=master" style="max-width:100%;"></a>
<a href="http://codecov.io/github/chakravala/Reduce.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/94bf4053ee4724e8077c200d54bddfe0e5106a5b/687474703a2f2f636f6465636f762e696f2f6769746875622f6368616b726176616c612f5265647563652e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/chakravala/Reduce.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>The premise behind Reduce.jl is based on the idea that <code>Symbol</code> and <code>Expr</code> types can be translated into computer algebra rewrite commands and then automatically parsed back into Julia ASTs, essentially extending the Julia language into a fully programable symbolic AST rewrite environment.</p>
<p>REDUCE is a system for general algebraic computations of interest to mathematicians, scientists and engineers:</p>
<ul>
<li>exact arithmetic using integers and fractions; arbitrary precision numerical approximation;</li>
<li>polynomial and rational function algebra; factorization and expansion of polynomials and rational functions;</li>
<li>differentiation and integration of multi-variable functions; exponential, logarithmic, trigonometric and hyperbolic;</li>
<li>output of results in a variety of formats; automatic and user controlled simplification of expressions;</li>
<li>substitutions and pattern matching of expressions; quantifier elimination and decision for interpreted first-order logic;</li>
<li>solution of ordinary differential equations; calculations with a wide variety of special (higher transcendental) functions;</li>
<li>calculations involving matrices with numerical and symbolic elements; general matrix and non-commutative algebra;</li>
<li>powerful intuitive user-level programming language; generating optimized numerical programs from symbolic input;</li>
<li>Dirac matrix calculations of interest to high energy physicists; solution of single and simultaneous equations.</li>
</ul>
<p>Interface for applying symbolic manipulation on <a href="https://docs.julialang.org/en/latest/manual/metaprogramming" rel="nofollow">Julia expressions</a> using <a href="http://www.reduce-algebra.com" rel="nofollow">REDUCE</a>'s term rewrite system:</p>
<ul>
<li>reduce expressions are <code>RExpr</code> objects that can <code>parse</code> into julia <code>Expr</code> objects and vice versa;</li>
<li>interface link communicates and interprets via various reduce output modes using <code>rcall</code> method;</li>
<li>high-level reduce-julia syntax parser-generator walks arbitrary expression to rewrite mathematical code;</li>
<li>import operators from REDUCE using code generation to apply to arbitrary computational expressions;</li>
<li>interactive <code>reduce&gt;</code> REPL within the Julia terminal window activated by <code>}</code> key;</li>
<li>extended arithmetic operators <code>+</code>,<code>-</code>,<code>*</code>,<code>^</code>,<code>/</code>,<code>//</code> compute on <code>Symbol</code> and <code>Expr</code> types;</li>
<li>provides hundreds of internal and external methods each supporting many argument types.</li>
</ul>
<p>Additional packages that depend on Reduce.jl are maintained at <a href="https://github.com/JuliaReducePkg">JuliaReducePkg</a>.</p>
<p>The upstream REDUCE software created by Anthony C. Hearn is maintained by collaborators on <a href="https://sourceforge.net/p/reduce-algebra/" rel="nofollow">SourceForge</a>.</p>
<p>This package is a heavily modifed version of Nathan Smith's <a href="https://github.com/nsmith5/Maxima.jl">Maxima.jl</a> with many additional features.</p>
<h2><a id="user-content-setup" class="anchor" aria-hidden="true" href="#setup"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Setup</h2>
<p>The <code>Reduce</code> package provides the base functionality to work with Julia and Reduce expressions, provided that you have <code>redcsl</code> in your path. On GNU/Linux/OSX/Windows, <code>Pkg.build("Reduce")</code> will automatically download a precompiled binary for you. If you are running a different Unix operating system, the build script will download the source and attempt to compile <code>redcsl</code> for you, success depends on the build tools installed. Automated testing for <strong>Travis CI</strong> and <strong>appveyor</strong> using Linux, OSX, and Windows are fully operational <code>using Reduce</code>.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>Reduce<span class="pl-pds">"</span></span>); Pkg<span class="pl-k">.</span><span class="pl-c1">build</span>(<span class="pl-s"><span class="pl-pds">"</span>Reduce<span class="pl-pds">"</span></span>)
julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Reduce
Reduce (Free CSL version, revision <span class="pl-c1">4521</span>),  <span class="pl-c1">11</span><span class="pl-k">-</span>March<span class="pl-k">-</span><span class="pl-c1">2018</span> <span class="pl-k">...</span></pre></div>
<p>For users who wish to experimentally apply additional precompilation, it is possible to enable extra precompilation scripts by setting the environment variable <code>ENV["REDPRE"] = "1"</code> in julia (only effective when <code>Reduce</code> is being compiled).</p>
<p>View the documentation <a href="https://chakravala.github.io/Reduce.jl/stable" rel="nofollow">stable</a> / <a href="https://chakravala.github.io/Reduce.jl/latest" rel="nofollow">latest</a> for more features and examples.</p>
<p>This <code>Reduce</code> package for the Julia language was created by <a href="https://github.com/chakravala">github.com/chakravala</a> for mathematics and computer algebra research with the upstream developed REDUCE software.
Please consider donating to show your thanks and appreciation to this Julia project for interfacing the upstream REDUCE language at <a href="https://liberapay.com/chakravala" rel="nofollow">liberapay</a>, <a href="https://github.com/sponsors/chakravala">GitHub Sponsors</a>, <a href="https://patreon.com/dreamscatter" rel="nofollow">Patreon</a>, or contribute (documentation, tests, examples) in the repository.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The extended algebraic symbolic expression mode of Reduce.jl is activated with <a href="https://github.com/chakravala/ForceImport.jl">ForceImport.jl</a> by</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@force</span> <span class="pl-k">using</span> Reduce<span class="pl-k">.</span>Algebra</pre></div>
<p>This locally extends native Julia functions to <code>Symbol</code> and <code>Expr</code> types in the current module without extending global methods. Alternatively, the methods it provides can be accesed by prefixing <code>Algebra.</code> in front of the method.</p>
<p>Reduce expressions encapsulated into <code>RExpr</code> objects can be manipulated within julia using the standard syntax. Create an expression object either using the <code>RExpr("expression")</code> string constructor or <code>R"expression"</code>. Additionally, arbitrary julia expressions can also be parsed directly using the <code>RExpr(expr)</code> constructor. Internally <code>RExpr</code> objects are represented as an array that can be accessed by calling <code>*.str[n]</code> on the object.</p>
<p>When <code>Reduce</code> is used in Julia, standard arithmetic operations are now extended to also work on <code>Symbol</code> and <code>Expr</code> types.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">:n</span>
:((n <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">//</span> n)

julia<span class="pl-k">&gt;</span> ans<span class="pl-k">^-</span><span class="pl-c1">:n</span>
:(<span class="pl-c1">1</span> <span class="pl-k">//</span> ((n <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">//</span> n) <span class="pl-k">^</span> n)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">limit</span>(ans,<span class="pl-c1">:n</span>,<span class="pl-c1">Inf</span>)
ℯ <span class="pl-k">=</span> <span class="pl-c1">2.7182818284590</span><span class="pl-k">...</span></pre></div>
<p>Julia abstract syntax trees are automatically converted into sequences of reduce statements (using <code>RExpr</code> constructor) that are in return parsed into julia <code>quote</code> blocks usig <code>parse</code>.
The <code>rcall</code> method is used to evaluate any type of expression.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> :(<span class="pl-c1">int</span>(<span class="pl-c1">sin</span>(im<span class="pl-k">*</span>x<span class="pl-k">+</span>pi)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1</span>,x)) <span class="pl-k">|&gt;</span> rcall
:((<span class="pl-c1">1</span> <span class="pl-k">-</span> (ℯ <span class="pl-k">^</span> (<span class="pl-c1">4</span>x) <span class="pl-k">+</span> <span class="pl-c1">4</span> <span class="pl-k">*</span> ℯ <span class="pl-k">^</span> (<span class="pl-c1">2</span>x) <span class="pl-k">*</span> x)) <span class="pl-k">//</span> (<span class="pl-c1">8</span> <span class="pl-k">*</span> ℯ <span class="pl-k">^</span> (<span class="pl-c1">2</span>x)))</pre></div>
<p>However, there are often multiple equivalent ways of achieving the same result:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">int</span>(<span class="pl-c1">sin</span>(im<span class="pl-k">*</span><span class="pl-c1">:x</span><span class="pl-k">+</span>π)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1</span>,<span class="pl-c1">:x</span>)
:((<span class="pl-c1">1</span> <span class="pl-k">-</span> (ℯ <span class="pl-k">^</span> (<span class="pl-c1">4</span>x) <span class="pl-k">+</span> <span class="pl-c1">4</span> <span class="pl-k">*</span> ℯ <span class="pl-k">^</span> (<span class="pl-c1">2</span>x) <span class="pl-k">*</span> x)) <span class="pl-k">//</span> (<span class="pl-c1">8</span> <span class="pl-k">*</span> ℯ <span class="pl-k">^</span> (<span class="pl-c1">2</span>x)))</pre></div>
<p>The output of <code>rcall</code> will be the same as its input type.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>int(sin(y)^2, y)<span class="pl-pds">"</span></span> <span class="pl-k">|&gt;</span> rcall
<span class="pl-s"><span class="pl-pds">"</span>( - cos(y)*sin(y) + y)/2<span class="pl-pds">"</span></span></pre></div>
<p>Use <code>rcall(expr,switches...)</code> to evaluate <code>expr</code> using REDUCE mode <code>switches</code> like <code>:expand</code>, <code>:factor</code>, and <code>:latex</code>.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> :((x<span class="pl-k">+</span>im<span class="pl-k">+</span>π)<span class="pl-k">^</span><span class="pl-c1">2</span>; <span class="pl-c1">int</span>(<span class="pl-c1">1</span><span class="pl-k">/</span>(<span class="pl-c1">1</span><span class="pl-k">+</span>x<span class="pl-k">^</span><span class="pl-c1">3</span>),x)) <span class="pl-k">|&gt;</span> RExpr
<span class="pl-k">^</span>(<span class="pl-k">+</span>(x,i,pi),<span class="pl-c1">2</span>);
<span class="pl-c1">int</span>(<span class="pl-k">/</span>(<span class="pl-c1">1</span>,<span class="pl-k">+</span>(<span class="pl-c1">1</span>,<span class="pl-k">^</span>(x,<span class="pl-c1">3</span>))),x);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">rcall</span>(ans,<span class="pl-c1">:horner</span>) <span class="pl-k">|&gt;</span> parse
<span class="pl-k">quote</span>
    ((π <span class="pl-k">+</span> <span class="pl-c1">2</span>x) <span class="pl-k">*</span> π <span class="pl-k">+</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> (π <span class="pl-k">+</span> x) <span class="pl-k">*</span> im <span class="pl-k">+</span> x <span class="pl-k">^</span> <span class="pl-c1">2</span>) <span class="pl-k">-</span> <span class="pl-c1">1</span>
    ((<span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">3</span>) <span class="pl-k">*</span> <span class="pl-c1">atan</span>((<span class="pl-c1">2</span>x <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">//</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">3</span>)) <span class="pl-k">-</span> <span class="pl-c1">log</span>((x <span class="pl-k">^</span> <span class="pl-c1">2</span> <span class="pl-k">-</span> x) <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">+</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">log</span>(x <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">//</span> <span class="pl-c1">6</span>
<span class="pl-k">end</span></pre></div>
<p>Mathematical operators and REDUCE modes can be applied directly to <code>Expr</code> and <code>RExpr</code> objects.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Expr</span>(<span class="pl-c1">:function</span>,:(<span class="pl-c1">fun</span>(a,b)),:(<span class="pl-k">return</span> <span class="pl-c1">4</span>x<span class="pl-k">^</span><span class="pl-c1">4</span><span class="pl-k">-</span><span class="pl-c1">44</span>x<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">+</span><span class="pl-c1">61</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span><span class="pl-c1">270</span>x<span class="pl-k">-</span><span class="pl-c1">525</span>)) <span class="pl-k">|&gt;</span> horner
:(<span class="pl-k">function</span> <span class="pl-en">fun</span>(a, b)
        <span class="pl-k">return</span> ((<span class="pl-c1">4</span> <span class="pl-k">*</span> (x <span class="pl-k">-</span> <span class="pl-c1">11</span>) <span class="pl-k">*</span> x <span class="pl-k">+</span> <span class="pl-c1">61</span>) <span class="pl-k">*</span> x <span class="pl-k">+</span> <span class="pl-c1">270</span>) <span class="pl-k">*</span> x <span class="pl-k">-</span> <span class="pl-c1">525</span>
    <span class="pl-k">end</span>)</pre></div>
<p>Additionally, REDUCE switch statements can be used as macros to control evaluation of expressions.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@rounded</span> <span class="pl-c1">@factor</span> x<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">2</span>x<span class="pl-k">+</span><span class="pl-c1">1</span>
:((x <span class="pl-k">+</span> <span class="pl-c1">1.61803398875</span>) <span class="pl-k">*</span> (x <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">*</span> (x <span class="pl-k">-</span> <span class="pl-c1">0.61803398875</span>))</pre></div>
<p>Most core features have a corresponding Julia method, but language features that have not been implemented yet can also be directly evaluated with <code>rcall</code> using a synergy of julia syntax.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Expr</span>(<span class="pl-c1">:for</span>,:(i<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">34</span>),:(<span class="pl-c1">product</span>(i))) <span class="pl-k">|&gt;</span> rcall
:(<span class="pl-c1">@big_str</span> <span class="pl-s"><span class="pl-pds">"</span>295232799039604140847618609643520000000<span class="pl-pds">"</span></span>)</pre></div>
<p>The <code>squash</code> function provides a way to reduce full program blocks into simplified functions, e.g.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Expr</span>(<span class="pl-c1">:function</span>,:(<span class="pl-c1">example</span>(a,b)),<span class="pl-k">quote</span>
           z <span class="pl-k">=</span> <span class="pl-c1">3</span>
           target <span class="pl-k">=</span> z <span class="pl-k">*</span> <span class="pl-c1">:a</span> <span class="pl-k">*</span> <span class="pl-c1">:b</span>
           z <span class="pl-k">-=</span> <span class="pl-c1">1</span>
           target <span class="pl-k">+=</span> z<span class="pl-k">*</span>(<span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-c1">:a</span>)<span class="pl-k">*</span>(<span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-c1">:b</span>)
       <span class="pl-k">end</span>) <span class="pl-k">|&gt;</span> squash <span class="pl-k">|&gt;</span> factor
:(<span class="pl-k">function</span> <span class="pl-en">example</span>(a, b)
        (<span class="pl-c1">5</span>b <span class="pl-k">-</span> <span class="pl-c1">2</span>) <span class="pl-k">*</span> a <span class="pl-k">-</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> (b <span class="pl-k">-</span> <span class="pl-c1">1</span>)
    <span class="pl-k">end</span>)</pre></div>
<p>where <code>z</code> is a program variable and <code>:a</code> and <code>:b</code> are symbolic variables.</p>
<h3><a id="user-content-loading-packages" class="anchor" aria-hidden="true" href="#loading-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Loading packages</h3>
<p>Packages which come shipped with REDUCE can be loaded with the <code>load_package</code> method. For example, the <code>optimize</code> method is available with</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">load_package</span>(<span class="pl-c1">:scope</span>)

julia<span class="pl-k">&gt;</span> Algebra<span class="pl-k">.</span><span class="pl-c1">optimize</span>(:(z <span class="pl-k">=</span> a<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>b<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span><span class="pl-c1">10</span><span class="pl-k">*</span>a<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>m<span class="pl-k">^</span><span class="pl-c1">6</span><span class="pl-k">+</span>a<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>m<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">+</span><span class="pl-c1">2</span><span class="pl-k">*</span>a<span class="pl-k">*</span>b<span class="pl-k">*</span>m<span class="pl-k">^</span><span class="pl-c1">4</span><span class="pl-k">+</span><span class="pl-c1">2</span><span class="pl-k">*</span>b<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>m<span class="pl-k">^</span><span class="pl-c1">6</span><span class="pl-k">+</span>b<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>m<span class="pl-k">^</span><span class="pl-c1">2</span>))
<span class="pl-k">quote</span>
    g40 <span class="pl-k">=</span> b <span class="pl-k">*</span> a
    g44 <span class="pl-k">=</span> m <span class="pl-k">*</span> m
    g41 <span class="pl-k">=</span> g44 <span class="pl-k">*</span> b <span class="pl-k">*</span> b
    g42 <span class="pl-k">=</span> g44 <span class="pl-k">*</span> a <span class="pl-k">*</span> a
    g43 <span class="pl-k">=</span> g44 <span class="pl-k">*</span> g44
    z <span class="pl-k">=</span> g41 <span class="pl-k">+</span> g42 <span class="pl-k">+</span> g40 <span class="pl-k">*</span> (<span class="pl-c1">2</span>g43 <span class="pl-k">+</span> g40) <span class="pl-k">+</span> g43 <span class="pl-k">*</span> (<span class="pl-c1">2</span>g41 <span class="pl-k">+</span> <span class="pl-c1">10</span>g42)
<span class="pl-k">end</span></pre></div>
<p>Other packages can be loaded, but not all of them come with pre-defined Julia dispatch methods.</p>
<h3><a id="user-content-matrices" class="anchor" aria-hidden="true" href="#matrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrices</h3>
<p>Some special support for symbolic matrices has also been added to <code>Reduce.Algebra</code> methods,</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> [<span class="pl-c1">:x</span> <span class="pl-c1">1</span>; <span class="pl-c1">:y</span> <span class="pl-c1">2</span>]<span class="pl-k">^-</span><span class="pl-c1">1</span>
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Array{Any,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 :(<span class="pl-c1">2</span> <span class="pl-k">/</span> (<span class="pl-c1">2</span>x <span class="pl-k">-</span> y))   :(<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">/</span> (<span class="pl-c1">2</span>x <span class="pl-k">-</span> y))
 :(<span class="pl-k">-</span>y <span class="pl-k">/</span> (<span class="pl-c1">2</span>x <span class="pl-k">-</span> y))  :(x <span class="pl-k">/</span> (<span class="pl-c1">2</span>x <span class="pl-k">-</span> y))</pre></div>
<p>The <code>jacobian</code> method has been added to the <a href="https://github.com/JuliaReducePkg/ReduceLinAlg.jl">ReduceLinAlg</a> package, which is dedicated to the LINALG extra package included with Reduce binaries.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> ReduceLinAlg

julia<span class="pl-k">&gt;</span> eqns <span class="pl-k">=</span> [<span class="pl-c1">:x1</span><span class="pl-k">-</span><span class="pl-c1">:x2</span>, <span class="pl-c1">:x1</span><span class="pl-k">+</span><span class="pl-c1">:x2</span><span class="pl-k">-</span><span class="pl-c1">:x3</span><span class="pl-k">+</span><span class="pl-c1">:x6t</span>, <span class="pl-c1">:x1</span><span class="pl-k">+</span><span class="pl-c1">:x3t</span><span class="pl-k">-</span><span class="pl-c1">:x4</span>, <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">:x1tt</span><span class="pl-k">+</span><span class="pl-c1">:x2tt</span><span class="pl-k">+</span><span class="pl-c1">:x3tt</span><span class="pl-k">+</span><span class="pl-c1">:x4t</span><span class="pl-k">+</span><span class="pl-c1">:x6ttt</span>, <span class="pl-c1">3</span><span class="pl-k">*</span><span class="pl-c1">:x1tt</span><span class="pl-k">+</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">:x2tt</span><span class="pl-k">+</span><span class="pl-c1">:x5</span><span class="pl-k">+</span><span class="pl-c1">0.1</span><span class="pl-k">*</span><span class="pl-c1">:x8</span>, <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">:x6</span><span class="pl-k">+</span><span class="pl-c1">:x7</span>, <span class="pl-c1">3</span><span class="pl-k">*</span><span class="pl-c1">:x6</span><span class="pl-k">+</span><span class="pl-c1">4</span><span class="pl-k">*</span><span class="pl-c1">:x7</span>, <span class="pl-c1">:x8</span><span class="pl-k">-</span><span class="pl-c1">sin</span>(<span class="pl-c1">:x8</span>)]
<span class="pl-c1">8</span><span class="pl-k">-</span>element Array{Expr,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 :(x1 <span class="pl-k">-</span> x2)
 :(x1 <span class="pl-k">-</span> ((x3 <span class="pl-k">-</span> x6t) <span class="pl-k">-</span> x2))
 :((x3t <span class="pl-k">-</span> x4) <span class="pl-k">+</span> x1)
 :(x4t <span class="pl-k">+</span> x6ttt <span class="pl-k">+</span> x3tt <span class="pl-k">+</span> x2tt <span class="pl-k">+</span> <span class="pl-c1">2</span>x1tt)
 :((<span class="pl-c1">10</span>x5 <span class="pl-k">+</span> x8 <span class="pl-k">+</span> <span class="pl-c1">20</span>x2tt <span class="pl-k">+</span> <span class="pl-c1">30</span>x1tt) <span class="pl-k">//</span> <span class="pl-c1">10</span>)
 :(<span class="pl-c1">2</span>x6 <span class="pl-k">+</span> x7)
 :(<span class="pl-c1">3</span>x6 <span class="pl-k">+</span> <span class="pl-c1">4</span>x7)
 :(x8 <span class="pl-k">-</span> <span class="pl-c1">sin</span>(x8))

julia<span class="pl-k">&gt;</span> vars <span class="pl-k">=</span> [<span class="pl-c1">:x1</span>, <span class="pl-c1">:x2</span>, <span class="pl-c1">:x3</span>, <span class="pl-c1">:x4</span>, <span class="pl-c1">:x6</span>, <span class="pl-c1">:x7</span>, <span class="pl-c1">:x1t</span>, <span class="pl-c1">:x2t</span>, <span class="pl-c1">:x3t</span>, <span class="pl-c1">:x6t</span>, <span class="pl-c1">:x7t</span>, <span class="pl-c1">:x6tt</span>, <span class="pl-c1">:x7tt</span>];

julia<span class="pl-k">&gt;</span> <span class="pl-c1">jacobian</span>(eqns, vars) <span class="pl-k">|&gt;</span> Reduce<span class="pl-k">.</span>mat
<span class="pl-c1">8</span><span class="pl-k">×</span><span class="pl-c1">13</span> Array{Any,<span class="pl-c1">2</span>}<span class="pl-k">:</span>
 <span class="pl-c1">1</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">1</span>   <span class="pl-c1">1</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>   <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">1</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">1</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-k">-</span><span class="pl-c1">1</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">1</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-c1">2</span>  <span class="pl-c1">1</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-c1">3</span>  <span class="pl-c1">4</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>
 <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>   <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span>  <span class="pl-c1">0</span></pre></div>
<p>The package also provides a demonstration of how additional <code>Reduce</code> methods can be imported into Julia.</p>
<h3><a id="user-content-output-mode" class="anchor" aria-hidden="true" href="#output-mode"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Output mode</h3>
<p>Various output modes are supported. While in the REPL, the default <code>nat</code> output mode will be displayed for <code>RExpr</code> objects.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> :(<span class="pl-c1">sin</span>(x<span class="pl-k">*</span>im) <span class="pl-k">+</span> <span class="pl-c1">cos</span>(y<span class="pl-k">*</span>MathConstants<span class="pl-k">.</span>φ)) <span class="pl-k">|&gt;</span> RExpr

     (<span class="pl-c1">sqrt</span>(<span class="pl-c1">5</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span>)<span class="pl-k">*</span>y
<span class="pl-c1">cos</span>(<span class="pl-k">-----------------</span>) <span class="pl-k">+</span> <span class="pl-c1">sinh</span>(x)<span class="pl-k">*</span>i
            <span class="pl-c1">2</span></pre></div>
<p>This same output can also be printed to the screen by calling <code>print(nat(r))</code> method.</p>
<p>It is possible to direclty convert a julia expression object to LaTeX code using the <code>latex</code> method.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">print</span>(<span class="pl-c1">@latex</span> <span class="pl-c1">sin</span>(x) <span class="pl-k">+</span> <span class="pl-c1">cos</span>(y<span class="pl-k">*</span>MathConstants<span class="pl-k">.</span>φ))
<span class="pl-k">\</span><span class="pl-k">begin</span>{displaymath}
<span class="pl-k">\</span>cos <span class="pl-k">\</span><span class="pl-c1">left</span>(<span class="pl-k">\</span><span class="pl-c1">left</span>(<span class="pl-k">\</span><span class="pl-c1">left</span>(<span class="pl-k">\</span>sqrt {<span class="pl-c1">5</span>}<span class="pl-k">+</span><span class="pl-c1">1</span><span class="pl-k">\</span>right) y<span class="pl-k">\</span>right)<span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">\</span>right)<span class="pl-k">+\</span>sin <span class="pl-k">\</span>,x
<span class="pl-k">\</span><span class="pl-k">end</span>{displaymath}</pre></div>
<p>Internally, this command essentially expands to <code>rcall(:(sin(x) + cos(y*MathConstants.φ)),:latex) |&gt; print</code>, which is equivalent.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/b71cbaca433fad6b077dd350c5efb63179c7a48a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543636f732673706163653b2535436c656674282535436c656674282535436c65667428253543737172742673706163653b253742352537442b312535437269676874292673706163653b792535437269676874292f322535437269676874292b25354373696e2673706163653b78"><img src="https://camo.githubusercontent.com/b71cbaca433fad6b077dd350c5efb63179c7a48a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543636f732673706163653b2535436c656674282535436c656674282535436c65667428253543737172742673706163653b253742352537442b312535437269676874292673706163653b792535437269676874292f322535437269676874292b25354373696e2673706163653b78" alt="latex-equation" data-canonical-src="https://latex.codecogs.com/svg.latex?%5Ccos&amp;space;%5Cleft(%5Cleft(%5Cleft(%5Csqrt&amp;space;%7B5%7D+1%5Cright)&amp;space;y%5Cright)/2%5Cright)+%5Csin&amp;space;x" style="max-width:100%;"></a></p>
<p>In <code>IJulia</code> the display output of <code>RExpr</code> objects will be rendered LaTeX with the <code>rlfi</code> REDUCE package in <code>latex</code> mode.</p>
<h3><a id="user-content-repl-interface" class="anchor" aria-hidden="true" href="#repl-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>REPL interface</h3>
<p>Similar to <kbd>?</kbd> help and <kbd>;</kbd> shell modes in Julia, <code>Reduce</code> provides a <code>reduce&gt;</code> REPL mode by pressing <kbd>shift</kbd>+<kbd>]</kbd> as the first character in the julia terminal prompt. The output is in <code>nat</code> mode.</p>
<div class="highlight highlight-source-julia"><pre>reduce<span class="pl-k">&gt;</span> <span class="pl-c1">df</span>(<span class="pl-c1">atan</span>(golden_ratio<span class="pl-k">*</span>x),x);

          <span class="pl-c1">2</span>              <span class="pl-c1">2</span>
 <span class="pl-c1">sqrt</span>(<span class="pl-c1">5</span>)<span class="pl-k">*</span>x  <span class="pl-k">+</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">5</span>) <span class="pl-k">-</span> x  <span class="pl-k">+</span> <span class="pl-c1">1</span>
<span class="pl-k">-------------------------------</span>
           <span class="pl-c1">4</span>      <span class="pl-c1">2</span>
       <span class="pl-c1">2</span><span class="pl-k">*</span>(x  <span class="pl-k">+</span> <span class="pl-c1">3</span><span class="pl-k">*</span>x  <span class="pl-k">+</span> <span class="pl-c1">1</span>)</pre></div>
<h2><a id="user-content-troubleshooting" class="anchor" aria-hidden="true" href="#troubleshooting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Troubleshooting</h2>
<p>If the <code>reduce&gt;</code> REPL is not appearing when <code>}</code> is pressed or the Reduce pipe is broken, the session can be restored by simply calling <code>Reduce.Reset()</code>, without requiring a restart of <code>julia</code> or reloading the package. This kills the currently running Reduce session and then re-initializes it for new use.</p>
<p>Otherwise, questions can be asked on gitter/discourse or submit your issue or pull-request if you require additional features or noticed some unusual edge-case behavior.</p>
<h3><a id="user-content-abstracttensors-interoperability" class="anchor" aria-hidden="true" href="#abstracttensors-interoperability"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>AbstractTensors interoperability</h3>
<p>By importing the <a href="https://github.com/chakravala/AbstractTensors.jl">AbstractTensors.jl</a> module, the <code>Reduce</code> is able to correctly bypass operations on <code>TensorAlgebra</code> elements to the correct methods within the scope of the <code>Reduce.Algebra</code> module.
This requires no additional overhead for the <a href="https://github.com/chakravala/Grassmann.jl">Grassmann.jl</a> or <code>Reduce</code> packages, because the <code>AbstractTensors</code> interoperability interface enables separate precompilation of both.</p>
<h2><a id="user-content-background" class="anchor" aria-hidden="true" href="#background"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Background</h2>
<p>The <code>Reduce</code> package currently provides a robust interface to directly use the CSL version of REDUCE within the Julia language and the REPL. This is achieved by interfacing the abstract syntax tree of <code>Expr</code> objects with the parser generator for <code>RExpr</code> objects and then using an <code>IOBuffer</code> to communicate with <code>redpsl</code>.</p>
<blockquote>
<p>REDUCE is a system for doing scalar, vector and matrix algebra by computer, which also supports arbitrary precision numerical approximation and interfaces to gnuplot to provide graphics. It can be used interactively for simple calculations but also provides a full programming language, with a syntax similar to other modern programming languages.
REDUCE has a long and distinguished place in the history of computer algebra systems. Other systems that address some of the same issues but sometimes with rather different emphasis are Axiom, Macsyma (Maxima), Maple and Mathematica.
REDUCE is implemented in Lisp (as are Axiom and Macsyma), but this is completely hidden from the casual user. REDUCE primarily runs on either Portable Standard Lisp (PSL) or Codemist Standard Lisp (CSL), both of which are included in the SourceForge distribution. PSL is long-established and compiles to machine code, whereas CSL is newer and compiles to byte code. Hence, PSL may be faster but CSL may be available on a wider range of platforms.</p>
</blockquote>
<p>Releases of <code>Reduce.jl</code> enable the general application of various REDUCE functionality and packages to manipulate the Julia language to simplify and compute new program expressions at run-time. Intended for uses where a symbolic pre-computation is required for numerical algorithm code generation.</p>
<blockquote>
<p>Julia is a high-level, high-performance dynamic programming language for numerical computing. It provides a sophisticated compiler, distributed parallel execution, numerical accuracy, and an extensive mathematical function library. Julia’s Base library, largely written in Julia itself, also integrates mature, best-of-breed open source C and Fortran libraries for linear algebra, random number generation, signal processing, and string processing.
The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of abstract syntax trees.</p>
</blockquote>
</article></div>