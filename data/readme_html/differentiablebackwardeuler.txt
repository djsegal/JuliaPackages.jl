<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-differentiablebackwardeulerjl-automatically-differentiating-the-backward-euler-method" class="anchor" aria-hidden="true" href="#differentiablebackwardeulerjl-automatically-differentiating-the-backward-euler-method"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DifferentiableBackwardEuler.jl: Automatically differentiating the backward Euler method</h1>
<h2 dir="auto"><a id="user-content-description" class="anchor" aria-hidden="true" href="#description"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Description</h2>
<p dir="auto">DifferentiableBackwardEuler.jl is a <a href="http://julialang.org/" rel="nofollow">Julia</a> module that automatically differentiates the <a href="https://en.wikipedia.org/wiki/Backward_Euler_method" rel="nofollow">backward Euler method</a>. It is used in the <a href="https://github.com/OrchardLANL/DPFEHM.jl">DPFEHM</a> subsurface flow simulator. Here are a couple illustartive examples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import DifferentiableBackwardEuler
import SparseArrays
import Zygote

f(u, p, t) = f_u(u, p, t) * u
f_u(u, p, t) = SparseArrays.spdiagm(0=&gt;p)
f_p(u, p, t) = SparseArrays.spdiagm(0=&gt;u)
f_t(u, p, t) = zero(u)

numsteps = 10 ^ 2
n = 2
u0 = ones(n)
p = collect(1.0:n)
ts = collect(range(0, 1e0; length=numsteps))
g(p, u0) = sum(DifferentiableBackwardEuler.steps(u0, f, f_u, f_p, f_t, p, ts)[:, end])
g(p, u0)#≈sum(exp.(p * ts[end])) --  integrates the ODE using the backward Euler method using the ts to define the time steps
#we can compute the gradient of g using Zygote.gradient
dgdp_zygote = Zygote.gradient((p, u0)-&gt;g(p, u0), p, u0)

#you can also solve the ODE specifying only the initial and final times, and this falls back to DifferentialEquations.jl's ImplicitEuler() method to do adaptive time-stepping
t0 = 0.0
tfinal = 1e0
g(p, u0) = sum(DifferentiableBackwardEuler.steps(u0, f, f_u, f_p, f_t, p, t0, tfinal; reltol=1e-4)[:, end])#the kwargs get passed to DifferentialEquations.solve(...;kwargs...)
g(p, u0)#≈sum(exp.(p * tfinal)) --  integrates the ODE using the backward Euler method from t0 to tfinal
#again, we can compute the gradient of g using Zygote.gradient
dgdp_zygote = Zygote.gradient((p, u0)-&gt;g(p, u0), p, u0)"><pre><span class="pl-k">import</span> DifferentiableBackwardEuler
<span class="pl-k">import</span> SparseArrays
<span class="pl-k">import</span> Zygote

<span class="pl-en">f</span>(u, p, t) <span class="pl-k">=</span> <span class="pl-c1">f_u</span>(u, p, t) <span class="pl-k">*</span> u
<span class="pl-en">f_u</span>(u, p, t) <span class="pl-k">=</span> SparseArrays<span class="pl-k">.</span><span class="pl-c1">spdiagm</span>(<span class="pl-c1">0</span><span class="pl-k">=&gt;</span>p)
<span class="pl-en">f_p</span>(u, p, t) <span class="pl-k">=</span> SparseArrays<span class="pl-k">.</span><span class="pl-c1">spdiagm</span>(<span class="pl-c1">0</span><span class="pl-k">=&gt;</span>u)
<span class="pl-en">f_t</span>(u, p, t) <span class="pl-k">=</span> <span class="pl-c1">zero</span>(u)

numsteps <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">^</span> <span class="pl-c1">2</span>
n <span class="pl-k">=</span> <span class="pl-c1">2</span>
u0 <span class="pl-k">=</span> <span class="pl-c1">ones</span>(n)
p <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">1.0</span><span class="pl-k">:</span>n)
ts <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1e0</span>; length<span class="pl-k">=</span>numsteps))
<span class="pl-en">g</span>(p, u0) <span class="pl-k">=</span> <span class="pl-c1">sum</span>(DifferentiableBackwardEuler<span class="pl-k">.</span><span class="pl-c1">steps</span>(u0, f, f_u, f_p, f_t, p, ts)[:, <span class="pl-c1">end</span>])
<span class="pl-c1">g</span>(p, u0)<span class="pl-c"><span class="pl-c">#</span>≈sum(exp.(p * ts[end])) --  integrates the ODE using the backward Euler method using the ts to define the time steps</span>
<span class="pl-c"><span class="pl-c">#</span>we can compute the gradient of g using Zygote.gradient</span>
dgdp_zygote <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">gradient</span>((p, u0)<span class="pl-k">-&gt;</span><span class="pl-c1">g</span>(p, u0), p, u0)

<span class="pl-c"><span class="pl-c">#</span>you can also solve the ODE specifying only the initial and final times, and this falls back to DifferentialEquations.jl's ImplicitEuler() method to do adaptive time-stepping</span>
t0 <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
tfinal <span class="pl-k">=</span> <span class="pl-c1">1e0</span>
<span class="pl-en">g</span>(p, u0) <span class="pl-k">=</span> <span class="pl-c1">sum</span>(DifferentiableBackwardEuler<span class="pl-k">.</span><span class="pl-c1">steps</span>(u0, f, f_u, f_p, f_t, p, t0, tfinal; reltol<span class="pl-k">=</span><span class="pl-c1">1e-4</span>)[:, <span class="pl-c1">end</span>])<span class="pl-c"><span class="pl-c">#</span>the kwargs get passed to DifferentialEquations.solve(...;kwargs...)</span>
<span class="pl-c1">g</span>(p, u0)<span class="pl-c"><span class="pl-c">#</span>≈sum(exp.(p * tfinal)) --  integrates the ODE using the backward Euler method from t0 to tfinal</span>
<span class="pl-c"><span class="pl-c">#</span>again, we can compute the gradient of g using Zygote.gradient</span>
dgdp_zygote <span class="pl-k">=</span> Zygote<span class="pl-k">.</span><span class="pl-c1">gradient</span>((p, u0)<span class="pl-k">-&gt;</span><span class="pl-c1">g</span>(p, u0), p, u0)</pre></div>
<h2 dir="auto"><a id="user-content-license" class="anchor" aria-hidden="true" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>License</h2>
<p dir="auto">DifferentiableBackwardEuler is provided under a BSD style license. See LICENSE.md file for the full text.</p>
<p dir="auto">This package is part of the Orchard suite, known internally as C20086 Orchard.</p>
<h2 dir="auto"><a id="user-content-author" class="anchor" aria-hidden="true" href="#author"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Author</h2>
<p dir="auto">Daniel O'Malley, <a href="mailto:omalled@lanl.gov">omalled@lanl.gov</a></p>
</article></div>