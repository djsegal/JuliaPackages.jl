<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-compiletraces" class="anchor" aria-hidden="true" href="#compiletraces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>CompileTraces</h1>
<p dir="auto"><a href="https://github.com/serenity4/CompileTraces.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/serenity4/CompileTraces.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/CompileTraces/FKKWd" rel="nofollow"><img src="https://camo.githubusercontent.com/941a337a94bb8e48c3cc397dc7b5c80d9ada8dca783e4d25d78314dd9ce9a6e0/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f436f6d70696c655472616365732f706b676576616c2e737667" alt="pkgeval" data-canonical-src="https://juliahub.com/docs/CompileTraces/pkgeval.svg" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/serenity4/CompileTraces.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/6d811e26b2c4ff4fb6493a720c0a11a90dd86123e4b55916a876104e031279a4/68747470733a2f2f636f6465636f762e696f2f67682f736572656e697479342f436f6d70696c655472616365732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/serenity4/CompileTraces.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/CompileTraces/FKKWd?t=2" rel="nofollow"><img src="https://camo.githubusercontent.com/dbd0d52059cf775086092c99950067ed4b87151b89710e2015d611f251c588f1/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f436f6d70696c655472616365732f646570732e737667" alt="deps" data-canonical-src="https://juliahub.com/docs/CompileTraces/deps.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Compile traces recorded in a trace file with a unique macro, <code>@compile_traces</code> (or its function counterpart, <code>compile_traces</code>).</p>
<p dir="auto">The core functionality was in part extracted from <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler.jl</a> internals. The package was designed to be as lightweight as possible:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @time_imports using CompileTraces
      11.5 ms  CompileTraces"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@time_imports</span> <span class="pl-k">using</span> CompileTraces
      <span class="pl-c1">11.5</span> ms  CompileTraces</pre></div>
<h2 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic usage</h2>
<p dir="auto">Generate compilation traces by executing code in a Julia process started with the <code>--trace-compile</code> option. For example, you can run a script which triggers compilation paths that you would like to generate traces for.</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia --trace-compile=/tmp/compiled.jl script.jl"><pre>julia --trace-compile=/tmp/compiled.jl script.jl</pre></div>
<p dir="auto">For example, <code>script.jl</code> could be:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Test
using LinearAlgebra

set = @testset &quot;Test set&quot; begin end
display(set)

det(ones(4, 4)) isa Float64"><pre><span class="pl-k">using</span> Test
<span class="pl-k">using</span> LinearAlgebra

set <span class="pl-k">=</span> <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>Test set<span class="pl-pds">"</span></span> <span class="pl-k">begin</span> <span class="pl-k">end</span>
<span class="pl-c1">display</span>(set)

<span class="pl-c1">det</span>(<span class="pl-c1">ones</span>(<span class="pl-c1">4</span>, <span class="pl-c1">4</span>)) <span class="pl-k">isa</span> Float64</pre></div>
<p dir="auto">Then, in a new session, use this file along with any potential package dependencies that are required in order to compile the code:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CompileTraces
using Test, LinearAlgebra # required for precompile statements to succeed

@compile_traces &quot;/tmp/compiled.jl&quot; warn = true
# Or, equivalently:
# compile_traces(@__MODULE__, &quot;/tmp/compiled.jl&quot;; warn = true)"><pre><span class="pl-k">using</span> CompileTraces
<span class="pl-k">using</span> Test, LinearAlgebra <span class="pl-c"><span class="pl-c">#</span> required for precompile statements to succeed</span>

<span class="pl-c1">@compile_traces</span> <span class="pl-s"><span class="pl-pds">"</span>/tmp/compiled.jl<span class="pl-pds">"</span></span> warn <span class="pl-k">=</span> <span class="pl-c1">true</span>
<span class="pl-c"><span class="pl-c">#</span> Or, equivalently:</span>
<span class="pl-c"><span class="pl-c">#</span> compile_traces(@__MODULE__, "/tmp/compiled.jl"; warn = true)</span></pre></div>
<p dir="auto">For convenience, <code>compile_traces</code> also accepts a list of trace files as first argument, if you want to aggregate multiple traces. Trace files must however have been written with the same format; see the documentation for <code>compile_traces</code> with <code>julia&gt; ?compile_traces</code> for more information.</p>
<p dir="auto">If used during precompilation, the first argument to <code>compile_traces</code> <em>must be the current module</em>, as it is then forbidden to dynamically evaluate code in other modules. This will be automatically the case if you use the macro equivalent <code>@compile_traces</code>.</p>
<p dir="auto">Trace compilation may be disabled on a per-package basis by setting the preference <code>compile_traces</code> to <code>false</code>.</p>
<h3 dir="auto"><a id="user-content-usage-with-snoopcompile" class="anchor" aria-hidden="true" href="#usage-with-snoopcompile"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage with SnoopCompile</h3>
<p dir="auto">If trace files were obtained using <code>SnoopCompile.parcel</code> and <code>SnoopCompile.write</code>, they must be evaluated in scope of the intended package. For a trace file written at <code>MyPackage/src/precompile_statements.jl</code> for a given package <code>MyPackage</code>, use the option <code>inline = true</code> to execute the precompile statements in the intended scope:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module MyPackage

# Package code.
# ...

# Compile traces for precompilation.
using CompileTraces
# Note: only use `inline = true` if the traces come from `SnoopCompile.write`.
@compile_traces &quot;precompile_directives.jl&quot; inline = true

end # module"><pre><span class="pl-k">module</span> MyPackage

<span class="pl-c"><span class="pl-c">#</span> Package code.</span>
<span class="pl-c"><span class="pl-c">#</span> ...</span>

<span class="pl-c"><span class="pl-c">#</span> Compile traces for precompilation.</span>
<span class="pl-k">using</span> CompileTraces
<span class="pl-c"><span class="pl-c">#</span> Note: only use `inline = true` if the traces come from `SnoopCompile.write`.</span>
<span class="pl-c1">@compile_traces</span> <span class="pl-s"><span class="pl-pds">"</span>precompile_directives.jl<span class="pl-pds">"</span></span> inline <span class="pl-k">=</span> <span class="pl-c1">true</span>

<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> module</span></pre></div>
<p dir="auto">Note that the term "precompile" in "precompile statements" is not related to "precompilation" as in "module precompilation". <code>Base.precompile(signature)</code> is a way to trigger compilation for a given method signature early without executing it, hence the prefix.</p>
<h2 dir="auto"><a id="user-content-use-cases" class="anchor" aria-hidden="true" href="#use-cases"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Use cases</h2>
<p dir="auto">It can be useful to emit traces in a Julia session, compile them in a new session and execute a workload to quickly check that a set of traces completely cover that particular workload.</p>
<p dir="auto">The end goal for such traces may be to use them in conjunction with <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler.jl</a>, to reduce latency using system images. In this case, being able to check traces manually without having to build the system image will lead to faster iterations.</p>
<p dir="auto">Another intended use case is to generate traces from a script or a test suite, and then compile these traces as part of a package precompilation block. This is very similar to <a href="https://github.com/JuliaLang/PrecompileTools.jl">PrecompileTools.jl</a>, but without actually having to execute code. This can be useful in environments that require access to devices such as GPUs which may need advanced driver functionalities to be able to trigger certain code paths, or workloads that require access to external running services such as a database which might be only occasionally available or filled with appropriate data to cover all the code paths in a codebase.</p>
<p dir="auto">For example, executing a workload involving GPU hardware ray-tracing will require a modern GPU with recent drivers, and any strategy (even clever) to conditionally include code based on available GPU features will be a likely point of failure. Using trace files, it is a win-win for both the user, who will have a more stable experience, and the developer who will be free to execute a highly specialized workload in a controlled environment to extend compilation coverage to a maximum.</p>
<p dir="auto">In the context of precompilation, it may be that some code which would otherwise be desired to run with <code>PrecompileTools.@compile_workload</code> cannot be executed because of limits in place during the precompilation process. One standard example is the creation of a module with <code>m = Module()</code> and evaluating expressions into it dynamically, using <code>Core.eval(m, ex)</code> or <code>m.eval(ex)</code>; this is explicitly forbidden during precompilation, and the only way to precompile code paths involving such constructs is to manually trigger method compilation without execution, which is the purpose of this package.</p>
</article></div>