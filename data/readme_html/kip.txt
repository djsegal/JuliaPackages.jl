<div id="readme" class="md" data-path="Readme.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-kip" class="anchor" aria-hidden="true" href="#kip"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kip</h1>
<p>Kip is an alternative module system for Julia with the goal of being more robust and easier to use. With Kip <strong>packages don't have names</strong>. Instead modules are identified by the file they are in. So you can have several versions of the same package without them overwriting each other. Also it favours putting <strong>dependency info inline</strong> rather than in a REQUIRE file. This reduces indirection and works well at the REPL. The final key difference is that it <strong>installs dependencies at runtime</strong>. So you never have to think about if a package is installed or not. Though you should run <code>Kip.update()</code> occasionally to update Kip's local cache of packages which are just plain Git repositories.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<div class="highlight highlight-source-julia"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">clone</span>(<span class="pl-s"><span class="pl-pds">"</span>https://github.com/jkroso/Kip.jl.git<span class="pl-pds">"</span></span>)</pre></div>
<p>Then add this code to your ~/.julia/config/startup.jl</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">import</span> Pkg
<span class="pl-k">using</span> Kip
<span class="pl-c1">haskey</span>(ENV, <span class="pl-s"><span class="pl-pds">"</span>ATOM_HOME<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">@use</span> <span class="pl-s"><span class="pl-pds">"</span>github.com/jkroso/Rutherford.jl<span class="pl-pds">"</span></span></pre></div>
<p>Now it's like Kip was built into Julia. It will be available at the REPL and in any files you run</p>
<h2><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>API</h2>
<p>Kip's API consists of just one macro to import modules. And one function to update all the 3rd party repositories you use</p>
<h3><a id="user-content-usepkgstring-importssymbol" class="anchor" aria-hidden="true" href="#usepkgstring-importssymbol"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>@use(pkg::String, imports::Symbol...)</code></h3>
<p><code>@use</code> takes a path to a package and a list of symbols to import from that package. If you want to use a different name locally for any of these symbols your can pass a <code>Pair</code> of symbols like <code>@use "./thing" a =&gt; b</code>. This will import <code>a</code> from the local package <code>"./thing"</code> and make it available as <code>b</code>.</p>
<p>Now I just need to explain the syntax of the path parameter. In this example I'm using a relative path which is resolved relative to the REPL's <code>pwd()</code>. Or if I was editing a file it would be the <code>dirname()</code> of that file. This should be familiar for people who use Unix machines. Now, assuming we are at the REPL, what <code>@use</code> does under the hood is check for a file called <code>joinpath(pwd(), "./thing")</code>. If it exists it will load it. Otherwise it tries a few other paths <code>joinpath(pwd(), "./thing.jl")</code>, <code>joinpath(pwd(), "./thing/main.jl")</code>, and <code>joinpath(pwd(), "./thing/src/thing.jl")</code>. This just enables you to save a bit of typing if you feel like it.</p>
<p>There are a couple other types of paths you can pass to <code>@use</code>:</p>
<ul>
<li>
<p>Absolute: <code>@use "/Users/jkroso/thing"</code></p>
</li>
<li>
<p>Github: <code>@use "github.com/jkroso/thing"</code></p>
<p>This syntax is actually pretty complex since it also needs to enable you to specify which ref (tag/commit/branch) you want to use. Here I haven't specified a ref so it uses the latest commit. If I want to specify one I put it after the reponame prefixed with an "@". e.g: <code>@use "github.com/jkroso/thing@1"</code> This looks like a semver query so it will be run over all tags in the repo and the latest tag that matches the query is the one that gets used. Finally, if the module we want from the repository isn't called "main.jl", or "src/$(reponame).jl" then we will need to specify its path. e.g: <code>@use "github.com/jkroso/thing@1/thing"</code>. And path completion will also be applied just like with relative and absolute paths.</p>
</li>
</ul>
<h3><a id="user-content-update" class="anchor" aria-hidden="true" href="#update"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>update()</code></h3>
<p>Runs <code>git fetch</code> on all the repositories you have <code>@use</code>'d in the past. So that next time you <code>@use</code> them you will get the latest version</p>
<h3><a id="user-content-native-julia-module-support" class="anchor" aria-hidden="true" href="#native-julia-module-support"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Native Julia module support</h3>
<p>If the module you require is registered in <code>Pkg.dir("METADATA")</code> then it will be installed and loaded using the built in module system. So  <code>@use "github.com/johnmyleswhite/Benchmark.jl" compare</code> is exactly equivalent to <code>import Benchmark: compare</code>. This reduces the likelihood of ending up with duplicate modules being loaded within <code>Kip</code> and <code>Pkg</code>'s respective caches. Especially while Julia doesn't provide any good way to load non-registered modules.</p>
<p>Kip also supports non-registered modules by looking at the contents of the file you are requiring to see if the only thing in it is a <code>Module</code>. When that's the case it will unbox it from the wrapper Kip normally uses. If Julia ever provides good support for non-registered modules itself then Kip will <code>Pkg.clone</code> the module and <code>import</code> it to match its handling of registered modules.</p>
<h2><a id="user-content-running-arbitrary-code-on-another-machine" class="anchor" aria-hidden="true" href="#running-arbitrary-code-on-another-machine"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Running arbitrary code on another machine</h2>
<p>Since dependencies are declared in the code you can pipe arbitrary code into a machine running Julia and have the results piped back. Or on the other hand you could <code>curl $url | julia</code> to run remote code on your local machine. Here is an example of running some code through a docker instance (BTW so long as you have docker installed you can run this)</p>
<div class="highlight highlight-source-shell"><pre>$ <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">'</span>@use "github.com/coiljl/URI" encode; encode("1 &lt;= 2")<span class="pl-pds">'</span></span> <span class="pl-k">|</span> docker run -i jkroso/kip.jl
<span class="pl-s"><span class="pl-pds">"</span>1%20%3C=%202<span class="pl-pds">"</span></span></pre></div>
<h2><a id="user-content-example-projects" class="anchor" aria-hidden="true" href="#example-projects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example projects</h2>
<h5><a id="user-content-jest" class="anchor" aria-hidden="true" href="#jest"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><a href="//github.com/jkroso/Jest.jl">Jest</a></h5>
<p>This demonstrates mixed use of native modules and Kip modules. It also shows how nice Kip is for writing CLI programs. Since its dependencies will be installed at runtime Jest's CLI script only needs to be downloaded and put in the user's $PATH.</p>
<h5><a id="user-content-uri-parser-benchmark" class="anchor" aria-hidden="true" href="#uri-parser-benchmark"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><a href="//github.com/coiljl/URI/blob/master/Readme.ipynb">URI parser benchmark</a></h5>
<p>Here Kip enabled me to put my benchmark code directly in this projects Readme.ipynb file since I didn't need to worry about installing the dependencies.</p>
<h2><a id="user-content-prospective-features" class="anchor" aria-hidden="true" href="#prospective-features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prospective features</h2>
<h5><a id="user-content-automatic-reloading-of-modules" class="anchor" aria-hidden="true" href="#automatic-reloading-of-modules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Automatic reloading of modules</h5>
<p>While at the REPL it could listen to changes on the modules you require and automatically reload them into the workspace.</p>
<h5><a id="user-content-dependency-tree-linting" class="anchor" aria-hidden="true" href="#dependency-tree-linting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dependency tree linting</h5>
<p>Kips ability to load multiple versions of a module at the same time is a double edged sword. The upside is package developers can make breaking changes to their API's without instantly breaking all their dependent projects. The downside is that if you and your dependencies have dependencies in common and they load different versions of these modules to you then you might run into issues if you passing Type instances back and fourth between your direct dependencies. This is a subtle problem which can be hard to recognise. Especially if you not aware that it can happen. A good solution to this might be to use a static analysis tool to check your dependency tree for potential instances of this problem. It would make sense to make it part of a <a href="//github.com/tonyhffong/Lint.jl">linting tool</a>.</p>
</article></div>