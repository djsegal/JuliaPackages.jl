<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-smolyakapproxjl" class="anchor" aria-hidden="true" href="#smolyakapproxjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SmolyakApprox.jl</h1>
<h1 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h1>
<p dir="auto">This package implements Smolyak's method for approximating multivariate continuous functions.  Two different types of interpolation schemes are allowed: Chebyshev polynomials and piecewise linear.</p>
<p dir="auto">To install this package you need to type in the REPL</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(&quot;SmolyakApprox&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>SmolyakApprox<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Then the package can be used by typing</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SmolyakApprox"><pre><span class="pl-k">using</span> SmolyakApprox</pre></div>
<h2 dir="auto"><a id="user-content-chebyshev-polynomials" class="anchor" aria-hidden="true" href="#chebyshev-polynomials"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Chebyshev polynomials</h2>
<p dir="auto">The nodes are computed using Chebyshev-Gauss-Lobatto, with the approximation grid and the multi-index computed by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="grid, multi_ind = smolyak_grid(chebyshev_gauss_lobatto,d,mu,domain)"><pre>grid, multi_ind <span class="pl-k">=</span> <span class="pl-c1">smolyak_grid</span>(chebyshev_gauss_lobatto,d,mu,domain)</pre></div>
<p dir="auto">where <code>d</code> is the dimension of the function, <code>mu</code> is the layer or approximation order, and domain is a 2d-array (2xd) containing the upper and lower bound on each variable.  If domain is not provided, then it is assumed that the variables reside on the [-1,1] interval.  If <code>mu</code> is an integer, then an isotropic grid is computed whereas if <code>mu</code> is a 1d array of integers with length <code>d</code>, then an anisotropic grid is computed.  Because the chebyshev_gauss_lobatto points are the same as the Chebyshev extrema points you can use <code>chebyshev_extrema</code> in place of <code>chebyshev_gauss_lobatto</code>.</p>
<p dir="auto">With the grid and multi-index in hand, we can compute the weights, or coefficients in the approximation, according to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="weights = smolyak_weights(y,grid,multi_ind,domain)"><pre>weights <span class="pl-k">=</span> <span class="pl-c1">smolyak_weights</span>(y,grid,multi_ind,domain)</pre></div>
<p dir="auto">where <code>y</code> is a 1d-array containing the evaluations at each grid point of the function being approximated.  Computation of the weights can be made more efficient by computing the inverse interpolation matrix (this generally needs to be done only once, outside any loops)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="inv_interp_mat = smolyak_inverse_interpolation_matrix(grid,multi_ind,domain)"><pre>inv_interp_mat <span class="pl-k">=</span> <span class="pl-c1">smolyak_inverse_interpolation_matrix</span>(grid,multi_ind,domain)</pre></div>
<p dir="auto">with the weights now computed through</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="weights = smolyak_weights(y,inv_interp_mat)"><pre>weights <span class="pl-k">=</span> <span class="pl-c1">smolyak_weights</span>(y,inv_interp_mat)</pre></div>
<p dir="auto">Lastly, we can evaluate the Smolyak approximation of the function at any point in the domain by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y_hat = smolyak_evaluate(weights,point,multi_ind,domain)"><pre>y_hat <span class="pl-k">=</span> <span class="pl-c1">smolyak_evaluate</span>(weights,point,multi_ind,domain)</pre></div>
<p dir="auto">where <code>point</code> (a 1d-array) is the point in the domain where the approximation is to be evaluated.</p>
<h2 dir="auto"><a id="user-content-piecewise-linear" class="anchor" aria-hidden="true" href="#piecewise-linear"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Piecewise linear</h2>
<p dir="auto">For piecewise linear approximation equidistant nodes are used where the number of nodes is determined according to the Clenshaw-Curtis grid structure: 2^(mu-1)+1</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="grid, multi_ind = smolyak_grid(clenshaw_curtis_equidistant,d,mu,domain)"><pre>grid, multi_ind <span class="pl-k">=</span> <span class="pl-c1">smolyak_grid</span>(clenshaw_curtis_equidistant,d,mu,domain)</pre></div>
<p dir="auto">Then the weights are computed using</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="weights = smolyak_pl_weights(y,grid,multi_ind,domain)"><pre>weights <span class="pl-k">=</span> <span class="pl-c1">smolyak_pl_weights</span>(y,grid,multi_ind,domain)</pre></div>
<p dir="auto">and the approximation computed via</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y_hat = smolyak_pl_evaluate(weights,point,grid,multi_ind,domain)"><pre>y_hat <span class="pl-k">=</span> <span class="pl-c1">smolyak_pl_evaluate</span>(weights,point,grid,multi_ind,domain)</pre></div>
<p dir="auto">Again <code>mu</code> can be either an integer or a 1d array of integers depending on whether an isotropic or an anisotropic approximation is desired, and the argument <code>domain</code> is unnecessary where the grid resides on [-1,1]^d.</p>
<h2 dir="auto"><a id="user-content-multi-threading" class="anchor" aria-hidden="true" href="#multi-threading"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multi-threading</h2>
<p dir="auto">There are multi-threaded functions to compute the polynomial weights and the interpolation matrix.  These multi-threaded functions are accessed by adding <code>_threaded</code> to the end of the funtion, as per</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="weights = smolyak_weights_threaded(y,inv_interp_mat)"><pre>weights <span class="pl-k">=</span> <span class="pl-c1">smolyak_weights_threaded</span>(y,inv_interp_mat)</pre></div>
<h2 dir="auto"><a id="user-content-useful-structures" class="anchor" aria-hidden="true" href="#useful-structures"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Useful structures</h2>
<p dir="auto">The key structure to be aware of is the SApproxPlan, which contains the key information needed to approximate a function.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d = 3
mu = 3
domain = [2.0 2.0 2.0; -2.0 -2.0 -2.0]
grid, mi = smolyak_grid(chebyshev_extrema,d,mu,domain)
plan = SApproxPlan(:chebyshev_extrema,grid,mi,domain)"><pre>d <span class="pl-k">=</span> <span class="pl-c1">3</span>
mu <span class="pl-k">=</span> <span class="pl-c1">3</span>
domain <span class="pl-k">=</span> [<span class="pl-c1">2.0</span> <span class="pl-c1">2.0</span> <span class="pl-c1">2.0</span>; <span class="pl-k">-</span><span class="pl-c1">2.0</span> <span class="pl-k">-</span><span class="pl-c1">2.0</span> <span class="pl-k">-</span><span class="pl-c1">2.0</span>]
grid, mi <span class="pl-k">=</span> <span class="pl-c1">smolyak_grid</span>(chebyshev_extrema,d,mu,domain)
plan <span class="pl-k">=</span> <span class="pl-c1">SApproxPlan</span>(<span class="pl-c1">:chebyshev_extrema</span>,grid,mi,domain)</pre></div>
<p dir="auto">or</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="plan = smolyak_plan(chebyshev_extrema,d,mu,domain)"><pre>plan <span class="pl-k">=</span> <span class="pl-c1">smolyak_plan</span>(chebyshev_extrema,d,mu,domain)</pre></div>
<p dir="auto">Once the approximation plan has been constructed it can be used to create functions to interpolate and to compute gradients and hessians.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f = smolyak_interp(y,plan)
g = smolyak_gradient(y,plan)
h = smolyak_hessian(y,plan)

point = [1.0, 1.0, 1.0]

f(point)
g(point)
h(point)"><pre>f <span class="pl-k">=</span> <span class="pl-c1">smolyak_interp</span>(y,plan)
g <span class="pl-k">=</span> <span class="pl-c1">smolyak_gradient</span>(y,plan)
h <span class="pl-k">=</span> <span class="pl-c1">smolyak_hessian</span>(y,plan)

point <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>]

<span class="pl-c1">f</span>(point)
<span class="pl-c1">g</span>(point)
<span class="pl-c1">h</span>(point)</pre></div>
<p dir="auto">There are threaded versions of <code>smolyak_interp</code>, <code>smolyak_gradient</code>, and <code>smolyak_hessian</code>.</p>
<h2 dir="auto"><a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related packages</h2>
<ul dir="auto">
<li>ChebyshevApprox.jl</li>
<li>HyperbolicCrossApprox.jl</li>
<li>PiecewiseLinearApprox.jl</li>
</ul>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">My primary references when writing this package were:</p>
<p dir="auto">Judd, K., Maliar, L., Maliar, S., and R. Valero, (2014), "Smolyak Method for Solving Dynamic Economic Models: Lagrange Interpolation, Anisotropic Grid and Adaptive Domain," Journal of Economic Dynamics and Control, 44, pp.92--123.</p>
<p dir="auto">Klimke, A., and B. Wohlmuth, (2005), "Algorithm 846: spinterp: Piecewise Multilinear Hierarchical Grid Interpolation in MATLAB," ACM Transactions on Mathematical Software, 31, 4, pp.561--579.</p>
</article></div>