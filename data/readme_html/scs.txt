<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-scs" class="anchor" aria-hidden="true" href="#scs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SCS</h1>
<p><a href="https://travis-ci.org/JuliaOpt/SCS.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/8a97268900106dd067567ebae03f1490c647ff1b/68747470733a2f2f7472617669732d63692e6f72672f4a756c69614f70742f5343532e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaOpt/SCS.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/mlubin/scs-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/70c42cf9a96392c09b0c0efdc270e2c12bf5b5fd/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f796234796667346f727977377974656e2f6272616e63682f6d61737465723f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/yb4yfg4oryw7yten/branch/master?svg=true" style="max-width:100%;"></a>
<a href="https://coveralls.io/r/JuliaOpt/SCS.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/05f23c72e6e275f388526d65ebfe0b8aa66bf88d/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f4a756c69614f70742f5343532e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/JuliaOpt/SCS.jl/badge.svg?branch=master" style="max-width:100%;"></a></p>
<p>Julia wrapper for the <a href="https://github.com/cvxgrp/scs">SCS</a> splitting cone
solver. SCS can solve linear programs, second-order cone programs, semidefinite
programs, exponential cone programs, and power cone programs.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>You can install SCS.jl through the Julia package manager:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>SCS<span class="pl-pds">"</span></span>)</pre></div>
<p>SCS.jl will use <a href="https://github.com/JuliaPackaging/BinaryProvider.jl">BinaryProvider.jl</a> to automatically install the SCS binaries. Note that if you are not using the official Julia binaries from <code>https://julialang.org/downloads/</code> you may need a custom install of the SCS binaries.</p>
<h2><a id="user-content-custom-installation" class="anchor" aria-hidden="true" href="#custom-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Installation</h2>
<p>Custom build binaries will allow to use e.g. the indirect solver on (a CUDA-enabled) gpu,
however special caution is required during the compilation of the <code>scs</code> libraries to ensure proper options and linking:</p>
<ul>
<li><code>libscsdir</code> and <code>libscsindir</code> need to be compiled with <code>DLONG=1</code>.</li>
<li>(optional) <code>libscsgpu</code> needs to be compiled with <code>DLONG=0</code></li>
</ul>
<p>All of these libraries should be linked against the OpenBLAS library which julia uses.
For the official julia binaries this can be achieved by e.g.</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">cd</span> SCS_SOURCE_DIR
make purge
make USE_OPENMP=1 BLAS64=1 BLASSUFFIX=_64_ DLONG=1 BLASLDFLAGS=<span class="pl-s"><span class="pl-pds">"</span>-L<span class="pl-smi">$JULIA_LIBRARY_PATH</span> -lopenblas64_<span class="pl-pds">"</span></span> out/libscsdir.so out/libscsindir.so
make clean
make USE_OPENMP=1 BLAS64=1 BLASSUFFIX=_64_ DLONG=0 BLASLDFLAGS=<span class="pl-s"><span class="pl-pds">"</span>-L<span class="pl-smi">$JULIA_LIBRARY_PATH</span> -lopenblas64_<span class="pl-pds">"</span></span> out/libscsgpu.so</pre></div>
<p>where</p>
<ul>
<li><code>SCS_SOURCE_DIR</code> is the main directory of the source of <code>scs</code>, and</li>
<li><code>JULIA_LIBRARY_PATH</code> is the path to julia-shipped libraries (e.g. <code>abspath(joinpath(Sys.BINDIR, "..", "lib", "julia"))</code>)</li>
</ul>
<p>To use custom built SCS binaries with <code>SCS.jl</code> set the environment variable
<code>JULIA_SCS_LIBRARY_PATH</code> to <code>SCS_SOURCE_DIR/opt</code> and build <code>SCS.jl</code>:</p>
<div class="highlight highlight-source-julia"><pre>ENV[<span class="pl-s"><span class="pl-pds">"</span>JULIA_SCS_LIBRARY_PATH<span class="pl-pds">"</span></span>]<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>&lt;scs_source_dir&gt;/out<span class="pl-pds">"</span></span>
<span class="pl-k">using</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">build</span>(<span class="pl-s"><span class="pl-pds">"</span>SCS<span class="pl-pds">"</span></span>)</pre></div>
<p>To switch back to the default binaries delete <code>JULIA_SCS_LIBRARY_PATH</code> and call <code>Pkg.build("SCS")</code> again.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<h3><a id="user-content-mathoptinterface-wrapper" class="anchor" aria-hidden="true" href="#mathoptinterface-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MathOptInterface wrapper</h3>
<p>SCS implements the solver-independent <a href="https://github.com/JuliaOpt/MathOptInterface.jl">MathOptInterface</a> interface, and so can be used within modeling softwares like <a href="https://github.com/JuliaOpt/Convex.jl">Convex</a> and <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a>. The optimizer constructor is <code>SCS.Optimizer</code>.</p>
<h3><a id="user-content-options" class="anchor" aria-hidden="true" href="#options"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Options</h3>
<p>All SCS solver options can be set through the direct interface(documented below) and through MathProgBase.
The list of options is defined the <a href="https://github.com/cvxgrp/scs/blob/58e9af926fabc6674a9f488d4e9761a4f0fc451c/include/scs.h#L43"><code>scs.h</code> header</a>.
To use these settings you can either pass them as keyword arguments to <code>SCS_solve</code> (high level interface) or as arguments to the <code>SCSSolver</code> constructor (MathProgBase interface), e.g.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Direct</span>
solution <span class="pl-k">=</span> <span class="pl-c1">SCS_solve</span>(m, n, A, <span class="pl-k">...</span>, psize; max_iters<span class="pl-k">=</span><span class="pl-c1">10</span>, verbose<span class="pl-k">=</span><span class="pl-c1">0</span>);
<span class="pl-c"><span class="pl-c">#</span> MathProgBase (with Convex)</span>
m <span class="pl-k">=</span> <span class="pl-c1">solve!</span>(problem, <span class="pl-c1">SCSSolver</span>(max_iters<span class="pl-k">=</span><span class="pl-c1">10</span>, verbose<span class="pl-k">=</span><span class="pl-c1">0</span>))</pre></div>
<p>Moreover, You may select one of the linear solvers to be used by <code>SCSSolver</code> via <code>linear_solver</code> keyword. The options available are <code>SCS.IndirectSolver</code> (the default) and <code>SCS.DirectSolver</code>.</p>
<h3><a id="user-content-high-level-wrapper" class="anchor" aria-hidden="true" href="#high-level-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>High level wrapper</h3>
<p>The file <a href="https://github.com/JuliaOpt/SCS.jl/blob/master/src/high_level_wrapper.jl"><code>high_level_wrapper.jl</code></a> is thoroughly commented. Here is the basic usage</p>
<p>We assume we are solving a problem of the form</p>
<pre><code>minimize        c' * x
subject to      A * x + s = b
                s in K
</code></pre>
<p>where K is a product cone of</p>
<ul>
<li>zero cones,</li>
<li>linear cones <code>{ x | x &gt;= 0 }</code>,</li>
<li>second-order cones <code>{ (t,x) | ||x||_2 &lt;= t }</code>,</li>
<li>semi-definite cones <code>{ X | X psd }</code>,</li>
<li>exponential cones <code>{(x,y,z) | y e^(x/y) &lt;= z, y&gt;0 }</code>, and</li>
<li>power cone <code>{(x,y,z) | x^a * y^(1-a) &gt;= |z|, x&gt;=0, y&gt;=0}</code>.</li>
</ul>
<p>The problem data are</p>
<ul>
<li><code>A</code> is the matrix with m rows and n cols</li>
<li><code>b</code> is of length m x 1</li>
<li><code>c</code> is of length n x 1</li>
<li><code>f</code> is the number of primal zero / dual free cones, i.e. primal equality constraints</li>
<li><code>l</code> is the number of linear cones</li>
<li><code>q</code> is the array of SOCs sizes</li>
<li><code>s</code> is the array of SDCs sizes</li>
<li><code>ep</code> is the number of primal exponential cones</li>
<li><code>ed</code> is the number of dual exponential cones</li>
<li><code>p</code> is the array of power cone parameters</li>
<li><code>options</code> is a dictionary of options (see above).</li>
</ul>
<p>The function is</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">SCS_solve</span>(linear_solver<span class="pl-k">::</span><span class="pl-c1">Type{&lt;:LinearSolver}</span>,
        m<span class="pl-k">::</span><span class="pl-c1">Integer</span>, n<span class="pl-k">::</span><span class="pl-c1">Integer</span>, A<span class="pl-k">::</span><span class="pl-c1">SCS.VecOrMatOrSparse</span>, b<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, c<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>,
        f<span class="pl-k">::</span><span class="pl-c1">Integer</span>, l<span class="pl-k">::</span><span class="pl-c1">Integer</span>, q<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Integer}</span>, s<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Integer}</span>,
        ep<span class="pl-k">::</span><span class="pl-c1">Integer</span>, ed<span class="pl-k">::</span><span class="pl-c1">Integer</span>, p<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>,
        primal_sol<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span><span class="pl-k">=</span><span class="pl-c1">zeros</span>(n),
        dual_sol<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span><span class="pl-k">=</span><span class="pl-c1">zeros</span>(m),
        slack<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span><span class="pl-k">=</span><span class="pl-c1">zeros</span>(m);
        options<span class="pl-k">...</span>)</pre></div>
<p>and it returns an object of type Solution, which contains the following fields</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">mutable struct</span> Solution{T<span class="pl-k">&lt;:</span><span class="pl-c1">SCSInt</span>}
  x<span class="pl-k">::</span><span class="pl-c1">Array{Float64, 1}</span>
  y<span class="pl-k">::</span><span class="pl-c1">Array{Float64, 1}</span>
  s<span class="pl-k">::</span><span class="pl-c1">Array{Float64, 1}</span>
  status<span class="pl-k">::</span><span class="pl-c1">SCSInfo{T}</span>
  ret_val<span class="pl-k">::</span><span class="pl-c1">T</span>
  <span class="pl-k">...</span></pre></div>
<p>Where <code>x</code> stores the optimal value of the primal variable, <code>y</code> stores the optimal value of the dual variable, <code>s</code> is the slack variable, and <code>status</code> contains various information about the solve step.
E.g. <code>SCS.raw_status(::SCSInfo)::String</code> describes the status, e.g. 'Solved', 'Intedeterminate', 'Infeasible/Inaccurate', etc.</p>
<h3><a id="user-content-low-level-wrapper" class="anchor" aria-hidden="true" href="#low-level-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Low level wrapper</h3>
<p>The low level wrapper directly calls SCS and is also thoroughly documented in <a href="https://github.com/JuliaOpt/SCS.jl/blob/master/src/low_level_wrapper.jl">low_level_wrapper.jl</a>. The low level wrapper performs the pointer manipulation necessary for the direct C call.</p>
<h3><a id="user-content-convex-and-jump-examples" class="anchor" aria-hidden="true" href="#convex-and-jump-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Convex and JuMP examples</h3>
<p>This example shows how we can model a simple knapsack problem with Convex and use SCS to solve it.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Convex, SCS
items  <span class="pl-k">=</span> [<span class="pl-c1">:Gold</span>, <span class="pl-c1">:Silver</span>, <span class="pl-c1">:Bronze</span>]
values <span class="pl-k">=</span> [<span class="pl-c1">5.0</span>, <span class="pl-c1">3.0</span>, <span class="pl-c1">1.0</span>]
weights <span class="pl-k">=</span> [<span class="pl-c1">2.0</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">0.3</span>]

<span class="pl-c"><span class="pl-c">#</span> Define a variable of size 3, each index representing an item</span>
x <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">3</span>)
p <span class="pl-k">=</span> <span class="pl-c1">maximize</span>(x<span class="pl-k">'</span> <span class="pl-k">*</span> values, <span class="pl-c1">0</span> <span class="pl-k">&lt;=</span> x, x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>, x<span class="pl-k">'</span> <span class="pl-k">*</span> weights <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>)
<span class="pl-c1">solve!</span>(p, <span class="pl-c1">SCSSolver</span>())
<span class="pl-c1">println</span>([items x<span class="pl-k">.</span>value])

<span class="pl-c"><span class="pl-c">#</span> [:Gold 0.9999971880377178</span>
<span class="pl-c"><span class="pl-c">#</span>  :Silver 0.46667637765641057</span>
<span class="pl-c"><span class="pl-c">#</span>  :Bronze 0.9999998036351865]</span></pre></div>
<p>This example shows how we can model a simple knapsack problem with JuMP and use SCS to solve it.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> JuMP, SCS
items  <span class="pl-k">=</span> [<span class="pl-c1">:Gold</span>, <span class="pl-c1">:Silver</span>, <span class="pl-c1">:Bronze</span>]
values <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">:Gold</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">5.0</span>,  <span class="pl-c1">:Silver</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">3.0</span>,  <span class="pl-c1">:Bronze</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1.0</span>)
weight <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">:Gold</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">2.0</span>,  <span class="pl-c1">:Silver</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1.5</span>,  <span class="pl-c1">:Bronze</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0.3</span>)

model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(SCS<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">@variable</span>(model, <span class="pl-c1">0</span> <span class="pl-k">&lt;=</span> take[items] <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span> Define a variable for each item</span>
<span class="pl-c1">@objective</span>(model, Max, <span class="pl-c1">sum</span>(values[item] <span class="pl-k">*</span> take[item] <span class="pl-k">for</span> item <span class="pl-k">in</span> items))
<span class="pl-c1">@constraint</span>(model, <span class="pl-c1">sum</span>(weight[item] <span class="pl-k">*</span> take[item] <span class="pl-k">for</span> item <span class="pl-k">in</span> items) <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>)
<span class="pl-c1">optimize!</span>(model)
<span class="pl-c1">println</span>(<span class="pl-c1">value</span>.(take))
<span class="pl-c"><span class="pl-c">#</span> 1-dimensional DenseAxisArray{Float64,1,...} with index sets:</span>
<span class="pl-c"><span class="pl-c">#</span>     Dimension 1, Symbol[:Gold, :Silver, :Bronze]</span>
<span class="pl-c"><span class="pl-c">#</span> And data, a 3-element Array{Float64,1}:</span>
<span class="pl-c"><span class="pl-c">#</span>  1.0000002002226671</span>
<span class="pl-c"><span class="pl-c">#</span>  0.4666659513182934</span>
<span class="pl-c"><span class="pl-c">#</span>  1.0000007732744878</span>
</pre></div>
</article></div>