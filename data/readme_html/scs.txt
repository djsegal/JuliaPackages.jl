<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-scs" class="anchor" aria-hidden="true" href="#scs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SCS</h1>
<p><a href="https://travis-ci.org/jump-dev/SCS.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/19f29d2cecfc78715d9a2592e0779386a8b917e8/68747470733a2f2f7472617669732d63692e6f72672f6a756d702d6465762f5343532e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/jump-dev/SCS.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/mlubin/scs-jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/70c42cf9a96392c09b0c0efdc270e2c12bf5b5fd/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f796234796667346f727977377974656e2f6272616e63682f6d61737465723f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/yb4yfg4oryw7yten/branch/master?svg=true" style="max-width:100%;"></a>
<a href="https://coveralls.io/r/jump-dev/SCS.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/74a032f4fd755d97a8eafd7692e695a7ee8946a8/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6a756d702d6465762f5343532e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/jump-dev/SCS.jl/badge.svg?branch=master" style="max-width:100%;"></a></p>
<p>Julia wrapper for the <a href="https://github.com/cvxgrp/scs">SCS</a> splitting cone
solver. SCS can solve linear programs, second-order cone programs, semidefinite
programs, exponential cone programs, and power cone programs.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>You can install SCS.jl through the Julia package manager:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>SCS<span class="pl-pds">"</span></span>)</pre></div>
<p>SCS.jl will use <a href="https://github.com/JuliaPackaging/BinaryProvider.jl">BinaryProvider.jl</a> to automatically install the SCS binaries. Note that if you are not using the official Julia binaries from <code>https://julialang.org/downloads/</code> you may need a custom install of the SCS binaries.</p>
<h2><a id="user-content-custom-installation" class="anchor" aria-hidden="true" href="#custom-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Installation</h2>
<p>Custom build binaries will allow to use e.g. the indirect solver on (a CUDA-enabled) gpu,
however special caution is required during the compilation of the <code>scs</code> libraries to ensure proper options and linking:</p>
<ul>
<li><code>libscsdir</code> and <code>libscsindir</code> need to be compiled with <code>DLONG=1</code>.</li>
<li>(optional) <code>libscsgpu</code> needs to be compiled with <code>DLONG=0</code></li>
</ul>
<p>All of these libraries should be linked against the OpenBLAS library which julia uses.
For the official julia binaries this can be achieved by e.g.</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">cd</span> SCS_SOURCE_DIR
make purge
make USE_OPENMP=1 BLAS64=1 BLASSUFFIX=_64_ DLONG=1 BLASLDFLAGS=<span class="pl-s"><span class="pl-pds">"</span>-L<span class="pl-smi">$JULIA_LIBRARY_PATH</span> -lopenblas64_<span class="pl-pds">"</span></span> out/libscsdir.so out/libscsindir.so
make clean
make USE_OPENMP=1 BLAS64=1 BLASSUFFIX=_64_ DLONG=0 BLASLDFLAGS=<span class="pl-s"><span class="pl-pds">"</span>-L<span class="pl-smi">$JULIA_LIBRARY_PATH</span> -lopenblas64_<span class="pl-pds">"</span></span> out/libscsgpu.so</pre></div>
<p>where</p>
<ul>
<li><code>SCS_SOURCE_DIR</code> is the main directory of the source of <code>scs</code>, and</li>
<li><code>JULIA_LIBRARY_PATH</code> is the path to julia-shipped libraries (e.g. <code>abspath(joinpath(Sys.BINDIR, "..", "lib", "julia"))</code>)</li>
</ul>
<p>To use custom built SCS binaries with <code>SCS.jl</code> set the environment variable
<code>JULIA_SCS_LIBRARY_PATH</code> to <code>SCS_SOURCE_DIR/opt</code> and build <code>SCS.jl</code>:</p>
<div class="highlight highlight-source-julia"><pre>ENV[<span class="pl-s"><span class="pl-pds">"</span>JULIA_SCS_LIBRARY_PATH<span class="pl-pds">"</span></span>]<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>&lt;scs_source_dir&gt;/out<span class="pl-pds">"</span></span>
<span class="pl-k">using</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">build</span>(<span class="pl-s"><span class="pl-pds">"</span>SCS<span class="pl-pds">"</span></span>)</pre></div>
<p>To switch back to the default binaries delete <code>JULIA_SCS_LIBRARY_PATH</code> and call <code>Pkg.build("SCS")</code> again.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<h3><a id="user-content-high-level-interfaces" class="anchor" aria-hidden="true" href="#high-level-interfaces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High-level interfaces</h3>
<p>SCS implements the solver-independent <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface</a> interface, and so can be used within modeling softwares like <a href="https://github.com/JuliaOpt/Convex.jl">Convex</a> and <a href="https://github.com/jump-dev/JuMP.jl">JuMP</a>. The optimizer constructor is <code>SCS.Optimizer</code>.</p>
<p>A legacy <a href="https://github.com/JuliaOpt/MathProgBase.jl">MathProgBase</a> interface is available as well, in maintanence mode only.</p>
<h3><a id="user-content-options" class="anchor" aria-hidden="true" href="#options"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Options</h3>
<p>All SCS solver options can be set through the direct interface(documented below), through <code>Convex.jl</code> or <code>MathOptInterface.jl</code>.
The list of options follows the <a href="https://github.com/cvxgrp/scs/blob/0fd7ea85e8b0d878cacf5b1dbce557b330422ff7/include/glbopts.h#L30"><code>glbopts.h</code> header</a> in lowercase.
To use these settings you can either pass them as keyword arguments to <code>SCS_solve</code> (high level interface) or using the <code>SCS.Optimizer</code> constructor (MathOptInterface), e.g.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Direct</span>
solution <span class="pl-k">=</span> <span class="pl-c1">SCS_solve</span>(m, n, A, <span class="pl-k">...</span>, psize; max_iters<span class="pl-k">=</span><span class="pl-c1">10</span>, verbose<span class="pl-k">=</span><span class="pl-c1">0</span>);
<span class="pl-c"><span class="pl-c">#</span> via MathOptInterface:</span>
optimizer <span class="pl-k">=</span> SCS<span class="pl-k">.</span><span class="pl-c1">Optimizer</span>()
MOI<span class="pl-k">.</span><span class="pl-c1">set</span>(optimizer, MOI<span class="pl-k">.</span><span class="pl-c1">RawParameter</span>(<span class="pl-s"><span class="pl-pds">"</span>max_iters<span class="pl-pds">"</span></span>), <span class="pl-c1">10</span>)
MOI<span class="pl-k">.</span><span class="pl-c1">set</span>(optimizer, MOI<span class="pl-k">.</span><span class="pl-c1">RawParameter</span>(<span class="pl-s"><span class="pl-pds">"</span>verbose<span class="pl-pds">"</span></span>), <span class="pl-c1">0</span>)</pre></div>
<p>or via specific helper functions:</p>
<div class="highlight highlight-source-julia"><pre>problem <span class="pl-k">=</span> <span class="pl-k">...</span> <span class="pl-c"><span class="pl-c">#</span> JuMP problem</span>
optimizer_constructor <span class="pl-k">=</span> <span class="pl-c1">optimizer_with_attributes</span>(SCS<span class="pl-k">.</span>Optimizer, <span class="pl-s"><span class="pl-pds">"</span>max_iters<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>verbose<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>)
<span class="pl-c1">set_optimizer</span>(problem, optimizer_constructor)
<span class="pl-c1">optimize!</span>(problem)</pre></div>
<p>Moreover, You may select one of the linear solvers to be used by <code>SCS.Optimizer</code> via <code>linear_solver</code> keyword.
The options available are <code>SCS.IndirectSolver</code> (the default) and <code>SCS.DirectSolver</code>.
An experimental <code>SCS.IndirectGpuSolver</code> can be used only with custom installation.</p>
<h3><a id="user-content-high-level-wrapper" class="anchor" aria-hidden="true" href="#high-level-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High level wrapper</h3>
<p>The file <a href="https://github.com/jump-dev/SCS.jl/blob/master/src/c_wrapper.jl"><code>c_wrapper.jl</code></a> is thoroughly commented. Here is the basic usage.</p>
<p>We assume we are solving a problem of the form</p>
<pre><code>minimize        c' * x
subject to      A * x + s = b
                s in K
</code></pre>
<p>where <code>K</code> is a product cone of</p>
<ul>
<li>zero cones,</li>
<li>positive orthant <code>{ x | x &gt;= 0 }</code>,</li>
<li>second-order cones (SOC) <code>{ (t,x) | ||x||_2 &lt;= t }</code>,</li>
<li>semi-definite cones (SDC) <code>{ X | X is psd }</code>,</li>
<li>exponential cones <code>{ (x,y,z) | y e^(x/y) &lt;= z, y&gt;0 }</code>,</li>
<li>power cone <code>{ (x,y,z) | x^a * y^(1-a) &gt;= |z|, x&gt;=0, y&gt;=0 }</code>, and</li>
<li>dual power cone <code>{ (u,v,w) | (u/a)^a * (v/(1-a))^(1-a) &gt;= |w|, u&gt;=0, v&gt;=0 }</code>.</li>
</ul>
<p>The problem data are</p>
<ul>
<li><code>A</code> is the matrix with m rows and n cols</li>
<li><code>b</code> is of length m x 1</li>
<li><code>c</code> is of length n x 1</li>
<li><code>f</code> is the number of primal zero / dual free cones, i.e. primal equality constraints</li>
<li><code>l</code> is the number of linear cones</li>
<li><code>q</code> is the array of SOCs sizes</li>
<li><code>s</code> is the array of SDCs sizes</li>
<li><code>ep</code> is the number of primal exponential cones</li>
<li><code>ed</code> is the number of dual exponential cones</li>
<li><code>p</code> is the array of power cone parameters (Â±1, with negative values for the dual cone)</li>
<li><code>options</code> is a dictionary of options (see above).</li>
</ul>
<p>The function is</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">SCS_solve</span>(linear_solver<span class="pl-k">::</span><span class="pl-c1">Type{&lt;:LinearSolver}</span>,
        m<span class="pl-k">::</span><span class="pl-c1">Integer</span>, n<span class="pl-k">::</span><span class="pl-c1">Integer</span>,
        A<span class="pl-k">::</span><span class="pl-c1">SCS.VecOrMatOrSparse</span>, b<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, c<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>,
        f<span class="pl-k">::</span><span class="pl-c1">Integer</span>, l<span class="pl-k">::</span><span class="pl-c1">Integer</span>, q<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Integer}</span>, s<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Integer}</span>,
        ep<span class="pl-k">::</span><span class="pl-c1">Integer</span>, ed<span class="pl-k">::</span><span class="pl-c1">Integer</span>, p<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>,
        primal_sol<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span><span class="pl-k">=</span><span class="pl-c1">zeros</span>(n),
        dual_sol<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span><span class="pl-k">=</span><span class="pl-c1">zeros</span>(m),
        slack<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span><span class="pl-k">=</span><span class="pl-c1">zeros</span>(m);
        options<span class="pl-k">...</span>)</pre></div>
<p>and it returns an object of type <code>Solution</code>, which contains the following fields</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">mutable struct</span> Solution{T<span class="pl-k">&lt;:</span><span class="pl-c1">SCSInt</span>}
    x<span class="pl-k">::</span><span class="pl-c1">Array{Float64, 1}</span>
    y<span class="pl-k">::</span><span class="pl-c1">Array{Float64, 1}</span>
    s<span class="pl-k">::</span><span class="pl-c1">Array{Float64, 1}</span>
    info<span class="pl-k">::</span><span class="pl-c1">SCSInfo{T}</span>
    ret_val<span class="pl-k">::</span><span class="pl-c1">T</span>
<span class="pl-k">end</span></pre></div>
<p>Where <code>x</code> stores the optimal value of the primal variable, <code>y</code> stores the optimal value of the dual variable, <code>s</code> is the slack variable, and <code>info</code> contains various information about the solve step.
E.g. <code>SCS.raw_status(::SCSInfo)::String</code> describes the status, e.g. 'Solved', 'Intedeterminate', 'Infeasible/Inaccurate', etc.</p>
<h3><a id="user-content-convex-and-jump-examples" class="anchor" aria-hidden="true" href="#convex-and-jump-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Convex and JuMP examples</h3>
<p>This example shows how we can model a simple knapsack problem with Convex and use SCS to solve it.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Convex, SCS
items  <span class="pl-k">=</span> [<span class="pl-c1">:Gold</span>, <span class="pl-c1">:Silver</span>, <span class="pl-c1">:Bronze</span>]
values <span class="pl-k">=</span> [<span class="pl-c1">5.0</span>, <span class="pl-c1">3.0</span>, <span class="pl-c1">1.0</span>]
weights <span class="pl-k">=</span> [<span class="pl-c1">2.0</span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">0.3</span>]

<span class="pl-c"><span class="pl-c">#</span> Define a variable of size 3, each index representing an item</span>
x <span class="pl-k">=</span> <span class="pl-c1">Variable</span>(<span class="pl-c1">3</span>)
p <span class="pl-k">=</span> <span class="pl-c1">maximize</span>(x<span class="pl-k">'</span> <span class="pl-k">*</span> values, <span class="pl-c1">0</span> <span class="pl-k">&lt;=</span> x, x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>, x<span class="pl-k">'</span> <span class="pl-k">*</span> weights <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>)
<span class="pl-c1">solve!</span>(p, SCS<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">println</span>([items x<span class="pl-k">.</span>value])

<span class="pl-c"><span class="pl-c">#</span> [:Gold 0.9999971880377178</span>
<span class="pl-c"><span class="pl-c">#</span>  :Silver 0.46667637765641057</span>
<span class="pl-c"><span class="pl-c">#</span>  :Bronze 0.9999998036351865]</span></pre></div>
<p>This example shows how we can model a simple knapsack problem with JuMP and use SCS to solve it.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> JuMP, SCS
items  <span class="pl-k">=</span> [<span class="pl-c1">:Gold</span>, <span class="pl-c1">:Silver</span>, <span class="pl-c1">:Bronze</span>]
values <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">:Gold</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">5.0</span>,  <span class="pl-c1">:Silver</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">3.0</span>,  <span class="pl-c1">:Bronze</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1.0</span>)
weight <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">:Gold</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">2.0</span>,  <span class="pl-c1">:Silver</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1.5</span>,  <span class="pl-c1">:Bronze</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">0.3</span>)

model <span class="pl-k">=</span> <span class="pl-c1">Model</span>(SCS<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">@variable</span>(model, <span class="pl-c1">0</span> <span class="pl-k">&lt;=</span> take[items] <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span> Define a variable for each item</span>
<span class="pl-c1">@objective</span>(model, Max, <span class="pl-c1">sum</span>(values[item] <span class="pl-k">*</span> take[item] <span class="pl-k">for</span> item <span class="pl-k">in</span> items))
<span class="pl-c1">@constraint</span>(model, <span class="pl-c1">sum</span>(weight[item] <span class="pl-k">*</span> take[item] <span class="pl-k">for</span> item <span class="pl-k">in</span> items) <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>)
<span class="pl-c1">optimize!</span>(model)
<span class="pl-c1">println</span>(<span class="pl-c1">value</span>.(take))
<span class="pl-c"><span class="pl-c">#</span> 1-dimensional DenseAxisArray{Float64,1,...} with index sets:</span>
<span class="pl-c"><span class="pl-c">#</span>     Dimension 1, Symbol[:Gold, :Silver, :Bronze]</span>
<span class="pl-c"><span class="pl-c">#</span> And data, a 3-element Array{Float64,1}:</span>
<span class="pl-c"><span class="pl-c">#</span>  1.0000002002226671</span>
<span class="pl-c"><span class="pl-c">#</span>  0.4666659513182934</span>
<span class="pl-c"><span class="pl-c">#</span>  1.0000007732744878</span>
</pre></div>
</article></div>