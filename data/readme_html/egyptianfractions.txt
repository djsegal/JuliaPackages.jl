<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-egyptianfractions" class="anchor" aria-hidden="true" href="#egyptianfractions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>EgyptianFractions</h1>
<p>Linux/Mac: <a href="https://travis-ci.org/reallyasi9/EgyptianFractions.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d18bed99ed67ebc35d5db02dd1a1bcbcd7781ad595e5fa089451f9d57e6c4e6d/68747470733a2f2f7472617669732d63692e6f72672f7265616c6c79617369392f456779707469616e4672616374696f6e732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/reallyasi9/EgyptianFractions.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p>Windows: <a href="https://ci.appveyor.com/project/reallyasi9/egyptianfractions-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/9eb9085343edf4c2aa3130e2222ebc33986f021f9b56d95a23f2a72f24c47c97/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f306d69306d32383264357262753270303f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/0mi0m282d5rbu2p0?svg=true" style="max-width:100%;"></a></p>
<p>Everything else: <a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/098d7aa2f5550f1485ac850d1715c75f613787e623847a37ba7d7a486db9177f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f7465737425323069742d696e25323070726f64756374696f6e2d627269676874677265656e2e737667"><img src="https://camo.githubusercontent.com/098d7aa2f5550f1485ac850d1715c75f613787e623847a37ba7d7a486db9177f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f7465737425323069742d696e25323070726f64756374696f6e2d627269676874677265656e2e737667" alt="Build status" data-canonical-src="https://img.shields.io/badge/test%20it-in%20production-brightgreen.svg" style="max-width:100%;"></a></p>
<p>This package will decompose rational numbers into <a href="https://en.wikipedia.org/wiki/Egyptian_fraction" rel="nofollow">Egyptian fractions</a>.</p>
<h2><a id="user-content-what-the-heck-are-egyptian-fractions" class="anchor" aria-hidden="true" href="#what-the-heck-are-egyptian-fractions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What the heck are Egyptian fractions?</h2>
<p>Egyptian fractions are representations of rational numbers as sums of fractions where the numerator is always 1.  Here is a quick example (using Julia's rational number representation):</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="3//4 == 1//2 + 1//4
"><pre><code>3//4 == 1//2 + 1//4
</code></pre></div>
<p>That's pretty easy to check.  A more complex example is something like this:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="5//121 == 1//33 + 1//121 + 1//363
"><pre><code>5//121 == 1//33 + 1//121 + 1//363
</code></pre></div>
<p>That result is not particularly obvious, but if you do the math, it turns out to be correct:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="(5*3)//(121*3) == 15//363 == (1*11)//(33*11) + (1*3)//(121*3) + 1//363
"><pre><code>(5*3)//(121*3) == 15//363 == (1*11)//(33*11) + (1*3)//(121*3) + 1//363
</code></pre></div>
<p>Egyptian fractions are called that because that is how the ancient Egyptians wrote down fractions that were more complex than the simple fractions supported by their hieroglyph script.  Ancient Egyptian hieroglyphs had a way to denote common fractions like 1/2, 2/3, and 3/4, but relied on sums of integer reciprocals for uncommon fractions.</p>
<p>Egyptian fractions follow these simple rules:</p>
<ol>
<li>Each fraction in the sum must be the reciprocal of a positive integer (<em>i.e.</em>, <em>1/n</em>, where <em>n</em> is an integer &gt; 0).</li>
<li>No denominator can appear more than once.</li>
</ol>
<p>Because of this, one can specify an Egyptian fraction as a list of denominators <em>n_1</em>, <em>n_2</em>, <em>...</em>, where each <em>n</em> is an integer, and every <em>n</em> will be unique.</p>
<h2><a id="user-content-extended-egyptian-fractions" class="anchor" aria-hidden="true" href="#extended-egyptian-fractions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Extended Egyptian fractions</h2>
<p>Proper Egyptian fractions (those that follow the two rules above) can only represent rational numbers strictly greater than 0.  If you want to extend the concept of Egyptian fractions to represent all rational numbers, you need to change the rules a little:</p>
<ol>
<li>Each fraction in the sum must be the reciprocal of <del>a positive</del> <strong>any</strong> integer (<em>i.e.</em>, <em>1/n</em>, where <em>n</em> is an integer <del>&gt; 0</del>).</li>
<li>No denominator <strong>except 1</strong> can appear more than once.</li>
<li>The Egyptian fraction representation of 0 is the empty set.</li>
</ol>
<p>The modification of the first rule means you can represent rational numbers &lt; 0 by simply using all negative denominators.  The sum of these (negative) fractions will equal the original (negative) rational number.  The modification of the second rule means you can represent rational numbers &gt; 1 or &lt; -1 by repeating <em>1/1</em> for each integral unit of the original rational number, then representing the remainder as a proper Egyptian fraction.  For example, if</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="3//4 == 1//2 + 1//4
"><pre><code>3//4 == 1//2 + 1//4
</code></pre></div>
<p>then a demonstration of the first modified rule would be</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="-3//4 == (-1//2) + (-1//4)
"><pre><code>-3//4 == (-1//2) + (-1//4)
</code></pre></div>
<p>and a demonstration of the second modified rule would be</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="11//4 == 1//1 + 1//1 + 1//2 + 1//4
"><pre><code>11//4 == 1//1 + 1//1 + 1//2 + 1//4
</code></pre></div>
<p>From these extended rules, any rational number can be represented as an Egyptian-style fraction.</p>
<p>It should be noted here that, because the harmonic series <em>1 + 1/2 + 1/3 + ...</em> does not converge, it is possible to represent any rational number &gt; 0 using the definition of the proper Egyptian fractions; however, the harmonic series diverges extremely slowly, so the modified rule 2 is adopted in this package for the sake of making runtimes more reasonable.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>To use this package, simply call from Julia:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using EgyptianFractions
"><pre><span class="pl-k">using</span> EgyptianFractions</pre></div>
<p>There are several methods for generating Egyptian fractions from a rational number.  The simplest is the "<a href="https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions" rel="nofollow">greedy</a>" algorithm:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(3//4)  # [2, 4]
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-c1">3</span><span class="pl-k">//</span><span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> [2, 4]</span></pre></div>
<p>All of the exported functions act on <code>Rational</code>s and return a <code>Vector{BigInt}</code>.  The returned integers represent the denominators of the Egyptian fraction expansion of the given rational, as demonstrated:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sum(1 .// efgreedy(3//4)) == 3//4  # true
"><pre><span class="pl-c1">sum</span>(<span class="pl-c1">1</span> <span class="pl-k">.//</span> <span class="pl-c1">efgreedy</span>(<span class="pl-c1">3</span><span class="pl-k">//</span><span class="pl-c1">4</span>)) <span class="pl-k">==</span> <span class="pl-c1">3</span><span class="pl-k">//</span><span class="pl-c1">4</span>  <span class="pl-c"><span class="pl-c">#</span> true</span></pre></div>
<p>You can also pass any <code>Real</code>, and the function will simply convert the number into a <code>Rational</code> as best it can:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(0.75)  # [2, 4]
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-c1">0.75</span>)  <span class="pl-c"><span class="pl-c">#</span> [2, 4]</span></pre></div>
<p><strong>Be careful using the <code>Real</code> versions of these functions</strong>:  Julia's conversion from <code>Real</code> to <code>Rational</code> may not be completely accurate due to how floating point numbers are represented by your CPU architecture, and you may end up with results that are not quite sensible, as demonstrated:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(2//3)  # [2, 6]
efgreedy(2/3)   # A 16-element vector, the last entry approximately 4.47e+14155
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-c1">2</span><span class="pl-k">//</span><span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> [2, 6]</span>
<span class="pl-c1">efgreedy</span>(<span class="pl-c1">2</span><span class="pl-k">/</span><span class="pl-c1">3</span>)   <span class="pl-c"><span class="pl-c">#</span> A 16-element vector, the last entry approximately 4.47e+14155</span></pre></div>
<p><strong>You have been warned.</strong></p>
<p>Expansions of negative numbers work:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(-3//4)  # [-2, -4]
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">//</span><span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> [-2, -4]</span></pre></div>
<p>So do expansions of numbers &gt; 1 or &lt; -1:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(11//4)  # [1, 1, 2, 4]
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-c1">11</span><span class="pl-k">//</span><span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> [1, 1, 2, 4]</span></pre></div>
<p>The expansions are done in such a way that the following identity should always hold:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="if isa(x, Rational)
  sum(1 .// efgreedy(x)) == x  # true
end
"><pre><span class="pl-k">if</span> <span class="pl-c1">isa</span>(x, Rational)
  <span class="pl-c1">sum</span>(<span class="pl-c1">1</span> <span class="pl-k">.//</span> <span class="pl-c1">efgreedy</span>(x)) <span class="pl-k">==</span> x  <span class="pl-c"><span class="pl-c">#</span> true</span>
<span class="pl-k">end</span></pre></div>
<h2><a id="user-content-types-of-expansions-included" class="anchor" aria-hidden="true" href="#types-of-expansions-included"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Types of expansions included</h2>
<p>As mentioned before, there are several ways to generate Egyptian fractions.  Besides the "greedy" algorithm, this package also includes an "<a href="https://en.wikipedia.org/wiki/Odd_greedy_expansion" rel="nofollow">odd greedy</a>" algorithm, a "harmonic/greedy" algorithm, and one that performs an <a href="https://en.wikipedia.org/wiki/Engel_expansion" rel="nofollow">Engel expansion</a> (also known as an "Egyptian product").</p>
<h3><a id="user-content-greedy-expansion" class="anchor" aria-hidden="true" href="#greedy-expansion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Greedy expansion</h3>
<p>This algorithm chooses greedily the largest possible unit fraction that can be used in any representation of the remaining fraction, then recurses on the remaining fraction.  This algorithm tends to produce expansions that have many terms with very large denominators.  For instance:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(5//121)  # [25, 757, 763309, 873960180913, 1527612795642093418846225]
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-c1">5</span><span class="pl-k">//</span><span class="pl-c1">121</span>)  <span class="pl-c"><span class="pl-c">#</span> [25, 757, 763309, 873960180913, 1527612795642093418846225]</span></pre></div>
<p>When, as seen before, <code>[33, 121, 163]</code> would be a much more sensible expansion.</p>
<h3><a id="user-content-odd-greedy-expansion" class="anchor" aria-hidden="true" href="#odd-greedy-expansion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Odd greedy expansion</h3>
<p>This algorithm acts identically to the greedy algorithm, but it greedily chooses the largest possible odd unit fraction.  It only works if the (reduced) denominator of the input rational is odd.  If it were applied to a rational number with an even denominator, the resulting expansion would never converge.  This algorithm may produce expansions that are shorter than those produced using the generic greedy expansion.  For example:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(8//77)     # [10, 257, 197890]
efoddgreedy(8//77)  # [11, 77]
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-c1">8</span><span class="pl-k">//</span><span class="pl-c1">77</span>)     <span class="pl-c"><span class="pl-c">#</span> [10, 257, 197890]</span>
<span class="pl-c1">efoddgreedy</span>(<span class="pl-c1">8</span><span class="pl-k">//</span><span class="pl-c1">77</span>)  <span class="pl-c"><span class="pl-c">#</span> [11, 77]</span></pre></div>
<p>However, odd greedy expansions are typically longer than generic greedy expansions, so are not typically useful except in rare situations.</p>
<h3><a id="user-content-harmonicgreedy-expansion" class="anchor" aria-hidden="true" href="#harmonicgreedy-expansion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Harmonic/greedy expansion</h3>
<p>Because the harmonic sum <em>1 + 1/2 + 1/3 + ...</em> diverges, it is always possible to find an integer <em>N</em> for any rational number <em>r</em> such that the harmonic sum up to <em>1/N</em> is less than or equal to <em>r</em>, and the harmonic sum up to <em>1/(N+1)</em> is greater than <em>r</em>.  In fact, one can start the harmonic series from any point, and that partial harmonic sum to infinity will also diverge.</p>
<p>Given these properties of the harmonic sum, the harmonic/greedy expansion will expand a rational number in a harmonic sum starting from some integer denominator (typically &gt; 2) until the next fraction in the harmonic series would make the partial sum greater than the given rational number, then expands the remainder using generic greedy expansion.  An example may be helpful:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(18//23)       # [2, 4, 31, 2852]
efharmonic(18//23)     # [2, 4, 31, 2852]
efharmonic(18//23, 5)  # [5, 6, 7, 8, 9, 28, 794, 23010120]
#                  ^ Start from the 5th term in the harmonic series
"><pre><span class="pl-c1">efgreedy</span>(<span class="pl-c1">18</span><span class="pl-k">//</span><span class="pl-c1">23</span>)       <span class="pl-c"><span class="pl-c">#</span> [2, 4, 31, 2852]</span>
<span class="pl-c1">efharmonic</span>(<span class="pl-c1">18</span><span class="pl-k">//</span><span class="pl-c1">23</span>)     <span class="pl-c"><span class="pl-c">#</span> [2, 4, 31, 2852]</span>
<span class="pl-c1">efharmonic</span>(<span class="pl-c1">18</span><span class="pl-k">//</span><span class="pl-c1">23</span>, <span class="pl-c1">5</span>)  <span class="pl-c"><span class="pl-c">#</span> [5, 6, 7, 8, 9, 28, 794, 23010120]</span>
<span class="pl-c"><span class="pl-c">#</span>                  ^ Start from the 5th term in the harmonic series</span></pre></div>
<p>The second argument given to the function <code>efharmonic</code> tells the algorithm where to begin the harmonic series, which defaults to 2.  Note that:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="if isa(r, Rational)
  efgreedy(r) == efharmonic(r) == efharmonic(r, 2)  # true
end
"><pre><span class="pl-k">if</span> <span class="pl-c1">isa</span>(r, Rational)
  <span class="pl-c1">efgreedy</span>(r) <span class="pl-k">==</span> <span class="pl-c1">efharmonic</span>(r) <span class="pl-k">==</span> <span class="pl-c1">efharmonic</span>(r, <span class="pl-c1">2</span>)  <span class="pl-c"><span class="pl-c">#</span> true</span>
<span class="pl-k">end</span></pre></div>
<p>This is because <em>1/2</em> is the largest fraction that can ever be chosen for the greedy algorithm, followed by <em>1/3</em>, then <em>1/4</em>, and so on.</p>
<h3><a id="user-content-engel-expansion" class="anchor" aria-hidden="true" href="#engel-expansion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Engel expansion</h3>
<p>The Engel expansion of a rational number is an Egyptian fraction, but with the fractions in the form <em>1/n_1 + 1/(n_1 * n_2) + 1/(n_1 * n_2 * n_3) + ...</em>.  Because the denominators are the cumulative products of distinct integers, this type of expansion is sometimes called an "Egyptian product".</p>
<p>This package supplies two functions for representing Engel expansions.  The first is the more typical way of representing Engel expansions in the literature:  instead of returning the full denominators <code>[n_1, n_1 * n_2, n_1 * n_2 * n_3, ...]</code>, the function <code>engelexpand</code> simply returns the unique <em>n_i</em> values.  For instance:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="engelexpand(7//40)  # [6, 20]
"><pre><span class="pl-c1">engelexpand</span>(<span class="pl-c1">7</span><span class="pl-k">//</span><span class="pl-c1">40</span>)  <span class="pl-c"><span class="pl-c">#</span> [6, 20]</span></pre></div>
<p>This means that the full series expansion is <code>1//6 + 1//(6 * 20)</code>.  The full series expansion is returned using the <code>efengel</code> function, as shown:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efengel(7//40)  # [6, 120]
"><pre><span class="pl-c1">efengel</span>(<span class="pl-c1">7</span><span class="pl-k">//</span><span class="pl-c1">40</span>)  <span class="pl-c"><span class="pl-c">#</span> [6, 120]</span></pre></div>
<p>It should be noted that the denominators in an Engel expansion can quickly become very large, so it is wise to use <code>engelexpand</code>.  Note also the relationship:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="if isa(r, Rational)
  efengel(r) == cumprod(engelexpand(r))  # true
end
"><pre><span class="pl-k">if</span> <span class="pl-c1">isa</span>(r, Rational)
  <span class="pl-c1">efengel</span>(r) <span class="pl-k">==</span> <span class="pl-c1">cumprod</span>(<span class="pl-c1">engelexpand</span>(r))  <span class="pl-c"><span class="pl-c">#</span> true</span>
<span class="pl-k">end</span></pre></div>
<h2><a id="user-content-terminating-expansions" class="anchor" aria-hidden="true" href="#terminating-expansions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Terminating expansions</h2>
<p>All of the exported functions in this package take an optional named argument <code>nmax::Int</code> which, if specified, will terminate the expansion after <code>nmax</code> terms.  This is useful if you want an approximation of a <code>Real</code> argument that you know cannot be accurately represented using a floating point number.  For instance:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="efgreedy(π-3)          # A length-14 vector with the last element approximately 2.24e+9107
efgreedy(π-3, nmax=4)  # [8, 61, 5020, 128541457]
sum(1 .// efgreedy(π-3)) - sum(1 .// efgreedy(π-3, nmax=4))
                       # Approximately 4.72e-18.  Not bad!
"><pre><span class="pl-c1">efgreedy</span>(π<span class="pl-k">-</span><span class="pl-c1">3</span>)          <span class="pl-c"><span class="pl-c">#</span> A length-14 vector with the last element approximately 2.24e+9107</span>
<span class="pl-c1">efgreedy</span>(π<span class="pl-k">-</span><span class="pl-c1">3</span>, nmax<span class="pl-k">=</span><span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> [8, 61, 5020, 128541457]</span>
<span class="pl-c1">sum</span>(<span class="pl-c1">1</span> <span class="pl-k">.//</span> <span class="pl-c1">efgreedy</span>(π<span class="pl-k">-</span><span class="pl-c1">3</span>)) <span class="pl-k">-</span> <span class="pl-c1">sum</span>(<span class="pl-c1">1</span> <span class="pl-k">.//</span> <span class="pl-c1">efgreedy</span>(π<span class="pl-k">-</span><span class="pl-c1">3</span>, nmax<span class="pl-k">=</span><span class="pl-c1">4</span>))
                       <span class="pl-c"><span class="pl-c">#</span> Approximately 4.72e-18.  Not bad!</span></pre></div>
<h2><a id="user-content-to-do" class="anchor" aria-hidden="true" href="#to-do"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>To do</h2>
<p>In no particular order, these are the enhancements I would like to make to this package:</p>
<ul>
<li>Add an algorithm that attempts to follow the deduced historical rules of Egyptian fractions (as determined from various historical texts).</li>
<li>Make the modified version of rule 2 optional (add a flag or another set of named functions).
<ul>
<li>This could lead to extremely large expansions for rational numbers &gt; 1, due to how slowly the harmonic series diverges.</li>
</ul>
</li>
<li>Add an <code>nmin</code> argument, using the various term-generation rules to construct larger expansions when needed.</li>
<li>Fix <code>nmax</code> so that it correctly counts the <code>1//1</code> terms that are added for rational numbers &gt; 1.</li>
</ul>
<p>Feel free to suggest other ideas using the <a href="https://github.com/reallyasi9/EgyptianFractions.jl/issues">issues</a> link or by creating a <a href="https://github.com/reallyasi9/EgyptianFractions.jl/pulls">pull request</a>.</p>
</article></div>