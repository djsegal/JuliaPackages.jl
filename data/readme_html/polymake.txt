<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-polymakejl" class="anchor" aria-hidden="true" href="#polymakejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Polymake.jl</h1>
<p><a href="https://travis-ci.com/oscar-system/Polymake.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/329ae96ffa9f7c4de06728f26788705ec68a1dda/68747470733a2f2f7472617669732d63692e636f6d2f6f736361722d73797374656d2f506f6c796d616b652e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/oscar-system/Polymake.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p><code>Polymake.jl</code> is a Julia package for using <a href="https://polymake.org/doku.php" rel="nofollow"><code>polymake</code></a>, a software for research in polyhedral geometry from Julia.
This package is developed as part of the <a href="https://oscar.computeralgebra.de" rel="nofollow">OSCAR</a> project.</p>
<p>The current version of <code>Polymake.jl</code> relies on <code>polymake</code> version <code>4.0</code> or later.</p>
<p><strong>Index:</strong></p>
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#polymake-syntax-translation">Polymake syntax translation</a></li>
<li><a href="#current-state-of-the-polymake-wrapper">Current state</a></li>
</ul>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>The installation can be done in the Julia's REPL by executing</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>Polymake<span class="pl-pds">"</span></span>)</pre></div>
<p>This will fetch a pre-built binary of <code>polymake</code>. You are ready to start <code>using Polymake</code>.</p>
<p>Note: Pre-built binaries are available for the <code>Linux</code> and <code>macOS</code> platform, but the <code>macOS</code> binaries are considered experimental. Windows users are encouraged to try running Julia inside Window Subsystem for Linux and reporting back ;)</p>
<p>Note: Pre-built polymake will use a separate <code>.polymake</code> config directory (usually <code>joinpath(homedir(), ".julia", "polymake_user")</code>).</p>
<h3><a id="user-content-your-own-installation-of-polymake" class="anchor" aria-hidden="true" href="#your-own-installation-of-polymake"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Your own installation of <code>polymake</code></h3>
<p>If you already have a recent enough version of <code>polymake</code> (i.e. <code>&gt;=4.0</code>) on your system and you want to use this version of <code>polymake</code>, you either need to</p>
<ul>
<li>set the environment variable <code>POLYMAKE_CONFIG=yes</code> and make <code>polymake-config</code> available in your <code>PATH</code> or</li>
<li>set the environment variable <code>POLYMAKE_CONFIG</code> to the full path of the <code>polymake-config</code> executable.</li>
</ul>
<p>After this just <code>add</code> the package as above (or <code>build</code> if the package has been already added), the build script will use your <code>polymake</code> installation.</p>
<h3><a id="user-content-polymake-from-source" class="anchor" aria-hidden="true" href="#polymake-from-source"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>polymake</code> from source</h3>
<p>A compatible version is available at <a href="https://github.com/polymake/polymake">polymake/polymake</a>.
It can be compiled as follows where <code>GIT_FOLDER</code> and <code>INSTALL_FOLDER</code> have to be substituted with your favorite folders. Please note that these need to be absolute paths.
Also make sure to check <a href="https://polymake.org/doku.php/howto/install" rel="nofollow">the necessary dependencies</a> as well as the <a href="https://polymake.org/doku.php/howto/mac" rel="nofollow">additional instructions for Macs</a>.</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-k">export</span> POLYMAKE_GIT=GIT_FOLDER
<span class="pl-k">export</span> POLYMAKE_INSTALL=INSTALL_FOLDER
git clone git@github.com:polymake/polymake <span class="pl-smi">$POLYMAKE_GIT</span>
<span class="pl-c1">cd</span> <span class="pl-smi">$POLYMAKE_GIT</span>
./configure --prefix=<span class="pl-smi">$POLYMAKE_INSTALL</span>
ninja -C build/Opt
ninja -C build/Opt install
<span class="pl-k">export</span> POLYMAKE_CONFIG=<span class="pl-smi">$POLYMAKE_INSTALL</span>/bin/polymake-config</pre></div>
<p>Note that <code>polymake</code> might take some time to compile.</p>
<p>After this start Julia and follow the instructions above.</p>
<p>Note: Self-built polymake will use the standard <code>.polymake</code> config directory (usually <code>$HOME/.polymake</code>).</p>
<h3><a id="user-content-polymakejl-in-a-separate-environment" class="anchor" aria-hidden="true" href="#polymakejl-in-a-separate-environment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Polymake.jl</code> in a separate environment:</h3>
<pre><code>mkdir my_new_env
cd my_new_env
</code></pre>
<p>Then start Julia in the directory and press <code>]</code> for <code>pkg</code> mode.</p>
<div class="highlight highlight-source-julia"><pre>(v1<span class="pl-c1">.3</span>) pkg<span class="pl-k">&gt;</span> activate .
(Polymake) pkg<span class="pl-k">&gt;</span> dev <span class="pl-k">--</span><span class="pl-k">local</span> Polymake
(Polymake) pkg<span class="pl-k">&gt;</span> build Polymake <span class="pl-c"><span class="pl-c">#</span> fetches the prebuild polymake binaries</span>
(Polymake) pkg<span class="pl-k">&gt;</span> test Polymake <span class="pl-c"><span class="pl-c">#</span> and You are good to go!</span></pre></div>
<p>If <code>polymake-config</code> is in your <code>PATH</code>, or <code>POLYMAKE_CONFIG</code> environment variable is set the <code>build</code> phase will try to use it.</p>
<p>Just remember that You need to <code>activate Polymake.jl</code> to use <code>Polymake</code>.</p>
<h2><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<p>In this section we just highlight various possible uses of <code>Polymake.jl</code>. Please refer to <a href="#polymake-syntax-translation">Polymake syntax translation</a> for more thorough treatment.</p>
<p><code>polymake</code> big objects (like <code>Polytope</code>, <code>Cone</code>, etc) constructors live within modules named after <code>polymake</code> applications, e.g.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Call the Polytope constructor</span>
julia<span class="pl-k">&gt;</span> p <span class="pl-k">=</span> polytope<span class="pl-k">.</span><span class="pl-c1">Polytope</span>(POINTS<span class="pl-k">=</span>[<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>; <span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>; <span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">1</span>; <span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>; <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>])
type<span class="pl-k">:</span> Polytope<span class="pl-k">&lt;</span>Rational<span class="pl-k">&gt;</span>

POINTS
<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
<span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">1</span>
<span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>
</pre></div>
<p>Parameters to constructors can be passed as keyword arguments only.
All the keys <em>must</em> be compatible with <code>polymake</code> input attribute names.</p>
<p>Properties of such objects can be accessed by the <code>.</code> syntax:</p>
<pre><code>julia&gt; p.INTERIOR_LATTICE_POINTS
pm::Matrix&lt;pm::Integer&gt;
1 0 0
</code></pre>
<h3><a id="user-content-example-script" class="anchor" aria-hidden="true" href="#example-script"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example script</h3>
<p>The following script is modelled on the one from the <a href="https://polymake.org/doku.php/user_guide/tutorials/perl_intro" rel="nofollow">Using Perl within polymake</a> tutorial:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Polymake

str <span class="pl-k">=</span> <span class="pl-c1">read</span>(<span class="pl-s"><span class="pl-pds">"</span>points.demo<span class="pl-pds">"</span></span>, String)
<span class="pl-c"><span class="pl-c">#</span> eval/parse is a hack for Rational input, don't do this at home!</span>
matrix_str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>[<span class="pl-pds">"</span></span><span class="pl-k">*</span><span class="pl-c1">replace</span>(str, <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-s"><span class="pl-pds">"</span>//<span class="pl-pds">"</span></span>)<span class="pl-k">*</span><span class="pl-s"><span class="pl-pds">"</span>]<span class="pl-pds">"</span></span>
matrix <span class="pl-k">=</span> <span class="pl-c1">eval</span>(Meta<span class="pl-k">.</span><span class="pl-c1">parse</span>(matrix_str))
<span class="pl-c1">@show</span> matrix

p <span class="pl-k">=</span> polytope<span class="pl-k">.</span><span class="pl-c1">Polytope</span>(POINTS<span class="pl-k">=</span>matrix)

<span class="pl-c1">@show</span> p<span class="pl-k">.</span>FACETS <span class="pl-c"><span class="pl-c">#</span> polymake matrix of polymake rationals</span>
<span class="pl-c1">@show</span> polytope<span class="pl-k">.</span><span class="pl-c1">dim</span>(p) <span class="pl-c"><span class="pl-c">#</span> Julia Int64</span>
<span class="pl-c"><span class="pl-c">#</span> note that even in Polymake property DIM is "fake" -- it's actually a function</span>
<span class="pl-c1">@show</span> p<span class="pl-k">.</span>VERTEX_SIZES <span class="pl-c"><span class="pl-c">#</span> polymake array of ints</span>
<span class="pl-c1">@show</span> p<span class="pl-k">.</span>VERTICES

<span class="pl-k">for</span> (i, vsize) <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(p<span class="pl-k">.</span>VERTEX_SIZES)
  <span class="pl-k">if</span> vsize <span class="pl-k">==</span> polytope<span class="pl-k">.</span><span class="pl-c1">dim</span>(p)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$i</span> : <span class="pl-v">$(p<span class="pl-k">.</span>VERTICES[i,:])</span><span class="pl-pds">"</span></span>)
    <span class="pl-c"><span class="pl-c">#</span> $i will be shifted by one from the polymake version</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

simple_verts <span class="pl-k">=</span> [i <span class="pl-k">for</span> (i, vsize) <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(p<span class="pl-k">.</span>VERTEX_SIZES) <span class="pl-k">if</span> vsize <span class="pl-k">==</span> polytope<span class="pl-k">.</span><span class="pl-c1">dim</span>(p)] <span class="pl-c"><span class="pl-c">#</span> Julia vector of Int64s</span>

special_points <span class="pl-k">=</span> p<span class="pl-k">.</span>VERTICES[simple_verts, :] <span class="pl-c"><span class="pl-c">#</span> polymake Matrix of rationals</span>
<span class="pl-c1">@show</span> special_points;</pre></div>
<p>The script included (i.e. in running REPL execute <code>include("example_script.jl");</code>) produces the following output:</p>
<pre><code>matrix = Rational{Int64}[1//1 0//1 0//1 0//1; 1//1 1//16 1//4 1//16; 1//1 3//8 1//4 1//32; 1//1 1//4 3//8 1//32; 1//1 1//16 1//16 1//4; 1//1 1//32 3//8 1//4; 1//1 1//4 1//16 1//16; 1//1 1//32 1//4 3//8; 1//1 3//8 1//32 1//4; 1//1 1//4 1//32 3//8]
p.FACETS = pm::Matrix&lt;pm::Rational&gt;
0 -1 20/7 8/7
0 -1 20 -1
0 20/7 -1 8/7
0 20/7 8/7 -1
0 20 -1 -1
1 16/3 16/3 -20/3
0 8/7 20/7 -1
0 8/7 -1 20/7
1 16/3 -20/3 16/3
0 -1 -1 20
0 -1 8/7 20/7
1 -20/3 16/3 16/3
1 -32/21 -32/21 -32/21

(Polymake.Polytope).dim(p) = 3
p.VERTEX_SIZES = pm::Array&lt;int&gt;
9 3 4 4 3 4 3 4 4 4
p.VERTICES = pm::Matrix&lt;pm::Rational&gt;
1 0 0 0
1 1/16 1/4 1/16
1 3/8 1/4 1/32
1 1/4 3/8 1/32
1 1/16 1/16 1/4
1 1/32 3/8 1/4
1 1/4 1/16 1/16
1 1/32 1/4 3/8
1 3/8 1/32 1/4
1 1/4 1/32 3/8

2 : pm::Vector&lt;pm::Rational&gt;
1 1/16 1/4 1/16
5 : pm::Vector&lt;pm::Rational&gt;
1 1/16 1/16 1/4
7 : pm::Vector&lt;pm::Rational&gt;
1 1/4 1/16 1/16
special_points = pm::Matrix&lt;pm::Rational&gt;
1 1/16 1/4 1/16
1 1/16 1/16 1/4
1 1/4 1/16 1/16


</code></pre>
<p>As can be seen we show consecutive steps of computations: the input <code>matrix</code>, <code>FACETS</code>, then we ask for <code>VERTEX_SIZES</code>, which triggers the convex hull computation. Then we show vertices and print those corresponding to simple vertices. Finally we collect them in <code>special_points</code>.</p>
<p>Observe that a <code>polymake</code> matrix (<code>Polymake.Matrix</code>) implements julia abstract array interface: <code>p.VERTICES[2,:]</code> returns a <code>1</code>-dimensional slice (i.e. <code>Polymake.Vector</code>), while passing a set of indices (<code>p.VERTICES[special_points, :]</code>) returns a <code>2</code>-dimensional one.</p>
<h4><a id="user-content-notes" class="anchor" aria-hidden="true" href="#notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Notes:</h4>
<p>The same minor (up to permutation of rows) could be obtained by using sets: either julia or polymake ones. However since by default one can not index arrays with sets, we need to collect them first:</p>
<div class="highlight highlight-source-julia"><pre>simple_verts <span class="pl-k">=</span> <span class="pl-c1">Set</span>(i <span class="pl-k">for</span> (i, vsize) <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(p<span class="pl-k">.</span>VERTEX_SIZES) <span class="pl-k">if</span> vsize <span class="pl-k">==</span> polytope<span class="pl-k">.</span><span class="pl-c1">dim</span>(p)) <span class="pl-c"><span class="pl-c">#</span> Julia set of Int64s</span>

simple_verts <span class="pl-k">=</span> Polymake<span class="pl-k">.</span><span class="pl-c1">Set</span>(i <span class="pl-k">for</span> (i, vsize) <span class="pl-k">in</span> <span class="pl-c1">enumerate</span>(p<span class="pl-k">.</span>VERTEX_SIZES) <span class="pl-k">if</span> vsize <span class="pl-k">==</span> polytope<span class="pl-k">.</span><span class="pl-c1">dim</span>(p)) <span class="pl-c"><span class="pl-c">#</span> polymake set of longs</span>

special_points <span class="pl-k">=</span> p<span class="pl-k">.</span>VERTICES[<span class="pl-c1">collect</span>(simple_verts), :]</pre></div>
<h2><a id="user-content-polymake-syntax-translation" class="anchor" aria-hidden="true" href="#polymake-syntax-translation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Polymake syntax translation</h2>
<p>The following tables explain by example how to quickly translate <code>polymake</code> syntax to <code>Polymake.jl</code>.</p>
<h3><a id="user-content-variables" class="anchor" aria-hidden="true" href="#variables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Variables</h3>
<table>
<thead>
<tr>
<th>Polymake</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$p</code> (reference to 'scalar' variable)</td>
<td><code>p</code> (reference to any variable)</td>
</tr>
<tr>
<td><code>print $p;</code></td>
<td><code>print(p)</code> or <code>println(p)</code> or <code>@show p</code>, or just <code>p</code> in REPL</td>
</tr>
<tr>
<td><code>$i=5; $j=6;</code></td>
<td><code>i,j = 5,6</code> or <code>i=5; j=6</code><br> (<code>;</code> is needed for separation, can be used to suppress return value in REPL)</td>
</tr>
<tr>
<td><code>$s = $i + $j; print $s;</code></td>
<td><code>s = i + j</code></td>
</tr>
</tbody>
</table>
<h3><a id="user-content-arrays" class="anchor" aria-hidden="true" href="#arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Arrays</h3>
<table>
<thead>
<tr>
<th>Polymake</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear containers with random access</td>
<td>Linear containers with random access + all the algebra attached</td>
</tr>
<tr>
<td><code>@A = ("a", "b", "c");</code></td>
<td><code>A = ["a", "b", "c"]</code></td>
</tr>
<tr>
<td><code>$first = $A[0];</code><br>(<code>first</code> is equal to <code>a</code>)</td>
<td><code>first = A[1]</code><br>(note the <code>1</code>-based indexing!)</td>
</tr>
<tr>
<td><code>@A2 = (3,1,4,2);</code></td>
<td><code>A2 = [3,1,4,2]</code></td>
</tr>
<tr>
<td><code>print sort(@A2);</code><br>(a copy of <code>A2</code> is sorted)</td>
<td><code>println(sort(A2))</code><br>(to sort in place use <code>sort!(A2))</code></td>
</tr>
<tr>
<td><code>$arr = new Array&lt;Int&gt;([3,2,5]);</code> <br>(a <code>C++</code> object)</td>
<td><code>arr = [3,2,5]</code><br>(the <code>Int</code> type is inferred)</td>
</tr>
<tr>
<td><code>$arr-&gt;[0] = 100;</code><br>(assignment)</td>
<td><code>arr[1] = 100</code><br>(assignment; returns <code>100</code>)</td>
</tr>
</tbody>
</table>
<h3><a id="user-content-dictionarieshash-tables" class="anchor" aria-hidden="true" href="#dictionarieshash-tables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dictionaries/Hash Tables</h3>
<table>
<thead>
<tr>
<th>Polymake</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%h = ();</code></td>
<td><code>h = Dict()</code><br>it is <strong>MUCH</strong> better to provide types e.g.<br><code>h = Dict{String, Int}()</code></td>
</tr>
<tr>
<td><code>$h{"zero"}=0; $h{"four"}=4;</code></td>
<td><code>h["zero"] = 0; h["four"] = 4</code><br>(call returns the value)</td>
</tr>
<tr>
<td><code>print keys %h;</code></td>
<td><code>@show keys(h)</code> (NOTE: order is not specified)</td>
</tr>
<tr>
<td><code>print join(", ",keys %hash);</code></td>
<td><code>join(keys(h), ", ")</code><br>(returns <code>String</code>)</td>
</tr>
<tr>
<td><code>%hash=("one",1,"two",2);</code></td>
<td><code>Dict([("one",1), ("two",2)])</code><br>(will infer types)</td>
</tr>
<tr>
<td><code>%hash=("one"=&gt;1,"two"=&gt;2);</code></td>
<td><code>Dict("one"=&gt;1,"two"=&gt;2)</code></td>
</tr>
</tbody>
</table>
<h3><a id="user-content-sets" class="anchor" aria-hidden="true" href="#sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Sets</h3>
<table>
<thead>
<tr>
<th>Polymake</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr>
<td>Balanced binary search trees</td>
<td>Hash table with no content</td>
</tr>
<tr>
<td><code>$set=new Set&lt;Int&gt;(3,2,5,3);</code></td>
<td><code>set = Set{Int}([3,2,5,3])</code></td>
</tr>
<tr>
<td><code>print $set-&gt;size;</code></td>
<td><code>length(set)</code></td>
</tr>
<tr>
<td><code>@array_from_set=@$set</code></td>
<td><code>collect(set)</code><br>(NOTE: this creates a <code>Vector</code>, but order is NOT specified)</td>
</tr>
</tbody>
</table>
<h3><a id="user-content-matrices" class="anchor" aria-hidden="true" href="#matrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Matrices</h3>
<table>
<thead>
<tr>
<th>Polymake</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new Matrix&lt;T&gt;</code> <br>Container with algebraic operations</td>
<td><code>Matrix{T} = Array{T, 2}</code><br><strong>Linear</strong> container with available indexing by <code>2</code>-ples; all algebra attached</td>
</tr>
<tr>
<td><code>$mat=new Matrix&lt;Rational&gt;([[2,1,4,0,0],[3,1,5,2,1],[1,0,4,0,6]]);</code><br><code>$row1=new Vector&lt;Rational&gt;([2,1,4,0,0]);</code><br><code>$row2=new Vector&lt;Rational&gt;([3,1,5,2,1]);</code><br><code>$row3=new Vector&lt;Rational&gt;([1,0,4,0,6]);</code><br><code>@matrix_rows=($row1,$row2,$row3);</code>(<code>Perl</code> object)<br><code>$matrix_from_array=new Matrix&lt;Rational&gt;(\@matrix_rows);</code>(<code>C++</code> object)</td>
<td><code>mat = Rational{Int}[2 1 4 0 0; 3 1 5 2 1; 1 0 4 0 6];</code><br><code>row1 = Rational{Int}[2, 1, 4, 0, 0];</code><br><code>row2 = Rational{Int}[3, 1, 5, 2, 1];</code><br><code>row3 = Rational{Int}[1, 0, 4, 0, 6];</code><br><code>matrix_rows = hcat(row1', row2', row3')</code><br>(Julia stores matrices in <strong>column major</strong> format, so <code>'</code> i.e. transposition is needed)</td>
</tr>
<tr>
<td><code>$mat-&gt;row(1)-&gt;[1]=7; $mat-&gt;elem(1,2)=8;</code></td>
<td><code>mat[2,2] = 7; mat[2,3] = 8</code></td>
</tr>
<tr>
<td><code>$unit_mat=4*unit_matrix&lt;Rational&gt;(3);</code></td>
<td><code>unit_mat = Diagonal([4//1 for i in 1:3])</code> or <code>UniformScaling(4//1)</code><br>depending on application; both require <code>using LinearAlgebra</code></td>
</tr>
<tr>
<td><code>$dense=new Matrix&lt;Rational&gt;($unit_mat);</code><br><code>$m_rat=new Matrix&lt;Rational&gt;(3/5*unit_matrix&lt;Rational&gt;(5));</code><br><code>$m2=$mat/$m_rat;</code><br><code>$m_int=new Matrix&lt;Int&gt;(unit_matrix&lt;Rational&gt;(5));</code><br><code>$m3=$m_rat/$m_int;</code><br>(results in an error due to incompatible types)</td>
<td><code>Array(unit_mat)</code><br><code>m_rat = Diagonal([3//5 for i in 1:5])</code><br><code>m2 = mat/m_rat</code><br><code>m_int = Diagonal([1 for i in 1:5])</code><br><code>m_rat/m_int</code><br>(succeeds due to <code>promote</code> happening in <code>/</code>)</td>
</tr>
<tr>
<td><code>convert_to&lt;Rational&gt;($m_int)</code><br><code>$z_vec=zero_vector&lt;Int&gt;($m_int-&gt;rows)</code><br><code>$extended_matrix=($z_vec|$m_int);</code><br>(adds <code>z_vec</code> as the first column, result is dense)</td>
<td><code>convert(Diagonal{Rational{Int}}, m_int)</code><br><code>z_vec = zeros(Int, size(m_int, 1))</code><br><code>extended_matrix = hcat(z_vec, m_int)</code><br>(result is sparse)</td>
</tr>
<tr>
<td><code>$set=new Set&lt;Int&gt;(3,2,5);</code><br><code>$template_Ex=new Array&lt;Set&lt;Int&gt;&gt;((new Set&lt;Int&gt;(5,2,6)),$set)</code></td>
<td><code>set = Set([3,2,5]);</code><br> <code>template_Ex = [Set([5,2,6]), set]</code></td>
</tr>
</tbody>
</table>
<h3><a id="user-content-big-objects--properties" class="anchor" aria-hidden="true" href="#big-objects--properties"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Big objects &amp; properties:</h3>
<table>
<thead>
<tr>
<th>Polymake</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$p=new Polytope&lt;Rational&gt;(POINTS=&gt;cube(4)-&gt;VERTICES);</code></td>
<td><code>p = polytope.Polytope(POINTS=polytope.cube(4).VERTICES)</code></td>
</tr>
<tr>
<td><code>$lp=new LinearProgram&lt;Rational&gt;(LINEAR_OBJECTIVE=&gt;[0,1,1,1,1]);</code></td>
<td><code>lp = polytope.LinearProgram(LINEAR_OBJECTIVE=[0,1,1,1,1])</code></td>
</tr>
<tr>
<td><code>$p-&gt;LP=$lp;</code><br><code>$p-&gt;LP-&gt;MAXIMAL_VALUE;</code></td>
<td><code>p.LP = lp</code><br><code>p.LP.MAXIMAL_VALUE</code></td>
</tr>
<tr>
<td><code>$i = ($p-&gt;N_FACETS * $p-&gt;N_FACETS) * 15;</code></td>
<td><code>i = (p.N_FACETS * p.N_FACETS) * 15</code></td>
</tr>
<tr>
<td><code>$print p-&gt;DIM;</code></td>
<td><code>polytope.dim(p)</code><br> <code>DIM</code> is actually a faux property, which hides a function beneath</td>
</tr>
<tr>
<td><code>application "topaz";</code><br><code>$p = new Polytope&lt;Max, QuadraticExtension&gt;(POINTS=&gt;[[1,0,0], [1,1,0], [1,1,1]]);</code></td>
<td><code>p = @pm tropical.Polytope{Max, QuadraticExtension}(POINTS=[1 0 0; 1 1 0; 1 1 1])</code><br> more information on the @pm macro can be found below</td>
</tr>
</tbody>
</table>
<h2><a id="user-content-current-state-of-the-polymake-wrapper" class="anchor" aria-hidden="true" href="#current-state-of-the-polymake-wrapper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Current state of the <code>polymake</code> wrapper</h2>
<h3><a id="user-content-data-structures" class="anchor" aria-hidden="true" href="#data-structures"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Data structures</h3>
<ul>
<li>Big objects, e.g., Polytopes, can be handled in Julia.</li>
<li>Several small objects (data types) from <code>polymake</code> are available in <code>Polymake.jl</code>:
<ul>
<li>Integers (<code>Polymake.Integer &lt;: Integer</code>)</li>
<li>Rationals (<code>Polymake.Rational &lt;: Real</code>)</li>
<li>Vectors (<code>Polymake.Vector &lt;: AbstractVector</code>) of <code>Int64</code>s, <code>Float64</code>s, <code>Polymake.Integer</code>s and <code>Polymake.Rational</code>s</li>
<li>Matrices (<code>Polymake.Matrix &lt;: AbstractMatrix</code>) of <code>Int64</code>s, <code>Float64</code>s, <code>Polymake.Integer</code>s and <code>Polymake.Rational</code>s</li>
<li>Sets (<code>Polymake.Set &lt;: AbstractSet</code>) of <code>Int64</code>s</li>
<li>Arrays (<code>Polymake.Array &lt;: AbstractVector</code>, as <code>Polymake.Arrays</code> are one-dimensional) of <code>Int64</code>s and <code>Polymake.Integers</code></li>
<li>some combinations thereof, e.g., <code>Polymake.Array</code>s of <code>Polymake.Sets</code> of <code>Int32</code>s.</li>
</ul>
</li>
</ul>
<p>These data types can be converted to appropriate Julia types,
but are also subtypes of the corresponding Julia abstract types (as indicated above),
and so should be accepted by all methods that apply to the abstract types.</p>
<p><strong>Note</strong>: If the returned small object has not been wrapped in <code>Polymake.jl</code>
yet, you will not be able to access its content or in general use it <strong>from Julia</strong>,
however you can always pass it back as an argument to a <code>polymake</code> function.
Moreover you may try to convert to Julia understandable type via macro
<code>@convert_to SomeType{Template, Names} obj</code>.</p>
<h3><a id="user-content-functions" class="anchor" aria-hidden="true" href="#functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functions</h3>
<ul>
<li>All user functions from <code>polymake</code> are available in the appropriate modules, e.g. <code>homology</code> function from <code>topaz</code> can be called as <code>topaz.homology(...)</code> in julia. We pull the docstrings for functions from <code>polymake</code> as well, so <code>?topaz.homology</code> (in Julia's REPL) returns the <code>polymake</code> docstring. Note: the syntax presented in the docstring is a <code>polymake</code> syntax, not <code>Polymake.jl</code> one.</li>
<li>Most of the user functions from <code>polymake</code> are available as <code>appname.funcname(...)</code> in <code>Polymake.jl</code>.  Moreover, any function from <code>polymake</code> <code>C++</code> library can be called via macro call <code>@pm appname.funcname{C++{template, names}}(...)</code>.</li>
<li>All big objects of <code>polymake</code> can be constructed either via call to constructor, i.e.</li>
</ul>
<div class="highlight highlight-source-julia"><pre>obj <span class="pl-k">=</span> appname<span class="pl-k">.</span><span class="pl-c1">BigObject</span>(args)</pre></div>
<p>One can specify some templates here as well: <code>polytope.Polytope{Float64}(...)</code> is a valid call, but the list of supported types is rather limited. Please consider filing a bug if a valid call results in <code>polymake</code> error.
For more advanced use see section on <code>@pm</code> macro.</p>
<ul>
<li>Properties of big objects are accessible by <code>bigobject.property</code> syntax (as opposed to <code>$bigobject-&gt;property</code> in <code>polymake</code>). If there is a missing property please check if it can be accessed by <code>appname.property(object)</code>. For example <code>polytope.Polytope</code> does not have <code>DIM</code> property in <code>Polymake.jl</code> sinc <code>DIM</code> is exposed as <code>polytope.dim(...)</code> function.</li>
<li>Methods are available as functions in the appropriate modules, with the first argument as the object, i.e. <code>$bigobj-&gt;methodname(...)</code> can be called via <code>appname.methodname(bigobj, ...)</code></li>
<li>A function in <code>Polymake.jl</code> calling <code>polymake</code> may return a big or small object, and the generic return (<code>PropertyValue</code>) is transparently converted to one of the known data types. This conversion can be deactivated by adding <code>keep_PropertyValue=true</code> keyword argument to function/method call.</li>
</ul>
<h3><a id="user-content-pm-macro" class="anchor" aria-hidden="true" href="#pm-macro"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>@pm</code> macro</h3>
<p>The <code>@pm</code> macro can be used to issue more complicated calls to polymake from julia.
If You need to pass templates to <code>BigObject</code>s, some limited support is provided in costructors.
For example one can construct <code>polytope.Polytope{Float64}(...)</code>.
However for this to work templates need to be valid julia types/object, hence
it is not possible to construct a <code>Polytope&lt;QuadraticExtension&gt;</code> through such call.
For this (and in general: for passing more complicated templates) one needs the
<code>@pm</code> macro:</p>
<div class="highlight highlight-source-perl"><pre><span class="pl-smi">$obj</span> = new BigObject&lt;Template,Parameters&gt;(args)</pre></div>
<p>becomes</p>
<div class="highlight highlight-source-julia"><pre>obj <span class="pl-k">=</span> <span class="pl-c1">@pm</span> appname<span class="pl-k">.</span><span class="pl-c1">BigObject</span><span class="pl-c1">{Template, Parameters}</span>(args)</pre></div>
<p>Examples:</p>
<div class="highlight highlight-source-julia"><pre>tropical<span class="pl-k">.</span><span class="pl-c1">Polytope</span><span class="pl-c1">{max, Polymake.Rational}</span>(POINTS<span class="pl-k">=</span>[<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>; <span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span>; <span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>])
<span class="pl-c"><span class="pl-c">#</span> call to constructor, note that max is a julia function, hence a valid object</span>
<span class="pl-c1">@pm</span> tropical<span class="pl-k">.</span><span class="pl-c1">Polytope</span><span class="pl-c1">{Max, QuadraticExtension}</span>(POINTS<span class="pl-k">=</span>[<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>; <span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span>; <span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>])
<span class="pl-c"><span class="pl-c">#</span> macro call: none of the types in templates need to exist in julia</span></pre></div>
<p>As a rule of thumb any template passed to <code>@pm</code> macro needs to be translatable
on syntax level to a <code>C++</code> one. E.g. <code>Matrix{Integer}</code> works, as it translates to
<code>pm::Matrix&lt;pm::Integer&gt;</code>.</p>
<p>Such templates can be passed to functions as well. A very useful example is the
<code>common.convert_to</code>:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> c <span class="pl-k">=</span> polytope<span class="pl-k">.</span><span class="pl-c1">cube</span>(<span class="pl-c1">3</span>);

julia<span class="pl-k">&gt;</span> f <span class="pl-k">=</span> c<span class="pl-k">.</span>FACETS;

julia<span class="pl-k">&gt;</span> f[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> f is an opaque pm::perl::PropertyValue to julia</span>
ERROR<span class="pl-k">:</span> MethodError<span class="pl-k">:</span> no method matching <span class="pl-c1">getindex</span>(<span class="pl-k">::</span><span class="pl-c1">Polymake.PropertyValueAllocated</span>, <span class="pl-k">::</span><span class="pl-c1">Int64</span>, <span class="pl-k">::</span><span class="pl-c1">Int64</span>)
Stacktrace<span class="pl-k">:</span>
  [<span class="pl-k">...</span>]

julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> <span class="pl-c1">@pm</span> common<span class="pl-k">.</span><span class="pl-c1">convert_to</span><span class="pl-c1">{Matrix{Integer}}</span>(f) <span class="pl-c"><span class="pl-c">#</span> the template must consist of C++ names</span>
pm<span class="pl-k">::</span><span class="pl-c1">Matrix</span><span class="pl-k">&lt;</span>pm<span class="pl-k">::</span><span class="pl-c1">Integer</span><span class="pl-k">&gt;</span>
<span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> m[<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]
<span class="pl-c1">1</span></pre></div>
<p>Since the combination of the <code>@pm</code> macro and <code>common.convert_to</code> is quite common there is a
specialized <code>@convert_to</code> macro for this:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> m <span class="pl-k">=</span> <span class="pl-c1">@convert_to</span> Matrix{Integer} f <span class="pl-c"><span class="pl-c">#</span> the template must consist of C++ names</span>
pm<span class="pl-k">::</span><span class="pl-c1">Matrix</span><span class="pl-k">&lt;</span>pm<span class="pl-k">::</span><span class="pl-c1">Integer</span><span class="pl-k">&gt;</span>
<span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">0</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span>
<span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span> <span class="pl-k">-</span><span class="pl-c1">1</span></pre></div>
<h3><a id="user-content-function-arguments" class="anchor" aria-hidden="true" href="#function-arguments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Function Arguments</h3>
<p>Functions in <code>Polymake.jl</code> accept the following types for their arguments:</p>
<ul>
<li>simple data types (bools, machine integers, floats)</li>
<li>wrapped native types (<code>Polymake.Integer</code>, <code>Polymake.Rational</code>, <code>Polymake.Vector</code>, <code>Polymake.Matrix</code>, <code>Polymake.Set</code> etc.)</li>
<li>other objects returned by polymake:
<ul>
<li><code>Polymake.BigObject</code>,</li>
<li><code>Polymake.PropertyValue</code> (containers opaque to Julia)</li>
</ul>
</li>
</ul>
<p>If an object passed to <code>Polymake.jl</code> function is of a different type the software will try its best to convert it to a known one. However, if the conversion doesn't work an <code>ArgumentError</code> will be thrown:</p>
<div class="highlight highlight-source-julia"><pre>ERROR<span class="pl-k">:</span> ArgumentError<span class="pl-k">:</span> Unrecognized argument type<span class="pl-k">:</span> SomeType.
You need to convert to polymake compatible type first.</pre></div>
<p>You can tell <code>Polymake.jl</code> how to convert it by definig</p>
<div class="highlight highlight-source-julia"><pre>Base<span class="pl-k">.</span><span class="pl-c1">convert</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Polymake.PolymakeType}</span>, x<span class="pl-k">::</span><span class="pl-c1">SomeType</span>)</pre></div>
<p>The returned value must be of one of the types as above. For example to use <code>AbstractAlgebra.jl</code> matrices as input to <code>Polymake.jl</code> one may define</p>
<div class="highlight highlight-source-julia"><pre>Base<span class="pl-k">.</span><span class="pl-en">convert</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Polymake.PolymakeType}</span>, M<span class="pl-k">::</span><span class="pl-c1">Generic.MatSpaceElem</span>) <span class="pl-k">=</span> Polymake<span class="pl-k">.</span><span class="pl-c1">Matrix</span>(M<span class="pl-k">.</span>entries)</pre></div>
<p>and the following should run smoothly.</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> AbstractAlgebra, Polymake
polymake version <span class="pl-c1">4.0</span>
Copyright (c) <span class="pl-c1">1997</span><span class="pl-k">-</span><span class="pl-c1">2020</span>
Ewgenij Gawrilow, Michael Joswig (TU Berlin)
https<span class="pl-k">:</span><span class="pl-k">//</span>polymake<span class="pl-k">.</span>org

This is free software licensed under GPL; see the source <span class="pl-k">for</span> copying conditions.
There is NO warranty; not even <span class="pl-k">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


julia<span class="pl-k">&gt;</span> mm <span class="pl-k">=</span> AbstractAlgebra<span class="pl-k">.</span><span class="pl-c1">matrix</span>(ZZ, [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>; <span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span>])
[<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>]
[<span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span>]

julia<span class="pl-k">&gt;</span> polytope<span class="pl-k">.</span><span class="pl-c1">Polytope</span>(POINTS<span class="pl-k">=</span>mm)
ERROR<span class="pl-k">:</span> ArgumentError<span class="pl-k">:</span> Unrecognized argument type<span class="pl-k">:</span> AbstractAlgebra<span class="pl-k">.</span>Generic<span class="pl-k">.</span>MatSpaceElem{Int64}.
You need to convert to polymake compatible type first.
  [<span class="pl-k">...</span>]

julia<span class="pl-k">&gt;</span> Base<span class="pl-k">.</span><span class="pl-en">convert</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Polymake.PolymakeType}</span>, M<span class="pl-k">::</span><span class="pl-c1">Generic.MatSpaceElem</span>) <span class="pl-k">=</span> Polymake<span class="pl-k">.</span><span class="pl-c1">Matrix</span>(M<span class="pl-k">.</span>entries)

julia<span class="pl-k">&gt;</span> polytope<span class="pl-k">.</span><span class="pl-c1">Polytope</span>(POINTS<span class="pl-k">=</span>mm)
type<span class="pl-k">:</span> Polytope<span class="pl-k">&lt;</span>Rational<span class="pl-k">&gt;</span>

POINTS
<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>
<span class="pl-c1">1</span> <span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">4</span> <span class="pl-c1">3</span><span class="pl-k">/</span><span class="pl-c1">2</span>
</pre></div>
<h2><a id="user-content-funding" class="anchor" aria-hidden="true" href="#funding"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Funding</h2>
<p>The development of this Julia package is supported by the Deutsche
Forschungsgemeinschaft DFG within the
<a href="https://www.computeralgebra.de/sfb/" rel="nofollow">Collaborative Research Center TRR 195</a>.</p>
</article></div>