<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-gaugefields" class="anchor" aria-hidden="true" href="#gaugefields"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Gaugefields</h1>
<p dir="auto"><a href="https://github.com/akio-tomiya/Gaugefields.jl/actions/workflows/CI.yml"><img src="https://github.com/akio-tomiya/Gaugefields.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://akio-tomiya.github.io//Gaugefields.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-abstract" class="anchor" aria-hidden="true" href="#abstract"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Abstract</h1>
<p dir="auto">This is a package for lattice QCD codes.
Treating gauge fields (links), gauge actions with MPI and autograd.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="LQCDjl_block.png"><img src="LQCDjl_block.png" width="300" style="max-width: 100%;"></a></p> 
<p dir="auto">This package will be used in <a href="https://github.com/akio-tomiya/LatticeQCD.jl">LatticeQCD.jl</a>.</p>
<h1 dir="auto"><a id="user-content-what-this-package-can-do" class="anchor" aria-hidden="true" href="#what-this-package-can-do"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What this package can do:</h1>
<p dir="auto">This package has following functionarities</p>
<ul dir="auto">
<li>SU(Nc) (Nc &gt; 1) gauge fields in 2 or 4 dimensions with arbitrary actions.</li>
<li>U(1) gauge fields in 2 dimensions with arbitrary actions.</li>
<li>Configuration generation
<ul dir="auto">
<li>Heatbath</li>
<li>quenched Hybrid Monte Carlo</li>
</ul>
</li>
<li>Gradient flow via RK3</li>
<li>I/O: ILDG and Bridge++ formats are supported (<a href="https://usqcd-software.github.io/c-lime/" rel="nofollow">c-lime</a> will be installed implicitly with <a href="https://github.com/JuliaBinaryWrappers/CLIME_jll.jl">CLIME_jll</a> )</li>
<li>MPI parallel computation (experimental. See documents.)</li>
</ul>
<p dir="auto">Dynamical fermions will be supported with <a href="https://github.com/akio-tomiya/LatticeDiracOperators.jl">LatticeDiracOperators.jl</a>.</p>
<p dir="auto">In addition, this supports followings</p>
<ul dir="auto">
<li><strong>Autograd for functions with SU(Nc) variables</strong></li>
<li>Stout smearing (exp projecting smearing)</li>
<li>Stout force via <a href="https://arxiv.org/abs/2103.11965" rel="nofollow">backpropagation</a></li>
</ul>
<p dir="auto">Autograd can be worked for general Wilson lines except for ones have overlaps.</p>
<h1 dir="auto"><a id="user-content-install" class="anchor" aria-hidden="true" href="#install"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Install</h1>
<p dir="auto">In Julia REPL in the package mode,</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add Gaugefields.jl"><pre class="notranslate"><code>add Gaugefields.jl
</code></pre></div>
<h1 dir="auto"><a id="user-content-how-to-use" class="anchor" aria-hidden="true" href="#how-to-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use</h1>
<h2 dir="auto"><a id="user-content-file-loading" class="anchor" aria-hidden="true" href="#file-loading"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File loading</h2>
<h2 dir="auto"><a id="user-content-ildg-format" class="anchor" aria-hidden="true" href="#ildg-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ILDG format</h2>
<p dir="auto"><a href="https://www-zeuthen.desy.de/~pleiter/ildg/ildg-file-format-1.1.pdf" rel="nofollow">ILDG</a> format is one of standard formats for LatticeQCD configurations.</p>
<p dir="auto">We can read ILDG format like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="NX = 4
NY = 4
NZ = 4
NT = 4
Nwing = 1
Dim = 4

U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)

ildg = ILDG(filename)
i = 1
L = [NX,NY,NZ,NT]
load_gaugefield!(U,i,ildg,L,NC)"><pre>NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>

U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)

ildg <span class="pl-k">=</span> <span class="pl-c1">ILDG</span>(filename)
i <span class="pl-k">=</span> <span class="pl-c1">1</span>
L <span class="pl-k">=</span> [NX,NY,NZ,NT]
<span class="pl-c1">load_gaugefield!</span>(U,i,ildg,L,NC)</pre></div>
<p dir="auto">Then, we can calculate the plaquette:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="temp1 = similar(U[1])
temp2 = similar(U[1])

comb = 6
factor = 1/(comb*U[1].NV*U[1].NC)
@time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
println(&quot;plaq_t = $plaq_t&quot;)
poly = calculate_Polyakov_loop(U,temp1,temp2) 
println(&quot;polyakov loop = $(real(poly)) $(imag(poly))&quot;)"><pre>temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
<span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">We can write a configuration as the ILDG format like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filename = &quot;hoge.ildg&quot;
save_binarydata(U,filename)"><pre>filename <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hoge.ildg<span class="pl-pds">"</span></span>
<span class="pl-c1">save_binarydata</span>(U,filename)</pre></div>
<h2 dir="auto"><a id="user-content-text-format-for-bridge" class="anchor" aria-hidden="true" href="#text-format-for-bridge"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Text format for Bridge++</h2>
<p dir="auto">Gaugefields.jl also supports a text format for <a href="https://bridge.kek.jp/Lattice-code/index_e.html" rel="nofollow">Bridge++</a>.</p>
<h3 dir="auto"><a id="user-content-file-loading-1" class="anchor" aria-hidden="true" href="#file-loading-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File loading</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filename = &quot;testconf.txt&quot;
load_BridgeText!(filename,U,L,NC)"><pre>filename <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>testconf.txt<span class="pl-pds">"</span></span>
<span class="pl-c1">load_BridgeText!</span>(filename,U,L,NC)</pre></div>
<h3 dir="auto"><a id="user-content-file-saving" class="anchor" aria-hidden="true" href="#file-saving"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File saving</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filename = &quot;testconf.txt&quot;
save_textdata(U,filename)"><pre>filename <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>testconf.txt<span class="pl-pds">"</span></span>
<span class="pl-c1">save_textdata</span>(U,filename)</pre></div>
<h2 dir="auto"><a id="user-content-heatbath-updates-even-odd-method" class="anchor" aria-hidden="true" href="#heatbath-updates-even-odd-method"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Heatbath updates (even-odd method)</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields


function heatbath_SU3!(U,NC,temps,β)
    Dim = 4
    temp1 = temps[1]
    temp2 = temps[2]
    V = temps[3]
    ITERATION_MAX = 10^5

    temps2 = Array{Matrix{ComplexF64},1}(undef,5) 
    temps3 = Array{Matrix{ComplexF64},1}(undef,5) 
    for i=1:5
        temps2[i] = zeros(ComplexF64,2,2)
        temps3[i] = zeros(ComplexF64,NC,NC)
    end


    mapfunc!(A,B) = SU3update_matrix!(A,B,β,NC,temps2,temps3,ITERATION_MAX)

    for μ=1:Dim

        loops = loops_staple[(Dim,μ)]
        iseven = true

        evaluate_gaugelinks_evenodd!(V,loops,U,[temp1,temp2],iseven)
        map_U!(U[μ],mapfunc!,V,iseven) 

        iseven = false
        evaluate_gaugelinks_evenodd!(V,loops,U,[temp1,temp2],iseven)
        map_U!(U[μ],mapfunc!,V,iseven) 
    end
    
end

function heatbathtest_4D(NX,NY,NZ,NT,β,NC)
    Dim = 4
    Nwing = 1

    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)

    temp1 = similar(U[1])
    temp2 = similar(U[1])
    temp3 = similar(U[1])

    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot;plaq_t = $plaq_t&quot;)
    poly = calculate_Polyakov_loop(U,temp1,temp2) 
    println(&quot;polyakov loop = $(real(poly)) $(imag(poly))&quot;)

    numhb = 40
    for itrj = 1:numhb
        heatbath_SU3!(U,NC,[temp1,temp2,temp3],β)

        if itrj % 10 == 0
            @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
            println(&quot;$itrj plaq_t = $plaq_t&quot;)
            poly = calculate_Polyakov_loop(U,temp1,temp2) 
            println(&quot;$itrj polyakov loop = $(real(poly)) $(imag(poly))&quot;)
        end
    end
    

    return plaq_t

end

NX = 4
NY = 4
NZ = 4
NT = 4
Nwing = 1

β = 5.7
NC = 3
@time plaq_t = heatbathtest_4D(NX,NY,NZ,NT,β,NC)"><pre><span class="pl-k">using</span> Gaugefields


<span class="pl-k">function</span> <span class="pl-en">heatbath_SU3!</span>(U,NC,temps,β)
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    V <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    ITERATION_MAX <span class="pl-k">=</span> <span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">5</span>

    temps2 <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{Matrix{ComplexF64},1}</span>(undef,<span class="pl-c1">5</span>) 
    temps3 <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{Matrix{ComplexF64},1}</span>(undef,<span class="pl-c1">5</span>) 
    <span class="pl-k">for</span> i<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>
        temps2[i] <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(ComplexF64,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)
        temps3[i] <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(ComplexF64,NC,NC)
    <span class="pl-k">end</span>


    <span class="pl-en">mapfunc!</span>(A,B) <span class="pl-k">=</span> <span class="pl-c1">SU3update_matrix!</span>(A,B,β,NC,temps2,temps3,ITERATION_MAX)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim

        loops <span class="pl-k">=</span> loops_staple[(Dim,μ)]
        iseven <span class="pl-k">=</span> <span class="pl-c1">true</span>

        <span class="pl-c1">evaluate_gaugelinks_evenodd!</span>(V,loops,U,[temp1,temp2],iseven)
        <span class="pl-c1">map_U!</span>(U[μ],mapfunc!,V,iseven) 

        iseven <span class="pl-k">=</span> <span class="pl-c1">false</span>
        <span class="pl-c1">evaluate_gaugelinks_evenodd!</span>(V,loops,U,[temp1,temp2],iseven)
        <span class="pl-c1">map_U!</span>(U[μ],mapfunc!,V,iseven) 
    <span class="pl-k">end</span>
    
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">heatbathtest_4D</span>(NX,NY,NZ,NT,β,NC)
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>

    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)

    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp3 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
    poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)

    numhb <span class="pl-k">=</span> <span class="pl-c1">40</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numhb
        <span class="pl-c1">heatbath_SU3!</span>(U,NC,[temp1,temp2,temp3],β)

        <span class="pl-k">if</span> itrj <span class="pl-k">%</span> <span class="pl-c1">10</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
            <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
            poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    

    <span class="pl-k">return</span> plaq_t

<span class="pl-k">end</span>

NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>

β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
<span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">heatbathtest_4D</span>(NX,NY,NZ,NT,β,NC)</pre></div>
<h2 dir="auto"><a id="user-content-heatbath-updates-with-general-actions" class="anchor" aria-hidden="true" href="#heatbath-updates-with-general-actions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Heatbath updates with general actions</h2>
<p dir="auto">We can do heatbath updates with a general action.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields

function heatbathtest_4D(NX,NY,NZ,NT,β,NC)
    Dim = 4
    Nwing = 1

    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)
    println(typeof(U))

    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;,Dim=Dim)
    append!(plaqloop,plaqloop')
    βinp = β/2
    push!(gauge_action,βinp,plaqloop)

    rectloop = make_loops_fromname(&quot;rectangular&quot;,Dim=Dim)
    append!(rectloop,rectloop')
    βinp = β/2
    push!(gauge_action,βinp,rectloop)

    hnew = Heatbath_update(U,gauge_action)

    show(gauge_action)

    temp1 = similar(U[1])
    temp2 = similar(U[1])
    temp3 = similar(U[1])

    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot;plaq_t = $plaq_t&quot;)
    poly = calculate_Polyakov_loop(U,temp1,temp2) 
    println(&quot;polyakov loop = $(real(poly)) $(imag(poly))&quot;)

    numhb = 1000
    for itrj = 1:numhb

        heatbath!(U,hnew)

        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        poly = calculate_Polyakov_loop(U,temp1,temp2) 

        if itrj % 40 == 0
            println(&quot;$itrj plaq_t = $plaq_t&quot;)
            println(&quot;$itrj polyakov loop = $(real(poly)) $(imag(poly))&quot;)
        end
    end
    
    close(fp)
    return plaq_t

end

NX = 4
NY = 4
NZ = 4
NT = 4
NC = 3
β = 5.7
heatbathtest_4D(NX,NY,NZ,NT,β,NC)"><pre><span class="pl-k">using</span> Gaugefields

<span class="pl-k">function</span> <span class="pl-en">heatbathtest_4D</span>(NX,NY,NZ,NT,β,NC)
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>

    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-c1">typeof</span>(U))

    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>,Dim<span class="pl-k">=</span>Dim)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)
    βinp <span class="pl-k">=</span> β<span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,βinp,plaqloop)

    rectloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>rectangular<span class="pl-pds">"</span></span>,Dim<span class="pl-k">=</span>Dim)
    <span class="pl-c1">append!</span>(rectloop,rectloop<span class="pl-k">'</span>)
    βinp <span class="pl-k">=</span> β<span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,βinp,rectloop)

    hnew <span class="pl-k">=</span> <span class="pl-c1">Heatbath_update</span>(U,gauge_action)

    <span class="pl-c1">show</span>(gauge_action)

    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp3 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
    poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)

    numhb <span class="pl-k">=</span> <span class="pl-c1">1000</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numhb

        <span class="pl-c1">heatbath!</span>(U,hnew)

        plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
        poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 

        <span class="pl-k">if</span> itrj <span class="pl-k">%</span> <span class="pl-c1">40</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    
    <span class="pl-c1">close</span>(fp)
    <span class="pl-k">return</span> plaq_t

<span class="pl-k">end</span>

NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
<span class="pl-c1">heatbathtest_4D</span>(NX,NY,NZ,NT,β,NC)</pre></div>
<p dir="auto">In this code, we consider the plaquette and rectangular actions.</p>
<h2 dir="auto"><a id="user-content-gradient-flow" class="anchor" aria-hidden="true" href="#gradient-flow"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Gradient flow</h2>
<p dir="auto">We can use Lüscher's gradient flow.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="NX = 4
NY = 4
NZ = 4
NT = 4
Nwing = 1
NC = 3

U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;)

temp1 = similar(U[1])
temp2 = similar(U[1])
temp3 = similar(U[1])

comb = 6
factor = 1/(comb*U[1].NV*U[1].NC)

g = Gradientflow(U)
for itrj=1:100
    flow!(U,g)
    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot;$itrj plaq_t = $plaq_t&quot;)
    poly = calculate_Polyakov_loop(U,temp1,temp2) 
    println(&quot;$itrj polyakov loop = $(real(poly)) $(imag(poly))&quot;)
end
"><pre>NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>)

temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
temp3 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)

g <span class="pl-k">=</span> <span class="pl-c1">Gradientflow</span>(U)
<span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>
    <span class="pl-c1">flow!</span>(U,g)
    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
    poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
</pre></div>
<h2 dir="auto"><a id="user-content-hybrid-monte-carlo" class="anchor" aria-hidden="true" href="#hybrid-monte-carlo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hybrid Monte Carlo</h2>
<p dir="auto">We can do the HMC simulations. The example code is as follows.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
using Random
using Gaugefields
using LinearAlgebra

function calc_action(gauge_action,U,p)
    NC = U[1].NC
    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_Gauge_action(gauge_action,U) = tr(evaluate_Gaugeaction_untraced(gauge_action,U))
    Sp = p*p/2
    S = Sp + Sg
    return real(S)
end

function MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)
    Δτ = 1/MDsteps
    gauss_distribution!(p)
    Sold = calc_action(gauge_action,U,p)
    substitute_U!(Uold,U)

    for itrj=1:MDsteps
        U_update!(U,p,0.5,Δτ,Dim,gauge_action)

        P_update!(U,p,1.0,Δτ,Dim,gauge_action)

        U_update!(U,p,0.5,Δτ,Dim,gauge_action)
    end
    Snew = calc_action(gauge_action,U,p)
    println(&quot;Sold = $Sold, Snew = $Snew&quot;)
    println(&quot;Snew - Sold = $(Snew-Sold)&quot;)
    ratio = min(1,exp(Snew-Sold))
    if rand() &gt; ratio
        substitute_U!(U,Uold)
        return false
    else
        return true
    end
end

function U_update!(U,p,ϵ,Δτ,Dim,gauge_action)
    temps = get_temporary_gaugefields(gauge_action)
    temp1 = temps[1]
    temp2 = temps[2]
    expU = temps[3]
    W = temps[4]

    for μ=1:Dim
        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])
        mul!(W,expU,U[μ])
        substitute_U!(U[μ],W)
        
    end
end

function P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -&gt; p +factor*U*dSdUμ
    NC = U[1].NC
    temps = get_temporary_gaugefields(gauge_action)
    dSdUμ = temps[end]
    factor =  -ϵ*Δτ/(NC)

    for μ=1:Dim
        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)
        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ
        Traceless_antihermitian_add!(p[μ],factor,temps[1])
    end
end


function HMC_test_4D(NX,NY,NZ,NT,NC,β)
    Dim = 4
    Nwing = 0

    Random.seed!(123)


    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;,randomnumber=&quot;Reproducible&quot;)
    #&quot;Reproducible&quot;
    println(typeof(U))

    temp1 = similar(U[1])
    temp2 = similar(U[1])

    if Dim == 4
        comb = 6 #4*3/2
    elseif Dim == 3
        comb = 3
    elseif Dim == 2
        comb = 1
    else
        error(&quot;dimension $Dim is not supported&quot;)
    end

    factor = 1/(comb*U[1].NV*U[1].NC)


    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot;0 plaq_t = $plaq_t&quot;)
    poly = calculate_Polyakov_loop(U,temp1,temp2) 
    println(&quot;0 polyakov loop = $(real(poly)) $(imag(poly))&quot;)

    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop')
    β = β/2
    push!(gauge_action,β,plaqloop)
    
    #show(gauge_action)

    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. 
    Uold = similar(U)
    substitute_U!(Uold,U)
    MDsteps = 100
    temp1 = similar(U[1])
    temp2 = similar(U[1])
    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    numaccepted = 0

    numtrj = 10
    for itrj = 1:numtrj
        t = @timed begin
            accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)
        end
        if get_myrank(U) == 0
            println(&quot;elapsed time for MDsteps: $(t.time) [s]&quot;)
        end
        numaccepted += ifelse(accepted,1,0)

        #plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        #println(&quot;$itrj plaq_t = $plaq_t&quot;)
        
        if itrj % 10 == 0
            @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
            println(&quot;$itrj plaq_t = $plaq_t&quot;)
            poly = calculate_Polyakov_loop(U,temp1,temp2) 
            println(&quot;$itrj polyakov loop = $(real(poly)) $(imag(poly))&quot;)
            println(&quot;acceptance ratio &quot;,numaccepted/itrj)
        end
    end
    return plaq_t,numaccepted/numtrj

end


function main()
    β = 5.7
    NX = 8
    NY = 8
    NZ = 8
    NT = 8
    NC = 3
    HMC_test_4D(NX,NY,NZ,NT,NC,β)
end
main()"><pre><span class="pl-k">using</span> Random
<span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LinearAlgebra

<span class="pl-k">function</span> <span class="pl-en">calc_action</span>(gauge_action,U,p)
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    Sg <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">evaluate_GaugeAction</span>(gauge_action,U)<span class="pl-k">/</span>NC <span class="pl-c"><span class="pl-c">#</span>evaluate_Gauge_action(gauge_action,U) = tr(evaluate_Gaugeaction_untraced(gauge_action,U))</span>
    Sp <span class="pl-k">=</span> p<span class="pl-k">*</span>p<span class="pl-k">/</span><span class="pl-c1">2</span>
    S <span class="pl-k">=</span> Sp <span class="pl-k">+</span> Sg
    <span class="pl-k">return</span> <span class="pl-c1">real</span>(S)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold)
    Δτ <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>MDsteps
    <span class="pl-c1">gauss_distribution!</span>(p)
    Sold <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p)
    <span class="pl-c1">substitute_U!</span>(Uold,U)

    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>MDsteps
        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">P_update!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)
    <span class="pl-k">end</span>
    Snew <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-v">$Sold</span>, Snew = <span class="pl-v">$Snew</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Snew - Sold = <span class="pl-v">$(Snew<span class="pl-k">-</span>Sold)</span><span class="pl-pds">"</span></span>)
    ratio <span class="pl-k">=</span> <span class="pl-c1">min</span>(<span class="pl-c1">1</span>,<span class="pl-c1">exp</span>(Snew<span class="pl-k">-</span>Sold))
    <span class="pl-k">if</span> <span class="pl-c1">rand</span>() <span class="pl-k">&gt;</span> ratio
        <span class="pl-c1">substitute_U!</span>(U,Uold)
        <span class="pl-k">return</span> <span class="pl-c1">false</span>
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">U_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action)
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    expU <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    W <span class="pl-k">=</span> temps[<span class="pl-c1">4</span>]

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">exptU!</span>(expU,ϵ<span class="pl-k">*</span>Δτ,p[μ],[temp1,temp2])
        <span class="pl-c1">mul!</span>(W,expU,U[μ])
        <span class="pl-c1">substitute_U!</span>(U[μ],W)
        
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">P_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action) <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    dSdUμ <span class="pl-k">=</span> temps[<span class="pl-c1">end</span>]
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ<span class="pl-k">/</span>(NC)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">calc_dSdUμ!</span>(dSdUμ,gauge_action,μ,U)
        <span class="pl-c1">mul!</span>(temps[<span class="pl-c1">1</span>],U[μ],dSdUμ) <span class="pl-c"><span class="pl-c">#</span> U*dSdUμ</span>
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,temps[<span class="pl-c1">1</span>])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">HMC_test_4D</span>(NX,NY,NZ,NT,NC,β)
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">0</span>

    Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">123</span>)


    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>,randomnumber<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reproducible<span class="pl-pds">"</span></span>)
    <span class="pl-c"><span class="pl-c">#</span>"Reproducible"</span>
    <span class="pl-c1">println</span>(<span class="pl-c1">typeof</span>(U))

    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

    <span class="pl-k">if</span> Dim <span class="pl-k">==</span> <span class="pl-c1">4</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span>4*3/2</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">3</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">3</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">2</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">1</span>
    <span class="pl-k">else</span>
        <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>dimension <span class="pl-v">$Dim</span> is not supported<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>

    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)


    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
    poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)

    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)
    β <span class="pl-k">=</span> β<span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)
    
    <span class="pl-c"><span class="pl-c">#</span>show(gauge_action)</span>

    p <span class="pl-k">=</span> <span class="pl-c1">initialize_TA_Gaugefields</span>(U) <span class="pl-c"><span class="pl-c">#</span>This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. </span>
    Uold <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    <span class="pl-c1">substitute_U!</span>(Uold,U)
    MDsteps <span class="pl-k">=</span> <span class="pl-c1">100</span>
    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    numaccepted <span class="pl-k">=</span> <span class="pl-c1">0</span>

    numtrj <span class="pl-k">=</span> <span class="pl-c1">10</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numtrj
        t <span class="pl-k">=</span> <span class="pl-c1">@timed</span> <span class="pl-k">begin</span>
            accepted <span class="pl-k">=</span> <span class="pl-c1">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold)
        <span class="pl-k">end</span>
        <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>elapsed time for MDsteps: <span class="pl-v">$(t<span class="pl-k">.</span>time)</span> [s]<span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        numaccepted <span class="pl-k">+=</span> <span class="pl-c1">ifelse</span>(accepted,<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)

        <span class="pl-c"><span class="pl-c">#</span>plaq_t = calculate_Plaquette(U,temp1,temp2)*factor</span>
        <span class="pl-c"><span class="pl-c">#</span>println("$itrj plaq_t = $plaq_t")</span>
        
        <span class="pl-k">if</span> itrj <span class="pl-k">%</span> <span class="pl-c1">10</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
            <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
            poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>acceptance ratio <span class="pl-pds">"</span></span>,numaccepted<span class="pl-k">/</span>itrj)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> plaq_t,numaccepted<span class="pl-k">/</span>numtrj

<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">main</span>()
    β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
    NX <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
    <span class="pl-c1">HMC_test_4D</span>(NX,NY,NZ,NT,NC,β)
<span class="pl-k">end</span>
<span class="pl-c1">main</span>()</pre></div>
<h2 dir="auto"><a id="user-content-gradient-flow-with-general-terms" class="anchor" aria-hidden="true" href="#gradient-flow-with-general-terms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Gradient flow with general terms</h2>
<p dir="auto">We can do the gradient flow with general terms with the use of Wilsonloop.jl, which is shown below.
The coefficient of the action can be complex. The complex conjugate of the action defined here is added automatically to make the total action hermitian.<br>
The code is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
using Random
using Test
using Gaugefields
using Wilsonloop

function gradientflow_test_4D(NX,NY,NZ,NT,NC)
    Dim = 4
    Nwing = 1

    Random.seed!(123)

    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;,randomnumber=&quot;Reproducible&quot;)

    temp1 = similar(U[1])
    temp2 = similar(U[1])

    if Dim == 4
        comb = 6 #4*3/2
    elseif Dim == 3
        comb = 3
    elseif Dim == 2
        comb = 1
    else
        error(&quot;dimension $Dim is not supported&quot;)
    end
    factor = 1/(comb*U[1].NV*U[1].NC)


    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot;0 plaq_t = $plaq_t&quot;)
    poly = calculate_Polyakov_loop(U,temp1,temp2) 
    println(&quot;0 polyakov loop = $(real(poly)) $(imag(poly))&quot;)

    #Plaquette term
    loops_p = Wilsonline{Dim}[]
    for μ=1:Dim
        for ν=μ:Dim
            if ν == μ
                continue
            end
            loop1 = Wilsonline([(μ,1),(ν,1),(μ,-1),(ν,-1)],Dim = Dim)
            push!(loops_p,loop1)
        end
    end

    #Rectangular term
    loops = Wilsonline{Dim}[]
    for μ=1:Dim
        for ν=μ:Dim
            if ν == μ
                continue
            end
            loop1 = Wilsonline([(μ,1),(ν,2),(μ,-1),(ν,-2)],Dim = Dim)
            push!(loops,loop1)
            loop1 = Wilsonline([(μ,2),(ν,1),(μ,-2),(ν,-1)],Dim = Dim)
            
            push!(loops,loop1)
        end
    end

    listloops = [loops_p,loops]
    listvalues = [1+im,0.1]
    g = Gradientflow_general(U,listloops,listvalues,eps = 0.01)

    for itrj=1:100
        flow!(U,g)
        if itrj % 10 == 0
            @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
            println(&quot;$itrj plaq_t = $plaq_t&quot;)
            poly = calculate_Polyakov_loop(U,temp1,temp2) 
            println(&quot;$itrj polyakov loop = $(real(poly)) $(imag(poly))&quot;)
        end
    end
    return plaq_t

end


function gradientflow_test_2D(NX,NT,NC)
    Dim = 2
    Nwing = 1
    U = Initialize_Gaugefields(NC,Nwing,NX,NT,condition = &quot;hot&quot;,randomnumber=&quot;Reproducible&quot;)

    temp1 = similar(U[1])
    temp2 = similar(U[1])

    if Dim == 4
        comb = 6 #4*3/2
    elseif Dim == 3
        comb = 3
    elseif Dim == 2
        comb = 1
    else
        error(&quot;dimension $Dim is not supported&quot;)
    end

    factor = 1/(comb*U[1].NV*U[1].NC)

    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot;0 plaq_t = $plaq_t&quot;)
    poly = calculate_Polyakov_loop(U,temp1,temp2) 
    println(&quot;0 polyakov loop = $(real(poly)) $(imag(poly))&quot;)

    #g = Gradientflow(U,eps = 0.01)
    #listnames = [&quot;plaquette&quot;]
    #listvalues = [1]
    loops_p = Wilsonline{Dim}[]
    for μ=1:Dim
        for ν=μ:Dim
            if ν == μ
                continue
            end

            loop1 = Wilsonline([(μ,1),(ν,1),(μ,-1),(ν,-1)],Dim = Dim)
            push!(loops_p,loop1)

        end
    end


    loops = Wilsonline{Dim}[]
    for μ=1:Dim
        for ν=μ:Dim
            if ν == μ
                continue
            end
            loop1 = Wilsonline([(μ,1),(ν,2),(μ,-1),(ν,-2)],Dim = Dim)
            push!(loops,loop1)
            loop1 = Wilsonline([(μ,2),(ν,1),(μ,-2),(ν,-1)],Dim = Dim)
            
            push!(loops,loop1)
        end
    end

    listloops = [loops_p,loops]
    listvalues = [1+im,0.1]
    g = Gradientflow_general(U,listloops,listvalues,eps = 0.01)

    for itrj=1:100
        flow!(U,g)
        if itrj % 10 == 0
            @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
            println(&quot;$itrj plaq_t = $plaq_t&quot;)
            poly = calculate_Polyakov_loop(U,temp1,temp2) 
            println(&quot;$itrj polyakov loop = $(real(poly)) $(imag(poly))&quot;)
        end
    end

    return plaq_t

end



const eps = 0.1


println(&quot;2D system&quot;)
@testset &quot;2D&quot; begin
    NX = 4
    #NY = 4
    #NZ = 4
    NT = 4
    Nwing = 1

    @testset &quot;NC=1&quot; begin
        β = 2.3
        NC = 1
        println(&quot;NC = $NC&quot;)
        @time plaq_t = gradientflow_test_2D(NX,NT,NC)
    end
    #error(&quot;d&quot;)
    
    @testset &quot;NC=2&quot; begin
        β = 2.3
        NC = 2
        println(&quot;NC = $NC&quot;)
        @time plaq_t = gradientflow_test_2D(NX,NT,NC)
    end

    @testset &quot;NC=3&quot; begin
        β = 5.7
        NC = 3
        println(&quot;NC = $NC&quot;)
        @time plaq_t = gradientflow_test_2D(NX,NT,NC)
    end

    @testset &quot;NC=4&quot; begin
        β = 5.7
        NC = 4
        println(&quot;NC = $NC&quot;)
        @time plaq_t = gradientflow_test_2D(NX,NT,NC)
    end
end

println(&quot;4D system&quot;)
@testset &quot;4D&quot; begin
    NX = 4
    NY = 4
    NZ = 4
    NT = 4
    Nwing = 1


    
    @testset &quot;NC=2&quot; begin
        β = 2.3
        NC = 2
        println(&quot;NC = $NC&quot;)
        @time plaq_t = gradientflow_test_4D(NX,NY,NZ,NT,NC)
    end

    @testset &quot;NC=3&quot; begin
        β = 5.7
        NC = 3
        println(&quot;NC = $NC&quot;)
        @time plaq_t = gradientflow_test_4D(NX,NY,NZ,NT,NC)
    end

    @testset &quot;NC=4&quot; begin
        β = 5.7
        NC = 4
        println(&quot;NC = $NC&quot;)

        val = 0.7301232810349298
        @time plaq_t =gradientflow_test_4D(NX,NY,NZ,NT,NC)
    end


end"><pre><span class="pl-k">using</span> Random
<span class="pl-k">using</span> Test
<span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> Wilsonloop

<span class="pl-k">function</span> <span class="pl-en">gradientflow_test_4D</span>(NX,NY,NZ,NT,NC)
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>

    Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">123</span>)

    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>,randomnumber<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reproducible<span class="pl-pds">"</span></span>)

    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

    <span class="pl-k">if</span> Dim <span class="pl-k">==</span> <span class="pl-c1">4</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span>4*3/2</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">3</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">3</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">2</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">1</span>
    <span class="pl-k">else</span>
        <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>dimension <span class="pl-v">$Dim</span> is not supported<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)


    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
    poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)

    <span class="pl-c"><span class="pl-c">#</span>Plaquette term</span>
    loops_p <span class="pl-k">=</span> Wilsonline{Dim}[]
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-k">for</span> ν<span class="pl-k">=</span>μ<span class="pl-c1">:Dim</span>
            <span class="pl-k">if</span> ν <span class="pl-k">==</span> μ
                <span class="pl-k">continue</span>
            <span class="pl-k">end</span>
            loop1 <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-c1">1</span>),(ν,<span class="pl-c1">1</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim)
            <span class="pl-c1">push!</span>(loops_p,loop1)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    <span class="pl-c"><span class="pl-c">#</span>Rectangular term</span>
    loops <span class="pl-k">=</span> Wilsonline{Dim}[]
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-k">for</span> ν<span class="pl-k">=</span>μ<span class="pl-c1">:Dim</span>
            <span class="pl-k">if</span> ν <span class="pl-k">==</span> μ
                <span class="pl-k">continue</span>
            <span class="pl-k">end</span>
            loop1 <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-c1">1</span>),(ν,<span class="pl-c1">2</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">2</span>)],Dim <span class="pl-k">=</span> Dim)
            <span class="pl-c1">push!</span>(loops,loop1)
            loop1 <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-c1">2</span>),(ν,<span class="pl-c1">1</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">2</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim)
            
            <span class="pl-c1">push!</span>(loops,loop1)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    listloops <span class="pl-k">=</span> [loops_p,loops]
    listvalues <span class="pl-k">=</span> [<span class="pl-c1">1</span><span class="pl-k">+</span>im,<span class="pl-c1">0.1</span>]
    g <span class="pl-k">=</span> <span class="pl-c1">Gradientflow_general</span>(U,listloops,listvalues,eps <span class="pl-k">=</span> <span class="pl-c1">0.01</span>)

    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>
        <span class="pl-c1">flow!</span>(U,g)
        <span class="pl-k">if</span> itrj <span class="pl-k">%</span> <span class="pl-c1">10</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
            <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
            poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> plaq_t

<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">gradientflow_test_2D</span>(NX,NT,NC)
    Dim <span class="pl-k">=</span> <span class="pl-c1">2</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>,randomnumber<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Reproducible<span class="pl-pds">"</span></span>)

    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

    <span class="pl-k">if</span> Dim <span class="pl-k">==</span> <span class="pl-c1">4</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span>4*3/2</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">3</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">3</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">2</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">1</span>
    <span class="pl-k">else</span>
        <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>dimension <span class="pl-v">$Dim</span> is not supported<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>

    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)

    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
    poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)

    <span class="pl-c"><span class="pl-c">#</span>g = Gradientflow(U,eps = 0.01)</span>
    <span class="pl-c"><span class="pl-c">#</span>listnames = ["plaquette"]</span>
    <span class="pl-c"><span class="pl-c">#</span>listvalues = [1]</span>
    loops_p <span class="pl-k">=</span> Wilsonline{Dim}[]
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-k">for</span> ν<span class="pl-k">=</span>μ<span class="pl-c1">:Dim</span>
            <span class="pl-k">if</span> ν <span class="pl-k">==</span> μ
                <span class="pl-k">continue</span>
            <span class="pl-k">end</span>

            loop1 <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-c1">1</span>),(ν,<span class="pl-c1">1</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim)
            <span class="pl-c1">push!</span>(loops_p,loop1)

        <span class="pl-k">end</span>
    <span class="pl-k">end</span>


    loops <span class="pl-k">=</span> Wilsonline{Dim}[]
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-k">for</span> ν<span class="pl-k">=</span>μ<span class="pl-c1">:Dim</span>
            <span class="pl-k">if</span> ν <span class="pl-k">==</span> μ
                <span class="pl-k">continue</span>
            <span class="pl-k">end</span>
            loop1 <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-c1">1</span>),(ν,<span class="pl-c1">2</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">2</span>)],Dim <span class="pl-k">=</span> Dim)
            <span class="pl-c1">push!</span>(loops,loop1)
            loop1 <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-c1">2</span>),(ν,<span class="pl-c1">1</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">2</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim)
            
            <span class="pl-c1">push!</span>(loops,loop1)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    listloops <span class="pl-k">=</span> [loops_p,loops]
    listvalues <span class="pl-k">=</span> [<span class="pl-c1">1</span><span class="pl-k">+</span>im,<span class="pl-c1">0.1</span>]
    g <span class="pl-k">=</span> <span class="pl-c1">Gradientflow_general</span>(U,listloops,listvalues,eps <span class="pl-k">=</span> <span class="pl-c1">0.01</span>)

    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>
        <span class="pl-c1">flow!</span>(U,g)
        <span class="pl-k">if</span> itrj <span class="pl-k">%</span> <span class="pl-c1">10</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
            <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
            poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    <span class="pl-k">return</span> plaq_t

<span class="pl-k">end</span>



<span class="pl-k">const</span> eps <span class="pl-k">=</span> <span class="pl-c1">0.1</span>


<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>2D system<span class="pl-pds">"</span></span>)
<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>2D<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    <span class="pl-c"><span class="pl-c">#</span>NY = 4</span>
    <span class="pl-c"><span class="pl-c">#</span>NZ = 4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>

    <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>NC=1<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
        β <span class="pl-k">=</span> <span class="pl-c1">2.3</span>
        NC <span class="pl-k">=</span> <span class="pl-c1">1</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>NC = <span class="pl-v">$NC</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">gradientflow_test_2D</span>(NX,NT,NC)
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span>error("d")</span>
    
    <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>NC=2<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
        β <span class="pl-k">=</span> <span class="pl-c1">2.3</span>
        NC <span class="pl-k">=</span> <span class="pl-c1">2</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>NC = <span class="pl-v">$NC</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">gradientflow_test_2D</span>(NX,NT,NC)
    <span class="pl-k">end</span>

    <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>NC=3<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
        β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
        NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>NC = <span class="pl-v">$NC</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">gradientflow_test_2D</span>(NX,NT,NC)
    <span class="pl-k">end</span>

    <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>NC=4<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
        β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
        NC <span class="pl-k">=</span> <span class="pl-c1">4</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>NC = <span class="pl-v">$NC</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">gradientflow_test_2D</span>(NX,NT,NC)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>4D system<span class="pl-pds">"</span></span>)
<span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>4D<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>


    
    <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>NC=2<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
        β <span class="pl-k">=</span> <span class="pl-c1">2.3</span>
        NC <span class="pl-k">=</span> <span class="pl-c1">2</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>NC = <span class="pl-v">$NC</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">gradientflow_test_4D</span>(NX,NY,NZ,NT,NC)
    <span class="pl-k">end</span>

    <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>NC=3<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
        β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
        NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>NC = <span class="pl-v">$NC</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">gradientflow_test_4D</span>(NX,NY,NZ,NT,NC)
    <span class="pl-k">end</span>

    <span class="pl-c1">@testset</span> <span class="pl-s"><span class="pl-pds">"</span>NC=4<span class="pl-pds">"</span></span> <span class="pl-k">begin</span>
        β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
        NC <span class="pl-k">=</span> <span class="pl-c1">4</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>NC = <span class="pl-v">$NC</span><span class="pl-pds">"</span></span>)

        val <span class="pl-k">=</span> <span class="pl-c1">0.7301232810349298</span>
        <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span><span class="pl-c1">gradientflow_test_4D</span>(NX,NY,NZ,NT,NC)
    <span class="pl-k">end</span>


<span class="pl-k">end</span></pre></div>
<h2 dir="auto"><a id="user-content-hmc-with-mpi" class="anchor" aria-hidden="true" href="#hmc-with-mpi"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>HMC with MPI</h2>
<p dir="auto">Here, we show the HMC with MPI.
the REPL and Jupyternotebook can not be used when one wants to use MPI.
The command is like:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="mpirun -np 2 julia exe.jl 1 1 1 2 true"><pre class="notranslate"><code>mpirun -np 2 julia exe.jl 1 1 1 2 true
</code></pre></div>
<p dir="auto"><code>1 1 1 2</code> means <code>PEX PEY PEZ PET</code>. In this case, the time-direction is diveded by 2.</p>
<p dir="auto">The sample code is written as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
using Random
using Gaugefields
using LinearAlgebra
using MPI

if length(ARGS) &lt; 5
    error(&quot;USAGE: &quot;,&quot;&quot;&quot;
    mpirun -np 2 exe.jl 1 1 1 2 true
    &quot;&quot;&quot;)
end
const pes = Tuple(parse.(Int64,ARGS[1:4]))
const mpi = parse(Bool,ARGS[5])

function calc_action(gauge_action,U,p)
    NC = U[1].NC
    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_Gauge_action(gauge_action,U) = tr(evaluate_Gaugeaction_untraced(gauge_action,U))
    Sp = p*p/2
    S = Sp + Sg
    return real(S)
end

function MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)
    Δτ = 1/MDsteps
    gauss_distribution!(p)
    Sold = calc_action(gauge_action,U,p)
    substitute_U!(Uold,U)

    for itrj=1:MDsteps
        U_update!(U,p,0.5,Δτ,Dim,gauge_action)

        P_update!(U,p,1.0,Δτ,Dim,gauge_action)

        U_update!(U,p,0.5,Δτ,Dim,gauge_action)
    end
    Snew = calc_action(gauge_action,U,p)
    if get_myrank(U) == 0
        println(&quot;Sold = $Sold, Snew = $Snew&quot;)
        println(&quot;Snew - Sold = $(Snew-Sold)&quot;)
    end
    ratio = min(1,exp(Snew-Sold))
    r = rand()
    if mpi
        r = MPI.bcast(r, 0, MPI.COMM_WORLD)
    end
    #ratio = min(1,exp(Snew-Sold))
    if r &gt; ratio
        substitute_U!(U,Uold)
        return false
    else
        return true
    end
end

function U_update!(U,p,ϵ,Δτ,Dim,gauge_action)
    temps = get_temporary_gaugefields(gauge_action)
    temp1 = temps[1]
    temp2 = temps[2]
    expU = temps[3]
    W = temps[4]

    for μ=1:Dim
        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])
        mul!(W,expU,U[μ])
        substitute_U!(U[μ],W)
        
    end
end

function P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -&gt; p +factor*U*dSdUμ
    NC = U[1].NC
    temps = get_temporary_gaugefields(gauge_action)
    dSdUμ = temps[end]
    factor =  -ϵ*Δτ/(NC)

    for μ=1:Dim
        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)
        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ
        Traceless_antihermitian_add!(p[μ],factor,temps[1])
    end
end


function HMC_test_4D(NX,NY,NZ,NT,NC,β)
    Dim = 4
    Nwing = 0

    Random.seed!(123)

    if mpi
        PEs = pes#(1,1,1,2)
        U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;,mpi=true,PEs = PEs,mpiinit = false) 
    else
        U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;)
    end

    if get_myrank(U) == 0
        println(typeof(U))
    end

    temp1 = similar(U[1])
    temp2 = similar(U[1])

    if Dim == 4
        comb = 6 #4*3/2
    elseif Dim == 3
        comb = 3
    elseif Dim == 2
        comb = 1
    else
        error(&quot;dimension $Dim is not supported&quot;)
    end

    factor = 1/(comb*U[1].NV*U[1].NC)

    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    if get_myrank(U) == 0
        println(&quot;0 plaq_t = $plaq_t&quot;)
    end
    poly = calculate_Polyakov_loop(U,temp1,temp2) 
    if get_myrank(U) == 0
        println(&quot;0 polyakov loop = $(real(poly)) $(imag(poly))&quot;)
    end

    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop')
    β = β/2
    push!(gauge_action,β,plaqloop)
    
    #show(gauge_action)

    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. 
    Uold = similar(U)
    substitute_U!(Uold,U)
    MDsteps = 100
    temp1 = similar(U[1])
    temp2 = similar(U[1])
    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    numaccepted = 0

    numtrj = 100
    for itrj = 1:numtrj
        t = @timed begin
            accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)
        end
        if get_myrank(U) == 0
            println(&quot;elapsed time for MDsteps: $(t.time) [s]&quot;)
        end
        numaccepted += ifelse(accepted,1,0)

        #plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        #println(&quot;$itrj plaq_t = $plaq_t&quot;)
        
        if itrj % 10 == 0
            plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
            if get_myrank(U) == 0
                println(&quot;$itrj plaq_t = $plaq_t&quot;)
            end
            poly = calculate_Polyakov_loop(U,temp1,temp2) 
            if get_myrank(U) == 0
                println(&quot;$itrj polyakov loop = $(real(poly)) $(imag(poly))&quot;)
                println(&quot;acceptance ratio &quot;,numaccepted/itrj)
            end
        end
    end


    return plaq_t,numaccepted/numtrj

end



function main()
    β = 5.7
    NX = 8
    NY = 8
    NZ = 8
    NT = 8
    NC = 3
    HMC_test_4D(NX,NY,NZ,NT,NC,β)
end
main()"><pre><span class="pl-k">using</span> Random
<span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LinearAlgebra
<span class="pl-k">using</span> MPI

<span class="pl-k">if</span> <span class="pl-c1">length</span>(<span class="pl-c1">ARGS</span>) <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>
    <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>USAGE: <span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    mpirun -np 2 exe.jl 1 1 1 2 true</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>)
<span class="pl-k">end</span>
<span class="pl-k">const</span> pes <span class="pl-k">=</span> <span class="pl-c1">Tuple</span>(<span class="pl-c1">parse</span>.(Int64,<span class="pl-c1">ARGS</span>[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>]))
<span class="pl-k">const</span> mpi <span class="pl-k">=</span> <span class="pl-c1">parse</span>(Bool,<span class="pl-c1">ARGS</span>[<span class="pl-c1">5</span>])

<span class="pl-k">function</span> <span class="pl-en">calc_action</span>(gauge_action,U,p)
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    Sg <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">evaluate_GaugeAction</span>(gauge_action,U)<span class="pl-k">/</span>NC <span class="pl-c"><span class="pl-c">#</span>evaluate_Gauge_action(gauge_action,U) = tr(evaluate_Gaugeaction_untraced(gauge_action,U))</span>
    Sp <span class="pl-k">=</span> p<span class="pl-k">*</span>p<span class="pl-k">/</span><span class="pl-c1">2</span>
    S <span class="pl-k">=</span> Sp <span class="pl-k">+</span> Sg
    <span class="pl-k">return</span> <span class="pl-c1">real</span>(S)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold)
    Δτ <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>MDsteps
    <span class="pl-c1">gauss_distribution!</span>(p)
    Sold <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p)
    <span class="pl-c1">substitute_U!</span>(Uold,U)

    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>MDsteps
        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">P_update!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)
    <span class="pl-k">end</span>
    Snew <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p)
    <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-v">$Sold</span>, Snew = <span class="pl-v">$Snew</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Snew - Sold = <span class="pl-v">$(Snew<span class="pl-k">-</span>Sold)</span><span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
    ratio <span class="pl-k">=</span> <span class="pl-c1">min</span>(<span class="pl-c1">1</span>,<span class="pl-c1">exp</span>(Snew<span class="pl-k">-</span>Sold))
    r <span class="pl-k">=</span> <span class="pl-c1">rand</span>()
    <span class="pl-k">if</span> mpi
        r <span class="pl-k">=</span> MPI<span class="pl-k">.</span><span class="pl-c1">bcast</span>(r, <span class="pl-c1">0</span>, MPI<span class="pl-k">.</span>COMM_WORLD)
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span>ratio = min(1,exp(Snew-Sold))</span>
    <span class="pl-k">if</span> r <span class="pl-k">&gt;</span> ratio
        <span class="pl-c1">substitute_U!</span>(U,Uold)
        <span class="pl-k">return</span> <span class="pl-c1">false</span>
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">U_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action)
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    expU <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    W <span class="pl-k">=</span> temps[<span class="pl-c1">4</span>]

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">exptU!</span>(expU,ϵ<span class="pl-k">*</span>Δτ,p[μ],[temp1,temp2])
        <span class="pl-c1">mul!</span>(W,expU,U[μ])
        <span class="pl-c1">substitute_U!</span>(U[μ],W)
        
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">P_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action) <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    dSdUμ <span class="pl-k">=</span> temps[<span class="pl-c1">end</span>]
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ<span class="pl-k">/</span>(NC)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">calc_dSdUμ!</span>(dSdUμ,gauge_action,μ,U)
        <span class="pl-c1">mul!</span>(temps[<span class="pl-c1">1</span>],U[μ],dSdUμ) <span class="pl-c"><span class="pl-c">#</span> U*dSdUμ</span>
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,temps[<span class="pl-c1">1</span>])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">HMC_test_4D</span>(NX,NY,NZ,NT,NC,β)
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">0</span>

    Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">123</span>)

    <span class="pl-k">if</span> mpi
        PEs <span class="pl-k">=</span> pes<span class="pl-c"><span class="pl-c">#</span>(1,1,1,2)</span>
        U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>,mpi<span class="pl-k">=</span><span class="pl-c1">true</span>,PEs <span class="pl-k">=</span> PEs,mpiinit <span class="pl-k">=</span> <span class="pl-c1">false</span>) 
    <span class="pl-k">else</span>
        U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>

    <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
        <span class="pl-c1">println</span>(<span class="pl-c1">typeof</span>(U))
    <span class="pl-k">end</span>

    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

    <span class="pl-k">if</span> Dim <span class="pl-k">==</span> <span class="pl-c1">4</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">#</span>4*3/2</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">3</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">3</span>
    <span class="pl-k">elseif</span> Dim <span class="pl-k">==</span> <span class="pl-c1">2</span>
        comb <span class="pl-k">=</span> <span class="pl-c1">1</span>
    <span class="pl-k">else</span>
        <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>dimension <span class="pl-v">$Dim</span> is not supported<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>

    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)

    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
    poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
    <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>

    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)
    β <span class="pl-k">=</span> β<span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)
    
    <span class="pl-c"><span class="pl-c">#</span>show(gauge_action)</span>

    p <span class="pl-k">=</span> <span class="pl-c1">initialize_TA_Gaugefields</span>(U) <span class="pl-c"><span class="pl-c">#</span>This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. </span>
    Uold <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    <span class="pl-c1">substitute_U!</span>(Uold,U)
    MDsteps <span class="pl-k">=</span> <span class="pl-c1">100</span>
    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    numaccepted <span class="pl-k">=</span> <span class="pl-c1">0</span>

    numtrj <span class="pl-k">=</span> <span class="pl-c1">100</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numtrj
        t <span class="pl-k">=</span> <span class="pl-c1">@timed</span> <span class="pl-k">begin</span>
            accepted <span class="pl-k">=</span> <span class="pl-c1">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold)
        <span class="pl-k">end</span>
        <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
            <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>elapsed time for MDsteps: <span class="pl-v">$(t<span class="pl-k">.</span>time)</span> [s]<span class="pl-pds">"</span></span>)
        <span class="pl-k">end</span>
        numaccepted <span class="pl-k">+=</span> <span class="pl-c1">ifelse</span>(accepted,<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)

        <span class="pl-c"><span class="pl-c">#</span>plaq_t = calculate_Plaquette(U,temp1,temp2)*factor</span>
        <span class="pl-c"><span class="pl-c">#</span>println("$itrj plaq_t = $plaq_t")</span>
        
        <span class="pl-k">if</span> itrj <span class="pl-k">%</span> <span class="pl-c1">10</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
            plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
            <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
                <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
            <span class="pl-k">end</span>
            poly <span class="pl-k">=</span> <span class="pl-c1">calculate_Polyakov_loop</span>(U,temp1,temp2) 
            <span class="pl-k">if</span> <span class="pl-c1">get_myrank</span>(U) <span class="pl-k">==</span> <span class="pl-c1">0</span>
                <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> polyakov loop = <span class="pl-v">$(<span class="pl-c1">real</span>(poly))</span> <span class="pl-v">$(<span class="pl-c1">imag</span>(poly))</span><span class="pl-pds">"</span></span>)
                <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>acceptance ratio <span class="pl-pds">"</span></span>,numaccepted<span class="pl-k">/</span>itrj)
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>


    <span class="pl-k">return</span> plaq_t,numaccepted<span class="pl-k">/</span>numtrj

<span class="pl-k">end</span>



<span class="pl-k">function</span> <span class="pl-en">main</span>()
    β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
    NX <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">8</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
    <span class="pl-c1">HMC_test_4D</span>(NX,NY,NZ,NT,NC,β)
<span class="pl-k">end</span>
<span class="pl-c1">main</span>()</pre></div>
<h1 dir="auto"><a id="user-content-utilities" class="anchor" aria-hidden="true" href="#utilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Utilities</h1>
<h2 dir="auto"><a id="user-content-data-structure" class="anchor" aria-hidden="true" href="#data-structure"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Data structure</h2>
<p dir="auto">We can access the gauge field defined on the bond between two neigbohr points.
In 4D system, the gauge field is like <code>u[ic,jc,ix,iy,iz,it]</code>.
There are four directions in 4D system. Gaugefields.jl uses the array like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="NX = 4
NY = 4
NZ = 4
NT = 4
Nwing = 1
Dim = 4

U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)
"><pre>NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>

U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)
</pre></div>
<p dir="auto">In the later exaples, we use, <code>mu=1</code> and <code>u=U[mu]</code> as an example.</p>
<h2 dir="auto"><a id="user-content-hermitian-conjugate-adjoint-operator" class="anchor" aria-hidden="true" href="#hermitian-conjugate-adjoint-operator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hermitian conjugate (Adjoint operator)</h2>
<p dir="auto">If you want to get the hermitian conjugate of the gauge fields, you can do like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="u'"><pre>u<span class="pl-k">'</span></pre></div>
<p dir="auto">This is evaluated with the lazy evaluation.
So there is no memory copy.
This returms <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="816ac4ed9d8ee312fb39e102c2c0db59">$U_\mu^dagger$</math-renderer> for all sites.</p>
<h2 dir="auto">
<a id="user-content-shift-operator" class="anchor" aria-hidden="true" href="#shift-operator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Shift operator</h2>
<p dir="auto">If you want to shift the gauge fields, you can do like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="shifted_u = shift_U(u, shift)"><pre>shifted_u <span class="pl-k">=</span> <span class="pl-c1">shift_U</span>(u, shift)</pre></div>
<p dir="auto">This is also evaluated with the lazy evaluation.
Here <code>shift</code> is <code>shift=(1,0,0,0)</code> for example.</p>
<h2 dir="auto">
<a id="user-content-matrix-field-matrix-field-product" class="anchor" aria-hidden="true" href="#matrix-field-matrix-field-product"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>matrix-field matrix-field product</h2>
<p dir="auto">If you want to calculate the matrix-matrix multiplicaetion on each lattice site, you can do like</p>
<p dir="auto">As a mathematical expression, for matrix-valued fields <code>A(n), B(n)</code>,
we define "matrix-field matrix-field product" as,</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="816ac4ed9d8ee312fb39e102c2c0db59">$$A(n)B(n)]_{ij} = \sum_k [A(n)]_{ik} [B(n)]_{kj}$$</math-renderer>
<p dir="auto">for all site index n.</p>

<p dir="auto">In our package, this is expressed as,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mul!(C,A,B)"><pre><span class="pl-c1">mul!</span>(C,A,B)</pre></div>
<p dir="auto">which means <code>C = A*B</code> on each lattice site.
Here <code>A, B, C</code> are same type of <code>u</code>.</p>
<h2 dir="auto">
<a id="user-content-trace-operation" class="anchor" aria-hidden="true" href="#trace-operation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Trace operation</h2>
<p dir="auto">If you want to calculate the trace of the gauge field, you can do like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="tr(A)"><pre><span class="pl-c1">tr</span>(A)</pre></div>
<p dir="auto">It is useful to evaluation actions.
This trace operation summing up all indecis, spacetime and color.</p>
<h1 dir="auto">
<a id="user-content-applications" class="anchor" aria-hidden="true" href="#applications"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Applications</h1>
<p dir="auto">This package and Wilsonloop.jl enable you to perform several calcurations.
Here we demonstrate them.</p>
<p dir="auto">Some of them will be simplified in LatticeQCD.jl.</p>
<h2 dir="auto">
<a id="user-content-wilson-loops" class="anchor" aria-hidden="true" href="#wilson-loops"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Wilson loops</h2>
<p dir="auto">We develop <a href="https://github.com/akio-tomiya/Wilsonloop.jl.git">Wilsonloop.jl</a>, which is useful to calculate Wilson loops.
If you want to use this, please install like</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add Wilsonloop.jl"><pre class="notranslate"><code>add Wilsonloop.jl
</code></pre></div>
<p dir="auto">For example, if you want to calculate the following quantity:</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="816ac4ed9d8ee312fb39e102c2c0db59">$$U_{1}(n)U_{2}(n+\hat{1}) U^{\dagger}_{1}(n+\hat{2}) U^{\dagger}_2(n)$$</math-renderer>
<p dir="auto">You can use Wilsonloop.jl as follows</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Wilsonloop
loop = [(1,1),(2,1),(1,-1),(2,-1)]
w = Wilsonline(loop)"><pre><span class="pl-k">using</span> Wilsonloop
loop <span class="pl-k">=</span> [(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>),(<span class="pl-c1">2</span>,<span class="pl-c1">1</span>),(<span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">1</span>),(<span class="pl-c1">2</span>,<span class="pl-k">-</span><span class="pl-c1">1</span>)]
w <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>(loop)</pre></div>
<p dir="auto">The output is <code>L"$U_{1}(n)U_{2}(n+e_{1})U^{\dagger}_{1}(n+e_{2})U^{\dagger}_{2}(n)$"</code>.
Then, you can evaluate this loop with the use of the Gaugefields.jl like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra
NX = 4
NY = 4
NZ = 4
NT = 4
NC = 3
Nwing = 1
Dim = 4
U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)

temp1 = similar(U[1])
V = similar(U[1])

evaluate_gaugelinks!(V,w,U,[temp1])
println(tr(V))"><pre><span class="pl-k">using</span> LinearAlgebra
NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)

temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
V <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

<span class="pl-c1">evaluate_gaugelinks!</span>(V,w,U,[temp1])
<span class="pl-c1">println</span>(<span class="pl-c1">tr</span>(V))</pre></div>
<p dir="auto">For example, if you want to calculate the clover operators, you can define like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function make_cloverloop(μ,ν,Dim)
    loops = Wilsonline{Dim}[]
    loop_righttop = Wilsonline([(μ,1),(ν,1),(μ,-1),(ν,-1)],Dim = Dim) # Pmunu
    push!(loops,loop_righttop)
    loop_rightbottom = Wilsonline([(ν,-1),(μ,1),(ν,1),(μ,-1)],Dim = Dim) # Qmunu
    push!(loops,loop_rightbottom)
    loop_leftbottom= Wilsonline([(μ,-1),(ν,-1),(μ,1),(ν,1)],Dim = Dim) # Rmunu
    push!(loops,loop_leftbottom)
    loop_lefttop = Wilsonline([(ν,1),(μ,-1),(ν,-1),(μ,1)],Dim = Dim) # Smunu
    push!(loops,loop_lefttop)
    return loops
end"><pre><span class="pl-k">function</span> <span class="pl-en">make_cloverloop</span>(μ,ν,Dim)
    loops <span class="pl-k">=</span> Wilsonline{Dim}[]
    loop_righttop <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-c1">1</span>),(ν,<span class="pl-c1">1</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim) <span class="pl-c"><span class="pl-c">#</span> Pmunu</span>
    <span class="pl-c1">push!</span>(loops,loop_righttop)
    loop_rightbottom <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>),(μ,<span class="pl-c1">1</span>),(ν,<span class="pl-c1">1</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim) <span class="pl-c"><span class="pl-c">#</span> Qmunu</span>
    <span class="pl-c1">push!</span>(loops,loop_rightbottom)
    loop_leftbottom<span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>),(μ,<span class="pl-c1">1</span>),(ν,<span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim) <span class="pl-c"><span class="pl-c">#</span> Rmunu</span>
    <span class="pl-c1">push!</span>(loops,loop_leftbottom)
    loop_lefttop <span class="pl-k">=</span> <span class="pl-c1">Wilsonline</span>([(ν,<span class="pl-c1">1</span>),(μ,<span class="pl-k">-</span><span class="pl-c1">1</span>),(ν,<span class="pl-k">-</span><span class="pl-c1">1</span>),(μ,<span class="pl-c1">1</span>)],Dim <span class="pl-k">=</span> Dim) <span class="pl-c"><span class="pl-c">#</span> Smunu</span>
    <span class="pl-c1">push!</span>(loops,loop_lefttop)
    <span class="pl-k">return</span> loops
<span class="pl-k">end</span></pre></div>
<p dir="auto">The energy density defined in the paper (Ramos and Sint, <a href="https://link.springer.com/article/10.1140%2Fepjc%2Fs10052-015-3831-9" rel="nofollow">Eur. Phys. J. C (2016) 76:15</a>) can be calculated as follows.  Note: the coefficient in the equation (3.40) in the preprint version is wrong.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function make_clover(G,U,temps,Dim)
    temp1 = temps[1]
    temp2 = temps[2]
    temp3 = temps[3]
    
    for μ=1:Dim
        for ν=1:Dim
            if μ == ν
                continue
            end
            loops = make_cloverloop(μ,ν,Dim)
            evaluate_gaugelinks!(temp3,loops,U,[temp1,temp2])

            Traceless_antihermitian!(G[μ,ν],temp3)
        end
    end
end

function calc_energydensity(G,U,temps,Dim)
    temp1 = temps[1]
    s = 0
    for μ=1:Dim
        for ν=1:Dim
            if μ == ν
                continue
            end
            mul!(temp1,G[μ,ν],G[μ,ν])
            s += -real(tr(temp1))/2
        end
    end
    return  s/(4^2*U[1].NV)
end"><pre><span class="pl-k">function</span> <span class="pl-en">make_clover</span>(G,U,temps,Dim)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    temp3 <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-k">for</span> ν<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
            <span class="pl-k">if</span> μ <span class="pl-k">==</span> ν
                <span class="pl-k">continue</span>
            <span class="pl-k">end</span>
            loops <span class="pl-k">=</span> <span class="pl-c1">make_cloverloop</span>(μ,ν,Dim)
            <span class="pl-c1">evaluate_gaugelinks!</span>(temp3,loops,U,[temp1,temp2])

            <span class="pl-c1">Traceless_antihermitian!</span>(G[μ,ν],temp3)
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">calc_energydensity</span>(G,U,temps,Dim)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    s <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-k">for</span> ν<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
            <span class="pl-k">if</span> μ <span class="pl-k">==</span> ν
                <span class="pl-k">continue</span>
            <span class="pl-k">end</span>
            <span class="pl-c1">mul!</span>(temp1,G[μ,ν],G[μ,ν])
            s <span class="pl-k">+=</span> <span class="pl-k">-</span><span class="pl-c1">real</span>(<span class="pl-c1">tr</span>(temp1))<span class="pl-k">/</span><span class="pl-c1">2</span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-k">return</span>  s<span class="pl-k">/</span>(<span class="pl-c1">4</span><span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV)
<span class="pl-k">end</span></pre></div>
<p dir="auto">Then, we can calculate the energy density:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function test(NX,NY,NZ,NT,β,NC)
    Dim = 4
    Nwing = 1

    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)

    filename = &quot;./conf_00000010.txt&quot; 
    L = [NX,NY,NZ,NT]
    load_BridgeText!(filename,U,L,NC) # We load a configuration from a file. 

    temp1 = similar(U[1])
    temp2 = similar(U[1])
    temp3 = similar(U[1])

    println(&quot;Make clover operator&quot;)
    G = Array{typeof(u1),2}(undef,Dim,Dim)
    for μ=1:Dim
        for ν=1:Dim
            G[μ,ν] = similar(U[1])
        end
    end

    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot;plaq_t = $plaq_t&quot;)

    g = Gradientflow(U,eps = 0.01)
    for itrj=1:100
        flow!(U,g)

        make_clover(G,U,[temp1,temp2,temp3],Dim)
        E = calc_energydensity(G,U,[temp1,temp2,temp3],Dim)

        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        println(&quot;$itrj $(itrj*0.01) plaq_t = $plaq_t , E = $E&quot;)
    end

end
NX = 8
NY = 8
NZ = 8
NT = 8
β = 5.7
NC = 3
test(NX,NY,NZ,NT,β,NC)"><pre><span class="pl-k">function</span> <span class="pl-en">test</span>(NX,NY,NZ,NT,β,NC)
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>

    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)

    filename <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>./conf_00000010.txt<span class="pl-pds">"</span></span> 
    L <span class="pl-k">=</span> [NX,NY,NZ,NT]
    <span class="pl-c1">load_BridgeText!</span>(filename,U,L,NC) <span class="pl-c"><span class="pl-c">#</span> We load a configuration from a file. </span>

    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp3 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])

    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Make clover operator<span class="pl-pds">"</span></span>)
    G <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{typeof(u1),2}</span>(undef,Dim,Dim)
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-k">for</span> ν<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
            G[μ,ν] <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    <span class="pl-c1">@time</span> plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)

    g <span class="pl-k">=</span> <span class="pl-c1">Gradientflow</span>(U,eps <span class="pl-k">=</span> <span class="pl-c1">0.01</span>)
    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>
        <span class="pl-c1">flow!</span>(U,g)

        <span class="pl-c1">make_clover</span>(G,U,[temp1,temp2,temp3],Dim)
        E <span class="pl-k">=</span> <span class="pl-c1">calc_energydensity</span>(G,U,[temp1,temp2,temp3],Dim)

        plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> <span class="pl-v">$(itrj<span class="pl-k">*</span><span class="pl-c1">0.01</span>)</span> plaq_t = <span class="pl-v">$plaq_t</span> , E = <span class="pl-v">$E</span><span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>

<span class="pl-k">end</span>
NX <span class="pl-k">=</span> <span class="pl-c1">8</span>
NY <span class="pl-k">=</span> <span class="pl-c1">8</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">8</span>
NT <span class="pl-k">=</span> <span class="pl-c1">8</span>
β <span class="pl-k">=</span> <span class="pl-c1">5.7</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
<span class="pl-c1">test</span>(NX,NY,NZ,NT,β,NC)</pre></div>
<h2 dir="auto">
<a id="user-content-calculating-actions" class="anchor" aria-hidden="true" href="#calculating-actions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calculating actions</h2>
<p dir="auto">We can calculate actions from this packages with fixed gauge fields U.
We introduce the concenpt "Scalar-valued neural network", which is S(U) -&gt; V, where U and V are gauge fields.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields
using LinearAlgebra
function test1()
    NX = 4
    NY = 4
    NZ = 4
    NT = 4
    Nwing = 1
    Dim = 4
    NC = 3

    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)


    gauge_action = GaugeAction(U) #empty network
    plaqloop = make_loops_fromname(&quot;plaquette&quot;) #This is a plaquette loops. 
    append!(plaqloop,plaqloop') #We need hermitian conjugate loops for making the action real. 
    β = 1 #This is a coefficient.
    push!(gauge_action,β,plaqloop)
    
    show(gauge_action)

    Uout = evaluate_Gaugeaction_untraced(gauge_action,U)
    println(tr(Uout))
end

test1()"><pre><span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LinearAlgebra
<span class="pl-k">function</span> <span class="pl-en">test1</span>()
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

    U  <span class="pl-k">=</span><span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)


    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U) <span class="pl-c"><span class="pl-c">#</span>empty network</span>
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span>This is a plaquette loops. </span>
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>) <span class="pl-c"><span class="pl-c">#</span>We need hermitian conjugate loops for making the action real. </span>
    β <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">#</span>This is a coefficient.</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)
    
    <span class="pl-c1">show</span>(gauge_action)

    Uout <span class="pl-k">=</span> <span class="pl-c1">evaluate_Gaugeaction_untraced</span>(gauge_action,U)
    <span class="pl-c1">println</span>(<span class="pl-c1">tr</span>(Uout))
<span class="pl-k">end</span>

<span class="pl-c1">test1</span>()</pre></div>
<p dir="auto">The output is</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="----------------------------------------------
Structure of the actions for Gaugefields
num. of terms: 1
-------------------------------
      1-st term: 
          coefficient: 1.0
      -------------------------
1-st loop
L&quot;$U_{1}(n)U_{2}(n+e_{1})U^{\dagger}_{1}(n+e_{2})U^{\dagger}_{2}(n)$&quot;	
2-nd loop
L&quot;$U_{1}(n)U_{3}(n+e_{1})U^{\dagger}_{1}(n+e_{3})U^{\dagger}_{3}(n)$&quot;	
3-rd loop
L&quot;$U_{1}(n)U_{4}(n+e_{1})U^{\dagger}_{1}(n+e_{4})U^{\dagger}_{4}(n)$&quot;	
4-th loop
L&quot;$U_{2}(n)U_{3}(n+e_{2})U^{\dagger}_{2}(n+e_{3})U^{\dagger}_{3}(n)$&quot;	
5-th loop
L&quot;$U_{2}(n)U_{4}(n+e_{2})U^{\dagger}_{2}(n+e_{4})U^{\dagger}_{4}(n)$&quot;	
6-th loop
L&quot;$U_{3}(n)U_{4}(n+e_{3})U^{\dagger}_{3}(n+e_{4})U^{\dagger}_{4}(n)$&quot;	
7-th loop
L&quot;$U_{2}(n)U_{1}(n+e_{2})U^{\dagger}_{2}(n+e_{1})U^{\dagger}_{1}(n)$&quot;	
8-th loop
L&quot;$U_{3}(n)U_{1}(n+e_{3})U^{\dagger}_{3}(n+e_{1})U^{\dagger}_{1}(n)$&quot;	
9-th loop
L&quot;$U_{4}(n)U_{1}(n+e_{4})U^{\dagger}_{4}(n+e_{1})U^{\dagger}_{1}(n)$&quot;	
10-th loop
L&quot;$U_{3}(n)U_{2}(n+e_{3})U^{\dagger}_{3}(n+e_{2})U^{\dagger}_{2}(n)$&quot;	
11-th loop
L&quot;$U_{4}(n)U_{2}(n+e_{4})U^{\dagger}_{4}(n+e_{2})U^{\dagger}_{2}(n)$&quot;	
12-th loop
L&quot;$U_{4}(n)U_{3}(n+e_{4})U^{\dagger}_{4}(n+e_{3})U^{\dagger}_{3}(n)$&quot;	
      -------------------------
----------------------------------------------
9216.0 + 0.0im
"><pre class="notranslate"><code>----------------------------------------------
Structure of the actions for Gaugefields
num. of terms: 1
-------------------------------
      1-st term: 
          coefficient: 1.0
      -------------------------
1-st loop
L"$U_{1}(n)U_{2}(n+e_{1})U^{\dagger}_{1}(n+e_{2})U^{\dagger}_{2}(n)$"	
2-nd loop
L"$U_{1}(n)U_{3}(n+e_{1})U^{\dagger}_{1}(n+e_{3})U^{\dagger}_{3}(n)$"	
3-rd loop
L"$U_{1}(n)U_{4}(n+e_{1})U^{\dagger}_{1}(n+e_{4})U^{\dagger}_{4}(n)$"	
4-th loop
L"$U_{2}(n)U_{3}(n+e_{2})U^{\dagger}_{2}(n+e_{3})U^{\dagger}_{3}(n)$"	
5-th loop
L"$U_{2}(n)U_{4}(n+e_{2})U^{\dagger}_{2}(n+e_{4})U^{\dagger}_{4}(n)$"	
6-th loop
L"$U_{3}(n)U_{4}(n+e_{3})U^{\dagger}_{3}(n+e_{4})U^{\dagger}_{4}(n)$"	
7-th loop
L"$U_{2}(n)U_{1}(n+e_{2})U^{\dagger}_{2}(n+e_{1})U^{\dagger}_{1}(n)$"	
8-th loop
L"$U_{3}(n)U_{1}(n+e_{3})U^{\dagger}_{3}(n+e_{1})U^{\dagger}_{1}(n)$"	
9-th loop
L"$U_{4}(n)U_{1}(n+e_{4})U^{\dagger}_{4}(n+e_{1})U^{\dagger}_{1}(n)$"	
10-th loop
L"$U_{3}(n)U_{2}(n+e_{3})U^{\dagger}_{3}(n+e_{2})U^{\dagger}_{2}(n)$"	
11-th loop
L"$U_{4}(n)U_{2}(n+e_{4})U^{\dagger}_{4}(n+e_{2})U^{\dagger}_{2}(n)$"	
12-th loop
L"$U_{4}(n)U_{3}(n+e_{4})U^{\dagger}_{4}(n+e_{3})U^{\dagger}_{3}(n)$"	
      -------------------------
----------------------------------------------
9216.0 + 0.0im

</code></pre></div>
<h1 dir="auto">
<a id="user-content-how-to-calculate-derivatives" class="anchor" aria-hidden="true" href="#how-to-calculate-derivatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to calculate derivatives</h1>
<p dir="auto">We can easily calculate the matrix derivative of the actions. The matrix derivative is defined as</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="816ac4ed9d8ee312fb39e102c2c0db59">$$\frac{\partial S}{\partial U_{\mu}(n)}]_{ij} = \frac{\partial S}{\partial U_{\mu,ji}(n)}$$</math-renderer>

<p dir="auto">We can calculate this like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="dSdUμ = calc_dSdUμ(gauge_action,μ,U)"><pre>dSdUμ <span class="pl-k">=</span> <span class="pl-c1">calc_dSdUμ</span>(gauge_action,μ,U)</pre></div>
<p dir="auto">or</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="calc_dSdUμ!(dSdUμ,gauge_action,μ,U)"><pre><span class="pl-c1">calc_dSdUμ!</span>(dSdUμ,gauge_action,μ,U)</pre></div>
<h2 dir="auto">
<a id="user-content-hybrid-monte-carlo-1" class="anchor" aria-hidden="true" href="#hybrid-monte-carlo-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hybrid Monte Carlo</h2>
<p dir="auto">With the use of the matrix derivative, we can do the Hybrid Monte Carlo method.
The simple code is as follows.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields
using LinearAlgebra

function MDtest!(gauge_action,U,Dim)
    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. 
    Uold = similar(U)
    substitute_U!(Uold,U)
    MDsteps = 100
    temp1 = similar(U[1])
    temp2 = similar(U[1])
    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    numaccepted = 0

    numtrj = 100
    for itrj = 1:numtrj
        accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)
        numaccepted += ifelse(accepted,1,0)

        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        println(&quot;$itrj plaq_t = $plaq_t&quot;)
        println(&quot;acceptance ratio &quot;,numaccepted/itrj)
    end
end"><pre><span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LinearAlgebra

<span class="pl-k">function</span> <span class="pl-en">MDtest!</span>(gauge_action,U,Dim)
    p <span class="pl-k">=</span> <span class="pl-c1">initialize_TA_Gaugefields</span>(U) <span class="pl-c"><span class="pl-c">#</span>This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. </span>
    Uold <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    <span class="pl-c1">substitute_U!</span>(Uold,U)
    MDsteps <span class="pl-k">=</span> <span class="pl-c1">100</span>
    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    numaccepted <span class="pl-k">=</span> <span class="pl-c1">0</span>

    numtrj <span class="pl-k">=</span> <span class="pl-c1">100</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numtrj
        accepted <span class="pl-k">=</span> <span class="pl-c1">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold)
        numaccepted <span class="pl-k">+=</span> <span class="pl-c1">ifelse</span>(accepted,<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)

        plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>acceptance ratio <span class="pl-pds">"</span></span>,numaccepted<span class="pl-k">/</span>itrj)
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">We define the functions as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
function calc_action(gauge_action,U,p)
    NC = U[1].NC
    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_Gaugeaction_untraced(gauge_action,U))
    Sp = p*p/2
    S = Sp + Sg
    return real(S)
end

function MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)
    Δτ = 1/MDsteps
    gauss_distribution!(p)
    Sold = calc_action(gauge_action,U,p)
    substitute_U!(Uold,U)

    for itrj=1:MDsteps
        U_update!(U,p,0.5,Δτ,Dim,gauge_action)

        P_update!(U,p,1.0,Δτ,Dim,gauge_action)

        U_update!(U,p,0.5,Δτ,Dim,gauge_action)
    end
    Snew = calc_action(gauge_action,U,p)
    println(&quot;Sold = $Sold, Snew = $Snew&quot;)
    println(&quot;Snew - Sold = $(Snew-Sold)&quot;)
    ratio = min(1,exp(Snew-Sold))
    if rand() &gt; ratio
        substitute_U!(U,Uold)
        return false
    else
        return true
    end
end

function U_update!(U,p,ϵ,Δτ,Dim,gauge_action)
    temps = get_temporary_gaugefields(gauge_action)
    temp1 = temps[1]
    temp2 = temps[2]
    expU = temps[3]
    W = temps[4]

    for μ=1:Dim
        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])
        mul!(W,expU,U[μ])
        substitute_U!(U[μ],W)
        
    end
end

function P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -&gt; p +factor*U*dSdUμ
    NC = U[1].NC
    temps = get_temporary_gaugefields(gauge_action)
    dSdUμ = temps[end]
    factor =  -ϵ*Δτ/(NC)

    for μ=1:Dim
        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)
        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ
        Traceless_antihermitian_add!(p[μ],factor,temps[1])
    end
end"><pre><span class="pl-k">function</span> <span class="pl-en">calc_action</span>(gauge_action,U,p)
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    Sg <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">evaluate_GaugeAction</span>(gauge_action,U)<span class="pl-k">/</span>NC <span class="pl-c"><span class="pl-c">#</span>evaluate_GaugeAction(gauge_action,U) = tr(evaluate_Gaugeaction_untraced(gauge_action,U))</span>
    Sp <span class="pl-k">=</span> p<span class="pl-k">*</span>p<span class="pl-k">/</span><span class="pl-c1">2</span>
    S <span class="pl-k">=</span> Sp <span class="pl-k">+</span> Sg
    <span class="pl-k">return</span> <span class="pl-c1">real</span>(S)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold)
    Δτ <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>MDsteps
    <span class="pl-c1">gauss_distribution!</span>(p)
    Sold <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p)
    <span class="pl-c1">substitute_U!</span>(Uold,U)

    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>MDsteps
        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">P_update!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)
    <span class="pl-k">end</span>
    Snew <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,U,p)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-v">$Sold</span>, Snew = <span class="pl-v">$Snew</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Snew - Sold = <span class="pl-v">$(Snew<span class="pl-k">-</span>Sold)</span><span class="pl-pds">"</span></span>)
    ratio <span class="pl-k">=</span> <span class="pl-c1">min</span>(<span class="pl-c1">1</span>,<span class="pl-c1">exp</span>(Snew<span class="pl-k">-</span>Sold))
    <span class="pl-k">if</span> <span class="pl-c1">rand</span>() <span class="pl-k">&gt;</span> ratio
        <span class="pl-c1">substitute_U!</span>(U,Uold)
        <span class="pl-k">return</span> <span class="pl-c1">false</span>
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">U_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action)
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    expU <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    W <span class="pl-k">=</span> temps[<span class="pl-c1">4</span>]

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">exptU!</span>(expU,ϵ<span class="pl-k">*</span>Δτ,p[μ],[temp1,temp2])
        <span class="pl-c1">mul!</span>(W,expU,U[μ])
        <span class="pl-c1">substitute_U!</span>(U[μ],W)
        
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">P_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action) <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    dSdUμ <span class="pl-k">=</span> temps[<span class="pl-c1">end</span>]
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ<span class="pl-k">/</span>(NC)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">calc_dSdUμ!</span>(dSdUμ,gauge_action,μ,U)
        <span class="pl-c1">mul!</span>(temps[<span class="pl-c1">1</span>],U[μ],dSdUμ) <span class="pl-c"><span class="pl-c">#</span> U*dSdUμ</span>
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,temps[<span class="pl-c1">1</span>])
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Then, we can do the HMC:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function test1()
    NX = 4
    NY = 4
    NZ = 4
    NT = 4
    Nwing = 1
    Dim = 4
    NC = 3

    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;cold&quot;)


    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop') # add hermitian conjugate
    β = 5.7/2 # real part; re[p] = (p+p')/2
    push!(gauge_action,β,plaqloop)
    
    show(gauge_action)

    MDtest!(gauge_action,U,Dim)

end


test1()"><pre><span class="pl-k">function</span> <span class="pl-en">test1</span>()
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

    U  <span class="pl-k">=</span><span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cold<span class="pl-pds">"</span></span>)


    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>) <span class="pl-c"><span class="pl-c">#</span> add hermitian conjugate</span>
    β <span class="pl-k">=</span> <span class="pl-c1">5.7</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> real part; re[p] = (p+p')/2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)
    
    <span class="pl-c1">show</span>(gauge_action)

    <span class="pl-c1">MDtest!</span>(gauge_action,U,Dim)

<span class="pl-k">end</span>


<span class="pl-c1">test1</span>()</pre></div>
<h2 dir="auto">
<a id="user-content-stout-smearing" class="anchor" aria-hidden="true" href="#stout-smearing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stout smearing</h2>
<p dir="auto">We can use stout smearing.</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="816ac4ed9d8ee312fb39e102c2c0db59">$$U_{\rm fat} = {\cal F}(U)$$</math-renderer>

<p dir="auto">The smearing is regarded as gauge covariant neural networks <a href="https://arxiv.org/abs/2103.11965" rel="nofollow">Tomiya and Nagai, arXiv:2103.11965</a>.
The network is constructed as follows.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="    nn = CovNeuralnet()
    ρ = [0.1]
    layername = [&quot;plaquette&quot;]
    st = STOUT_Layer(layername,ρ,L)
    push!(nn,st)

    show(nn)"><pre>    nn <span class="pl-k">=</span> <span class="pl-c1">CovNeuralnet</span>()
    ρ <span class="pl-k">=</span> [<span class="pl-c1">0.1</span>]
    layername <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>]
    st <span class="pl-k">=</span> <span class="pl-c1">STOUT_Layer</span>(layername,ρ,L)
    <span class="pl-c1">push!</span>(nn,st)

    <span class="pl-c1">show</span>(nn)</pre></div>
<p dir="auto">The output is</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="num. of layers: 1
- 1-st layer: STOUT
num. of terms: 1
-------------------------------
      1-st term: 
          coefficient: 0.1
      -------------------------
1-st loop
L&quot;$U_{1}(n)U_{2}(n+e_{1})U^{\dagger}_{1}(n+e_{2})U^{\dagger}_{2}(n)$&quot;	
2-nd loop
L&quot;$U_{1}(n)U_{3}(n+e_{1})U^{\dagger}_{1}(n+e_{3})U^{\dagger}_{3}(n)$&quot;	
3-rd loop
L&quot;$U_{1}(n)U_{4}(n+e_{1})U^{\dagger}_{1}(n+e_{4})U^{\dagger}_{4}(n)$&quot;	
4-th loop
L&quot;$U_{2}(n)U_{3}(n+e_{2})U^{\dagger}_{2}(n+e_{3})U^{\dagger}_{3}(n)$&quot;	
5-th loop
L&quot;$U_{2}(n)U_{4}(n+e_{2})U^{\dagger}_{2}(n+e_{4})U^{\dagger}_{4}(n)$&quot;	
6-th loop
L&quot;$U_{3}(n)U_{4}(n+e_{3})U^{\dagger}_{3}(n+e_{4})U^{\dagger}_{4}(n)$&quot;	
      -------------------------"><pre class="notranslate"><code>num. of layers: 1
- 1-st layer: STOUT
num. of terms: 1
-------------------------------
      1-st term: 
          coefficient: 0.1
      -------------------------
1-st loop
L"$U_{1}(n)U_{2}(n+e_{1})U^{\dagger}_{1}(n+e_{2})U^{\dagger}_{2}(n)$"	
2-nd loop
L"$U_{1}(n)U_{3}(n+e_{1})U^{\dagger}_{1}(n+e_{3})U^{\dagger}_{3}(n)$"	
3-rd loop
L"$U_{1}(n)U_{4}(n+e_{1})U^{\dagger}_{1}(n+e_{4})U^{\dagger}_{4}(n)$"	
4-th loop
L"$U_{2}(n)U_{3}(n+e_{2})U^{\dagger}_{2}(n+e_{3})U^{\dagger}_{3}(n)$"	
5-th loop
L"$U_{2}(n)U_{4}(n+e_{2})U^{\dagger}_{2}(n+e_{4})U^{\dagger}_{4}(n)$"	
6-th loop
L"$U_{3}(n)U_{4}(n+e_{3})U^{\dagger}_{3}(n+e_{4})U^{\dagger}_{4}(n)$"	
      -------------------------
</code></pre></div>
<p dir="auto">Since we ragard the smearing as the neural networks, we can calculate the derivative with the use of the back propergation techques.</p>
<math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="816ac4ed9d8ee312fb39e102c2c0db59">$$\frac{\partial S}{\partial U} = G \left( \frac{dS}{dU_{\rm fat}},U \right)$$</math-renderer>

<p dir="auto">For example,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields
using Wilsonloop

function stoutsmearing(NX,NY,NZ,NT,NC)
    Nwing = 1
    Dim = 4
    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;)
    L = [NX,NY,NZ,NT]

    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    temp1 = similar(U[1])
    temp2 = similar(U[1])
    plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
    println(&quot; plaq_t = $plaq_t&quot;)


    nn = CovNeuralnet()
    ρ = [0.1]
    layername = [&quot;plaquette&quot;]
    st = STOUT_Layer(layername,ρ,L)
    push!(nn,st)

    show(nn)

    
    @time Uout,Uout_multi,_ = calc_smearedU(U,nn)
    plaq_t = calculate_Plaquette(Uout,temp1,temp2)*factor
    println(&quot;plaq_t = $plaq_t&quot;)


    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop')# add hermitian conjugate
    β = 5.7/2 # real part; re[p] = (p+p')/2
    push!(gauge_action,β,plaqloop)

    μ = 1
    dSdUμ = similar(U)
    for μ=1:Dim
        dSdUμ[μ] = calc_dSdUμ(gauge_action,μ,U)
    end

    @time dSdUbareμ = back_prop(dSdUμ,nn,Uout_multi,U) 

end

NX = 4
NY = 4
NZ = 4
NT = 4
NC = 3
stoutsmearing(NX,NY,NZ,NT,NC)"><pre><span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> Wilsonloop

<span class="pl-k">function</span> <span class="pl-en">stoutsmearing</span>(NX,NY,NZ,NT,NC)
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    U <span class="pl-k">=</span> <span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>)
    L <span class="pl-k">=</span> [NX,NY,NZ,NT]

    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)


    nn <span class="pl-k">=</span> <span class="pl-c1">CovNeuralnet</span>()
    ρ <span class="pl-k">=</span> [<span class="pl-c1">0.1</span>]
    layername <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>]
    st <span class="pl-k">=</span> <span class="pl-c1">STOUT_Layer</span>(layername,ρ,L)
    <span class="pl-c1">push!</span>(nn,st)

    <span class="pl-c1">show</span>(nn)

    
    <span class="pl-c1">@time</span> Uout,Uout_multi,_ <span class="pl-k">=</span> <span class="pl-c1">calc_smearedU</span>(U,nn)
    plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(Uout,temp1,temp2)<span class="pl-k">*</span>factor
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)


    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)<span class="pl-c"><span class="pl-c">#</span> add hermitian conjugate</span>
    β <span class="pl-k">=</span> <span class="pl-c1">5.7</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> real part; re[p] = (p+p')/2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)

    μ <span class="pl-k">=</span> <span class="pl-c1">1</span>
    dSdUμ <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        dSdUμ[μ] <span class="pl-k">=</span> <span class="pl-c1">calc_dSdUμ</span>(gauge_action,μ,U)
    <span class="pl-k">end</span>

    <span class="pl-c1">@time</span> dSdUbareμ <span class="pl-k">=</span> <span class="pl-c1">back_prop</span>(dSdUμ,nn,Uout_multi,U) 

<span class="pl-k">end</span>

NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
NC <span class="pl-k">=</span> <span class="pl-c1">3</span>
<span class="pl-c1">stoutsmearing</span>(NX,NY,NZ,NT,NC)</pre></div>
<h1 dir="auto">
<a id="user-content-hmc-with-stout-smearing" class="anchor" aria-hidden="true" href="#hmc-with-stout-smearing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>HMC with stout smearing</h1>
<p dir="auto">With the use of the derivatives, we can do the HMC with the stout smearing.
The code is shown as follows</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Gaugefields
using LinearAlgebra

function MDtest!(gauge_action,U,Dim,nn)
    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. 
    Uold = similar(U)
    dSdU = similar(U)
    
    substitute_U!(Uold,U)
    MDsteps = 100
    temp1 = similar(U[1])
    temp2 = similar(U[1])
    comb = 6
    factor = 1/(comb*U[1].NV*U[1].NC)
    numaccepted = 0
    

    numtrj = 100
    for itrj = 1:numtrj
        accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)
        numaccepted += ifelse(accepted,1,0)

        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor
        println(&quot;$itrj plaq_t = $plaq_t&quot;)
        println(&quot;acceptance ratio &quot;,numaccepted/itrj)
    end
end

function calc_action(gauge_action,U,p)
    NC = U[1].NC
    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))
    Sp = p*p/2
    S = Sp + Sg
    return real(S)
end


function MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)
    

    Δτ = 1/MDsteps
    gauss_distribution!(p)

    Uout,Uout_multi,_ = calc_smearedU(U,nn)
    Sold = calc_action(gauge_action,Uout,p)

    substitute_U!(Uold,U)

    for itrj=1:MDsteps
        U_update!(U,p,0.5,Δτ,Dim,gauge_action)

        P_update!(U,p,1.0,Δτ,Dim,gauge_action,dSdU,nn)

        U_update!(U,p,0.5,Δτ,Dim,gauge_action)
    end

    Uout,Uout_multi,_ = calc_smearedU(U,nn)
    Snew = calc_action(gauge_action,Uout,p)

    println(&quot;Sold = $Sold, Snew = $Snew&quot;)
    println(&quot;Snew - Sold = $(Snew-Sold)&quot;)

    accept = exp(Sold - Snew) &gt;= rand()

    if accept != true #rand() &gt; ratio
        substitute_U!(U,Uold)
        return false
    else
        return true
    end

end

function U_update!(U,p,ϵ,Δτ,Dim,gauge_action)
    temps = get_temporary_gaugefields(gauge_action)
    temp1 = temps[1]
    temp2 = temps[2]
    expU = temps[3]
    W = temps[4]

    for μ=1:Dim
        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])
        mul!(W,expU,U[μ])
        substitute_U!(U[μ],W)
        
    end
end

function P_update!(U,p,ϵ,Δτ,Dim,gauge_action,dSdU,nn) # p -&gt; p +factor*U*dSdUμ
    NC = U[1].NC
    factor =  -ϵ*Δτ/(NC)
    temps = get_temporary_gaugefields(gauge_action)
    Uout,Uout_multi,_ = calc_smearedU(U,nn)

    for μ=1:Dim
        calc_dSdUμ!(dSdU[μ],gauge_action,μ,Uout)
    end

    dSdUbare = back_prop(dSdU,nn,Uout_multi,U) 
    
    for μ=1:Dim
        mul!(temps[1],U[μ],dSdUbare[μ]) # U*dSdUμ
        Traceless_antihermitian_add!(p[μ],factor,temps[1])
    end
end

function test1()
    NX = 4
    NY = 4
    NZ = 4
    NT = 4
    Nwing = 1
    Dim = 4
    NC = 3

    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = &quot;hot&quot;)


    gauge_action = GaugeAction(U)
    plaqloop = make_loops_fromname(&quot;plaquette&quot;)
    append!(plaqloop,plaqloop')
    β = 5.7/2
    push!(gauge_action,β,plaqloop)

    show(gauge_action)

    L = [NX,NY,NZ,NT]
    nn = CovNeuralnet()
    ρ = [0.1]
    layername = [&quot;plaquette&quot;]
    st = STOUT_Layer(layername,ρ,L)
    push!(nn,st)

    

    MDtest!(gauge_action,U,Dim,nn)

end


test1()"><pre><span class="pl-k">using</span> Gaugefields
<span class="pl-k">using</span> LinearAlgebra

<span class="pl-k">function</span> <span class="pl-en">MDtest!</span>(gauge_action,U,Dim,nn)
    p <span class="pl-k">=</span> <span class="pl-c1">initialize_TA_Gaugefields</span>(U) <span class="pl-c"><span class="pl-c">#</span>This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. </span>
    Uold <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    dSdU <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U)
    
    <span class="pl-c1">substitute_U!</span>(Uold,U)
    MDsteps <span class="pl-k">=</span> <span class="pl-c1">100</span>
    temp1 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    temp2 <span class="pl-k">=</span> <span class="pl-c1">similar</span>(U[<span class="pl-c1">1</span>])
    comb <span class="pl-k">=</span> <span class="pl-c1">6</span>
    factor <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(comb<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NV<span class="pl-k">*</span>U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC)
    numaccepted <span class="pl-k">=</span> <span class="pl-c1">0</span>
    

    numtrj <span class="pl-k">=</span> <span class="pl-c1">100</span>
    <span class="pl-k">for</span> itrj <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>numtrj
        accepted <span class="pl-k">=</span> <span class="pl-c1">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)
        numaccepted <span class="pl-k">+=</span> <span class="pl-c1">ifelse</span>(accepted,<span class="pl-c1">1</span>,<span class="pl-c1">0</span>)

        plaq_t <span class="pl-k">=</span> <span class="pl-c1">calculate_Plaquette</span>(U,temp1,temp2)<span class="pl-k">*</span>factor
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$itrj</span> plaq_t = <span class="pl-v">$plaq_t</span><span class="pl-pds">"</span></span>)
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>acceptance ratio <span class="pl-pds">"</span></span>,numaccepted<span class="pl-k">/</span>itrj)
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">calc_action</span>(gauge_action,U,p)
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    Sg <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">evaluate_GaugeAction</span>(gauge_action,U)<span class="pl-k">/</span>NC <span class="pl-c"><span class="pl-c">#</span>evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))</span>
    Sp <span class="pl-k">=</span> p<span class="pl-k">*</span>p<span class="pl-k">/</span><span class="pl-c1">2</span>
    S <span class="pl-k">=</span> Sp <span class="pl-k">+</span> Sg
    <span class="pl-k">return</span> <span class="pl-c1">real</span>(S)
<span class="pl-k">end</span>


<span class="pl-k">function</span> <span class="pl-en">MDstep!</span>(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)
    

    Δτ <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">/</span>MDsteps
    <span class="pl-c1">gauss_distribution!</span>(p)

    Uout,Uout_multi,_ <span class="pl-k">=</span> <span class="pl-c1">calc_smearedU</span>(U,nn)
    Sold <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,Uout,p)

    <span class="pl-c1">substitute_U!</span>(Uold,U)

    <span class="pl-k">for</span> itrj<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>MDsteps
        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)

        <span class="pl-c1">P_update!</span>(U,p,<span class="pl-c1">1.0</span>,Δτ,Dim,gauge_action,dSdU,nn)

        <span class="pl-c1">U_update!</span>(U,p,<span class="pl-c1">0.5</span>,Δτ,Dim,gauge_action)
    <span class="pl-k">end</span>

    Uout,Uout_multi,_ <span class="pl-k">=</span> <span class="pl-c1">calc_smearedU</span>(U,nn)
    Snew <span class="pl-k">=</span> <span class="pl-c1">calc_action</span>(gauge_action,Uout,p)

    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Sold = <span class="pl-v">$Sold</span>, Snew = <span class="pl-v">$Snew</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Snew - Sold = <span class="pl-v">$(Snew<span class="pl-k">-</span>Sold)</span><span class="pl-pds">"</span></span>)

    accept <span class="pl-k">=</span> <span class="pl-c1">exp</span>(Sold <span class="pl-k">-</span> Snew) <span class="pl-k">&gt;=</span> <span class="pl-c1">rand</span>()

    <span class="pl-k">if</span> accept <span class="pl-k">!=</span> <span class="pl-c1">true</span> <span class="pl-c"><span class="pl-c">#</span>rand() &gt; ratio</span>
        <span class="pl-c1">substitute_U!</span>(U,Uold)
        <span class="pl-k">return</span> <span class="pl-c1">false</span>
    <span class="pl-k">else</span>
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    <span class="pl-k">end</span>

<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">U_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action)
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    temp1 <span class="pl-k">=</span> temps[<span class="pl-c1">1</span>]
    temp2 <span class="pl-k">=</span> temps[<span class="pl-c1">2</span>]
    expU <span class="pl-k">=</span> temps[<span class="pl-c1">3</span>]
    W <span class="pl-k">=</span> temps[<span class="pl-c1">4</span>]

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">exptU!</span>(expU,ϵ<span class="pl-k">*</span>Δτ,p[μ],[temp1,temp2])
        <span class="pl-c1">mul!</span>(W,expU,U[μ])
        <span class="pl-c1">substitute_U!</span>(U[μ],W)
        
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">P_update!</span>(U,p,ϵ,Δτ,Dim,gauge_action,dSdU,nn) <span class="pl-c"><span class="pl-c">#</span> p -&gt; p +factor*U*dSdUμ</span>
    NC <span class="pl-k">=</span> U[<span class="pl-c1">1</span>]<span class="pl-k">.</span>NC
    factor <span class="pl-k">=</span>  <span class="pl-k">-</span>ϵ<span class="pl-k">*</span>Δτ<span class="pl-k">/</span>(NC)
    temps <span class="pl-k">=</span> <span class="pl-c1">get_temporary_gaugefields</span>(gauge_action)
    Uout,Uout_multi,_ <span class="pl-k">=</span> <span class="pl-c1">calc_smearedU</span>(U,nn)

    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">calc_dSdUμ!</span>(dSdU[μ],gauge_action,μ,Uout)
    <span class="pl-k">end</span>

    dSdUbare <span class="pl-k">=</span> <span class="pl-c1">back_prop</span>(dSdU,nn,Uout_multi,U) 
    
    <span class="pl-k">for</span> μ<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>Dim
        <span class="pl-c1">mul!</span>(temps[<span class="pl-c1">1</span>],U[μ],dSdUbare[μ]) <span class="pl-c"><span class="pl-c">#</span> U*dSdUμ</span>
        <span class="pl-c1">Traceless_antihermitian_add!</span>(p[μ],factor,temps[<span class="pl-c1">1</span>])
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">test1</span>()
    NX <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NY <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NZ <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NT <span class="pl-k">=</span> <span class="pl-c1">4</span>
    Nwing <span class="pl-k">=</span> <span class="pl-c1">1</span>
    Dim <span class="pl-k">=</span> <span class="pl-c1">4</span>
    NC <span class="pl-k">=</span> <span class="pl-c1">3</span>

    U  <span class="pl-k">=</span><span class="pl-c1">Initialize_Gaugefields</span>(NC,Nwing,NX,NY,NZ,NT,condition <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hot<span class="pl-pds">"</span></span>)


    gauge_action <span class="pl-k">=</span> <span class="pl-c1">GaugeAction</span>(U)
    plaqloop <span class="pl-k">=</span> <span class="pl-c1">make_loops_fromname</span>(<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>)
    <span class="pl-c1">append!</span>(plaqloop,plaqloop<span class="pl-k">'</span>)
    β <span class="pl-k">=</span> <span class="pl-c1">5.7</span><span class="pl-k">/</span><span class="pl-c1">2</span>
    <span class="pl-c1">push!</span>(gauge_action,β,plaqloop)

    <span class="pl-c1">show</span>(gauge_action)

    L <span class="pl-k">=</span> [NX,NY,NZ,NT]
    nn <span class="pl-k">=</span> <span class="pl-c1">CovNeuralnet</span>()
    ρ <span class="pl-k">=</span> [<span class="pl-c1">0.1</span>]
    layername <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>plaquette<span class="pl-pds">"</span></span>]
    st <span class="pl-k">=</span> <span class="pl-c1">STOUT_Layer</span>(layername,ρ,L)
    <span class="pl-c1">push!</span>(nn,st)

    

    <span class="pl-c1">MDtest!</span>(gauge_action,U,Dim,nn)

<span class="pl-k">end</span>


<span class="pl-c1">test1</span>()</pre></div>
</article></div>