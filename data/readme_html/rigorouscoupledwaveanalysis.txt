<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-rigorouscoupledwaveanalysisjl---rigorous-coupled-wave-analysis-rcwa" class="anchor" aria-hidden="true" href="#rigorouscoupledwaveanalysisjl---rigorous-coupled-wave-analysis-rcwa"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>RigorousCoupledWaveAnalysis.jl - Rigorous Coupled-Wave Analysis (RCWA)</h1>
<p>This implements both the scattering matrix and the enhanced transmission matrix RCWA algorithms in julia for periodic multilayer structures in nano-optics and RF.</p>
<table>
<thead>
<tr>
<th align="center">Status</th>
<th align="center">Coverage</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://travis-ci.com/jonschlipf/RigorousCoupledWaveAnalysis.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/cdcdaf21934d95ee94ef44c2834f41a7ad5045b9ac93adb1fc876602516b6c9d/68747470733a2f2f7472617669732d63692e636f6d2f6a6f6e7363686c6970662f5269676f726f7573436f75706c656457617665416e616c797369732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jonschlipf/RigorousCoupledWaveAnalysis.jl.svg?branch=master" style="max-width:100%;"></a></td>
<td align="center"><a href="http://codecov.io/gh/jonschlipf/RigorousCoupledWaveAnalysis.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/954898309f0015323fa28b202b2fd1a6fdbe7332702ef60d9e3438416fd6bf5f/687474703a2f2f636f6465636f762e696f2f67682f6a6f6e7363686c6970662f5269676f726f7573436f75706c656457617665416e616c797369732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/gh/jonschlipf/RigorousCoupledWaveAnalysis.jl/coverage.svg?branch=master" style="max-width:100%;"></a></td>
</tr>
</tbody>
</table>
<h2><a id="user-content-modeling" class="anchor" aria-hidden="true" href="#modeling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Modeling</h2>
<h3><a id="user-content-materials" class="anchor" aria-hidden="true" href="#materials"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Materials</h3>
<p>The package supports isotropic materials along with diagonal and in-plane anisotropy so far. RCWA is a frequency domain method, so spectroscopic data can be taken directly and arbitrary permittivities can be entered. One can implement constant permittivities, dispersion formulas or interpolated spectroscopic data.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Air=ConstantPerm(1) #air material with relative permittivity of 1
M1=ConstantPerm(4+2im) #independent of wavelength, the permittivity has a value of 4+2i
wavelength=600:100:1600  #wavelength axis for interpolated permittivity data
e=[3,4,5,6,5,4,3,2,3,4,5] #permittivity data to be interpolated
using Interpolations
E=interpolate((wavelength,), e, Gridded(Linear()))
M2=InterpolPerm(E) #model with interpolated permittivity
"><pre>Air<span class="pl-k">=</span><span class="pl-c1">ConstantPerm</span>(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span>air material with relative permittivity of 1</span>
M1<span class="pl-k">=</span><span class="pl-c1">ConstantPerm</span>(<span class="pl-c1">4</span><span class="pl-k">+</span><span class="pl-c1">2im</span>) <span class="pl-c"><span class="pl-c">#</span>independent of wavelength, the permittivity has a value of 4+2i</span>
wavelength<span class="pl-k">=</span><span class="pl-c1">600</span><span class="pl-k">:</span><span class="pl-c1">100</span><span class="pl-k">:</span><span class="pl-c1">1600</span>  <span class="pl-c"><span class="pl-c">#</span>wavelength axis for interpolated permittivity data</span>
e<span class="pl-k">=</span>[<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">3</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>] <span class="pl-c"><span class="pl-c">#</span>permittivity data to be interpolated</span>
<span class="pl-k">using</span> Interpolations
E<span class="pl-k">=</span><span class="pl-c1">interpolate</span>((wavelength,), e, <span class="pl-c1">Gridded</span>(<span class="pl-c1">Linear</span>()))
M2<span class="pl-k">=</span><span class="pl-c1">InterpolPerm</span>(E) <span class="pl-c"><span class="pl-c">#</span>model with interpolated permittivity</span></pre></div>
<p>Some literature materials are already included by default. More can be incorporated on request.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Si=InterpolPerm(RigorousCoupledWaveAnalysis.si_schinke) #Si from interpolated literature values
Ge=InterpolPerm(RigorousCoupledWaveAnalysis.ge_nunley) #Ge from interpolated literature values
SiO2=ModelPerm(RigorousCoupledWaveAnalysis.sio2_malitson) #SiO2 from literature dispersion formula
Al=ModelPerm(RigorousCoupledWaveAnalysis.al_rakic) #Al from literature dispersion formula
"><pre>Si<span class="pl-k">=</span><span class="pl-c1">InterpolPerm</span>(RigorousCoupledWaveAnalysis<span class="pl-k">.</span>si_schinke) <span class="pl-c"><span class="pl-c">#</span>Si from interpolated literature values</span>
Ge<span class="pl-k">=</span><span class="pl-c1">InterpolPerm</span>(RigorousCoupledWaveAnalysis<span class="pl-k">.</span>ge_nunley) <span class="pl-c"><span class="pl-c">#</span>Ge from interpolated literature values</span>
SiO2<span class="pl-k">=</span><span class="pl-c1">ModelPerm</span>(RigorousCoupledWaveAnalysis<span class="pl-k">.</span>sio2_malitson) <span class="pl-c"><span class="pl-c">#</span>SiO2 from literature dispersion formula</span>
Al<span class="pl-k">=</span><span class="pl-c1">ModelPerm</span>(RigorousCoupledWaveAnalysis<span class="pl-k">.</span>al_rakic) <span class="pl-c"><span class="pl-c">#</span>Al from literature dispersion formula</span></pre></div>
<h3><a id="user-content-geometry" class="anchor" aria-hidden="true" href="#geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Geometry</h3>
<p>One can specify the distribution of materials within each layer with simple geometric shapes. Currently, the package analytically implements rectangular and elliptic inclusions. Rotation and translation in the plane is also possible. All coordinates are relative to the cell size in the respective direction. For simple verification of the geometry design, the RigorousCoupledWaveAnalysis.drawable function yields the x and y coordinates of the outline.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="R=Rectangle(.2,.2) #create rectangle with width and height one fifth of the cell size
E=Ellipse(.1,.3) #create ellipse with relative radius 0.1 along the x axis and 0.3 along the y axis
R=Rotation(R,pi/4) #rotate the rectangle in the plane by 45 degrees
E=Shift(E,.8,.1) #shift the ellipse in x-direction by 0.8 and in y-direction by 0.1
Geo=Combination([R,E]) #combine the ellipse and rectangle into one geometry object
Cir=Circle(480/950) #a circle with a diameter of 480 nm in a unit cell with a pitch of 950 nm
x,y=RigorousCoupledWaveAnalysis.drawable(Geo)
"><pre>R<span class="pl-k">=</span><span class="pl-c1">Rectangle</span>(<span class="pl-c1">.2</span>,<span class="pl-c1">.2</span>) <span class="pl-c"><span class="pl-c">#</span>create rectangle with width and height one fifth of the cell size</span>
E<span class="pl-k">=</span><span class="pl-c1">Ellipse</span>(<span class="pl-c1">.1</span>,<span class="pl-c1">.3</span>) <span class="pl-c"><span class="pl-c">#</span>create ellipse with relative radius 0.1 along the x axis and 0.3 along the y axis</span>
R<span class="pl-k">=</span><span class="pl-c1">Rotation</span>(R,<span class="pl-c1">pi</span><span class="pl-k">/</span><span class="pl-c1">4</span>) <span class="pl-c"><span class="pl-c">#</span>rotate the rectangle in the plane by 45 degrees</span>
E<span class="pl-k">=</span><span class="pl-c1">Shift</span>(E,<span class="pl-c1">.8</span>,<span class="pl-c1">.1</span>) <span class="pl-c"><span class="pl-c">#</span>shift the ellipse in x-direction by 0.8 and in y-direction by 0.1</span>
Geo<span class="pl-k">=</span><span class="pl-c1">Combination</span>([R,E]) <span class="pl-c"><span class="pl-c">#</span>combine the ellipse and rectangle into one geometry object</span>
Cir<span class="pl-k">=</span><span class="pl-c1">Circle</span>(<span class="pl-c1">480</span><span class="pl-k">/</span><span class="pl-c1">950</span>) <span class="pl-c"><span class="pl-c">#</span>a circle with a diameter of 480 nm in a unit cell with a pitch of 950 nm</span>
x,y<span class="pl-k">=</span>RigorousCoupledWaveAnalysis<span class="pl-k">.</span><span class="pl-c1">drawable</span>(Geo)</pre></div>
<p>It is also possible to compute the RCWA for arbitrary structures defined by a bit mask using the Fourier transform. Here, a reciprocal space grid is required before modeling. See the section on grids below for guidelines how to choose the grid order.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="N=4
nx,ny,dnx,dny=ngrid(N,N) #define a grid of reciprocal space, with maximum spatial frequency N
using Random
f=bitrand(100,100) #define the geometry of the unit cell as a random 10x10 bit mask
F=real2recip(dnx,dny,f) #Fourier transform the geometry to the reciprocal space grid
Geo=Custom(F) #custom geometry object with the defined structure
"><pre>N<span class="pl-k">=</span><span class="pl-c1">4</span>
nx,ny,dnx,dny<span class="pl-k">=</span><span class="pl-c1">ngrid</span>(N,N) <span class="pl-c"><span class="pl-c">#</span>define a grid of reciprocal space, with maximum spatial frequency N</span>
<span class="pl-k">using</span> Random
f<span class="pl-k">=</span><span class="pl-c1">bitrand</span>(<span class="pl-c1">100</span>,<span class="pl-c1">100</span>) <span class="pl-c"><span class="pl-c">#</span>define the geometry of the unit cell as a random 10x10 bit mask</span>
F<span class="pl-k">=</span><span class="pl-c1">real2recip</span>(dnx,dny,f) <span class="pl-c"><span class="pl-c">#</span>Fourier transform the geometry to the reciprocal space grid</span>
Geo<span class="pl-k">=</span><span class="pl-c1">Custom</span>(F) <span class="pl-c"><span class="pl-c">#</span>custom geometry object with the defined structure</span></pre></div>
<h3><a id="user-content-layers" class="anchor" aria-hidden="true" href="#layers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Layers</h3>
<p>There are structures implemented for simple (=homogenous) layers and patterned layers. A plain layer requires just a thickness and a material object. A patterned layer is defined by its thickness, an array of materials (at least one) and an array of geometry objects (the size of the geometry array should be one smaller than that of the materials array).</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="nha=PatternedLayer(100,[Al,Air],[Cir]) # the a nanohole in the Al layer is filled with air
spa=SimpleLayer(50,SiO2)
nsi=SimpleLayer(20,Si)
nge=SimpleLayer(20,Ge)
ige=SimpleLayer(480,Ge)
"><pre>nha<span class="pl-k">=</span><span class="pl-c1">PatternedLayer</span>(<span class="pl-c1">100</span>,[Al,Air],[Cir]) <span class="pl-c"><span class="pl-c">#</span> the a nanohole in the Al layer is filled with air</span>
spa<span class="pl-k">=</span><span class="pl-c1">SimpleLayer</span>(<span class="pl-c1">50</span>,SiO2)
nsi<span class="pl-k">=</span><span class="pl-c1">SimpleLayer</span>(<span class="pl-c1">20</span>,Si)
nge<span class="pl-k">=</span><span class="pl-c1">SimpleLayer</span>(<span class="pl-c1">20</span>,Ge)
ige<span class="pl-k">=</span><span class="pl-c1">SimpleLayer</span>(<span class="pl-c1">480</span>,Ge)</pre></div>
<h3><a id="user-content-building-models" class="anchor" aria-hidden="true" href="#building-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Building models</h3>
<p>A model object requires an arrays of layers (sorted in direction of the light propagation) and the materials for the superstrate and substrate halfspaces.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Mdl=RCWAModel([nha,spa,nsi,nge,ige],Air,Si) # a nanohole array device with the layers defined as in the previous section on a Si substrate
"><pre>Mdl<span class="pl-k">=</span><span class="pl-c1">RCWAModel</span>([nha,spa,nsi,nge,ige],Air,Si) <span class="pl-c"><span class="pl-c">#</span> a nanohole array device with the layers defined as in the previous section on a Si substrate</span></pre></div>
<h3><a id="user-content-computation-grid" class="anchor" aria-hidden="true" href="#computation-grid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Computation grid</h3>
<p>RCWA computations are carried out in discretized reciprocal space, so a grid is required. The grid can be discretized by 2π/a, where a is the lattice constant of the 2D unit cell. One has to specify the direction of the impinging plane wave by θ and α, as well as the lattice constant in x and y ax and ay. The only parameter in RCWA that affects accuracy vs performance is N, the maximum spatial frequency to be considered. N=4 is normally a good value for all-dielectric metasurfaces, plasmonics requires higher N.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="N=4 #maximum spatial frequency, same for x and y
λ=1000 #nm wavelength
θ=1E-5 #elevation angle, zero will yield a singularity inversion error
α=0 #azimuth angle
ax=ay=500 #500 nm square cell
λ=1000 #wavelength
Grd=rcwagrid(N,N,ax,ay,θ,α,λ,Air) #create the grid, superstrate is air
"><pre>N<span class="pl-k">=</span><span class="pl-c1">4</span> <span class="pl-c"><span class="pl-c">#</span>maximum spatial frequency, same for x and y</span>
λ<span class="pl-k">=</span><span class="pl-c1">1000</span> <span class="pl-c"><span class="pl-c">#</span>nm wavelength</span>
θ<span class="pl-k">=</span><span class="pl-c1">1E-5</span> <span class="pl-c"><span class="pl-c">#</span>elevation angle, zero will yield a singularity inversion error</span>
α<span class="pl-k">=</span><span class="pl-c1">0</span> <span class="pl-c"><span class="pl-c">#</span>azimuth angle</span>
ax<span class="pl-k">=</span>ay<span class="pl-k">=</span><span class="pl-c1">500</span> <span class="pl-c"><span class="pl-c">#</span>500 nm square cell</span>
λ<span class="pl-k">=</span><span class="pl-c1">1000</span> <span class="pl-c"><span class="pl-c">#</span>wavelength</span>
Grd<span class="pl-k">=</span><span class="pl-c1">rcwagrid</span>(N,N,ax,ay,θ,α,λ,Air) <span class="pl-c"><span class="pl-c">#</span>create the grid, superstrate is air</span></pre></div>
<h3><a id="user-content-solution" class="anchor" aria-hidden="true" href="#solution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Solution</h3>
<p>One can employ the enhanced transmission matrix (etm) approach to solve the Maxwell equations for their system. This will yield the reflected and transmitted power.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ste,stm=rcwasource(Grd)    #create a source object
Rte,Tte=etm_reftra(ste,Mdl,Grd,λ) #run the etm algorithm for TE polarization
Rtm,Ttm=etm_reftra(stm,Mdl,Grd,λ) #run the etm algorithm for TM polarization
"><pre>ste,stm<span class="pl-k">=</span><span class="pl-c1">rcwasource</span>(Grd)    <span class="pl-c"><span class="pl-c">#</span>create a source object</span>
Rte,Tte<span class="pl-k">=</span><span class="pl-c1">etm_reftra</span>(ste,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>run the etm algorithm for TE polarization</span>
Rtm,Ttm<span class="pl-k">=</span><span class="pl-c1">etm_reftra</span>(stm,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>run the etm algorithm for TM polarization</span></pre></div>
<p>The scatter matrix method can be called in the same manner.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ste,stm=rcwasource(Grd)    #create a source object
Rte,Tte=srcwa_reftra(ste,Mdl,Grd,λ) #run the srcwa algorithm for TE polarization
Rtm,Ttm=srcwa_reftra(stm,Mdl,Grd,λ) #run the srcwa algorithm for TM polarization
"><pre>ste,stm<span class="pl-k">=</span><span class="pl-c1">rcwasource</span>(Grd)    <span class="pl-c"><span class="pl-c">#</span>create a source object</span>
Rte,Tte<span class="pl-k">=</span><span class="pl-c1">srcwa_reftra</span>(ste,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>run the srcwa algorithm for TE polarization</span>
Rtm,Ttm<span class="pl-k">=</span><span class="pl-c1">srcwa_reftra</span>(stm,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>run the srcwa algorithm for TM polarization</span></pre></div>
<p>Absorptions within the layers can be computed from the power flows between them</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ste,stm=rcwasource(Grd)    #create a source object
Rte,Tte,fte=etm_reftra_flows(ste,Mdl,Grd,λ) #TE
Ate=-fte[end]-Tte #absorption in lowest layer
Rtm,Ttm,ftm=etm_reftra_flows(stm,Mdl,Grd,λ) #TM
Ate=-ftm[end]-Ttm #absorption in lowest layer
"><pre>ste,stm<span class="pl-k">=</span><span class="pl-c1">rcwasource</span>(Grd)    <span class="pl-c"><span class="pl-c">#</span>create a source object</span>
Rte,Tte,fte<span class="pl-k">=</span><span class="pl-c1">etm_reftra_flows</span>(ste,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>TE</span>
Ate<span class="pl-k">=</span><span class="pl-k">-</span>fte[<span class="pl-c1">end</span>]<span class="pl-k">-</span>Tte <span class="pl-c"><span class="pl-c">#</span>absorption in lowest layer</span>
Rtm,Ttm,ftm<span class="pl-k">=</span><span class="pl-c1">etm_reftra_flows</span>(stm,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>TM</span>
Ate<span class="pl-k">=</span><span class="pl-k">-</span>ftm[<span class="pl-c1">end</span>]<span class="pl-k">-</span>Ttm <span class="pl-c"><span class="pl-c">#</span>absorption in lowest layer</span></pre></div>
<h3><a id="user-content-local-fields" class="anchor" aria-hidden="true" href="#local-fields"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Local fields</h3>
<p>Local electric and magnetic fields are obtainable via the propagating amplitudes as well:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="em=RigorousCoupledWaveAnalysis.eigenmodes(Grd,λ,ly)      #get the eigenmodes of propagation in the first layer (this is the nanohole array)
a,b=etm_amplitudes(ste,Mdl,Grd,λ) #get propagating wave amplitudes inside layer
points=[100,100,10]               #set the number of points to compute in x,y,z
E,H=RigorousCoupledWaveAnalysis.getfields(a[1],b[1],Mdl.layers[1].thickness,em,Grd,points,λ) #compute the electric and magnetic field
"><pre>em<span class="pl-k">=</span>RigorousCoupledWaveAnalysis<span class="pl-k">.</span><span class="pl-c1">eigenmodes</span>(Grd,λ,ly)      <span class="pl-c"><span class="pl-c">#</span>get the eigenmodes of propagation in the first layer (this is the nanohole array)</span>
a,b<span class="pl-k">=</span><span class="pl-c1">etm_amplitudes</span>(ste,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>get propagating wave amplitudes inside layer</span>
points<span class="pl-k">=</span>[<span class="pl-c1">100</span>,<span class="pl-c1">100</span>,<span class="pl-c1">10</span>]               <span class="pl-c"><span class="pl-c">#</span>set the number of points to compute in x,y,z</span>
E,H<span class="pl-k">=</span>RigorousCoupledWaveAnalysis<span class="pl-k">.</span><span class="pl-c1">getfields</span>(a[<span class="pl-c1">1</span>],b[<span class="pl-c1">1</span>],Mdl<span class="pl-k">.</span>layers[<span class="pl-c1">1</span>]<span class="pl-k">.</span>thickness,em,Grd,points,λ) <span class="pl-c"><span class="pl-c">#</span>compute the electric and magnetic field</span></pre></div>
<p>Or via scattering matrix algorithm:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using LinearAlgebra
em=RigorousCoupledWaveAnalysis.eigenmodes(Grd,λ,ly)        #get the eigenmodes of propagation in the first layer (this is the nanohole array)
a,b=srcwa_amplitudes(ste,Mdl,Grd,λ) #get propagating wave amplitudes outside layer
ain,bout=slicehalf(.5*[em.W\I+em.V\Grd.V0 em.W\I-em.V\Grd.V0;em.W\I-em.V\Grd.V0 em.W\I+em.V\Grd.V0]*[a[:,1];b[:,1]]) #get propagating wave amplitudes inside layer
points=[100,100,10]               #set the number of points to compute in x,y,z
E,H=RigorousCoupledWaveAnalysis.getfields(a[1],b[1],Mdl.layers[1].thickness,em,Grd,points,λ) #compute the electric and magnetic field
"><pre><span class="pl-k">using</span> LinearAlgebra
em<span class="pl-k">=</span>RigorousCoupledWaveAnalysis<span class="pl-k">.</span><span class="pl-c1">eigenmodes</span>(Grd,λ,ly)        <span class="pl-c"><span class="pl-c">#</span>get the eigenmodes of propagation in the first layer (this is the nanohole array)</span>
a,b<span class="pl-k">=</span><span class="pl-c1">srcwa_amplitudes</span>(ste,Mdl,Grd,λ) <span class="pl-c"><span class="pl-c">#</span>get propagating wave amplitudes outside layer</span>
ain,bout<span class="pl-k">=</span><span class="pl-c1">slicehalf</span>(<span class="pl-c1">.5</span><span class="pl-k">*</span>[em<span class="pl-k">.</span>W<span class="pl-k">\</span>I<span class="pl-k">+</span>em<span class="pl-k">.</span>V<span class="pl-k">\</span>Grd<span class="pl-k">.</span>V0 em<span class="pl-k">.</span>W<span class="pl-k">\</span>I<span class="pl-k">-</span>em<span class="pl-k">.</span>V<span class="pl-k">\</span>Grd<span class="pl-k">.</span>V0;em<span class="pl-k">.</span>W<span class="pl-k">\</span>I<span class="pl-k">-</span>em<span class="pl-k">.</span>V<span class="pl-k">\</span>Grd<span class="pl-k">.</span>V0 em<span class="pl-k">.</span>W<span class="pl-k">\</span>I<span class="pl-k">+</span>em<span class="pl-k">.</span>V<span class="pl-k">\</span>Grd<span class="pl-k">.</span>V0]<span class="pl-k">*</span>[a[:,<span class="pl-c1">1</span>];b[:,<span class="pl-c1">1</span>]]) <span class="pl-c"><span class="pl-c">#</span>get propagating wave amplitudes inside layer</span>
points<span class="pl-k">=</span>[<span class="pl-c1">100</span>,<span class="pl-c1">100</span>,<span class="pl-c1">10</span>]               <span class="pl-c"><span class="pl-c">#</span>set the number of points to compute in x,y,z</span>
E,H<span class="pl-k">=</span>RigorousCoupledWaveAnalysis<span class="pl-k">.</span><span class="pl-c1">getfields</span>(a[<span class="pl-c1">1</span>],b[<span class="pl-c1">1</span>],Mdl<span class="pl-k">.</span>layers[<span class="pl-c1">1</span>]<span class="pl-k">.</span>thickness,em,Grd,points,λ) <span class="pl-c"><span class="pl-c">#</span>compute the electric and magnetic field</span></pre></div>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>References</h2>
<p>D. M. Whittaker and I. S. Culshaw, Scattering-matrix treatment of patterned multilayer photonic structures, Phys. Rev. B60(1999), 2610–2618.1</p>
<p>Marco Liscidini, Dario Gerace, Lucio Claudio Andreani, and J. E. Sipe, Scattering-matrix analysis of periodically patterned multilayers with asymmetric unit cells and birefringent media,Phys. Rev. B77(2008), 035324.1</p>
<p>Raymond Rumpf, Improved formulation of scattering matrices for semi-analytical methods thatis consistent with convention, Progress In Electromagnetics Research B35(2011), 241–261.1</p>
</article></div>