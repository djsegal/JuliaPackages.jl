<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-localpolyjl" class="anchor" aria-hidden="true" href="#localpolyjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LocalPoly.jl</h1>
<p dir="auto"><a href="https://github.com/jbshannon/LocalPoly.jl/actions?query=workflows/CI"><img src="https://github.com/jbshannon/LocalPoly.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://jbshannon.github.io/LocalPoly.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://jbshannon.github.io/LocalPoly.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><code>LocalPoly.jl</code> is a Julia implementation of the local polynomial regression methods outlined in <a href="https://doi.org/10.1201/9780203748725" rel="nofollow">Fan and Gijbels (1996)</a>. This package is still experimental, and the API is subject to change.</p>
<h2 dir="auto"><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overview</h2>
<p dir="auto">This package provides the function <code>lpreg</code>, which computes the local polynomial regression coefficients and standard errors at a vector of evaluation knots. This function also (optionally) implements the linear binning method to speed up the computations by reducing the dimensionality of the data. The number of bins is controlled by the keyword argument  <code>nbins</code> (set to 0 for no binning).</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LocalPoly, Random
Random.seed!(42)
x = 2π * rand(1000)
y = sin.(x) + randn(size(x))/4
v = range(0, 2π, length=100)
β̂ = lpreg(x, y, v; nbins=100)"><pre><span class="pl-k">using</span> LocalPoly, Random
Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">42</span>)
x <span class="pl-k">=</span> <span class="pl-c1">2</span>π <span class="pl-k">*</span> <span class="pl-c1">rand</span>(<span class="pl-c1">1000</span>)
y <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(x) <span class="pl-k">+</span> <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(x))<span class="pl-k">/</span><span class="pl-c1">4</span>
v <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">2</span>π, length<span class="pl-k">=</span><span class="pl-c1">100</span>)
β̂ <span class="pl-k">=</span> <span class="pl-c1">lpreg</span>(x, y, v; nbins<span class="pl-k">=</span><span class="pl-c1">100</span>)</pre></div>
<p dir="auto">The first element of the coefficient vector represents the function estimate at the point of evaluation:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ŷ = first.(β̂)
100-element Vector{Float64}:
 -0.03070776997429395
  0.048352477003287916
  ⋮
 -0.04452583837750935
 -0.04543586963674676"><pre>julia<span class="pl-k">&gt;</span> ŷ <span class="pl-k">=</span> <span class="pl-c1">first</span>.(β̂)
<span class="pl-c1">100</span><span class="pl-k">-</span>element Vector{Float64}<span class="pl-k">:</span>
 <span class="pl-k">-</span><span class="pl-c1">0.03070776997429395</span>
  <span class="pl-c1">0.048352477003287916</span>
  ⋮
 <span class="pl-k">-</span><span class="pl-c1">0.04452583837750935</span>
 <span class="pl-k">-</span><span class="pl-c1">0.04543586963674676</span></pre></div>
<p dir="auto">Plotting the fitted function values against the data:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using CairoMakie
f = Figure()
ax = Axis(f[1, 1])
scatter!(ax, x, y; markersize=3, label=&quot;Data&quot;)
lines!(ax, v, sin.(v); color=:darkgreen, label=&quot;True values&quot;)
lines!(ax, v, ŷ; color=:tomato, linewidth=3, label=&quot;Fitted values&quot;)
Legend(f[2, 1], ax; orientation=:horizontal, framevisible=false)
current_figure()"><pre><span class="pl-k">using</span> CairoMakie
f <span class="pl-k">=</span> <span class="pl-c1">Figure</span>()
ax <span class="pl-k">=</span> <span class="pl-c1">Axis</span>(f[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>])
<span class="pl-c1">scatter!</span>(ax, x, y; markersize<span class="pl-k">=</span><span class="pl-c1">3</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Data<span class="pl-pds">"</span></span>)
<span class="pl-c1">lines!</span>(ax, v, <span class="pl-c1">sin</span>.(v); color<span class="pl-k">=</span><span class="pl-c1">:darkgreen</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True values<span class="pl-pds">"</span></span>)
<span class="pl-c1">lines!</span>(ax, v, ŷ; color<span class="pl-k">=</span><span class="pl-c1">:tomato</span>, linewidth<span class="pl-k">=</span><span class="pl-c1">3</span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Fitted values<span class="pl-pds">"</span></span>)
<span class="pl-c1">Legend</span>(f[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>], ax; orientation<span class="pl-k">=</span><span class="pl-c1">:horizontal</span>, framevisible<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c1">current_figure</span>()</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="./docs/src/images/readme/light/fit.svg#gh-light-mode-only"><img src="./docs/src/images/readme/light/fit.svg#gh-light-mode-only" alt="Fit" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer" href="./docs/src/images/readme/dark/fit.svg#gh-dark-mode-only"><img src="./docs/src/images/readme/dark/fit.svg#gh-dark-mode-only" alt="Fit" style="max-width: 100%;"></a></p>
<p dir="auto">Alternatively, a <code>LPModel</code> object can be constructed to first bin the data before running the regression with the <code>lpreg!</code> method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; 𝐌 = LPModel(x, y, 1; nbins=100)
LPModel{Float64}
        Degree: 1
  Observations: 1000
          Bins: 100

julia&gt; β̃ = lpreg!(𝐌, v);

julia&gt; ỹ = first.(β̃);

julia&gt; ỹ == ŷ
true"><pre>julia<span class="pl-k">&gt;</span> 𝐌 <span class="pl-k">=</span> <span class="pl-c1">LPModel</span>(x, y, <span class="pl-c1">1</span>; nbins<span class="pl-k">=</span><span class="pl-c1">100</span>)
LPModel{Float64}
        Degree<span class="pl-k">:</span> <span class="pl-c1">1</span>
  Observations<span class="pl-k">:</span> <span class="pl-c1">1000</span>
          Bins<span class="pl-k">:</span> <span class="pl-c1">100</span>

julia<span class="pl-k">&gt;</span> β̃ <span class="pl-k">=</span> <span class="pl-c1">lpreg!</span>(𝐌, v);

julia<span class="pl-k">&gt;</span> ỹ <span class="pl-k">=</span> <span class="pl-c1">first</span>.(β̃);

julia<span class="pl-k">&gt;</span> ỹ <span class="pl-k">==</span> ŷ
<span class="pl-c1">true</span></pre></div>
<h3 dir="auto"><a id="user-content-standard-errors" class="anchor" aria-hidden="true" href="#standard-errors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Standard Errors</h3>
<p dir="auto">The conditional variance-covariance matrix can be computed along with the coefficient estimates at each evaluation point by using the keyword argument <code>se=true</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; β̂, V̂ = lpreg(x, y, v; nbins=100, se=true);

julia&gt; V̂[1]
2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):
  0.0250571  -0.169832
 -0.169832    1.85631

julia&gt; σ̂ = map(V -&gt; sqrt(V[1, 1]), V̂)
100-element Vector{Float64}:
 0.15829439002638532
 0.10565459771497485
 0.08285173519350204
 ⋮
 0.08866937970971286
 0.11655671525900956
 0.17517857236448717"><pre>julia<span class="pl-k">&gt;</span> β̂, V̂ <span class="pl-k">=</span> <span class="pl-c1">lpreg</span>(x, y, v; nbins<span class="pl-k">=</span><span class="pl-c1">100</span>, se<span class="pl-k">=</span><span class="pl-c1">true</span>);

julia<span class="pl-k">&gt;</span> V̂[<span class="pl-c1">1</span>]
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> SMatrix{<span class="pl-c1">2</span>, <span class="pl-c1">2</span>, Float64, <span class="pl-c1">4</span>} with indices <span class="pl-c1">SOneTo</span>(<span class="pl-c1">2</span>)<span class="pl-k">×</span><span class="pl-c1">SOneTo</span>(<span class="pl-c1">2</span>)<span class="pl-k">:</span>
  <span class="pl-c1">0.0250571</span>  <span class="pl-k">-</span><span class="pl-c1">0.169832</span>
 <span class="pl-k">-</span><span class="pl-c1">0.169832</span>    <span class="pl-c1">1.85631</span>

julia<span class="pl-k">&gt;</span> σ̂ <span class="pl-k">=</span> <span class="pl-c1">map</span>(V <span class="pl-k">-&gt;</span> <span class="pl-c1">sqrt</span>(V[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>]), V̂)
<span class="pl-c1">100</span><span class="pl-k">-</span>element Vector{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.15829439002638532</span>
 <span class="pl-c1">0.10565459771497485</span>
 <span class="pl-c1">0.08285173519350204</span>
 ⋮
 <span class="pl-c1">0.08866937970971286</span>
 <span class="pl-c1">0.11655671525900956</span>
 <span class="pl-c1">0.17517857236448717</span></pre></div>
<p dir="auto">We can use this to add a confidence interval to the plot:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Distributions
tᶜ = quantile(TDist(100-2), 1-0.05/2)
band!(ax, v, ŷ - tᶜ*σ̂, ŷ + tᶜ*σ̂; color=(:tomato, 0.3))
current_figure()"><pre><span class="pl-k">using</span> Distributions
tᶜ <span class="pl-k">=</span> <span class="pl-c1">quantile</span>(<span class="pl-c1">TDist</span>(<span class="pl-c1">100</span><span class="pl-k">-</span><span class="pl-c1">2</span>), <span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-c1">0.05</span><span class="pl-k">/</span><span class="pl-c1">2</span>)
<span class="pl-c1">band!</span>(ax, v, ŷ <span class="pl-k">-</span> tᶜ<span class="pl-k">*</span>σ̂, ŷ <span class="pl-k">+</span> tᶜ<span class="pl-k">*</span>σ̂; color<span class="pl-k">=</span>(<span class="pl-c1">:tomato</span>, <span class="pl-c1">0.3</span>))
<span class="pl-c1">current_figure</span>()</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="./docs/src/images/readme/light/fit_ci.svg#gh-light-mode-only"><img src="./docs/src/images/readme/light/fit_ci.svg#gh-light-mode-only" alt="Fit with confidence interval" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer" href="./docs/src/images/readme/dark/fit_ci.svg#gh-dark-mode-only"><img src="./docs/src/images/readme/dark/fit_ci.svg#gh-dark-mode-only" alt="Fit with confidence interval" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-performance" class="anchor" aria-hidden="true" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance</h2>
<p dir="auto">Set the number of observations to 100,000 and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="d28b44b2557a0ea884e01362537030ee">$Y_i = \sin(X_i) + \varepsilon_i$</math-renderer> for <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="d28b44b2557a0ea884e01362537030ee">$X_i \in [0, 2\pi]$</math-renderer>. Evaluate the local polynomial estimator at 1,000 points.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using BenchmarkTools, LocalPoly
x = 2π * rand(100_000)
y = sin.(x) + randn(size(x))/10
v = range(minimum(x), maximum(x), length=1000)
@btime h = plugin_bandwidth($x, $y)
# 2.701 ms (14 allocations: 6.10 MiB)
@btime lpreg($x, $y, $v; h=$h)
# 11.204 ms (9563 allocations: 442.02 KiB)"><pre><span class="pl-k">using</span> BenchmarkTools, LocalPoly
x <span class="pl-k">=</span> <span class="pl-c1">2</span>π <span class="pl-k">*</span> <span class="pl-c1">rand</span>(<span class="pl-c1">100_000</span>)
y <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(x) <span class="pl-k">+</span> <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(x))<span class="pl-k">/</span><span class="pl-c1">10</span>
v <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">minimum</span>(x), <span class="pl-c1">maximum</span>(x), length<span class="pl-k">=</span><span class="pl-c1">1000</span>)
<span class="pl-c1">@btime</span> h <span class="pl-k">=</span> <span class="pl-c1">plugin_bandwidth</span>(<span class="pl-k">$</span>x, <span class="pl-k">$</span>y)
<span class="pl-c"><span class="pl-c">#</span> 2.701 ms (14 allocations: 6.10 MiB)</span>
<span class="pl-c1">@btime</span> <span class="pl-c1">lpreg</span>(<span class="pl-k">$</span>x, <span class="pl-k">$</span>y, <span class="pl-k">$</span>v; h<span class="pl-k">=</span><span class="pl-k">$</span>h)
<span class="pl-c"><span class="pl-c">#</span> 11.204 ms (9563 allocations: 442.02 KiB)</span></pre></div>
<h3 dir="auto">
<a id="user-content-r" class="anchor" aria-hidden="true" href="#r"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>R</h3>
<div class="highlight highlight-source-r notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="library(KernSmooth)
library(microbenchmark)
x &lt;- 2*pi*runif(100000)
y &lt;- sin(x) + rnorm(100000)/10
v &lt;- seq(from = 0, to = 2*pi, length.out = 1000)
h &lt;- dpill(x, y, gridsize = 1000, range.x = c(0, 2*pi))
microbenchmark(&quot;KernSmooth&quot; = locpoly(x, y, bandwidth = h, gridsize = 1000, range.x = c(0, 2*pi)))"><pre>library(<span class="pl-smi">KernSmooth</span>)
library(<span class="pl-smi">microbenchmark</span>)
<span class="pl-smi">x</span> <span class="pl-k">&lt;-</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span><span class="pl-k">*</span>runif(<span class="pl-c1">100000</span>)
<span class="pl-smi">y</span> <span class="pl-k">&lt;-</span> sin(<span class="pl-smi">x</span>) <span class="pl-k">+</span> rnorm(<span class="pl-c1">100000</span>)<span class="pl-k">/</span><span class="pl-c1">10</span>
<span class="pl-smi">v</span> <span class="pl-k">&lt;-</span> seq(<span class="pl-v">from</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-v">to</span> <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span>, <span class="pl-v">length.out</span> <span class="pl-k">=</span> <span class="pl-c1">1000</span>)
<span class="pl-smi">h</span> <span class="pl-k">&lt;-</span> dpill(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>, <span class="pl-v">gridsize</span> <span class="pl-k">=</span> <span class="pl-c1">1000</span>, <span class="pl-v">range.x</span> <span class="pl-k">=</span> c(<span class="pl-c1">0</span>, <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span>))
microbenchmark(<span class="pl-s"><span class="pl-pds">"</span>KernSmooth<span class="pl-pds">"</span></span> <span class="pl-k">=</span> locpoly(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>, <span class="pl-v">bandwidth</span> <span class="pl-k">=</span> <span class="pl-smi">h</span>, <span class="pl-v">gridsize</span> <span class="pl-k">=</span> <span class="pl-c1">1000</span>, <span class="pl-v">range.x</span> <span class="pl-k">=</span> c(<span class="pl-c1">0</span>, <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">pi</span>)))</pre></div>
<p dir="auto">Output:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Unit: milliseconds
       expr      min       lq     mean   median       uq      max neval
 KernSmooth 2.062024 2.992719 3.506988 3.205222 3.713487 12.05903   100"><pre class="notranslate"><code>Unit: milliseconds
       expr      min       lq     mean   median       uq      max neval
 KernSmooth 2.062024 2.992719 3.506988 3.205222 3.713487 12.05903   100
</code></pre></div>
<h3 dir="auto">
<a id="user-content-stata" class="anchor" aria-hidden="true" href="#stata"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Stata</h3>
<div class="highlight highlight-source-stata notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="clear all
qui set obs 100000
gen x = 2*3.14159265*runiform()
gen y = sin(x) + rnormal()/10
forval i = 1/10 {
    timer on `i'
    lpoly y x, n(1000) kernel(epan2) degree(1) nograph
    timer off `i'
}
timer list"><pre>clear all
qui set obs 100000
<span class="pl-k">gen</span> x <span class="pl-k">=</span> 2<span class="pl-k">*</span>3.14159265<span class="pl-k">*</span>runiform()
<span class="pl-k">gen</span> y <span class="pl-k">=</span> sin(x) <span class="pl-k">+</span> rnormal()<span class="pl-k">/</span>10
<span class="pl-k">forval</span> i <span class="pl-k">=</span> 1<span class="pl-k">/</span>10 {
    timer on `i'
    lpoly y x, n(1000) kernel(epan2) degree(1) nograph
    timer off `i'
}
timer list</pre></div>
<p dir="auto">Output (measured in seconds):</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="1:     14.59 /        1 =      14.5850
2:     14.45 /        1 =      14.4500
3:     14.07 /        1 =      14.0730
4:     14.31 /        1 =      14.3090
5:     14.44 /        1 =      14.4440
6:     14.31 /        1 =      14.3120
7:     14.06 /        1 =      14.0630
8:     14.22 /        1 =      14.2160
9:     14.33 /        1 =      14.3280
10:     15.00 /        1 =      14.9980"><pre class="notranslate"><code>1:     14.59 /        1 =      14.5850
2:     14.45 /        1 =      14.4500
3:     14.07 /        1 =      14.0730
4:     14.31 /        1 =      14.3090
5:     14.44 /        1 =      14.4440
6:     14.31 /        1 =      14.3120
7:     14.06 /        1 =      14.0630
8:     14.22 /        1 =      14.2160
9:     14.33 /        1 =      14.3280
10:     15.00 /        1 =      14.9980
</code></pre></div>
<h3 dir="auto">
<a id="user-content-matlab" class="anchor" aria-hidden="true" href="#matlab"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MATLAB</h3>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = rand(100000, 1);
y = sin(x) + randn(100000, 1)/10;
v = linspace(min(x), max(x), 1000);
h = 0.087; % approximate plugin bandwidth

T = 100; % number of benchmark trials to run
tocs = zeros(T, 1);
for i = 1:numel(tocs)
    tic; lpreg(x, y, v, h); tocs(i) = toc;
end
fprintf('mean = %4.3f s\n std = %4.3f s\n', mean(tocs), std(tocs));

function betas = lpreg(x, y, v, h)
    X = [ones(size(x)) x];
    betas = v;
    for i = 1:numel(v)
        d = x - v(i);
        X(:, 2) = d;
        w = kernelfunc(d/h)/h;
        beta = inv(X' * (w .* X))*(X' * (w .* y));
        betas(i) = beta(1);
    end

    function z = kernelfunc(u)
        I = abs(u) &lt;= 1;
        z = zeros(size(u));
        z(I) = 3*(1-u(I).^2)/4;
    end
end"><pre>x <span class="pl-k">=</span> <span class="pl-en">rand</span>(<span class="pl-c1">100000</span>, <span class="pl-c1">1</span>);
y <span class="pl-k">=</span> <span class="pl-en">sin</span>(<span class="pl-smi">x</span>) <span class="pl-k">+</span> <span class="pl-en">randn</span>(<span class="pl-c1">100000</span>, <span class="pl-c1">1</span>)/<span class="pl-c1">10</span>;
v <span class="pl-k">=</span> <span class="pl-en">linspace</span>(<span class="pl-en">min</span>(<span class="pl-smi">x</span>), <span class="pl-en">max</span>(<span class="pl-smi">x</span>), <span class="pl-c1">1000</span>);
h <span class="pl-k">=</span> <span class="pl-c1">0.087</span>; <span class="pl-c"><span class="pl-c">%</span> approximate plugin bandwidth</span>

T <span class="pl-k">=</span> <span class="pl-c1">100</span>; <span class="pl-c"><span class="pl-c">%</span> number of benchmark trials to run</span>
tocs <span class="pl-k">=</span> <span class="pl-en">zeros</span>(<span class="pl-smi">T</span>, <span class="pl-c1">1</span>);
<span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-en">numel</span>(<span class="pl-smi">tocs</span>)
    <span class="pl-smi">tic</span>; <span class="pl-en">lpreg</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>, <span class="pl-smi">v</span>, <span class="pl-smi">h</span>); <span class="pl-en">tocs</span>(i) <span class="pl-k">=</span> <span class="pl-smi">toc</span>;
<span class="pl-k">end</span>
<span class="pl-en">fprintf</span>(<span class="pl-s"><span class="pl-pds">'</span>mean = <span class="pl-cce">%4.3f</span> s<span class="pl-cce">\n</span> std = <span class="pl-cce">%4.3f</span> s<span class="pl-cce">\n</span><span class="pl-pds">'</span></span>, <span class="pl-en">mean</span>(<span class="pl-smi">tocs</span>), <span class="pl-en">std</span>(<span class="pl-smi">tocs</span>));

<span class="pl-k">function</span> <span class="pl-v">betas</span> <span class="pl-k">=</span> <span class="pl-en">lpreg</span>(<span class="pl-v">x</span>, <span class="pl-v">y</span>, <span class="pl-v">v</span>, <span class="pl-v">h</span>)
    X <span class="pl-k">=</span> [<span class="pl-en">ones</span>(<span class="pl-en">size</span>(<span class="pl-smi">x</span>)) <span class="pl-smi">x</span>];
    betas <span class="pl-k">=</span> <span class="pl-smi">v</span>;
    <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-en">numel</span>(<span class="pl-smi">v</span>)
        d <span class="pl-k">=</span> <span class="pl-smi">x</span> <span class="pl-k">-</span> <span class="pl-en">v</span>(<span class="pl-smi">i</span>);
        <span class="pl-en">X</span>(<span class="pl-k">:</span>, <span class="pl-c1">2</span>) <span class="pl-k">=</span> <span class="pl-smi">d</span>;
        w <span class="pl-k">=</span> <span class="pl-en">kernelfunc</span>(<span class="pl-smi">d</span><span class="pl-k">/</span><span class="pl-smi">h</span>)/<span class="pl-smi">h</span>;
        beta <span class="pl-k">=</span> <span class="pl-en">inv</span>(<span class="pl-smi">X</span><span class="pl-k">'</span> <span class="pl-k">*</span> (<span class="pl-smi">w</span> <span class="pl-k">.*</span> <span class="pl-smi">X</span>))*(<span class="pl-smi">X</span><span class="pl-k">'</span> <span class="pl-k">*</span> (<span class="pl-smi">w</span> <span class="pl-k">.*</span> <span class="pl-smi">y</span>));
        <span class="pl-en">betas</span>(i) <span class="pl-k">=</span> <span class="pl-en">beta</span>(<span class="pl-c1">1</span>);
    <span class="pl-k">end</span>

    <span class="pl-k">function</span> <span class="pl-v">z</span> <span class="pl-k">=</span> <span class="pl-en">kernelfunc</span>(<span class="pl-v">u</span>)
        I <span class="pl-k">=</span> <span class="pl-en">abs</span>(<span class="pl-smi">u</span>) <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>;
        z <span class="pl-k">=</span> <span class="pl-en">zeros</span>(<span class="pl-en">size</span>(<span class="pl-smi">u</span>));
        <span class="pl-en">z</span>(I) <span class="pl-k">=</span> <span class="pl-c1">3</span>*(<span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-en">u</span>(<span class="pl-smi">I</span>).^<span class="pl-c1">2</span>)/<span class="pl-c1">4</span>;
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Output:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="mean = 2.739 s
 std = 0.130 s"><pre class="notranslate"><code>mean = 2.739 s
 std = 0.130 s
</code></pre></div>
<h2 dir="auto">
<a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<ol dir="auto">
<li>Fan, J., &amp; Gijbels, I. (1996). Local Polynomial Modelling and its Applications (1st ed.). Chapman &amp; Hall.</li>
</ol>
</article></div>