<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-predicatecomposition" class="anchor" aria-hidden="true" href="#predicatecomposition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PredicateComposition</h1>
<p dir="auto"><a href="https://jfeist.github.io/PredicateComposition.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://jfeist.github.io/PredicateComposition.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://travis-ci.com/jfeist/PredicateComposition.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a48237853627dac20c06e8913cec09a48e91fb6c5dcf5d35f53904f53d44deda/68747470733a2f2f7472617669732d63692e636f6d2f6a66656973742f507265646963617465436f6d706f736974696f6e2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jfeist/PredicateComposition.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jfeist/PredicateComposition.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/1a7d9a558eb85d597d3693832fca11fdeb67740fec15063c2ce49945712e265e/68747470733a2f2f636f6465636f762e696f2f67682f6a66656973742f507265646963617465436f6d706f736974696f6e2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/jfeist/PredicateComposition.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package defines some functions that do logical composition of predicate functions (i.e., functions that return a boolean). These are higher-order functions, i.e., functions that take functions as arguments and return a new function. Julia implements them efficiently. This permits a compact notation for selecting specific elements out of collections.</p>
<h2 dir="auto"><a id="user-content-logical-compositions" class="anchor" aria-hidden="true" href="#logical-compositions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Logical compositions</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="AND(f1,f2) = (args...) -&gt; f1(args...) &amp;&amp; f2(args...)
OR(f1,f2) = (args...) -&gt; f1(args...) || f2(args...)"><pre><span class="pl-en">AND</span>(f1,f2) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f1</span>(args<span class="pl-k">...</span>) <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">f2</span>(args<span class="pl-k">...</span>)
<span class="pl-en">OR</span>(f1,f2) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f1</span>(args<span class="pl-k">...</span>) <span class="pl-k">||</span> <span class="pl-c1">f2</span>(args<span class="pl-k">...</span>)</pre></div>
<h2 dir="auto"><a id="user-content-numerical-comparisons" class="anchor" aria-hidden="true" href="#numerical-comparisons"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Numerical comparisons</h2>
<p dir="auto">These functions give functions that compare the output values of different functions. The last three (<code>MAX</code>, <code>MIN</code>, <code>SUM</code>) can take an arbitrary number of arguments, and create functions that (normally) return numerical, not logical, values.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ISEQUAL(f1,f2) = (args...) -&gt; f1(args...) == f2(args...)
ISLESS(f1,f2) = (args...) -&gt; f1(args...) &lt; f2(args...)
ISLESSEQ(f1,f2) = (args...) -&gt; f1(args...) ≤ f2(args...)
ISGREATER(f1,f2) = (args...) -&gt; f1(args...) &gt; f2(args...)
ISGREATEREQ(f1,f2) = (args...) -&gt; f1(args...) ≥ f2(args...)

MAX(fs...) = (args...) -&gt; max((f(args...) for f in fs)...)
MIN(fs...) = (args...) -&gt; min((f(args...) for f in fs)...)
SUM(fs...) = (args...) -&gt; +((f(args...) for f in fs)...)"><pre><span class="pl-en">ISEQUAL</span>(f1,f2) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f1</span>(args<span class="pl-k">...</span>) <span class="pl-k">==</span> <span class="pl-c1">f2</span>(args<span class="pl-k">...</span>)
<span class="pl-en">ISLESS</span>(f1,f2) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f1</span>(args<span class="pl-k">...</span>) <span class="pl-k">&lt;</span> <span class="pl-c1">f2</span>(args<span class="pl-k">...</span>)
<span class="pl-en">ISLESSEQ</span>(f1,f2) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f1</span>(args<span class="pl-k">...</span>) <span class="pl-k">≤</span> <span class="pl-c1">f2</span>(args<span class="pl-k">...</span>)
<span class="pl-en">ISGREATER</span>(f1,f2) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f1</span>(args<span class="pl-k">...</span>) <span class="pl-k">&gt;</span> <span class="pl-c1">f2</span>(args<span class="pl-k">...</span>)
<span class="pl-en">ISGREATEREQ</span>(f1,f2) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">f1</span>(args<span class="pl-k">...</span>) <span class="pl-k">≥</span> <span class="pl-c1">f2</span>(args<span class="pl-k">...</span>)

<span class="pl-en">MAX</span>(fs<span class="pl-k">...</span>) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">max</span>((<span class="pl-c1">f</span>(args<span class="pl-k">...</span>) <span class="pl-k">for</span> f <span class="pl-k">in</span> fs)<span class="pl-k">...</span>)
<span class="pl-en">MIN</span>(fs<span class="pl-k">...</span>) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">min</span>((<span class="pl-c1">f</span>(args<span class="pl-k">...</span>) <span class="pl-k">for</span> f <span class="pl-k">in</span> fs)<span class="pl-k">...</span>)
<span class="pl-en">SUM</span>(fs<span class="pl-k">...</span>) <span class="pl-k">=</span> (args<span class="pl-k">...</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">+</span>((<span class="pl-c1">f</span>(args<span class="pl-k">...</span>) <span class="pl-k">for</span> f <span class="pl-k">in</span> fs)<span class="pl-k">...</span>)</pre></div>
<h2 dir="auto"><a id="user-content-aliases" class="anchor" aria-hidden="true" href="#aliases"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Aliases</h2>
<p dir="auto">For convenient typing, we also define the following aliases using operators that do not have a predefined meaning in Julia.</p>
<ul dir="auto">
<li><code>⩓ = AND</code> (type with <code>\And&lt;Tab&gt;</code>)</li>
<li><code>⩔ = OR</code> (type with <code>\Or&lt;Tab&gt;</code>)</li>
<li><code>≣ = ISEQUAL</code> (type with <code>\Equiv&lt;Tab&gt;</code>)</li>
<li><code>≺ = ISLESS</code> (type with <code>\prec&lt;Tab&gt;</code>)</li>
<li><code>⪯ = ISLESSEQ</code> (type with <code>\preceq&lt;Tab&gt;</code>)</li>
<li><code>≻ = ISGREATER</code> (type with <code>\succ&lt;Tab&gt;</code>)</li>
<li><code>⪰ = ISGREATEREQ</code> (type with <code>\succeq&lt;Tab&gt;</code>)</li>
</ul>
<p dir="auto"><strong>CAUTION</strong>: The operators <code>⩓</code> and <code>⩔</code>, although they do not have predefined meaning, have the precedence of addition operators, which is higher than comparison operators like <code>≻</code> and <code>≺</code>.
So a statement like <code>length ≻ 2 ⩓ length ≺ 7</code> would be parsed as <code>length ≻ (2 ⩓ length) ≺ 7</code>, i.e., the function <code>x -&gt; length(x) &gt; (2(x) &amp;&amp; length(x)) &lt; 7(x)</code>, instead of the probably desired <code>x -&gt; (length(x) &gt; 2) &amp;&amp; (length(x) &lt; 7)</code>.
So to logically compose functions like this, you have to explicitly add parentheses, e.g., <code>(length ≻ 2) ⩓ (length ≺ 7)</code>.</p>
<p dir="auto">For a complete list of operator precedence rules, see <a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm">https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm</a>.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="length_from_3_to_5 = (length ⪰ 3) ⩓ (length ⪯ 5)"><pre>length_from_3_to_5 <span class="pl-k">=</span> (length ⪰ <span class="pl-c1">3</span>) ⩓ (length ⪯ <span class="pl-c1">5</span>)</pre></div>
<p dir="auto">which is equivalent to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="length_from_3_to_5(x) = length(x) ≥ 3 &amp;&amp; length(x) ≤ 5"><pre><span class="pl-en">length_from_3_to_5</span>(x) <span class="pl-k">=</span> <span class="pl-c1">length</span>(x) <span class="pl-k">≥</span> <span class="pl-c1">3</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">length</span>(x) <span class="pl-k">≤</span> <span class="pl-c1">5</span></pre></div>
<p dir="auto">The compact notation in particular is advantageous for passing as a function argument to <code>filter</code> and similar functions, compare</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filter((length ⪰ 3) ⩓ (length ⪯ 5), collection)"><pre><span class="pl-c1">filter</span>((length ⪰ <span class="pl-c1">3</span>) ⩓ (length ⪯ <span class="pl-c1">5</span>), collection)</pre></div>
<p dir="auto">to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filter(x -&gt; length(x) ≥ 3 &amp;&amp; length(x) ≤ 5, collection)"><pre><span class="pl-c1">filter</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">length</span>(x) <span class="pl-k">≥</span> <span class="pl-c1">3</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">length</span>(x) <span class="pl-k">≤</span> <span class="pl-c1">5</span>, collection)</pre></div>
<p dir="auto">Assuming we have functions <code>count_apples</code>, <code>count_oranges</code>, and <code>count_lemons</code> that count the number of apples, oranges, and lemons in some data structure describing a fruit basket, we can do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filter(MAX(count_apples,count_oranges,count_lemons) ⪰ 3, fruit_baskets)"><pre><span class="pl-c1">filter</span>(<span class="pl-c1">MAX</span>(count_apples,count_oranges,count_lemons) ⪰ <span class="pl-c1">3</span>, fruit_baskets)</pre></div>
<p dir="auto">instead of</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="filter(x -&gt; max(count_apples(x),count_oranges(x),count_lemons(x)) ⪰ 3, fruit_baskets)"><pre><span class="pl-c1">filter</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">max</span>(<span class="pl-c1">count_apples</span>(x),<span class="pl-c1">count_oranges</span>(x),<span class="pl-c1">count_lemons</span>(x)) ⪰ <span class="pl-c1">3</span>, fruit_baskets)</pre></div>
<p dir="auto">to get all fruit baskets with at least three apples, three oranges, or three lemons.</p>
</article></div>