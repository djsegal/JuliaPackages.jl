<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-pffrgsolverjl-" class="anchor" aria-hidden="true" href="#pffrgsolverjl-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PFFRGSolver.jl <a target="_blank" rel="noopener noreferrer" href="https://github.com/dominikkiese/PFFRGSolver.jl/blob/main/README/logo.png"><img src="https://github.com/dominikkiese/PFFRGSolver.jl/raw/main/README/logo.png" align="right" height="175" width="250" style="max-width: 100%;"></a></h1>
<p dir="auto"><strong>P</strong>seudo-<strong>F</strong>ermion <strong>F</strong>unctional <strong>R</strong>enormalization <strong>G</strong>roup <strong>Solver</strong> <br>
(Julia v1.5 and higher)</p>
<h1 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h1>
<p dir="auto">The package PFFRGSolver.jl aims at providing an efficient, state-of-the-art multiloop solver for functional renormalization group equations of quantum lattice spin models in the pseudo-fermion representation. It is currently applicable to spin models described by Hamiltonians of the form</p>
<p align="center" dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/dominikkiese/PFFRGSolver.jl/blob/main/README/hamiltonian.png"><img src="https://github.com/dominikkiese/PFFRGSolver.jl/raw/main/README/hamiltonian.png" height="70" width="700" style="max-width: 100%;"></a>
</p>
<p dir="auto">which can be defined on a variety of pre-implemented two and three dimensional lattices. Internally, PFFRGSolver.jl first computes a reduced representation of the lattice by employing space group symmetries before initializing the renormalization group flow with the bare couplings or, optionally, a solution of the regularized parquet equations, to which the multiloop truncated FRG converges by construction. The RG equations are integrated using the Bogacki-Shampine method with adaptive step size control. In each stage of the flow, real-space spin-spin correlations are computed from the flowing vertices. For a more detailed discussion of the method and its implementation see <a href="https://arxiv.org/abs/2011.01269" rel="nofollow">https://arxiv.org/abs/2011.01269</a>.</p>
<h1 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h1>
<p dir="auto">The package can be installed with the Julia package manager by switching to package mode in the REPL (with <code>]</code>) and using</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add PFFRGSolver"><pre>pkg<span class="pl-k">&gt;</span> add PFFRGSolver</pre></div>
<h1 dir="auto"><a id="user-content-citation" class="anchor" aria-hidden="true" href="#citation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citation</h1>
<p dir="auto">If you use PFFRGSolver.jl in your work, please acknowledge the package accordingly and cite our preprint</p>
<p dir="auto">D. Kiese, T.MÃ¼ller, Y. Iqbal, R. Thomale and S. Trebst, "Multiloop functional renormalization group approach to quantum spin systems", arXiv:2011.01269 (2020)</p>
<p dir="auto">A suitable bibtex entry is</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@misc{kiese2020multiloop,
      title={Multiloop functional renormalization group approach to quantum spin systems},
      author={Dominik Kiese and Tobias M\&quot;uller and Yasir Iqbal and Ronny Thomale and Simon Trebst},
      year={2020},
      eprint={2011.01269},
      archivePrefix={arXiv},
      primaryClass={cond-mat.str-el}
}"><pre class="notranslate"><code>@misc{kiese2020multiloop,
      title={Multiloop functional renormalization group approach to quantum spin systems},
      author={Dominik Kiese and Tobias M\"uller and Yasir Iqbal and Ronny Thomale and Simon Trebst},
      year={2020},
      eprint={2011.01269},
      archivePrefix={arXiv},
      primaryClass={cond-mat.str-el}
}
</code></pre></div>
<h1 dir="auto"><a id="user-content-running-calculations" class="anchor" aria-hidden="true" href="#running-calculations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Running calculations</h1>
<p dir="auto">In order to simulate e.g. the nearest-neighbor Heisenberg antiferromagnet on the square lattice for a lattice truncation L = 3 simply do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PFFRGSolver
launch!(&quot;/path/to/output&quot;, &quot;square&quot;, 3, &quot;heisenberg&quot;, &quot;su2&quot;, [1.0])"><pre><span class="pl-k">using</span> PFFRGSolver
<span class="pl-c1">launch!</span>(<span class="pl-s"><span class="pl-pds">"</span>/path/to/output<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>square<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>, <span class="pl-s"><span class="pl-pds">"</span>heisenberg<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>su2<span class="pl-pds">"</span></span>, [<span class="pl-c1">1.0</span>])</pre></div>
<p dir="auto">The FRG solver allows for more fine grained control over the calculation by various keyword arguments. The full reference can be obtained via <code>?launch!</code>. Currently available lattices and models can be obtained in verbose form with <code>lattice_avail()</code> and <code>model_avail()</code>.</p>
<h1 dir="auto"><a id="user-content-post-processing-data" class="anchor" aria-hidden="true" href="#post-processing-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Post-processing data</h1>
<p dir="auto">Each calculation generates two output files <code>"/path/to/output_obs"</code> and <code>"/path/to/output_cp"</code> in the HDF5 format, containing observables measured during the RG flow and checkpoints with full vertex data respectively. <br>
The so-obtained real space spin-spin correlations are usually converted to structure factors (or susceptibilities) via a Fourier transform to momentum space, to investigate the ground state predicted by pf-FRG. In the following, example code is provided for computing the momentum (and Matsubara frequency) resolved structure factor for the full FRG flow, as well as a single cutoff, for Heisenberg models on the square lattice.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PFFRGSolver
using HDF5

# generate 50 x 50 momentum space discretization within first Brillouin zone of the square lattice
rx = (-1.0 * pi, 1.0 * pi)
ry = (-1.0 * pi, 1.0 * pi)
rz = (0.0, 0.0)
k  = get_momenta(rx, ry, rz, (50, 50, 0))

# open observable file and output file to save structure factor
file_in  = h5open(&quot;/path/to/output_obs&quot;, &quot;r&quot;)
file_out = h5open(&quot;/path/to/output_sf&quot;,  &quot;cw&quot;)

# compute structure factor for the full flow
compute_structure_factor_flow!(file_in, file_out, k, &quot;diag&quot;)

# read so-computed structure factor with its frequency mesh at cutoff Î = 1.0 from file_out
m, s = read_structure_factor(file_out, 1.0, &quot;diag&quot;)

# read so-computed static structure factor flow at momentum with largest amplitude with respect to reference scale Î = 1.0
ref  = read_reference_momentum(file_out, 1.0, &quot;diag&quot;)
Î, s = read_structure_factor_flow_at_momentum(file_out, ref, &quot;diag&quot;)

# read lattice data and real space correlations with their frequency mesh at cutoff Î = 1.0 from file_in
l, r = read_lattice(file_in)
m, Ï = read_Ï(file_in, 1.0, &quot;diag&quot;)

# compute static structure factor at cutoff Î = 1.0
s = compute_structure_factor(Ï[:, 1], k, l, r)

# close HDF5 files
close(file_in)
close(file_out)"><pre><span class="pl-k">using</span> PFFRGSolver
<span class="pl-k">using</span> HDF5

<span class="pl-c"><span class="pl-c">#</span> generate 50 x 50 momentum space discretization within first Brillouin zone of the square lattice</span>
rx <span class="pl-k">=</span> (<span class="pl-k">-</span><span class="pl-c1">1.0</span> <span class="pl-k">*</span> <span class="pl-c1">pi</span>, <span class="pl-c1">1.0</span> <span class="pl-k">*</span> <span class="pl-c1">pi</span>)
ry <span class="pl-k">=</span> (<span class="pl-k">-</span><span class="pl-c1">1.0</span> <span class="pl-k">*</span> <span class="pl-c1">pi</span>, <span class="pl-c1">1.0</span> <span class="pl-k">*</span> <span class="pl-c1">pi</span>)
rz <span class="pl-k">=</span> (<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>)
k  <span class="pl-k">=</span> <span class="pl-c1">get_momenta</span>(rx, ry, rz, (<span class="pl-c1">50</span>, <span class="pl-c1">50</span>, <span class="pl-c1">0</span>))

<span class="pl-c"><span class="pl-c">#</span> open observable file and output file to save structure factor</span>
file_in  <span class="pl-k">=</span> <span class="pl-c1">h5open</span>(<span class="pl-s"><span class="pl-pds">"</span>/path/to/output_obs<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>)
file_out <span class="pl-k">=</span> <span class="pl-c1">h5open</span>(<span class="pl-s"><span class="pl-pds">"</span>/path/to/output_sf<span class="pl-pds">"</span></span>,  <span class="pl-s"><span class="pl-pds">"</span>cw<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> compute structure factor for the full flow</span>
<span class="pl-c1">compute_structure_factor_flow!</span>(file_in, file_out, k, <span class="pl-s"><span class="pl-pds">"</span>diag<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> read so-computed structure factor with its frequency mesh at cutoff Î = 1.0 from file_out</span>
m, s <span class="pl-k">=</span> <span class="pl-c1">read_structure_factor</span>(file_out, <span class="pl-c1">1.0</span>, <span class="pl-s"><span class="pl-pds">"</span>diag<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> read so-computed static structure factor flow at momentum with largest amplitude with respect to reference scale Î = 1.0</span>
ref  <span class="pl-k">=</span> <span class="pl-c1">read_reference_momentum</span>(file_out, <span class="pl-c1">1.0</span>, <span class="pl-s"><span class="pl-pds">"</span>diag<span class="pl-pds">"</span></span>)
Î, s <span class="pl-k">=</span> <span class="pl-c1">read_structure_factor_flow_at_momentum</span>(file_out, ref, <span class="pl-s"><span class="pl-pds">"</span>diag<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> read lattice data and real space correlations with their frequency mesh at cutoff Î = 1.0 from file_in</span>
l, r <span class="pl-k">=</span> <span class="pl-c1">read_lattice</span>(file_in)
m, Ï <span class="pl-k">=</span> <span class="pl-c1">read_Ï</span>(file_in, <span class="pl-c1">1.0</span>, <span class="pl-s"><span class="pl-pds">"</span>diag<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> compute static structure factor at cutoff Î = 1.0</span>
s <span class="pl-k">=</span> <span class="pl-c1">compute_structure_factor</span>(Ï[:, <span class="pl-c1">1</span>], k, l, r)

<span class="pl-c"><span class="pl-c">#</span> close HDF5 files</span>
<span class="pl-c1">close</span>(file_in)
<span class="pl-c1">close</span>(file_out)</pre></div>
<p dir="auto">Vertex data can be accessed by reading checkpoints from <code>"/path/to/output_cp"</code> like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PFFRGSolver
using HDF5

# open checkpoint file of FRG solver
file = h5open(&quot;/path/to/output_cp&quot;, &quot;r&quot;)

# load checkpoint at cutoff Î = 1.0
Î, dÎ, m, a = read_checkpoint(file, 1.0)

# close HDF5 file
close(file)"><pre><span class="pl-k">using</span> PFFRGSolver
<span class="pl-k">using</span> HDF5

<span class="pl-c"><span class="pl-c">#</span> open checkpoint file of FRG solver</span>
file <span class="pl-k">=</span> <span class="pl-c1">h5open</span>(<span class="pl-s"><span class="pl-pds">"</span>/path/to/output_cp<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> load checkpoint at cutoff Î = 1.0</span>
Î, dÎ, m, a <span class="pl-k">=</span> <span class="pl-c1">read_checkpoint</span>(file, <span class="pl-c1">1.0</span>)

<span class="pl-c"><span class="pl-c">#</span> close HDF5 file</span>
<span class="pl-c1">close</span>(file)</pre></div>
<p dir="auto">The solver generates (if <code>parquet = true</code> in the <code>launch!</code> command) at least two checkpoints, one with the converged parquet solution used as the initial condition for the FRG and one with the final result at the end of the flow. Additional checkpoints are created according to a timer heuristic, which can be controlled with the <code>ct</code> and <code>wt</code> keywords in <code>launch!</code>.</p>
<h1 dir="auto"><a id="user-content-performance-notes" class="anchor" aria-hidden="true" href="#performance-notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance notes</h1>
<p dir="auto">The PFFRGSolver.jl package accelerates calculations by making use of Julia's built-in dynamical thread scheduling (<code>Threads.@spawn</code>). Even for small systems, the number of flow equations to be integrated is quite tremendous and parallelization is vital to achieve acceptable run times. <strong>We recommend to launch Julia with multiple threads whenever PFFRGSolver.jl is used</strong>, either by setting up the respective enviroment variable <code>export JULIA_NUM_THREADS=$nthreads</code> or by adding the <code>-t</code> flag when opening the Julia REPL from the terminal i.e. <code>julia -t $nthreads</code>. <br>
Note that iterating the parquet equations is quite costly (compared to one loop FRG calculations) and contributes a substantial overhead for computing an initial condition of the flow. It is advisable to turn them on (via the <code>parquet</code> keyword in <code>launch!</code>) only when accordingly large computing resources are available. <br>
If you are using the package in an HPC environment, make sure that the precompile cache is generated for that CPU architecture on which production runs are performed, as the LoopVectorizations.jl dependency of the solver will unlock compiler optimizations based on the respective hardware.</p>
<h1 dir="auto"><a id="user-content-slurm-interface" class="anchor" aria-hidden="true" href="#slurm-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SLURM Interface</h1>
<p dir="auto">Calculations with PFFRGSolver.jl on small to medium sized systems can usually be done locally with a low number of threads. However, when the number of loops is increased and high resolution is required, calculations can become quite time consuming and it is advisable to make use of a computing cluster if available. PFFRGSolver.jl exports a few commands, to help people setting up simulations on clusters utilizing the SLURM workload manager (integration for other systems is plannned for future versions). Example code for a rough scan of the phase diagram of the J1-J2 Heisenberg model on the square lattice (with L = 6) is given below.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PFFRGSolver

# make new folder and add launcher files for a rough scan of the phase diagram
mkdir(&quot;j1j2_square&quot;)

for j2 in [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]
  save_launcher!(&quot;j1j2_square/j2$(j2).jl&quot;, &quot;j2$(j2)&quot;, &quot;square&quot;, 6, &quot;heisenberg&quot;, &quot;su2&quot;, [1.0, j2], num_Ï = 50, num_Î© = 30, num_Î½ = 20, num_Ï = 10)
end

# set up SLURM parameters as dictionary
sbatch_args = Dict([&quot;account&quot; =&gt; &quot;my_account&quot;, &quot;nodes&quot; =&gt; &quot;1&quot;, &quot;ntasks&quot; =&gt; &quot;1&quot;, &quot;cpus-per-task&quot; =&gt; &quot;8&quot;, &quot;time&quot; =&gt; &quot;04:00:00&quot;, &quot;partition&quot; =&gt; &quot;my_partition&quot;])

# generate job files
make_repository!(&quot;j1j2_square&quot;, &quot;/path/to/julia/exe&quot;, sbatch_args)"><pre><span class="pl-k">using</span> PFFRGSolver

<span class="pl-c"><span class="pl-c">#</span> make new folder and add launcher files for a rough scan of the phase diagram</span>
<span class="pl-c1">mkdir</span>(<span class="pl-s"><span class="pl-pds">"</span>j1j2_square<span class="pl-pds">"</span></span>)

<span class="pl-k">for</span> j2 <span class="pl-k">in</span> [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.2</span>, <span class="pl-c1">0.4</span>, <span class="pl-c1">0.6</span>, <span class="pl-c1">0.8</span>, <span class="pl-c1">1.0</span>]
  <span class="pl-c1">save_launcher!</span>(<span class="pl-s"><span class="pl-pds">"</span>j1j2_square/j2<span class="pl-v">$(j2)</span>.jl<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>j2<span class="pl-v">$(j2)</span><span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>square<span class="pl-pds">"</span></span>, <span class="pl-c1">6</span>, <span class="pl-s"><span class="pl-pds">"</span>heisenberg<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>su2<span class="pl-pds">"</span></span>, [<span class="pl-c1">1.0</span>, j2], num_Ï <span class="pl-k">=</span> <span class="pl-c1">50</span>, num_Î© <span class="pl-k">=</span> <span class="pl-c1">30</span>, num_Î½ <span class="pl-k">=</span> <span class="pl-c1">20</span>, num_Ï <span class="pl-k">=</span> <span class="pl-c1">10</span>)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> set up SLURM parameters as dictionary</span>
sbatch_args <span class="pl-k">=</span> <span class="pl-c1">Dict</span>([<span class="pl-s"><span class="pl-pds">"</span>account<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>my_account<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>nodes<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>ntasks<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cpus-per-task<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>8<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>time<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>04:00:00<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>partition<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>my_partition<span class="pl-pds">"</span></span>])

<span class="pl-c"><span class="pl-c">#</span> generate job files</span>
<span class="pl-c1">make_repository!</span>(<span class="pl-s"><span class="pl-pds">"</span>j1j2_square<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>/path/to/julia/exe<span class="pl-pds">"</span></span>, sbatch_args)</pre></div>
<p dir="auto">The jobs subsequently can be submitted using</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="for FILE in j1j2_square/*/*.job; do sbatch $FILE; done"><pre><span class="pl-k">for</span> <span class="pl-smi">FILE</span> <span class="pl-k">in</span> j1j2_square/<span class="pl-k">*</span>/<span class="pl-k">*</span>.job<span class="pl-k">;</span> <span class="pl-k">do</span> sbatch <span class="pl-smi">$FILE</span><span class="pl-k">;</span> <span class="pl-k">done</span></pre></div>
<p dir="auto">After having submitted and run the jobs, results can be gathered in <code>"j1j2_square/finished"</code> with the <code>collect_repository!</code> command. Note that simulations, which could not be finished in time, have their <code>overwrite</code> flag in the respective launcher file set to <code>false</code> by <code>collect_repository!</code>. As such they can just be resubmitted and will continue calculations from the last available checkpoint.</p>
<h1 dir="auto"><a id="user-content-literature" class="anchor" aria-hidden="true" href="#literature"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Literature</h1>
<p dir="auto">For further reading on technical aspects of (multiloop) pf-FRG see</p>
<ul dir="auto">
<li>[1] <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.81.144410" rel="nofollow">https://journals.aps.org/prb/abstract/10.1103/PhysRevB.81.144410</a></li>
<li>[2] <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.96.045144" rel="nofollow">https://journals.aps.org/prb/abstract/10.1103/PhysRevB.96.045144</a></li>
<li>[3] <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.97.064416" rel="nofollow">https://journals.aps.org/prb/abstract/10.1103/PhysRevB.97.064416</a></li>
<li>[4] <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.97.035162" rel="nofollow">https://journals.aps.org/prb/abstract/10.1103/PhysRevB.97.035162</a></li>
<li>[5] <a href="https://arxiv.org/abs/2011.01268" rel="nofollow">https://arxiv.org/abs/2011.01268</a></li>
</ul>
</article></div>