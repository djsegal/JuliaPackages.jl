<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-sumtypesjl" class="anchor" aria-hidden="true" href="#sumtypesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SumTypes.jl</h1>
<ul dir="auto">
<li><a href="https://github.com/MasonProtter/SumTypes.jl#basics">Basics</a></li>
<li><a href="https://github.com/MasonProtter/SumTypes.jl#destructuring-sum-types">Destructuring sum types</a></li>
<li><a href="https://github.com/MasonProtter/SumTypes.jl/#using-full_type-to-get-the-concrete-type-of-a-sum-type">Using <code>full_type</code> to get the concrete type of a Sum Type</a></li>
<li><a href="https://github.com/MasonProtter/SumTypes.jl#avoiding-namespace-clutter">Avoiding namespace clutter</a></li>
<li><a href="https://github.com/MasonProtter/SumTypes.jl#custom-printing">Custom printing</a></li>
<li><a href="https://github.com/MasonProtter/SumTypes.jl#performance">Performance</a></li>
</ul>
<h2 dir="auto"><a id="user-content-basics" class="anchor" aria-hidden="true" href="#basics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basics</h2>


<p dir="auto">Sum types, sometimes called 'tagged unions' are the type system equivalent
of the <a href="https://en.wikipedia.org/wiki/Disjoint_union" rel="nofollow">disjoint union</a> operation (which is <em>not</em> a union in the
traditional sense). In the <a href="https://doc.rust-lang.org/book/ch06-00-enums.html" rel="nofollow">Rust programming language</a>, these
are called "Enums", and they're more general than what Julia calls an
<a href="https://docs.julialang.org/en/v1/base/base/#Base.Enums.@enum" rel="nofollow">enum</a>.</p>
<p dir="auto">At the end of the day, a sum type is really just a fancy word for a container that can store data of a few
different, pre-declared types and is labelled by how it was instantiated.</p>
<p dir="auto">Users of statically typed programming languages often prefer Sum types to unions because it makes type checking
easier. In a dynamic language like julia, the benefit of these objects is less obvious, but there are cases where
they're helpful, like performance sensitive branching on heterogeneous types, and enforcing the handling of cases.</p>
<p dir="auto">The simplest version of a sum type is just a list of constant variants (i.e. basically a
<a href="https://docs.julialang.org/en/v1/base/base/#Base.Enums.@enum" rel="nofollow">julia enum</a>):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @sum_type Fruit begin
           apple
           banana
           orange
       end

julia&gt; apple
apple::Fruit

julia&gt; banana
banana::Fruit

julia&gt; orange
brange::Fruit

julia&gt; typeof(apple) == typeof(banana) == typeof(orange) &lt;: Fruit
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@sum_type</span> Fruit <span class="pl-k">begin</span>
           apple
           banana
           orange
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> apple
apple<span class="pl-k">::</span><span class="pl-c1">Fruit</span>

julia<span class="pl-k">&gt;</span> banana
banana<span class="pl-k">::</span><span class="pl-c1">Fruit</span>

julia<span class="pl-k">&gt;</span> orange
brange<span class="pl-k">::</span><span class="pl-c1">Fruit</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(apple) <span class="pl-k">==</span> <span class="pl-c1">typeof</span>(banana) <span class="pl-k">==</span> <span class="pl-c1">typeof</span>(orange) <span class="pl-k">&lt;:</span> <span class="pl-c1">Fruit</span>
<span class="pl-c1">true</span></pre></div>
<p dir="auto">But this isn't particularly interesting. More intesting is sum types which can <strong>enclose data</strong>.
Let's explore a very fundamental sum type (fundamental in the sense that all other sum types may be derived from it):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using SumTypes

julia&gt; @sum_type Either{A, B} begin
           Left{A}(::A)
           Right{B}(::B)
       end"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> SumTypes

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@sum_type</span> Either{A, B} <span class="pl-k">begin</span>
           <span class="pl-c1">Left</span><span class="pl-c1">{A}</span>(<span class="pl-k">::</span><span class="pl-c1">A</span>)
           <span class="pl-c1">Right</span><span class="pl-c1">{B}</span>(<span class="pl-k">::</span><span class="pl-c1">B</span>)
       <span class="pl-k">end</span></pre></div>
<p dir="auto">This says that we have a sum type <code>Either{A, B}</code>, and it can hold a value that is either of type <code>A</code> or of type <code>B</code>. <code>Either</code> has two
'constructors' which we have called <code>Left{A}</code> and <code>Right{B}</code>. These exist essentially as a way to have instances of <code>Either</code> carry
a record of how they were constructed by being wrapped in dummy structs named <code>Left</code> or <code>Right</code>.</p>
<p dir="auto">Here is how these constructors behave:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Left(1)
Left(1)::Either{Int64, Uninit}

julia&gt; Right(1.0)
Right(1.0)::Either{Uninit, Float64}"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">Left</span>(<span class="pl-c1">1</span>)
<span class="pl-c1">Left</span>(<span class="pl-c1">1</span>)<span class="pl-k">::</span><span class="pl-c1">Either{Int64, Uninit}</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Right</span>(<span class="pl-c1">1.0</span>)
<span class="pl-c1">Right</span>(<span class="pl-c1">1.0</span>)<span class="pl-k">::</span><span class="pl-c1">Either{Uninit, Float64}</span></pre></div>
<p dir="auto">Notice that because both <code>Left{A}</code> and <code>Right{B}</code> each carry one fewer type parameter than <code>Either{A,B}</code>, then simply writing
<code>Left(1)</code> is <em>not enough</em> to fully specify the type of the full <code>Either</code>, so the unspecified field is <code>SumTypes.Uninit</code> by default.</p>
<p dir="auto">In cases like this, you can rely on <em>implicit conversion</em> to get the fully initialized type. E.g.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; let x::Either{Int, Float64} = Left(1)
           x
       end
Left(1)::Either{Int64, Float64}"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">let</span> x<span class="pl-k">::</span><span class="pl-c1">Either{Int, Float64}</span> <span class="pl-k">=</span> <span class="pl-c1">Left</span>(<span class="pl-c1">1</span>)
           x
       <span class="pl-k">end</span>
<span class="pl-c1">Left</span>(<span class="pl-c1">1</span>)<span class="pl-k">::</span><span class="pl-c1">Either{Int64, Float64}</span></pre></div>
<p dir="auto">Typically, you'll do this by enforcing a return type on a function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; function foo() :: Either{Int, Float64}
           # Randomly return either a Left(1) or a Right(2.0)
           rand(Bool) ? Left(1) : Right(2.0)
       end;

julia&gt; foo()
Left(1)::Either{Int64, Float64}

julia&gt; foo()
Right(2.0)::Either{Int64, Float64}"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() <span class="pl-k">::</span> <span class="pl-c1">Either{Int, Float64}</span>
           <span class="pl-c"><span class="pl-c">#</span> Randomly return either a Left(1) or a Right(2.0)</span>
           <span class="pl-c1">rand</span>(Bool) <span class="pl-k">?</span> <span class="pl-c1">Left</span>(<span class="pl-c1">1</span>) <span class="pl-k">:</span> <span class="pl-c1">Right</span>(<span class="pl-c1">2.0</span>)
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo</span>()
<span class="pl-c1">Left</span>(<span class="pl-c1">1</span>)<span class="pl-k">::</span><span class="pl-c1">Either{Int64, Float64}</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo</span>()
<span class="pl-c1">Right</span>(<span class="pl-c1">2.0</span>)<span class="pl-k">::</span><span class="pl-c1">Either{Int64, Float64}</span></pre></div>
<p dir="auto">This is particularly useful because in this case <code>foo</code> is
<a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Write-%22type-stable%22-functions" rel="nofollow">type stable</a>!</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Base.return_types(foo, Tuple{})
1-element Vector{Any}:
 Either{Int64, Float64, 8, 0, UInt64}

julia&gt; isconcretetype(ans[1])
true"><pre>julia<span class="pl-k">&gt;</span> Base<span class="pl-k">.</span><span class="pl-c1">return_types</span>(foo, Tuple{})
<span class="pl-c1">1</span><span class="pl-k">-</span>element Vector{Any}<span class="pl-k">:</span>
 Either{Int64, Float64, <span class="pl-c1">8</span>, <span class="pl-c1">0</span>, UInt64}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">isconcretetype</span>(ans[<span class="pl-c1">1</span>])
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Note that unlike <code>Union{A, B}</code>, <code>A &lt;: Either{A,B}</code> is false, and <code>Either{A, A}</code> is distinct from <code>A</code>.</p>

<h2 dir="auto"><a id="user-content-destructuring-sum-types" class="anchor" aria-hidden="true" href="#destructuring-sum-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Destructuring Sum types</h2>


<p dir="auto">Okay, but how do I actually access the data enclosed in a <code>Fruit</code> or an <code>Either</code>? The answer is destructuring.
SumTypes.jl exposes a <code>@cases</code> macro for efficiently unwrapping and branching on the contents of a sum type:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; myfruit = Orange
Orange::Fruit

julia&gt; @cases myfruit begin
           Apple =&gt; &quot;Got an apple!&quot;
           Orange =&gt; &quot;Got an orange!&quot;
           Banana =&gt; throw(error(&quot;I'm allergic to bananas!&quot;))
       end
&quot;Got an orange!&quot;

julia&gt; @cases Banana begin
           Apple =&gt; &quot;Got an apple!&quot;
           Orange =&gt; &quot;Got an orange!&quot;
           Banana =&gt; throw(error(&quot;I'm allergic to bananas!&quot;))
       end
ERROR: I'm allergic to bananas!
[...]"><pre>julia<span class="pl-k">&gt;</span> myfruit <span class="pl-k">=</span> Orange
Orange<span class="pl-k">::</span><span class="pl-c1">Fruit</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cases</span> myfruit <span class="pl-k">begin</span>
           Apple <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Got an apple!<span class="pl-pds">"</span></span>
           Orange <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Got an orange!<span class="pl-pds">"</span></span>
           Banana <span class="pl-k">=&gt;</span> <span class="pl-c1">throw</span>(<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>I'm allergic to bananas!<span class="pl-pds">"</span></span>))
       <span class="pl-k">end</span>
<span class="pl-s"><span class="pl-pds">"</span>Got an orange!<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cases</span> Banana <span class="pl-k">begin</span>
           Apple <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Got an apple!<span class="pl-pds">"</span></span>
           Orange <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Got an orange!<span class="pl-pds">"</span></span>
           Banana <span class="pl-k">=&gt;</span> <span class="pl-c1">throw</span>(<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>I'm allergic to bananas!<span class="pl-pds">"</span></span>))
       <span class="pl-k">end</span>
ERROR<span class="pl-k">:</span> I<span class="pl-k">'</span>m allergic to bananas!
[<span class="pl-k">...</span>]</pre></div>
<p dir="auto"><code>@cases</code> can automatically detect if you didn't give an exhaustive set of cases (with no runtime penalty) and throw an error.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @cases myfruit begin
           Apple =&gt; &quot;Got an apple!&quot;
           Orange =&gt; &quot;Got an orange!&quot;
       end
ERROR: Inexhaustive @cases specification. Got cases (:Apple, :Orange), expected (:Apple, :Banana, :Orange)
[...]"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@cases</span> myfruit <span class="pl-k">begin</span>
           Apple <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Got an apple!<span class="pl-pds">"</span></span>
           Orange <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Got an orange!<span class="pl-pds">"</span></span>
       <span class="pl-k">end</span>
ERROR<span class="pl-k">:</span> Inexhaustive <span class="pl-c1">@cases</span> specification. Got cases (<span class="pl-c1">:Apple</span>, <span class="pl-c1">:Orange</span>), expected (<span class="pl-c1">:Apple</span>, <span class="pl-c1">:Banana</span>, <span class="pl-c1">:Orange</span>)
[<span class="pl-k">...</span>]</pre></div>
<p dir="auto">Furthermore, <code>@cases</code> can <em>destructure</em> sum types which hold data:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; let x::Either{Int, Float64} = rand(Bool) ? Left(1) : Right(2.0)
           @cases x begin
               Left(l) =&gt; l + 1.0
               Right(r) =&gt; r - 1
           end
       end
2.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">let</span> x<span class="pl-k">::</span><span class="pl-c1">Either{Int, Float64}</span> <span class="pl-k">=</span> <span class="pl-c1">rand</span>(Bool) <span class="pl-k">?</span> <span class="pl-c1">Left</span>(<span class="pl-c1">1</span>) <span class="pl-k">:</span> <span class="pl-c1">Right</span>(<span class="pl-c1">2.0</span>)
           <span class="pl-c1">@cases</span> x <span class="pl-k">begin</span>
               <span class="pl-c1">Left</span>(l) <span class="pl-k">=&gt;</span> l <span class="pl-k">+</span> <span class="pl-c1">1.0</span>
               <span class="pl-c1">Right</span>(r) <span class="pl-k">=&gt;</span> r <span class="pl-k">-</span> <span class="pl-c1">1</span>
           <span class="pl-k">end</span>
       <span class="pl-k">end</span>
<span class="pl-c1">2.0</span></pre></div>
<p dir="auto">i.e. in this example, <code>@cases</code> took in an <code>Either{Int,Float64}</code> and if it contained a <code>Left</code>, it took the wrapped data (an <code>Int</code>)
bound it do the variable <code>l</code> and added <code>1.0</code> to <code>l</code>, whereas if it was a <code>Right</code>, it took the <code>Float64</code> and bound it to a variable
<code>r</code> and subtracted <code>1</code> from <code>r</code>.</p>
<p dir="auto">The <code>@cases</code> macro still falls far short of a full on pattern matching system, lacking many features. For anything advanced, I'd recommend using <code>@match</code> from <a href="https://github.com/thautwarm/MLStyle.jl">MLStyle.jl</a>.</p>

<h2 dir="auto"><a id="user-content-using-full_type-to-get-the-concrete-type-of-a-sum-type" class="anchor" aria-hidden="true" href="#using-full_type-to-get-the-concrete-type-of-a-sum-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using <code>full_type</code> to get the concrete type of a Sum Type</h2>
<details>
<summary>Click to expand</summary>
<p dir="auto">SumTypes.jl generates structs with a compactified memory layout which is computed on demand for parametric types. Because of this,
every SumTypes actually has two extra type parameters related to its memory layout. This means that for instance, with <code>Either{Int, Int}</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @sum_type Either{A, B} begin
           Left{A}(::A)
           Right{B}(::B)
       end

julia&gt; isconcretetype(Either{Int, Int})
false"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@sum_type</span> Either{A, B} <span class="pl-k">begin</span>
           <span class="pl-c1">Left</span><span class="pl-c1">{A}</span>(<span class="pl-k">::</span><span class="pl-c1">A</span>)
           <span class="pl-c1">Right</span><span class="pl-c1">{B}</span>(<span class="pl-k">::</span><span class="pl-c1">B</span>)
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">isconcretetype</span>(Either{Int, Int})
<span class="pl-c1">false</span></pre></div>
<p dir="auto">In order to get the proper, concrete type corresponding to <code>Either{Int, Int}</code>, one can use the <code>full_type</code> function exported by SumTypes.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; full_type(Either{Int, Int})
Either{Int64, Int64, 8, 0, UInt64}

julia&gt; full_type(Either{Int, String})
Either{Int64, String, 8, 1, UInt8}

julia&gt; full_type(Either{Tuple{Int, Int, Int}, String})
Either{Tuple{Int64, Int64, Int64}, String, 24, 1, UInt8}

julia&gt; isconcretetype(ans)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">full_type</span>(Either{Int, Int})
Either{Int64, Int64, <span class="pl-c1">8</span>, <span class="pl-c1">0</span>, UInt64}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">full_type</span>(Either{Int, String})
Either{Int64, String, <span class="pl-c1">8</span>, <span class="pl-c1">1</span>, UInt8}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">full_type</span>(Either{Tuple{Int, Int, Int}, String})
Either{Tuple{Int64, Int64, Int64}, String, <span class="pl-c1">24</span>, <span class="pl-c1">1</span>, UInt8}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">isconcretetype</span>(ans)
<span class="pl-c1">true</span></pre></div>
<p dir="auto">Avoiding these extra parameters would require <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="43921745" data-permission-text="Title is private" data-url="https://github.com/JuliaLang/julia/issues/8472" data-hovercard-type="issue" data-hovercard-url="/JuliaLang/julia/issues/8472/hovercard" href="https://github.com/JuliaLang/julia/issues/8472">JuliaLang/julia#8472</a> to be implemented.</p>
</details>
<h2 dir="auto"><a id="user-content-avoiding-namespace-clutter" class="anchor" aria-hidden="true" href="#avoiding-namespace-clutter"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Avoiding namespace clutter</h2>
<details>
<summary>Click to expand</summary>
<p dir="auto">A common complaint about Enums and Sum Types is that sometimes they can contribute to clutter in the namespace. If you want to avoid having all the variants being available as top-level constant variables, then you can use the <code>:hidden</code> option:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @sum_type Foo{T} :hidden begin
           A
           B{T}(::T)
       end

julia&gt; A
ERROR: UndefVarError: A not defined

julia&gt; B
ERROR: UndefVarError: B not defined"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@sum_type</span> Foo{T} <span class="pl-c1">:hidden</span> <span class="pl-k">begin</span>
           A
           <span class="pl-c1">B</span><span class="pl-c1">{T}</span>(<span class="pl-k">::</span><span class="pl-c1">T</span>)
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> A
ERROR<span class="pl-k">:</span> UndefVarError<span class="pl-k">:</span> A not defined

julia<span class="pl-k">&gt;</span> B
ERROR<span class="pl-k">:</span> UndefVarError<span class="pl-k">:</span> B not defined</pre></div>
<p dir="auto">These 'hidden' variants can be accessed by applying the <code>'</code> operator to the type <code>Foo</code>, which returns a named tuple of the variants:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; Foo'
(A = A::Foo{Uninit}, B = var&quot;#Foo#B&quot;)"><pre>julia<span class="pl-k">&gt;</span> Foo<span class="pl-k">'</span>
(A <span class="pl-k">=</span> A<span class="pl-k">::</span><span class="pl-c1">Foo{Uninit}</span>, B <span class="pl-k">=</span> <span class="pl-c1">var"#Foo#B"</span>)</pre></div>
<p dir="auto">And then you can access this named tuple as normal:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
julia&gt; Foo'.A
A::Foo{Uninit}

julia&gt; Foo'.B(1)
B(1)::Foo{Int64}"><pre>julia<span class="pl-k">&gt;</span> Foo<span class="pl-k">'</span><span class="pl-k">.</span>A
A<span class="pl-k">::</span><span class="pl-c1">Foo{Uninit}</span>

julia<span class="pl-k">&gt;</span> Foo<span class="pl-k">'</span><span class="pl-k">.</span><span class="pl-c1">B</span>(<span class="pl-c1">1</span>)
<span class="pl-c1">B</span>(<span class="pl-c1">1</span>)<span class="pl-k">::</span><span class="pl-c1">Foo{Int64}</span></pre></div>
<p dir="auto">You can even do fancy things like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; let (; B) = Foo'
           B(1)
       end
B(1)::Foo{Int64}"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">let</span> (; B) <span class="pl-k">=</span> Foo<span class="pl-k">'</span>
           <span class="pl-c1">B</span>(<span class="pl-c1">1</span>)
       <span class="pl-k">end</span>
<span class="pl-c1">B</span>(<span class="pl-c1">1</span>)<span class="pl-k">::</span><span class="pl-c1">Foo{Int64}</span></pre></div>
<p dir="auto">Note that property-destructuring syntax is only available on julia version 1.7 and higher <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="787482404" data-permission-text="Title is private" data-url="https://github.com/JuliaLang/julia/issues/39285" data-hovercard-type="pull_request" data-hovercard-url="/JuliaLang/julia/pull/39285/hovercard" href="https://github.com/JuliaLang/julia/pull/39285">JuliaLang/julia#39285</a></p>
</details>
<h2 dir="auto"><a id="user-content-custom-printing" class="anchor" aria-hidden="true" href="#custom-printing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Custom printing</h2>
<details>
<summary>Click to expand</summary>
<p dir="auto">SumTypes.jl automatically overloads <code>Base.show(::IO, ::YourType)</code> and <code>Base.show(::IO, ::MIME"text/plain", ::YourType)</code>
for your type when you create a sum type, but it forwards that call to an internal function <code>SumTypes.show_sumtype</code>. If
you wish to customize the printing of a sum type, then you should overload <code>SumTypes.show_sumtype</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @sum_type Fruit2 begin
           apple
           orange
           banana
       end;

julia&gt; apple
apple::Fruit2

julia&gt; SumTypes.show_sumtype(io::IO, x::Fruit2) = @cases x begin
           apple =&gt; print(io, &quot;apple&quot;)
           orange =&gt; print(io, &quot;orange&quot;)
           banana =&gt; print(io, &quot;banana&quot;)
       end

julia&gt; apple
apple

julia&gt; SumTypes.show_sumtype(io::IO, ::MIME&quot;text/plain&quot;, x::Fruit2) = @cases x begin
           apple =&gt; print(io, &quot;apple!&quot;)
           orange =&gt; print(io, &quot;orange!&quot;)
           banana =&gt; print(io, &quot;banana!&quot;)
       end

julia&gt; apple
apple!"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@sum_type</span> Fruit2 <span class="pl-k">begin</span>
           apple
           orange
           banana
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> apple
apple<span class="pl-k">::</span><span class="pl-c1">Fruit2</span>

julia<span class="pl-k">&gt;</span> SumTypes<span class="pl-k">.</span><span class="pl-en">show_sumtype</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, x<span class="pl-k">::</span><span class="pl-c1">Fruit2</span>) <span class="pl-k">=</span> <span class="pl-c1">@cases</span> x <span class="pl-k">begin</span>
           apple <span class="pl-k">=&gt;</span> <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>apple<span class="pl-pds">"</span></span>)
           orange <span class="pl-k">=&gt;</span> <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>orange<span class="pl-pds">"</span></span>)
           banana <span class="pl-k">=&gt;</span> <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>banana<span class="pl-pds">"</span></span>)
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> apple
apple

julia<span class="pl-k">&gt;</span> SumTypes<span class="pl-k">.</span><span class="pl-en">show_sumtype</span>(io<span class="pl-k">::</span><span class="pl-c1">IO</span>, <span class="pl-k">::</span><span class="pl-c1">MIME"text/plain"</span>, x<span class="pl-k">::</span><span class="pl-c1">Fruit2</span>) <span class="pl-k">=</span> <span class="pl-c1">@cases</span> x <span class="pl-k">begin</span>
           apple <span class="pl-k">=&gt;</span> <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>apple!<span class="pl-pds">"</span></span>)
           orange <span class="pl-k">=&gt;</span> <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>orange!<span class="pl-pds">"</span></span>)
           banana <span class="pl-k">=&gt;</span> <span class="pl-c1">print</span>(io, <span class="pl-s"><span class="pl-pds">"</span>banana!<span class="pl-pds">"</span></span>)
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> apple
apple!</pre></div>
<p dir="auto">If you overload <code>Base.show</code> directly inside a package, you might get annoying method deletion warnings during pre-compilation.</p>
</details>
<h2 dir="auto"><a id="user-content-performance" class="anchor" aria-hidden="true" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance</h2>
<p dir="auto">In the same way as <a href="https://github.com/YingboMa/Unityper.jl">Unityper.jl</a> is able to provide a dramatic speedup versus manual union splitting, SumTypes.jl can do this too:</p>
<p dir="auto">Branching on abstractly typed data</p>
<details>
<summary>Benchmark code</summary>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module AbstractTypeTest

using BenchmarkTools

abstract type AT end
Base.@kwdef struct A &lt;: AT
    common_field::Int = 0
    a::Bool = true
    b::Int = 10
end
Base.@kwdef struct B &lt;: AT
    common_field::Int = 0
    a::Int = 1
    b::Float64 = 1.0
    d::Complex = 1 + 1.0im # not isbits
end
Base.@kwdef struct C &lt;: AT
    common_field::Int = 0
    b::Float64 = 2.0
    d::Bool = false
    e::Float64 = 3.0
    k::Complex{Real} = 1 + 2im # not isbits
end
Base.@kwdef struct D &lt;: AT
    common_field::Int = 0
    b::Any = :hi # not isbits
end

foo!(xs) = for i in eachindex(xs)
    @inbounds x = xs[i]
    @inbounds xs[i] = x isa A ? B() :
                      x isa B ? C() :
                      x isa C ? D() :
                      x isa D ? A() : error()
end


xs = rand((A(), B(), C(), D()), 10000);
display(@benchmark foo!($xs);)

end"><pre><span class="pl-k">module</span> AbstractTypeTest

<span class="pl-k">using</span> BenchmarkTools

<span class="pl-k">abstract type</span> AT <span class="pl-k">end</span>
Base<span class="pl-k">.</span><span class="pl-c1">@kwdef</span> <span class="pl-k">struct</span> A <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
    common_field<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    a<span class="pl-k">::</span><span class="pl-c1">Bool</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
    b<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>
<span class="pl-k">end</span>
Base<span class="pl-k">.</span><span class="pl-c1">@kwdef</span> <span class="pl-k">struct</span> B <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
    common_field<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    a<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>
    b<span class="pl-k">::</span><span class="pl-c1">Float64</span> <span class="pl-k">=</span> <span class="pl-c1">1.0</span>
    d<span class="pl-k">::</span><span class="pl-c1">Complex</span> <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">1.0im</span> <span class="pl-c"><span class="pl-c">#</span> not isbits</span>
<span class="pl-k">end</span>
Base<span class="pl-k">.</span><span class="pl-c1">@kwdef</span> <span class="pl-k">struct</span> C <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
    common_field<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    b<span class="pl-k">::</span><span class="pl-c1">Float64</span> <span class="pl-k">=</span> <span class="pl-c1">2.0</span>
    d<span class="pl-k">::</span><span class="pl-c1">Bool</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>
    e<span class="pl-k">::</span><span class="pl-c1">Float64</span> <span class="pl-k">=</span> <span class="pl-c1">3.0</span>
    k<span class="pl-k">::</span><span class="pl-c1">Complex{Real}</span> <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span> <span class="pl-c"><span class="pl-c">#</span> not isbits</span>
<span class="pl-k">end</span>
Base<span class="pl-k">.</span><span class="pl-c1">@kwdef</span> <span class="pl-k">struct</span> D <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
    common_field<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    b<span class="pl-k">::</span><span class="pl-c1">Any</span> <span class="pl-k">=</span> <span class="pl-c1">:hi</span> <span class="pl-c"><span class="pl-c">#</span> not isbits</span>
<span class="pl-k">end</span>

<span class="pl-en">foo!</span>(xs) <span class="pl-k">=</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(xs)
    <span class="pl-c1">@inbounds</span> x <span class="pl-k">=</span> xs[i]
    <span class="pl-c1">@inbounds</span> xs[i] <span class="pl-k">=</span> x <span class="pl-k">isa</span> A <span class="pl-k">?</span> <span class="pl-c1">B</span>() <span class="pl-k">:</span>
                      x <span class="pl-k">isa</span> B <span class="pl-k">?</span> <span class="pl-c1">C</span>() <span class="pl-k">:</span>
                      x <span class="pl-k">isa</span> C <span class="pl-k">?</span> <span class="pl-c1">D</span>() <span class="pl-k">:</span>
                      x <span class="pl-k">isa</span> D <span class="pl-k">?</span> <span class="pl-c1">A</span>() <span class="pl-k">:</span> <span class="pl-c1">error</span>()
<span class="pl-k">end</span>


xs <span class="pl-k">=</span> <span class="pl-c1">rand</span>((<span class="pl-c1">A</span>(), <span class="pl-c1">B</span>(), <span class="pl-c1">C</span>(), <span class="pl-c1">D</span>()), <span class="pl-c1">10000</span>);
<span class="pl-c1">display</span>(<span class="pl-c1">@benchmark</span> <span class="pl-c1">foo!</span>(<span class="pl-k">$</span>xs);)

<span class="pl-k">end</span></pre></div>
</details>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  267.399 μs …   3.118 ms  ┊ GC (min … max):  0.00% … 90.36%
 Time  (median):     278.904 μs               ┊ GC (median):     0.00%
 Time  (mean ± σ):   316.971 μs ± 306.290 μs  ┊ GC (mean ± σ):  11.68% ± 10.74%

  █                                                             ▁
  █▆▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇▇ █
  267 μs        Histogram: log(frequency) by time       2.77 ms &lt;

 Memory estimate: 654.75 KiB, allocs estimate: 21952."><pre class="notranslate"><code>BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  267.399 μs …   3.118 ms  ┊ GC (min … max):  0.00% … 90.36%
 Time  (median):     278.904 μs               ┊ GC (median):     0.00%
 Time  (mean ± σ):   316.971 μs ± 306.290 μs  ┊ GC (mean ± σ):  11.68% ± 10.74%

  █                                                             ▁
  █▆▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇▇ █
  267 μs        Histogram: log(frequency) by time       2.77 ms &lt;

 Memory estimate: 654.75 KiB, allocs estimate: 21952.
</code></pre></div>
<p dir="auto">SumTypes.jl</p>
<details>
<summary>Benchmark code</summary>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module SumTypeTest

using SumTypes,  BenchmarkTools
@sum_type AT begin
    A(common_field::Int, a::Bool, b::Int)
    B(common_field::Int, a::Int, b::Float64, d::Complex)
    C(common_field::Int, b::Float64, d::Bool, e::Float64, k::Complex{Real})
    D(common_field::Int, b::Any)
end

A(;common_field=1, a=true, b=10) = A(common_field, a, b) 
B(;common_field=1, a=1, b=1.0, d=1 + 1.0im) = B(common_field, a, b, d)
C(;common_field=1, b=2.0, d=false, e=3.0, k=Complex{Real}(1 + 2im)) = C(common_field, b, d, e, k)
D(;common_field=1, b=:hi) = D(common_field, b)

foo!(xs) = for i in eachindex(xs)
    xs[i] = @cases xs[i] begin
        A =&gt; B()
        B =&gt; C()
        C =&gt; D()
        D =&gt; A()
    end
end

xs = rand((A(), B(), C(), D()), 10000);
display(@benchmark foo!($xs);)

end "><pre><span class="pl-k">module</span> SumTypeTest

<span class="pl-k">using</span> SumTypes,  BenchmarkTools
<span class="pl-c1">@sum_type</span> AT <span class="pl-k">begin</span>
    <span class="pl-c1">A</span>(common_field<span class="pl-k">::</span><span class="pl-c1">Int</span>, a<span class="pl-k">::</span><span class="pl-c1">Bool</span>, b<span class="pl-k">::</span><span class="pl-c1">Int</span>)
    <span class="pl-c1">B</span>(common_field<span class="pl-k">::</span><span class="pl-c1">Int</span>, a<span class="pl-k">::</span><span class="pl-c1">Int</span>, b<span class="pl-k">::</span><span class="pl-c1">Float64</span>, d<span class="pl-k">::</span><span class="pl-c1">Complex</span>)
    <span class="pl-c1">C</span>(common_field<span class="pl-k">::</span><span class="pl-c1">Int</span>, b<span class="pl-k">::</span><span class="pl-c1">Float64</span>, d<span class="pl-k">::</span><span class="pl-c1">Bool</span>, e<span class="pl-k">::</span><span class="pl-c1">Float64</span>, k<span class="pl-k">::</span><span class="pl-c1">Complex{Real}</span>)
    <span class="pl-c1">D</span>(common_field<span class="pl-k">::</span><span class="pl-c1">Int</span>, b<span class="pl-k">::</span><span class="pl-c1">Any</span>)
<span class="pl-k">end</span>

<span class="pl-en">A</span>(;common_field<span class="pl-k">=</span><span class="pl-c1">1</span>, a<span class="pl-k">=</span><span class="pl-c1">true</span>, b<span class="pl-k">=</span><span class="pl-c1">10</span>) <span class="pl-k">=</span> <span class="pl-c1">A</span>(common_field, a, b) 
<span class="pl-en">B</span>(;common_field<span class="pl-k">=</span><span class="pl-c1">1</span>, a<span class="pl-k">=</span><span class="pl-c1">1</span>, b<span class="pl-k">=</span><span class="pl-c1">1.0</span>, d<span class="pl-k">=</span><span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">1.0im</span>) <span class="pl-k">=</span> <span class="pl-c1">B</span>(common_field, a, b, d)
<span class="pl-en">C</span>(;common_field<span class="pl-k">=</span><span class="pl-c1">1</span>, b<span class="pl-k">=</span><span class="pl-c1">2.0</span>, d<span class="pl-k">=</span><span class="pl-c1">false</span>, e<span class="pl-k">=</span><span class="pl-c1">3.0</span>, k<span class="pl-k">=</span><span class="pl-en">Complex</span><span class="pl-c1">{Real}</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span>)) <span class="pl-k">=</span> <span class="pl-c1">C</span>(common_field, b, d, e, k)
<span class="pl-en">D</span>(;common_field<span class="pl-k">=</span><span class="pl-c1">1</span>, b<span class="pl-k">=</span><span class="pl-c1">:hi</span>) <span class="pl-k">=</span> <span class="pl-c1">D</span>(common_field, b)

<span class="pl-en">foo!</span>(xs) <span class="pl-k">=</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(xs)
    xs[i] <span class="pl-k">=</span> <span class="pl-c1">@cases</span> xs[i] <span class="pl-k">begin</span>
        A <span class="pl-k">=&gt;</span> <span class="pl-c1">B</span>()
        B <span class="pl-k">=&gt;</span> <span class="pl-c1">C</span>()
        C <span class="pl-k">=&gt;</span> <span class="pl-c1">D</span>()
        D <span class="pl-k">=&gt;</span> <span class="pl-c1">A</span>()
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

xs <span class="pl-k">=</span> <span class="pl-c1">rand</span>((<span class="pl-c1">A</span>(), <span class="pl-c1">B</span>(), <span class="pl-c1">C</span>(), <span class="pl-c1">D</span>()), <span class="pl-c1">10000</span>);
<span class="pl-c1">display</span>(<span class="pl-c1">@benchmark</span> <span class="pl-c1">foo!</span>(<span class="pl-k">$</span>xs);)

<span class="pl-k">end</span> </pre></div>
</details>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  52.680 μs …  72.570 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     53.590 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   53.718 μs ± 756.064 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

        ▁▂▁▃▆▅█▇▅▅▃▁▁                                           
  ▁▂▂▃▅▆██████████████▇▇▅▄▄▃▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃
  52.7 μs         Histogram: frequency by time         56.7 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0."><pre class="notranslate"><code>BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  52.680 μs …  72.570 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     53.590 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   53.718 μs ± 756.064 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

        ▁▂▁▃▆▅█▇▅▅▃▁▁                                           
  ▁▂▂▃▅▆██████████████▇▇▅▄▄▃▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃
  52.7 μs         Histogram: frequency by time         56.7 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
</code></pre></div>
<p dir="auto">And Unityper.jl:</p>
<details>
<summary>Benchmark code</summary>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module UnityperTest

using Unityper, BenchmarkTools

@compactify begin
    @abstract struct AT
        common_field::Int = 0
    end
    struct A &lt;: AT
        a::Bool = true
        b::Int = 10
    end
    struct B &lt;: AT
        a::Int = 1
        b::Float64 = 1.0
        d::Complex = 1 + 1.0im # not isbits
    end
    struct C &lt;: AT
        b::Float64 = 2.0
        d::Bool = false
        e::Float64 = 3.0
        k::Complex{Real} = 1 + 2im # not isbits
    end
    struct D &lt;: AT
        b::Any = :hi # not isbits
    end
end

foo!(xs) = for i in eachindex(xs)
    @inbounds x = xs[i]
    @inbounds xs[i] = @compactified x::AT begin
        A =&gt; B()
        B =&gt; C()
        C =&gt; D()
        D =&gt; A()
    end
end

xs = rand((A(), B(), C(), D()), 10000);
display(@benchmark foo!($xs);)

end"><pre><span class="pl-k">module</span> UnityperTest

<span class="pl-k">using</span> Unityper, BenchmarkTools

<span class="pl-c1">@compactify</span> <span class="pl-k">begin</span>
    <span class="pl-c1">@abstract</span> <span class="pl-k">struct</span> AT
        common_field<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">end</span>
    <span class="pl-k">struct</span> A <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
        a<span class="pl-k">::</span><span class="pl-c1">Bool</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
        b<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>
    <span class="pl-k">end</span>
    <span class="pl-k">struct</span> B <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
        a<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>
        b<span class="pl-k">::</span><span class="pl-c1">Float64</span> <span class="pl-k">=</span> <span class="pl-c1">1.0</span>
        d<span class="pl-k">::</span><span class="pl-c1">Complex</span> <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">1.0im</span> <span class="pl-c"><span class="pl-c">#</span> not isbits</span>
    <span class="pl-k">end</span>
    <span class="pl-k">struct</span> C <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
        b<span class="pl-k">::</span><span class="pl-c1">Float64</span> <span class="pl-k">=</span> <span class="pl-c1">2.0</span>
        d<span class="pl-k">::</span><span class="pl-c1">Bool</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>
        e<span class="pl-k">::</span><span class="pl-c1">Float64</span> <span class="pl-k">=</span> <span class="pl-c1">3.0</span>
        k<span class="pl-k">::</span><span class="pl-c1">Complex{Real}</span> <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span> <span class="pl-c"><span class="pl-c">#</span> not isbits</span>
    <span class="pl-k">end</span>
    <span class="pl-k">struct</span> D <span class="pl-k">&lt;:</span> <span class="pl-c1">AT</span>
        b<span class="pl-k">::</span><span class="pl-c1">Any</span> <span class="pl-k">=</span> <span class="pl-c1">:hi</span> <span class="pl-c"><span class="pl-c">#</span> not isbits</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-en">foo!</span>(xs) <span class="pl-k">=</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(xs)
    <span class="pl-c1">@inbounds</span> x <span class="pl-k">=</span> xs[i]
    <span class="pl-c1">@inbounds</span> xs[i] <span class="pl-k">=</span> <span class="pl-c1">@compactified</span> x<span class="pl-k">::</span><span class="pl-c1">AT</span> <span class="pl-k">begin</span>
        A <span class="pl-k">=&gt;</span> <span class="pl-c1">B</span>()
        B <span class="pl-k">=&gt;</span> <span class="pl-c1">C</span>()
        C <span class="pl-k">=&gt;</span> <span class="pl-c1">D</span>()
        D <span class="pl-k">=&gt;</span> <span class="pl-c1">A</span>()
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

xs <span class="pl-k">=</span> <span class="pl-c1">rand</span>((<span class="pl-c1">A</span>(), <span class="pl-c1">B</span>(), <span class="pl-c1">C</span>(), <span class="pl-c1">D</span>()), <span class="pl-c1">10000</span>);
<span class="pl-c1">display</span>(<span class="pl-c1">@benchmark</span> <span class="pl-c1">foo!</span>(<span class="pl-k">$</span>xs);)

<span class="pl-k">end</span></pre></div>
</details>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  54.220 μs …  76.000 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     55.030 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   55.073 μs ± 466.103 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

              ▁▁▅▄▄▅▅█▄▅▃▃▂                                     
  ▁▁▁▁▂▂▂▃▄▆▆███████████████▇▆▅▆▃▃▃▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃
  54.2 μs         Histogram: frequency by time         56.7 μs &lt;
 Memory estimate: 0 bytes, allocs estimate: 0."><pre class="notranslate"><code>BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  54.220 μs …  76.000 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     55.030 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   55.073 μs ± 466.103 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

              ▁▁▅▄▄▅▅█▄▅▃▃▂                                     
  ▁▁▁▁▂▂▂▃▄▆▆███████████████▇▆▅▆▃▃▃▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃
  54.2 μs         Histogram: frequency by time         56.7 μs &lt;
 Memory estimate: 0 bytes, allocs estimate: 0.
</code></pre></div>
<p dir="auto">SumTypes.jl and Unityper.jl are about equal in this benchmark, though there are cases where there are differences.
SumTypes.jl has some other advantages relative to Unityper.jl such as:</p>
<ul dir="auto">
<li>SumTypes.jl allows <a href="https://docs.julialang.org/en/v1/manual/types/#Parametric-Types" rel="nofollow">parametric types</a> for much greater container flexibility.</li>
<li>SumTypes.jl does not require default values for every field of the struct.</li>
<li>SumTypes.jl's <code>@cases</code> macro is more powerful and flexible than Unityper's <code>@compactified</code>.</li>
<li>SumTypes.jl allows you to hide its variants from the namespace (opt in).</li>
</ul>
<p dir="auto">One advantage of Unityper.jl is:</p>
<ul dir="auto">
<li>Because Unityper.jl doesn't allow parameterized types and needs to know all type information at macroexpansion time, their structs have a fixed layout for boxed variables that lets them avoid an allocation when storing heap allocated objects (this allocation would be in addition to the heap allocation for the object itself). If we had used <code>D(;common_field=1, b="hi")</code> in our benchmarks, SumTypes.jl could have incurred an allocation whereas Unityper.jl would not. As far as I know, this would requre <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="43921745" data-permission-text="Title is private" data-url="https://github.com/JuliaLang/julia/issues/8472" data-hovercard-type="issue" data-hovercard-url="/JuliaLang/julia/issues/8472/hovercard" href="https://github.com/JuliaLang/julia/issues/8472">JuliaLang/julia#8472</a> in order to avoid in SumTypes.jl</li>
</ul>
</article></div>