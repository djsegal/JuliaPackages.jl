<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p align="center" dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="assets/gblogo.png"><img src="assets/gblogo.png" width="600" alt="" style="max-width: 100%;"></a>
</p>
<table align="center">
  <tbody><tr>
    <th>CI</th>
    <th>Coverage</th>
    <th>License</th>
  </tr>
  <tr>
    <td align="center">
      <a href="https://github.com/FermiQC/GaussianBasis.jl/actions/workflows/CI.yml">
      <img src="https://github.com/FermiQC/GaussianBasis.jl/actions/workflows/CI.yml/badge.svg" style="max-width: 100%;">
      </a> 
    </td>
    <td align="center">
      <a href="https://codecov.io/gh/FermiQC/GaussianBasis.jl" rel="nofollow">
      <img src="https://camo.githubusercontent.com/abd4cd63b66ca40eb8fb4b8b60f5722e0432b53d5db3d0fa461904911826ad79/68747470733a2f2f636f6465636f762e696f2f67682f4665726d6951432f476175737369616e42617369732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d4a4e6f754a50776f486d" data-canonical-src="https://codecov.io/gh/FermiQC/GaussianBasis.jl/branch/main/graph/badge.svg?token=JNouJPwoHm" style="max-width: 100%;">
      </a> 
    </td>
    <td align="center">
      <a href="https://github.com/FermiQC/GaussianBasis.jl/blob/main/LICENSE">
      <img src="https://camo.githubusercontent.com/5fab2edf3816ef9fb3ebcaf6e613fa7b40ff7652ec69e5f6e7f695aa24bf5ce6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d626c75652e737667" data-canonical-src="https://img.shields.io/badge/License-MIT-blue.svg" style="max-width: 100%;">
      </a>
    </td>
  </tr>
</tbody></table>
<p dir="auto">GaussianBasis offers high-level utilities for molecular integral computations.</p>
<p dir="auto">Current features include:</p>
<ul dir="auto">
<li>Basis set parsing (<code>gbs</code> format)</li>
<li>Standard basis set files from <a href="https://www.basissetexchange.org/" rel="nofollow">BSE</a></li>
<li>One-electron integral (1e)</li>
<li>Two-electron two-center integral (2e2c)</li>
<li>Two-electrons three-center integral (2e3c)</li>
<li>Two-electrons four-center integral (2e4c)</li>
<li>Gradients (currrently under construction - <em>watch out!</em>)</li>
</ul>
<p dir="auto">Integral computations use by default the integral library <a href="https://github.com/sunqm/libcint">libcint</a> <em>via</em> <a href="https://github.com/JuliaBinaryWrappers/libcint_jll.jl">libcint_jll.jl</a>. A simple Julia-written integral module <code>Acsint.jl</code> is also available, but it is significantly slower than the <code>libcint</code>.</p>
<h1 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic Usage</h1>
<p dir="auto">The simplest way to use the code is by first creating a <code>BasisSet</code> object. For example</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; bset = BasisSet(&quot;sto-3g&quot;, &quot;&quot;&quot;
              H        0.00      0.00     0.00                 
              H        0.76      0.00     0.00&quot;&quot;&quot;)
sto-3g Basis Set
Type: Spherical   Backend: Libcint
Number of shells: 2
Number of basis:  2

H: 1s 
H: 1s"><pre>julia<span class="pl-k">&gt;</span> bset <span class="pl-k">=</span> <span class="pl-c1">BasisSet</span>(<span class="pl-s"><span class="pl-pds">"</span>sto-3g<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">              H        0.00      0.00     0.00                 </span>
<span class="pl-s">              H        0.76      0.00     0.00<span class="pl-pds">"""</span></span>)
sto<span class="pl-k">-</span><span class="pl-c1">3</span>g Basis Set
Type<span class="pl-k">:</span> Spherical   Backend<span class="pl-k">:</span> Libcint
Number of shells<span class="pl-k">:</span> <span class="pl-c1">2</span>
Number of basis<span class="pl-k">:</span>  <span class="pl-c1">2</span>

H<span class="pl-k">:</span> <span class="pl-c1">1</span>s 
H<span class="pl-k">:</span> <span class="pl-c1">1</span>s</pre></div>
<p dir="auto">Next, call the desired integral function with the <code>BasisSet</code> object as the argument. Let's take the <code>overlap</code> function as an example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; overlap(bset)
2×2 Matrix{Float64}:
 1.0       0.646804
 0.646804  1.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">overlap</span>(bset)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span>       <span class="pl-c1">0.646804</span>
 <span class="pl-c1">0.646804</span>  <span class="pl-c1">1.0</span></pre></div>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
<th align="center">Formula</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>overlap</code></td>
<td>Overlap between two basis functions</td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="assets/ovlp.png"><img src="assets/ovlp.png" alt="S" style="max-width: 100%;"></a></td>
</tr>
<tr>
<td><code>kinetic</code></td>
<td>Kinetic integral</td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="assets/kin.png"><img src="assets/kin.png" alt="T" style="max-width: 100%;"></a></td>
</tr>
<tr>
<td><code>nuclear</code></td>
<td>Nuclear attraction integral</td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="assets/nuc.png"><img src="assets/nuc.png" alt="V" style="max-width: 100%;"></a></td>
</tr>
<tr>
<td><code>ERI_2e4c</code></td>
<td>Electron repulsion integral - returns a full rank-4 tensor!</td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="assets/4cERI.png"><img src="assets/4cERI.png" alt="ERI" style="max-width: 100%;"></a></td>
</tr>
<tr>
<td><code>sparseERI_2e4c</code></td>
<td>Electron repulsion integral - returns non-zero elements along with a index tuple</td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="assets/4cERI.png"><img src="assets/4cERI.png" alt="sERI" style="max-width: 100%;"></a></td>
</tr>
<tr>
<td><code>ERI_2e3c</code></td>
<td>Electron repulsion integral over three centers. <strong>Note:</strong> this function requires another basis set as the second argument (that is the auxiliary basis set in <a href="http://vergil.chemistry.gatech.edu/notes/df.pdf" rel="nofollow">Density Fitting</a>). It must be called as <code>ERI_2c3c(bset, aux)</code></td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="assets/3cERI.png"><img src="assets/3cERI.png" alt="3cERI" style="max-width: 100%;"></a></td>
</tr>
<tr>
<td><code>ERI_2e2c</code></td>
<td>Electron repulsion integral over two centers</td>
<td align="center"><a target="_blank" rel="noopener noreferrer" href="assets/2cERI.png"><img src="assets/2cERI.png" alt="2cERI" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table>
<h1 dir="auto"><a id="user-content-advanced-usage" class="anchor" aria-hidden="true" href="#advanced-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Advanced Usage</h1>
<h2 dir="auto"><a id="user-content-basis-functions" class="anchor" aria-hidden="true" href="#basis-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basis Functions</h2>
<p dir="auto"><code>BasisFunction</code> object is the central data type within this package. Here, <code>BasisFunction</code> is an abstract type with two concrete structures: <code>SphericalShell</code> and <code>CartesianShell</code>. By default <code>SphericalShell</code> is created. In general a spherical basis function is</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="assets/bf.png"><img src="assets/bf.png" alt="BF" style="max-width: 100%;"></a></p>
<p dir="auto">where the sum goes over primitive functions. A <code>BasisFunction</code> object contains the data to reproduce the mathematical object, i.e. the angular momentum number (<em><strong>l</strong></em>), expansion coefficients (<em><strong>c<sub>n</sub></strong></em>), and exponential factors (<em><strong>ξ<sub>n</sub></strong></em>). We can create a basis function by passing these arguments orderly:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using StaticArrays
julia&gt; atom = GaussianBasis.Atom(8, 16.0, [1.0, 0.0, 0.0])
julia&gt; bf = BasisFunction(1, SVector(1/√2, 1/√2), SVector(5.0, 1.2), atom)
P shell with 3 basis built from 2 primitive gaussians

χ₁₋₁ =    0.7071067812⋅Y₁₋₁⋅r¹⋅exp(-5.0⋅r²)
     +    0.7071067812⋅Y₁₋₁⋅r¹⋅exp(-1.2⋅r²)

χ₁₀  =    0.7071067812⋅Y₁₀⋅r¹⋅exp(-5.0⋅r²)
     +    0.7071067812⋅Y₁₀⋅r¹⋅exp(-1.2⋅r²)

χ₁₁  =    0.7071067812⋅Y₁₁⋅r¹⋅exp(-5.0⋅r²)
     +    0.7071067812⋅Y₁₁⋅r¹⋅exp(-1.2⋅r²)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> StaticArrays
julia<span class="pl-k">&gt;</span> atom <span class="pl-k">=</span> GaussianBasis<span class="pl-k">.</span><span class="pl-c1">Atom</span>(<span class="pl-c1">8</span>, <span class="pl-c1">16.0</span>, [<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>])
julia<span class="pl-k">&gt;</span> bf <span class="pl-k">=</span> <span class="pl-c1">BasisFunction</span>(<span class="pl-c1">1</span>, <span class="pl-c1">SVector</span>(<span class="pl-c1">1</span><span class="pl-k">/√</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">/√</span><span class="pl-c1">2</span>), <span class="pl-c1">SVector</span>(<span class="pl-c1">5.0</span>, <span class="pl-c1">1.2</span>), atom)
P shell with <span class="pl-c1">3</span> basis built from <span class="pl-c1">2</span> primitive gaussians

χ₁₋₁ <span class="pl-k">=</span>    <span class="pl-c1">0.7071067812</span><span class="pl-k">⋅</span>Y₁₋₁<span class="pl-k">⋅</span>r¹<span class="pl-k">⋅</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">5.0</span><span class="pl-k">⋅</span>r²)
     <span class="pl-k">+</span>    <span class="pl-c1">0.7071067812</span><span class="pl-k">⋅</span>Y₁₋₁<span class="pl-k">⋅</span>r¹<span class="pl-k">⋅</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">1.2</span><span class="pl-k">⋅</span>r²)

χ₁₀  <span class="pl-k">=</span>    <span class="pl-c1">0.7071067812</span><span class="pl-k">⋅</span>Y₁₀<span class="pl-k">⋅</span>r¹<span class="pl-k">⋅</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">5.0</span><span class="pl-k">⋅</span>r²)
     <span class="pl-k">+</span>    <span class="pl-c1">0.7071067812</span><span class="pl-k">⋅</span>Y₁₀<span class="pl-k">⋅</span>r¹<span class="pl-k">⋅</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">1.2</span><span class="pl-k">⋅</span>r²)

χ₁₁  <span class="pl-k">=</span>    <span class="pl-c1">0.7071067812</span><span class="pl-k">⋅</span>Y₁₁<span class="pl-k">⋅</span>r¹<span class="pl-k">⋅</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">5.0</span><span class="pl-k">⋅</span>r²)
     <span class="pl-k">+</span>    <span class="pl-c1">0.7071067812</span><span class="pl-k">⋅</span>Y₁₁<span class="pl-k">⋅</span>r¹<span class="pl-k">⋅</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">1.2</span><span class="pl-k">⋅</span>r²)</pre></div>
<p dir="auto">We can now check the fields (attributes):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; bf.l
1

julia&gt; bf.coef
2-element SVector{2, Float64} with indices SOneTo(2):
 0.7071067811865475
 0.7071067811865475

julia&gt; bf.exp
2-element SVector{2, Float64} with indices SOneTo(2):
 5.0
 1.2"><pre>julia<span class="pl-k">&gt;</span> bf<span class="pl-k">.</span>l
<span class="pl-c1">1</span>

julia<span class="pl-k">&gt;</span> bf<span class="pl-k">.</span>coef
<span class="pl-c1">2</span><span class="pl-k">-</span>element SVector{<span class="pl-c1">2</span>, Float64} with indices <span class="pl-c1">SOneTo</span>(<span class="pl-c1">2</span>)<span class="pl-k">:</span>
 <span class="pl-c1">0.7071067811865475</span>
 <span class="pl-c1">0.7071067811865475</span>

julia<span class="pl-k">&gt;</span> bf<span class="pl-k">.</span>exp
<span class="pl-c1">2</span><span class="pl-k">-</span>element SVector{<span class="pl-c1">2</span>, Float64} with indices <span class="pl-c1">SOneTo</span>(<span class="pl-c1">2</span>)<span class="pl-k">:</span>
 <span class="pl-c1">5.0</span>
 <span class="pl-c1">1.2</span></pre></div>
<p dir="auto">Note that <code>exp</code> and <code>coef</code> are expected to be <code>SVector</code> from <code>StaticArrays</code>.</p>
<h2 dir="auto"><a id="user-content-basis-set" class="anchor" aria-hidden="true" href="#basis-set"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basis Set</h2>
<p dir="auto">The <code>BasisSet</code> object is the main ingredient for integrals. It can be created in a number of ways:</p>
<ul dir="auto">
<li>
<p dir="auto">The highest level approach takes two strings as arguments, one for the basis set name and another for the XYZ file. See <em>Basic Usage</em>.</p>
</li>
<li>
<p dir="auto">You can pass your vector of <code>Atom</code> structures instead of an XYZ string as the second argument. <code>GaussianBasis</code> uses the <code>Atom</code> structure from <a href="https://github.com/FermiQC/GaussianBasis.jl">Molecules.jl</a>.</p>
</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="atoms = GaussianBasis.parse_string(&quot;&quot;&quot;
            H        0.00      0.00     0.00                 
            H        0.76      0.00     0.00&quot;&quot;&quot;)
BasisSet(&quot;sto-3g&quot;, atoms)"><pre>atoms <span class="pl-k">=</span> GaussianBasis<span class="pl-k">.</span><span class="pl-c1">parse_string</span>(<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">            H        0.00      0.00     0.00                 </span>
<span class="pl-s">            H        0.76      0.00     0.00<span class="pl-pds">"""</span></span>)
<span class="pl-c1">BasisSet</span>(<span class="pl-s"><span class="pl-pds">"</span>sto-3g<span class="pl-pds">"</span></span>, atoms)</pre></div>
<ul dir="auto">
<li>Finally, instead of searching into <code>GaussianBasis/lib</code> for a basis set file matching the desired name, you can construct your own from scratch. We further discuss this approach below.</li>
</ul>
<p dir="auto">Basis sets are mainly composed of two arrays: a vector of atoms and a vector of basis functions objects. We can construct both manually for maximum flexibility:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; h2 = GaussianBasis.parse_string(
  &quot;H 0.0 0.0 0.0
   H 0.0 0.0 0.7&quot;
)
2-element Vector{Atom{Int16, Float64}}:
Atom{Int16, Float64}(1, 1.008, [0.0, 0.0, 0.0])
Atom{Int16, Float64}(1, 1.008, [0.0, 0.0, 0.7])"><pre>julia<span class="pl-k">&gt;</span> h2 <span class="pl-k">=</span> GaussianBasis<span class="pl-k">.</span><span class="pl-c1">parse_string</span>(
  <span class="pl-s"><span class="pl-pds">"</span>H 0.0 0.0 0.0</span>
<span class="pl-s">   H 0.0 0.0 0.7<span class="pl-pds">"</span></span>
)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Atom{Int16, Float64}}<span class="pl-k">:</span>
<span class="pl-c1">Atom</span><span class="pl-c1">{Int16, Float64}</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1.008</span>, [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>])
<span class="pl-c1">Atom</span><span class="pl-c1">{Int16, Float64}</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1.008</span>, [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.7</span>])</pre></div>
<p dir="auto">Next, we create a vector of basis functions.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; shells = [BasisFunction(0, SVector(0.5215367271), SVector(0.122), h2[1]),
BasisFunction(0, SVector(0.5215367271), SVector(0.122), h2[2]),
BasisFunction(1, SVector(1.9584045349), SVector(0.727), h2[2])];"><pre>julia<span class="pl-k">&gt;</span> shells <span class="pl-k">=</span> [<span class="pl-c1">BasisFunction</span>(<span class="pl-c1">0</span>, <span class="pl-c1">SVector</span>(<span class="pl-c1">0.5215367271</span>), <span class="pl-c1">SVector</span>(<span class="pl-c1">0.122</span>), h2[<span class="pl-c1">1</span>]),
<span class="pl-c1">BasisFunction</span>(<span class="pl-c1">0</span>, <span class="pl-c1">SVector</span>(<span class="pl-c1">0.5215367271</span>), <span class="pl-c1">SVector</span>(<span class="pl-c1">0.122</span>), h2[<span class="pl-c1">2</span>]),
<span class="pl-c1">BasisFunction</span>(<span class="pl-c1">1</span>, <span class="pl-c1">SVector</span>(<span class="pl-c1">1.9584045349</span>), <span class="pl-c1">SVector</span>(<span class="pl-c1">0.727</span>), h2[<span class="pl-c1">2</span>])];</pre></div>
<p dir="auto">Finally, we create the basis set object. Note that, you got to make sure your procedure is consistent. The atoms used to construct the basis set object must be in the <code>atom</code> vector, otherwise unexpected results may arise.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; bset = BasisSet(&quot;UnequalHydrogens&quot;, h2, shells)
UnequalHydrogens Basis Set
Type: Spherical{Molecules.Atom, 1, Float64}   Backend: Libcint
Number of shells: 3
Number of basis:  5

H: 1s 
H: 1s 1p"><pre>julia<span class="pl-k">&gt;</span> bset <span class="pl-k">=</span> <span class="pl-c1">BasisSet</span>(<span class="pl-s"><span class="pl-pds">"</span>UnequalHydrogens<span class="pl-pds">"</span></span>, h2, shells)
UnequalHydrogens Basis Set
Type<span class="pl-k">:</span> Spherical{Molecules<span class="pl-k">.</span>Atom, <span class="pl-c1">1</span>, Float64}   Backend<span class="pl-k">:</span> Libcint
Number of shells<span class="pl-k">:</span> <span class="pl-c1">3</span>
Number of basis<span class="pl-k">:</span>  <span class="pl-c1">5</span>

H<span class="pl-k">:</span> <span class="pl-c1">1</span>s 
H<span class="pl-k">:</span> <span class="pl-c1">1</span>s <span class="pl-c1">1</span>p</pre></div>
<p dir="auto">The most import fields here are:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; bset.name == &quot;UnequalHydrogens&quot;
true
julia&gt; bset.basis == shells 
true
julia&gt; bset.atoms == h2
true"><pre>julia<span class="pl-k">&gt;</span> bset<span class="pl-k">.</span>name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>UnequalHydrogens<span class="pl-pds">"</span></span>
<span class="pl-c1">true</span>
julia<span class="pl-k">&gt;</span> bset<span class="pl-k">.</span>basis <span class="pl-k">==</span> shells 
<span class="pl-c1">true</span>
julia<span class="pl-k">&gt;</span> bset<span class="pl-k">.</span>atoms <span class="pl-k">==</span> h2
<span class="pl-c1">true</span></pre></div>
<h3 dir="auto"><a id="user-content-integrals-over-different-basis-sets" class="anchor" aria-hidden="true" href="#integrals-over-different-basis-sets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Integrals over different basis sets</h3>
<p dir="auto">Functions such as <code>ERI_2e3c</code> require two basis set as arguments. Looking at the corresponding equation
<a target="_blank" rel="noopener noreferrer" href="assets/3cERI.png"><img src="assets/3cERI.png" alt="3cERI" style="max-width: 100%;"></a> we see two basis set: <em><strong>Χ</strong></em> and <em><strong>P</strong></em>. If your first basis set has 2 basis functions and the second has 4, your output array is a 2x2x4 tensor. For example</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; b1 = BasisSet(&quot;sto-3g&quot;, &quot;&quot;&quot;
              H        0.00      0.00     0.00                 
              H        0.76      0.00     0.00&quot;&quot;&quot;)
julia&gt; b2 = BasisSet(&quot;3-21g&quot;, &quot;&quot;&quot;
              H        0.00      0.00     0.00                 
              H        0.76      0.00     0.00&quot;&quot;&quot;)
julia&gt; ERI_2e3c(b1,b2)
2×2×4 Array{Float64, 3}:
[:, :, 1] =
 3.26737  1.85666
 1.85666  2.44615

[:, :, 2] =
 6.18932  3.83049
 3.83049  5.60161

[:, :, 3] =
 2.44615  1.85666
 1.85666  3.26737

[:, :, 4] =
 5.60161  3.83049
 3.83049  6.18932"><pre>julia<span class="pl-k">&gt;</span> b1 <span class="pl-k">=</span> <span class="pl-c1">BasisSet</span>(<span class="pl-s"><span class="pl-pds">"</span>sto-3g<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">              H        0.00      0.00     0.00                 </span>
<span class="pl-s">              H        0.76      0.00     0.00<span class="pl-pds">"""</span></span>)
julia<span class="pl-k">&gt;</span> b2 <span class="pl-k">=</span> <span class="pl-c1">BasisSet</span>(<span class="pl-s"><span class="pl-pds">"</span>3-21g<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">              H        0.00      0.00     0.00                 </span>
<span class="pl-s">              H        0.76      0.00     0.00<span class="pl-pds">"""</span></span>)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">ERI_2e3c</span>(b1,b2)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">4</span> Array{Float64, <span class="pl-c1">3</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">3.26737</span>  <span class="pl-c1">1.85666</span>
 <span class="pl-c1">1.85666</span>  <span class="pl-c1">2.44615</span>

[:, :, <span class="pl-c1">2</span>] <span class="pl-k">=</span>
 <span class="pl-c1">6.18932</span>  <span class="pl-c1">3.83049</span>
 <span class="pl-c1">3.83049</span>  <span class="pl-c1">5.60161</span>

[:, :, <span class="pl-c1">3</span>] <span class="pl-k">=</span>
 <span class="pl-c1">2.44615</span>  <span class="pl-c1">1.85666</span>
 <span class="pl-c1">1.85666</span>  <span class="pl-c1">3.26737</span>

[:, :, <span class="pl-c1">4</span>] <span class="pl-k">=</span>
 <span class="pl-c1">5.60161</span>  <span class="pl-c1">3.83049</span>
 <span class="pl-c1">3.83049</span>  <span class="pl-c1">6.18932</span></pre></div>
<p dir="auto">One electron integrals can also be employed with different basis set.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; overlap(b1, b2)
2×4 Matrix{Float64}:
 0.914077  0.899458  0.473201  0.708339
 0.473201  0.708339  0.914077  0.899458

julia&gt; kinetic(b1, b2)
2×4 Matrix{Float64}:
 1.03401  0.314867  0.20091  0.203163
 0.20091  0.203163  1.03401  0.314867"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">overlap</span>(b1, b2)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">4</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.914077</span>  <span class="pl-c1">0.899458</span>  <span class="pl-c1">0.473201</span>  <span class="pl-c1">0.708339</span>
 <span class="pl-c1">0.473201</span>  <span class="pl-c1">0.708339</span>  <span class="pl-c1">0.914077</span>  <span class="pl-c1">0.899458</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">kinetic</span>(b1, b2)
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">4</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">1.03401</span>  <span class="pl-c1">0.314867</span>  <span class="pl-c1">0.20091</span>  <span class="pl-c1">0.203163</span>
 <span class="pl-c1">0.20091</span>  <span class="pl-c1">0.203163</span>  <span class="pl-c1">1.03401</span>  <span class="pl-c1">0.314867</span></pre></div>
<p dir="auto">This can be useful when working with projections from one basis set onto another.</p>
<h3 dir="auto"><a id="user-content-computing-integrals-element-wise" class="anchor" aria-hidden="true" href="#computing-integrals-element-wise"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Computing integrals element-wise</h3>
<p dir="auto">For all integrals, you can get the full array by using the general syntax <code>integral(basisset)</code> (e.g. <code>overlap(bset)</code> or <code>ERI_2e4c(bset)</code>). Alternatively, you can specify a shell combination for which the integral must be computed</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ERI_2e4c(b1, 1,2,2,1)
1×1×1×1 Array{Float64, 4}:
[:, :, 1, 1] =
 0.2845189435761272

julia&gt; kinetic(b1, 1,2)
1×1 Matrix{Float64}:
 0.2252049038643092"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">ERI_2e4c</span>(b1, <span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>,<span class="pl-c1">1</span>)
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span> Array{Float64, <span class="pl-c1">4</span>}<span class="pl-k">:</span>
[:, :, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span>
 <span class="pl-c1">0.2845189435761272</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">kinetic</span>(b1, <span class="pl-c1">1</span>,<span class="pl-c1">2</span>)
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.2252049038643092</span></pre></div>
<p dir="auto">Mutating versions of the functions are also available</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; S = zeros(2,2);
julia&gt; overlap!(S, b1)
julia&gt; S
2×2 Matrix{Float64}:
 1.0       0.646804
 0.646804  1.0"><pre>julia<span class="pl-k">&gt;</span> S <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">2</span>,<span class="pl-c1">2</span>);
julia<span class="pl-k">&gt;</span> <span class="pl-c1">overlap!</span>(S, b1)
julia<span class="pl-k">&gt;</span> S
<span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">1.0</span>       <span class="pl-c1">0.646804</span>
 <span class="pl-c1">0.646804</span>  <span class="pl-c1">1.0</span></pre></div>
</article></div>