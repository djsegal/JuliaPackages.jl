<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-diffeqapproxfunjl" class="anchor" aria-hidden="true" href="#diffeqapproxfunjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DiffEqApproxFun.jl</h1>
<p><a href="https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" rel="nofollow"><img src="https://camo.githubusercontent.com/063a520f1733d1b53d1e2fdb37b70a8016dd36f6/68747470733a2f2f6261646765732e6769747465722e696d2f4a756c69614469666645712f4c6f6262792e737667" alt="Join the chat at https://gitter.im/JuliaDiffEq/Lobby" data-canonical-src="https://badges.gitter.im/JuliaDiffEq/Lobby.svg" style="max-width:100%;"></a></p>
<p><a href="https://travis-ci.org/JuliaDiffEq/DiffEqApproxFun.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c402996bb69ac64acb900e469e997b5be28c442a/68747470733a2f2f7472617669732d63692e6f72672f4a756c69614469666645712f446966664571417070726f7846756e2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaDiffEq/DiffEqApproxFun.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/ChrisRackauckas/diffeqapproxfun-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/9e5584ccf44bd90b7afd5afdf066d842e7a71093/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f3969346c6762757277667930386177673f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/9i4lgburwfy08awg?svg=true" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/JuliaDiffEq/DiffEqApproxFun.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/6832c4ce09bdcc00b89634bf6d889c4c56b7e7bc/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f4a756c69614469666645712f446966664571417070726f7846756e2e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/JuliaDiffEq/DiffEqApproxFun.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a>
<a href="http://codecov.io/github/JuliaDiffEq/DiffEqApproxFun.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/66cd40e3fa0ba9f89bf9d9354e376d1241e302ef/687474703a2f2f636f6465636f762e696f2f6769746875622f4a756c69614469666645712f446966664571417070726f7846756e2e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/JuliaDiffEq/DiffEqApproxFun.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p><a href="http://pkg.julialang.org/?pkg=DiffEqApproxFun" rel="nofollow"><img src="https://camo.githubusercontent.com/7646cdc50d6e303afc81104052821bf8e6b6d498/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f446966664571417070726f7846756e5f302e362e737667" alt="DiffEqApproxFun" data-canonical-src="http://pkg.julialang.org/badges/DiffEqApproxFun_0.6.svg" style="max-width:100%;"></a></p>
<p>DiffEqApproxFun.jl is a component package in the DifferentialEquations ecosystem. It holds the components for solving differential equations using spectral methods defined by types from ApproxFun.jl. Users interested in using this functionality should check out <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p>
<h3><a id="user-content-this-repository-has-been-deprecated-there-are-better-ways-to-do-this" class="anchor" aria-hidden="true" href="#this-repository-has-been-deprecated-there-are-better-ways-to-do-this"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>This repository has been deprecated. There are better ways to do this.</h3>
<h2><a id="user-content-usage-examples" class="anchor" aria-hidden="true" href="#usage-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage Examples</h2>
<h3><a id="user-content-indirect-approxfuns" class="anchor" aria-hidden="true" href="#indirect-approxfuns"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Indirect ApproxFuns</h3>
<p>The indirect ApproxFun interface allows one to define an <code>ODEProblem</code> directly from ApproxFun expressions. It will automatically convert this into a spectral ODE problem where the vector is the spectral coefficients. The pro for this method is that it can be used with any ODE solver on the common interface such as Sundials. However, this method uses a constant number of coefficients and truncates the expansions given by ApproxFun to always match this size and so it's a little bit wasteful. But this presents itself as one of the easiest ways to solve a spectral discretization of a PDE.</p>
<p>To define such a problem, we first need to define our inital condition as a <code>Fun</code> type:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> DiffEqApproxFun
S<span class="pl-k">=</span><span class="pl-c1">Fourier</span>()
u0<span class="pl-k">=</span><span class="pl-c1">Fun</span>(θ<span class="pl-k">-&gt;</span><span class="pl-c1">cos</span>(<span class="pl-c1">cos</span>(θ<span class="pl-k">-</span><span class="pl-c1">0.1</span>))<span class="pl-k">-</span><span class="pl-c1">cos</span>(<span class="pl-c1">cos</span>(<span class="pl-c1">0</span><span class="pl-k">-</span><span class="pl-c1">0.1</span>)),S)</pre></div>
<p>Now let's define our ODE which takes in <code>Fun</code> types and spits out new <code>Fun</code>s:</p>
<div class="highlight highlight-source-julia"><pre>c<span class="pl-k">=</span><span class="pl-c1">Fun</span>(cos,S)
ode_prob <span class="pl-k">=</span> <span class="pl-c1">ODEProblem</span>((u,p,t)<span class="pl-k">-&gt;</span>u<span class="pl-k">''</span><span class="pl-k">+</span>(c<span class="pl-k">+</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>u<span class="pl-k">'</span>,u0,(<span class="pl-c1">0.</span>,<span class="pl-c1">1.</span>))</pre></div>
<p>To turn this into an indirect ApproxFun problem, we use the <code>ApproxFunProblem</code> wrapper:</p>
<div class="highlight highlight-source-julia"><pre>prob <span class="pl-k">=</span> <span class="pl-c1">ApproxFunProblem</span>(ode_prob)</pre></div>
<p>We can now solve this using any solver:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> OrdinaryDiffEq
sol<span class="pl-k">=</span><span class="pl-c1">solve</span>(prob,<span class="pl-c1">Tsit5</span>()) <span class="pl-c"><span class="pl-c">#</span> OrdinaryDiffEq.jl</span>
<span class="pl-k">using</span> Sundials
sol<span class="pl-k">=</span><span class="pl-c1">solve</span>(prob,<span class="pl-c1">CVODE_BDF</span>()) <span class="pl-c"><span class="pl-c">#</span> Sundials.jl</span>
<span class="pl-k">using</span> ODEInterfaceDiffEq
sol<span class="pl-k">=</span><span class="pl-c1">solve</span>(prob,<span class="pl-c1">radau</span>()) <span class="pl-c"><span class="pl-c">#</span> ODEInterfaceDiffEq.jl</span></pre></div>
<p>The solution interface works on this output, so to grab the solution at the 5th timepoint we do <code>sol[5]</code> for <code>sol.t[5]</code>. Each solution is a <code>Fun</code> type, which we can evaluate. Thus we can get the value at <code>x=0.2</code> at time <code>sol.t[5]</code> via <code>sol[5](0.2)</code>. The interpolations generate their own Fun types, so the value of <code>x=0.2</code> at time <code>t=0.5</code> is calculated via <code>sol(0.5,0.2)</code>.</p>
<h3><a id="user-content-adding-boundary-conditions" class="anchor" aria-hidden="true" href="#adding-boundary-conditions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Adding Boundary Conditions</h3>
<p>Normally you will want to solve a PDE with non-trivial boundary conditions. If possible you should make your <code>Fun</code> discretization match the BCs. For example, this is done automatically when the BCs are periodic and the discretization is periodic. But this isn't always possible, in which case you will need to define a <code>bc</code> function which projects the solution at each step to satisfy the boundary conditions. For example, we can have Dirichlet conditions s.t. the solution must be zero at the endpoints of our interval in the problem above via:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">bc</span>(t,u)
  C<span class="pl-k">=</span><span class="pl-c1">eye</span>(S)[<span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">end</span>,:]
  tmp <span class="pl-k">=</span> [<span class="pl-c1">Evaluation</span>(<span class="pl-c1">0</span>);
         <span class="pl-c1">Evaluation</span>(<span class="pl-c1">2</span>π);
         C]<span class="pl-k">\</span>[<span class="pl-c1">0.</span>;<span class="pl-c1">0.</span>;u]
<span class="pl-k">end</span></pre></div>
<p>Then we can generate a callback via <code>BoundaryCallback</code> and have the solver utilize this callback. This requires a common interface solver which is compatible with the callback interface.</p>
<div class="highlight highlight-source-julia"><pre>boundary_projection <span class="pl-k">=</span> <span class="pl-c1">BoundaryCallback</span>(bc)
sol<span class="pl-k">=</span><span class="pl-c1">solve</span>(prob,<span class="pl-c1">Tsit5</span>(),callback<span class="pl-k">=</span>boundary_projection)</pre></div>
<p>The resulting solution satisfies the boundary conditions.</p>
<h3><a id="user-content-plotting" class="anchor" aria-hidden="true" href="#plotting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Plotting</h3>
<p>Note that <code>sol(0.5)</code> returns the interpolated <code>Fun</code> type at time <code>t=0.5</code>, and <code>Fun</code> types have their own plotting recipes. Thus you can plot the solution at snippets of time directly like <code>plot(sol(0.5))</code>. Example:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">plot</span>(sol[<span class="pl-c1">1</span>],labels<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>t=0.0<span class="pl-pds">"</span></span>) 
<span class="pl-c1">plot!</span>(<span class="pl-c1">sol</span>(<span class="pl-c1">0.5</span>),labels<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>t=0.5<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot!</span>(sol[<span class="pl-c1">end</span>],labels<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>t=1.0<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/1814174/29637284-8695de9a-8808-11e7-9f01-63809f72b4a9.png"><img src="https://user-images.githubusercontent.com/1814174/29637284-8695de9a-8808-11e7-9f01-63809f72b4a9.png" alt="Plot Example" style="max-width:100%;"></a></p>
<h2><a id="user-content-direct-approxfuns" class="anchor" aria-hidden="true" href="#direct-approxfuns"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Direct ApproxFuns</h2>
<p>The direct ApproxFun interface is simply using a <code>Fun</code> as an initial condition and a function on <code>Fun</code> types as the function in a standard <code>ODEProblem</code>. The <code>*DiffEq</code> solvers like OrdinaryDiffEq.jl will directly handle this as an adaptive-space spectral discretization of the PDE. However, care has to be taken since this can cause the number of coefficients to grow rapidly. One may need to use an L-stable integrator and change the linear solver which is used. This is still in development.</p>
</article></div>