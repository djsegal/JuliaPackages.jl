<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-jlrscore" class="anchor" aria-hidden="true" href="#jlrscore"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>JlrsCore</h1>
<p dir="auto">This package must be used in combination with the jlrs crate for the Rust programming language. It provides core functionality that jlrs depends on, can be used to generate Rust structs from Julia types, and generate Julia modules that have been (partially) implemented in Rust in combination with the <code>julia_module</code> macro from jlrs.</p>
<h2 dir="auto"><a id="user-content-reflect" class="anchor" aria-hidden="true" href="#reflect"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reflect</h2>
<p dir="auto">The functions defined in the <code>Reflect</code> module can be used to generate jlrs-compatible Rust implementations of Julia structs (layouts).</p>
<p dir="auto">Layouts can be generated for many structs, including structs with union fields, tuple fields, and type parameters. Layouts are recursively generated for all of a type's fields, and are always generated for the most general case; any provided type parameter is erased and included in the set of structs for which layouts are generated.</p>
<p dir="auto">Three things that are not supported are structs with union or tuple fields that depend on a type parameter (eg <code>struct SomeGenericStruct{T} a::Tuple{Int32, T} end</code> and <code>struct SomeGenericStruct{T} a::Union{Int32, T} end</code>), unions used as generic parameters (eg <code>SomeGenericStruct{Union{A,B}}</code>), and structs with atomic fields. An error is thrown in the first two cases, in the final case no layout is generated for the struct itself but wrappers for all of its dependencies will be generated.</p>
<p dir="auto">You can generate layouts by calling the <code>reflect</code> function with a <code>Vector</code> of types:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JlrsCore.Reflect

struct TypeA
    # ...fields
end

struct TypeB{T}
    # ...fields
end

...

layouts = reflect([TypeA, TypeB, ...]);

# Print layouts to standard output
println(layouts)

# Write layouts to file
open(&quot;julia_layouts.rs&quot;, &quot;w&quot;) do f
    write(f, layouts)
end"><pre><span class="pl-k">using</span> JlrsCore<span class="pl-k">.</span>Reflect

<span class="pl-k">struct</span> TypeA
    <span class="pl-c"><span class="pl-c">#</span> ...fields</span>
<span class="pl-k">end</span>

<span class="pl-k">struct</span> TypeB{T}
    <span class="pl-c"><span class="pl-c">#</span> ...fields</span>
<span class="pl-k">end</span>

<span class="pl-k">...</span>

layouts <span class="pl-k">=</span> <span class="pl-c1">reflect</span>([TypeA, TypeB, <span class="pl-k">...</span>]);

<span class="pl-c"><span class="pl-c">#</span> Print layouts to standard output</span>
<span class="pl-c1">println</span>(layouts)

<span class="pl-c"><span class="pl-c">#</span> Write layouts to file</span>
<span class="pl-c1">open</span>(<span class="pl-s"><span class="pl-pds">"</span>julia_layouts.rs<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>) <span class="pl-k">do</span> f
    <span class="pl-c1">write</span>(f, layouts)
<span class="pl-k">end</span></pre></div>
<p dir="auto">Layouts for types used as fields and type parameters are automatically generated. If you want or need to rename structs or their fields you can use <code>renamestruct!</code> and <code>renamefields!</code> as follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JlrsCore.Reflect

layouts = reflect([TypeA, TypeB, ...])
renamestruct!(layouts, TypeA, &quot;StructA&quot;)
renamefields!(layouts, TypeB, [:fielda =&gt; &quot;field_a&quot;, :fieldb =&gt; &quot;field_b&quot;])"><pre><span class="pl-k">using</span> JlrsCore<span class="pl-k">.</span>Reflect

layouts <span class="pl-k">=</span> <span class="pl-c1">reflect</span>([TypeA, TypeB, <span class="pl-k">...</span>])
<span class="pl-c1">renamestruct!</span>(layouts, TypeA, <span class="pl-s"><span class="pl-pds">"</span>StructA<span class="pl-pds">"</span></span>)
<span class="pl-c1">renamefields!</span>(layouts, TypeB, [<span class="pl-c1">:fielda</span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>field_a<span class="pl-pds">"</span></span>, <span class="pl-c1">:fieldb</span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>field_b<span class="pl-pds">"</span></span>])</pre></div>
<h2 dir="auto"><a id="user-content-wrap" class="anchor" aria-hidden="true" href="#wrap"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Wrap</h2>
<p dir="auto">The macros defined in the <code>Wrap</code> module can be used to make the items exported by the <code>julia_module</code> macro available.</p>
<p dir="auto">For example, let's say you have a crate called example that uses <code>julia_module</code> to generate an initialization function called <code>module_init_fn</code>:</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia_module! {
    become module_init_fn;
    // ...exported items
    // See the documentation for `julia_module` in the jlrs docs for more information about
    // what can be exported from Rust to Julia and how.
}"><pre><span class="pl-en">julia_module</span><span class="pl-en">!</span> <span class="pl-kos">{</span>
    become module_init_fn;
    <span class="pl-c">// ...exported items</span>
    <span class="pl-c">// See the documentation for `julia_module` in the jlrs docs for more information about</span>
    <span class="pl-c">// what can be exported from Rust to Julia and how.</span>
<span class="pl-kos">}</span></pre></div>
<p dir="auto">After the crate has been built (NB: the crate type must have been set to <code>cdylib</code> to build a shared library that can be used by Julia), the <code>@wrapmodule</code> and <code>@initjlrs</code> macros can be used to make the exported items available in Julia:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module Example
using JlrsCore.Wrap

@wrapmodule(&quot;../relative/path/to/libexample&quot;, :module_init_fn)

function __init__()
  @initjlrs
end
end"><pre><span class="pl-k">module</span> Example
<span class="pl-k">using</span> JlrsCore<span class="pl-k">.</span>Wrap

<span class="pl-c1">@wrapmodule</span>(<span class="pl-s"><span class="pl-pds">"</span>../relative/path/to/libexample<span class="pl-pds">"</span></span>, <span class="pl-c1">:module_init_fn</span>)

<span class="pl-k">function</span> <span class="pl-en">__init__</span>()
  <span class="pl-c1">@initjlrs</span>
<span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
</article></div>