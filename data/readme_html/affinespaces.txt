<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-affinespacesjl" class="anchor" aria-hidden="true" href="#affinespacesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AffineSpaces.jl</h1>
<p>This library provides a simple, general way of dealing with affine subspaces, and it's implemented entirely in Julia. Affine subspaces are familiar objects like points, lines, planes, etc., as well as more exotic objects like hyperplanes and so on. Using this library, you can represent and manipulate objects like this easily.</p>
<h3><a id="user-content-what-is-it-good-for" class="anchor" aria-hidden="true" href="#what-is-it-good-for"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is it good for?</h3>
<p>Often we want to do things like calculate plane-line intersections, or plane-plane intersections, or find the plane that passes through a line and a point, or find the distance from a point to a line in 3d, and lots of other geometric operations. There are countless Q&amp;As on stackoverflow dealing with each of these special cases. But unforunately the code is usually very specific and not generalizable. It's also not guaranteed to work for all special cases (if planes are parallel, for example) and might be numerically unstable. For example, the intersection of three planes (in 3d) might return a point, a line, a plane, or nothing at all, and our code needs to be able to reflect this.</p>
<p>This kind of complexity and confusion is where this library comes in: You can do all these computational geometry operations and more in a way that's guaranteed to be mathematically correct. And it's all done through a unified interface - no special cases.</p>
<h3><a id="user-content-so-how-do-i-use-it" class="anchor" aria-hidden="true" href="#so-how-do-i-use-it"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>So how do I use it?</h3>
<p>First, let's go through what an affine subspace is. An affine subspace is built upon the notion of a <em>vector space</em>. In mathematics, vector spaces can be defined in a lot of different ways, but here we're going to stick to a very simple way of defining them. We're simply going to define vector spaces as <em>linear combinations</em> of <em>basis vectors</em>. So for example, if you have a basis vector <code>[1,0,0]</code>, the vector space <em>generated</em> by this basis vector includes all vectors <code>a*[1,0,0]</code> where <code>a</code> is a real number, so it would be all vectors of the form <code>[a,0,0]</code>. If you have two basis vectors, say <code>[1,0,0]</code> (as before) and <code>[1/2,1,0]</code>, now your vector space consists of all vectors <code>a*[1,0,0] + b*[1/2,1,0]</code>, where both <code>a</code> and <code>b</code> are real numbers. So they would look like: <code>[a+b/2,b,0]</code>. In AffineSpaces.jl, we would define this vector space as follows:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">VectorSpace</span>([<span class="pl-c1">1</span> <span class="pl-c1">0.5</span>
             <span class="pl-c1">0</span>  <span class="pl-c1">1</span>
             <span class="pl-c1">0</span>  <span class="pl-c1">0</span>])</pre></div>
<p>That is, by giving the basis <em>matrix</em> as the argument to the constructor.</p>
<p>You can see that by manipulating basis vectors, you can generate lines (one basis vector), planes (two basis vectors), and so on.</p>
<h3><a id="user-content-affine-subspaces" class="anchor" aria-hidden="true" href="#affine-subspaces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Affine Subspaces</h3>
<p>Affine subspaces are simply vector spaces plus some offset. The vector spaces we defined had to pass through the origin - they all had to have <code>[0,0,0]</code> in the space. This puts a limitation on the kinds of lines and planes we can represent. Affine subspaces don't need to pass through the origin. For example, here is the line y=1 in 2d:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> first define the vector space as the y axis (passing through the origin).</span>
v <span class="pl-k">=</span> <span class="pl-c1">VectorSpace</span>([<span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span>]')
<span class="pl-c"><span class="pl-c">#</span> now offset it by 1.</span>
as <span class="pl-k">=</span> <span class="pl-c1">AffineSpace</span>(v,[<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>])</pre></div>
<p>You can show that with this simple formalism, any kind of point, line, plane, hyperplane, etc. can be represented.</p>
<h3><a id="user-content-operations" class="anchor" aria-hidden="true" href="#operations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operations</h3>
<h4><a id="user-content-distance" class="anchor" aria-hidden="true" href="#distance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Distance</h4>
<p>In AffineSpaces.jl, all affine subspace operations can be done between any two affine spaces. The distance between two affine spaces, for example, can be calculated easily:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">dist_affine</span>(affinesubspace1, affinesubspace2)</pre></div>
<p>And this works no matter what the two affine subspaces are. You can use it to calculate, for example, the distance between two points, a plane and a point, or two parallel planes. The only restriction is that the two subspaces inhabit the same space i.e. they both inhabit 2d or 3d space. But that's it. If the two affine subspaces intersect, the distance returned will simply be zero.</p>
<p>The fact that this function is so general is even more interesting when you look at the implementation of the function:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">function</span> <span class="pl-en">dist_affine</span><span class="pl-c1">{T,N}</span>(as1<span class="pl-k">::</span><span class="pl-c1">AffineSpace{T,N}</span>,as2<span class="pl-k">::</span><span class="pl-c1">AffineSpace{T,N}</span>)
	v <span class="pl-k">=</span> as1<span class="pl-k">.</span>v <span class="pl-k">∪</span> as2<span class="pl-k">.</span>v
	C <span class="pl-k">=</span> <span class="pl-c1">ortho</span>(v)<span class="pl-k">.</span>basis
	<span class="pl-c1">norm</span>(C<span class="pl-k">*</span>(C<span class="pl-k">\</span>(as2<span class="pl-k">.</span>x0 <span class="pl-k">-</span> as1<span class="pl-k">.</span>x0)))
<span class="pl-k">end</span>
<span class="pl-en">ortho</span><span class="pl-c1">{T,N}</span>(v<span class="pl-k">::</span><span class="pl-c1">VectorSpace{T,N}</span>) <span class="pl-k">=</span>
    <span class="pl-c1">VectorSpace</span><span class="pl-c1">{T,N}</span>(<span class="pl-c1">nullspace</span>(v<span class="pl-k">.</span>basis<span class="pl-k">'</span>))</pre></div>
<p>This is the power of working with a general affine subspace structure - very general calculations can be performed in a simple way.</p>
<h4><a id="user-content-generated-subspaces" class="anchor" aria-hidden="true" href="#generated-subspaces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generated subspaces</h4>
<p><code>generated_space</code> is the function that takes two affine subspaces and produces the <em>smallest</em> affine subspace that <em>includes</em> both. So for instance, we can calculate the line that passes through two points:</p>
<div class="highlight highlight-source-julia"><pre>line <span class="pl-k">=</span> <span class="pl-c1">generated_space</span>(point1, point2)</pre></div>
<p>If the two points are coincident, it won't throw an error - it will just return the point, as it should.</p>
<p>Another example: the plane that passes through a point and a line:</p>
<div class="highlight highlight-source-julia"><pre>plane <span class="pl-k">=</span> <span class="pl-c1">generated_space</span>(line, point3)</pre></div>
<p>Again, if the point lies on the line, it will just return the line. If <code>line</code> isn't a line, as we think, but is instead a point (for example, if it was returned from a previous operation), then it will return the line that goes through both points. In this way, in AffineSpaces.jl you don't have to worry about what your geometric objects are and you don't need to worry about writing special case code for them. Everything 'just works'.</p>
<h4><a id="user-content-intersections" class="anchor" aria-hidden="true" href="#intersections"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Intersections</h4>
<p>The following function can be used to calculate affine subspace intersections. The intersection is the largest affine subspace that is included in both.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">intersect</span>(affinesubspace1, affinesubspace2)</pre></div>
<h3><a id="user-content-solid-geometry" class="anchor" aria-hidden="true" href="#solid-geometry"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solid Geometry</h3>
<p>AffineSpaces.jl contains a set of functions for performing <em>solid geometry</em> - the geometry of volumes including n-dimensional polyhedra. These are described below.</p>
<h4><a id="user-content-half-spaces" class="anchor" aria-hidden="true" href="#half-spaces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Half-spaces</h4>
<p>The simplest volume is the entire R<sup>n</sup> space. We can represent this space using basis vectors, as mentioned. However, R<sup>n</sup> by itself is not that interesting. It becomes more interesting when we introduce the notion of <em>half-spaces</em>. Half-spaces are produced when we take an n-dimensional space and divide it into parts using a <em>hyperplane</em> (an affine subspace of dimension n-1). For example, we can divide the 2D plane into two parts with a line, or a 3D space into two parts with a plane. Mathematically, we can represent a half-space of dimension n as follows. Let <strong>a</strong> be a normal vector of dimension n, and <em>b</em> be a real number. Then all points <strong>x</strong> in the space that satisfy:</p>
<p><strong>a</strong><sup>T</sup><strong>x</strong> &gt; b</p>
<p>Or, if it's a <em>closed</em> half-space:</p>
<p><strong>a</strong><sup>T</sup><strong>x</strong> ≥ b</p>
<p>Together form a half-space. To create a half-space in AffineSpaces.jl, we simply input <strong>a</strong> and <em>b</em>, for example here's a 3D half-space:</p>
<div class="highlight highlight-source-julia"><pre>hs <span class="pl-k">=</span> <span class="pl-c1">HalfSpace</span><span class="pl-c1">{Float64,3}</span>([<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>],<span class="pl-c1">5.0</span>,<span class="pl-c1">true</span>)</pre></div>
<p>The first parameter is the normal vector, the second parameter is the offset, and the final parameter specifies if the half-space is closed or not.</p>
<h4><a id="user-content-convex-polyhedra" class="anchor" aria-hidden="true" href="#convex-polyhedra"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Convex polyhedra</h4>
<p>Now that we have a notion of half-spaces, we can combine them together via <em>intersections</em>, using the function <code>inter()</code>. Half-spaces are convex spaces. The intersection of any two convex spaces is also a convex space, so the intersection of any number of half-spaces is also a convex space. Indeed, you can show that <em>any</em> convex space/polyhedron can be formed via an intersection of half-spaces. This idea forms the basis of <a href="https://en.wikipedia.org/wiki/Nef_polygon" rel="nofollow">Nef polyhedron theory</a>, and gives us a simple mathematical formalism for dealing with convex polyhedra.</p>
<p>In addition, if you take an affine subspace of dimension <em>m</em> &lt; <em>n</em>, and compute its intersection with a convex space of dimension <em>n</em>, you get a convex space of dimension <em>m</em>. This is very useful for, for example, computing ray-polyhedron intersections for various rendering/physics simulations. In AffineSpaces.jl, the function that performs this intersection is:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">section</span>(halfspace, affinesubspace)</pre></div>
<p>AffineSpaces.jl provides the functions</p>
<p>There are many more functions in AffineSpaces.jl. Look at test/ and src/ for the various functions that are available.</p>
</article></div>