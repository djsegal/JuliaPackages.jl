<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="doc/src/assets/logo.png"><img src="doc/src/assets/logo.png" alt="SpinMC.jl" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/fbuessen/SpinMC.jl/actions/workflows/runtests.yml"><img src="https://github.com/fbuessen/SpinMC.jl/actions/workflows/runtests.yml/badge.svg" alt="" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/fbuessen/SpinMC.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/0d594c00a88959d033317440a47e3dc3add00dcf225f250bcaef4a732f869537/68747470733a2f2f636f6465636f762e696f2f67682f666275657373656e2f5370696e4d432e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d4b47574c37314b483846" alt="codecov" data-canonical-src="https://codecov.io/gh/fbuessen/SpinMC.jl/branch/master/graph/badge.svg?token=KGWL71KH8F" style="max-width: 100%;"></a></p>
<p dir="auto">The package SpinMC.jl provides a flexible Markov chain Monte Carlo implementation for classical lattice spin models.
It is suitable to simulate microscopic spin models which are described by a Hamiltonian of the form</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="doc/src/assets/hamiltonian.png"><img src="doc/src/assets/hamiltonian.png" alt="" style="max-width: 100%;"></a></p>
<p dir="auto">Throughout the simulation, measurements of the energy density, the specific heat, the absolute value of the magnetization, and the spin correlations are performed.
The statistical evaluation of measurements is based on the <a href="https://github.com/crstnbr/BinningAnalysis.jl">BinningAnalysis.jl</a> package.</p>
<p dir="auto">The model Hamiltonian of classical O(3) spins can be defined on arbitrary D-dimensional lattices, whose efficient representation is automatically constructed from a customizable lattice unit cell, employing periodic boundary conditions.</p>
<p dir="auto">The implementation further leverages <a href="https://github.com/JuliaParallel/MPI.jl">MPI</a> to enable the parallel simulation of multiple replicas of the original system at different temperatures in the spirit of the <a href="https://arxiv.org/abs/cond-mat/9512035" rel="nofollow">parallel tempering</a> algorithm, thereby allowing for much faster convergence of the results.</p>
<p dir="auto">The SpinMC.jl package can be installed by invoking the following command in the Julia REPL:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="] add https://github.com/fbuessen/SpinMC.jl"><pre>] add https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>fbuessen<span class="pl-k">/</span>SpinMC<span class="pl-k">.</span>jl</pre></div>
<h2 dir="auto"><a id="user-content-define-a-lattice-spin-model" class="anchor" aria-hidden="true" href="#define-a-lattice-spin-model"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Define a lattice spin model</h2>
<p dir="auto">We illustrate the setup of a two-dimensional honeycomb lattice with antiferromagnetic nearest-neighbor Heisenberg interactions.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SpinMC

# Create the lattice unit cell from the primitive lattice vectors a1 and a2.
a1 = (3/2, sqrt(3)/2)
a2 = (3/2, -sqrt(3)/2)
uc = UnitCell(a1,a2) 

# Add two basis sites to the unit cell at positions (0,0) and (1,0), respectively. 
b1 = addBasisSite!(uc, (0.0, 0.0))
b2 = addBasisSite!(uc, (1.0, 0.0)) 

# Add antiferromagnetic Heisenberg interactions between nearest neighbors.
M = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0] # Heisenberg interaction matrix
addInteraction!(uc, b1, b2, M, (0, 0)) # Interaction of basis site b1 with site b2 in the same unit cell
addInteraction!(uc, b1, b2, M, (-1, 0)) # Interaction of basis site b1 with site b2 in the unit cell shifted by (-1, 0) lattice vectors.
addInteraction!(uc, b1, b2, M, (0, -1)) # Interaction of basis site b1 with site b2 in the unit cell shifted by (0, -1) lattice vectors.
#setField!(uc, b1, [1.0, 1.0, 1.0]) # Optionally apply a magnetic field B=(1,1,1) to basis site b1. 

# Generate a lattice of 16*16 unit cells. 
L = (16, 16)
lattice = Lattice(uc, L)"><pre><span class="pl-k">using</span> SpinMC

<span class="pl-c"><span class="pl-c">#</span> Create the lattice unit cell from the primitive lattice vectors a1 and a2.</span>
a1 <span class="pl-k">=</span> (<span class="pl-c1">3</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-c1">sqrt</span>(<span class="pl-c1">3</span>)<span class="pl-k">/</span><span class="pl-c1">2</span>)
a2 <span class="pl-k">=</span> (<span class="pl-c1">3</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">3</span>)<span class="pl-k">/</span><span class="pl-c1">2</span>)
uc <span class="pl-k">=</span> <span class="pl-c1">UnitCell</span>(a1,a2) 

<span class="pl-c"><span class="pl-c">#</span> Add two basis sites to the unit cell at positions (0,0) and (1,0), respectively. </span>
b1 <span class="pl-k">=</span> <span class="pl-c1">addBasisSite!</span>(uc, (<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>))
b2 <span class="pl-k">=</span> <span class="pl-c1">addBasisSite!</span>(uc, (<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>)) 

<span class="pl-c"><span class="pl-c">#</span> Add antiferromagnetic Heisenberg interactions between nearest neighbors.</span>
M <span class="pl-k">=</span> [<span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span>] <span class="pl-c"><span class="pl-c">#</span> Heisenberg interaction matrix</span>
<span class="pl-c1">addInteraction!</span>(uc, b1, b2, M, (<span class="pl-c1">0</span>, <span class="pl-c1">0</span>)) <span class="pl-c"><span class="pl-c">#</span> Interaction of basis site b1 with site b2 in the same unit cell</span>
<span class="pl-c1">addInteraction!</span>(uc, b1, b2, M, (<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>)) <span class="pl-c"><span class="pl-c">#</span> Interaction of basis site b1 with site b2 in the unit cell shifted by (-1, 0) lattice vectors.</span>
<span class="pl-c1">addInteraction!</span>(uc, b1, b2, M, (<span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-c"><span class="pl-c">#</span> Interaction of basis site b1 with site b2 in the unit cell shifted by (0, -1) lattice vectors.</span>
<span class="pl-c"><span class="pl-c">#</span>setField!(uc, b1, [1.0, 1.0, 1.0]) # Optionally apply a magnetic field B=(1,1,1) to basis site b1. </span>

<span class="pl-c"><span class="pl-c">#</span> Generate a lattice of 16*16 unit cells. </span>
L <span class="pl-k">=</span> (<span class="pl-c1">16</span>, <span class="pl-c1">16</span>)
lattice <span class="pl-k">=</span> <span class="pl-c1">Lattice</span>(uc, L)</pre></div>
<p dir="auto">Note that the interactions, which are added to the unit cell by means of the <code>addInteraction!</code> function are directed from basis site <code>b1</code> to basis site <code>b2</code>. It is thus straight-forward to implement e.g. antisymmetric <a href="https://en.wikipedia.org/wiki/Antisymmetric_exchange" rel="nofollow">Dzyaloshinskii–Moriya</a> interactions.
Similarly, since the interactions are defined individually for every pair of lattice sites, it is readily possible to implement e.g. bond-directional <a href="https://arxiv.org/abs/cond-mat/0506438" rel="nofollow">Kitaev</a> exchange.</p>
<p dir="auto">The lattice is constructed by repeating the unit cell, including all basis sites and lattice bonds.
<strong>The bonds should be defined such that double counting is avoided</strong>.
For example, in the case of the honeycomb lattice, we obly define three nearest neighbor bonds, despite the unit cell having two basis sites with three nearest neighbors each.
Similarly, for a cubic lattice (see example section below), we define three nearest neighbor bonds despite each lattice site having six nearest neighbors.</p>
<h2 dir="auto"><a id="user-content-launch-a-monte-carlo-simulation" class="anchor" aria-hidden="true" href="#launch-a-monte-carlo-simulation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Launch a Monte Carlo simulation</h2>
<p dir="auto">With the lattice object created above, we are now ready to launch the Monte Carlo simulation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Define simulation parameters
thermalizationSweeps = 50000 # Number of sweeps to thermalize the system. 
measurementSweeps = 50000 # Number of sweeps after thermalization to perform measurements.
beta = 10.0 #inverse temperature

# Create and run simulation
m = MonteCarlo(lattice, beta, thermalizationSweeps, measurementSweeps)
run!(m, outfile=&quot;simulation.h5&quot;) # Run simulation and write result file &quot;simulation.h5&quot;. "><pre><span class="pl-c"><span class="pl-c">#</span> Define simulation parameters</span>
thermalizationSweeps <span class="pl-k">=</span> <span class="pl-c1">50000</span> <span class="pl-c"><span class="pl-c">#</span> Number of sweeps to thermalize the system. </span>
measurementSweeps <span class="pl-k">=</span> <span class="pl-c1">50000</span> <span class="pl-c"><span class="pl-c">#</span> Number of sweeps after thermalization to perform measurements.</span>
beta <span class="pl-k">=</span> <span class="pl-c1">10.0</span> <span class="pl-c"><span class="pl-c">#</span>inverse temperature</span>

<span class="pl-c"><span class="pl-c">#</span> Create and run simulation</span>
m <span class="pl-k">=</span> <span class="pl-c1">MonteCarlo</span>(lattice, beta, thermalizationSweeps, measurementSweeps)
<span class="pl-c1">run!</span>(m, outfile<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>simulation.h5<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span> Run simulation and write result file "simulation.h5". </span></pre></div>
<p dir="auto">The MonteCarlo constructor further accepts the following kwargs:</p>
<ul dir="auto">
<li><code>measurementRate</code>: After thermalization, perform measurements at the specified rate, in units of sweeps (default: 1).</li>
<li><code>reportInterval</code>: Rate at which to print progress to the terminal, in units of sweeps (default: 1/20 of the total number of sweeps).</li>
<li><code>checkpointInterval</code>: Interval at which to write checkpoints to disk, in units of seconds (default: 3600).</li>
<li><code>rng</code>: Random number generator to use (default: copy of Random.GLOBAL_RNG).</li>
<li><code>seed</code>: Seed for the random number generator (default: Random.RandomDevice()).</li>
<li><code>replicaExchangeRate</code>: Rate at which to attempt replica exchanges in MPI mode (default: 10), see below.</li>
</ul>
<p dir="auto">The code example above would write progress reports to the terminal, similar to the following:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Simulation started on 02 Apr 2021 19:57:11.

Sweep 5000 / 100000 (5.0%)              ETA : 02 Apr 2021 19:57:14
                thermalized : NO
                sweep rate : 37878.8 sweeps/s
                sweep duration : 0.026 ms
                update acceptance rate: 3.59%

Sweep 10000 / 100000 (10.0%)            ETA : 02 Apr 2021 19:57:13
                thermalized : NO
                sweep rate : 52631.6 sweeps/s
                sweep duration : 0.019 ms
                update acceptance rate: 3.50%

[...]"><pre lang="text" class="notranslate"><code>Simulation started on 02 Apr 2021 19:57:11.

Sweep 5000 / 100000 (5.0%)              ETA : 02 Apr 2021 19:57:14
                thermalized : NO
                sweep rate : 37878.8 sweeps/s
                sweep duration : 0.026 ms
                update acceptance rate: 3.59%

Sweep 10000 / 100000 (10.0%)            ETA : 02 Apr 2021 19:57:13
                thermalized : NO
                sweep rate : 52631.6 sweeps/s
                sweep duration : 0.019 ms
                update acceptance rate: 3.50%

[...]
</code></pre></div>
<h2 dir="auto"><a id="user-content-launch-multiple-replicas-of-monte-carlo-simulations-in-mpi-mode" class="anchor" aria-hidden="true" href="#launch-multiple-replicas-of-monte-carlo-simulations-in-mpi-mode"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Launch multiple replicas of Monte Carlo simulations in MPI mode</h2>
<p dir="auto">Alternatively, the Monte Carlo simulation can be launched in an MPI environment by executing Julia with the usual <code>mpirun</code> command.
When run in an MPI environment, i.e. <code>MPI.Init()</code> has been called prior to invoking the <code>run!()</code> command, the Monte Carlo simulation automatically performs replica exchanges of spin configurations between the simulations running on different MPI ranks.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Initialize MPI
using MPI
MPI.Initialized() || MPI.Init()
commSize = MPI.Comm_size(MPI.COMM_WORLD)
commRank = MPI.Comm_rank(MPI.COMM_WORLD)

# Define simulation parameters
thermalizationSweeps = 50000
measurementSweeps = 50000
tmin = 0.1
tmax = 10.0
beta = (commSize == 1) ? 1.0/tmin : 1.0 / (reverse([ tmax * (tmin / tmax)^(n/(commSize-1)) for n in 0:commSize-1 ])[commRank+1]) # Assign logarithmically spaced temperature points across the different MPI ranks

# Create and run simulation
m = MonteCarlo(lattice, beta, thermalizationSweeps, measurementSweeps, replicaExchangeRate=10) # Attempt replica exchanges every 10 sweeps
run!(m, outfile=&quot;simulation.h5&quot;) # In MPI mode, each rank creates a separate result file &quot;simulation.h5.RANK&quot;"><pre><span class="pl-c"><span class="pl-c">#</span> Initialize MPI</span>
<span class="pl-k">using</span> MPI
MPI<span class="pl-k">.</span><span class="pl-c1">Initialized</span>() <span class="pl-k">||</span> MPI<span class="pl-k">.</span><span class="pl-c1">Init</span>()
commSize <span class="pl-k">=</span> MPI<span class="pl-k">.</span><span class="pl-c1">Comm_size</span>(MPI<span class="pl-k">.</span>COMM_WORLD)
commRank <span class="pl-k">=</span> MPI<span class="pl-k">.</span><span class="pl-c1">Comm_rank</span>(MPI<span class="pl-k">.</span>COMM_WORLD)

<span class="pl-c"><span class="pl-c">#</span> Define simulation parameters</span>
thermalizationSweeps <span class="pl-k">=</span> <span class="pl-c1">50000</span>
measurementSweeps <span class="pl-k">=</span> <span class="pl-c1">50000</span>
tmin <span class="pl-k">=</span> <span class="pl-c1">0.1</span>
tmax <span class="pl-k">=</span> <span class="pl-c1">10.0</span>
beta <span class="pl-k">=</span> (commSize <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">?</span> <span class="pl-c1">1.0</span><span class="pl-k">/</span>tmin <span class="pl-k">:</span> <span class="pl-c1">1.0</span> <span class="pl-k">/</span> (<span class="pl-c1">reverse</span>([ tmax <span class="pl-k">*</span> (tmin <span class="pl-k">/</span> tmax)<span class="pl-k">^</span>(n<span class="pl-k">/</span>(commSize<span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">for</span> n <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">:</span>commSize<span class="pl-k">-</span><span class="pl-c1">1</span> ])[commRank<span class="pl-k">+</span><span class="pl-c1">1</span>]) <span class="pl-c"><span class="pl-c">#</span> Assign logarithmically spaced temperature points across the different MPI ranks</span>

<span class="pl-c"><span class="pl-c">#</span> Create and run simulation</span>
m <span class="pl-k">=</span> <span class="pl-c1">MonteCarlo</span>(lattice, beta, thermalizationSweeps, measurementSweeps, replicaExchangeRate<span class="pl-k">=</span><span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> Attempt replica exchanges every 10 sweeps</span>
<span class="pl-c1">run!</span>(m, outfile<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>simulation.h5<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span> In MPI mode, each rank creates a separate result file "simulation.h5.RANK"</span></pre></div>
<p dir="auto">The code example above would produce terminal output similar to the following:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Simulation started on 02 Apr 2021 20:00:44.

Sweep 5000 / 100000 (5.0%)              ETA : 02 Apr 2021 20:00:47
                thermalized : NO
                sweep rate : 33333.3 sweeps/s
                sweep duration : 0.030 ms
                simulation 0 update acceptance rate: 89.18%
                simulation 0 replica exchange acceptance rate : 65.60%
                simulation 1 update acceptance rate: 91.44%
                simulation 1 replica exchange acceptance rate : 67.20%
                simulation 2 update acceptance rate: 93.19%
                simulation 2 replica exchange acceptance rate : 73.60%
                simulation 3 update acceptance rate: 94.59%
                simulation 3 replica exchange acceptance rate : 78.40%

[...]"><pre lang="text" class="notranslate"><code>Simulation started on 02 Apr 2021 20:00:44.

Sweep 5000 / 100000 (5.0%)              ETA : 02 Apr 2021 20:00:47
                thermalized : NO
                sweep rate : 33333.3 sweeps/s
                sweep duration : 0.030 ms
                simulation 0 update acceptance rate: 89.18%
                simulation 0 replica exchange acceptance rate : 65.60%
                simulation 1 update acceptance rate: 91.44%
                simulation 1 replica exchange acceptance rate : 67.20%
                simulation 2 update acceptance rate: 93.19%
                simulation 2 replica exchange acceptance rate : 73.60%
                simulation 3 update acceptance rate: 94.59%
                simulation 3 replica exchange acceptance rate : 78.40%

[...]
</code></pre></div>
<h2 dir="auto"><a id="user-content-continue-or-extend-a-simulation" class="anchor" aria-hidden="true" href="#continue-or-extend-a-simulation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Continue or extend a simulation</h2>
<p dir="auto">The simulation periodically writes checkpoint files to save the progress.
If a simulation crashes, it can be resumed from the last checkpoint.
Similarly, the checkpoint of a completed simulation can be read, and the number of measurement sweeps extended to further improve the result.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Load MonteCarlo object from checkpoint file
m = readMonteCarlo(&quot;simulation.h5&quot;) 

#m.measurementSweeps = 100000 # If desired, increase the total number of sweeps to perform. 

# Resume calculation
run!(m, outfile=&quot;simulation.continued.h5&quot;) "><pre><span class="pl-c"><span class="pl-c">#</span> Load MonteCarlo object from checkpoint file</span>
m <span class="pl-k">=</span> <span class="pl-c1">readMonteCarlo</span>(<span class="pl-s"><span class="pl-pds">"</span>simulation.h5<span class="pl-pds">"</span></span>) 

<span class="pl-c"><span class="pl-c">#</span>m.measurementSweeps = 100000 # If desired, increase the total number of sweeps to perform. </span>

<span class="pl-c"><span class="pl-c">#</span> Resume calculation</span>
<span class="pl-c1">run!</span>(m, outfile<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>simulation.continued.h5<span class="pl-pds">"</span></span>) </pre></div>
<h2 dir="auto"><a id="user-content-access-results" class="anchor" aria-hidden="true" href="#access-results"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Access results</h2>
<p dir="auto">The output file, which is generated by the <code>run!</code> command, contains both binary checkpoint data and human readable measurement results.
It is written in the <a href="https://github.com/JuliaIO/HDF5.jl">HDF5</a> file format, with the measurement results found in the following locations:</p>
<ul dir="auto">
<li><code>mc/observables/energyDensity/mean</code>, <code>mc/observables/energyDensity/error</code>: Mean value and standard error of the energy density.</li>
<li><code>mc/observables/magnetization/mean</code>, <code>mc/observables/magnetization/error</code>: Mean value and standard error of the absolute value of the magnetization per lattice site.</li>
<li><code>mc/observables/correlation/mean</code>, <code>mc/observables/correlation/error</code>: Mean value and standard error of the spin correlations relative to basis sites (in matrix form, where the rows run over all lattice sites and the columns run over all basis sites).</li>
<li><code>mc/observables/specificHeat/mean</code>, <code>mc/observables/specificHeat/error</code>: Mean value and standard error of the specific heat capacity per spin.</li>
</ul>
<p dir="auto">Alternatively, after running a simulation, the results can be accessed interactively in the <code>m.observables.energy</code> (containing the energy density and its square value), <code>m.observables.magnetization</code>, and <code>m.observables.correlation</code> data structures, which are of types <code>ErrorPropagator</code> and <code>LogBinner</code>, respectively, as defined in the <a href="https://github.com/crstnbr/BinningAnalysis.jl">BinningAnalysis.jl</a> package.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<h3 dir="auto"><a id="user-content-specific-heat-and-magnetization-of-a-cubic-lattice-heisenberg-ferromagnet" class="anchor" aria-hidden="true" href="#specific-heat-and-magnetization-of-a-cubic-lattice-heisenberg-ferromagnet"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Specific heat and magnetization of a cubic lattice Heisenberg ferromagnet</h3>
<p dir="auto">Below, we provide a complete example to calculate the specific heat and magnetization of a Heisenberg ferromagnet on the cubic lattice as a function of temperature. For illustrative purposes, we calculate the different temperature points sequentially, instead of making use of the built-in MPI support for parallel simulations.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SpinMC

a1 = (1.0, 0.0, 0.0)
a2 = (0.0, 1.0, 0.0)
a3 = (0.0, 0.0, 1.0)
uc = UnitCell(a1,a2,a3)

b = addBasisSite!(uc, (0.0, 0.0, 0.0))
M = [-1.0 0.0 0.0; 0.0 -1.0 0.0; 0.0 0.0 -1.0]
addInteraction!(uc, b, b, M, (1, 0, 0))
addInteraction!(uc, b, b, M, (0, 1, 0))
addInteraction!(uc, b, b, M, (0, 0, 1))

L = (8, 8, 8)
lattice = Lattice(uc, L)
thermalizationSweeps = 10000
measurementSweeps = 100000

tmin = 0.1
tmax = 10.0
N = 32
temperature = zeros(N)
heat = zeros(N)
dheat = zeros(N)
magnetization = zeros(N)
dmagnetization = zeros(N)
for i in 1:N
    println(&quot;Performing MC simulation &quot;, i, &quot;/&quot;, N)
    beta = 1.0 / (tmax * (tmin / tmax)^((i-1)/(N-1)))
    m = MonteCarlo(lattice, beta, thermalizationSweeps, measurementSweeps, reportInterval=20000)
    run!(m)
    temperature[i] = 1.0 / beta

    # Calculate specific heat 
    # (Note that if file output is activated in the run!() call, the specific heat is automatically included.)
    c(e) = beta * beta * (e[2] - e[1] * e[1]) * length(m.lattice)
    ∇c(e) = [-2.0 * beta * beta * e[1] * length(m.lattice), beta * beta * length(m.lattice)]
    heat[i] = mean(m.observables.energy, c)
    dheat[i] = std_error(m.observables.energy, ∇c)
    # Calculate magnetization
    magnetization[i] = mean(m.observables.magnetization)
    dmagnetization[i] = std_error(m.observables.magnetization)
end

using Plots
display(plot(temperature, heat, yerror=dheat, xaxis=:log, yrange=(0.0,2.5), xrange=(0.1,10.0), xlabel=&quot;temperature&quot;, ylabel=&quot;specific heat&quot;, label=&quot;8*8*8 cubic lattice&quot;))
display(plot(temperature, magnetization, yerror=dmagnetization, xaxis=:log, yrange=(0.0,1.0), xrange=(0.1,10.0), xlabel=&quot;temperature&quot;, ylabel=&quot;magnetization&quot;, label=&quot;8*8*8 cubic lattice&quot;))"><pre><span class="pl-k">using</span> SpinMC

a1 <span class="pl-k">=</span> (<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>)
a2 <span class="pl-k">=</span> (<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>)
a3 <span class="pl-k">=</span> (<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)
uc <span class="pl-k">=</span> <span class="pl-c1">UnitCell</span>(a1,a2,a3)

b <span class="pl-k">=</span> <span class="pl-c1">addBasisSite!</span>(uc, (<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>))
M <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-k">-</span><span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-k">-</span><span class="pl-c1">1.0</span>]
<span class="pl-c1">addInteraction!</span>(uc, b, b, M, (<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>))
<span class="pl-c1">addInteraction!</span>(uc, b, b, M, (<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>))
<span class="pl-c1">addInteraction!</span>(uc, b, b, M, (<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>))

L <span class="pl-k">=</span> (<span class="pl-c1">8</span>, <span class="pl-c1">8</span>, <span class="pl-c1">8</span>)
lattice <span class="pl-k">=</span> <span class="pl-c1">Lattice</span>(uc, L)
thermalizationSweeps <span class="pl-k">=</span> <span class="pl-c1">10000</span>
measurementSweeps <span class="pl-k">=</span> <span class="pl-c1">100000</span>

tmin <span class="pl-k">=</span> <span class="pl-c1">0.1</span>
tmax <span class="pl-k">=</span> <span class="pl-c1">10.0</span>
N <span class="pl-k">=</span> <span class="pl-c1">32</span>
temperature <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(N)
heat <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(N)
dheat <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(N)
magnetization <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(N)
dmagnetization <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(N)
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Performing MC simulation <span class="pl-pds">"</span></span>, i, <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>, N)
    beta <span class="pl-k">=</span> <span class="pl-c1">1.0</span> <span class="pl-k">/</span> (tmax <span class="pl-k">*</span> (tmin <span class="pl-k">/</span> tmax)<span class="pl-k">^</span>((i<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">/</span>(N<span class="pl-k">-</span><span class="pl-c1">1</span>)))
    m <span class="pl-k">=</span> <span class="pl-c1">MonteCarlo</span>(lattice, beta, thermalizationSweeps, measurementSweeps, reportInterval<span class="pl-k">=</span><span class="pl-c1">20000</span>)
    <span class="pl-c1">run!</span>(m)
    temperature[i] <span class="pl-k">=</span> <span class="pl-c1">1.0</span> <span class="pl-k">/</span> beta

    <span class="pl-c"><span class="pl-c">#</span> Calculate specific heat </span>
    <span class="pl-c"><span class="pl-c">#</span> (Note that if file output is activated in the run!() call, the specific heat is automatically included.)</span>
    <span class="pl-en">c</span>(e) <span class="pl-k">=</span> beta <span class="pl-k">*</span> beta <span class="pl-k">*</span> (e[<span class="pl-c1">2</span>] <span class="pl-k">-</span> e[<span class="pl-c1">1</span>] <span class="pl-k">*</span> e[<span class="pl-c1">1</span>]) <span class="pl-k">*</span> <span class="pl-c1">length</span>(m<span class="pl-k">.</span>lattice)
    <span class="pl-en">∇c</span>(e) <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">2.0</span> <span class="pl-k">*</span> beta <span class="pl-k">*</span> beta <span class="pl-k">*</span> e[<span class="pl-c1">1</span>] <span class="pl-k">*</span> <span class="pl-c1">length</span>(m<span class="pl-k">.</span>lattice), beta <span class="pl-k">*</span> beta <span class="pl-k">*</span> <span class="pl-c1">length</span>(m<span class="pl-k">.</span>lattice)]
    heat[i] <span class="pl-k">=</span> <span class="pl-c1">mean</span>(m<span class="pl-k">.</span>observables<span class="pl-k">.</span>energy, c)
    dheat[i] <span class="pl-k">=</span> <span class="pl-c1">std_error</span>(m<span class="pl-k">.</span>observables<span class="pl-k">.</span>energy, ∇c)
    <span class="pl-c"><span class="pl-c">#</span> Calculate magnetization</span>
    magnetization[i] <span class="pl-k">=</span> <span class="pl-c1">mean</span>(m<span class="pl-k">.</span>observables<span class="pl-k">.</span>magnetization)
    dmagnetization[i] <span class="pl-k">=</span> <span class="pl-c1">std_error</span>(m<span class="pl-k">.</span>observables<span class="pl-k">.</span>magnetization)
<span class="pl-k">end</span>

<span class="pl-k">using</span> Plots
<span class="pl-c1">display</span>(<span class="pl-c1">plot</span>(temperature, heat, yerror<span class="pl-k">=</span>dheat, xaxis<span class="pl-k">=</span><span class="pl-c1">:log</span>, yrange<span class="pl-k">=</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">2.5</span>), xrange<span class="pl-k">=</span>(<span class="pl-c1">0.1</span>,<span class="pl-c1">10.0</span>), xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>temperature<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>specific heat<span class="pl-pds">"</span></span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>8*8*8 cubic lattice<span class="pl-pds">"</span></span>))
<span class="pl-c1">display</span>(<span class="pl-c1">plot</span>(temperature, magnetization, yerror<span class="pl-k">=</span>dmagnetization, xaxis<span class="pl-k">=</span><span class="pl-c1">:log</span>, yrange<span class="pl-k">=</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>), xrange<span class="pl-k">=</span>(<span class="pl-c1">0.1</span>,<span class="pl-c1">10.0</span>), xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>temperature<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>magnetization<span class="pl-pds">"</span></span>, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>8*8*8 cubic lattice<span class="pl-pds">"</span></span>))</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="doc/src/assets/plot_heat.png"><img src="doc/src/assets/plot_heat.png" alt="" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer" href="doc/src/assets/plot_magnetization.png"><img src="doc/src/assets/plot_magnetization.png" alt="" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-spin-structure-factor-of-a-honeycomb-lattice-heisenberg-antiferromagnet" class="anchor" aria-hidden="true" href="#spin-structure-factor-of-a-honeycomb-lattice-heisenberg-antiferromagnet"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Spin structure factor of a honeycomb lattice Heisenberg antiferromagnet</h3>
<p dir="auto">As a second example, we compute the ground state of the Heisenberg antiferromagnet on the honeycomb lattice.
The model is expected to host Neel order in the ground state, i.e. the spins on the two sublattices of the bipartite honeycomb lattice are aligned antiparallel.</p>
<p dir="auto">Long-range Neel order implies sharp peaks in the magnetic structure factor (i.e. the Fourier transformed spin correlations) on the corners of the extended Brillouin zone.
Note that due to the finite system size with periodic boundary conditions, only a finite set of points formally exists in momentum space. We'll ignore this for simplicity.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SpinMC
using LinearAlgebra

a1 = (3/2, sqrt(3)/2)
a2 = (3/2, -sqrt(3)/2)
uc = UnitCell(a1,a2)

b1 = addBasisSite!(uc, (0.0, 0.0))
b2 = addBasisSite!(uc, (1.0, 0.0))

M = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
addInteraction!(uc, b1, b2, M, (0, 0))
addInteraction!(uc, b1, b2, M, (0, -1))
addInteraction!(uc, b1, b2, M, (-1, 0))

L = (16, 16)
lattice = Lattice(uc, L)

thermalizationSweeps = 50000
measurementSweeps = 50000
beta = 10.0
m = MonteCarlo(lattice, beta, thermalizationSweeps, measurementSweeps)
run!(m)

# Fourier transform correlations to compute structure factor. 
N = 256
correlation = mean(m.observables.correlation) # The correlation is measured with respect to spins on the lattice basis sites, i.e. the (i,j)-th entry of the matrix is the correlation dot(S_i,S_j), where i runs over all lattice sites and j runs over all basis sites. 
kx = collect(range(-2pi,2pi,length=N))
ky = collect(range(-2pi,2pi,length=N))
structurefactor = zeros(N,N)
for i in 1:N
    for j in 1:N
        z = 0.0
        # Compute Fourier transformation at momentum (kx, ky). The real-space position of the i-th spin is obtained via getSitePosition(lattice,i). 
        for b in 1:length(lattice.unitcell.basis)
            for k in 1:length(lattice)
                z += cos(dot((kx[i],ky[j]),getSitePosition(lattice,k).-getSitePosition(lattice,b))) * correlation[k,b]
            end
        end
        structurefactor[j,i] = z / (length(lattice) * length(lattice.unitcell.basis))
    end
end

# Plot result
using Plots
heatmap(kx,ky,structurefactor,aspect_ratio=1,xrange=(-2pi,2pi),yrange=(-2pi,2pi),clims=(0,1),xlabel=&quot;kx&quot;, ylabel=&quot;ky&quot;)
xs = [4.0pi/3.0, 2.0pi/3.0, -2.0pi/3.0, -4.0pi/3.0, -2.0pi/3.0, 2.0pi/3.0, 4.0pi/3.0]
ys = [0.0, 2.0pi/sqrt(3.0), 2.0pi/sqrt(3.0), 0.0, -2.0pi/sqrt(3.0), -2.0pi/sqrt(3.0), 0.0]
plot!(xs, ys, label=&quot;Extended BZ&quot;)"><pre><span class="pl-k">using</span> SpinMC
<span class="pl-k">using</span> LinearAlgebra

a1 <span class="pl-k">=</span> (<span class="pl-c1">3</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-c1">sqrt</span>(<span class="pl-c1">3</span>)<span class="pl-k">/</span><span class="pl-c1">2</span>)
a2 <span class="pl-k">=</span> (<span class="pl-c1">3</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">3</span>)<span class="pl-k">/</span><span class="pl-c1">2</span>)
uc <span class="pl-k">=</span> <span class="pl-c1">UnitCell</span>(a1,a2)

b1 <span class="pl-k">=</span> <span class="pl-c1">addBasisSite!</span>(uc, (<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>))
b2 <span class="pl-k">=</span> <span class="pl-c1">addBasisSite!</span>(uc, (<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>))

M <span class="pl-k">=</span> [<span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span> <span class="pl-c1">0.0</span>; <span class="pl-c1">0.0</span> <span class="pl-c1">0.0</span> <span class="pl-c1">1.0</span>]
<span class="pl-c1">addInteraction!</span>(uc, b1, b2, M, (<span class="pl-c1">0</span>, <span class="pl-c1">0</span>))
<span class="pl-c1">addInteraction!</span>(uc, b1, b2, M, (<span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>))
<span class="pl-c1">addInteraction!</span>(uc, b1, b2, M, (<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>))

L <span class="pl-k">=</span> (<span class="pl-c1">16</span>, <span class="pl-c1">16</span>)
lattice <span class="pl-k">=</span> <span class="pl-c1">Lattice</span>(uc, L)

thermalizationSweeps <span class="pl-k">=</span> <span class="pl-c1">50000</span>
measurementSweeps <span class="pl-k">=</span> <span class="pl-c1">50000</span>
beta <span class="pl-k">=</span> <span class="pl-c1">10.0</span>
m <span class="pl-k">=</span> <span class="pl-c1">MonteCarlo</span>(lattice, beta, thermalizationSweeps, measurementSweeps)
<span class="pl-c1">run!</span>(m)

<span class="pl-c"><span class="pl-c">#</span> Fourier transform correlations to compute structure factor. </span>
N <span class="pl-k">=</span> <span class="pl-c1">256</span>
correlation <span class="pl-k">=</span> <span class="pl-c1">mean</span>(m<span class="pl-k">.</span>observables<span class="pl-k">.</span>correlation) <span class="pl-c"><span class="pl-c">#</span> The correlation is measured with respect to spins on the lattice basis sites, i.e. the (i,j)-th entry of the matrix is the correlation dot(S_i,S_j), where i runs over all lattice sites and j runs over all basis sites. </span>
kx <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2pi</span>,<span class="pl-c1">2pi</span>,length<span class="pl-k">=</span>N))
ky <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2pi</span>,<span class="pl-c1">2pi</span>,length<span class="pl-k">=</span>N))
structurefactor <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(N,N)
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
    <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        z <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
        <span class="pl-c"><span class="pl-c">#</span> Compute Fourier transformation at momentum (kx, ky). The real-space position of the i-th spin is obtained via getSitePosition(lattice,i). </span>
        <span class="pl-k">for</span> b <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(lattice<span class="pl-k">.</span>unitcell<span class="pl-k">.</span>basis)
            <span class="pl-k">for</span> k <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(lattice)
                z <span class="pl-k">+=</span> <span class="pl-c1">cos</span>(<span class="pl-c1">dot</span>((kx[i],ky[j]),<span class="pl-c1">getSitePosition</span>(lattice,k)<span class="pl-k">.-</span><span class="pl-c1">getSitePosition</span>(lattice,b))) <span class="pl-k">*</span> correlation[k,b]
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>
        structurefactor[j,i] <span class="pl-k">=</span> z <span class="pl-k">/</span> (<span class="pl-c1">length</span>(lattice) <span class="pl-k">*</span> <span class="pl-c1">length</span>(lattice<span class="pl-k">.</span>unitcell<span class="pl-k">.</span>basis))
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Plot result</span>
<span class="pl-k">using</span> Plots
<span class="pl-c1">heatmap</span>(kx,ky,structurefactor,aspect_ratio<span class="pl-k">=</span><span class="pl-c1">1</span>,xrange<span class="pl-k">=</span>(<span class="pl-k">-</span><span class="pl-c1">2pi</span>,<span class="pl-c1">2pi</span>),yrange<span class="pl-k">=</span>(<span class="pl-k">-</span><span class="pl-c1">2pi</span>,<span class="pl-c1">2pi</span>),clims<span class="pl-k">=</span>(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>),xlabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>kx<span class="pl-pds">"</span></span>, ylabel<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>ky<span class="pl-pds">"</span></span>)
xs <span class="pl-k">=</span> [<span class="pl-c1">4.0pi</span><span class="pl-k">/</span><span class="pl-c1">3.0</span>, <span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">3.0</span>, <span class="pl-k">-</span><span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">3.0</span>, <span class="pl-k">-</span><span class="pl-c1">4.0pi</span><span class="pl-k">/</span><span class="pl-c1">3.0</span>, <span class="pl-k">-</span><span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">3.0</span>, <span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">3.0</span>, <span class="pl-c1">4.0pi</span><span class="pl-k">/</span><span class="pl-c1">3.0</span>]
ys <span class="pl-k">=</span> [<span class="pl-c1">0.0</span>, <span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">3.0</span>), <span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">3.0</span>), <span class="pl-c1">0.0</span>, <span class="pl-k">-</span><span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">3.0</span>), <span class="pl-k">-</span><span class="pl-c1">2.0pi</span><span class="pl-k">/</span><span class="pl-c1">sqrt</span>(<span class="pl-c1">3.0</span>), <span class="pl-c1">0.0</span>]
<span class="pl-c1">plot!</span>(xs, ys, label<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Extended BZ<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="doc/src/assets/plot_structurefactor.png"><img src="doc/src/assets/plot_structurefactor.png" alt="" style="max-width: 100%;"></a></p>
</article></div>