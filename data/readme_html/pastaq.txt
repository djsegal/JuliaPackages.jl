<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="assets/readme_logo.png"><img src="assets/readme_logo.png" alt="alt text" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/GTorlai/PastaQ.jl/actions?query=workflow%3ATests"><img src="https://github.com/GTorlai/PastaQ.jl/workflows/Tests/badge.svg" alt="Tests" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/GTorlai/PastaQ.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/1be77e8c90bf9ddc4a2d47c05b06a917b203081af420d254001278dc8e6e93b7/68747470733a2f2f636f6465636f762e696f2f67682f47546f726c61692f5061737461512e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/GTorlai/PastaQ.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://gtorlai.github.io/PastaQ.jl/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://gtorlai.github.io/PastaQ.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://opensource.org/licenses/Apache-2.0" rel="nofollow"><img src="https://camo.githubusercontent.com/2a2157c971b7ae1deb8eb095799440551c33dcf61ea3d965d86b496a5a65df55/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d417061636865253230322e302d626c75652e737667" alt="License" data-canonical-src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" style="max-width: 100%;"></a>
<a href="https://www.pastaq.org/" rel="nofollow"><img src="https://camo.githubusercontent.com/d3fd52122bd5be0c76202c1ccd2e4cd439ba5a6424d207471c1dc6903ab0dd50/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f776562736974652d7061737461712e6f72672d6f72616e67652e737667" alt="website" data-canonical-src="https://img.shields.io/badge/website-pastaq.org-orange.svg" style="max-width: 100%;"></a>
<a href="https://arxiv.org/abs/" rel="nofollow"><img src="https://camo.githubusercontent.com/8f1f2a48d3cc954d21ece3026a294b42ca007bd839819df336ecdb2300423adc/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f61725869762d2d6233316231622e737667" alt="arXiv" data-canonical-src="https://img.shields.io/badge/arXiv--b31b1b.svg" style="max-width: 100%;"></a></p>
<p dir="auto">PLEASE NOTE THIS IS PRE-RELEASE SOFTWARE</p>
<h1 dir="auto"><a id="user-content-pastaqjl-design-and-benchmarking-quantum-hardware" class="anchor" aria-hidden="true" href="#pastaqjl-design-and-benchmarking-quantum-hardware"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PastaQ.jl: design and benchmarking quantum hardware</h1>
<p dir="auto">PastaQ.jl is a Julia software toolbox providing a range of computational methods for quantum computing applications. Some examples are the simulation of quancum circuits, the design of quantum gates, noise characterization and performance benchmarking. PastaQ relies on tensor-network representations of quantum states and processes, and borrows well-refined techniques from the field of machine learning and data science, such as probabilistic modeling and automatic differentiation.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="assets/readme_summary.jpg"><img src="assets/readme_summary.jpg" alt="alt text" style="max-width: 100%;"></a></p>
<hr>
<h2 dir="auto"><a id="user-content-install" class="anchor" aria-hidden="true" href="#install"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Install</h2>
<p dir="auto">The PastaQ package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; ]

pkg&gt; add PastaQ"><pre>julia<span class="pl-k">&gt;</span> ]

pkg<span class="pl-k">&gt;</span> add PastaQ</pre></div>
<p dir="auto">PastaQ.jl relies on the following packages: <a href="https://github.com/ITensor/ITensors.jl">ITensors.jl</a> for low-level tensor-network algorithms, <a href="https://github.com/FluxML/Optimisers.jl">Optimisers.jl</a> for stochastic optimization methods, <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> for automatic differentiation, and <a href="https://github.com/GTorlai/Observers.jl">Observers.jl</a> for tracking/recording metrics and observables. Please note that right now, PastaQ.jl requires that you use Julia v1.6 or later.</p>
<hr>
<h2 dir="auto"><a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Documentation</h2>
<ul dir="auto">
<li><a href="https://gtorlai.github.io/PastaQ.jl/stable/" rel="nofollow"><strong>STABLE</strong></a> --  <strong>documentation of the most recently tagged version.</strong></li>
<li><a href="https://gtorlai.github.io/PastaQ.jl/dev/" rel="nofollow"><strong>DEVEL</strong></a> -- <em>documentation of the in-development version.</em></li>
</ul>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">We briefly showcase some of the functionalities provided by PastaQ.jl. For more in-depth discussion, please refer to the tutorials folder.</p>
<h4 dir="auto"><a id="user-content-simulating-quantum-circuits" class="anchor" aria-hidden="true" href="#simulating-quantum-circuits"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simulating quantum circuits</h4>
<p dir="auto">The vast majority of tasks related to designing and benchmarking quantum computers relies on the capability of simulating quantum circuits, built out of a collection of elementary quantum gates. In PastaQ, a quantum gates is described by a data structure <code>g = ("gatename", support, params)</code>, consisting of a gate identifier <code>gatename</code> (a <code>String</code>), a <code>support</code> (an <code>Int</code> for single-qubit gates or a <code>Tuple</code> for multi-qubit gates), and a set of gate parameters, such as rotations angles, whenever needed. A comprehensive set of elementary gates is provided, including Pauli operations, phase and T gates, single-qubit rotations, controlled gates, Toffoli gate and others. Additional user-specific gates can be easily added to this collection. Once a circuit is defined, it can be executed using the <code>runcircuit</code> function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PastaQ

# a quantum circuit in PastaQ
gates = [(&quot;X&quot; , 1),                              # Pauli X on qubit 1
         (&quot;CX&quot;, (1, 3)),                         # Controlled-X on qubits [1,3]
         (&quot;Rx&quot;, 2, (θ = 0.5,)),                  # Rotation of θ around X
         (&quot;Rn&quot;, 3, (θ = 0.5, ϕ = 0.2, λ = 1.2)), # Arbitrary rotation with angles (θ,ϕ,λ)
         (&quot;√SWAP&quot;, (3, 4)),                      # Sqrt Swap on qubits [2,3]
         (&quot;T&quot; , 4)]                              # T gate on qubit 4
         
# run the circuit
ψ = runcircuit(gates)
# returns the MPS at the output of the quantum circuit: `|ψ⟩ = Û|0,0,…,0⟩`
# first the gate (&quot;X&quot; , 1) is applied, then (&quot;CX&quot;, (1, 3)), etc.

# ------------------------------------------------------------------
# Output:
#  ITensors.MPS
#  [1] ((dim=2|id=456|&quot;Qubit,Site,n=1&quot;), (dim=1|id=760|&quot;Link,n=1&quot;))
#  [2] ((dim=1|id=760|&quot;Link,n=1&quot;), (dim=2|id=613|&quot;Qubit,Site,n=2&quot;), (dim=1|id=362|&quot;Link,n=1&quot;))
#  [3] ((dim=2|id=9|&quot;Qubit,Site,n=3&quot;), (dim=2|id=357|&quot;Link,n=1&quot;), (dim=1|id=362|&quot;Link,n=1&quot;))
#  [4] ((dim=2|id=980|&quot;Qubit,Site,n=4&quot;), (dim=2|id=357|&quot;Link,n=1&quot;))"><pre><span class="pl-k">using</span> PastaQ

<span class="pl-c"><span class="pl-c">#</span> a quantum circuit in PastaQ</span>
gates <span class="pl-k">=</span> [(<span class="pl-s"><span class="pl-pds">"</span>X<span class="pl-pds">"</span></span> , <span class="pl-c1">1</span>),                              <span class="pl-c"><span class="pl-c">#</span> Pauli X on qubit 1</span>
         (<span class="pl-s"><span class="pl-pds">"</span>CX<span class="pl-pds">"</span></span>, (<span class="pl-c1">1</span>, <span class="pl-c1">3</span>)),                         <span class="pl-c"><span class="pl-c">#</span> Controlled-X on qubits [1,3]</span>
         (<span class="pl-s"><span class="pl-pds">"</span>Rx<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>, (θ <span class="pl-k">=</span> <span class="pl-c1">0.5</span>,)),                  <span class="pl-c"><span class="pl-c">#</span> Rotation of θ around X</span>
         (<span class="pl-s"><span class="pl-pds">"</span>Rn<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>, (θ <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, ϕ <span class="pl-k">=</span> <span class="pl-c1">0.2</span>, λ <span class="pl-k">=</span> <span class="pl-c1">1.2</span>)), <span class="pl-c"><span class="pl-c">#</span> Arbitrary rotation with angles (θ,ϕ,λ)</span>
         (<span class="pl-s"><span class="pl-pds">"</span>√SWAP<span class="pl-pds">"</span></span>, (<span class="pl-c1">3</span>, <span class="pl-c1">4</span>)),                      <span class="pl-c"><span class="pl-c">#</span> Sqrt Swap on qubits [2,3]</span>
         (<span class="pl-s"><span class="pl-pds">"</span>T<span class="pl-pds">"</span></span> , <span class="pl-c1">4</span>)]                              <span class="pl-c"><span class="pl-c">#</span> T gate on qubit 4</span>
         
<span class="pl-c"><span class="pl-c">#</span> run the circuit</span>
ψ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(gates)
<span class="pl-c"><span class="pl-c">#</span> returns the MPS at the output of the quantum circuit: `|ψ⟩ = Û|0,0,…,0⟩`</span>
<span class="pl-c"><span class="pl-c">#</span> first the gate ("X" , 1) is applied, then ("CX", (1, 3)), etc.</span>

<span class="pl-c"><span class="pl-c">#</span> ------------------------------------------------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> Output:</span>
<span class="pl-c"><span class="pl-c">#</span>  ITensors.MPS</span>
<span class="pl-c"><span class="pl-c">#</span>  [1] ((dim=2|id=456|"Qubit,Site,n=1"), (dim=1|id=760|"Link,n=1"))</span>
<span class="pl-c"><span class="pl-c">#</span>  [2] ((dim=1|id=760|"Link,n=1"), (dim=2|id=613|"Qubit,Site,n=2"), (dim=1|id=362|"Link,n=1"))</span>
<span class="pl-c"><span class="pl-c">#</span>  [3] ((dim=2|id=9|"Qubit,Site,n=3"), (dim=2|id=357|"Link,n=1"), (dim=1|id=362|"Link,n=1"))</span>
<span class="pl-c"><span class="pl-c">#</span>  [4] ((dim=2|id=980|"Qubit,Site,n=4"), (dim=2|id=357|"Link,n=1"))</span></pre></div>
<p dir="auto">In this next example, we create a circuit to prepare the GHZ state, and sample projective measurements in the computational basis. We then execture the circuit in the presence of noise, where a local noise channel is applied to each gate. A noise model is described as <code>noisemodel = ("noisename", (noiseparams...))</code>, in which case it is applied to each gate identically. To distinguish between one- and two-qubit gates, for example, the following syntax can be used: <code>noisemodel = (1 =&gt; noise1, 2 =&gt; noise2)</code>. For more sophisticated noise models (such as gate-dependent noise), please refer to the documentation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PastaQ
using ITensors

# number of qubits
n = 20

# manually create a circuit to prepare GHZ state,
# or use built-in call `circuit = ghz(n)` 
circuit = Tuple[(&quot;H&quot;, 1)]
for j in 1:n-1
  push!(circuit, (&quot;CX&quot;, (j, j+1)))
end

# run the circuit to obtain the output MPS
hilbert = qubits(n)
ψ = runcircuit(hilbert, circuit)


# sample projective measurements in the computational basis
@show getsamples(ψ, 5)

# define a noise model with different error rates for
# one- and two-qubit gates
noisemodel = (1 =&gt; (&quot;depolarizing&quot;, (p = 0.01,)), 
              2 =&gt; (&quot;depolarizing&quot;, (p = 0.05,)))

# run a noisy circuit
ρ = runcircuit(hilbert, circuit; noise = noisemodel)
@show fidelity(ψ, ρ)
@show getsamples(ρ, 5)

# quantum processes can also be obtained.
# unitary MPO
U = runcircuit(circuit; process = true)
# Choi matrix
Λ = runcircuit(circuit; process = true, noise = noisemodel)

# ------------------------------------------------------------------
# Output:
#  5×20 Matrix{Int64}:
#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
#  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
#  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
# 
#  fidelity(ψ, ρ) = 0.40840853095498975
# 
#  5×20 Matrix{Int64}:
#  1  1  1  1  1  1  0  0  0  0  0  0  1  0  0  0  1  1  1  1
#  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
#  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1
#  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1
#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1"><pre><span class="pl-k">using</span> PastaQ
<span class="pl-k">using</span> ITensors

<span class="pl-c"><span class="pl-c">#</span> number of qubits</span>
n <span class="pl-k">=</span> <span class="pl-c1">20</span>

<span class="pl-c"><span class="pl-c">#</span> manually create a circuit to prepare GHZ state,</span>
<span class="pl-c"><span class="pl-c">#</span> or use built-in call `circuit = ghz(n)` </span>
circuit <span class="pl-k">=</span> Tuple[(<span class="pl-s"><span class="pl-pds">"</span>H<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>)]
<span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n<span class="pl-k">-</span><span class="pl-c1">1</span>
  <span class="pl-c1">push!</span>(circuit, (<span class="pl-s"><span class="pl-pds">"</span>CX<span class="pl-pds">"</span></span>, (j, j<span class="pl-k">+</span><span class="pl-c1">1</span>)))
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> run the circuit to obtain the output MPS</span>
hilbert <span class="pl-k">=</span> <span class="pl-c1">qubits</span>(n)
ψ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(hilbert, circuit)


<span class="pl-c"><span class="pl-c">#</span> sample projective measurements in the computational basis</span>
<span class="pl-c1">@show</span> <span class="pl-c1">getsamples</span>(ψ, <span class="pl-c1">5</span>)

<span class="pl-c"><span class="pl-c">#</span> define a noise model with different error rates for</span>
<span class="pl-c"><span class="pl-c">#</span> one- and two-qubit gates</span>
noisemodel <span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> (<span class="pl-s"><span class="pl-pds">"</span>depolarizing<span class="pl-pds">"</span></span>, (p <span class="pl-k">=</span> <span class="pl-c1">0.01</span>,)), 
              <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> (<span class="pl-s"><span class="pl-pds">"</span>depolarizing<span class="pl-pds">"</span></span>, (p <span class="pl-k">=</span> <span class="pl-c1">0.05</span>,)))

<span class="pl-c"><span class="pl-c">#</span> run a noisy circuit</span>
ρ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(hilbert, circuit; noise <span class="pl-k">=</span> noisemodel)
<span class="pl-c1">@show</span> <span class="pl-c1">fidelity</span>(ψ, ρ)
<span class="pl-c1">@show</span> <span class="pl-c1">getsamples</span>(ρ, <span class="pl-c1">5</span>)

<span class="pl-c"><span class="pl-c">#</span> quantum processes can also be obtained.</span>
<span class="pl-c"><span class="pl-c">#</span> unitary MPO</span>
U <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(circuit; process <span class="pl-k">=</span> <span class="pl-c1">true</span>)
<span class="pl-c"><span class="pl-c">#</span> Choi matrix</span>
Λ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(circuit; process <span class="pl-k">=</span> <span class="pl-c1">true</span>, noise <span class="pl-k">=</span> noisemodel)

<span class="pl-c"><span class="pl-c">#</span> ------------------------------------------------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> Output:</span>
<span class="pl-c"><span class="pl-c">#</span>  5×20 Matrix{Int64}:</span>
<span class="pl-c"><span class="pl-c">#</span>  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="pl-c"><span class="pl-c">#</span>  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="pl-c"><span class="pl-c">#</span>  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="pl-c"><span class="pl-c">#</span>  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="pl-c"><span class="pl-c">#</span>  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
<span class="pl-c"><span class="pl-c">#</span>  fidelity(ψ, ρ) = 0.40840853095498975</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
<span class="pl-c"><span class="pl-c">#</span>  5×20 Matrix{Int64}:</span>
<span class="pl-c"><span class="pl-c">#</span>  1  1  1  1  1  1  0  0  0  0  0  0  1  0  0  0  1  1  1  1</span>
<span class="pl-c"><span class="pl-c">#</span>  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="pl-c"><span class="pl-c">#</span>  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1</span>
<span class="pl-c"><span class="pl-c">#</span>  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1</span>
<span class="pl-c"><span class="pl-c">#</span>  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span></pre></div>
<p dir="auto">There is a number of built-in circuits available, one examples being random circuits. In the following, we generate a one-dimensional random quantum circuits built out with a brick-layer geometry of alternative <code>CX</code> gates and layers of random single-qubit rotations:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n = 100 
depth = 20
circuit = randomcircuit(n; depth = depth, 
                           twoqubitgates = &quot;CX&quot;, 
                           onequbitgates = &quot;Rn&quot;)
@time ψ = runcircuit(circuit; cutoff = 1e-10)
@show maxlinkdim(ψ)
# ------------------------------------------------------------------
# Output:
#  89.375383 seconds (5.25 M allocations: 64.781 GiB, 9.98% gc time)
#  maxlinkdim(ψ) = 908"><pre>n <span class="pl-k">=</span> <span class="pl-c1">100</span> 
depth <span class="pl-k">=</span> <span class="pl-c1">20</span>
circuit <span class="pl-k">=</span> <span class="pl-c1">randomcircuit</span>(n; depth <span class="pl-k">=</span> depth, 
                           twoqubitgates <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>CX<span class="pl-pds">"</span></span>, 
                           onequbitgates <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Rn<span class="pl-pds">"</span></span>)
<span class="pl-c1">@time</span> ψ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(circuit; cutoff <span class="pl-k">=</span> <span class="pl-c1">1e-10</span>)
<span class="pl-c1">@show</span> <span class="pl-c1">maxlinkdim</span>(ψ)
<span class="pl-c"><span class="pl-c">#</span> ------------------------------------------------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> Output:</span>
<span class="pl-c"><span class="pl-c">#</span>  89.375383 seconds (5.25 M allocations: 64.781 GiB, 9.98% gc time)</span>
<span class="pl-c"><span class="pl-c">#</span>  maxlinkdim(ψ) = 908</span></pre></div>
<h4 dir="auto"><a id="user-content-variational-quantum-eingensolver" class="anchor" aria-hidden="true" href="#variational-quantum-eingensolver"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Variational quantum eingensolver</h4>
<p dir="auto">We show how to perform a ground state search of a many-body hamiltonian <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$H$</math-renderer> using the variational quantum eigensolver (VQE). The VQE algorithm, based on the variational principle, consists of an iterative optimization of an objective function <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$\langle \psi(\theta)|H|\psi(\theta)\rangle/\langle\psi(\theta)|\psi(\theta)\rangle$</math-renderer>, where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$|\psi(\theta)\rangle = U(\theta)|0\rangle$</math-renderer> is the output wavefunction of a parametrized quantum circuit <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$U(\theta)$</math-renderer>.</p>
<p dir="auto">In the following example, we consider a quantum Ising model with 10 spins, and perform the optimization by leveraging Automatic Differentiation techniques (AD), provided by the package Zygote.jl. Specifically, we build a variational circuit using built-in circuit-contruction functions, and optimize the expectation value of the Hamiltonian using a gradient-based approach and the LBFGS optimizer. The gradients are evaluated through AD, providing a flexible interface in defining custom variational circuit ansatze.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PastaQ
using ITensors
using Random
using Printf
using OptimKit
using Zygote

N = 10   # number of qubits
J = 1.0  # Ising exchange interaction
h = 0.5  # transverse magnetic field

# Hilbert space
hilbert = qubits(N)

function ising_hamiltonian(N; J, h)
  os = OpSum()
  for j in 1:(N - 1)
    os += -J, &quot;Z&quot;, j, &quot;Z&quot;, j + 1
  end
  for j in 1:N
    os += -h, &quot;X&quot;, j
  end
  return os
end

# define the Hamiltonian
os = ising_hamiltonian(N; J, h)

# build MPO &quot;cost function&quot;
H = MPO(os, hilbert)
# find ground state with DMRG

nsweeps = 10
maxdim = [10, 20, 30, 50, 100]
cutoff = 1e-10
Edmrg, Φ = dmrg(H, randomMPS(hilbert); outputlevel=0, nsweeps, maxdim, cutoff);
@printf(&quot;\nGround state energy from DMRG: %.10f\n\n&quot;, Edmrg)

# layer of single-qubit Ry gates
Rylayer(N, θ) = [(&quot;Ry&quot;, j, (θ=θ[j],)) for j in 1:N]

# brick-layer of CX gates
function CXlayer(N, Π)
  start = isodd(Π) ? 1 : 2
  return [(&quot;CX&quot;, (j, j + 1)) for j in start:2:(N - 1)]
end

# variational ansatz
function variationalcircuit(N, depth, θ⃗)
  circuit = Tuple[]
  for d in 1:depth
    circuit = vcat(circuit, CXlayer(N, d))
    circuit = vcat(circuit, Rylayer(N, θ⃗[d]))
  end
  return circuit
end

depth = 20
ψ = productstate(hilbert)

cutoff = 1e-8
maxdim = 50

# cost function
function loss(θ⃗)
  circuit = variationalcircuit(N, depth, θ⃗)
  Uψ = runcircuit(ψ, circuit; cutoff, maxdim)
  return inner(Uψ', H, Uψ; cutoff, maxdim)
end

Random.seed!(1234)

# initialize parameters
θ⃗₀ = [2π .* rand(N) for _ in 1:depth]

# run VQE using BFGS optimization
optimizer = LBFGS(; maxiter=50, verbosity=2)
function loss_and_grad(x)
  y, (∇,) = withgradient(loss, x)
  return y, ∇
end
θ⃗, fs, gs, niter, normgradhistory = optimize(loss_and_grad, θ⃗₀, optimizer)
@printf(&quot;Relative error: %.3E&quot;, abs(Edmrg - fs[end]) / abs(Edmrg))

# ------------------------------------------------------------------
# Output:
#
# Ground state energy from DMRG: -9.7652945661
# 
# [ Info: LBFGS: initializing with f = 0.576652201766, ‖∇f‖ = 2.9254e+00
# [ Info: LBFGS: iter    1: f = -1.646145318390, ‖∇f‖ = 2.9389e+00, α = 1.00e+00, m = 0, nfg = 1
# [ Info: LBFGS: iter    2: f = -2.419207697706, ‖∇f‖ = 4.5128e+00, α = 1.00e+00, m = 1, nfg = 1
# [ Info: LBFGS: iter    3: f = -4.682919004545, ‖∇f‖ = 3.8525e+00, α = 1.00e+00, m = 2, nfg = 1
# [ Info: LBFGS: iter    4: f = -6.033064307468, ‖∇f‖ = 5.2589e+00, α = 4.77e-01, m = 3, nfg = 2
# [ Info: LBFGS: iter    5: f = -7.367240455503, ‖∇f‖ = 3.6558e+00, α = 1.00e+00, m = 4, nfg = 1
# ...
# [ Info: LBFGS: iter   48: f = -9.761513620000, ‖∇f‖ = 3.4139e-02, α = 1.00e+00, m = 8, nfg = 1
# [ Info: LBFGS: iter   49: f = -9.761590462886, ‖∇f‖ = 3.3963e-02, α = 1.00e+00, m = 8, nfg = 1
# ┌ Warning: LBFGS: not converged to requested tol: f = -9.761700259081, ‖∇f‖ = 2.9825e-02
# └ @ OptimKit ~/.julia/packages/OptimKit/xpmbV/src/lbfgs.jl:141
# Relative error: 3.681E-04"><pre><span class="pl-k">using</span> PastaQ
<span class="pl-k">using</span> ITensors
<span class="pl-k">using</span> Random
<span class="pl-k">using</span> Printf
<span class="pl-k">using</span> OptimKit
<span class="pl-k">using</span> Zygote

N <span class="pl-k">=</span> <span class="pl-c1">10</span>   <span class="pl-c"><span class="pl-c">#</span> number of qubits</span>
J <span class="pl-k">=</span> <span class="pl-c1">1.0</span>  <span class="pl-c"><span class="pl-c">#</span> Ising exchange interaction</span>
h <span class="pl-k">=</span> <span class="pl-c1">0.5</span>  <span class="pl-c"><span class="pl-c">#</span> transverse magnetic field</span>

<span class="pl-c"><span class="pl-c">#</span> Hilbert space</span>
hilbert <span class="pl-k">=</span> <span class="pl-c1">qubits</span>(N)

<span class="pl-k">function</span> <span class="pl-en">ising_hamiltonian</span>(N; J, h)
  os <span class="pl-k">=</span> <span class="pl-c1">OpSum</span>()
  <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>(N <span class="pl-k">-</span> <span class="pl-c1">1</span>)
    os <span class="pl-k">+=</span> <span class="pl-k">-</span>J, <span class="pl-s"><span class="pl-pds">"</span>Z<span class="pl-pds">"</span></span>, j, <span class="pl-s"><span class="pl-pds">"</span>Z<span class="pl-pds">"</span></span>, j <span class="pl-k">+</span> <span class="pl-c1">1</span>
  <span class="pl-k">end</span>
  <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
    os <span class="pl-k">+=</span> <span class="pl-k">-</span>h, <span class="pl-s"><span class="pl-pds">"</span>X<span class="pl-pds">"</span></span>, j
  <span class="pl-k">end</span>
  <span class="pl-k">return</span> os
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> define the Hamiltonian</span>
os <span class="pl-k">=</span> <span class="pl-c1">ising_hamiltonian</span>(N; J, h)

<span class="pl-c"><span class="pl-c">#</span> build MPO "cost function"</span>
H <span class="pl-k">=</span> <span class="pl-c1">MPO</span>(os, hilbert)
<span class="pl-c"><span class="pl-c">#</span> find ground state with DMRG</span>

nsweeps <span class="pl-k">=</span> <span class="pl-c1">10</span>
maxdim <span class="pl-k">=</span> [<span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>, <span class="pl-c1">50</span>, <span class="pl-c1">100</span>]
cutoff <span class="pl-k">=</span> <span class="pl-c1">1e-10</span>
Edmrg, Φ <span class="pl-k">=</span> <span class="pl-c1">dmrg</span>(H, <span class="pl-c1">randomMPS</span>(hilbert); outputlevel<span class="pl-k">=</span><span class="pl-c1">0</span>, nsweeps, maxdim, cutoff);
<span class="pl-c1">@printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span>Ground state energy from DMRG: %.10f<span class="pl-cce">\n\n</span><span class="pl-pds">"</span></span>, Edmrg)

<span class="pl-c"><span class="pl-c">#</span> layer of single-qubit Ry gates</span>
<span class="pl-en">Rylayer</span>(N, θ) <span class="pl-k">=</span> [(<span class="pl-s"><span class="pl-pds">"</span>Ry<span class="pl-pds">"</span></span>, j, (θ<span class="pl-k">=</span>θ[j],)) <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N]

<span class="pl-c"><span class="pl-c">#</span> brick-layer of CX gates</span>
<span class="pl-k">function</span> <span class="pl-en">CXlayer</span>(N, Π)
  start <span class="pl-k">=</span> <span class="pl-c1">isodd</span>(Π) <span class="pl-k">?</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">2</span>
  <span class="pl-k">return</span> [(<span class="pl-s"><span class="pl-pds">"</span>CX<span class="pl-pds">"</span></span>, (j, j <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">for</span> j <span class="pl-k">in</span> start<span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>(N <span class="pl-k">-</span> <span class="pl-c1">1</span>)]
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> variational ansatz</span>
<span class="pl-k">function</span> <span class="pl-en">variationalcircuit</span>(N, depth, θ⃗)
  circuit <span class="pl-k">=</span> Tuple[]
  <span class="pl-k">for</span> d <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>depth
    circuit <span class="pl-k">=</span> <span class="pl-c1">vcat</span>(circuit, <span class="pl-c1">CXlayer</span>(N, d))
    circuit <span class="pl-k">=</span> <span class="pl-c1">vcat</span>(circuit, <span class="pl-c1">Rylayer</span>(N, θ⃗[d]))
  <span class="pl-k">end</span>
  <span class="pl-k">return</span> circuit
<span class="pl-k">end</span>

depth <span class="pl-k">=</span> <span class="pl-c1">20</span>
ψ <span class="pl-k">=</span> <span class="pl-c1">productstate</span>(hilbert)

cutoff <span class="pl-k">=</span> <span class="pl-c1">1e-8</span>
maxdim <span class="pl-k">=</span> <span class="pl-c1">50</span>

<span class="pl-c"><span class="pl-c">#</span> cost function</span>
<span class="pl-k">function</span> <span class="pl-en">loss</span>(θ⃗)
  circuit <span class="pl-k">=</span> <span class="pl-c1">variationalcircuit</span>(N, depth, θ⃗)
  Uψ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(ψ, circuit; cutoff, maxdim)
  <span class="pl-k">return</span> <span class="pl-c1">inner</span>(Uψ<span class="pl-k">'</span>, H, Uψ; cutoff, maxdim)
<span class="pl-k">end</span>

Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1234</span>)

<span class="pl-c"><span class="pl-c">#</span> initialize parameters</span>
θ⃗₀ <span class="pl-k">=</span> [<span class="pl-c1">2</span>π <span class="pl-k">.*</span> <span class="pl-c1">rand</span>(N) <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>depth]

<span class="pl-c"><span class="pl-c">#</span> run VQE using BFGS optimization</span>
optimizer <span class="pl-k">=</span> <span class="pl-c1">LBFGS</span>(; maxiter<span class="pl-k">=</span><span class="pl-c1">50</span>, verbosity<span class="pl-k">=</span><span class="pl-c1">2</span>)
<span class="pl-k">function</span> <span class="pl-en">loss_and_grad</span>(x)
  y, (∇,) <span class="pl-k">=</span> <span class="pl-c1">withgradient</span>(loss, x)
  <span class="pl-k">return</span> y, ∇
<span class="pl-k">end</span>
θ⃗, fs, gs, niter, normgradhistory <span class="pl-k">=</span> <span class="pl-c1">optimize</span>(loss_and_grad, θ⃗₀, optimizer)
<span class="pl-c1">@printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Relative error: %.3E<span class="pl-pds">"</span></span>, <span class="pl-c1">abs</span>(Edmrg <span class="pl-k">-</span> fs[<span class="pl-c1">end</span>]) <span class="pl-k">/</span> <span class="pl-c1">abs</span>(Edmrg))

<span class="pl-c"><span class="pl-c">#</span> ------------------------------------------------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> Output:</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> Ground state energy from DMRG: -9.7652945661</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: initializing with f = 0.576652201766, ‖∇f‖ = 2.9254e+00</span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: iter    1: f = -1.646145318390, ‖∇f‖ = 2.9389e+00, α = 1.00e+00, m = 0, nfg = 1</span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: iter    2: f = -2.419207697706, ‖∇f‖ = 4.5128e+00, α = 1.00e+00, m = 1, nfg = 1</span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: iter    3: f = -4.682919004545, ‖∇f‖ = 3.8525e+00, α = 1.00e+00, m = 2, nfg = 1</span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: iter    4: f = -6.033064307468, ‖∇f‖ = 5.2589e+00, α = 4.77e-01, m = 3, nfg = 2</span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: iter    5: f = -7.367240455503, ‖∇f‖ = 3.6558e+00, α = 1.00e+00, m = 4, nfg = 1</span>
<span class="pl-c"><span class="pl-c">#</span> ...</span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: iter   48: f = -9.761513620000, ‖∇f‖ = 3.4139e-02, α = 1.00e+00, m = 8, nfg = 1</span>
<span class="pl-c"><span class="pl-c">#</span> [ Info: LBFGS: iter   49: f = -9.761590462886, ‖∇f‖ = 3.3963e-02, α = 1.00e+00, m = 8, nfg = 1</span>
<span class="pl-c"><span class="pl-c">#</span> ┌ Warning: LBFGS: not converged to requested tol: f = -9.761700259081, ‖∇f‖ = 2.9825e-02</span>
<span class="pl-c"><span class="pl-c">#</span> └ @ OptimKit ~/.julia/packages/OptimKit/xpmbV/src/lbfgs.jl:141</span>
<span class="pl-c"><span class="pl-c">#</span> Relative error: 3.681E-04</span></pre></div>
<h4 dir="auto">
<a id="user-content-monitored-quantum-circuits" class="anchor" aria-hidden="true" href="#monitored-quantum-circuits"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Monitored quantum circuits</h4>
<p dir="auto">In this example we simulate a monitored quantum circuit, a circuit composed by entangling unitaries and probabilistic local projective measurements, with a rate <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$p$</math-renderer>. The circuit has a brick-layer structure, where each layer consists of nearest-neighbor two-qubit random unitaries, followed by a layer of randomly-placed projective measurements in the computational basis. In the limit of <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$p=0$</math-renderer>, the system displays a scrambling dynamics, exhibiting a volume-law entanglement entropy. When <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$p$</math-renderer> grows large, the competition between the entangling unitaries and the (disentangling) projective measurements generates can induce an ''<em>entanglement phase transition</em>" at a critical rate <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$p_c$</math-renderer>, separating a volume law phase (low <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$p$</math-renderer>) from an area-law phase (high <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="dfe21cc122b246d0556bdb125e3ec314">$p$</math-renderer>).</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PastaQ
using ITensors
using Printf
using LinearAlgebra
using StatsBase: mean, sem 

import PastaQ: gate

# define the two measurement projectors
gate(::GateName&quot;Π0&quot;) =
  [1 0
   0 0]
gate(::GateName&quot;Π1&quot;) =
  [0 0
   0 1]

# compute the Von Neumann entanglement entropy at the center bond 
# of a linear chain of qubits
function entanglemententropy(ψ₀::MPS)
  ψ = normalize!(copy(ψ₀))
  N = length(ψ)
  bond = N ÷ 2
  orthogonalize!(ψ, bond)

  row_inds = (linkind(ψ, bond - 1), siteind(ψ, bond))
  u, s, v = svd(ψ[bond], row_inds)

  S = 0.0
  for n in 1:dim(s, 1)
    λ = s[n, n]^2
    S -= λ * log(λ + 1e-20)
  end
  return S
end

# build a brick-layer circuit of random unitaries
function entangling_layer(N::Int)
  layer_odd  = randomlayer(&quot;RandomUnitary&quot;,[(j,j+1) for j in 1:2:N-1])
  layer_even = randomlayer(&quot;RandomUnitary&quot;,[(j,j+1) for j in 2:2:N-1])
  return [layer_odd..., layer_even...]
end

# perform a projective measurement in the computational basis
# at a given site
function projective_measurement!(ψ₀::MPS, site::Int)
  ψ = orthogonalize!(ψ₀, site)
  ϕ = ψ[site]
  # 1-qubit reduced density matrix
  ρ = prime(ϕ, tags=&quot;Site&quot;) * dag(ϕ)
  # Outcome probabilities
  prob = real.(diag(array(ρ)))
  # Sample
  σ = (rand() &lt; prob[1] ? 0 : 1)
  # Projection
  ψ = runcircuit(ψ, (&quot;Π&quot;*&quot;$(σ)&quot;, site))
  normalize!(ψ)
  ψ₀[:] = ψ
  return ψ₀
end

# compute average Von Neumann entropy for an ensemble of random circuits
# for a fixed local measurement probability rate `p`
function monitored_circuits(circuits::Vector{&lt;:Vector}, p::Float64)
  svn = []
  N = nqubits(circuits[1])
  for circuit in circuits
    # initialize state ψ = |000…⟩
    ψ = productstate(N)
    # sweep over layers
    for layer in circuit
      # apply entangling unitary
      ψ = runcircuit(ψ, layer; cutoff = 1e-8)
      # perform measurements
      for j in 1:N
        p &gt; rand() &amp;&amp; projective_measurement!(ψ, j)
      end
    end
    push!(svn, entanglemententropy(ψ))
  end
  return svn
end

let
  Random.seed!(1234)
  N = 10        # number of qubits
  depth = 100   # circuit's depth
  ntrials = 50  # number of random trials

  # generate random circuits
  circuits = [[entangling_layer(N) for _ in 1:depth] for _ in 1:ntrials]

  # loop over projective measurement probability (per site)
  for p in 0.0:0.02:0.2
    t = @elapsed svn = monitored_circuits(circuits, p)
    @printf(&quot;p = %.2f  S(ρ) = %.5f ± %.1E\t(elapsed = %.2fs)\n&quot;, p, mean(svn), sem(svn), t)
  end
end

# ------------------------------------------------------------------
# Output:
#  p = 0.00  S(ρ) = 2.96398 ± 2.0E-03	(elapsed = 75.53s)
#  p = 0.02  S(ρ) = 2.64681 ± 4.1E-02	(elapsed = 31.23s)
#  p = 0.04  S(ρ) = 2.42949 ± 5.8E-02	(elapsed = 31.73s)
#  p = 0.06  S(ρ) = 2.24704 ± 5.0E-02	(elapsed = 30.99s)
#  p = 0.08  S(ρ) = 1.99610 ± 6.3E-02	(elapsed = 32.02s)
#  p = 0.10  S(ρ) = 1.95011 ± 6.3E-02	(elapsed = 32.27s)
#  p = 0.12  S(ρ) = 1.72640 ± 5.6E-02	(elapsed = 31.29s)
#  p = 0.14  S(ρ) = 1.66021 ± 5.8E-02	(elapsed = 31.75s)
#  p = 0.16  S(ρ) = 1.30065 ± 5.6E-02	(elapsed = 32.44s)
#  p = 0.18  S(ρ) = 1.34038 ± 6.4E-02	(elapsed = 33.34s)
#  p = 0.20  S(ρ) = 1.12428 ± 6.0E-02	(elapsed = 34.35s)"><pre><span class="pl-k">using</span> PastaQ
<span class="pl-k">using</span> ITensors
<span class="pl-k">using</span> Printf
<span class="pl-k">using</span> LinearAlgebra
<span class="pl-k">using</span> StatsBase<span class="pl-k">:</span> mean, sem 

<span class="pl-k">import</span> PastaQ<span class="pl-k">:</span> gate

<span class="pl-c"><span class="pl-c">#</span> define the two measurement projectors</span>
<span class="pl-en">gate</span>(<span class="pl-k">::</span><span class="pl-c1">GateName"Π0"</span>) <span class="pl-k">=</span>
  [<span class="pl-c1">1</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">0</span>]
<span class="pl-en">gate</span>(<span class="pl-k">::</span><span class="pl-c1">GateName"Π1"</span>) <span class="pl-k">=</span>
  [<span class="pl-c1">0</span> <span class="pl-c1">0</span>
   <span class="pl-c1">0</span> <span class="pl-c1">1</span>]

<span class="pl-c"><span class="pl-c">#</span> compute the Von Neumann entanglement entropy at the center bond </span>
<span class="pl-c"><span class="pl-c">#</span> of a linear chain of qubits</span>
<span class="pl-k">function</span> <span class="pl-en">entanglemententropy</span>(ψ₀<span class="pl-k">::</span><span class="pl-c1">MPS</span>)
  ψ <span class="pl-k">=</span> <span class="pl-c1">normalize!</span>(<span class="pl-c1">copy</span>(ψ₀))
  N <span class="pl-k">=</span> <span class="pl-c1">length</span>(ψ)
  bond <span class="pl-k">=</span> N <span class="pl-k">÷</span> <span class="pl-c1">2</span>
  <span class="pl-c1">orthogonalize!</span>(ψ, bond)

  row_inds <span class="pl-k">=</span> (<span class="pl-c1">linkind</span>(ψ, bond <span class="pl-k">-</span> <span class="pl-c1">1</span>), <span class="pl-c1">siteind</span>(ψ, bond))
  u, s, v <span class="pl-k">=</span> <span class="pl-c1">svd</span>(ψ[bond], row_inds)

  S <span class="pl-k">=</span> <span class="pl-c1">0.0</span>
  <span class="pl-k">for</span> n <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">dim</span>(s, <span class="pl-c1">1</span>)
    λ <span class="pl-k">=</span> s[n, n]<span class="pl-k">^</span><span class="pl-c1">2</span>
    S <span class="pl-k">-=</span> λ <span class="pl-k">*</span> <span class="pl-c1">log</span>(λ <span class="pl-k">+</span> <span class="pl-c1">1e-20</span>)
  <span class="pl-k">end</span>
  <span class="pl-k">return</span> S
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> build a brick-layer circuit of random unitaries</span>
<span class="pl-k">function</span> <span class="pl-en">entangling_layer</span>(N<span class="pl-k">::</span><span class="pl-c1">Int</span>)
  layer_odd  <span class="pl-k">=</span> <span class="pl-c1">randomlayer</span>(<span class="pl-s"><span class="pl-pds">"</span>RandomUnitary<span class="pl-pds">"</span></span>,[(j,j<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>N<span class="pl-k">-</span><span class="pl-c1">1</span>])
  layer_even <span class="pl-k">=</span> <span class="pl-c1">randomlayer</span>(<span class="pl-s"><span class="pl-pds">"</span>RandomUnitary<span class="pl-pds">"</span></span>,[(j,j<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span>N<span class="pl-k">-</span><span class="pl-c1">1</span>])
  <span class="pl-k">return</span> [layer_odd<span class="pl-k">...</span>, layer_even<span class="pl-k">...</span>]
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> perform a projective measurement in the computational basis</span>
<span class="pl-c"><span class="pl-c">#</span> at a given site</span>
<span class="pl-k">function</span> <span class="pl-en">projective_measurement!</span>(ψ₀<span class="pl-k">::</span><span class="pl-c1">MPS</span>, site<span class="pl-k">::</span><span class="pl-c1">Int</span>)
  ψ <span class="pl-k">=</span> <span class="pl-c1">orthogonalize!</span>(ψ₀, site)
  ϕ <span class="pl-k">=</span> ψ[site]
  <span class="pl-c"><span class="pl-c">#</span> 1-qubit reduced density matrix</span>
  ρ <span class="pl-k">=</span> <span class="pl-c1">prime</span>(ϕ, tags<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Site<span class="pl-pds">"</span></span>) <span class="pl-k">*</span> <span class="pl-c1">dag</span>(ϕ)
  <span class="pl-c"><span class="pl-c">#</span> Outcome probabilities</span>
  prob <span class="pl-k">=</span> <span class="pl-c1">real</span>.(<span class="pl-c1">diag</span>(<span class="pl-c1">array</span>(ρ)))
  <span class="pl-c"><span class="pl-c">#</span> Sample</span>
  σ <span class="pl-k">=</span> (<span class="pl-c1">rand</span>() <span class="pl-k">&lt;</span> prob[<span class="pl-c1">1</span>] <span class="pl-k">?</span> <span class="pl-c1">0</span> <span class="pl-k">:</span> <span class="pl-c1">1</span>)
  <span class="pl-c"><span class="pl-c">#</span> Projection</span>
  ψ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(ψ, (<span class="pl-s"><span class="pl-pds">"</span>Π<span class="pl-pds">"</span></span><span class="pl-k">*</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$(σ)</span><span class="pl-pds">"</span></span>, site))
  <span class="pl-c1">normalize!</span>(ψ)
  ψ₀[:] <span class="pl-k">=</span> ψ
  <span class="pl-k">return</span> ψ₀
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> compute average Von Neumann entropy for an ensemble of random circuits</span>
<span class="pl-c"><span class="pl-c">#</span> for a fixed local measurement probability rate `p`</span>
<span class="pl-k">function</span> <span class="pl-en">monitored_circuits</span>(circuits<span class="pl-k">::</span><span class="pl-c1">Vector{&lt;:Vector}</span>, p<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
  svn <span class="pl-k">=</span> []
  N <span class="pl-k">=</span> <span class="pl-c1">nqubits</span>(circuits[<span class="pl-c1">1</span>])
  <span class="pl-k">for</span> circuit <span class="pl-k">in</span> circuits
    <span class="pl-c"><span class="pl-c">#</span> initialize state ψ = |000…⟩</span>
    ψ <span class="pl-k">=</span> <span class="pl-c1">productstate</span>(N)
    <span class="pl-c"><span class="pl-c">#</span> sweep over layers</span>
    <span class="pl-k">for</span> layer <span class="pl-k">in</span> circuit
      <span class="pl-c"><span class="pl-c">#</span> apply entangling unitary</span>
      ψ <span class="pl-k">=</span> <span class="pl-c1">runcircuit</span>(ψ, layer; cutoff <span class="pl-k">=</span> <span class="pl-c1">1e-8</span>)
      <span class="pl-c"><span class="pl-c">#</span> perform measurements</span>
      <span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
        p <span class="pl-k">&gt;</span> <span class="pl-c1">rand</span>() <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">projective_measurement!</span>(ψ, j)
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
    <span class="pl-c1">push!</span>(svn, <span class="pl-c1">entanglemententropy</span>(ψ))
  <span class="pl-k">end</span>
  <span class="pl-k">return</span> svn
<span class="pl-k">end</span>

<span class="pl-k">let</span>
  Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1234</span>)
  N <span class="pl-k">=</span> <span class="pl-c1">10</span>        <span class="pl-c"><span class="pl-c">#</span> number of qubits</span>
  depth <span class="pl-k">=</span> <span class="pl-c1">100</span>   <span class="pl-c"><span class="pl-c">#</span> circuit's depth</span>
  ntrials <span class="pl-k">=</span> <span class="pl-c1">50</span>  <span class="pl-c"><span class="pl-c">#</span> number of random trials</span>

  <span class="pl-c"><span class="pl-c">#</span> generate random circuits</span>
  circuits <span class="pl-k">=</span> [[<span class="pl-c1">entangling_layer</span>(N) <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>depth] <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>ntrials]

  <span class="pl-c"><span class="pl-c">#</span> loop over projective measurement probability (per site)</span>
  <span class="pl-k">for</span> p <span class="pl-k">in</span> <span class="pl-c1">0.0</span><span class="pl-k">:</span><span class="pl-c1">0.02</span><span class="pl-k">:</span><span class="pl-c1">0.2</span>
    t <span class="pl-k">=</span> <span class="pl-c1">@elapsed</span> svn <span class="pl-k">=</span> <span class="pl-c1">monitored_circuits</span>(circuits, p)
    <span class="pl-c1">@printf</span>(<span class="pl-s"><span class="pl-pds">"</span>p = %.2f  S(ρ) = %.5f ± %.1E<span class="pl-cce">\t</span>(elapsed = %.2fs)<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, p, <span class="pl-c1">mean</span>(svn), <span class="pl-c1">sem</span>(svn), t)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> ------------------------------------------------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> Output:</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.00  S(ρ) = 2.96398 ± 2.0E-03	(elapsed = 75.53s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.02  S(ρ) = 2.64681 ± 4.1E-02	(elapsed = 31.23s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.04  S(ρ) = 2.42949 ± 5.8E-02	(elapsed = 31.73s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.06  S(ρ) = 2.24704 ± 5.0E-02	(elapsed = 30.99s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.08  S(ρ) = 1.99610 ± 6.3E-02	(elapsed = 32.02s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.10  S(ρ) = 1.95011 ± 6.3E-02	(elapsed = 32.27s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.12  S(ρ) = 1.72640 ± 5.6E-02	(elapsed = 31.29s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.14  S(ρ) = 1.66021 ± 5.8E-02	(elapsed = 31.75s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.16  S(ρ) = 1.30065 ± 5.6E-02	(elapsed = 32.44s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.18  S(ρ) = 1.34038 ± 6.4E-02	(elapsed = 33.34s)</span>
<span class="pl-c"><span class="pl-c">#</span>  p = 0.20  S(ρ) = 1.12428 ± 6.0E-02	(elapsed = 34.35s)</span></pre></div>
<h2 dir="auto">
<a id="user-content-citation" class="anchor" aria-hidden="true" href="#citation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citation</h2>
<p dir="auto">If you use PastaQ.jl in your work, for now please consider citing the Github page:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@misc{pastaq,
    title={\mbox{PastaQ}: A Package for Simulation, Tomography and Analysis of Quantum Computers},
    author={Giacomo Torlai and Matthew Fishman},
    year={2020},
    url={https://github.com/GTorlai/PastaQ.jl/}
}"><pre class="notranslate"><code>@misc{pastaq,
    title={\mbox{PastaQ}: A Package for Simulation, Tomography and Analysis of Quantum Computers},
    author={Giacomo Torlai and Matthew Fishman},
    year={2020},
    url={https://github.com/GTorlai/PastaQ.jl/}
}
</code></pre></div>
<h2 dir="auto">
<a id="user-content-research-papers-using-pastaq" class="anchor" aria-hidden="true" href="#research-papers-using-pastaq"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Research papers using PastaQ</h2>
<p dir="auto">If you used PastaQ.jl and your paper does not appear in this list, please let us know at <a href="mailto:info@pastaq.org">info@pastaq.org</a>.</p>
<p dir="auto"><strong>2023</strong></p>
<ul dir="auto">
<li>
<a href="https://arxiv.org/abs/2304.12292" rel="nofollow">2304.12292</a> <em>Enhanced estimation of quantum properties with common randomized measurements</em>, B Vermersch, A Rath, B Sundar, C Branciard, J Preskill, A Elben.</li>
<li>
<a href="https://arxiv.org/abs/2301.08292" rel="nofollow">2301.08292</a> <em>Quantum HyperNetworks: Training Binary Neural Networks in Quantum Superposition</em>, Juan Carrasquilla, Mohamed Hibat-Allah, Estelle Inack, Alireza Makhzani, Kirill Neklyudov, Graham W. Taylor, Giacomo Torlai.</li>
</ul>
<p dir="auto"><strong>2022</strong></p>
<ul dir="auto">
<li>
<a href="https://arxiv.org/abs/2204.10061" rel="nofollow">2204.10061</a> <em>Scalable measure of magic for quantum computers</em>, T Haug and MS Kim, <em>PRX Quantum 4, 010301</em>.</li>
<li>
<a href="https://arxiv.org/abs/2204.03454" rel="nofollow">2204.03454</a> <em>Variational dynamics as a ground-state problem on a quantum computer</em>, Stefano Barison, Filippo Vicentini, Ignacio Cirac, Giuseppe Carleo, <em>Phys. Rev. Research 4, 043161</em>.</li>
<li>
<a href="https://arxiv.org/abs/2203.04948" rel="nofollow">2203.04948</a> <em>Fragile boundaries of tailored surface codes and improved decoding of circuit-level noise</em>, O Higgott, TC Bohdanowicz, A Kubica, ST Flammia, ET Campbell.</li>
</ul>
<p dir="auto"><strong>2021</strong></p>
<ul dir="auto">
<li>
<a href="https://arxiv.org/abs/2106.12627" rel="nofollow">2106.12627</a> <em>Provably efficient machine learning for quantum many-body problems</em>, H-Y Huang, R Kueng, G Torlai, VV Albert, J Preskill, <em>Science Vol 377, Issue 6613</em>.</li>
<li>
<a href="https://arxiv.org/abs/2106.03769" rel="nofollow">2106.03769</a> <em>Simulating a measurement-induced phase transition in trapped-ion circuits</em>, S Czischek, G Torlai, S Ray, R Islam, RG Melko, <em>Phys. Rev. A 104, 062405</em>.</li>
</ul>
<p dir="auto"><strong>2020</strong></p>
<ul dir="auto">
<li>
<a href="https://arxiv.org/abs/2009.01760" rel="nofollow">2009.01760</a> <em>Classical variational simulation of the Quantum Approximation Optimization Algorithm</em>, M Medvidovic and G Carleo, <em>Nature Communication, 7, 101</em>.</li>
<li>
<a href="https://arxiv.org/abs/2006.02424" rel="nofollow">2006.02424</a> <em>Quantum process tomography with unsupervised learning and tensor networks</em>, G Torlai, CJ Wood, A Acharya, G Carleo, J Carrasquilla, L Aolita.</li>
</ul>
</article></div>