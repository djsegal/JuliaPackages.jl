<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-julogjl" class="anchor" aria-hidden="true" href="#julogjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Julog.jl</h1>
<p>A Julia package for Prolog-style logic programming.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>Enter the package manager by pressing <code>]</code> at the Julia REPL, then run:</p>
<pre><code>add Julog
</code></pre>
<p>The latest development version can also be installed by running:</p>
<pre><code>add &lt;link to this git repository&gt;
</code></pre>
<h2><a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Features</h2>
<ul>
<li><a href="#syntax">Prolog-like syntax</a></li>
<li><a href="#interpolation">Interpolation of expressions</a></li>
<li><a href="#custom-functions">Custom function support</a></li>
<li><a href="#built-in-predicates">Built-in predicates and logical connectives</a></li>
<li><a href="#conversion-utilities">Conversion utilities</a></li>
</ul>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p><a href="http://www.dai.ed.ac.uk/groups/ssp/bookpages/quickprolog/node5.html" rel="nofollow">Terms</a> and <a href="https://en.wikipedia.org/wiki/Horn_clause" rel="nofollow">Horn clauses</a> can be expressed in Prolog-like syntax using the
<code>@julog</code> macro:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> This creates a term</span>
<span class="pl-c1">@julog</span> <span class="pl-c1">teacher</span>(bodhidharma, huike)
<span class="pl-c"><span class="pl-c">#</span> This creates a fact (a term which is asserted to be true)</span>
<span class="pl-c1">@julog</span> <span class="pl-c1">teacher</span>(bodhidharma, huike) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">true</span>
<span class="pl-c"><span class="pl-c">#</span> This creates a definite clause</span>
<span class="pl-c1">@julog</span> <span class="pl-c1">grandteacher</span>(A, C) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">teacher</span>(A, B) <span class="pl-k">&amp;</span> <span class="pl-c1">teacher</span>(B, C)</pre></div>
<p>The <code>@julog</code> macro can be also applied to a list of clauses to create a
knowledge base. We use the traditional <a href="https://en.wikipedia.org/wiki/Zen_lineage_charts" rel="nofollow">Zen lineage chart</a> as an example:</p>
<div class="highlight highlight-source-julia"><pre>clauses <span class="pl-k">=</span> <span class="pl-c1">@julog</span> [
  <span class="pl-c1">ancestor</span>(sakyamuni, bodhidharma) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">true</span>,
  <span class="pl-c1">teacher</span>(bodhidharma, huike) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">true</span>,
  <span class="pl-c1">teacher</span>(huike, sengcan) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">true</span>,
  <span class="pl-c1">teacher</span>(sengcan, daoxin) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">true</span>,
  <span class="pl-c1">teacher</span>(daoxin, hongren) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">true</span>,
  <span class="pl-c1">teacher</span>(hongren, huineng) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">true</span>,
  <span class="pl-c1">ancestor</span>(A, B) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">teacher</span>(A, B),
  <span class="pl-c1">ancestor</span>(A, C) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">teacher</span>(B, C) <span class="pl-k">&amp;</span> <span class="pl-c1">ancestor</span>(A, B),
  <span class="pl-c1">grandteacher</span>(A, C) <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">teacher</span>(A, B) <span class="pl-k">&amp;</span> <span class="pl-c1">teacher</span>(B, C)
]</pre></div>
<p>With the <code>resolve</code> function, we can query the knowledge base via <a href="https://en.wikipedia.org/wiki/SLD_resolution" rel="nofollow">SLD resolution</a> (the form of backward-chaining proof search used by Prolog):</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Query: Is Sakyamuni the dharma ancestor of Huineng?</span>
julia<span class="pl-k">&gt;</span> goals <span class="pl-k">=</span> <span class="pl-c1">@julog</span> [<span class="pl-c1">ancestor</span>(sakyamuni, huineng)]; <span class="pl-c"><span class="pl-c">#</span> List of terms to query or prove</span>
julia<span class="pl-k">&gt;</span> sat, subst <span class="pl-k">=</span> <span class="pl-c1">resolve</span>(goals, clauses);
julia<span class="pl-k">&gt;</span> sat
<span class="pl-c1">true</span>

<span class="pl-c"><span class="pl-c">#</span> Query: Who are the grandteachers of whom?</span>
julia<span class="pl-k">&gt;</span> goals <span class="pl-k">=</span> <span class="pl-c1">@julog</span> [<span class="pl-c1">grandteacher</span>(X, Y)];
julia<span class="pl-k">&gt;</span> sat, subst <span class="pl-k">=</span> <span class="pl-c1">resolve</span>(goals, clauses);
julia<span class="pl-k">&gt;</span> subst
<span class="pl-c1">4</span><span class="pl-k">-</span>element Array{Any,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
  {Y <span class="pl-k">=&gt;</span> sengcan, X <span class="pl-k">=&gt;</span> bodhidharma}
  {Y <span class="pl-k">=&gt;</span> daoxin, X <span class="pl-k">=&gt;</span> huike}
  {Y <span class="pl-k">=&gt;</span> hongren, X <span class="pl-k">=&gt;</span> sengcan}
  {Y <span class="pl-k">=&gt;</span> huineng, X <span class="pl-k">=&gt;</span> daoxin}</pre></div>
<p>Forward-chaining proof search is supported as well, using <code>derive</code>. We can also compute the list of n-step derivations with <code>derivations(clauses, n)</code>:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c"><span class="pl-c">#</span> Facts derivable from one iteration through the rules</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">derivations</span>(clauses, <span class="pl-c1">1</span>)
<span class="pl-c1">16</span><span class="pl-k">-</span>element Array{Clause,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">teacher</span>(bodhidharma, huike)
 ⋮
 <span class="pl-c1">ancestor</span>(sakyamuni, huike)

<span class="pl-c"><span class="pl-c">#</span> The set of all derivable facts (i.e. the closure / fixed-point)</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">derivations</span>(clauses, <span class="pl-c1">Inf</span>)
<span class="pl-c1">30</span><span class="pl-k">-</span>element Array{Clause,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">teacher</span>(bodhidharma, huike)
 ⋮
 <span class="pl-c1">ancestor</span>(sakyamuni, huineng)</pre></div>
<p>More examples can be found in the <a href="test"><code>test</code></a> folder.</p>
<h2><a id="user-content-syntax" class="anchor" aria-hidden="true" href="#syntax"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax</h2>
<p><code>Julog</code> uses syntax very similar to Prolog. In particular, users should
note that argument-free terms with initial capitals are parsed as variables,
whereas lowercase terms are parsed as constants:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(<span class="pl-c1">@julog</span>(Person))
Var
julia<span class="pl-k">&gt;</span> <span class="pl-c1">typeof</span>(<span class="pl-c1">@julog</span>(person))
Const</pre></div>
<p>However, several important operators differ from Prolog, as shown by the examples below:</p>
<table>
<thead>
<tr>
<th>Julog</th>
<th>Prolog</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>human(socrates) &lt;&lt;= true</code></td>
<td><code>human(socrates).</code></td>
<td>Socrates is human.</td>
</tr>
<tr>
<td><code>mortal(X) &lt;&lt;= human(X)</code></td>
<td><code>mortal(X) :- human(X).</code></td>
<td>If X is human, X is mortal.</td>
</tr>
<tr>
<td><code>!mortal(gaia)</code></td>
<td><code>\+mortal(gaia)</code></td>
<td>Gaia is not mortal.</td>
</tr>
<tr>
<td><code>mortal(X) &lt;&lt;= can_live(X) &amp; can_die(X)</code></td>
<td><code>mortal(X) :- can_live(X), can_die(X)</code></td>
<td>X is mortal if it can live and die.</td>
</tr>
</tbody>
</table>
<p>In words, <code>&lt;&lt;=</code> replaces the Prolog turnstile <code>:-</code>, <code>&lt;&lt;= true</code> or <code>'</code> replaces <code>.</code> when stating facts, <code>!</code> replaces <code>\+</code> for negation, there is no longer a special operator for <code>cut</code>, <code>&amp;</code> replaces <code>,</code> in the bodies of definite clauses, and there is no <code>or</code> operator like the <code>;</code> in Prolog.</p>
<p>If Prolog syntax is preferred, the <code>@prolog</code> macro and <code>parse_prolog</code> functions can be used to convert Prolog strings directly to Julog constructs, while <code>write_prolog</code> converts a list of Julog clauses to a Prolog string. However, this conversion cannot presently handle all of Prolog syntax (e.g., nested infix operators or comparison operators such as <code>=:=</code>), and should be used with caution.</p>
<h2><a id="user-content-interpolation" class="anchor" aria-hidden="true" href="#interpolation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interpolation</h2>
<p>Similar to <a href="https://docs.julialang.org/en/latest/manual/strings/#string-interpolation-1" rel="nofollow">string interpolation</a> and <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Expressions-and-evaluation-1" rel="nofollow">expression interpolation</a> in Julia, you can interpolate Julia expressions when constructing <code>Julog</code> terms using the <code>@julog</code> macro. <code>Julog</code> supports two forms of interpolation. The first form is constant interpolation using the <code>$</code> operator, where ordinary Julia expressions are converted to <code>Const</code>s:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> e <span class="pl-k">=</span> <span class="pl-c1">exp</span>(<span class="pl-c1">1</span>)
<span class="pl-c1">2.718281828459045</span>
julia<span class="pl-k">&gt;</span> term <span class="pl-k">=</span> <span class="pl-c1">@julog</span> <span class="pl-c1">irrational</span>(<span class="pl-k">$</span>e)
<span class="pl-c1">irrational</span>(<span class="pl-c1">2.718281828459045</span>)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">dump</span>(term)
Compound
  name<span class="pl-k">:</span> Symbol irrational
  args<span class="pl-k">:</span> <span class="pl-c1">Array</span><span class="pl-c1">{Term}</span>((<span class="pl-c1">1</span>,))
    <span class="pl-c1">1</span><span class="pl-k">:</span> Const
      name<span class="pl-k">:</span> Float64 <span class="pl-c1">2.718281828459045</span></pre></div>
<p>The second form is term interpolation using the <code>:</code> operator, where pre-constructed <code>Julog</code> terms are interpolated into a surrounding <code>Julog</code> expression:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> e <span class="pl-k">=</span> <span class="pl-c1">Const</span>(<span class="pl-c1">exp</span>(<span class="pl-c1">1</span>))
<span class="pl-c1">2.718281828459045</span>
julia<span class="pl-k">&gt;</span> term <span class="pl-k">=</span> <span class="pl-c1">@julog</span> <span class="pl-c1">irrational</span>(<span class="pl-c1">:e</span>)
<span class="pl-c1">irrational</span>(<span class="pl-c1">2.718281828459045</span>)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">dump</span>(term)
Compound
  name<span class="pl-k">:</span> Symbol irrational
  args<span class="pl-k">:</span> <span class="pl-c1">Array</span><span class="pl-c1">{Term}</span>((<span class="pl-c1">1</span>,))
    <span class="pl-c1">1</span><span class="pl-k">:</span> Const
      name<span class="pl-k">:</span> Float64 <span class="pl-c1">2.718281828459045</span></pre></div>
<p>Interpolation allows us to easily generate Julog knowledge bases programatically using Julia code:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> people <span class="pl-k">=</span> <span class="pl-c1">@julog</span> [avery, bailey, casey, darcy];
julia<span class="pl-k">&gt;</span> heights <span class="pl-k">=</span> [<span class="pl-c1">@julog</span>(<span class="pl-c1">height</span>(<span class="pl-c1">:p</span>, <span class="pl-c1">cm</span>(<span class="pl-k">$</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">140</span><span class="pl-k">:</span><span class="pl-c1">200</span>))))) <span class="pl-k">for</span> p <span class="pl-k">in</span> people]
<span class="pl-c1">4</span><span class="pl-k">-</span>element Array{Compound,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-c1">height</span>(avery, <span class="pl-c1">cm</span>(<span class="pl-c1">155</span>))
 <span class="pl-c1">height</span>(bailey, <span class="pl-c1">cm</span>(<span class="pl-c1">198</span>))
 <span class="pl-c1">height</span>(casey, <span class="pl-c1">cm</span>(<span class="pl-c1">161</span>))
 <span class="pl-c1">height</span>(darcy, <span class="pl-c1">cm</span>(<span class="pl-c1">175</span>))</pre></div>
<h2><a id="user-content-custom-functions" class="anchor" aria-hidden="true" href="#custom-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Functions</h2>
<p>In addition to standard arithmetic functions, <code>Julog</code> supports the evaluation of custom functions during proof search, allowing users to leverage the full power of precompiled Julia code. This can be done by providing a dictionary of functions when calling <code>resolve</code>. This dictionary can also accept constants (allowing one to store, e.g., numeric-valued fluents), and lookup-tables. An example is shown below:</p>
<div class="highlight highlight-source-julia"><pre>funcs <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
funcs[<span class="pl-c1">:pi</span>] <span class="pl-k">=</span> pi
funcs[<span class="pl-c1">:sin</span>] <span class="pl-k">=</span> sin
funcs[<span class="pl-c1">:cos</span>] <span class="pl-k">=</span> cos
funcs[<span class="pl-c1">:square</span>] <span class="pl-k">=</span> x <span class="pl-k">-&gt;</span> x <span class="pl-k">*</span> x
funcs[<span class="pl-c1">:lookup</span>] <span class="pl-k">=</span> <span class="pl-c1">Dict</span>((<span class="pl-c1">:foo</span>,) <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>, (<span class="pl-c1">:bar</span>,) <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>)

<span class="pl-c1">@assert</span> <span class="pl-c1">resolve</span>(<span class="pl-c1">@julog</span>(<span class="pl-c1">sin</span>(pi <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">==</span> <span class="pl-c1">1</span>), Clause[], funcs<span class="pl-k">=</span>funcs)[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">true</span>
<span class="pl-c1">@assert</span> <span class="pl-c1">resolve</span>(<span class="pl-c1">@julog</span>(<span class="pl-c1">cos</span>(pi) <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span>), Clause[], funcs<span class="pl-k">=</span>funcs)[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">true</span>
<span class="pl-c1">@assert</span> <span class="pl-c1">resolve</span>(<span class="pl-c1">@julog</span>(<span class="pl-c1">lookup</span>(foo) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>), Clause[], funcs<span class="pl-k">=</span>funcs)[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">true</span>
<span class="pl-c1">@assert</span> <span class="pl-c1">resolve</span>(<span class="pl-c1">@julog</span>(<span class="pl-c1">lookup</span>(bar) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>), Clause[], funcs<span class="pl-k">=</span>funcs)[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">true</span></pre></div>
<p>See <a href="test/custom_funcs.jl"><code>test/custom_funcs.jl</code></a> for more examples.</p>
<h2><a id="user-content-built-in-predicates" class="anchor" aria-hidden="true" href="#built-in-predicates"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Built-in Predicates</h2>
<p><code>Julog</code> provides a number of built-in predicates for control-flow and convenience. Some of these are also part of ISO Prolog, but may not share the exact same behavior.</p>
<ul>
<li><code>cons</code> and <code>cend</code> are reserved for lists. <code>[x, y, z]</code> is equivalent to <code>cons(x, cons(y, cons(z, cend()))</code>.</li>
<li><code>true</code> and <code>false</code> operate as one might expect.</li>
<li><code>and(A, B, C, ...)</code> is equivalent to <code>A &amp; B &amp; C &amp; ...</code> in the body of an Julog clause.</li>
<li><code>or(A, B, C, ...)</code> is equivalent to <code>A ; B ; C ; ...</code> in Prolog-syntax.</li>
<li><code>not(X)</code> / <code>!X</code> is true if X cannot be proven (i.e. negation as failure).</li>
<li><code>unifies(X, Y)</code> / <code>X ≐ Y</code> is true if <code>X</code> unifies with <code>Y</code>.</li>
<li><code>exists(Cond, Act)</code> is true if <code>Act</code> is true for at least one binding of <code>Cond</code>.</li>
<li><code>forall(Cond, Act)</code> is true if <code>Act</code> is true for all possible bindings of <code>Cond</code> (beware infinite loops).</li>
<li><code>imply(Cond, Act)</code> / <code>Cond =&gt; Act</code> is true if either <code>Cond</code> is false, or both <code>Cond</code> and <code>Act</code> are true.</li>
<li><code>findall(Template, Cond, List)</code> finds all instances where <code>Cond</code> is true, substitutes any variables into <code>Template</code>, and unifies <code>List</code> with the result</li>
<li><code>countall(Cond, N)</code> counts the number of proofs of <code>Cond</code> and unifies <code>N</code> with the result</li>
<li><code>fail</code> causes the current goal to fail (equivalent to <code>false</code>).</li>
<li><code>cut</code> causes the current goal to succeed and suppresses all other goals. However, this does not have the same effects as in Prolog because <code>Julog</code> uses breadth-first search during SLD-resolution, unlike most Prolog implementations, which use depth-first search.</li>
</ul>
<p>See <a href="test/builtins.jl"><code>test/builtins.jl</code></a> for usage examples.</p>
<h2><a id="user-content-conversion-utilities" class="anchor" aria-hidden="true" href="#conversion-utilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conversion Utilities</h2>
<p>Julog provides some support for converting and manipulating logical formulae,
for example, conversion to negation, conjunctive, or disjunctive normal form:</p>
<div class="highlight highlight-source-julia"><pre>julia<span class="pl-k">&gt;</span> formula <span class="pl-k">=</span> <span class="pl-c1">@julog</span> <span class="pl-c1">and</span>(<span class="pl-c1">not</span>(<span class="pl-c1">and</span>(a, <span class="pl-c1">not</span>(b))), c)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">to_nnf</span>(formula)
<span class="pl-c1">and</span>(<span class="pl-c1">or</span>(<span class="pl-c1">not</span>(a), b), c)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">to_cnf</span>(formula)
<span class="pl-c1">and</span>(<span class="pl-c1">or</span>(<span class="pl-c1">not</span>(a), b), <span class="pl-c1">or</span>(c))
julia<span class="pl-k">&gt;</span> <span class="pl-c1">to_dnf</span>(formula)
<span class="pl-c1">or</span>(<span class="pl-c1">and</span>(<span class="pl-c1">not</span>(a), c), <span class="pl-c1">and</span>(b, c))</pre></div>
<p>This can be useful for downstream applications, such as classical planning.
Note however that these conversions do not handle the implicit existential
quantification in Prolog semantics, and hence are not guaranteed to preserve equivalence when free variables are involved. In particular, care should be
taken with negations of conjunctions of unbound predicates. For example,
the following expression states that "All ravens are black.":</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@julog</span> <span class="pl-c1">not</span>(<span class="pl-c1">and</span>(<span class="pl-c1">raven</span>(X), <span class="pl-c1">not</span>(<span class="pl-c1">black</span>(X))))</pre></div>
<p>However, <code>to_dnf</code> doesn't handle the implied existential quantifier over <code>X</code>,
and gives the non-equivalent statement "Either there are no ravens, or there
exist black things, or both.":</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">@julog</span> <span class="pl-c1">or</span>(<span class="pl-c1">and</span>(<span class="pl-c1">not</span>(<span class="pl-c1">raven</span>(X))), <span class="pl-c1">and</span>(<span class="pl-c1">black</span>(X)))</pre></div>
<h2><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Acknowledgements</h2>
<p>This implementation was made with reference to Chris Meyer's <a href="http://www.openbookproject.net/py4fun/prolog/intro.html" rel="nofollow">Python interpreter for Prolog</a>, as well as the unification and SLD-resolution algorithms presented in <a href="https://link.springer.com/content/pdf/bbm%3A978-3-642-41464-0%2F1.pdf" rel="nofollow">An Introduction to Prolog</a> by Pierre M. Nugues.</p>
</article></div>