<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-pddljl" class="anchor" aria-hidden="true" href="#pddljl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PDDL.jl</h1>
<p dir="auto"><a href="https://juliaplanners.github.io/PDDL.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Documentation (Stable)" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://juliaplanners.github.io/PDDL.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="Documentation (Latest)" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/259c4525fc3f46ace0f17a693168d73f1b9e8c2f255c0ba185733898983f8c18/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f4a756c6961506c616e6e6572732f5044444c2e6a6c2f43492e796d6c3f6272616e63683d6d6173746572"><img src="https://camo.githubusercontent.com/259c4525fc3f46ace0f17a693168d73f1b9e8c2f255c0ba185733898983f8c18/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f4a756c6961506c616e6e6572732f5044444c2e6a6c2f43492e796d6c3f6272616e63683d6d6173746572" alt="GitHub Workflow Status" data-canonical-src="https://img.shields.io/github/actions/workflow/status/JuliaPlanners/PDDL.jl/CI.yml?branch=master" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b2b0f2982c001932c6b33621daeba5c2794718ec582c46fac673f1edeb1f585b/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f4a756c6961506c616e6e6572732f5044444c2e6a6c"><img src="https://camo.githubusercontent.com/b2b0f2982c001932c6b33621daeba5c2794718ec582c46fac673f1edeb1f585b/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f4a756c6961506c616e6e6572732f5044444c2e6a6c" alt="GitHub release (latest SemVer)" data-canonical-src="https://img.shields.io/github/v/release/JuliaPlanners/PDDL.jl" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/171388c9b7a55b32e67ab601edd0b58983f2f98d5ba2ce880fa6b1748e8e68dc/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f4a756c6961506c616e6e6572732f5044444c2e6a6c3f636f6c6f723d6c6967687467726579"><img src="https://camo.githubusercontent.com/171388c9b7a55b32e67ab601edd0b58983f2f98d5ba2ce880fa6b1748e8e68dc/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f4a756c6961506c616e6e6572732f5044444c2e6a6c3f636f6c6f723d6c6967687467726579" alt="GitHub" data-canonical-src="https://img.shields.io/github/license/JuliaPlanners/PDDL.jl?color=lightgrey" style="max-width: 100%;"></a></p>
<p dir="auto">A Julia parser, interpreter, and compiler interface for the Planning Domain Definition Language (PDDL).</p>
<p dir="auto">Planners not included, but see <a href="https://github.com/JuliaPlanners/SymbolicPlanners.jl"><code>SymbolicPlanners.jl</code></a>.</p>
<p dir="auto">If you use this software, please cite:</p>
<blockquote>
<p dir="auto">T. Zhi-Xuan, <a href="https://dspace.mit.edu/handle/1721.1/143179" rel="nofollow">“PDDL.jl: An Extensible Interpreter and Compiler Interface for Fast and Flexible AI Planning”</a>, MS Thesis, Massachusetts Institute of Technology, 2022.</p>
</blockquote>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Press <code>]</code> at the Julia REPL to enter the package manager, then run:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add PDDL"><pre class="notranslate"><code>add PDDL
</code></pre></div>
<p dir="auto">For the latest development version, run:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="add https://github.com/JuliaPlanners/PDDL.jl.git"><pre class="notranslate"><code>add https://github.com/JuliaPlanners/PDDL.jl.git
</code></pre></div>
<h2 dir="auto"><a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features</h2>
<ul dir="auto">
<li>Parsing and writing of PDDL domain and problem files</li>
<li>A high-level symbolic planning API</li>
<li>Execution of PDDL actions and plans</li>
<li>Abstract interpretation of PDDL semantics</li>
<li>Domain grounding and/or compilation for increased performance</li>
<li>Support for the following PDDL requirements:
<ul dir="auto">
<li><code>:strips</code> - the most restricted functionality</li>
<li><code>:typing</code> - (hierarchically) typed objects</li>
<li><code>:equality</code> - comparing equality <code>=</code> of objects</li>
<li><code>:quantified-preconditions</code> - <code>forall</code> and <code>exists</code></li>
<li><code>:disjunctive-preconditions</code> - <code>or</code> predicates</li>
<li><code>:conditional-effects</code> - <code>when</code> and <code>forall</code> effects</li>
<li><code>:adl</code> - shorthand for the above 6 requirements</li>
<li><code>:constants</code> - domain constants</li>
<li><code>:fluents</code> - numeric fluents</li>
<li><code>:derived-predicates</code> - a.k.a. domain axioms</li>
</ul>
</li>
</ul>
<p dir="auto"><code>PDDL.jl</code> does not include any planning algorithms. Rather, it aims to provide an
interface so that planners for PDDL domains can easily be written in Julia, as
in <a href="https://github.com/JuliaPlanners/SymbolicPlanners.jl"><code>SymbolicPlanners.jl</code></a>.</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<p dir="auto"><code>PDDL.jl</code> can be used to parse domains and planning problems written in PDDL.
For example, the following file describes a world of square tiles which are either
white or black, arranged in a grid. To change the color of the tiles one can flip
either a row of tiles or a column of tiles.</p>
<div class="highlight highlight-source-clojure notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content=";; Grid flipping domain with conditional effects and universal quantifiers
(define (domain flip)
  (:requirements :adl :typing)
  (:types row column)
  (:predicates (white ?r - row ?c - column))
  (:action flip_row
    :parameters (?r - row)
    :effect (forall (?c - column)
                    (and (when (white ?r ?c) (not (white ?r ?c)))
                         (when (not (white ?r ?c)) (white ?r ?c))))
  )
  (:action flip_column
    :parameters (?c - column)
    :effect (forall (?r - row)
                    (and (when (white ?r ?c) (not (white ?r ?c)))
                         (when (not (white ?r ?c)) (white ?r ?c))))
  )
)"><pre><span class="pl-c"><span class="pl-c">;</span>; Grid flipping domain with conditional effects and universal quantifiers</span>
(<span class="pl-k">define</span> (<span class="pl-en">domain</span> flip)
  (<span class="pl-c1">:requirements</span> <span class="pl-c1">:adl</span> <span class="pl-c1">:typing</span>)
  (<span class="pl-c1">:types</span> row column)
  (<span class="pl-c1">:predicates</span> (<span class="pl-en">white</span> ?r - row ?c - column))
  (<span class="pl-c1">:action</span> flip_row
    <span class="pl-c1">:parameters</span> (<span class="pl-en">?r</span> - row)
    <span class="pl-c1">:effect</span> (<span class="pl-en">forall</span> (<span class="pl-en">?c</span> - column)
                    (<span class="pl-en">and</span> (<span class="pl-k">when</span> (<span class="pl-en">white</span> ?r ?c) (<span class="pl-en">not</span> (<span class="pl-en">white</span> ?r ?c)))
                         (<span class="pl-k">when</span> (<span class="pl-en">not</span> (<span class="pl-en">white</span> ?r ?c)) (<span class="pl-en">white</span> ?r ?c))))
  )
  (<span class="pl-c1">:action</span> flip_column
    <span class="pl-c1">:parameters</span> (<span class="pl-en">?c</span> - column)
    <span class="pl-c1">:effect</span> (<span class="pl-en">forall</span> (<span class="pl-en">?r</span> - row)
                    (<span class="pl-en">and</span> (<span class="pl-k">when</span> (<span class="pl-en">white</span> ?r ?c) (<span class="pl-en">not</span> (<span class="pl-en">white</span> ?r ?c)))
                         (<span class="pl-k">when</span> (<span class="pl-en">not</span> (<span class="pl-en">white</span> ?r ?c)) (<span class="pl-en">white</span> ?r ?c))))
  )
)</pre></div>
<p dir="auto">A corresponding problem in this domain might be to make all the tiles white,
when the initial state is an alternating pattern of black and white tiles in a 3x3 grid:</p>
<div class="highlight highlight-source-clojure notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content=";; Grid flipping problem
(define (problem flip-problem)
  (:domain flip)
  (:objects r1 r2 r3 - row c1 c2 c3 - column)
  (:init (white r1 c2)
         (white r2 c1)
         (white r2 c3)
         (white r3 c2))
  (:goal (forall (?r - row ?c - column) (white ?r ?c)))
)"><pre><span class="pl-c"><span class="pl-c">;</span>; Grid flipping problem</span>
(<span class="pl-k">define</span> (<span class="pl-en">problem</span> flip-problem)
  (<span class="pl-c1">:domain</span> flip)
  (<span class="pl-c1">:objects</span> r1 r2 r3 - row c1 c2 c3 - column)
  (<span class="pl-c1">:init</span> (<span class="pl-en">white</span> r1 c2)
         (<span class="pl-en">white</span> r2 c1)
         (<span class="pl-en">white</span> r2 c3)
         (<span class="pl-en">white</span> r3 c2))
  (<span class="pl-c1">:goal</span> (<span class="pl-en">forall</span> (<span class="pl-en">?r</span> - row ?c - column) (<span class="pl-en">white</span> ?r ?c)))
)</pre></div>
<p dir="auto">With <code>PDDL.jl</code>, we can parse each of these files into Julia constructs:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="domain = load_domain(&quot;flip-domain.pddl&quot;)
problem = load_problem(&quot;flip-problem.pddl&quot;)"><pre>domain <span class="pl-k">=</span> <span class="pl-c1">load_domain</span>(<span class="pl-s"><span class="pl-pds">"</span>flip-domain.pddl<span class="pl-pds">"</span></span>)
problem <span class="pl-k">=</span> <span class="pl-c1">load_problem</span>(<span class="pl-s"><span class="pl-pds">"</span>flip-problem.pddl<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Actions defined by the domain can be executed to solve the problem:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="state = initstate(domain, problem)
state = execute(domain, state, pddl&quot;(flip_column c1)&quot;)
state = execute(domain, state, pddl&quot;(flip_column c3)&quot;)
state = execute(domain, state, pddl&quot;(flip_row r2)&quot;)"><pre>state <span class="pl-k">=</span> <span class="pl-c1">initstate</span>(domain, problem)
state <span class="pl-k">=</span> <span class="pl-c1">execute</span>(domain, state, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">pddl</span>"</span>(flip_column c1)<span class="pl-pds">"</span></span>)
state <span class="pl-k">=</span> <span class="pl-c1">execute</span>(domain, state, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">pddl</span>"</span>(flip_column c3)<span class="pl-pds">"</span></span>)
state <span class="pl-k">=</span> <span class="pl-c1">execute</span>(domain, state, <span class="pl-s"><span class="pl-pds"><span class="pl-c1">pddl</span>"</span>(flip_row r2)<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">We can then check that the problem is successfully solved in the final state:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@assert satisfy(domain, state, problem.goal) == true"><pre><span class="pl-c1">@assert</span> <span class="pl-c1">satisfy</span>(domain, state, problem<span class="pl-k">.</span>goal) <span class="pl-k">==</span> <span class="pl-c1">true</span></pre></div>
<p dir="auto">More examples can be found in the <a href="test"><code>test</code></a> directory. Documentation can be found <a href="https://juliaplanners.github.io/PDDL.jl/stable" rel="nofollow">here</a>.</p>
<h2 dir="auto"><a id="user-content-interface" class="anchor" aria-hidden="true" href="#interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interface</h2>
<p dir="auto">PDDL.jl exposes a high-level interface for interacting with planning domains and problems, which can be used to implement planning algorithms and other downstream applications. Full documentation of interface methods can be found <a href="https://juliaplanners.github.io/PDDL.jl/stable/ref/interface/#Interface-Functions" rel="nofollow">here</a>. A summary is provided below:</p>
<ul dir="auto">
<li><code>satisfy</code> checks whether a logical formula is satisfied (or satisfiable) in a PDDL state.</li>
<li><code>satisfiers</code> returns all satisfying substitutions to free variables in a logical formula.</li>
<li><code>evaluate</code> returns the value of a functional or logical expression within the context of a state.</li>
<li><code>initstate</code> constructs an initial state from a PDDL domain and problem.</li>
<li><code>goalstate</code> constructs a (partial) goal state from a PDDL domain and problem</li>
<li><code>transition</code> returns the successor to a state after applying an action or set of actions.</li>
<li><code>execute</code> applies an action to a state, returning the resulting state.</li>
<li><code>regress</code> computes the pre-image of an action with respect to a state.</li>
<li><code>available</code> checks whether an action can be executed in a state.
<ul dir="auto">
<li>If no action is specified, it returns the list of available actions.</li>
</ul>
</li>
<li><code>relevant</code> checks whether an action can lead to a state.
<ul dir="auto">
<li>If no action is specified, it returns the list of relevant actions.</li>
</ul>
</li>
</ul>
</article></div>