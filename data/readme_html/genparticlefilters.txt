<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-genparticlefiltersjl" class="anchor" aria-hidden="true" href="#genparticlefiltersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GenParticleFilters.jl</h1>
<p dir="auto"><a href="https://probcomp.github.io/GenParticleFilters.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Documentation (Stable)" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://probcomp.github.io/GenParticleFilters.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="Documentation (Latest)" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6d66717cbd4aceb70f925e9837b3052d632fcfda09d995edccba1874fef4d4ec/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f70726f62636f6d702f47656e5061727469636c6546696c746572732e6a6c2f43492e796d6c3f6272616e63683d6d6173746572"><img src="https://camo.githubusercontent.com/6d66717cbd4aceb70f925e9837b3052d632fcfda09d995edccba1874fef4d4ec/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f70726f62636f6d702f47656e5061727469636c6546696c746572732e6a6c2f43492e796d6c3f6272616e63683d6d6173746572" alt="GitHub Workflow Status" data-canonical-src="https://img.shields.io/github/actions/workflow/status/probcomp/GenParticleFilters.jl/CI.yml?branch=master" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2d4c2517e7d8761c1a18db0e4744e871251e83f948ef6ab8ccbb1048720be7ce/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f70726f62636f6d702f47656e5061727469636c6546696c746572732e6a6c"><img src="https://camo.githubusercontent.com/2d4c2517e7d8761c1a18db0e4744e871251e83f948ef6ab8ccbb1048720be7ce/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f70726f62636f6d702f47656e5061727469636c6546696c746572732e6a6c" alt="GitHub release (latest SemVer)" data-canonical-src="https://img.shields.io/github/v/release/probcomp/GenParticleFilters.jl" style="max-width: 100%;"></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6184fbedb72a2faa513c82912eb70c3298c5fbcbb36e1e0c6f046257f8fc7994/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f70726f62636f6d702f47656e5061727469636c6546696c746572732e6a6c3f636f6c6f723d6c6967687467726579"><img src="https://camo.githubusercontent.com/6184fbedb72a2faa513c82912eb70c3298c5fbcbb36e1e0c6f046257f8fc7994/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f70726f62636f6d702f47656e5061727469636c6546696c746572732e6a6c3f636f6c6f723d6c6967687467726579" alt="License" data-canonical-src="https://img.shields.io/github/license/probcomp/GenParticleFilters.jl?color=lightgrey" style="max-width: 100%;"></a></p>
<p dir="auto">Building blocks for simple and advanced particle filtering in <a href="https://www.gen.dev/" rel="nofollow">Gen</a>, a general-purpose probabilistic programming system. Documentation is <a href="https://probcomp.github.io/GenParticleFilters.jl/" rel="nofollow">available here</a>.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Press <code>]</code> at the Julia REPL to enter the package manager, then run:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add GenParticleFilters"><pre>add GenParticleFilters</pre></div>
<p dir="auto">To install the development version, run:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add https://github.com/probcomp/GenParticleFilters.jl.git"><pre>add https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>probcomp<span class="pl-k">/</span>GenParticleFilters<span class="pl-k">.</span>jl<span class="pl-k">.</span>git</pre></div>
<h2 dir="auto"><a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features</h2>
<p dir="auto">In addition to basic particle filtering functionality (i.e., initializing a particle filter and updating it with new observations), this package provides support for:</p>
<ul dir="auto">
<li>Particle updates that allow discarding of old choices, provided that
backward kernels are specified <a href="#1">[1]</a></li>
<li>Multiple resampling methods, including variance-reducing methods such as residual resampling <a href="#2">[2]</a></li>
<li>Custom priority weights for resampling, to control the aggressiveness of pruning <a href="#3">[3]</a></li>
<li>Metropolis-Hasting (i.e. move-accept) rejuvenation moves, to increase particle diversity <a href="#4">[4]</a></li>
<li>Move-reweight rejuvenation, which increases particle diversity while reweighting particles <a href="#5">[5]</a></li>
<li>Sequential Monte Carlo over a series of distinct models, via <a href="https://www.gen.dev/stable/ref/trace_translators/" rel="nofollow">trace translators</a> <a href="#6">[6]</a></li>
<li>SMCP³, a method which generalizes <a href="#1">[1]</a>, <a href="#5">[5]</a> and <a href="#6">[6]</a> through particle updates that support auxiliary randomness and deterministic transformations  <a href="#7">[7]</a></li>
<li>Particle filter resizing methods, which can be used in online adaptation of the total number of particles <a href="#8">[8]</a></li>
<li>Utility functions to compute distributional statistics (e.g. mean and variance) for the inferred latent variables</li>
</ul>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<p dir="auto">Suppose we are trying to infer the position <code>y</code> of an object that is either staying still or moving sinusoidally, given noisy measurements <code>y_obs</code>. We can write a model of this object's motion as an <code>@gen</code> function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@gen function object_motion(T::Int)
    y, moving = 0, false
    y_obs_all = Float64[]
    for t=1:T
        moving = {t =&gt; :moving} ~ bernoulli(moving ? 0.75 : 0.25)
        vel_y = moving ? sin(t) : 0.0
        y = {t =&gt; :y} ~ normal(y + vel_y, 0.01)
        y_obs = {t =&gt; :y_obs} ~ normal(y, 0.25)
        push!(y_obs_all, y_obs)
    end
    return y_obs_all
end"><pre><span class="pl-c1">@gen</span> <span class="pl-k">function</span> <span class="pl-en">object_motion</span>(T<span class="pl-k">::</span><span class="pl-c1">Int</span>)
    y, moving <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-c1">false</span>
    y_obs_all <span class="pl-k">=</span> Float64[]
    <span class="pl-k">for</span> t<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>T
        moving <span class="pl-k">=</span> {t <span class="pl-k">=&gt;</span> <span class="pl-c1">:moving</span>} <span class="pl-k">~</span> <span class="pl-c1">bernoulli</span>(moving <span class="pl-k">?</span> <span class="pl-c1">0.75</span> <span class="pl-k">:</span> <span class="pl-c1">0.25</span>)
        vel_y <span class="pl-k">=</span> moving <span class="pl-k">?</span> <span class="pl-c1">sin</span>(t) <span class="pl-k">:</span> <span class="pl-c1">0.0</span>
        y <span class="pl-k">=</span> {t <span class="pl-k">=&gt;</span> <span class="pl-c1">:y</span>} <span class="pl-k">~</span> <span class="pl-c1">normal</span>(y <span class="pl-k">+</span> vel_y, <span class="pl-c1">0.01</span>)
        y_obs <span class="pl-k">=</span> {t <span class="pl-k">=&gt;</span> <span class="pl-c1">:y_obs</span>} <span class="pl-k">~</span> <span class="pl-c1">normal</span>(y, <span class="pl-c1">0.25</span>)
        <span class="pl-c1">push!</span>(y_obs_all, y_obs)
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> y_obs_all
<span class="pl-k">end</span></pre></div>
<p dir="auto">We can then construct a particle filter with resampling and rejuvenation moves, in order to infer both the object's position <code>y</code> and whether the object was <code>moving</code> at each timestep.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function particle_filter(observations, n_particles, ess_thresh=0.5)
    # Initialize particle filter with first observation
    n_obs = length(observations)
    obs_choices = [choicemap((t =&gt; :y_obs, observations[t])) for t=1:n_obs]
    state = pf_initialize(object_motion, (1,), obs_choices[1], n_particles)
    # Iterate across timesteps
    for t=2:n_obs
        # Resample and rejuvenate if the effective sample size is too low
        if effective_sample_size(state) &lt; ess_thresh * n_particles
            # Perform residual resampling, pruning low-weight particles
            pf_resample!(state, :residual)
            # Perform a rejuvenation move on past choices
            rejuv_sel = select(t-1=&gt;:moving, t-1=&gt;:y, t=&gt;:moving, t=&gt;:y)
            pf_rejuvenate!(state, mh, (rejuv_sel,))
        end
        # Update filter state with new observation at timestep t
        pf_update!(state, (t,), (UnknownChange(),), obs_choices[t])
    end
    return state
end"><pre><span class="pl-k">function</span> <span class="pl-en">particle_filter</span>(observations, n_particles, ess_thresh<span class="pl-k">=</span><span class="pl-c1">0.5</span>)
    <span class="pl-c"><span class="pl-c">#</span> Initialize particle filter with first observation</span>
    n_obs <span class="pl-k">=</span> <span class="pl-c1">length</span>(observations)
    obs_choices <span class="pl-k">=</span> [<span class="pl-c1">choicemap</span>((t <span class="pl-k">=&gt;</span> <span class="pl-c1">:y_obs</span>, observations[t])) <span class="pl-k">for</span> t<span class="pl-k">=</span><span class="pl-c1">1</span><span class="pl-k">:</span>n_obs]
    state <span class="pl-k">=</span> <span class="pl-c1">pf_initialize</span>(object_motion, (<span class="pl-c1">1</span>,), obs_choices[<span class="pl-c1">1</span>], n_particles)
    <span class="pl-c"><span class="pl-c">#</span> Iterate across timesteps</span>
    <span class="pl-k">for</span> t<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">:</span>n_obs
        <span class="pl-c"><span class="pl-c">#</span> Resample and rejuvenate if the effective sample size is too low</span>
        <span class="pl-k">if</span> <span class="pl-c1">effective_sample_size</span>(state) <span class="pl-k">&lt;</span> ess_thresh <span class="pl-k">*</span> n_particles
            <span class="pl-c"><span class="pl-c">#</span> Perform residual resampling, pruning low-weight particles</span>
            <span class="pl-c1">pf_resample!</span>(state, <span class="pl-c1">:residual</span>)
            <span class="pl-c"><span class="pl-c">#</span> Perform a rejuvenation move on past choices</span>
            rejuv_sel <span class="pl-k">=</span> <span class="pl-c1">select</span>(t<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">=&gt;</span><span class="pl-c1">:moving</span>, t<span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">=&gt;</span><span class="pl-c1">:y</span>, t<span class="pl-k">=&gt;</span><span class="pl-c1">:moving</span>, t<span class="pl-k">=&gt;</span><span class="pl-c1">:y</span>)
            <span class="pl-c1">pf_rejuvenate!</span>(state, mh, (rejuv_sel,))
        <span class="pl-k">end</span>
        <span class="pl-c"><span class="pl-c">#</span> Update filter state with new observation at timestep t</span>
        <span class="pl-c1">pf_update!</span>(state, (t,), (<span class="pl-c1">UnknownChange</span>(),), obs_choices[t])
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> state
<span class="pl-k">end</span></pre></div>
<p dir="auto">We can then run the particle filter on a sequence of observations, e.g., of the
object staying still for 5 timesteps then oscillating for 5 timesteps:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Generate synthetic dataset of object motion
constraints = choicemap([(t =&gt; :moving, t &gt; 5) for t in 1:10]...)
trace, _ = generate(object_motion, (10,), constraints)
observations = get_retval(trace)
# Run particle filter with 100 particles
state = particle_filter(observations, 100)"><pre><span class="pl-c"><span class="pl-c">#</span> Generate synthetic dataset of object motion</span>
constraints <span class="pl-k">=</span> <span class="pl-c1">choicemap</span>([(t <span class="pl-k">=&gt;</span> <span class="pl-c1">:moving</span>, t <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>) <span class="pl-k">for</span> t <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>]<span class="pl-k">.</span><span class="pl-k">..</span>)
trace, _ <span class="pl-k">=</span> <span class="pl-c1">generate</span>(object_motion, (<span class="pl-c1">10</span>,), constraints)
observations <span class="pl-k">=</span> <span class="pl-c1">get_retval</span>(trace)
<span class="pl-c"><span class="pl-c">#</span> Run particle filter with 100 particles</span>
state <span class="pl-k">=</span> <span class="pl-c1">particle_filter</span>(observations, <span class="pl-c1">100</span>)</pre></div>
<p dir="auto">We can then use <code>mean</code> and <code>var</code> to compute the empirical posterior mean
and variance for variables of interest:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; mean(state, 5=&gt;:moving) |&gt; x-&gt;round(x, digits=2) # Prob. motion at t=5
0.07
julia&gt; var(state, 5=&gt;:moving) |&gt; x-&gt;round(x, digits=2) # Variance at t=5
0.07
julia&gt; mean(state, 6=&gt;:moving) |&gt; x-&gt;round(x, digits=2) # Prob. motion at t=6
0.95
julia&gt; var(state, 6=&gt;:moving) |&gt; x-&gt;round(x, digits=2) # Variance at t=6
0.05"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">mean</span>(state, <span class="pl-c1">5</span><span class="pl-k">=&gt;</span><span class="pl-c1">:moving</span>) <span class="pl-k">|&gt;</span> x<span class="pl-k">-&gt;</span><span class="pl-c1">round</span>(x, digits<span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> Prob. motion at t=5</span>
<span class="pl-c1">0.07</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">var</span>(state, <span class="pl-c1">5</span><span class="pl-k">=&gt;</span><span class="pl-c1">:moving</span>) <span class="pl-k">|&gt;</span> x<span class="pl-k">-&gt;</span><span class="pl-c1">round</span>(x, digits<span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> Variance at t=5</span>
<span class="pl-c1">0.07</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">mean</span>(state, <span class="pl-c1">6</span><span class="pl-k">=&gt;</span><span class="pl-c1">:moving</span>) <span class="pl-k">|&gt;</span> x<span class="pl-k">-&gt;</span><span class="pl-c1">round</span>(x, digits<span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> Prob. motion at t=6</span>
<span class="pl-c1">0.95</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">var</span>(state, <span class="pl-c1">6</span><span class="pl-k">=&gt;</span><span class="pl-c1">:moving</span>) <span class="pl-k">|&gt;</span> x<span class="pl-k">-&gt;</span><span class="pl-c1">round</span>(x, digits<span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> Variance at t=6</span>
<span class="pl-c1">0.05</span></pre></div>
<p dir="auto">We see that the filter accurately infers a change in motion from <code>t=5</code> to <code>t=6</code>.</p>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto"><a id="user-content-1">[1]</a> P. D. Moral, A. Doucet, and A. Jasra, “Sequential Monte Carlo samplers,” Journal of the Royal Statistical Society: Series B (Statistical Methodology), vol. 68, no. 3, pp. 411–436, 2006.</p>
<p dir="auto"><a id="user-content-2">[2]</a> R. Douc and O. Cappé, "Comparison of resampling schemes for particle filtering," in ISPA 2005. Proceedings of the 4th International Symposium on Image and Signal Processing and Analysis, 2005., 2005, pp. 64-69.</p>
<p dir="auto"><a id="user-content-3">[3]</a> R. Chen, “Sequential Monte Carlo methods and their applications,” in Markov Chain Monte Carlo, vol. Volume 7, 0 vols., Singapore University Press, 2005, pp. 147–182.</p>
<p dir="auto"><a id="user-content-4">[4]</a> N. Chopin, “A sequential particle filter method for static models,” Biometrika 89.3, 2000, pp. 539-552.</p>
<p dir="auto"><a id="user-content-5">[5]</a> R. A. G. Marques and G. Storvik, "Particle move-reweighting strategies for online inference," Preprint series. Statistical Research Report, 2013.</p>
<p dir="auto"><a id="user-content-6">[6]</a> M. Cusumano-Towner, B. Bichsel, T. Gehr, M. Vechev, and V. K. Mansinghka, “Incremental inference for probabilistic programs,” in Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation, Philadelphia PA USA, Jun. 2018, pp. 571–585.</p>
<p dir="auto"><a id="user-content-7">[7]</a> Lew, A. K., Matheos, G., Zhi-Xuan, T., Ghavamizadeh, M., Gothoskar, N., Russell, S., and Mansinghka, V. K. "SMCP3: Sequential Monte Carlo with Probabilistic Program Proposals." AISTATS, 2023.</p>
<p dir="auto"><a id="user-content-8">[8]</a> V. Elvira, J. Míguez and P. M. Djurić, "Adapting the Number of Particles in Sequential Monte Carlo Methods Through an Online Scheme for Convergence Assessment," in IEEE Transactions on Signal Processing, vol. 65, no. 7, pp. 1781-1794, 1 April 2017, doi: 10.1109/TSP.2016.2637324.</p>
</article></div>