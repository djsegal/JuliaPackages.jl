<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-powerseriesjl" class="anchor" aria-hidden="true" href="#powerseriesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PowerSeries.jl</h1>
<p dir="auto">Truncated Power Series for Julia</p>
<p dir="auto"><a href="https://travis-ci.org/jwmerrill/PowerSeries.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/86f0bf1f5907ecc58daef00622def2dc80e2981d7ebcaeb505e15e5ed222dc68/68747470733a2f2f7472617669732d63692e6f72672f6a776d657272696c6c2f506f7765725365726965732e6a6c2e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/jwmerrill/PowerSeries.jl.png?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">PowerSeries.jl defines Series types that represent truncated power series by their coefficients. You can do arithmetic on Series and apply functions to series just as you would Real or Complex numbers. Here's an example session:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using PowerSeries

# Represent the series 1.0 + 1.0*x - 2.0*x^2
julia&gt; a = series(1.0, 1.0, -2.0)
Series2{Float64}(1.0,1.0,-2.0)

# Represent the series 1.0 + 0.0*x + 1.0*x^2
julia&gt; b = series(1.0, 0.0, 1.0)
Series2{Float64}(1.0,0.0,1.0)

# Series add linearly
julia&gt; a+b
Series2{Float64}(2.0,1.0,-1.0)

# The output of series operations is truncated to match the input size.
# Represents (1+x-2x^2)(1 + x^2) = 1+x-x^2+o(x^3)
julia&gt; a*b
Series2{Float64}(1.0,1.0,-1.0)

# Extract the constant term of a series
julia&gt; constant(a)
1.0

# Functions with known derivatives can easily be overloaded to operate on
# power series.
# You can generate the taylor series of a function about a point x up to
# e.g. 5th order by computing f(Series(x, 1.0, 0.0, 0.0, 0.0, 0.0))
julia&gt; x = series(0.0, 1.0, 0.0, 0.0, 0.0, 0.0)
Series5{Float64}(0.0,1.0,0.0,0.0,0.0,0.0)

julia&gt; sin(x)
Series5{Float64}(0.0,1.0,0.0,-0.16666666666666666,0.0,0.008333333333333333)

julia&gt; log(1 + x)
Series5{Float64}(0.0,1.0,-0.5,0.3333333333333333,-0.25,0.2)

julia&gt; 1/(1 - x)
Series5{Float64}(1.0,1.0,1.0,1.0,1.0,1.0)

# These are numerically equal to their series definitions
julia&gt; series(0.0, 1.0, 0.0, -1.0/6.0, 0.0, 1.0/120)
Series5{Float64}(0.0,1.0,0.0,-0.16666666666666666,0.0,0.008333333333333333)

julia&gt; series(0.0, 1.0, -1.0/2, 1.0/3, -1.0/4, 1.0/5)
Series5{Float64}(0.0,1.0,-0.5,0.3333333333333333,-0.25,0.2)

# Take the derivative of a series
julia&gt; polyder(a)
Series1{Float64}(1.0,-4.0)

# Integrate a series term by term. Note that by convention, the constant term is 0.
julia&gt; polyint(a)
Series3{Float64}(0.0,1.0,0.5,-0.6666666666666666)

julia&gt; @assert polyder(polyint(a)) == a

# Truncate a series to a series 1 order lower
julia&gt; restrict(a)
Series1{Float64}(1.0,1.0)

# Restricting a first order series returns a real number
julia&gt; restrict(restrict(a))
1.0

# polyint, polydir, and restrict are the only operations that change the order of
# a series. Arithmetic on series of different orders is disallowed because
# relevant terms in the lower order series may have been dropped at intermediate
# steps.
julia&gt; series(1.0, 1.0) + series(1.0, 2.0, 3.0)
ERROR: no promotion exists for Series1{Float64} and Series2{Float64}
 in + at promotion.jl:158

# Truncated power series offer one of the best ways to take multiple derivatives
# of generic mathematical functions.
julia&gt; f(x) = exp(-x^2)
f (generic function with 1 method)

julia&gt; f2(x) = polyder(polyder(f(series(x, 1, 0))))
f2 (generic function with 1 method)

julia&gt; f2(2.0)
0.25641894444227853

# Compare to the symbolic second derivative
julia&gt; let x = 2.0; -2exp(-x^2)+4x^2*exp(-x^2); end
0.25641894444227853

# PowerSeries comes with types defined for series up to order 7. By default,
# trying to construct a higher order series is a type error.
julia&gt; series(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
ERROR: no method series(Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64)

# If you want to work with higher order series, you can generate types up
# to a given order with PowerSeries.generate(order)
julia&gt; PowerSeries.generate(9)
julia&gt; series(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
Series9{Int64}(0,1,2,3,4,5,6,7,8,9)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> PowerSeries

<span class="pl-c"><span class="pl-c">#</span> Represent the series 1.0 + 1.0*x - 2.0*x^2</span>
julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">series</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-k">-</span><span class="pl-c1">2.0</span>)
<span class="pl-c1">Series2</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">2.0</span>)

<span class="pl-c"><span class="pl-c">#</span> Represent the series 1.0 + 0.0*x + 1.0*x^2</span>
julia<span class="pl-k">&gt;</span> b <span class="pl-k">=</span> <span class="pl-c1">series</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>)
<span class="pl-c1">Series2</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">1.0</span>,<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>)

<span class="pl-c"><span class="pl-c">#</span> Series add linearly</span>
julia<span class="pl-k">&gt;</span> a<span class="pl-k">+</span>b
<span class="pl-c1">Series2</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">2.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">1.0</span>)

<span class="pl-c"><span class="pl-c">#</span> The output of series operations is truncated to match the input size.</span>
<span class="pl-c"><span class="pl-c">#</span> Represents (1+x-2x^2)(1 + x^2) = 1+x-x^2+o(x^3)</span>
julia<span class="pl-k">&gt;</span> a<span class="pl-k">*</span>b
<span class="pl-c1">Series2</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">1.0</span>)

<span class="pl-c"><span class="pl-c">#</span> Extract the constant term of a series</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">constant</span>(a)
<span class="pl-c1">1.0</span>

<span class="pl-c"><span class="pl-c">#</span> Functions with known derivatives can easily be overloaded to operate on</span>
<span class="pl-c"><span class="pl-c">#</span> power series.</span>
<span class="pl-c"><span class="pl-c">#</span> You can generate the taylor series of a function about a point x up to</span>
<span class="pl-c"><span class="pl-c">#</span> e.g. 5th order by computing f(Series(x, 1.0, 0.0, 0.0, 0.0, 0.0))</span>
julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">series</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>)
<span class="pl-c1">Series5</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">0.0</span>,<span class="pl-c1">0.0</span>,<span class="pl-c1">0.0</span>,<span class="pl-c1">0.0</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sin</span>(x)
<span class="pl-c1">Series5</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">0.0</span>,<span class="pl-k">-</span><span class="pl-c1">0.16666666666666666</span>,<span class="pl-c1">0.0</span>,<span class="pl-c1">0.008333333333333333</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">log</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> x)
<span class="pl-c1">Series5</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">0.5</span>,<span class="pl-c1">0.3333333333333333</span>,<span class="pl-k">-</span><span class="pl-c1">0.25</span>,<span class="pl-c1">0.2</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">1</span><span class="pl-k">/</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span> x)
<span class="pl-c1">Series5</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>)

<span class="pl-c"><span class="pl-c">#</span> These are numerically equal to their series definitions</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">series</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-k">-</span><span class="pl-c1">1.0</span><span class="pl-k">/</span><span class="pl-c1">6.0</span>, <span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span><span class="pl-k">/</span><span class="pl-c1">120</span>)
<span class="pl-c1">Series5</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">0.0</span>,<span class="pl-k">-</span><span class="pl-c1">0.16666666666666666</span>,<span class="pl-c1">0.0</span>,<span class="pl-c1">0.008333333333333333</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">series</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-k">-</span><span class="pl-c1">1.0</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-c1">1.0</span><span class="pl-k">/</span><span class="pl-c1">3</span>, <span class="pl-k">-</span><span class="pl-c1">1.0</span><span class="pl-k">/</span><span class="pl-c1">4</span>, <span class="pl-c1">1.0</span><span class="pl-k">/</span><span class="pl-c1">5</span>)
<span class="pl-c1">Series5</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">0.5</span>,<span class="pl-c1">0.3333333333333333</span>,<span class="pl-k">-</span><span class="pl-c1">0.25</span>,<span class="pl-c1">0.2</span>)

<span class="pl-c"><span class="pl-c">#</span> Take the derivative of a series</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">polyder</span>(a)
<span class="pl-c1">Series1</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">4.0</span>)

<span class="pl-c"><span class="pl-c">#</span> Integrate a series term by term. Note that by convention, the constant term is 0.</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">polyint</span>(a)
<span class="pl-c1">Series3</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">0.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">0.5</span>,<span class="pl-k">-</span><span class="pl-c1">0.6666666666666666</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@assert</span> <span class="pl-c1">polyder</span>(<span class="pl-c1">polyint</span>(a)) <span class="pl-k">==</span> a

<span class="pl-c"><span class="pl-c">#</span> Truncate a series to a series 1 order lower</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">restrict</span>(a)
<span class="pl-c1">Series1</span><span class="pl-c1">{Float64}</span>(<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>)

<span class="pl-c"><span class="pl-c">#</span> Restricting a first order series returns a real number</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">restrict</span>(<span class="pl-c1">restrict</span>(a))
<span class="pl-c1">1.0</span>

<span class="pl-c"><span class="pl-c">#</span> polyint, polydir, and restrict are the only operations that change the order of</span>
<span class="pl-c"><span class="pl-c">#</span> a series. Arithmetic on series of different orders is disallowed because</span>
<span class="pl-c"><span class="pl-c">#</span> relevant terms in the lower order series may have been dropped at intermediate</span>
<span class="pl-c"><span class="pl-c">#</span> steps.</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">series</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>) <span class="pl-k">+</span> <span class="pl-c1">series</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>)
ERROR<span class="pl-k">:</span> no promotion exists <span class="pl-k">for</span> Series1{Float64} and Series2{Float64}
 <span class="pl-k">in</span> <span class="pl-k">+</span> at promotion<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">158</span>

<span class="pl-c"><span class="pl-c">#</span> Truncated power series offer one of the best ways to take multiple derivatives</span>
<span class="pl-c"><span class="pl-c">#</span> of generic mathematical functions.</span>
julia<span class="pl-k">&gt;</span> <span class="pl-en">f</span>(x) <span class="pl-k">=</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>)
f (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-en">f2</span>(x) <span class="pl-k">=</span> <span class="pl-c1">polyder</span>(<span class="pl-c1">polyder</span>(<span class="pl-c1">f</span>(<span class="pl-c1">series</span>(x, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>))))
f2 (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f2</span>(<span class="pl-c1">2.0</span>)
<span class="pl-c1">0.25641894444227853</span>

<span class="pl-c"><span class="pl-c">#</span> Compare to the symbolic second derivative</span>
julia<span class="pl-k">&gt;</span> <span class="pl-k">let</span> x <span class="pl-k">=</span> <span class="pl-c1">2.0</span>; <span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">+</span><span class="pl-c1">4</span>x<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>); <span class="pl-k">end</span>
<span class="pl-c1">0.25641894444227853</span>

<span class="pl-c"><span class="pl-c">#</span> PowerSeries comes with types defined for series up to order 7. By default,</span>
<span class="pl-c"><span class="pl-c">#</span> trying to construct a higher order series is a type error.</span>
julia<span class="pl-k">&gt;</span> <span class="pl-c1">series</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>)
ERROR<span class="pl-k">:</span> no method <span class="pl-c1">series</span>(Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64)

<span class="pl-c"><span class="pl-c">#</span> If you want to work with higher order series, you can generate types up</span>
<span class="pl-c"><span class="pl-c">#</span> to a given order with PowerSeries.generate(order)</span>
julia<span class="pl-k">&gt;</span> PowerSeries<span class="pl-k">.</span><span class="pl-c1">generate</span>(<span class="pl-c1">9</span>)
julia<span class="pl-k">&gt;</span> <span class="pl-c1">series</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>)
<span class="pl-c1">Series9</span><span class="pl-c1">{Int64}</span>(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>)</pre></div>
<p dir="auto">For taking first derivatives of code, see also <a href="https://github.com/scidom/DualNumbers.jl">DualNumbers.jl</a>, and for taking symbolic derivatives, see the <code>differentiate</code> method of <a href="https://github.com/johnmyleswhite/Calculus.jl">Calculus.jl</a>.</p>
<p dir="auto">Truncated series have performance advantages over symbolic derivatives for either deeply nested functions or high order derivatives.</p>
<p dir="auto">###Theory of operation
Computations of functions of a power series are based on the fundamental theorem of calculus:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fd95799f6aae670c01cee390cabfadb37115c4eba7cfad86d8b29245a4e07e46/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f706e672e6c617465783f66253238782532302b253230253543657073696c6f6e25323925323025334425323066253238782532392532302b253230253543696e745f78253545253742782532302b253230253543657073696c6f6e25374425323064782532306625323725323878253239"><img src="https://camo.githubusercontent.com/fd95799f6aae670c01cee390cabfadb37115c4eba7cfad86d8b29245a4e07e46/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f706e672e6c617465783f66253238782532302b253230253543657073696c6f6e25323925323025334425323066253238782532392532302b253230253543696e745f78253545253742782532302b253230253543657073696c6f6e25374425323064782532306625323725323878253239" alt="equation-1" data-canonical-src="http://latex.codecogs.com/png.latex?f%28x%20+%20%5Cepsilon%29%20%3D%20f%28x%29%20+%20%5Cint_x%5E%7Bx%20+%20%5Cepsilon%7D%20dx%20f%27%28x%29" style="max-width: 100%;"></a></p>
<p dir="auto">Using this relation, it's easy to derive a composition rule for functions that can be applied directly to power series.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0dfb8d092d4a32d05f4abf1529f16dc85d828e3d5742bb327b761db201f245f3/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f706e672e6c617465783f6625323867253238782532302b253230253543657073696c6f6e2532392532392532302533442532306625323867253238782532392532392532302b253230253543696e745f78253545253742782532302b253230253543657073696c6f6e25374425323064782532306625323725323867253238782532392532392532306725323725323878253239"><img src="https://camo.githubusercontent.com/0dfb8d092d4a32d05f4abf1529f16dc85d828e3d5742bb327b761db201f245f3/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f706e672e6c617465783f6625323867253238782532302b253230253543657073696c6f6e2532392532392532302533442532306625323867253238782532392532392532302b253230253543696e745f78253545253742782532302b253230253543657073696c6f6e25374425323064782532306625323725323867253238782532392532392532306725323725323878253239" alt="equation-2" data-canonical-src="http://latex.codecogs.com/png.latex?f%28g%28x%20+%20%5Cepsilon%29%29%20%3D%20f%28g%28x%29%29%20+%20%5Cint_x%5E%7Bx%20+%20%5Cepsilon%7D%20dx%20f%27%28g%28x%29%29%20g%27%28x%29" style="max-width: 100%;"></a></p>
<p dir="auto">This is essentially an extension of the chain rule from infinitesimal calculus to finite step sizes.</p>
<p dir="auto">Once differentiation and definite integration are defined on series, this relation allows a simple definition of functions of series. For example, the sine and cosine of series are mutually-recursively defined as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sin(x::AbstractSeries) = sin(constant(x)) + polyint(polyder(x)*cos(restrict(x)))
cos(x::AbstractSeries) = cos(constant(x)) - polyint(polyder(x)*sin(restrict(x)))"><pre><span class="pl-en">sin</span>(x<span class="pl-k">::</span><span class="pl-c1">AbstractSeries</span>) <span class="pl-k">=</span> <span class="pl-c1">sin</span>(<span class="pl-c1">constant</span>(x)) <span class="pl-k">+</span> <span class="pl-c1">polyint</span>(<span class="pl-c1">polyder</span>(x)<span class="pl-k">*</span><span class="pl-c1">cos</span>(<span class="pl-c1">restrict</span>(x)))
<span class="pl-en">cos</span>(x<span class="pl-k">::</span><span class="pl-c1">AbstractSeries</span>) <span class="pl-k">=</span> <span class="pl-c1">cos</span>(<span class="pl-c1">constant</span>(x)) <span class="pl-k">-</span> <span class="pl-c1">polyint</span>(<span class="pl-c1">polyder</span>(x)<span class="pl-k">*</span><span class="pl-c1">sin</span>(<span class="pl-c1">restrict</span>(x)))</pre></div>
<p dir="auto">The general pattern is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f(x::AbstractSeries) = f(constant(x)) + polyint(polyder(x)*f'(restrict(x)))"><pre><span class="pl-en">f</span>(x<span class="pl-k">::</span><span class="pl-c1">AbstractSeries</span>) <span class="pl-k">=</span> <span class="pl-c1">f</span>(<span class="pl-c1">constant</span>(x)) <span class="pl-k">+</span> <span class="pl-c1">polyint</span>(<span class="pl-c1">polyder</span>(x)<span class="pl-k">*</span>f<span class="pl-k">'</span>(<span class="pl-c1">restrict</span>(x)))</pre></div>
<p dir="auto">where <code>f'</code> should be replaced by a known derivative function.</p>
</article></div>