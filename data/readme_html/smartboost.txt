<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-smartboost" class="anchor" aria-hidden="true" href="#smartboost"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SMARTboost</h1>
<p dir="auto"><a href="https://github.com/PaoloGiordani/SMARTboost.jl/actions"><img src="https://github.com/PaoloGiordani/SMARTboost.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto">A Julia implementation of SMARTboost (Smooth Additive Regression Trees), as described in the paper <a href="https://ssrn.com/abstract=3975543" rel="nofollow">SMARTboost learning for tabular data</a>.</p>
<p dir="auto">The R version (via JuliaConnectoR) is available <a href="https://github.com/PaoloGiordani/SMARTboost">here.</a></p>
<p dir="auto">Currently support only L2 loss, but extensions are planned.</p>
<p dir="auto">Input features can be <code>Array{Float64/Float32}</code> or DataFrame.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Latest:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="pkg&gt; add &quot;https://github.com/PaoloGiordani/SMARTboost.jl&quot;"><pre lang="julia-repl" class="notranslate"><code>pkg&gt; add "https://github.com/PaoloGiordani/SMARTboost.jl"
</code></pre></div>
<h2 dir="auto"><a id="user-content-parameters-incomplete-list-see-smartparam-documentation-for-more" class="anchor" aria-hidden="true" href="#parameters-incomplete-list-see-smartparam-documentation-for-more"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Parameters (incomplete list, see SMARTparam Documentation for more).</h2>
<ul dir="auto">
<li><code>loss</code>              [:L2] currently only :L2 is supported, but extensions are planned.</li>
<li><code>depth</code>             [4] tree depth. If not default, then typically cross-validated in SMARTfit.</li>
<li><code>lambda</code>            [0.2] learning rate</li>
<li><code>loglikdivide</code>      [1.0] with panel data, SMARTloglikdivide() can be used to set this parameter</li>
<li><code>overlap</code>           [0] number of overlaps. Typically overlap = h-1, where y(t) = Y(t+h)-Y(t)</li>
<li><code>nfold</code>             [5] n in n-fold cv. Set nfold = 1 for a single validation set, the last sharevalidation share of the sample.</li>
<li><code>verbose</code>           [:Off] verbosity :On or :Off</li>
<li><code>T</code>                 [Float32] Float32 is faster than Float64</li>
<li><code>randomizecv</code>       [false] default is purged-cv (see paper); a time series or panel structure is automatically detected (see SMARTdata)</li>
<li><code>subsamplesharevs</code>  [1.0] row subs-sampling; if &lt;1.0, only a randomly drawn (at each iteration) share of the sample is used in determining ι (which feature),μ,τ.</li>
<li><code>subsampleshare_columns</code>  [1.0] column sub-sampling</li>
</ul>
<h2 dir="auto"><a id="user-content-example1-with-n--1_000" class="anchor" aria-hidden="true" href="#example1-with-n--1_000"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example1 with n = 1_000</h2>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="figures/Example1_1k.png"><img src="figures/Example1_1k.png" alt="" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-example1-with-n--1_000_000" class="anchor" aria-hidden="true" href="#example1-with-n--1_000_000"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example1 with n = 1_000_000</h2>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="figures/Example1_1m.png"><img src="figures/Example1_1m.png" alt="" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-example1" class="anchor" aria-hidden="true" href="#example1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example1</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
using SMARTboost   # single core

#=
number_workers  = 4  # desired number of workers
using Distributed
nprocs()&lt;number_workers ? addprocs( number_workers - nprocs()  ) : addprocs(0)
@everywhere using SMARTboost
=#

using Random, Plots, JLD2

# Some options for SMARTboost
cvdepth   = false    # false to use the default depth (3), true to cv
nfold     = 1        # nfold cv. 1 faster, default 5 is slower, but more accurate.

# options to generate data. y = sum of four additive nonlinear functions + Gaussian noise(0,stde^2)
n,p,n_test  = 10_000,5,100_000
stde        = 1.0

f_1(x,b)    = b*x
f_2(x,b)    = sin.(b*x)
f_3(x,b)    = b*x.^3
f_4(x,b)    = b./(1.0 .+ (exp.(4.0*x))) .- 0.5*b

b1,b2,b3,b4 = 1.5,2.0,0.5,2.0

# generate data
x,x_test = randn(n,p), randn(n_test,p)
f        = f_1(x[:,1],b1) + f_2(x[:,2],b2) + f_3(x[:,3],b3) + f_4(x[:,4],b4)
f_test   = f_1(x_test[:,1],b1) + f_2(x_test[:,2],b2) + f_3(x_test[:,3],b3) + f_4(x_test[:,4],b4)
y        = f + randn(n)*stde

# set up SMARTparam and SMARTdata, then fit and predit
param  = SMARTparam( nfold = nfold,verbose = :Off )
data   = SMARTdata(y,x,param,fdgp=f)

if cvdepth==false
    output = SMARTfit(data,param)                # default depth
else
    output = SMARTfit(data,param,paramfield=:depth,cv_grid=[1,2,3,4,5],stopwhenlossup=true)  # starts at depth = 1, stops as soon as loss increases
end

yf     = SMARTpredict(x_test,output.SMARTtrees)  # predict

println(&quot;\n depth = $(output.bestvalue), number of trees = $(output.ntrees) &quot;)
println(&quot; out-of-sample RMSE from truth &quot;, sqrt(sum((yf - f_test).^2)/n_test) )

# save (load) fitted model
@save &quot;output.jld2&quot; output
#@load &quot;output.jld2&quot; output    # Note: key must be the same, e.g. @load &quot;output.jld2&quot; output2 is a KeyError

# feature importance, partial dependence plots and marginal effects
fnames,fi,fnames_sorted,fi_sorted,sortedindx = SMARTrelevance(output.SMARTtrees,data)
q,pdp  = SMARTpartialplot(data,output.SMARTtrees,[1,2,3,4])
qm,me  = SMARTmarginaleffect(data,output.SMARTtrees,[1,2,3,4],npoints = 40)

# To compute marginal effect at one point x0 rather than over a grid, set npoints = 1 and other_xs = x0 (a p vector, p the number of features), e.g.
# qm,me  = SMARTmarginaleffect(data,output.SMARTtrees,[1,2,3,4],other_xs=x0,npoints = 1)

# plot partial dependence
![](figures/Example1.png)
"><pre><span class="pl-k">using</span> SMARTboost   <span class="pl-c"><span class="pl-c">#</span> single core</span>

<span class="pl-c"><span class="pl-c">#=</span></span>
<span class="pl-c">number_workers  = 4  # desired number of workers</span>
<span class="pl-c">using Distributed</span>
<span class="pl-c">nprocs()&lt;number_workers ? addprocs( number_workers - nprocs()  ) : addprocs(0)</span>
<span class="pl-c">@everywhere using SMARTboost</span>
<span class="pl-c"><span class="pl-c">=#</span></span>

<span class="pl-k">using</span> Random, Plots, JLD2

<span class="pl-c"><span class="pl-c">#</span> Some options for SMARTboost</span>
cvdepth   <span class="pl-k">=</span> <span class="pl-c1">false</span>    <span class="pl-c"><span class="pl-c">#</span> false to use the default depth (3), true to cv</span>
nfold     <span class="pl-k">=</span> <span class="pl-c1">1</span>        <span class="pl-c"><span class="pl-c">#</span> nfold cv. 1 faster, default 5 is slower, but more accurate.</span>

<span class="pl-c"><span class="pl-c">#</span> options to generate data. y = sum of four additive nonlinear functions + Gaussian noise(0,stde^2)</span>
n,p,n_test  <span class="pl-k">=</span> <span class="pl-c1">10_000</span>,<span class="pl-c1">5</span>,<span class="pl-c1">100_000</span>
stde        <span class="pl-k">=</span> <span class="pl-c1">1.0</span>

<span class="pl-en">f_1</span>(x,b)    <span class="pl-k">=</span> b<span class="pl-k">*</span>x
<span class="pl-en">f_2</span>(x,b)    <span class="pl-k">=</span> <span class="pl-c1">sin</span>.(b<span class="pl-k">*</span>x)
<span class="pl-en">f_3</span>(x,b)    <span class="pl-k">=</span> b<span class="pl-k">*</span>x<span class="pl-k">.^</span><span class="pl-c1">3</span>
<span class="pl-en">f_4</span>(x,b)    <span class="pl-k">=</span> b<span class="pl-k">./</span>(<span class="pl-c1">1.0</span> <span class="pl-k">.+</span> (<span class="pl-c1">exp</span>.(<span class="pl-c1">4.0</span><span class="pl-k">*</span>x))) <span class="pl-k">.-</span> <span class="pl-c1">0.5</span><span class="pl-k">*</span>b

b1,b2,b3,b4 <span class="pl-k">=</span> <span class="pl-c1">1.5</span>,<span class="pl-c1">2.0</span>,<span class="pl-c1">0.5</span>,<span class="pl-c1">2.0</span>

<span class="pl-c"><span class="pl-c">#</span> generate data</span>
x,x_test <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n,p), <span class="pl-c1">randn</span>(n_test,p)
f        <span class="pl-k">=</span> <span class="pl-c1">f_1</span>(x[:,<span class="pl-c1">1</span>],b1) <span class="pl-k">+</span> <span class="pl-c1">f_2</span>(x[:,<span class="pl-c1">2</span>],b2) <span class="pl-k">+</span> <span class="pl-c1">f_3</span>(x[:,<span class="pl-c1">3</span>],b3) <span class="pl-k">+</span> <span class="pl-c1">f_4</span>(x[:,<span class="pl-c1">4</span>],b4)
f_test   <span class="pl-k">=</span> <span class="pl-c1">f_1</span>(x_test[:,<span class="pl-c1">1</span>],b1) <span class="pl-k">+</span> <span class="pl-c1">f_2</span>(x_test[:,<span class="pl-c1">2</span>],b2) <span class="pl-k">+</span> <span class="pl-c1">f_3</span>(x_test[:,<span class="pl-c1">3</span>],b3) <span class="pl-k">+</span> <span class="pl-c1">f_4</span>(x_test[:,<span class="pl-c1">4</span>],b4)
y        <span class="pl-k">=</span> f <span class="pl-k">+</span> <span class="pl-c1">randn</span>(n)<span class="pl-k">*</span>stde

<span class="pl-c"><span class="pl-c">#</span> set up SMARTparam and SMARTdata, then fit and predit</span>
param  <span class="pl-k">=</span> <span class="pl-c1">SMARTparam</span>( nfold <span class="pl-k">=</span> nfold,verbose <span class="pl-k">=</span> <span class="pl-c1">:Off</span> )
data   <span class="pl-k">=</span> <span class="pl-c1">SMARTdata</span>(y,x,param,fdgp<span class="pl-k">=</span>f)

<span class="pl-k">if</span> cvdepth<span class="pl-k">==</span><span class="pl-c1">false</span>
    output <span class="pl-k">=</span> <span class="pl-c1">SMARTfit</span>(data,param)                <span class="pl-c"><span class="pl-c">#</span> default depth</span>
<span class="pl-k">else</span>
    output <span class="pl-k">=</span> <span class="pl-c1">SMARTfit</span>(data,param,paramfield<span class="pl-k">=</span><span class="pl-c1">:depth</span>,cv_grid<span class="pl-k">=</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>],stopwhenlossup<span class="pl-k">=</span><span class="pl-c1">true</span>)  <span class="pl-c"><span class="pl-c">#</span> starts at depth = 1, stops as soon as loss increases</span>
<span class="pl-k">end</span>

yf     <span class="pl-k">=</span> <span class="pl-c1">SMARTpredict</span>(x_test,output<span class="pl-k">.</span>SMARTtrees)  <span class="pl-c"><span class="pl-c">#</span> predict</span>

<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span> depth = <span class="pl-v">$(output<span class="pl-k">.</span>bestvalue)</span>, number of trees = <span class="pl-v">$(output<span class="pl-k">.</span>ntrees)</span> <span class="pl-pds">"</span></span>)
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span> out-of-sample RMSE from truth <span class="pl-pds">"</span></span>, <span class="pl-c1">sqrt</span>(<span class="pl-c1">sum</span>((yf <span class="pl-k">-</span> f_test)<span class="pl-k">.</span><span class="pl-k">^</span><span class="pl-c1">2</span>)<span class="pl-k">/</span>n_test) )

<span class="pl-c"><span class="pl-c">#</span> save (load) fitted model</span>
<span class="pl-c1">@save</span> <span class="pl-s"><span class="pl-pds">"</span>output.jld2<span class="pl-pds">"</span></span> output
<span class="pl-c"><span class="pl-c">#</span>@load "output.jld2" output    # Note: key must be the same, e.g. @load "output.jld2" output2 is a KeyError</span>

<span class="pl-c"><span class="pl-c">#</span> feature importance, partial dependence plots and marginal effects</span>
fnames,fi,fnames_sorted,fi_sorted,sortedindx <span class="pl-k">=</span> <span class="pl-c1">SMARTrelevance</span>(output<span class="pl-k">.</span>SMARTtrees,data)
q,pdp  <span class="pl-k">=</span> <span class="pl-c1">SMARTpartialplot</span>(data,output<span class="pl-k">.</span>SMARTtrees,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>])
qm,me  <span class="pl-k">=</span> <span class="pl-c1">SMARTmarginaleffect</span>(data,output<span class="pl-k">.</span>SMARTtrees,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>],npoints <span class="pl-k">=</span> <span class="pl-c1">40</span>)

<span class="pl-c"><span class="pl-c">#</span> To compute marginal effect at one point x0 rather than over a grid, set npoints = 1 and other_xs = x0 (a p vector, p the number of features), e.g.</span>
<span class="pl-c"><span class="pl-c">#</span> qm,me  = SMARTmarginaleffect(data,output.SMARTtrees,[1,2,3,4],other_xs=x0,npoints = 1)</span>

<span class="pl-c"><span class="pl-c">#</span> plot partial dependence</span>
<span class="pl-k">!</span>[](figures<span class="pl-k">/</span>Example1<span class="pl-k">.</span>png)
</pre></div>
<h2 dir="auto"><a id="user-content-example2-global-equity-data-parallelization-via-distributed-cv-and-priors-for-panel-data" class="anchor" aria-hidden="true" href="#example2-global-equity-data-parallelization-via-distributed-cv-and-priors-for-panel-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example2 (Global Equity data, parallelization via Distributed, CV and priors for panel data)</h2>
<p dir="auto">Refer to examples/Example2. Notice how we prepare the panel data for purged-CV, and calibrate loglikdivide; here the effective sample size ess is much smaller than n.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
# Setting up parallelization
number_workers  = 4  # desired number of workers
using Distributed
nprocs()&lt;number_workers ? addprocs( number_workers - nprocs()  ) : addprocs(0)
@everywhere using SMARTboost

# ....
# prepare data; sorting dataframe by :date is required by purged-CV.
sort!(df,:date)

# calibrate loglikdivide.
lld,ess =  SMARTloglikdivide(df,:excessret,:date,overlap=0)
param   = SMARTparam(loglikdivide = lld,overlap=0,stopwhenlossup=true) # in CV, stop as soon as loss increases

"><pre><span class="pl-c"><span class="pl-c">#</span> Setting up parallelization</span>
number_workers  <span class="pl-k">=</span> <span class="pl-c1">4</span>  <span class="pl-c"><span class="pl-c">#</span> desired number of workers</span>
<span class="pl-k">using</span> Distributed
<span class="pl-c1">nprocs</span>()<span class="pl-k">&lt;</span>number_workers <span class="pl-k">?</span> <span class="pl-c1">addprocs</span>( number_workers <span class="pl-k">-</span> <span class="pl-c1">nprocs</span>()  ) <span class="pl-k">:</span> <span class="pl-c1">addprocs</span>(<span class="pl-c1">0</span>)
<span class="pl-c1">@everywhere</span> <span class="pl-k">using</span> SMARTboost

<span class="pl-c"><span class="pl-c">#</span> ....</span>
<span class="pl-c"><span class="pl-c">#</span> prepare data; sorting dataframe by :date is required by purged-CV.</span>
<span class="pl-c1">sort!</span>(df,<span class="pl-c1">:date</span>)

<span class="pl-c"><span class="pl-c">#</span> calibrate loglikdivide.</span>
lld,ess <span class="pl-k">=</span>  <span class="pl-c1">SMARTloglikdivide</span>(df,<span class="pl-c1">:excessret</span>,<span class="pl-c1">:date</span>,overlap<span class="pl-k">=</span><span class="pl-c1">0</span>)
param   <span class="pl-k">=</span> <span class="pl-c1">SMARTparam</span>(loglikdivide <span class="pl-k">=</span> lld,overlap<span class="pl-k">=</span><span class="pl-c1">0</span>,stopwhenlossup<span class="pl-k">=</span><span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">#</span> in CV, stop as soon as loss increases</span>

</pre></div>
<p dir="auto">Refer to examples/Example2. Here we point out how to do a train-validation-test split in SMARTboost.
In particular, notice that the default is to re-fit the model (with the cross-validated tuning parameters) on the entire data (train+validation), as is done in n-fold CV, even if nfold = 1. If you wish to skip this step (for speed or for comparison with other methods), set nofullsample = true in SMARTfit.
When nfold = 1, the default is to use the last 30% of the data as validation test ('approximately' 30% in some cases because of purged validation). To change this default, set e.g. sharevalidation = 0.2 for the last 20% of the sample, or sharevalidation = 1000 for the last 1000 observations. Setting sharevalidation to an integer switches the default to nfold = 1.</p>
<h1 dir="auto"><a id="user-content-some-suggestions-for-speeding-up-smartboost" class="anchor" aria-hidden="true" href="#some-suggestions-for-speeding-up-smartboost"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Some suggestions for speeding up SMARTboost.</h1>
<p dir="auto">Example of approximate computing time for 100 trees, depth = 4, using 8 workers on an AMD EPYC 7542, dgp  linear. (dgp is linear. 100 trees are sufficient in most applications.)</p>
<table>
<thead>
<tr>
<th>n x p</th>
<th align="center">Minutes for 100 trees</th>
</tr>
</thead>
<tbody>
<tr>
<td>100k x 10</td>
<td align="center">1.7'</td>
</tr>
<tr>
<td>1m x 10</td>
<td align="center">17'</td>
</tr>
<tr>
<td>10m x 10</td>
<td align="center">170'</td>
</tr>
<tr>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td>100k x 100</td>
<td align="center">9'</td>
</tr>
<tr>
<td>1m x 100</td>
<td align="center">85'</td>
</tr>
<tr>
<td>10m x 100</td>
<td align="center">850'</td>
</tr>
</tbody>
</table>
<p dir="auto">SMARTboost runs much faster (particularly with large n) with 4-8 cores than with one, after the initial one-off cost.
If you are running on few cores, consider limiting depth &lt;= 3.</p>
<p dir="auto">With large n:</p>
<ul dir="auto">
<li>Use a single validation sample instead of the default 5-fold cv (param.nfold=1). Additionally, in SMARTfit, set nofullsample = true further reduces computing time by roughly 60% (at the cost of a modest efficiency loss.) nofullsample = true is also required if you want to have a train-validation-test split, so that the model is only fit on the train set (the default will use a validation test to CV, and then re-train on the train+validation at the optimum parameter values).</li>
<li>Computing time increases rapidly with param.depth in smooth trees. If you cv tree depth, start at a low value and stop as soon as there is
no sizable improvement (set stopwhenlossup = true in SMARTfit). With 8 workers, as a rule of thumb, computing times double if depth &lt;- depth + 1.</li>
<li>set stderulestop = 0.05 or 0.1 to stop iterations when the loss is no longer decreasing sizably (at a cost of a small loss in performance.)</li>
<li>row and column subs-sampling are supported.</li>
</ul>
</article></div>