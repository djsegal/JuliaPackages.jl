<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-methodchainsjl" class="anchor" aria-hidden="true" href="#methodchainsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><em>MethodChains.jl</em></h1>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="α.{a}.{b}.{c}.{d}.{e}.{f}.{g}.{h}.{i}.{j}.{k}.{l}.{m}.{n}.{o}.{p}.{q}.{r}.{s}.{t}.{u}.{v}.{w}.{x}.{y}.{z}"><pre>α.{a}.{b}.{c}.{d}.{e}.{f}.{g}.{h}.{i}.{j}.{k}.{l}.{m}.{n}.{o}.{p}.{q}.{r}.{s}.{t}.{u}.{v}.{w}.{x}.{y}.{z}</pre></div>
<h2 dir="auto"><a id="user-content-welcome" class="anchor" aria-hidden="true" href="#welcome"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Welcome!</h2>
<p dir="auto">This is an ambitious (and somewhat experimental, and fun!) approach to generalize method chaining and function composition.</p>
<p dir="auto">To install:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="] add https://github.com/uniment/MethodChains.jl"><pre>] add https<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>uniment<span class="pl-k">/</span>MethodChains<span class="pl-k">.</span>jl</pre></div>
<p dir="auto">and</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MethodChains"><pre><span class="pl-k">using</span> MethodChains</pre></div>
<p dir="auto">You will now have the <code>@mc</code> method chaining macro installed. You can invoke this macro on a single expression:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y = @mc x.{f, g}"><pre>y <span class="pl-k">=</span> <span class="pl-c1">@mc</span> x.{f, g}</pre></div>
<p dir="auto">or you can invoke it on an entire block of expressions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@mc function foo(x)
    y = x.{f, g}
    z = y.{g; h}
end"><pre><span class="pl-c1">@mc</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(x)
    y <span class="pl-k">=</span> x.{f, g}
    z <span class="pl-k">=</span> y.{g; h}
<span class="pl-k">end</span></pre></div>
<p dir="auto">To make it execute on every line in the REPL, run this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="MethodChains.init_repl()"><pre>MethodChains<span class="pl-k">.</span><span class="pl-c1">init_repl</span>()</pre></div>
<p dir="auto">Then, you won't have to worry about typing <code>@mc</code> every time. <g-emoji class="g-emoji" alias="star_struck" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f929.png">🤩</g-emoji></p>
<p dir="auto">That only seems to work for the REPL; VSCode and IJulia seems to be having trouble at the moment. (It works in the VSCode REPL, but not for SHIFT+ENTER or CTRL+ENTER.) For this reason, it's recommended to use the REPL.</p>
<p dir="auto">Definitely do not add this to your startup.jl file if you don't like having fun:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using MethodChains
MethodChains.init_repl()"><pre><span class="pl-k">using</span> MethodChains
MethodChains<span class="pl-k">.</span><span class="pl-c1">init_repl</span>()</pre></div>
<h1 dir="auto"><a id="user-content-basic-use" class="anchor" aria-hidden="true" href="#basic-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><em>Basic Use</em></h1>
<p dir="auto">The basic idea of a method chain is simple:</p>
<p dir="auto">For an object <code>x</code>, you can call a sequence of functions <code>f; g; h</code> on it like so:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y = x.{f; g; h}"><pre>y <span class="pl-k">=</span> x.{f; g; h}</pre></div>
<p dir="auto">This is equivalent to:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y = h(g(f(x)))"><pre>y <span class="pl-k">=</span> <span class="pl-c1">h</span>(<span class="pl-c1">g</span>(<span class="pl-c1">f</span>(x)))</pre></div>
<p dir="auto">or this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y = x.{f}.{g}.{h}"><pre>y <span class="pl-k">=</span> x.{f}.{g}.{h}</pre></div>
<p dir="auto">(why you'd do that I don't know, but that's none of my beeswax!)</p>
<p dir="auto">That was for calling three functions <em>in sequence</em>. But we can also do this!</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="z = x.{f, g, h}"><pre>z <span class="pl-k">=</span> x.{f, g, h}</pre></div>
<p dir="auto">That's equivalent to:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="z = (f(x), g(x), h(x))"><pre>z <span class="pl-k">=</span> (<span class="pl-c1">f</span>(x), <span class="pl-c1">g</span>(x), <span class="pl-c1">h</span>(x))</pre></div>
<p dir="auto">You'll often find it handy to use chaining syntax even when the "chain" is only one element long, and that's dandy!</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="my_arr.{length}.prop + 1"><pre>my_arr.{length}<span class="pl-k">.</span>prop <span class="pl-k">+</span> <span class="pl-c1">1</span></pre></div>
<p dir="auto">Example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; randn(100).{maximum; sqrt}
1.4735877523876308

julia&gt; (1:2:9).{first, last, step}
(1, 9, 2)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">randn</span>(<span class="pl-c1">100</span>).{maximum; sqrt}
<span class="pl-c1">1.4735877523876308</span>

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">9</span>)<span class="pl-k">.</span>{first, last, step}
(<span class="pl-c1">1</span>, <span class="pl-c1">9</span>, <span class="pl-c1">2</span>)</pre></div>
<p dir="auto">You can also make a method chain and call it later, instead of immediately executing it:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="m = {f; g; h}
y = x.{m}
# or
y = m(x)"><pre>m <span class="pl-k">=</span> {f; g; h}
y <span class="pl-k">=</span> x.{m}
<span class="pl-c"><span class="pl-c">#</span> or</span>
y <span class="pl-k">=</span> <span class="pl-c1">m</span>(x)</pre></div>
<p dir="auto">In this case, <code>m</code> is called a "chainlink." Chainlinks are single-input, single-output functions defined with chaining syntax.</p>
<p dir="auto">You can also construct a chainlink and immediately call it, but that's not really necessary (and takes greater compile time than putting the chain in suffix position):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y = {f; g; h}(x)"><pre>y <span class="pl-k">=</span> {f; g; h}(x)</pre></div>
<p dir="auto">Now, unless every function is a Clojure-style transducer, or another chainlink, chances are that your functions won't compose perfectly like this. This situation happens in real life too—and to handle this, in the English language we reserve the pronoun "it," to give the object a local and temporary name to allow short (but flexible) manipulations spliced between larger functions. So, <code>MethodChains</code> also uses <code>it</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x = 2;

julia&gt; f(x) = x^2;

julia&gt; g(x) = x+1;

julia&gt; x.{f; √(it - 1); g}
2.732050807568877"><pre>julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> <span class="pl-c1">2</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-en">f</span>(x) <span class="pl-k">=</span> x<span class="pl-k">^</span><span class="pl-c1">2</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-en">g</span>(x) <span class="pl-k">=</span> x<span class="pl-k">+</span><span class="pl-c1">1</span>;

julia<span class="pl-k">&gt;</span> x.{f; <span class="pl-k">√</span>(it <span class="pl-k">-</span> <span class="pl-c1">1</span>); g}
<span class="pl-c1">2.732050807568877</span></pre></div>
<p dir="auto">To better understand what's going on, you can run <code>@macroexpand</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @macroexpand @mc x.{f; √(it - 1); g}
:(let it = x
      it = f(it)
      it = √(it - 1)
      it = g(it)
  end)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@macroexpand</span> <span class="pl-c1">@mc</span> x.{f; <span class="pl-k">√</span>(it <span class="pl-k">-</span> <span class="pl-c1">1</span>); g}
:(<span class="pl-k">let</span> it <span class="pl-k">=</span> x
      it <span class="pl-k">=</span> <span class="pl-c1">f</span>(it)
      it <span class="pl-k">=</span> <span class="pl-k">√</span>(it <span class="pl-k">-</span> <span class="pl-c1">1</span>)
      it <span class="pl-k">=</span> <span class="pl-c1">g</span>(it)
  <span class="pl-k">end</span>)</pre></div>
<p dir="auto">When constructing a chainlink, a function of <code>it</code> is created:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @macroexpand @mc {f; √(it - 1); g}
:(MethodChainLink{Symbol(&quot;{f, √(it - 1), g}&quot;)}((it-&gt;begin
              it = f(it)
              it = √(it - 1)
              it = g(it)
          end)))"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@macroexpand</span> <span class="pl-c1">@mc</span> {f; <span class="pl-k">√</span>(it <span class="pl-k">-</span> <span class="pl-c1">1</span>); g}
:(<span class="pl-c1">MethodChainLink</span><span class="pl-c1">{Symbol("{f, √(it - 1), g}")}</span>((it<span class="pl-k">-&gt;</span><span class="pl-k">begin</span>
              it <span class="pl-k">=</span> <span class="pl-c1">f</span>(it)
              it <span class="pl-k">=</span> <span class="pl-k">√</span>(it <span class="pl-k">-</span> <span class="pl-c1">1</span>)
              it <span class="pl-k">=</span> <span class="pl-c1">g</span>(it)
          <span class="pl-k">end</span>)))</pre></div>
<p dir="auto">Pretty simple, neh? <code>it</code> is a keyword <em>defined only locally inside the chain</em>, and on every step it takes on a new value. If an expression in the chain has <code>it</code> in it, then it's simply executed and the result overwrites <code>it</code>; otherwise it's assumed that it evaluates to a function, which is called on <code>it</code> (and again, the result is assigned to <code>it</code>).</p>
<p dir="auto">These two do the same thing:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="map({it^2}, 1:10)
(1:10).{map({it^2}, it)}"><pre><span class="pl-c1">map</span>({it<span class="pl-k">^</span><span class="pl-c1">2</span>}, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>)
(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>)<span class="pl-k">.</span>{<span class="pl-c1">map</span>({it<span class="pl-k">^</span><span class="pl-c1">2</span>}, it)}</pre></div>
<p dir="auto">A couple more examples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; x = (0,3,5);

julia&gt; x.{(first(it):last(it)...,)}
(0, 1, 2, 3, 4, 5)

julia&gt; (x.{first}:x.{last}...,)
(0, 1, 2, 3, 4, 5)

julia&gt; x.{sum(x) &gt; 7 ? maximum : minimum}
5

julia&gt; (1,2,3).{it.^2; sum; sqrt}
3.7416573867739413

julia&gt; &quot;1,2,3&quot;.{split(it,&quot;,&quot;), parse.(Int,it), it.^2, join(it,&quot;,&quot;)}
&quot;1,4,9&quot;"><pre>julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> (<span class="pl-c1">0</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>);

julia<span class="pl-k">&gt;</span> x.{(<span class="pl-c1">first</span>(it)<span class="pl-k">:</span><span class="pl-c1">last</span>(it)<span class="pl-k">...</span>,)}
(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>)

julia<span class="pl-k">&gt;</span> (x.{first}<span class="pl-k">:</span>x.{last}<span class="pl-k">...</span>,)
(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>)

julia<span class="pl-k">&gt;</span> x.{<span class="pl-c1">sum</span>(x) <span class="pl-k">&gt;</span> <span class="pl-c1">7</span> <span class="pl-k">?</span> maximum <span class="pl-k">:</span> minimum}
<span class="pl-c1">5</span>

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)<span class="pl-k">.</span>{it<span class="pl-k">.^</span><span class="pl-c1">2</span>; sum; sqrt}
<span class="pl-c1">3.7416573867739413</span>

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1,2,3<span class="pl-pds">"</span></span>.{<span class="pl-c1">split</span>(it,<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>), <span class="pl-c1">parse</span>.(Int,it), it<span class="pl-k">.^</span><span class="pl-c1">2</span>, <span class="pl-c1">join</span>(it,<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>)}
<span class="pl-s"><span class="pl-pds">"</span>1,4,9<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">Now, the rule for whether to <em>call</em> the expression, or to leave it intact, or to assign <code>it</code> to it, is actually a bit more complicated (but pretty natural and straightforward). Check it out:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; const avg = {len=it.{length}; sum(it)/len}
##chainlink#295 (generic function with 1 method)

julia&gt; const stdev = {μ = avg(it); it.-μ; it.^2; avg; sqrt};

julia&gt; (1,2,3).{avg, stdev}
(2.0, 0.816496580927726)

julia&gt; Dict(:a=&gt;1, :b=&gt;2, :c=&gt;3).{for k ∈ keys(it) it[k]=it[k]^2 end}
Dict{Symbol, Int64} with 3 entries:
  :a =&gt; 1
  :b =&gt; 4
  :c =&gt; 9"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> avg <span class="pl-k">=</span> {len<span class="pl-k">=</span>it.{length}; <span class="pl-c1">sum</span>(it)<span class="pl-k">/</span>len}
<span class="pl-c"><span class="pl-c">#</span>#chainlink#295 (generic function with 1 method)</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> stdev <span class="pl-k">=</span> {μ <span class="pl-k">=</span> <span class="pl-c1">avg</span>(it); it<span class="pl-k">.-</span>μ; it<span class="pl-k">.^</span><span class="pl-c1">2</span>; avg; sqrt};

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)<span class="pl-k">.</span>{avg, stdev}
(<span class="pl-c1">2.0</span>, <span class="pl-c1">0.816496580927726</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">:a</span><span class="pl-k">=&gt;</span><span class="pl-c1">1</span>, <span class="pl-c1">:b</span><span class="pl-k">=&gt;</span><span class="pl-c1">2</span>, <span class="pl-c1">:c</span><span class="pl-k">=&gt;</span><span class="pl-c1">3</span>).{<span class="pl-k">for</span> k <span class="pl-k">∈</span> <span class="pl-c1">keys</span>(it) it[k]<span class="pl-k">=</span>it[k]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">end</span>}
Dict{Symbol, Int64} with <span class="pl-c1">3</span> entries<span class="pl-k">:</span>
  <span class="pl-c1">:a</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>
  <span class="pl-c1">:b</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">4</span>
  <span class="pl-c1">:c</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">9</span></pre></div>
<p dir="auto">(Note that expressions can be separated by commas or by semicolons.)</p>
<p dir="auto">Namely, regarding expressions inside the curly braces:</p>
<ul dir="auto">
<li>If an expression is an assignment, leave it intact and do not assign <code>it</code> to it. This allows local variables to be assigned.</li>
<li>If an expression type returns nothing, such as a <code>for</code> or <code>while</code> loop, then it is executed but its result is not assigned to <code>it</code>. (Note: this does <em>not</em> apply to function calls, such as <code>println</code>.)</li>
<li>If an expression is a non-callable type, such as a comprehension, generator, tuple, or vector, then it is not called and is simply assigned to <code>it</code>.</li>
<li>If an expression is an expression of <code>it</code>, then it is simply executed and assigned to <code>it</code>.</li>
<li>Otherwise it's assumed that the expression evaluates to something callable, and so it should be called on <code>it</code> and assigned to <code>it</code>. This is the default behavior.</li>
<li>A sequence of expressions is delimited with semicolons <code>;</code> or newlines; delimit with commas <code>,</code> to calculate multiple values and collect into a tuple.</li>
</ul>
<p dir="auto">If it's desired to override the default behavior of method calling, you can make an explicit assignment to <code>it</code>.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto"><em>My Examples</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="[1,2,3].{map({it^2}, it)}
[1,2,3].{join(it, &quot;, &quot;)}
&quot;1&quot;.{parse(Int, it)} == 1
(1,2).{(a,b)=it, (;b,a)}"><pre>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]<span class="pl-k">.</span>{<span class="pl-c1">map</span>({it<span class="pl-k">^</span><span class="pl-c1">2</span>}, it)}
[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]<span class="pl-k">.</span>{<span class="pl-c1">join</span>(it, <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>)}
<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>.{<span class="pl-c1">parse</span>(Int, it)} <span class="pl-k">==</span> <span class="pl-c1">1</span>
(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)<span class="pl-k">.</span>{(a,b)<span class="pl-k">=</span>it, (;b,a)}</pre></div>
<p dir="auto"><em>Operator Precedence</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; (1,2).{(a,b)=it; (;b,a)}.b
2

julia&gt; (1,2).{(a,b)=it; (;b,a)}[1]
2"><pre>julia<span class="pl-k">&gt;</span> (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)<span class="pl-k">.</span>{(a,b)<span class="pl-k">=</span>it; (;b,a)}<span class="pl-k">.</span>b
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)<span class="pl-k">.</span>{(a,b)<span class="pl-k">=</span>it; (;b,a)}[<span class="pl-c1">1</span>]
<span class="pl-c1">2</span></pre></div>
<p dir="auto"><em>Examples from <a href="https://github.com/oxinabox/Pipe.jl">Pipe.jl</a> Readme</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="a.{b(it...)}
a.{b(it(1,2))}
a.{b(it[3])}
(2,4).{get_angle(it...)}"><pre>a.{<span class="pl-c1">b</span>(it<span class="pl-k">...</span>)}
a.{<span class="pl-c1">b</span>(<span class="pl-c1">it</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>))}
a.{<span class="pl-c1">b</span>(it[<span class="pl-c1">3</span>])}
(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>)<span class="pl-k">.</span>{<span class="pl-c1">get_angle</span>(it<span class="pl-k">...</span>)}</pre></div>
<p dir="auto"><em>Block Chaining</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; [1,2,3].{
           filter(isodd, it)
           map({it^2}, it)
           sum
           sqrt
       }
3.1622776601683795"><pre>julia<span class="pl-k">&gt;</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]<span class="pl-k">.</span>{
           <span class="pl-c1">filter</span>(isodd, it)
           <span class="pl-c1">map</span>({it<span class="pl-k">^</span><span class="pl-c1">2</span>}, it)
           sum
           sqrt
       }
<span class="pl-c1">3.1622776601683795</span></pre></div>
<p dir="auto"><em>Example from <a href="https://github.com/jkrumbiegel/Chain.jl">Chain.jl</a> Readme</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="df.{
    dropmissing
    filter(:id =&gt; &gt;(6), it)
    groupby(it, :group)
    @show it
    combine(it, :age =&gt; sum)
}"><pre>df.{
    dropmissing
    <span class="pl-c1">filter</span>(<span class="pl-c1">:id</span> <span class="pl-k">=&gt;</span> <span class="pl-k">&gt;</span>(<span class="pl-c1">6</span>), it)
    <span class="pl-c1">groupby</span>(it, <span class="pl-c1">:group</span>)
    <span class="pl-c1">@show</span> it
    <span class="pl-c1">combine</span>(it, <span class="pl-c1">:age</span> <span class="pl-k">=&gt;</span> sum)
}</pre></div>
<p dir="auto"><em>Example from <a href="https://gitlab.com/aplavin/DataPipes.jl" rel="nofollow">DataPipes.jl</a> Readme</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; &quot;a=1 b=2 c=3&quot;.{
           split
           map({
               split(it, &quot;=&quot;)
               (Symbol(it[1]) =&gt; parse(Int, it[2]))
           }, it)
           NamedTuple
       }
(a = 1, b = 2, c = 3)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a=1 b=2 c=3<span class="pl-pds">"</span></span>.{
           split
           <span class="pl-c1">map</span>({
               <span class="pl-c1">split</span>(it, <span class="pl-s"><span class="pl-pds">"</span>=<span class="pl-pds">"</span></span>)
               (<span class="pl-c1">Symbol</span>(it[<span class="pl-c1">1</span>]) <span class="pl-k">=&gt;</span> <span class="pl-c1">parse</span>(Int, it[<span class="pl-c1">2</span>]))
           }, it)
           NamedTuple
       }
(a <span class="pl-k">=</span> <span class="pl-c1">1</span>, b <span class="pl-k">=</span> <span class="pl-c1">2</span>, c <span class="pl-k">=</span> <span class="pl-c1">3</span>)</pre></div>
<p dir="auto"><em>More</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; &quot;1 2, 3; hehe4&quot;.{
           eachmatch(r&quot;(\d+)&quot;, it)
           map({first, parse(Int, it)}, it)
           join(it, &quot;, &quot;)
       }
&quot;1, 2, 3, 4&quot;"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1 2, 3; hehe4<span class="pl-pds">"</span></span>.{
           <span class="pl-c1">eachmatch</span>(<span class="pl-sr"><span class="pl-pds">r"</span>(<span class="pl-cce">\d</span>+)<span class="pl-pds">"</span></span>, it)
           <span class="pl-c1">map</span>({first, <span class="pl-c1">parse</span>(Int, it)}, it)
           <span class="pl-c1">join</span>(it, <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>)
       }
<span class="pl-s"><span class="pl-pds">"</span>1, 2, 3, 4<span class="pl-pds">"</span></span></pre></div>
<p dir="auto"><em>Saving a Chainlink</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; chainlink = {split(it, r&quot;,\s*&quot;); {parse(Int, it)^2}.(it); join(it, &quot;, &quot;)};

julia&gt; &quot;1, 2, 3, 4&quot;.{chainlink}
&quot;1, 4, 9, 16&quot;"><pre>julia<span class="pl-k">&gt;</span> chainlink <span class="pl-k">=</span> {<span class="pl-c1">split</span>(it, <span class="pl-sr"><span class="pl-pds">r"</span>,<span class="pl-cce">\s</span>*<span class="pl-pds">"</span></span>); {<span class="pl-c1">parse</span>(Int, it)<span class="pl-k">^</span><span class="pl-c1">2</span>}.(it); <span class="pl-c1">join</span>(it, <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>)};

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1, 2, 3, 4<span class="pl-pds">"</span></span>.{chainlink}
<span class="pl-s"><span class="pl-pds">"</span>1, 4, 9, 16<span class="pl-pds">"</span></span></pre></div>
<p dir="auto"><em>Transducer Chain</em></p>
<p dir="auto">(example taken from <a href="https://www.youtube.com/watch?v=6mTbuzafcII" rel="nofollow">this presentation</a>)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="process_bags = {
    mapcatting(unbundle_pallet)
    filtering(is_nonfood)
    mapping(label_heavy)
}
process_bags.{into(airplane, it, pallets)}"><pre>process_bags <span class="pl-k">=</span> {
    <span class="pl-c1">mapcatting</span>(unbundle_pallet)
    <span class="pl-c1">filtering</span>(is_nonfood)
    <span class="pl-c1">mapping</span>(label_heavy)
}
process_bags.{<span class="pl-c1">into</span>(airplane, it, pallets)}</pre></div>
<h1 dir="auto"><a id="user-content-advanced-use" class="anchor" aria-hidden="true" href="#advanced-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><em>Advanced Use</em></h1>
<p dir="auto">That was fun! This chaining syntax allows for really basic composition like <code>x.{f; g; h}</code>, and basic collections like <code>x.{f, g, h}</code>, but also some more advanced stuff too like <code>x.{f; it.a; g}</code> or <code>x.{i for i ∈ 1:it}</code>.</p>
<p dir="auto">Why would you use this instead of normal function call syntax? Because in every expression you're presumed <em>most likely</em> to call a function on, or otherwise manipulate, the object <code>it</code>, this default behavior frequently enables very concise expressions. It also hints to the IDE autocomplete what type of object you're likely about to call a function on, as well as providing a natural "flow" of thought as the object passes through a sequence of transformations. Finally, calling the chain immediately (e.g. <code>x.{expr1; expr2; ...}</code>) doesn't allocate a function, which keeps compile time minimized, while still being a shorthand for creating locally-scoped variables.</p>
<p dir="auto">But there's even more to it. (This is the <em>really</em> experimental feature of this syntax, so please play with it and offer feedback!)</p>
<h2 dir="auto"><a id="user-content-multi-chains" class="anchor" aria-hidden="true" href="#multi-chains"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multi-Chains</h2>
<p dir="auto">So far we've discussed one-dimensional chains, wherein a single object undergoes a sequence of transformations in time. However, we can also express two-dimensional chains, wherein multiple objects spread across space undergo their own transformation chains, and occasionally interact, through time.</p>
<p dir="auto">The syntax is similar to that for vector and matrix building. Semicolons or newlines separate rows, and horizontal whitespace separates expressions within a row. When newlines delimit rows, semicolons are optional.</p>
<p dir="auto">I suggest you skip to the bottom to look at the examples to gain some motivation for what this syntax could be used for, and then return here.</p>
<p dir="auto">Take this for example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(a, b, c).{
    it...
    f       g       h
    g       h       f
    h       f       g
    it+3    it*2    it+1    
    them
}"><pre>(a, b, c)<span class="pl-k">.</span>{
    it<span class="pl-k">...</span>
    f       g       h
    g       h       f
    h       f       g
    it<span class="pl-k">+</span><span class="pl-c1">3</span>    it<span class="pl-k">*</span><span class="pl-c1">2</span>    it<span class="pl-k">+</span><span class="pl-c1">1</span>    
    them
}</pre></div>
<p dir="auto">The result of this chain is equivalent to <code>(h(g(f(a)))+3, f(h(g(b)))*2, g(f(h(c)))+1)</code>. Notice that the expression represents three chains; the three elements of the input argument have been splatted across the top row, and the values waterfall down to the bottom where they are collected into a tuple. The pronoun <code>it</code> is, again, local to each chain, and the pronoun <code>them</code>, any time it appears in a row, collects all <code>it</code>s from the previous row into a tuple. Another example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(2-2im).{
    real        imag
    it^2        it^2
    Complex(them...)
}"><pre>(<span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">2im</span>)<span class="pl-k">.</span>{
    real        imag
    it<span class="pl-k">^</span><span class="pl-c1">2</span>        it<span class="pl-k">^</span><span class="pl-c1">2</span>
    <span class="pl-c1">Complex</span>(them<span class="pl-k">...</span>)
}</pre></div>
<p dir="auto">Here, the input argument was *not* splatted across the top row. When the next row has more columns than the last, and the last did not splat, then the last element of the row above is copied across. At the bottom, the two chains came together and interacted by first being collected into <code>them</code>, which was then splatted into the <code>Complex</code> constructor.</p>
<blockquote>
<p dir="auto">Question for the reader: Is copying the <em>last</em> value across the preferred behavior? Or perhaps, would copying the sequence, e.g.:</p>
<p dir="auto">Suppose the last line had <code>1 2 3</code>, and the next line has <code>it it it it it it</code>. Current behavior would copy across <code>1 2 3 3 3 3</code>. But maybe it would be better to copy across <code>1 2 3 1 2 3</code>? Behavior is not fixed, and feedback is welcome.</p>
</blockquote>
<p dir="auto">It is presumed that each line will have the same number of expressions as the one above it. But if it doesn't, or if there is any splat on the previous line, or if there's any expression of <code>them</code> on the next line, then all the individual chains terminate, their values are collected into <code>them</code>, and new chains commence.</p>
<p dir="auto">Values can also be discarded, which causes their respective chains to end as well:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(a, b, c).{
    it...
    it      it      it
    it
    them
}"><pre>(a, b, c)<span class="pl-k">.</span>{
    it<span class="pl-k">...</span>
    it      it      it
    it
    them
}</pre></div>
<p dir="auto">In this case, the return value is a simple tuple <code>(a,)</code>. Values drop off the right side.</p>
<blockquote>
<p dir="auto">Question for the reader: Is dropping the <em>rightmost</em> values the preferred behavior? Or should we drop the left?</p>
</blockquote>
<p dir="auto">Values can also be duplicated, starting new chains:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(1).{
    it                      # 1
    it      it+1            # 1,2
    it      it      it+1    # 1,2,3
    them.+1...              # 2,3,4
    it      them.+1...      # 2,3,4,5
    them                    # collect at end
}"><pre>(<span class="pl-c1">1</span>)<span class="pl-k">.</span>{
    it                      <span class="pl-c"><span class="pl-c">#</span> 1</span>
    it      it<span class="pl-k">+</span><span class="pl-c1">1</span>            <span class="pl-c"><span class="pl-c">#</span> 1,2</span>
    it      it      it<span class="pl-k">+</span><span class="pl-c1">1</span>    <span class="pl-c"><span class="pl-c">#</span> 1,2,3</span>
    them<span class="pl-k">.+</span><span class="pl-c1">1</span><span class="pl-k">...</span>              <span class="pl-c"><span class="pl-c">#</span> 2,3,4</span>
    it      them<span class="pl-k">.+</span><span class="pl-c1">1</span><span class="pl-k">...</span>      <span class="pl-c"><span class="pl-c">#</span> 2,3,4,5</span>
    them                    <span class="pl-c"><span class="pl-c">#</span> collect at end</span>
}</pre></div>
<p dir="auto">In this case, the return value is <code>(2, 3, 4, 5)</code>.</p>
<p dir="auto">New chains can also be instantiated with an assignment to <code>it</code>. Previous values can also be splatted across new rows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(1,2).{
    it...
    it      (it, it+1)...
    it      it              it
    them[2:3]...
    it      it
    them
}"><pre>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)<span class="pl-k">.</span>{
    it<span class="pl-k">...</span>
    it      (it, it<span class="pl-k">+</span><span class="pl-c1">1</span>)<span class="pl-k">.</span><span class="pl-k">..</span>
    it      it              it
    them[<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">3</span>]<span class="pl-k">.</span><span class="pl-k">..</span>
    it      it
    them
}</pre></div>
<p dir="auto">The return value here is <code>(2, 3)</code>.</p>
<p dir="auto">It's a little funky to be playing around with expressions of just <code>it</code> and <code>them</code>, but it's instructive (and weirdly therapeutic), so try it!</p>
<p dir="auto">Fun question: On the line with two <code>it</code>s after <code>them[2:3]...</code>, what happens if you add another <code>it</code>? <g-emoji class="g-emoji" alias="smirk" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png">😏</g-emoji></p>
<h2 dir="auto"><a id="user-content-going-deeper" class="anchor" aria-hidden="true" href="#going-deeper"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Going Deeper</h2>
<p dir="auto">Let's discuss how it works, so you really understand what's going on.</p>
<p dir="auto">When you create a multi-chain (a method chain with multiple columns), first a "background chain" is started. The background chain has two local keywords defined, <code>it</code> and <code>them</code>. The keyword <code>it</code> acts just as before. The keyword <code>them</code> has interesting behavior, which we'll explore in a bit. Like expressions of <code>it</code>, expressions of <code>them</code> are not called, and are instead assigned to <code>it</code>. As with single chains, any variables defined in a multi-chain are local to that chain.</p>
<p dir="auto">When a row with more than one column starts, subchains begin (and execution of the background chain is paused). Any local variables in the background chain are accessible to the subchains, except that of course each sub-chain has its own local <code>it</code> defined.</p>
<p dir="auto">When sub-chains begin, they take their local <code>it</code> values as the elements of the background chain's collection <code>them</code>. Nominally, <code>them</code> is just a tuple <code>them=(it,)</code>. When new subchains exceed the length of <code>them</code>, then <code>last(them)</code> is copied across into the new chains' <code>it</code> values.</p>
<p dir="auto">When multiple chains exist, then <code>them</code> becomes a tuple of the chains' values. Also, if a value is splatted into a row, <code>them</code> slurps up those values.</p>
<p dir="auto">For any row where the number of columns changes, where an object is splatted across a row, or where <code>them</code> is accessed, all subchains are halted (destroying any locally-defined variables) and an inventory is taken of all the chains' local <code>it</code> values, which are collected into <code>them</code>.</p>
<p dir="auto">One non-intuitive consequence of this behavior is that, if you have a multi-chain where all you do is access <code>them</code> repeatedly (which, you'll remember, causes an assignment <code>it=them</code>), you just get a deeper and deeper nested tuple.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; (1,2,3).{them; them; them}
((((1, 2, 3),),),)"><pre>julia<span class="pl-k">&gt;</span> (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)<span class="pl-k">.</span>{them; them; them}
((((<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>),),),)</pre></div>
<p dir="auto">But that's okay! That's exactly how it should operate.</p>
<p dir="auto">As before, if you're not sure how a multi-chain will operate, run <code>@macroexpand @mc ...</code>. Let's see if you think its behavior is as intuitive and unambiguous as I think it is.</p>
<h2 dir="auto"><a id="user-content-examples-1" class="anchor" aria-hidden="true" href="#examples-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto"><em>Standard Deviation, Variance, and Maximum Absolute Deviation</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; (0:10...,).{
           avg = {len=it.{length}, sum(it)/len}
           μ = it.{avg}
           it .- μ

         # stdev     var      mad
           it.^2     it.^2    abs.(it)
           avg       avg      maximum
           sqrt      _        _
           them
       }
(3.1622776601683795, 10.0, 5.0)"><pre>julia<span class="pl-k">&gt;</span> (<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">10</span><span class="pl-k">...</span>,)<span class="pl-k">.</span>{
           avg <span class="pl-k">=</span> {len<span class="pl-k">=</span>it.{length}, <span class="pl-c1">sum</span>(it)<span class="pl-k">/</span>len}
           μ <span class="pl-k">=</span> it.{avg}
           it <span class="pl-k">.-</span> μ

         <span class="pl-c"><span class="pl-c">#</span> stdev     var      mad</span>
           it<span class="pl-k">.^</span><span class="pl-c1">2</span>     it<span class="pl-k">.^</span><span class="pl-c1">2</span>    <span class="pl-c1">abs</span>.(it)
           avg       avg      maximum
           sqrt      _        _
           them
       }
(<span class="pl-c1">3.1622776601683795</span>, <span class="pl-c1">10.0</span>, <span class="pl-c1">5.0</span>)</pre></div>
<p dir="auto">Notice that <code>_</code> is used as a continuation of the chain on the last line. <code>it</code> can also be used.</p>
<blockquote>
<p dir="auto">This behavior for <code>_</code> is experimental and not guaranteed for the future (pending a more final decision on the character's use in the language). Would've been perfect if I could use <code>⋮</code>, but it's defined to be an operator so I can't.</p>
</blockquote>
<p dir="auto">Note that if it's desired to make a chain shorter (e.g., because one chain is much longer than its adjacent chains), you can package several operations together inside <code>{}</code>. Within the context of a chain, it's syntax transformed away so a function needn't be declared.</p>
<p dir="auto">To inspect the intermediate values mid-chain:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; (0:10...,).{
           avg = {len=it.{length}; sum(it)/len}
           μ = it.{avg}             ; (@show μ; it)
           it .- μ                  ; @show it

         # stdev   var     mad
           it.^2   it.^2   abs.(it) ; @show(them)...
           avg     avg     maximum  ; @show(them)...
           sqrt    _       _        ; @show(them)...
           them
       }
(3.1622776601683795, 10.0, 5.0)"><pre>julia<span class="pl-k">&gt;</span> (<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">10</span><span class="pl-k">...</span>,)<span class="pl-k">.</span>{
           avg <span class="pl-k">=</span> {len<span class="pl-k">=</span>it.{length}; <span class="pl-c1">sum</span>(it)<span class="pl-k">/</span>len}
           μ <span class="pl-k">=</span> it.{avg}             ; (<span class="pl-c1">@show</span> μ; it)
           it <span class="pl-k">.-</span> μ                  ; <span class="pl-c1">@show</span> it

         <span class="pl-c"><span class="pl-c">#</span> stdev   var     mad</span>
           it<span class="pl-k">.^</span><span class="pl-c1">2</span>   it<span class="pl-k">.^</span><span class="pl-c1">2</span>   <span class="pl-c1">abs</span>.(it) ; <span class="pl-c1">@show</span>(them)<span class="pl-k">.</span><span class="pl-k">..</span>
           avg     avg     maximum  ; <span class="pl-c1">@show</span>(them)<span class="pl-k">.</span><span class="pl-k">..</span>
           sqrt    _       _        ; <span class="pl-c1">@show</span>(them)<span class="pl-k">.</span><span class="pl-k">..</span>
           them
       }
(<span class="pl-c1">3.1622776601683795</span>, <span class="pl-c1">10.0</span>, <span class="pl-c1">5.0</span>)</pre></div>
<p dir="auto"><em>FFT Butterfly</em></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@mc const toy_fft = {
    # setup
    Vector{ComplexF64}
    n = it.{length}
    if n == 2 return [it[1]+it[2]; it[1]-it[2]] else it end # base case
    W = exp(-2π*im/n)
    # butterfly
    it[1:2:end-1].{toy_fft}   it[2:2:end].{toy_fft}
    _                         it.*W.^(0:n÷2-1)
#   ⋮        ⋱                ⋰         ⋮
                (x1,x2)=them
#   ⋮        ⋰                ⋱         ⋮
    [x1.+x2          ;            x1.-x2]::Vector{ComplexF64}
}"><pre><span class="pl-c1">@mc</span> <span class="pl-k">const</span> toy_fft <span class="pl-k">=</span> {
    <span class="pl-c"><span class="pl-c">#</span> setup</span>
    Vector{ComplexF64}
    n <span class="pl-k">=</span> it.{length}
    <span class="pl-k">if</span> n <span class="pl-k">==</span> <span class="pl-c1">2</span> <span class="pl-k">return</span> [it[<span class="pl-c1">1</span>]<span class="pl-k">+</span>it[<span class="pl-c1">2</span>]; it[<span class="pl-c1">1</span>]<span class="pl-k">-</span>it[<span class="pl-c1">2</span>]] <span class="pl-k">else</span> it <span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> base case</span>
    W <span class="pl-k">=</span> <span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>π<span class="pl-k">*</span>im<span class="pl-k">/</span>n)
    <span class="pl-c"><span class="pl-c">#</span> butterfly</span>
    it[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">.</span>{toy_fft}   it[<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">end</span>]<span class="pl-k">.</span>{toy_fft}
    _                         it<span class="pl-k">.*</span>W<span class="pl-k">.^</span>(<span class="pl-c1">0</span><span class="pl-k">:</span>n<span class="pl-k">÷</span><span class="pl-c1">2</span><span class="pl-k">-</span><span class="pl-c1">1</span>)
<span class="pl-c"><span class="pl-c">#</span>   ⋮        ⋱                ⋰         ⋮</span>
                (x1,x2)<span class="pl-k">=</span>them
<span class="pl-c"><span class="pl-c">#</span>   ⋮        ⋰                ⋱         ⋮</span>
    [x1<span class="pl-k">.+</span>x2          ;            x1<span class="pl-k">.-</span>x2]<span class="pl-k">::</span><span class="pl-c1">Vector{ComplexF64}</span>
}</pre></div>
<p dir="auto">This is a fully-functioning recursive FFT. Note that this is radix-2 (i.e., it only works for arrays whose length is a power of two).</p>
<p dir="auto">On the performance front, there's no way these fourteen lines (ten excluding comments) will beat the monster that is FFTW (which is optimized to the hilt and uses memoization to store the twiddle factors), but it's a cute toy. As expected, it's definitely better than a DFT doing naïve matrix multiplication (whose time and resource consumption are <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="040ea332f7f856ba42f987969f3cde17">$O(n^2)$</math-renderer>, versus <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="040ea332f7f856ba42f987969f3cde17">$O(n\log n)$</math-renderer> for FFT):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @mc function dft(x̲)
           N = x̲.{length}
           ℱ = [exp(-2π*im*m*n/N) for m=0:N-1, n=0:N-1]
           ℱ * x̲
       end
dft (generic function with 1 method)

julia&gt; x=randn(2); @btime $x.{toy_fft}; @btime $x.{dft};
  45.197 ns (2 allocations: 192 bytes)
  162.435 ns (3 allocations: 320 bytes)

julia&gt; x=randn(4); @btime $x.{toy_fft}; @btime $x.{dft};
  245.596 ns (11 allocations: 1.09 KiB)
  409.000 ns (3 allocations: 592 bytes)

julia&gt; x=randn(8); @btime $x.{toy_fft}; @btime $x.{dft};
  669.737 ns (29 allocations: 3.19 KiB)
  1.320 μs (3 allocations: 1.44 KiB)

julia&gt; x=randn(16); @btime $x.{toy_fft}; @btime $x.{dft};
  1.540 μs (65 allocations: 7.97 KiB)
  4.857 μs (3 allocations: 4.78 KiB)

julia&gt; x=randn(32); @btime $x.{toy_fft}; @btime $x.{dft};
  3.325 μs (137 allocations: 18.70 KiB)
  18.800 μs (3 allocations: 17.25 KiB)

julia&gt; x=randn(64); @btime $x.{toy_fft}; @btime $x.{dft};
  7.075 μs (281 allocations: 42.34 KiB)
  127.500 μs (4 allocations: 66.17 KiB)

julia&gt; x=randn(128); @btime $x.{toy_fft}; @btime $x.{dft};
  15.000 μs (569 allocations: 94.25 KiB)
  379.300 μs (4 allocations: 260.30 KiB)

julia&gt; x=randn(256); @btime $x.{toy_fft}; @btime $x.{dft};
  32.400 μs (1145 allocations: 207.38 KiB)
  1.421 ms (4 allocations: 1.01 MiB)

julia&gt; x=randn(512); @btime $x.{toy_fft}; @btime $x.{dft};
  69.200 μs (2297 allocations: 451.62 KiB)
  5.528 ms (4 allocations: 4.02 MiB)

julia&gt; x=randn(1024); @btime $x.{toy_fft}; @btime $x.{dft};
  147.800 μs (4601 allocations: 976.12 KiB)
  21.369 ms (4 allocations: 16.03 MiB)

julia&gt; x=randn(2048); @btime $x.{toy_fft}; @btime $x.{dft};
  339.000 μs (9211 allocations: 2.05 MiB)
  84.898 ms (6 allocations: 64.06 MiB)

julia&gt; x=randn(4096); @btime $x.{toy_fft}; @btime $x.{dft};
  761.300 μs (18436 allocations: 4.38 MiB)
  340.492 ms (6 allocations: 256.13 MiB)

julia&gt; x=randn(8192); @btime $x.{toy_fft}; @btime $x.{dft};
  1.736 ms (36886 allocations: 9.32 MiB)
  1.363 s (6 allocations: 1.00 GiB)

julia&gt; x=randn(16384); @btime $x.{toy_fft}; @btime $x.{dft};
  3.881 ms (73786 allocations: 19.76 MiB)
  5.544 s (6 allocations: 4.00 GiB)

julia&gt; x=randn(32768); @btime $x.{toy_fft}; @btime $x.{dft};
  8.915 ms (147586 allocations: 41.77 MiB)
  22.615 s (6 allocations: 16.00 GiB)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@mc</span> <span class="pl-k">function</span> <span class="pl-en">dft</span>(x̲)
           N <span class="pl-k">=</span> x̲.{length}
           ℱ <span class="pl-k">=</span> [<span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>π<span class="pl-k">*</span>im<span class="pl-k">*</span>m<span class="pl-k">*</span>n<span class="pl-k">/</span>N) <span class="pl-k">for</span> m<span class="pl-k">=</span><span class="pl-c1">0</span><span class="pl-k">:</span>N<span class="pl-k">-</span><span class="pl-c1">1</span>, n<span class="pl-k">=</span><span class="pl-c1">0</span><span class="pl-k">:</span>N<span class="pl-k">-</span><span class="pl-c1">1</span>]
           ℱ <span class="pl-k">*</span> x̲
       <span class="pl-k">end</span>
dft (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">2</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">45.197</span> ns (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">192</span> bytes)
  <span class="pl-c1">162.435</span> ns (<span class="pl-c1">3</span> allocations<span class="pl-k">:</span> <span class="pl-c1">320</span> bytes)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">4</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">245.596</span> ns (<span class="pl-c1">11</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.09</span> KiB)
  <span class="pl-c1">409.000</span> ns (<span class="pl-c1">3</span> allocations<span class="pl-k">:</span> <span class="pl-c1">592</span> bytes)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">8</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">669.737</span> ns (<span class="pl-c1">29</span> allocations<span class="pl-k">:</span> <span class="pl-c1">3.19</span> KiB)
  <span class="pl-c1">1.320</span> μs (<span class="pl-c1">3</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.44</span> KiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">16</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">1.540</span> μs (<span class="pl-c1">65</span> allocations<span class="pl-k">:</span> <span class="pl-c1">7.97</span> KiB)
  <span class="pl-c1">4.857</span> μs (<span class="pl-c1">3</span> allocations<span class="pl-k">:</span> <span class="pl-c1">4.78</span> KiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">32</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">3.325</span> μs (<span class="pl-c1">137</span> allocations<span class="pl-k">:</span> <span class="pl-c1">18.70</span> KiB)
  <span class="pl-c1">18.800</span> μs (<span class="pl-c1">3</span> allocations<span class="pl-k">:</span> <span class="pl-c1">17.25</span> KiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">64</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">7.075</span> μs (<span class="pl-c1">281</span> allocations<span class="pl-k">:</span> <span class="pl-c1">42.34</span> KiB)
  <span class="pl-c1">127.500</span> μs (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">66.17</span> KiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">128</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">15.000</span> μs (<span class="pl-c1">569</span> allocations<span class="pl-k">:</span> <span class="pl-c1">94.25</span> KiB)
  <span class="pl-c1">379.300</span> μs (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">260.30</span> KiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">256</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">32.400</span> μs (<span class="pl-c1">1145</span> allocations<span class="pl-k">:</span> <span class="pl-c1">207.38</span> KiB)
  <span class="pl-c1">1.421</span> ms (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.01</span> MiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">512</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">69.200</span> μs (<span class="pl-c1">2297</span> allocations<span class="pl-k">:</span> <span class="pl-c1">451.62</span> KiB)
  <span class="pl-c1">5.528</span> ms (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">4.02</span> MiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">1024</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">147.800</span> μs (<span class="pl-c1">4601</span> allocations<span class="pl-k">:</span> <span class="pl-c1">976.12</span> KiB)
  <span class="pl-c1">21.369</span> ms (<span class="pl-c1">4</span> allocations<span class="pl-k">:</span> <span class="pl-c1">16.03</span> MiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">2048</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">339.000</span> μs (<span class="pl-c1">9211</span> allocations<span class="pl-k">:</span> <span class="pl-c1">2.05</span> MiB)
  <span class="pl-c1">84.898</span> ms (<span class="pl-c1">6</span> allocations<span class="pl-k">:</span> <span class="pl-c1">64.06</span> MiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">4096</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">761.300</span> μs (<span class="pl-c1">18436</span> allocations<span class="pl-k">:</span> <span class="pl-c1">4.38</span> MiB)
  <span class="pl-c1">340.492</span> ms (<span class="pl-c1">6</span> allocations<span class="pl-k">:</span> <span class="pl-c1">256.13</span> MiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">8192</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">1.736</span> ms (<span class="pl-c1">36886</span> allocations<span class="pl-k">:</span> <span class="pl-c1">9.32</span> MiB)
  <span class="pl-c1">1.363</span> s (<span class="pl-c1">6</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.00</span> GiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">16384</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">3.881</span> ms (<span class="pl-c1">73786</span> allocations<span class="pl-k">:</span> <span class="pl-c1">19.76</span> MiB)
  <span class="pl-c1">5.544</span> s (<span class="pl-c1">6</span> allocations<span class="pl-k">:</span> <span class="pl-c1">4.00</span> GiB)

julia<span class="pl-k">&gt;</span> x<span class="pl-k">=</span><span class="pl-c1">randn</span>(<span class="pl-c1">32768</span>); <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{toy_fft}; <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{dft};
  <span class="pl-c1">8.915</span> ms (<span class="pl-c1">147586</span> allocations<span class="pl-k">:</span> <span class="pl-c1">41.77</span> MiB)
  <span class="pl-c1">22.615</span> s (<span class="pl-c1">6</span> allocations<span class="pl-k">:</span> <span class="pl-c1">16.00</span> GiB)</pre></div>
<p dir="auto">GLHF!</p>
<h1 dir="auto">
<a id="user-content-performance-considerations" class="anchor" aria-hidden="true" href="#performance-considerations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance Considerations</h1>
<p dir="auto">When defining a chainlink, e.g.</p>
<p dir="auto"><code>chain = {f; g; h}</code>,</p>
<p dir="auto">a function is created, and on its first run with a particular type it will be compiled (whether called by <code>x.{chain}</code> or by <code>chain(x)</code>). In contrast, when calling <code>x.{f; g; h}</code> directly, no function is created or compiled, so execution occurs with minimum time and resources.</p>
<p dir="auto">If it's necessary to save a <code>chain</code> as a global object, it's recommended to set it to a constant value <code>const</code>. This is to avoid type-instability, which causes slower runtime:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; chain = {it+1}
{it + 1}

julia&gt; @btime (1).{chain}
  22.513 ns (0 allocations: 0 bytes)
2

julia&gt; const chain_const = {it+1}
{it + 1}

julia&gt; @btime (1).{chain_const}
  1.400 ns (0 allocations: 0 bytes)
2"><pre>julia<span class="pl-k">&gt;</span> chain <span class="pl-k">=</span> {it<span class="pl-k">+</span><span class="pl-c1">1</span>}
{it <span class="pl-k">+</span> <span class="pl-c1">1</span>}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> (<span class="pl-c1">1</span>)<span class="pl-k">.</span>{chain}
  <span class="pl-c1">22.513</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> chain_const <span class="pl-k">=</span> {it<span class="pl-k">+</span><span class="pl-c1">1</span>}
{it <span class="pl-k">+</span> <span class="pl-c1">1</span>}

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> (<span class="pl-c1">1</span>)<span class="pl-k">.</span>{chain_const}
  <span class="pl-c1">1.400</span> ns (<span class="pl-c1">0</span> allocations<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes)
<span class="pl-c1">2</span></pre></div>
<p dir="auto">Namely, when <code>chain</code> isn't a <code>const</code>, its type is not known at runtime so it must be boxed, and its return value is also unknown so that too must be boxed. But this is true of any global variable.</p>
<p dir="auto">When performing benchmarks, be careful to ensure the correct things are being measured. For example, let's try this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @btime [1,2].{it./2}
  70.329 ns (2 allocations: 160 bytes)
2-element Vector{Float64}:
 0.5
 1.0

julia&gt; x = [1,2];

julia&gt; @btime $x./2
  41.515 ns (1 allocation: 80 bytes)
2-element Vector{Float64}:
 0.5
 1.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]<span class="pl-k">.</span>{it<span class="pl-k">./</span><span class="pl-c1">2</span>}
  <span class="pl-c1">70.329</span> ns (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">160</span> bytes)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.5</span>
 <span class="pl-c1">1.0</span>

julia<span class="pl-k">&gt;</span> x <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>];

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x<span class="pl-k">./</span><span class="pl-c1">2</span>
  <span class="pl-c1">41.515</span> ns (<span class="pl-c1">1</span> allocation<span class="pl-k">:</span> <span class="pl-c1">80</span> bytes)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.5</span>
 <span class="pl-c1">1.0</span></pre></div>
<p dir="auto">From this test, it appears that the method chain has caused extra runtime and an extra allocation. However, this is just an artifact of the measurement technique, as you can easily confirm:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @btime [1,2]./2
  72.181 ns (2 allocations: 160 bytes)
2-element Vector{Float64}:
 0.5
 1.0

 julia&gt; @btime $x.{it./2}
  41.446 ns (1 allocation: 80 bytes)
2-element Vector{Float64}:
 0.5
 1.0"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]<span class="pl-k">.</span><span class="pl-k">/</span><span class="pl-c1">2</span>
  <span class="pl-c1">72.181</span> ns (<span class="pl-c1">2</span> allocations<span class="pl-k">:</span> <span class="pl-c1">160</span> bytes)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.5</span>
 <span class="pl-c1">1.0</span>

 julia<span class="pl-k">&gt;</span> <span class="pl-c1">@btime</span> <span class="pl-k">$</span>x.{it<span class="pl-k">./</span><span class="pl-c1">2</span>}
  <span class="pl-c1">41.446</span> ns (<span class="pl-c1">1</span> allocation<span class="pl-k">:</span> <span class="pl-c1">80</span> bytes)
<span class="pl-c1">2</span><span class="pl-k">-</span>element Vector{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.5</span>
 <span class="pl-c1">1.0</span></pre></div>
<h1 dir="auto">
<a id="user-content-errata--points-of-debate" class="anchor" aria-hidden="true" href="#errata--points-of-debate"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><em>Errata / Points of Debate</em>
</h1>
<ol dir="auto">
<li>I don't have multi-threading implemented yet.</li>
<li>
<del>It might also be nice to have macros to make it easier to call <code>println</code>, or otherwise ignore an expression's return value.</del> <code>@show</code> works perfectly.</li>
<li>To add: subchain splatting (so that long rows can be made by splatting in vertically arranged expressions)?</li>
<li>
<code>x.{f}</code> returns <code>f(x)</code>, and <code>x.{f,g}</code> returns <code>(f(x), g(x))</code>, but <code>x.{f,}</code> unfortunately returns <code>f(x)</code> because the parser doesn't tell them apart. This is pretty unfortunate.</li>
<li>As mentioned before: what's the best way to copy values into new chains, and drop old chains? Left-aligned, right-aligned, etc.?</li>
<li>
<code>{;}</code> creates a chainlink <code>{1}</code>. This is because <code>:({;})</code> parses as <code>:({1})</code>. Thankfully this is a degenerate case, but it's quite surprising when you find it.</li>
<li>Readme: discuss type assertions, <code>do</code> statements, and <code>recurse</code>.</li>
</ol>
</article></div>