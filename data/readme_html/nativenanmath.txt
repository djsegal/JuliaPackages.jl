<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-nativenanmath" class="anchor" aria-hidden="true" href="#nativenanmath"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NativeNaNMath</h1>
<p dir="auto"><a href="https://github.com/longemen3000/NativeNaNMath.jl/actions"><img src="https://github.com/longemen3000/NativeNaNMath.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/longemen3000/NativeNaNMath.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ab6f299232e343d10eeccbec94dd9aa8fa1660d25dc5a9da7240a22e40cc8952/68747470733a2f2f636f6465636f762e696f2f67682f6c6f6e67656d656e333030302f4e61746976654e614e4d6174682e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/longemen3000/NativeNaNMath.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Alternative approach to <a href="https://github.com/mlubin/NaNMath.jl">NaNMath.jl</a>, by using the functions available in Julia Base instead of the Libm ones.</p>
<p dir="auto">It should be (almost) drop-in replacement for NaNMath.jl.</p>
<h2 dir="auto"><a id="user-content-mathematic-functions" class="anchor" aria-hidden="true" href="#mathematic-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Mathematic functions:</h2>
<p dir="auto">The following functions are not exported but defined:</p>
<ul dir="auto">
<li>Logarithmic:
<ul dir="auto">
<li><code>log(x)</code>,<code>log1p(x)</code>,<code>log2(x)</code>,<code>log10(x)</code>,<code>log1p(x)</code></li>
<li><code>log(x,base)</code></li>
</ul>
</li>
<li>Trigonometric:
<ul dir="auto">
<li><code>sin(x)</code>,<code>cos(x)</code>,<code>tan(x)</code>,<code>cot(x)</code>,<code>sec(x)</code>,<code>csc(x)</code></li>
<li><code>sind(x)</code>,<code>cosd(x)</code>,<code>tand(x)</code>,<code>cotd(x)</code>,<code>secd(x)</code>,<code>cscd(x)</code></li>
<li><code>sinpi(x)</code>,<code>cospi(x)</code></li>
<li><code>sincos(x)</code>,<code>sincosd(x)</code>,<code>sincospi(x)</code></li>
<li><code>asin(x)</code>,<code>acos(x)</code>,<code>asec(x)</code>,<code>acsc(x)</code></li>
<li><code>asind(x)</code>,<code>acosd(x)</code>,<code>asecd(x)</code>,<code>acscd(x)</code></li>
</ul>
</li>
<li>Hyperbolic:
<ul dir="auto">
<li><code>acosh(x)</code>,<code>asech(x)</code>,<code>atanh(x)</code>,<code>acoth(x)</code></li>
</ul>
</li>
<li><code>sqrt(x)</code></li>
<li><code>pow(x,y)</code></li>
<li><code>min(x)</code>,<code>max(x)</code></li>
</ul>
<h2 dir="auto"><a id="user-content-skipnan" class="anchor" aria-hidden="true" href="#skipnan"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>skipnan</code></h2>
<p dir="auto">The package only exports a single function: <code>skipnan(itr)</code> that works in the same way that <code>skipmissing(itr)</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = collect(1.0:10.0)
x[end] = NaN
xn = skipnan(x)
sum(xn) #45"><pre>x <span class="pl-k">=</span> <span class="pl-c1">collect</span>(<span class="pl-c1">1.0</span><span class="pl-k">:</span><span class="pl-c1">10.0</span>)
x[<span class="pl-c1">end</span>] <span class="pl-k">=</span> <span class="pl-c1">NaN</span>
xn <span class="pl-k">=</span> <span class="pl-c1">skipnan</span>(x)
<span class="pl-c1">sum</span>(xn) <span class="pl-c"><span class="pl-c">#</span>45</span></pre></div>
<h2 dir="auto"><a id="user-content-nan" class="anchor" aria-hidden="true" href="#nan"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>nan</code></h2>
<p dir="auto">The package uses the <code>nan(::Type{&lt;:Real})</code> function to obtain an always valid NaN. on types that aren't capable of holding NaNs, (like all integers), it will return a promoted type that can hold NaNs (<code>Float64</code> for <code>Int8</code>,<code>Int16</code>,<code>Int32</code>,<code>Int64</code>, <code>BigFloat</code> for <code>BigInt</code>). on Rationals, <code>nan(Rational{T}) = nan(T)</code>. This function should satisfy <code>isnan(nan(T))</code></p>
<p dir="auto">It defaults to <code>zero(x)/zero(x)</code>.</p>
<h2 dir="auto"><a id="user-content-differences-with-nanmathjl" class="anchor" aria-hidden="true" href="#differences-with-nanmathjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Differences with NaNMath.jl</h2>
<ul dir="auto">
<li>instead of providing NaN-compatible <code>sum</code>, <code>maximum</code>, <code>minimum</code>, etc. It provides a nan-skipping iterator. it can reproduce almost all functionality, except some corner cases:
<ul dir="auto">
<li><code>sum(skipnan[NaN])</code> is <code>0.0</code> instead of <code>NaN</code>, because <code>collect(skipnan([NaN])) = Float64[]</code> and <code>sum(Float64[]) == 0.0</code></li>
<li><code>median(skipnan([NaN])</code> is not defined. same reason that with <code>sum</code>
Other than that, <code>skipnan</code> expands the NaN functionality to any reducing operator.</li>
</ul>
</li>
<li><code>pow(x::Integer,y::Integer)</code> will always promote to a float type.</li>
<li><code>NativeNaNMath.f(x)</code> where x is not a <code>Real</code> number will always default to <code>Base.f(x)</code>. This is useful because automatic differenciation and custom number types can use this package without overloading anything.</li>
</ul>
</article></div>