<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-sinkhorndistancejl" class="anchor" aria-hidden="true" href="#sinkhorndistancejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SinkhornDistance.jl</h1>
<p>a work in progress of the Sinkhorn matrix scaling algorithm for regularized
optimal transport. The plan is to have a small, simple implementation that
works on both CPU and GPU, and with autodiff systems. currently, it seems to work for this purpose (compatible with CuArrays and Flux). There is likely room for optimization, however.</p>
<p>The functions <code>sinkhorn_plan</code> and <code>sinkhorn_plan_log</code> take in a distance matrix and two marginals and spit out the optimal regularized plan after some number of iterations.</p>
<p>Possible future improvements include:</p>
<ul>
<li>convenience methods to directly compute the Sinkhorn distance as a single number</li>
<li>convenience methods using <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> to create distance matrices for common ground costs (Euclidean/Wasserstein, 0-1/Total Variation, etc.)</li>
</ul>
<h1><a id="user-content-relevant-papers" class="anchor" aria-hidden="true" href="#relevant-papers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>relevant papers</h1>
<p>The implementations are taken from Ch. 4 of the excellent:</p>
<p>Gabriel Peyré and Marco Cuturi. 2018. Computational Optimal Transport. arXiv:1803.00567 [stat] (March 2018). Retrieved October 31, 2018 from <a href="http://arxiv.org/abs/1803.00567" rel="nofollow">http://arxiv.org/abs/1803.00567</a></p>
<p>The paper that introduced the use of the Sinkhorn algorithm for optimal transport is:</p>
<p>Marco Cuturi. 2013. Sinkhorn distances: Lightspeed computation of optimal transport. In Advances in neural information processing systems, 2292–2300.</p>
</article></div>