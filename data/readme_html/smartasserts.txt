<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-smartasserts" class="anchor" aria-hidden="true" href="#smartasserts"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SmartAsserts</h1>
<p dir="auto"><a href="https://github.com/MrVPlusOne/SmartAsserts.jl/actions/workflows/test.yml"><img src="https://github.com/MrVPlusOne/SmartAsserts.jl/actions/workflows/test.yml/badge.svg" alt="Run tests" style="max-width: 100%;"></a></p>
<p dir="auto">A <code>@smart_assert</code> macro that automatically prints out argument values upon assertion failure, used to replace the standard <code>@assert</code>. Unlike <code>@assert</code>, these smart assertions can also be easily <a href="https://github.com/MrVPlusOne/SmartAsserts.jl#turning-off-the-assertions-at-compile-time">turned off at compile-time</a>.</p>
<p dir="auto"><strong>Note: Most of the functionalities of this package are being integrated into <a href="https://github.com/jw3126/ArgCheck.jl">ArgCheck.jl</a>. Considering using that package instead.</strong></p>
<h2 dir="auto"><a id="user-content-example-usages" class="anchor" aria-hidden="true" href="#example-usages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example Usages</h2>
<p dir="auto">A (failed) binary inequality assertion:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; let a = 5
           @smart_assert a &lt; 1
       end
ERROR: AssertionError: Condition `a &lt; 1` failed due to:
        `a` evaluates to 5
Stacktrace:
 [1] top-level scope
   @ REPL[156]:2"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">5</span>
           <span class="pl-c1">@smart_assert</span> a <span class="pl-k">&lt;</span> <span class="pl-c1">1</span>
       <span class="pl-k">end</span>
ERROR<span class="pl-k">:</span> AssertionError<span class="pl-k">:</span> Condition <span class="pl-s"><span class="pl-pds">`</span>a &lt; 1<span class="pl-pds">`</span></span> failed due to<span class="pl-k">:</span>
        <span class="pl-s"><span class="pl-pds">`</span>a<span class="pl-pds">`</span></span> evaluates to <span class="pl-c1">5</span>
Stacktrace<span class="pl-k">:</span>
 [<span class="pl-c1">1</span>] top<span class="pl-k">-</span>level scope
   @ REPL[<span class="pl-c1">156</span>]<span class="pl-k">:</span><span class="pl-c1">2</span></pre></div>
<p dir="auto">Functions with keyword arguments are also supported:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; let a = 1.0, rtol=0.1
           @smart_assert isapprox(a, sin(a), atol=0.05; rtol)
       end
ERROR: AssertionError: Condition `isapprox(a, sin(a), atol = 0.05; rtol)` failed due to:
        `a` evaluates to 1.0
        `sin(a)` evaluates to 0.8414709848078965
        `rtol` evaluates to 0.1
Stacktrace:
 [1] top-level scope
   @ REPL[177]:2"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">1.0</span>, rtol<span class="pl-k">=</span><span class="pl-c1">0.1</span>
           <span class="pl-c1">@smart_assert</span> <span class="pl-c1">isapprox</span>(a, <span class="pl-c1">sin</span>(a), atol<span class="pl-k">=</span><span class="pl-c1">0.05</span>; rtol)
       <span class="pl-k">end</span>
ERROR<span class="pl-k">:</span> AssertionError<span class="pl-k">:</span> Condition <span class="pl-s"><span class="pl-pds">`</span>isapprox(a, sin(a), atol = 0.05; rtol)<span class="pl-pds">`</span></span> failed due to<span class="pl-k">:</span>
        <span class="pl-s"><span class="pl-pds">`</span>a<span class="pl-pds">`</span></span> evaluates to <span class="pl-c1">1.0</span>
        <span class="pl-s"><span class="pl-pds">`</span>sin(a)<span class="pl-pds">`</span></span> evaluates to <span class="pl-c1">0.8414709848078965</span>
        <span class="pl-s"><span class="pl-pds">`</span>rtol<span class="pl-pds">`</span></span> evaluates to <span class="pl-c1">0.1</span>
Stacktrace<span class="pl-k">:</span>
 [<span class="pl-c1">1</span>] top<span class="pl-k">-</span>level scope
   @ REPL[<span class="pl-c1">177</span>]<span class="pl-k">:</span><span class="pl-c1">2</span></pre></div>
<p dir="auto">Like <code>@assert</code>, you can also provide an additional message as the second argument:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; let a = 5
           @smart_assert a &lt; 1 &quot;This should fail. 2a = $(2 * a)&quot;
       end
ERROR: AssertionError: This should fail. 2a = 10
Caused by Condition `a &lt; 1` failed due to:
        `a` evaluates to 5
Stacktrace:
 [1] top-level scope
   @ REPL[167]:2"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">5</span>
           <span class="pl-c1">@smart_assert</span> a <span class="pl-k">&lt;</span> <span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">"</span>This should fail. 2a = <span class="pl-v">$(<span class="pl-c1">2</span> <span class="pl-k">*</span> a)</span><span class="pl-pds">"</span></span>
       <span class="pl-k">end</span>
ERROR<span class="pl-k">:</span> AssertionError<span class="pl-k">:</span> This should fail. <span class="pl-c1">2</span>a <span class="pl-k">=</span> <span class="pl-c1">10</span>
Caused by Condition <span class="pl-s"><span class="pl-pds">`</span>a &lt; 1<span class="pl-pds">`</span></span> failed due to<span class="pl-k">:</span>
        <span class="pl-s"><span class="pl-pds">`</span>a<span class="pl-pds">`</span></span> evaluates to <span class="pl-c1">5</span>
Stacktrace<span class="pl-k">:</span>
 [<span class="pl-c1">1</span>] top<span class="pl-k">-</span>level scope
   @ REPL[<span class="pl-c1">167</span>]<span class="pl-k">:</span><span class="pl-c1">2</span></pre></div>
<h2 dir="auto"><a id="user-content-how-it-works" class="anchor" aria-hidden="true" href="#how-it-works"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How it works</h2>
<p dir="auto">Under the hood, an expression like <code>@smart_assert f(&lt;ex1&gt;, &lt;ex2&gt;)</code> is expanded by the macro into something like the following (with newly introduced variables renamed by macro hygiene)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="quote
    arg1 = &lt;ex1&gt;
    arg2 = &lt;ex2&gt;
    if !(f(arg1, arg2))
        eval_string = Main.join([&quot;\t`$(ex)` evaluates to $(val)&quot; for (ex, val) in Main.zip((&lt;ex1&gt;, &lt;ex2&gt;), (arg1, arg2))], &quot;\n&quot;)
        reason_text = &quot;Condition `f(&lt;ex1&gt;, &lt;ex2&gt;)` failed due to:\n&quot; * eval_string
        Main.throw(Main.AssertionError(reason))
    end
end"><pre><span class="pl-k">quote</span>
    arg1 <span class="pl-k">=</span> <span class="pl-k">&lt;</span>ex1<span class="pl-k">&gt;</span>
    arg2 <span class="pl-k">=</span> <span class="pl-k">&lt;</span>ex2<span class="pl-k">&gt;</span>
    <span class="pl-k">if</span> <span class="pl-k">!</span>(<span class="pl-c1">f</span>(arg1, arg2))
        eval_string <span class="pl-k">=</span> Main<span class="pl-k">.</span><span class="pl-c1">join</span>([<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span>`<span class="pl-v">$(ex)</span>` evaluates to <span class="pl-v">$(val)</span><span class="pl-pds">"</span></span> <span class="pl-k">for</span> (ex, val) <span class="pl-k">in</span> Main<span class="pl-k">.</span><span class="pl-c1">zip</span>((<span class="pl-k">&lt;</span>ex1<span class="pl-k">&gt;</span>, <span class="pl-k">&lt;</span>ex2<span class="pl-k">&gt;</span>), (arg1, arg2))], <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>)
        reason_text <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Condition `f(&lt;ex1&gt;, &lt;ex2&gt;)` failed due to:<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> <span class="pl-k">*</span> eval_string
        Main<span class="pl-k">.</span><span class="pl-c1">throw</span>(Main<span class="pl-k">.</span><span class="pl-c1">AssertionError</span>(reason))
    <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Note that a new local variable (<code>arg1</code> and <code>arg2</code>) is introduced for each expression to ensure that all expressions are only evaluated once. Thus, when the assertion fails, the original values that caused the assertion condition to fail will be printed out, avoiding re-evaluation.</p>
<h2 dir="auto"><a id="user-content-supported-syntax" class="anchor" aria-hidden="true" href="#supported-syntax"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Supported Syntax</h2>
<p dir="auto">Currently, additional information will be printed out for the following types of expressions:</p>
<ul dir="auto">
<li>
<p dir="auto">function calls: e.g., <code>a &lt;= b</code>, <code>bool_f(a,k1=...; k2...)</code></p>
</li>
<li>
<p dir="auto">type asserts: e.g., <code>Type1 &lt;: Type2</code></p>
</li>
<li>
<p dir="auto">comparison expressions: e.g., <code>a == b &lt;= c + d &lt;= e</code></p>
</li>
</ul>
<p dir="auto">For other cases, only the original condition expression will be printed but not their argument information.</p>
<h2 dir="auto"><a id="user-content-turning-off-the-assertions-at-compile-time" class="anchor" aria-hidden="true" href="#turning-off-the-assertions-at-compile-time"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Turning off the assertions (at compile-time)</h2>
<p dir="auto">Calling <code>SmartAsserts.set_enabled(false)</code> will make all future <code>@smart_assert</code>
be compiled into no-ops. Hence, simply call this at the beginning of your module
to disable all <code>@smart_asserts</code> in your project.
(You might also want to call <code>SmartAsserts.set_enabled(true)</code> at the end of your
module to not accidentally turn off others' <code>@smart_asserts</code>).</p>
</article></div>