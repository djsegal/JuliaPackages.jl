<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-sparsevectors" class="anchor" aria-hidden="true" href="#sparsevectors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SparseVectors</h1>
<p>A Julia package to support sparse vectors.</p>
<p><a href="https://travis-ci.org/JuliaSparse/SparseVectors.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/7ee50baf2eb581b0aa78d7175c249cbfd8517ecac1cead68ac3adc53554abab5/68747470733a2f2f7472617669732d63692e6f72672f4a756c69615370617273652f537061727365566563746f72732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaSparse/SparseVectors.jl.svg?branch=master" style="max-width:100%;"></a></p>
<h2><a id="user-content-overview" class="anchor" aria-hidden="true" href="#overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Overview</h2>
<p>Sparse data has become increasingly common in machine learning and related areas. For example, in document analysis, each document is often represented as a <em>sparse vector</em>, which each entry represents the number of occurrences of a certain word. However, the support of sparse vectors remains quite limited in Julia base.</p>
<p>This package provides two types <code>SparseVector</code> and <code>SparseVectorView</code> and a series of methods to work with <em>sparse vectors</em>. Specifically, this package provides the following functionalities:</p>
<ul>
<li>Construction of sparse vectors, either with given non-zero entries or randomly.</li>
<li>Get a view of a column in a sparse matrix (of CSC format), or a view of a range of columns.</li>
<li>Specialized arithmetic functions on sparse vectors, <em>e.g.</em> <code>+</code>, <code>-</code>, <code>*</code>, etc.</li>
<li>Specialized math functions on sparse vectors, <em>e.g.</em> <code>abs</code>, <code>abs2</code>, <code>exp</code>, <code>sin</code>, etc.</li>
<li>Specialized reduction functions on sparse vectors, <em>e.g.</em> <code>sum</code>, <code>vecnorm</code>, etc.</li>
<li>Specialized linear algebraic functions, <em>e.g.</em> <code>axpy!</code>, <code>dot</code>, <code>A * x</code>, <code>At_mul_B</code>, etc.</li>
</ul>
<p><strong>Note:</strong> Many of the functionalities implemented in this package may be migrated to Julia Base in <code>v0.5</code> development cycle.</p>
<h2><a id="user-content-types" class="anchor" aria-hidden="true" href="#types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Types</h2>
<p>This package defines two types.</p>
<ul>
<li><code>SparseVector</code>: a sparse vector that owns its memory</li>
<li><code>SparseVectorView</code>: a view of external data as a sparse vector.</li>
</ul>
<p>The formal definition of these types are listed below:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="immutable SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}
    n::Int              # the number of elements
    nzind::Vector{Ti}   # the indices of nonzeros
    nzval::Vector{Tv}   # the values of nonzeros
end

typealias CVecView{T} ContiguousView{T,1,Vector{T}}

immutable SparseVectorView{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}
    n::Int                  # the number of elements
    nzind::CVecView{Ti}     # the indices of nonzeros
    nzval::CVecView{Tv}     # the values of nonzeros
end
"><pre>immutable SparseVector{Tv,Ti<span class="pl-k">&lt;:</span><span class="pl-c1">Integer</span>} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractSparseVector{Tv,Ti}</span>
    n<span class="pl-k">::</span><span class="pl-c1">Int</span>              <span class="pl-c"><span class="pl-c">#</span> the number of elements</span>
    nzind<span class="pl-k">::</span><span class="pl-c1">Vector{Ti}</span>   <span class="pl-c"><span class="pl-c">#</span> the indices of nonzeros</span>
    nzval<span class="pl-k">::</span><span class="pl-c1">Vector{Tv}</span>   <span class="pl-c"><span class="pl-c">#</span> the values of nonzeros</span>
<span class="pl-k">end</span>

typealias CVecView{T} ContiguousView{T,<span class="pl-c1">1</span>,Vector{T}}

immutable SparseVectorView{Tv,Ti<span class="pl-k">&lt;:</span><span class="pl-c1">Integer</span>} <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractSparseVector{Tv,Ti}</span>
    n<span class="pl-k">::</span><span class="pl-c1">Int</span>                  <span class="pl-c"><span class="pl-c">#</span> the number of elements</span>
    nzind<span class="pl-k">::</span><span class="pl-c1">CVecView{Ti}</span>     <span class="pl-c"><span class="pl-c">#</span> the indices of nonzeros</span>
    nzval<span class="pl-k">::</span><span class="pl-c1">CVecView{Tv}</span>     <span class="pl-c"><span class="pl-c">#</span> the values of nonzeros</span>
<span class="pl-k">end</span></pre></div>
<h2><a id="user-content-constructors" class="anchor" aria-hidden="true" href="#constructors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Constructors</h2>
<p>An instance of <code>SparseVector</code> can be constructed as follows:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="SparseVector(n, nzind, nzval)  # constructs an instance by providing all fields
"><pre><span class="pl-c1">SparseVector</span>(n, nzind, nzval)  <span class="pl-c"><span class="pl-c">#</span> constructs an instance by providing all fields</span></pre></div>
<p>Here, all inputs will be used as fields as they are. The constructor will ensure that <code>length(nzind) == length(nzval)</code>. However, it will <em>NOT</em> examine the elements of <code>nzind</code> (<em>e.g.</em> the indexes are sorted, without duplication, and within the range <code>1:n</code>).</p>
<p>The package also provides a <code>sparsevector</code> function to construct a sparse vector in a variety of ways:</p>
<h4><a id="user-content-zero-sparse-vector" class="anchor" aria-hidden="true" href="#zero-sparse-vector"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>zero sparse vector</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# construct a zerp sparse vector of length `len` and element type `T`
sparsevector(T, len)  
"><pre><span class="pl-c"><span class="pl-c">#</span> construct a zerp sparse vector of length `len` and element type `T`</span>
<span class="pl-c1">sparsevector</span>(T, len)  </pre></div>
<h4><a id="user-content-with-given-lists-of-non-zero-entries" class="anchor" aria-hidden="true" href="#with-given-lists-of-non-zero-entries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>with given lists of non-zero entries</h4>
<p>The following methods construct a sparse vector of length <code>len</code>, with:</p>
<ul>
<li>non-zero indices, given by an integer vector <code>I</code></li>
<li>non-zero values, given by <code>V</code> (either a vector or a number)</li>
</ul>
<p><strong>Note:</strong></p>
<ul>
<li>When <code>len</code> is omitted, it is determined by <code>maximum(I)</code>.</li>
<li>Multiple values are allowed to be corresponding to the same index. These values are combined with a binary function/functor <code>combine</code>. When it is omitted, <code>AddFun</code> is used by default, meaning that the values are summed.</li>
</ul>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sparsevector(I, V, len, combine)
sparsevector(I, V, combine)
sparsevector(I, V, len)
sparsevector(I, V)
"><pre><span class="pl-c1">sparsevector</span>(I, V, len, combine)
<span class="pl-c1">sparsevector</span>(I, V, combine)
<span class="pl-c1">sparsevector</span>(I, V, len)
<span class="pl-c1">sparsevector</span>(I, V)</pre></div>
<h4><a id="user-content-from-an-associative-collection-eg-dict" class="anchor" aria-hidden="true" href="#from-an-associative-collection-eg-dict"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>from an associative collection (e.g. <em>Dict</em>)</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sparsevector(a, len)  # a is an instance of `Associative{Ti&lt;:Integer, Tv}`
sparsevector(a)  # length inferred as the maximum index
"><pre><span class="pl-c1">sparsevector</span>(a, len)  <span class="pl-c"><span class="pl-c">#</span> a is an instance of `Associative{Ti&lt;:Integer, Tv}`</span>
<span class="pl-c1">sparsevector</span>(a)  <span class="pl-c"><span class="pl-c">#</span> length inferred as the maximum index</span></pre></div>
<h4><a id="user-content-random-sparse-vector" class="anchor" aria-hidden="true" href="#random-sparse-vector"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>random sparse vector</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sprand(n, p)       # construct a random sparse vector with length n and density p
                   # the non-zero values are generated using rand(nnz)

sprand(n, p, T)    # construct a random sparse vector of element type T
                   # the non-zero values are generated using rand(T, nnz)

sprandn(n, p)      # construct a random sparse vector,
                   # where values follow standard Normal distribution

sprand(n, p, rfn)  # construct a random sparse vector,
                   # where the non-zero values are generated using rfn
"><pre><span class="pl-c1">sprand</span>(n, p)       <span class="pl-c"><span class="pl-c">#</span> construct a random sparse vector with length n and density p</span>
                   <span class="pl-c"><span class="pl-c">#</span> the non-zero values are generated using rand(nnz)</span>

<span class="pl-c1">sprand</span>(n, p, T)    <span class="pl-c"><span class="pl-c">#</span> construct a random sparse vector of element type T</span>
                   <span class="pl-c"><span class="pl-c">#</span> the non-zero values are generated using rand(T, nnz)</span>

<span class="pl-c1">sprandn</span>(n, p)      <span class="pl-c"><span class="pl-c">#</span> construct a random sparse vector,</span>
                   <span class="pl-c"><span class="pl-c">#</span> where values follow standard Normal distribution</span>

<span class="pl-c1">sprand</span>(n, p, rfn)  <span class="pl-c"><span class="pl-c">#</span> construct a random sparse vector,</span>
                   <span class="pl-c"><span class="pl-c">#</span> where the non-zero values are generated using rfn</span></pre></div>
<h2><a id="user-content-basic-methods" class="anchor" aria-hidden="true" href="#basic-methods"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basic methods</h2>
<p>Like other array types, <code>SparseVector</code> and <code>SparseVectorView</code> support all the basic methods for arrays:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="eltype(x)   # get the element type
ndims(x)    # get the number of dimensions (1)
length(x)   # get the length
size(x)     # get the size, i.e. (length(x),)

x[I]        # getindex with index(es) I,
            # where I can be either an integer or an integer array
x[i] = v    # set the i-th element of x to v
"><pre><span class="pl-c1">eltype</span>(x)   <span class="pl-c"><span class="pl-c">#</span> get the element type</span>
<span class="pl-c1">ndims</span>(x)    <span class="pl-c"><span class="pl-c">#</span> get the number of dimensions (1)</span>
<span class="pl-c1">length</span>(x)   <span class="pl-c"><span class="pl-c">#</span> get the length</span>
<span class="pl-c1">size</span>(x)     <span class="pl-c"><span class="pl-c">#</span> get the size, i.e. (length(x),)</span>

x[I]        <span class="pl-c"><span class="pl-c">#</span> getindex with index(es) I,</span>
            <span class="pl-c"><span class="pl-c">#</span> where I can be either an integer or an integer array</span>
x[i] <span class="pl-k">=</span> v    <span class="pl-c"><span class="pl-c">#</span> set the i-th element of x to v</span></pre></div>
<p>They also provide methods for extracting internal data structures:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="nnz(x)          # the number of stored entries
countnz(x)      # count the actual number of nonzero entries
nonzeroinds(x)  # get the vector of indices of non-zero values  
nonzeros(x)     # get the vector of non-zero values
"><pre><span class="pl-c1">nnz</span>(x)          <span class="pl-c"><span class="pl-c">#</span> the number of stored entries</span>
<span class="pl-c1">countnz</span>(x)      <span class="pl-c"><span class="pl-c">#</span> count the actual number of nonzero entries</span>
<span class="pl-c1">nonzeroinds</span>(x)  <span class="pl-c"><span class="pl-c">#</span> get the vector of indices of non-zero values  </span>
<span class="pl-c1">nonzeros</span>(x)     <span class="pl-c"><span class="pl-c">#</span> get the vector of non-zero values</span></pre></div>
<h2><a id="user-content-conversion" class="anchor" aria-hidden="true" href="#conversion"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Conversion</h2>
<p>The package supports conversion between sparse vectors and other types of arrays.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="convert(SparseVector, s)  # convert s to an instance of SparseVector
                          # s can be an instance of Vector or SparseMatrixCSC

convert(SparseVector{Tv}, s)  # convert the element-type of s to Tv
                              # where s is an instance of SparseVector

convert(SparseVector{Tv,Ti}, s)  # convert the element-type of s to Tv,
                                 # and the index-type of s to Ti,
                                 # where s is an instance of SparseVector

convert(SparseMatrixCSC, v)  # convert a sparse vector v to a sparse matrix
                             # with a single column

convert(SparseMatrixCSC{Tv}, v)
convert(SparseMatrixCSC{Tv,Ti}, v)
"><pre><span class="pl-c1">convert</span>(SparseVector, s)  <span class="pl-c"><span class="pl-c">#</span> convert s to an instance of SparseVector</span>
                          <span class="pl-c"><span class="pl-c">#</span> s can be an instance of Vector or SparseMatrixCSC</span>

<span class="pl-c1">convert</span>(SparseVector{Tv}, s)  <span class="pl-c"><span class="pl-c">#</span> convert the element-type of s to Tv</span>
                              <span class="pl-c"><span class="pl-c">#</span> where s is an instance of SparseVector</span>

<span class="pl-c1">convert</span>(SparseVector{Tv,Ti}, s)  <span class="pl-c"><span class="pl-c">#</span> convert the element-type of s to Tv,</span>
                                 <span class="pl-c"><span class="pl-c">#</span> and the index-type of s to Ti,</span>
                                 <span class="pl-c"><span class="pl-c">#</span> where s is an instance of SparseVector</span>

<span class="pl-c1">convert</span>(SparseMatrixCSC, v)  <span class="pl-c"><span class="pl-c">#</span> convert a sparse vector v to a sparse matrix</span>
                             <span class="pl-c"><span class="pl-c">#</span> with a single column</span>

<span class="pl-c1">convert</span>(SparseMatrixCSC{Tv}, v)
<span class="pl-c1">convert</span>(SparseMatrixCSC{Tv,Ti}, v)</pre></div>
<h2><a id="user-content-views" class="anchor" aria-hidden="true" href="#views"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Views</h2>
<p>The package provides methods to obtain views of sparse vectors or individual columns of a sparse matrix:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="view(x)   # construct a SparseVectorView instance as a view of x
          # where x is an instance of SparseVector

view(A, :, i)   # construct a view of the i-th column of X
                # where X is an instance of SparseMatrixCSC
                # returns a instance of SparseVectorView

getcol(A, i)   # get a copy of the i-th column of a sparse matrix A
               # returns an instance of SparseVector

unsafe_colrange(A, i1:i2)  # construct an unsafe view of a range of columns
                           # i.e. from the i1-th to i2-th column.
                           # returns an instance of SparseMatrixCSC
"><pre><span class="pl-c1">view</span>(x)   <span class="pl-c"><span class="pl-c">#</span> construct a SparseVectorView instance as a view of x</span>
          <span class="pl-c"><span class="pl-c">#</span> where x is an instance of SparseVector</span>

<span class="pl-c1">view</span>(A, :, i)   <span class="pl-c"><span class="pl-c">#</span> construct a view of the i-th column of X</span>
                <span class="pl-c"><span class="pl-c">#</span> where X is an instance of SparseMatrixCSC</span>
                <span class="pl-c"><span class="pl-c">#</span> returns a instance of SparseVectorView</span>

<span class="pl-c1">getcol</span>(A, i)   <span class="pl-c"><span class="pl-c">#</span> get a copy of the i-th column of a sparse matrix A</span>
               <span class="pl-c"><span class="pl-c">#</span> returns an instance of SparseVector</span>

<span class="pl-c1">unsafe_colrange</span>(A, i1<span class="pl-k">:</span>i2)  <span class="pl-c"><span class="pl-c">#</span> construct an unsafe view of a range of columns</span>
                           <span class="pl-c"><span class="pl-c">#</span> i.e. from the i1-th to i2-th column.</span>
                           <span class="pl-c"><span class="pl-c">#</span> returns an instance of SparseMatrixCSC</span></pre></div>
<p><strong>Note:</strong> <code>unsafe_colrange</code> uses <code>pointer_to_array</code> to obtain the internal vectors, and therefore the returned array should only be used within the local scope.</p>
<h2><a id="user-content-math-functions" class="anchor" aria-hidden="true" href="#math-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Math Functions</h2>
<p>The package implement a number of specialized math functions for sparse vectors.</p>
<h4><a id="user-content-arithmetics" class="anchor" aria-hidden="true" href="#arithmetics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Arithmetics</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="scale!(x, c)   # x &lt;- x * c, where c is a scalar
scale!(c, x)   # i.e. scale!(x, c)
scale(x, c)    # returns x * c
scale(c, x)    # i.e. scale(x, c)

x * c, x .* c  # multiple x and a scalar c
c * x, c .* x  # i.e. x * c

- x            # negate x
x + y, x .+ y  # add x and y, x and y can be either dense or sparse
x - y, x .- y  # subtract y from x, x and y can be either dense or sparse
x .* y         # multiply x and y (element-wise),
               # x and y can be either dense or sparse

axpy!(a, x, y)  # y &lt;- y + a * x
                # a: a scalar number
                # x: a sparse vector
                # y: a dense vector
"><pre><span class="pl-c1">scale!</span>(x, c)   <span class="pl-c"><span class="pl-c">#</span> x &lt;- x * c, where c is a scalar</span>
<span class="pl-c1">scale!</span>(c, x)   <span class="pl-c"><span class="pl-c">#</span> i.e. scale!(x, c)</span>
<span class="pl-c1">scale</span>(x, c)    <span class="pl-c"><span class="pl-c">#</span> returns x * c</span>
<span class="pl-c1">scale</span>(c, x)    <span class="pl-c"><span class="pl-c">#</span> i.e. scale(x, c)</span>

x <span class="pl-k">*</span> c, x <span class="pl-k">.*</span> c  <span class="pl-c"><span class="pl-c">#</span> multiple x and a scalar c</span>
c <span class="pl-k">*</span> x, c <span class="pl-k">.*</span> x  <span class="pl-c"><span class="pl-c">#</span> i.e. x * c</span>

<span class="pl-k">-</span> x            <span class="pl-c"><span class="pl-c">#</span> negate x</span>
x <span class="pl-k">+</span> y, x <span class="pl-k">.+</span> y  <span class="pl-c"><span class="pl-c">#</span> add x and y, x and y can be either dense or sparse</span>
x <span class="pl-k">-</span> y, x <span class="pl-k">.-</span> y  <span class="pl-c"><span class="pl-c">#</span> subtract y from x, x and y can be either dense or sparse</span>
x <span class="pl-k">.*</span> y         <span class="pl-c"><span class="pl-c">#</span> multiply x and y (element-wise),</span>
               <span class="pl-c"><span class="pl-c">#</span> x and y can be either dense or sparse</span>

<span class="pl-c1">axpy!</span>(a, x, y)  <span class="pl-c"><span class="pl-c">#</span> y &lt;- y + a * x</span>
                <span class="pl-c"><span class="pl-c">#</span> a: a scalar number</span>
                <span class="pl-c"><span class="pl-c">#</span> x: a sparse vector</span>
                <span class="pl-c"><span class="pl-c">#</span> y: a dense vector</span></pre></div>
<h4><a id="user-content-element-wise-math-functions" class="anchor" aria-hidden="true" href="#element-wise-math-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Element-wise math functions</h4>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Input: (sparse, sparse) --&gt; Output: sparse
# Input: (sparse, dense)  --&gt; Output: dense
# Input: (dense, sparse)  --&gt; Output: sparse

max(x, y), min(x, y)
complex(x, y)

# zero-preserving functions
#   Input: sparse --&gt; Output: sparse

abs(x), abs2(x)
real(x), imag(x), conj(x)
floor(x), ceil(x), trunc(x), round(x)
log1p(x), expm1(x),
sin(x), tan(x), sinpi(x), sind(x), tand(x),
asin(x), atan(x), asind(x), atand(x),
sinh(x), tanh(x), asinh(x), atanh(x)

# Non-zero-preserving functions
#   Input: sparse --&gt; Output: dense

exp(x), exp2(x), exp10(x), log(x), log2(x), log10(x),
cos(x), csc(x), cot(x), sec(x), cospi(x),
cosd(x), cscd(x), cotd(x), secd(x),
acos(x), acot(x), acosd(x), acotd(x),
cosh(x), csch(x), coth(x), sech(x),
acsch(x), asech(x)
"><pre><span class="pl-c"><span class="pl-c">#</span> Input: (sparse, sparse) --&gt; Output: sparse</span>
<span class="pl-c"><span class="pl-c">#</span> Input: (sparse, dense)  --&gt; Output: dense</span>
<span class="pl-c"><span class="pl-c">#</span> Input: (dense, sparse)  --&gt; Output: sparse</span>

<span class="pl-c1">max</span>(x, y), <span class="pl-c1">min</span>(x, y)
<span class="pl-c1">complex</span>(x, y)

<span class="pl-c"><span class="pl-c">#</span> zero-preserving functions</span>
<span class="pl-c"><span class="pl-c">#</span>   Input: sparse --&gt; Output: sparse</span>

<span class="pl-c1">abs</span>(x), <span class="pl-c1">abs2</span>(x)
<span class="pl-c1">real</span>(x), <span class="pl-c1">imag</span>(x), <span class="pl-c1">conj</span>(x)
<span class="pl-c1">floor</span>(x), <span class="pl-c1">ceil</span>(x), <span class="pl-c1">trunc</span>(x), <span class="pl-c1">round</span>(x)
<span class="pl-c1">log1p</span>(x), <span class="pl-c1">expm1</span>(x),
<span class="pl-c1">sin</span>(x), <span class="pl-c1">tan</span>(x), <span class="pl-c1">sinpi</span>(x), <span class="pl-c1">sind</span>(x), <span class="pl-c1">tand</span>(x),
<span class="pl-c1">asin</span>(x), <span class="pl-c1">atan</span>(x), <span class="pl-c1">asind</span>(x), <span class="pl-c1">atand</span>(x),
<span class="pl-c1">sinh</span>(x), <span class="pl-c1">tanh</span>(x), <span class="pl-c1">asinh</span>(x), <span class="pl-c1">atanh</span>(x)

<span class="pl-c"><span class="pl-c">#</span> Non-zero-preserving functions</span>
<span class="pl-c"><span class="pl-c">#</span>   Input: sparse --&gt; Output: dense</span>

<span class="pl-c1">exp</span>(x), <span class="pl-c1">exp2</span>(x), <span class="pl-c1">exp10</span>(x), <span class="pl-c1">log</span>(x), <span class="pl-c1">log2</span>(x), <span class="pl-c1">log10</span>(x),
<span class="pl-c1">cos</span>(x), <span class="pl-c1">csc</span>(x), <span class="pl-c1">cot</span>(x), <span class="pl-c1">sec</span>(x), <span class="pl-c1">cospi</span>(x),
<span class="pl-c1">cosd</span>(x), <span class="pl-c1">cscd</span>(x), <span class="pl-c1">cotd</span>(x), <span class="pl-c1">secd</span>(x),
<span class="pl-c1">acos</span>(x), <span class="pl-c1">acot</span>(x), <span class="pl-c1">acosd</span>(x), <span class="pl-c1">acotd</span>(x),
<span class="pl-c1">cosh</span>(x), <span class="pl-c1">csch</span>(x), <span class="pl-c1">coth</span>(x), <span class="pl-c1">sech</span>(x),
<span class="pl-c1">acsch</span>(x), <span class="pl-c1">asech</span>(x)</pre></div>
<h2><a id="user-content-reduction" class="anchor" aria-hidden="true" href="#reduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reduction</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sum(x)      # Compute the sum of elements
sumabs(x)   # Compute the sum of absolute values
sumabs2(x)  # Compute the sum of squared absolute values
maximum(x)  # Compute the maximum of elements (including zeros)
minimum(x)  # Compute the minimum of elements (including zeros)
maxabs(x)   # Compute the maximum of absolute values
minabs(x)   # Compute the minimum of absolute values

vecnorm(x, p=2)  # Compute the p-th order vector-norm

dot(x, y)   # Compute the dot product between x and y
            # x and y can be either dense or sparse vectors
"><pre><span class="pl-c1">sum</span>(x)      <span class="pl-c"><span class="pl-c">#</span> Compute the sum of elements</span>
<span class="pl-c1">sumabs</span>(x)   <span class="pl-c"><span class="pl-c">#</span> Compute the sum of absolute values</span>
<span class="pl-c1">sumabs2</span>(x)  <span class="pl-c"><span class="pl-c">#</span> Compute the sum of squared absolute values</span>
<span class="pl-c1">maximum</span>(x)  <span class="pl-c"><span class="pl-c">#</span> Compute the maximum of elements (including zeros)</span>
<span class="pl-c1">minimum</span>(x)  <span class="pl-c"><span class="pl-c">#</span> Compute the minimum of elements (including zeros)</span>
<span class="pl-c1">maxabs</span>(x)   <span class="pl-c"><span class="pl-c">#</span> Compute the maximum of absolute values</span>
<span class="pl-c1">minabs</span>(x)   <span class="pl-c"><span class="pl-c">#</span> Compute the minimum of absolute values</span>

<span class="pl-c1">vecnorm</span>(x, p<span class="pl-k">=</span><span class="pl-c1">2</span>)  <span class="pl-c"><span class="pl-c">#</span> Compute the p-th order vector-norm</span>

<span class="pl-c1">dot</span>(x, y)   <span class="pl-c"><span class="pl-c">#</span> Compute the dot product between x and y</span>
            <span class="pl-c"><span class="pl-c">#</span> x and y can be either dense or sparse vectors</span></pre></div>
<h2><a id="user-content-linear-algebra-matrix-vector-product" class="anchor" aria-hidden="true" href="#linear-algebra-matrix-vector-product"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Linear Algebra: Matrix-vector product</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# Note: the product is dense iff A is dense
A * x             # A * x (matrix-vector product)
At_mul_B(A, x)    # A.' * x, without explicitly transposing A
Ac_mul_B(A, x)    # A' * x, without explicitly conjugate-transposing A

# If you want to get a dense result even when both A and x are sparse
# then you can write:
densemv(A, x)               # A * x --&gt; dense vector
densemv(A, x; trans='N')    # A * x, as above
densemv(A, x; trans='T')    # transpose(A) * x -&gt; dense vector
densemv(A, x; trans='C')    # ctranspose(A) * x -&gt; dense vector

# Note: the following functions are only for cases where y is a strided vector
A_mul_B!(y, A, x)         # y &lt;- A * x
A_mul_B!(a, A, x, b, y)   # y &lt;- a * A * x + b * y
At_mul_B(y, A, x)         # y &lt;- A.' * x
At_mul_B!(a, A, x, b, y)  # y &lt;- a * A.' * x + b * y
Ac_mul_B(y, A, x)         # y &lt;- A' * x
Ac_mul_B!(a, A, x, b, y)  # y &lt;- a * A' * x + b * y
"><pre><span class="pl-c"><span class="pl-c">#</span> Note: the product is dense iff A is dense</span>
A <span class="pl-k">*</span> x             <span class="pl-c"><span class="pl-c">#</span> A * x (matrix-vector product)</span>
<span class="pl-c1">At_mul_B</span>(A, x)    <span class="pl-c"><span class="pl-c">#</span> A.' * x, without explicitly transposing A</span>
<span class="pl-c1">Ac_mul_B</span>(A, x)    <span class="pl-c"><span class="pl-c">#</span> A' * x, without explicitly conjugate-transposing A</span>

<span class="pl-c"><span class="pl-c">#</span> If you want to get a dense result even when both A and x are sparse</span>
<span class="pl-c"><span class="pl-c">#</span> then you can write:</span>
<span class="pl-c1">densemv</span>(A, x)               <span class="pl-c"><span class="pl-c">#</span> A * x --&gt; dense vector</span>
<span class="pl-c1">densemv</span>(A, x; trans<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>N<span class="pl-pds">'</span></span>)    <span class="pl-c"><span class="pl-c">#</span> A * x, as above</span>
<span class="pl-c1">densemv</span>(A, x; trans<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>T<span class="pl-pds">'</span></span>)    <span class="pl-c"><span class="pl-c">#</span> transpose(A) * x -&gt; dense vector</span>
<span class="pl-c1">densemv</span>(A, x; trans<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>)    <span class="pl-c"><span class="pl-c">#</span> ctranspose(A) * x -&gt; dense vector</span>

<span class="pl-c"><span class="pl-c">#</span> Note: the following functions are only for cases where y is a strided vector</span>
<span class="pl-c1">A_mul_B!</span>(y, A, x)         <span class="pl-c"><span class="pl-c">#</span> y &lt;- A * x</span>
<span class="pl-c1">A_mul_B!</span>(a, A, x, b, y)   <span class="pl-c"><span class="pl-c">#</span> y &lt;- a * A * x + b * y</span>
<span class="pl-c1">At_mul_B</span>(y, A, x)         <span class="pl-c"><span class="pl-c">#</span> y &lt;- A.' * x</span>
<span class="pl-c1">At_mul_B!</span>(a, A, x, b, y)  <span class="pl-c"><span class="pl-c">#</span> y &lt;- a * A.' * x + b * y</span>
<span class="pl-c1">Ac_mul_B</span>(y, A, x)         <span class="pl-c"><span class="pl-c">#</span> y &lt;- A' * x</span>
<span class="pl-c1">Ac_mul_B!</span>(a, A, x, b, y)  <span class="pl-c"><span class="pl-c">#</span> y &lt;- a * A' * x + b * y</span></pre></div>
</article></div>