<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-controlsystemidentification" class="anchor" aria-hidden="true" href="#controlsystemidentification"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ControlSystemIdentification</h1>
<p><a href="https://github.com/baggepinnen/ControlSystemIdentification.jl/actions"><img src="https://github.com/baggepinnen/ControlSystemIdentification.jl/workflows/CI/badge.svg" alt="CI" style="max-width:100%;"></a>
<a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/report.html" rel="nofollow"><img src="https://camo.githubusercontent.com/b373dccd73336608e973f80dd751d3c21b6a2013/68747470733a2f2f6a756c696163692e6769746875622e696f2f4e616e6f736f6c646965725265706f7274732f706b676576616c5f6261646765732f432f436f6e74726f6c53797374656d4964656e74696669636174696f6e2e737667" alt="PkgEval" data-canonical-src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/C/ControlSystemIdentification.svg" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/baggepinnen/ControlSystemIdentification.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ae4086c75f96a6149e5b8eb5113ae2ce9df2c776/68747470733a2f2f636f6465636f762e696f2f67682f626167676570696e6e656e2f436f6e74726f6c53797374656d4964656e74696669636174696f6e2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/baggepinnen/ControlSystemIdentification.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>System identification for <a href="https://github.com/JuliaControl/ControlSystems.jl/">ControlSystems.jl</a>. Examples in the form of jupyter notebooks are provided <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">here</a>.</p>
<h1><a id="user-content-lti-state-space-models" class="anchor" aria-hidden="true" href="#lti-state-space-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LTI state-space models</h1>
<p>There exist two methods for identification of statespace models, <code>n4sid</code> and <code>pem</code>. <code>n4sid</code> uses subspace-based identification whereas <code>pem</code> solves the prediction-error problem using an iterative optimization method (from Optim.jl). If unsure which method to use, try <code>n4sid</code> first.</p>
<h2><a id="user-content-subspace-based-identification-using-n4sid" class="anchor" aria-hidden="true" href="#subspace-based-identification-using-n4sid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Subspace based identification using n4sid</h2>
<div class="highlight highlight-source-julia"><pre>d <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u)
sys <span class="pl-k">=</span> <span class="pl-c1">n4sid</span>(d, <span class="pl-c1">:auto</span>; verbose<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c"><span class="pl-c">#</span> or use a robust version of svd if y has outliers or missing values</span>
<span class="pl-k">using</span> TotalLeastSquares
sys <span class="pl-k">=</span> <span class="pl-c1">n4sid</span>(d, <span class="pl-c1">:auto</span>; verbose<span class="pl-k">=</span><span class="pl-c1">false</span>, svd<span class="pl-k">=</span>x<span class="pl-k">-&gt;</span><span class="pl-c1">rpca</span>(x)[<span class="pl-c1">3</span>])</pre></div>
<p>Estimate a statespace model using the n4sid method. Returns an object of type <code>N4SIDResult</code> where the model is accessed as <code>sys.sys</code>.</p>
<h4><a id="user-content-arguments" class="anchor" aria-hidden="true" href="#arguments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments:</h4>
<ul>
<li><code>d</code>: Identification data object, created using <code>iddata(y,u)</code>.</li>
<li><code>y</code>: Measurements N×ny</li>
<li><code>u</code>: Control signal N×nu</li>
<li><code>r</code>: Rank of the model (model order)</li>
<li><code>verbose</code>: Print stuff?</li>
<li><code>i</code>: Algorithm parameter, generally no need to tune this</li>
<li><code>γ</code>: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.</li>
</ul>
<h3><a id="user-content-filtering-and-simulation" class="anchor" aria-hidden="true" href="#filtering-and-simulation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filtering and simulation</h3>
<p>Models can be simulated using <code>lsim</code> from ControlSystems.jl and using <code>simulate</code>. You may also convert the model to a <code>KalmanFilter</code> from <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl">LowLevelParticleFilters.jl</a> by calling <code>KalmanFilter(sys)</code>, after which you can perform filtering and smoothing etc. with the utilities provided for a <code>KalmanFilter</code>.</p>
<h2><a id="user-content-pem" class="anchor" aria-hidden="true" href="#pem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PEM</h2>
<p>A simple algorithm for identification of discrete-time LTI systems on state-space form:</p>
<pre lang="math"><code>x' = Ax + Bu + Ke
y  = Cx + e
</code></pre>
<p>is provided. The user can choose to minimize either prediction errors or simulation errors, with arbitrary metrics, i.e., not limited to squared errors.</p>
<p>The result of the identification is a custom type <code>StateSpaceNoise &lt;: ControlSystems.LTISystem</code>, with fields <code>A,B,K</code>, representing the dynamics matrix, input matrix and Kalman gain matrix, respectively. The observation matrix <code>C</code> is not stored, as this is always given by <code>[I 0]</code> (you can still access it through <code>sys.C</code> thanks to <code>getproperty</code>).</p>
<p>This package also supports estimating models on the form</p>
<pre lang="math"><code>Ay = Bu + Cw
</code></pre>
<p>through pseudo-linear regression.
Estimation of the more general model form</p>
<pre lang="math"><code>Ay = B/F u + C/D w
</code></pre>
<p>or any of its other special cases is not supported. Since those models are also LTI systems, estimating a state-space model is in some sense equivalent.</p>
<p>Transfer-function estimation through spectral methods is supported through the functions <code>tfest</code> and <code>coherence</code>.</p>
<h3><a id="user-content-usage-example" class="anchor" aria-hidden="true" href="#usage-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage example</h3>
<p>Below, we generate a system and simulate it forward in time. We then try to estimate a model based on the input and output sequences.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ControlSystemIdentification, ControlSystems, Random, LinearAlgebra

<span class="pl-k">function</span> ⟂(x)
    u,s,v <span class="pl-k">=</span> <span class="pl-c1">svd</span>(x)
    u<span class="pl-k">*</span>v
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">generate_system</span>(nx,ny,nu)
    U,S  <span class="pl-k">=</span> ⟂(<span class="pl-c1">randn</span>(nx,nx)), <span class="pl-c1">diagm</span>(<span class="pl-c1">0</span><span class="pl-k">=&gt;</span><span class="pl-c1">0.2</span> <span class="pl-k">.+</span> <span class="pl-c1">0.5</span><span class="pl-c1">rand</span>(nx))
    A    <span class="pl-k">=</span> S<span class="pl-k">*</span>U
    B   <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nx,nu)
    C   <span class="pl-k">=</span> <span class="pl-c1">randn</span>(ny,nx)
    sys <span class="pl-k">=</span> <span class="pl-c1">ss</span>(A,B,C,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>)
<span class="pl-k">end</span>

Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1</span>)
T   <span class="pl-k">=</span> <span class="pl-c1">1000</span>                      <span class="pl-c"><span class="pl-c">#</span> Number of time steps</span>
nx  <span class="pl-k">=</span> <span class="pl-c1">3</span>                         <span class="pl-c"><span class="pl-c">#</span> Number of poles in the true system</span>
nu  <span class="pl-k">=</span> <span class="pl-c1">1</span>                         <span class="pl-c"><span class="pl-c">#</span> Number of control inputs</span>
ny  <span class="pl-k">=</span> <span class="pl-c1">1</span>                         <span class="pl-c"><span class="pl-c">#</span> Number of outputs</span>
x0  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nx)                 <span class="pl-c"><span class="pl-c">#</span> Initial state</span>
<span class="pl-en">sim</span>(sys,u,x0<span class="pl-k">=</span>x0) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u<span class="pl-k">'</span>, <span class="pl-c1">1</span><span class="pl-k">:</span>T, x0<span class="pl-k">=</span>x0)[<span class="pl-c1">1</span>]' <span class="pl-c"><span class="pl-c">#</span> Helper function</span>
sys <span class="pl-k">=</span> <span class="pl-c1">generate_system</span>(nx,nu,ny)
u   <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nu,T)               <span class="pl-c"><span class="pl-c">#</span> Generate random input</span>
y   <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u, x0)           <span class="pl-c"><span class="pl-c">#</span> Simulate system</span>
d   <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u)

sysh,x0h,opt <span class="pl-k">=</span> <span class="pl-c1">pem</span>(d, nx<span class="pl-k">=</span>nx, focus<span class="pl-k">=</span><span class="pl-c1">:prediction</span>) <span class="pl-c"><span class="pl-c">#</span> Estimate model</span>

yh <span class="pl-k">=</span> <span class="pl-c1">predict</span>(sysh, d, x0h)      <span class="pl-c"><span class="pl-c">#</span> Predict using estimated model</span>
<span class="pl-c1">plot</span>([y; yh]', lab<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>ŷ<span class="pl-pds">"</span></span>])   <span class="pl-c"><span class="pl-c">#</span> Plot prediction and true output</span></pre></div>
<p>We can also simulate the system with colored noise, necessitating estimating also noise models.</p>
<div class="highlight highlight-source-julia"><pre>σu <span class="pl-k">=</span> <span class="pl-c1">0.1</span> <span class="pl-c"><span class="pl-c">#</span> Noise variances</span>
σy <span class="pl-k">=</span> <span class="pl-c1">0.1</span>

sysn <span class="pl-k">=</span> <span class="pl-c1">generate_system</span>(nx,nu,ny)             <span class="pl-c"><span class="pl-c">#</span> Noise system</span>
un   <span class="pl-k">=</span> u <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, σu<span class="pl-k">*</span><span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)),<span class="pl-c1">0</span><span class="pl-k">*</span>x0) <span class="pl-c"><span class="pl-c">#</span> Input + load disturbance</span>
y    <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, un, x0)
yn   <span class="pl-k">=</span> y <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, σy<span class="pl-k">*</span><span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)),<span class="pl-c1">0</span><span class="pl-k">*</span>x0) <span class="pl-c"><span class="pl-c">#</span> Output + measurement noise</span>
dn   <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,un)</pre></div>
<p>The system now has <code>3nx</code> poles, <code>nx</code> for the system dynamics, and <code>nx</code> for each noise model, we indicated this to the main estimation function <code>pem</code>:</p>
<div class="highlight highlight-source-julia"><pre>sysh,x0h,opt <span class="pl-k">=</span> <span class="pl-c1">pem</span>(dn,nx<span class="pl-k">=</span><span class="pl-c1">3</span>nx, focus<span class="pl-k">=</span><span class="pl-c1">:prediction</span>)
yh           <span class="pl-k">=</span> <span class="pl-c1">predict</span>(sysh, dn, x0h) <span class="pl-c"><span class="pl-c">#</span> Form prediction</span>
<span class="pl-c1">plot</span>([y; yh]', lab<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>ŷ<span class="pl-pds">"</span></span>])             <span class="pl-c"><span class="pl-c">#</span> Compare true output (without noise) to prediction</span></pre></div>
<p>We can have a look at the singular values of a balanced system Gramian:</p>
<div class="highlight highlight-source-julia"><pre>s    <span class="pl-k">=</span> <span class="pl-c1">ss</span>(sysh)   <span class="pl-c"><span class="pl-c">#</span> Convert to standard state-space type</span>
s2,G <span class="pl-k">=</span> <span class="pl-c1">balreal</span>(s) <span class="pl-c"><span class="pl-c">#</span> Form balanced representation (obs. and ctrb. Gramians are the same</span>
<span class="pl-c1">diag</span>(G)           <span class="pl-c"><span class="pl-c">#</span> Singular values of Gramians</span>

<span class="pl-c"><span class="pl-c">#</span> 9-element Array{Float64,1}:</span>
<span class="pl-c"><span class="pl-c">#</span>  3.5972307807882844    </span>
<span class="pl-c"><span class="pl-c">#</span>  0.19777167699663994   </span>
<span class="pl-c"><span class="pl-c">#</span>  0.0622528285731599    </span>
<span class="pl-c"><span class="pl-c">#</span>  0.004322765397504325  </span>
<span class="pl-c"><span class="pl-c">#</span>  0.004270259700592557  </span>
<span class="pl-c"><span class="pl-c">#</span>  0.003243449461350837  </span>
<span class="pl-c"><span class="pl-c">#</span>  0.003150873301312319  </span>
<span class="pl-c"><span class="pl-c">#</span>  0.0005827927965893053</span>
<span class="pl-c"><span class="pl-c">#</span>  0.00029732262107216666</span></pre></div>
<p>Note that there are 3 big singular values, corresponding to the system poles, there are also 2×3 smaller singular values, corresponding to the noise dynamics.</p>
<p>The estimated noise model can be extracted by <code>noise_model(sys)</code>, we can visualize it with a bodeplot.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">bodeplot</span>(<span class="pl-c1">noise_model</span>(sysh), <span class="pl-c1">exp10</span>.(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">3</span>, stop<span class="pl-k">=</span><span class="pl-c1">0</span>, length<span class="pl-k">=</span><span class="pl-c1">200</span>)), title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Estimated noise dynamics<span class="pl-pds">"</span></span>)</pre></div>
<p>See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for these plots.</p>
<h3><a id="user-content-call-signature" class="anchor" aria-hidden="true" href="#call-signature"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Call signature</h3>
<p><code>sys, x0, opt = pem(d; nx, kwargs...)</code></p>
<h4><a id="user-content-arguments-1" class="anchor" aria-hidden="true" href="#arguments-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments:</h4>
<ul>
<li><code>d</code>: Identification data object, created using <code>iddata(y,u [,sampletime=nothing])</code></li>
<li><code>y</code>: Measurements, either a matrix with time along dim 2, or a vector of vectors</li>
<li><code>u</code>: Control signals, same structure as <code>y</code></li>
<li><code>nx</code>: Number of poles in the estimated system. This number should be chosen as number of system poles plus number of poles in noise models for measurement noise and load disturbances.</li>
<li><code>focus</code>: Either <code>:prediction</code> or <code>:simulation</code>. If <code>:simulation</code> is chosen, a two stage problem is solved with prediction focus first, followed by a refinement for simulation focus.</li>
<li><code>metric</code>: A Function determining how the size of the residuals is measured, default <code>sse</code> (e'e), but any Function such as <code>norm</code>, <code>e-&gt;sum(abs,e)</code> or <code>e -&gt; e'Q*e</code> could be used.</li>
<li><code>regularizer(p) = 0</code>: function for regularization of the parameter vector <code>p</code>. The structure of <code>p</code> is detailed below. L₂ regularization, for instance, can be achieved by <code>regularizer = p-&gt;sum(abs2, p)</code></li>
<li><code>solver</code> Defaults to <code>Optim.BFGS()</code></li>
<li><code>kwargs</code>: additional keyword arguments are sent to <a href="http://julianlsolvers.github.io/Optim.jl/stable/#user/config/" rel="nofollow"><code>Optim.Options</code></a>.</li>
</ul>
<h4><a id="user-content-structure-of-parameter-vector-p" class="anchor" aria-hidden="true" href="#structure-of-parameter-vector-p"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Structure of parameter vector <code>p</code></h4>
<div class="highlight highlight-source-julia"><pre>A  <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx,ny)
B  <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx,nu)
K  <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx,ny)
x0 <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx)
p  <span class="pl-k">=</span> [A[:];B[:];K[:];x0]</pre></div>
<h3><a id="user-content-return-values" class="anchor" aria-hidden="true" href="#return-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Return values</h3>
<ul>
<li><code>sys::StateSpaceNoise</code>: identified system. Can be converted to <code>StateSpace</code> by <code>convert(StateSpace, sys)</code> or <code>ss(sys)</code>, but this will discard the Kalman gain matrix, see <code>innovation_form</code>.</li>
<li><code>x0</code>: Estimated initial state</li>
<li><code>opt</code>: Optimization problem structure. Contains info of the result of the optimization problem</li>
</ul>
<h3><a id="user-content-functions" class="anchor" aria-hidden="true" href="#functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functions</h3>
<ul>
<li><code>pem</code>: Main estimation function, see above.</li>
<li><code>predict(sys, d, x0=zeros)</code>: Form predictions using estimated <code>sys</code>, this essentially runs a stationary Kalman filter.</li>
<li><code>simulate(sys, u, x0=zeros)</code>: Simulate the system using input <code>u</code>. The noise model and Kalman gain does not have any influence on the simulated output.</li>
<li><code>innovation_form</code>: Extract the noise model from the estimated system (<code>ss(A,K,C,0)</code>).</li>
</ul>
<h3><a id="user-content-internals" class="anchor" aria-hidden="true" href="#internals"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Internals</h3>
<p>Internally, <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> is used to optimize the system parameters, using automatic differentiation to calculate gradients (and Hessians where applicable). Optim solver options can be controlled by passing keyword arguments to <code>pem</code>, and by passing a manually constructed solver object. The default solver is <a href="http://julianlsolvers.github.io/Optim.jl/stable/#algo/lbfgs/" rel="nofollow"><code>BFGS()</code></a></p>
<h1><a id="user-content-arx-and-plr-estimation" class="anchor" aria-hidden="true" href="#arx-and-plr-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ARX and PLR estimation</h1>
<p>Basic support for ARX/ARMAX model estimation, i.e. a model on any of the forms</p>
<pre lang="math"><code>Ay = Bu + w
Ay = Bu + Cw
</code></pre>
<p>is provided. The ARX estimation problem is convex and the solution is available on closed-form.
Usage example:</p>
<div class="highlight highlight-source-julia"><pre>N  <span class="pl-k">=</span> <span class="pl-c1">2000</span>     <span class="pl-c"><span class="pl-c">#</span> Number of time steps</span>
t  <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
Δt <span class="pl-k">=</span> <span class="pl-c1">1</span>        <span class="pl-c"><span class="pl-c">#</span> Sample time</span>
u  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(N) <span class="pl-c"><span class="pl-c">#</span> A random control input</span>
G  <span class="pl-k">=</span> <span class="pl-c1">tf</span>(<span class="pl-c1">0.8</span>, [<span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">0.9</span>], <span class="pl-c1">1</span>)
y  <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(G,u,t)[<span class="pl-c1">1</span>][:]
yn <span class="pl-k">=</span> y
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,Δt)

na,nb <span class="pl-k">=</span> <span class="pl-c1">1</span>,<span class="pl-c1">1</span>   <span class="pl-c"><span class="pl-c">#</span> Number of polynomial coefficients</span>

Gls <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb,stochastic<span class="pl-k">=</span><span class="pl-c1">false</span>) <span class="pl-c"><span class="pl-c">#</span> set stochastic to true to get a transfer function of MonteCarloMeasurements.Particles</span>
<span class="pl-c1">@show</span> Gls
<span class="pl-c"><span class="pl-c">#</span> TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.8000000000000005</span>
<span class="pl-c"><span class="pl-c">#</span> --------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.8999999999999997</span></pre></div>
<p>As we can see, the model is perfectly recovered. In reality, the measurement signal is often affected by noise, in which case the estimation will suffer. To combat this, a few different options exist:</p>
<div class="highlight highlight-source-julia"><pre>e  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(N)
yn <span class="pl-k">=</span> y <span class="pl-k">+</span> e    <span class="pl-c"><span class="pl-c">#</span> Measurement signal with noise</span>
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,u,Δt)

na,nb,nc <span class="pl-k">=</span> <span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>

Gls      <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb, stochastic<span class="pl-k">=</span><span class="pl-c1">true</span>)     <span class="pl-c"><span class="pl-c">#</span> Regular least-squares estimation</span>
Gtls     <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb, estimator<span class="pl-k">=</span>tls)       <span class="pl-c"><span class="pl-c">#</span> Total least-squares estimation</span>
Gwtls    <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb, estimator<span class="pl-k">=</span><span class="pl-c1">wtls_estimator</span>(y,na,nb)) <span class="pl-c"><span class="pl-c">#</span> Weighted Total least-squares estimation</span>
Gplr, Gn <span class="pl-k">=</span> <span class="pl-c1">plr</span>(d,na,nb,nc, initial_order<span class="pl-k">=</span><span class="pl-c1">20</span>) <span class="pl-c"><span class="pl-c">#</span> Pseudo-linear regression</span>
<span class="pl-c1">@show</span> Gls; <span class="pl-c1">@show</span>  Gtls; <span class="pl-c1">@show</span>  Gwtls; <span class="pl-c1">@show</span>  Gplr; <span class="pl-c1">@show</span>  Gn;
<span class="pl-c"><span class="pl-c">#</span> TransferFunction{ControlSystems.SisoRational{MonteCarloMeasurements.Particles{Float64,500}}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.824 ± 0.029</span>
<span class="pl-c"><span class="pl-c">#</span> ---------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.713 ± 0.013</span>

<span class="pl-c"><span class="pl-c">#</span> Gtls = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     1.848908051191616</span>
<span class="pl-c"><span class="pl-c">#</span> -------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.774385918070221</span>

<span class="pl-c"><span class="pl-c">#</span> Gwtls = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>    0.8180228878106678</span>
<span class="pl-c"><span class="pl-c">#</span> -------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.891939152690534</span>

<span class="pl-c"><span class="pl-c">#</span> Gplr = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.8221837077656046</span>
<span class="pl-c"><span class="pl-c">#</span> --------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.8896345125395438</span>

<span class="pl-c"><span class="pl-c">#</span> Gn = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.9347035105826179</span>
<span class="pl-c"><span class="pl-c">#</span> --------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.8896345125395438</span></pre></div>
<p>We now see that the estimate using standard least-squares is heavily biased and it is wrongly certain about the estimate (notice the ± in the transfer function coefficients). Regular Total least-squares does not work well in this example, since not all variables in the regressor contain equally much noise. Weighted total least-squares does a reasonable job at recovering the true model. Pseudo-linear regression also fares okay, while simultaneously estimating a noise model. The helper function <code>wtls_estimator(y,na,nb)</code> returns a function that performs <code>wtls</code> using appropriately sized covariance matrices, based on the length of <code>y</code> and the model orders. Weighted total least-squares estimation is provided by <a href="https://github.com/baggepinnen/TotalLeastSquares.jl">TotalLeastSquares.jl</a>. See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for more details.</p>
<p>Uncertain transfer function with <code>Particles</code> coefficients can be used like any other model. Try, e.g., <code>nyquistplot(Gls)</code> to get a Nyquist plot with confidence bounds.</p>
<p>See also function <code>arma</code> for estimation of signal models without inputs.</p>
<h2><a id="user-content-functions-1" class="anchor" aria-hidden="true" href="#functions-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functions</h2>
<ul>
<li><code>arx</code>: Transfer-function estimation using closed-form solution.</li>
<li><code>ar</code>: Estimate an AR model.</li>
<li><code>arma</code>: Estimate an ARMA model.</li>
<li><code>plr</code>: Transfer-function estimation using pseudo-linear regression</li>
<li><code>getARXregressor/getARregressor</code>: For low-level control over the estimation
See docstrings for further help.</li>
</ul>
<h2><a id="user-content-model-based-spectral-estimation" class="anchor" aria-hidden="true" href="#model-based-spectral-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Model-based spectral estimation</h2>
<p>The model estimation procedures can be used to estimate spectrograms. This package extends some methods from DSP.jl to accept a estimation function as the second argument. To create a suitable such function, we provide the function <code>model_spectrum</code>. Usage is illustrated below.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> ControlSystemIdentification, DSP
T  <span class="pl-k">=</span> <span class="pl-c1">1000</span>
fs <span class="pl-k">=</span> <span class="pl-c1">1</span>
s <span class="pl-k">=</span> <span class="pl-c1">sin</span>.((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span>fs<span class="pl-k">:</span>T) <span class="pl-k">.*</span> <span class="pl-c1">2</span>pi<span class="pl-k">/</span><span class="pl-c1">10</span>) <span class="pl-k">+</span> <span class="pl-c1">0.5</span><span class="pl-c1">randn</span>(T)
S1 <span class="pl-k">=</span> <span class="pl-c1">spectrogram</span>(s,window<span class="pl-k">=</span>hanning, fs<span class="pl-k">=</span>fs)            <span class="pl-c"><span class="pl-c">#</span> Standard spectrogram</span>
estimator <span class="pl-k">=</span> <span class="pl-c1">model_spectrum</span>(ar,fs,<span class="pl-c1">6</span>)
S2 <span class="pl-k">=</span> <span class="pl-c1">spectrogram</span>(s,estimator,window<span class="pl-k">=</span>rect, fs<span class="pl-k">=</span>fs)     <span class="pl-c"><span class="pl-c">#</span> Model-based spectrogram</span>
<span class="pl-c1">plot</span>(<span class="pl-c1">plot</span>(S1,title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Standard Spectrogram<span class="pl-pds">"</span></span>),<span class="pl-c1">plot</span>(S2,title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>AR Spectrogram<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">#</span> Requires the package LPVSpectral.jl</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/ar_spectrogram.svg"><img src="figs/ar_spectrogram.svg" alt="window" style="max-width:100%;"></a></p>
<h1><a id="user-content-transfer-function-estimation-using-spectral-techniques" class="anchor" aria-hidden="true" href="#transfer-function-estimation-using-spectral-techniques"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transfer-function estimation using spectral techniques</h1>
<p>Non-parametric estimation is provided through spectral estimation. To illustrate, we once again simulate some data:</p>
<div class="highlight highlight-source-julia"><pre>T          <span class="pl-k">=</span> <span class="pl-c1">100000</span>
h          <span class="pl-k">=</span> <span class="pl-c1">1</span>
<span class="pl-en">sim</span>(sys,u) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u, <span class="pl-c1">1</span><span class="pl-k">:</span>T)[<span class="pl-c1">1</span>][:]
σy         <span class="pl-k">=</span> <span class="pl-c1">0.5</span>
sys        <span class="pl-k">=</span> <span class="pl-c1">tf</span>(<span class="pl-c1">1</span>,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>])
ωn         <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">0.3</span>)
sysn       <span class="pl-k">=</span> <span class="pl-c1">tf</span>(σy<span class="pl-k">*</span>ωn,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span><span class="pl-k">*</span>ωn,ωn<span class="pl-k">^</span><span class="pl-c1">2</span>])

u  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(T)
y  <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u)
yn <span class="pl-k">=</span> y <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)))
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,h)
dn <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,u,h)</pre></div>
<p>We can now estimate the coherence function to get a feel for whether or nor our data seems to be generated by a linear system:</p>
<div class="highlight highlight-source-julia"><pre>k <span class="pl-k">=</span> <span class="pl-c1">coherence</span>(d)  <span class="pl-c"><span class="pl-c">#</span> Should be close to 1 if the system is linear and noise free</span>
k <span class="pl-k">=</span> <span class="pl-c1">coherence</span>(dn) <span class="pl-c"><span class="pl-c">#</span> Slightly lower values are obtained if the system is subject to measurement noise</span></pre></div>
<p>We can also estimate a transfer function using spectral techniques, the main entry point to this is the function <code>tfest</code>, which returns a transfer-function estimate and an estimate of the power-spectral density of the noise (note, the unit of the PSD is squared compared to a transfer function, hence the <code>√N</code> when plotting it in the code below):</p>
<div class="highlight highlight-source-julia"><pre>G,N <span class="pl-k">=</span> <span class="pl-c1">tfest</span>(dn)
<span class="pl-c1">bodeplot</span>([sys,sysn], <span class="pl-c1">exp10</span>.(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">3</span>, stop<span class="pl-k">=</span><span class="pl-c1">log10</span>(pi), length<span class="pl-k">=</span><span class="pl-c1">200</span>)), layout<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>), plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>], size<span class="pl-k">=</span>(<span class="pl-c1">3</span><span class="pl-k">*</span><span class="pl-c1">800</span>, <span class="pl-c1">600</span>), ylims<span class="pl-k">=</span>(<span class="pl-c1">0.1</span>,<span class="pl-c1">300</span>), linecolor<span class="pl-k">=</span><span class="pl-c1">:blue</span>)

<span class="pl-c1">coherenceplot!</span>(dn, subplot<span class="pl-k">=</span><span class="pl-c1">3</span>)
<span class="pl-c1">plot!</span>(G, subplot<span class="pl-k">=</span><span class="pl-c1">1</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>G Est<span class="pl-pds">"</span></span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.3</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Process model<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot!</span>(<span class="pl-k">√</span>N, subplot<span class="pl-k">=</span><span class="pl-c1">2</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>N Est<span class="pl-pds">"</span></span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.3</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Noise model<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/bodecoher.png"><img src="figs/bodecoher.png" alt="window" style="max-width:100%;"></a></p>
<p>The left figure displays the Bode magnitude of the true system, together with the estimate (noisy), and the middle figure illustrates the estimated noise model. The right figure displays the coherence function, which is close to 1 everywhere except for at the resonance peak of the noise <code>log10(sqrt(0.3)) = -0.26</code>.</p>
<p>See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for more details.</p>
<h1><a id="user-content-impulse-response-estimation" class="anchor" aria-hidden="true" href="#impulse-response-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Impulse-response estimation</h1>
<p>The functions <code>impulseest(h,y,u,order)</code> and <code>impulseestplot</code> performs impulse-response estimation by fitting a high-order FIR model.</p>
<p>Example</p>
<div class="highlight highlight-source-julia"><pre>T <span class="pl-k">=</span> <span class="pl-c1">200</span>
h <span class="pl-k">=</span> <span class="pl-c1">1</span>
t <span class="pl-k">=</span> h<span class="pl-k">:</span>h<span class="pl-k">:</span>T
<span class="pl-en">sim</span>(sys,u) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u, t)[<span class="pl-c1">1</span>][:]
sys <span class="pl-k">=</span> <span class="pl-c1">c2d</span>(<span class="pl-c1">tf</span>(<span class="pl-c1">1</span>,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>]),h)

u  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">length</span>(t))
y  <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u)
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,h)

<span class="pl-c1">impulseestplot</span>(d,<span class="pl-c1">50</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Estimate<span class="pl-pds">"</span></span>)
<span class="pl-c1">impulseplot!</span>(sys,<span class="pl-c1">50</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True system<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/impulse.svg"><img src="figs/impulse.svg" alt="window" style="max-width:100%;"></a></p>
<p>See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for more details.</p>
<h1><a id="user-content-validation" class="anchor" aria-hidden="true" href="#validation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Validation</h1>
<p>A number of functions are made available to assist in validation of the estimated models. We illustrate by an example</p>
<p>Generate some test data:</p>
<div class="highlight highlight-source-julia"><pre>Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1</span>)
T          <span class="pl-k">=</span> <span class="pl-c1">200</span>
nx         <span class="pl-k">=</span> <span class="pl-c1">2</span>
nu         <span class="pl-k">=</span> <span class="pl-c1">1</span>
ny         <span class="pl-k">=</span> <span class="pl-c1">1</span>
x0         <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nx)
σy         <span class="pl-k">=</span> <span class="pl-c1">0.5</span>
<span class="pl-en">sim</span>(sys,u) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u<span class="pl-k">'</span>, <span class="pl-c1">1</span><span class="pl-k">:</span>T)[<span class="pl-c1">1</span>]'
sys        <span class="pl-k">=</span> <span class="pl-c1">tf</span>(<span class="pl-c1">1</span>,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>])
sysn       <span class="pl-k">=</span> <span class="pl-c1">tf</span>(σy,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.3</span>])
<span class="pl-c"><span class="pl-c">#</span> Training data</span>
u          <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nu,T)
y          <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u)
yn         <span class="pl-k">=</span> y <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)))
dn         <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,u)
<span class="pl-c"><span class="pl-c">#</span> Validation data</span>
uv         <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nu,T)
yv         <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, uv)
ynv        <span class="pl-k">=</span> yv <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(uv)))
dv         <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yv,uv)
dnv        <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(ynv,uv)</pre></div>
<p>We then fit a couple of models, the flag <code>difficult=true</code> causes <code>pem</code> to solve an initial global optimization problem with constraints on the stability of <code>A-KC</code> to provide a good guess for the gradient-based solver</p>
<div class="highlight highlight-source-julia"><pre>res <span class="pl-k">=</span> [<span class="pl-c1">pem</span>(dn,nx<span class="pl-k">=</span>nx, iterations<span class="pl-k">=</span><span class="pl-c1">100</span>, difficult<span class="pl-k">=</span><span class="pl-c1">true</span>, focus<span class="pl-k">=</span><span class="pl-c1">:prediction</span>) <span class="pl-k">for</span> nx <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>]]</pre></div>
<p>After fitting the models, we validate the results using the validation data and the functions <code>simplot</code> and <code>predplot</code> (cf. Matlab sys.id's <code>compare</code>):</p>
<div class="highlight highlight-source-julia"><pre>ω   <span class="pl-k">=</span> <span class="pl-c1">exp10</span>.(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>, stop<span class="pl-k">=</span><span class="pl-c1">log10</span>(pi), length<span class="pl-k">=</span><span class="pl-c1">150</span>))
fig <span class="pl-k">=</span> <span class="pl-c1">plot</span>(layout<span class="pl-k">=</span><span class="pl-c1">4</span>, size<span class="pl-k">=</span>(<span class="pl-c1">1000</span>,<span class="pl-c1">600</span>))
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(res)
    (sysh,x0h,opt) <span class="pl-k">=</span> res[i]
    <span class="pl-c1">simplot!</span>( sysh,dnv,x0h; subplot<span class="pl-k">=</span><span class="pl-c1">1</span>, ploty<span class="pl-k">=</span>i<span class="pl-k">==</span><span class="pl-c1">1</span>)
    <span class="pl-c1">predplot!</span>(sysh,dnv,x0h; subplot<span class="pl-k">=</span><span class="pl-c1">2</span>, ploty<span class="pl-k">=</span>i<span class="pl-k">==</span><span class="pl-c1">1</span>)
<span class="pl-k">end</span>
<span class="pl-c1">bodeplot!</span>(<span class="pl-c1">ss</span>.(<span class="pl-c1">getindex</span>.(res,<span class="pl-c1">1</span>)),                   ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">3</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Process<span class="pl-pds">"</span></span>, linewidth<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span>[<span class="pl-c1">4</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>])
<span class="pl-c1">bodeplot!</span>(<span class="pl-c1">innovation_form</span>.(<span class="pl-c1">getindex</span>.(res,<span class="pl-c1">1</span>)),      ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">4</span>, linewidth<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span>[<span class="pl-c1">4</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>])
<span class="pl-c1">bodeplot!</span>(sys,                                     ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">3</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span>, linecolor<span class="pl-k">=</span><span class="pl-c1">:blue</span>, l<span class="pl-k">=</span><span class="pl-c1">:dash</span>, legend <span class="pl-k">=</span> <span class="pl-c1">:bottomleft</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>System model<span class="pl-pds">"</span></span>)
<span class="pl-c1">bodeplot!</span>(<span class="pl-c1">innovation_form</span>(<span class="pl-c1">ss</span>(sys),syse<span class="pl-k">=</span><span class="pl-c1">ss</span>(sysn)),  ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">4</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span>, linecolor<span class="pl-k">=</span><span class="pl-c1">:blue</span>, l<span class="pl-k">=</span><span class="pl-c1">:dash</span>, ylims<span class="pl-k">=</span>(<span class="pl-c1">0.1</span>, <span class="pl-c1">100</span>), legend <span class="pl-k">=</span> <span class="pl-c1">:bottomleft</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Noise model<span class="pl-pds">"</span></span>)
<span class="pl-c1">display</span>(fig)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/val.svg"><img src="figs/val.svg" alt="window" style="max-width:100%;"></a></p>
<p>In the figure, simulation output is compared to the true model on the top left and prediction on top right. The system models and noise models are visualized in the bottom plots. Both high-order models capture the system dynamics well, but struggle slightly with capturing the gain of the noise dynamics.
The figure also indicates that a model with 4 poles performs best on both prediction and simulation data. The true system has 4 poles (two in the process and two in the noise process) so this is expected. However, the third order model performs almost equally well and may be a better choice.</p>
<h1><a id="user-content-other-resources" class="anchor" aria-hidden="true" href="#other-resources"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other resources</h1>
<ul>
<li>For estimation of linear time-varying models (LTV), see <a href="https://github.com/baggepinnen/LTVModels.jl">LTVModels.jl</a>.</li>
<li>For estimation of linear and nonlinear grey-box models in continuous time, see <a href="http://docs.juliadiffeq.org/stable/analysis/parameter_estimation.html" rel="nofollow">DifferentialEquations.jl (parameter estimation)</a></li>
<li>Estimation of nonlinear black-box models in continuous time <a href="https://github.com/JuliaDiffEq/DiffEqFlux.jl/">DiffEqFlux.jl</a> and in discrete time <a href="https://github.com/FluxML/Flux.jl">Flux.jl</a></li>
<li>For more advanced spectral estimation, cross coherence, etc., see <a href="https://github.com/baggepinnen/LPVSpectral.jl">LPVSpectral.jl</a></li>
<li>This package interacts well with <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a>. See <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/controlsystems.jl">example file</a>.</li>
</ul>
</article></div>