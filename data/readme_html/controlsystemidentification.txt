<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-controlsystemidentification" class="anchor" aria-hidden="true" href="#controlsystemidentification"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ControlSystemIdentification</h1>
<p><a href="https://github.com/baggepinnen/ControlSystemIdentification.jl/actions"><img src="https://github.com/baggepinnen/ControlSystemIdentification.jl/workflows/CI/badge.svg" alt="CI" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/baggepinnen/ControlSystemIdentification.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/47dcf9b0587562d36a275cab476be61400387cb811c58b6e5359f3326f325373/68747470733a2f2f636f6465636f762e696f2f67682f626167676570696e6e656e2f436f6e74726f6c53797374656d4964656e74696669636174696f6e2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/baggepinnen/ControlSystemIdentification.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>System identification for <a href="https://github.com/JuliaControl/ControlSystems.jl/">ControlSystems.jl</a>. Examples in the form of jupyter notebooks are provided <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">here</a>.</p>
<h1><a id="user-content-lti-state-space-models" class="anchor" aria-hidden="true" href="#lti-state-space-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>LTI state-space models</h1>
<p>There exist two methods for identification of statespace models, <code>n4sid</code> and <code>pem</code>. <code>n4sid</code> uses subspace-based identification whereas <code>pem</code> solves the prediction-error problem using an iterative optimization method (from Optim.jl). If unsure which method to use, try <code>n4sid</code> first.</p>
<h2><a id="user-content-subspace-based-identification-using-n4sid" class="anchor" aria-hidden="true" href="#subspace-based-identification-using-n4sid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Subspace based identification using n4sid</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="d = iddata(y,u,sampletime)
sys = n4sid(d, :auto; verbose=false)
# or use a robust version of svd if y has outliers or missing values
using TotalLeastSquares
sys = n4sid(d, :auto; verbose=false, svd=x-&gt;rpca(x)[3])
"><pre>d <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,sampletime)
sys <span class="pl-k">=</span> <span class="pl-c1">n4sid</span>(d, <span class="pl-c1">:auto</span>; verbose<span class="pl-k">=</span><span class="pl-c1">false</span>)
<span class="pl-c"><span class="pl-c">#</span> or use a robust version of svd if y has outliers or missing values</span>
<span class="pl-k">using</span> TotalLeastSquares
sys <span class="pl-k">=</span> <span class="pl-c1">n4sid</span>(d, <span class="pl-c1">:auto</span>; verbose<span class="pl-k">=</span><span class="pl-c1">false</span>, svd<span class="pl-k">=</span>x<span class="pl-k">-&gt;</span><span class="pl-c1">rpca</span>(x)[<span class="pl-c1">3</span>])</pre></div>
<p>Estimate a statespace model using the n4sid method. Returns an object of type <code>N4SIDResult</code> where the model is accessed as <code>sys.sys</code>.</p>
<h4><a id="user-content-arguments" class="anchor" aria-hidden="true" href="#arguments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Arguments:</h4>
<ul>
<li><code>d</code>: Identification data object, created using <code>iddata(y,u,sampletime)</code>.</li>
<li><code>y</code>: Measurements N×ny</li>
<li><code>u</code>: Control signal N×nu</li>
<li><code>r</code>: Rank of the model (model order)</li>
<li><code>verbose</code>: Print stuff?</li>
<li><code>Wf</code>: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like <code>Wf = Bandstop(lower, upper, fs=1/Ts)</code> to indicate that there are disturbances <em>outside</em> this band.</li>
<li><code>i</code>: Algorithm parameter, generally no need to tune this</li>
<li><code>γ</code>: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.</li>
</ul>
<p>The frequency weighting is borrowing ideas from
<em>"Frequency Weighted Subspace Based System Identification in the Frequency Domain", Tomas McKelvey 1996</em>. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).</p>
<h3><a id="user-content-era-and-okid" class="anchor" aria-hidden="true" href="#era-and-okid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ERA and OKID</h3>
<p>See</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sys = era(d::AbstractIdData, r, m = 2r, n = 2r, l = 5r)
H   = okid(d::AbstractIdData, r, l = 5r)
"><pre>sys <span class="pl-k">=</span> <span class="pl-c1">era</span>(d<span class="pl-k">::</span><span class="pl-c1">AbstractIdData</span>, r, m <span class="pl-k">=</span> <span class="pl-c1">2</span>r, n <span class="pl-k">=</span> <span class="pl-c1">2</span>r, l <span class="pl-k">=</span> <span class="pl-c1">5</span>r)
H   <span class="pl-k">=</span> <span class="pl-c1">okid</span>(d<span class="pl-k">::</span><span class="pl-c1">AbstractIdData</span>, r, l <span class="pl-k">=</span> <span class="pl-c1">5</span>r)</pre></div>
<h3><a id="user-content-filtering-and-simulation" class="anchor" aria-hidden="true" href="#filtering-and-simulation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Filtering and simulation</h3>
<p>Models can be simulated using <code>lsim</code> from ControlSystems.jl and using <code>simulate</code>. You may also convert the model to a <code>KalmanFilter</code> from <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl">LowLevelParticleFilters.jl</a> by calling <code>KalmanFilter(sys)</code>, after which you can perform filtering and smoothing etc. with the utilities provided for a <code>KalmanFilter</code>.</p>
<h2><a id="user-content-pem" class="anchor" aria-hidden="true" href="#pem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PEM</h2>
<p>A simple algorithm for identification of discrete-time LTI systems on state-space form:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="x' = Ax + Bu + Ke
y  = Cx + e
"><pre lang="math"><code>x' = Ax + Bu + Ke
y  = Cx + e
</code></pre></div>
<p>is provided. The user can choose to minimize either prediction errors or simulation errors, with arbitrary metrics, i.e., not limited to squared errors.</p>
<p>The result of the identification is a custom type <code>StateSpaceNoise &lt;: ControlSystems.LTISystem</code>, with fields <code>A,B,K</code>, representing the dynamics matrix, input matrix and Kalman gain matrix, respectively. The observation matrix <code>C</code> is not stored, as this is always given by <code>[I 0]</code> (you can still access it through <code>sys.C</code> thanks to <code>getproperty</code>).</p>
<p>This package also supports estimating models on the form</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="Ay = Bu + Cw
"><pre lang="math"><code>Ay = Bu + Cw
</code></pre></div>
<p>through pseudo-linear regression or</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="Ay = Bu + 1/D w
"><pre lang="math"><code>Ay = Bu + 1/D w
</code></pre></div>
<p>through the generalized least squares method (<code>arxar</code>).
Estimation of the more general model form</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="Ay = B/F u + C/D w
"><pre lang="math"><code>Ay = B/F u + C/D w
</code></pre></div>
<p>or any of its other special cases is not supported. Since those models are also LTI systems, estimating a state-space model is in some sense equivalent.</p>
<p>Transfer-function estimation through spectral methods is supported through the functions <code>tfest</code> and <code>coherence</code>.</p>
<h3><a id="user-content-usage-example" class="anchor" aria-hidden="true" href="#usage-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage example</h3>
<p>Below, we generate a system and simulate it forward in time. We then try to estimate a model based on the input and output sequences.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using ControlSystemIdentification, ControlSystems, Random, LinearAlgebra

function ⟂(x)
    u,s,v = svd(x)
    u*v
end
function generate_system(nx,ny,nu)
    U,S  = ⟂(randn(nx,nx)), diagm(0=&gt;0.2 .+ 0.5rand(nx))
    A    = S*U
    B   = randn(nx,nu)
    C   = randn(ny,nx)
    sys = ss(A,B,C,0,1)
end

Random.seed!(1)
T   = 1000                      # Number of time steps
nx  = 3                         # Number of poles in the true system
nu  = 1                         # Number of control inputs
ny  = 1                         # Number of outputs
x0  = randn(nx)                 # Initial state
sim(sys,u,x0=x0) = lsim(sys, u', 1:T, x0=x0)[1]' # Helper function
sys = generate_system(nx,nu,ny)
u   = randn(nu,T)               # Generate random input
y   = sim(sys, u, x0)           # Simulate system
d   = iddata(y,u,1)

sysh,x0h,opt = pem(d, nx=nx, focus=:prediction) # Estimate model

yh = predict(sysh, d, x0h)      # Predict using estimated model
plot([y; yh]', lab=[&quot;y&quot; &quot;ŷ&quot;])   # Plot prediction and true output
"><pre><span class="pl-k">using</span> ControlSystemIdentification, ControlSystems, Random, LinearAlgebra

<span class="pl-k">function</span> ⟂(x)
    u,s,v <span class="pl-k">=</span> <span class="pl-c1">svd</span>(x)
    u<span class="pl-k">*</span>v
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">generate_system</span>(nx,ny,nu)
    U,S  <span class="pl-k">=</span> ⟂(<span class="pl-c1">randn</span>(nx,nx)), <span class="pl-c1">diagm</span>(<span class="pl-c1">0</span><span class="pl-k">=&gt;</span><span class="pl-c1">0.2</span> <span class="pl-k">.+</span> <span class="pl-c1">0.5</span><span class="pl-c1">rand</span>(nx))
    A    <span class="pl-k">=</span> S<span class="pl-k">*</span>U
    B   <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nx,nu)
    C   <span class="pl-k">=</span> <span class="pl-c1">randn</span>(ny,nx)
    sys <span class="pl-k">=</span> <span class="pl-c1">ss</span>(A,B,C,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>)
<span class="pl-k">end</span>

Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1</span>)
T   <span class="pl-k">=</span> <span class="pl-c1">1000</span>                      <span class="pl-c"><span class="pl-c">#</span> Number of time steps</span>
nx  <span class="pl-k">=</span> <span class="pl-c1">3</span>                         <span class="pl-c"><span class="pl-c">#</span> Number of poles in the true system</span>
nu  <span class="pl-k">=</span> <span class="pl-c1">1</span>                         <span class="pl-c"><span class="pl-c">#</span> Number of control inputs</span>
ny  <span class="pl-k">=</span> <span class="pl-c1">1</span>                         <span class="pl-c"><span class="pl-c">#</span> Number of outputs</span>
x0  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nx)                 <span class="pl-c"><span class="pl-c">#</span> Initial state</span>
<span class="pl-en">sim</span>(sys,u,x0<span class="pl-k">=</span>x0) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u<span class="pl-k">'</span>, <span class="pl-c1">1</span><span class="pl-k">:</span>T, x0<span class="pl-k">=</span>x0)[<span class="pl-c1">1</span>]' <span class="pl-c"><span class="pl-c">#</span> Helper function</span>
sys <span class="pl-k">=</span> <span class="pl-c1">generate_system</span>(nx,nu,ny)
u   <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nu,T)               <span class="pl-c"><span class="pl-c">#</span> Generate random input</span>
y   <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u, x0)           <span class="pl-c"><span class="pl-c">#</span> Simulate system</span>
d   <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,<span class="pl-c1">1</span>)

sysh,x0h,opt <span class="pl-k">=</span> <span class="pl-c1">pem</span>(d, nx<span class="pl-k">=</span>nx, focus<span class="pl-k">=</span><span class="pl-c1">:prediction</span>) <span class="pl-c"><span class="pl-c">#</span> Estimate model</span>

yh <span class="pl-k">=</span> <span class="pl-c1">predict</span>(sysh, d, x0h)      <span class="pl-c"><span class="pl-c">#</span> Predict using estimated model</span>
<span class="pl-c1">plot</span>([y; yh]', lab<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>ŷ<span class="pl-pds">"</span></span>])   <span class="pl-c"><span class="pl-c">#</span> Plot prediction and true output</span></pre></div>
<p>We can also simulate the system with colored noise, necessitating estimating also noise models.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="σu = 0.1 # Noise variances
σy = 0.1

sysn = generate_system(nx,nu,ny)             # Noise system
un   = u + sim(sysn, σu*randn(size(u)),0*x0) # Input + load disturbance
y    = sim(sys, un, x0)
yn   = y + sim(sysn, σy*randn(size(u)),0*x0) # Output + measurement noise
dn   = iddata(yn,un,1)
"><pre>σu <span class="pl-k">=</span> <span class="pl-c1">0.1</span> <span class="pl-c"><span class="pl-c">#</span> Noise variances</span>
σy <span class="pl-k">=</span> <span class="pl-c1">0.1</span>

sysn <span class="pl-k">=</span> <span class="pl-c1">generate_system</span>(nx,nu,ny)             <span class="pl-c"><span class="pl-c">#</span> Noise system</span>
un   <span class="pl-k">=</span> u <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, σu<span class="pl-k">*</span><span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)),<span class="pl-c1">0</span><span class="pl-k">*</span>x0) <span class="pl-c"><span class="pl-c">#</span> Input + load disturbance</span>
y    <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, un, x0)
yn   <span class="pl-k">=</span> y <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, σy<span class="pl-k">*</span><span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)),<span class="pl-c1">0</span><span class="pl-k">*</span>x0) <span class="pl-c"><span class="pl-c">#</span> Output + measurement noise</span>
dn   <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,un,<span class="pl-c1">1</span>)</pre></div>
<p>The system now has <code>3nx</code> poles, <code>nx</code> for the system dynamics, and <code>nx</code> for each noise model, we indicated this to the main estimation function <code>pem</code>:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sysh,x0h,opt = pem(dn,nx=3nx, focus=:prediction)
yh           = predict(sysh, dn, x0h) # Form prediction
plot([y; yh]', lab=[&quot;y&quot; &quot;ŷ&quot;])             # Compare true output (without noise) to prediction
"><pre>sysh,x0h,opt <span class="pl-k">=</span> <span class="pl-c1">pem</span>(dn,nx<span class="pl-k">=</span><span class="pl-c1">3</span>nx, focus<span class="pl-k">=</span><span class="pl-c1">:prediction</span>)
yh           <span class="pl-k">=</span> <span class="pl-c1">predict</span>(sysh, dn, x0h) <span class="pl-c"><span class="pl-c">#</span> Form prediction</span>
<span class="pl-c1">plot</span>([y; yh]', lab<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>ŷ<span class="pl-pds">"</span></span>])             <span class="pl-c"><span class="pl-c">#</span> Compare true output (without noise) to prediction</span></pre></div>
<p>We can have a look at the singular values of a balanced system Gramian:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="s    = ss(sysh)   # Convert to standard state-space type
s2,G = balreal(s) # Form balanced representation (obs. and ctrb. Gramians are the same
diag(G)           # Singular values of Gramians

# 9-element Array{Float64,1}:
#  3.5972307807882844
#  0.19777167699663994
#  0.0622528285731599
#  0.004322765397504325
#  0.004270259700592557
#  0.003243449461350837
#  0.003150873301312319
#  0.0005827927965893053
#  0.00029732262107216666
"><pre>s    <span class="pl-k">=</span> <span class="pl-c1">ss</span>(sysh)   <span class="pl-c"><span class="pl-c">#</span> Convert to standard state-space type</span>
s2,G <span class="pl-k">=</span> <span class="pl-c1">balreal</span>(s) <span class="pl-c"><span class="pl-c">#</span> Form balanced representation (obs. and ctrb. Gramians are the same</span>
<span class="pl-c1">diag</span>(G)           <span class="pl-c"><span class="pl-c">#</span> Singular values of Gramians</span>

<span class="pl-c"><span class="pl-c">#</span> 9-element Array{Float64,1}:</span>
<span class="pl-c"><span class="pl-c">#</span>  3.5972307807882844</span>
<span class="pl-c"><span class="pl-c">#</span>  0.19777167699663994</span>
<span class="pl-c"><span class="pl-c">#</span>  0.0622528285731599</span>
<span class="pl-c"><span class="pl-c">#</span>  0.004322765397504325</span>
<span class="pl-c"><span class="pl-c">#</span>  0.004270259700592557</span>
<span class="pl-c"><span class="pl-c">#</span>  0.003243449461350837</span>
<span class="pl-c"><span class="pl-c">#</span>  0.003150873301312319</span>
<span class="pl-c"><span class="pl-c">#</span>  0.0005827927965893053</span>
<span class="pl-c"><span class="pl-c">#</span>  0.00029732262107216666</span></pre></div>
<p>Note that there are 3 big singular values, corresponding to the system poles, there are also 2×3 smaller singular values, corresponding to the noise dynamics.</p>
<p>The estimated noise model can be extracted by <code>noise_model(sys)</code>, we can visualize it with a bodeplot.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="bodeplot(noise_model(sysh), exp10.(range(-3, stop=0, length=200)), title=&quot;Estimated noise dynamics&quot;)
"><pre><span class="pl-c1">bodeplot</span>(<span class="pl-c1">noise_model</span>(sysh), <span class="pl-c1">exp10</span>.(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">3</span>, stop<span class="pl-k">=</span><span class="pl-c1">0</span>, length<span class="pl-k">=</span><span class="pl-c1">200</span>)), title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Estimated noise dynamics<span class="pl-pds">"</span></span>)</pre></div>
<p>See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for these plots.</p>
<h3><a id="user-content-call-signature" class="anchor" aria-hidden="true" href="#call-signature"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Call signature</h3>
<p><code>sys, x0, opt = pem(d; nx, kwargs...)</code></p>
<h4><a id="user-content-arguments-1" class="anchor" aria-hidden="true" href="#arguments-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Arguments:</h4>
<ul>
<li><code>d</code>: Identification data object, created using <code>iddata(y, u sampletime)</code>
<ul>
<li><code>y</code>: Measurements, either a matrix with time along dim 2, or a vector of vectors</li>
<li><code>u</code>: Control signals, same structure as <code>y</code></li>
</ul>
</li>
<li><code>nx</code>: Number of poles in the estimated system. This number should be chosen as number of system poles plus number of poles in noise models for measurement noise and load disturbances.</li>
<li><code>focus</code>: Either <code>:prediction</code> or <code>:simulation</code>. If <code>:simulation</code> is chosen, a two stage problem is solved with prediction focus first, followed by a refinement for simulation focus.</li>
<li><code>metric</code>: A Function determining how the size of the residuals is measured, default <code>sse</code> (e'e), but any Function such as <code>norm</code>, <code>e-&gt;sum(abs,e)</code> or <code>e -&gt; e'Q*e</code> could be used.</li>
<li><code>regularizer(p) = 0</code>: function for regularization of the parameter vector <code>p</code>. The structure of <code>p</code> is detailed below. L₂ regularization, for instance, can be achieved by <code>regularizer = p-&gt;sum(abs2, p)</code></li>
<li><code>solver</code> Defaults to <code>Optim.BFGS()</code></li>
<li><code>kwargs</code>: additional keyword arguments are sent to <a href="http://julianlsolvers.github.io/Optim.jl/stable/#user/config/" rel="nofollow"><code>Optim.Options</code></a>.</li>
</ul>
<h4><a id="user-content-structure-of-parameter-vector-p" class="anchor" aria-hidden="true" href="#structure-of-parameter-vector-p"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Structure of parameter vector <code>p</code></h4>
<p>The parameter vector is of type <a href="https://github.com/jonniedie/ComponentArrays.jl"><code>ComponentVector</code></a> and the fields <code>A,B,K,x0</code> can be accessed as <code>p.A</code> etc. The internal storage is according to</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="A  = size(nx,nx)
B  = size(nx,nu)
K  = size(nx,ny)
x0 = size(nx)
p  = [A[:];B[:];K[:];x0]
"><pre>A  <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx,nx)
B  <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx,nu)
K  <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx,ny)
x0 <span class="pl-k">=</span> <span class="pl-c1">size</span>(nx)
p  <span class="pl-k">=</span> [A[:];B[:];K[:];x0]</pre></div>
<h3><a id="user-content-return-values" class="anchor" aria-hidden="true" href="#return-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Return values</h3>
<ul>
<li><code>sys::StateSpaceNoise</code>: identified system. Can be converted to <code>StateSpace</code> by <code>convert(StateSpace, sys)</code> or <code>ss(sys)</code>, but this will discard the Kalman gain matrix, see <code>innovation_form</code>.</li>
<li><code>x0</code>: Estimated initial state</li>
<li><code>opt</code>: Optimization problem structure. Contains info of the result of the optimization problem</li>
</ul>
<h3><a id="user-content-functions" class="anchor" aria-hidden="true" href="#functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functions</h3>
<ul>
<li><code>pem</code>: Main estimation function, see above.</li>
<li><code>predict(sys, d, x0=zeros)</code>: Form predictions using estimated <code>sys</code>, this essentially runs a stationary Kalman filter.</li>
<li><code>simulate(sys, u, x0=zeros)</code>: Simulate the system using input <code>u</code>. The noise model and Kalman gain does not have any influence on the simulated output.</li>
<li><code>innovation_form</code>: Extract the noise model from the estimated system (<code>ss(A,K,C,0)</code>).</li>
</ul>
<h3><a id="user-content-internals" class="anchor" aria-hidden="true" href="#internals"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Internals</h3>
<p>Internally, <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> is used to optimize the system parameters, using automatic differentiation to calculate gradients (and Hessians where applicable). Optim solver options can be controlled by passing keyword arguments to <code>pem</code>, and by passing a manually constructed solver object. The default solver is <a href="http://julianlsolvers.github.io/Optim.jl/stable/#algo/lbfgs/" rel="nofollow"><code>BFGS()</code></a></p>
<h1><a id="user-content-arx-and-plr-estimation" class="anchor" aria-hidden="true" href="#arx-and-plr-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ARX and PLR estimation</h1>
<p>Basic support for ARX/ARMAX model estimation, i.e. a model on any of the forms</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="Ay = Bu + w
Ay = Bu + Cw
Ay = Bu + 1/D w
"><pre lang="math"><code>Ay = Bu + w
Ay = Bu + Cw
Ay = Bu + 1/D w
</code></pre></div>
<p>is provided. The ARX estimation problem is convex and the solution is available on closed-form.
Usage example:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="N  = 2000     # Number of time steps
t  = 1:N
Δt = 1        # Sample time
u  = randn(N) # A random control input
G  = tf(0.8, [1,-0.9], 1)
y  = lsim(G,u,t)[1][:]
yn = y
d  = iddata(y,u,Δt)

na,nb = 1,1   # Number of polynomial coefficients

Gls = arx(d,na,nb,stochastic=false) # set stochastic to true to get a transfer function of MonteCarloMeasurements.Particles
@show Gls
# TransferFunction{ControlSystems.SisoRational{Float64}}
#     0.8000000000000005
# --------------------------
# 1.0*z - 0.8999999999999997
"><pre>N  <span class="pl-k">=</span> <span class="pl-c1">2000</span>     <span class="pl-c"><span class="pl-c">#</span> Number of time steps</span>
t  <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N
Δt <span class="pl-k">=</span> <span class="pl-c1">1</span>        <span class="pl-c"><span class="pl-c">#</span> Sample time</span>
u  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(N) <span class="pl-c"><span class="pl-c">#</span> A random control input</span>
G  <span class="pl-k">=</span> <span class="pl-c1">tf</span>(<span class="pl-c1">0.8</span>, [<span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">0.9</span>], <span class="pl-c1">1</span>)
y  <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(G,u,t)[<span class="pl-c1">1</span>][:]
yn <span class="pl-k">=</span> y
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,Δt)

na,nb <span class="pl-k">=</span> <span class="pl-c1">1</span>,<span class="pl-c1">1</span>   <span class="pl-c"><span class="pl-c">#</span> Number of polynomial coefficients</span>

Gls <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb,stochastic<span class="pl-k">=</span><span class="pl-c1">false</span>) <span class="pl-c"><span class="pl-c">#</span> set stochastic to true to get a transfer function of MonteCarloMeasurements.Particles</span>
<span class="pl-c1">@show</span> Gls
<span class="pl-c"><span class="pl-c">#</span> TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.8000000000000005</span>
<span class="pl-c"><span class="pl-c">#</span> --------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.8999999999999997</span></pre></div>
<p>As we can see, the model is perfectly recovered. In reality, the measurement signal is often affected by noise, in which case the estimation will suffer. To combat this, a few different options exist:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="e  = randn(N)
yn = y + e    # Measurement signal with noise
d  = iddata(yn,u,Δt)

na,nb,nc = 1,1,1

Gls      = arx(d,na,nb, stochastic=true)     # Regular least-squares estimation
Gtls     = arx(d,na,nb, estimator=tls)       # Total least-squares estimation
Gwtls    = arx(d,na,nb, estimator=wtls_estimator(y,na,nb)) # Weighted Total least-squares estimation
Gplr, Gn = plr(d,na,nb,nc, initial_order=20) # Pseudo-linear regression
@show Gls; @show  Gtls; @show  Gwtls; @show  Gplr; @show  Gn;
# TransferFunction{ControlSystems.SisoRational{MonteCarloMeasurements.Particles{Float64,500}}}
#     0.824 ± 0.029
# ---------------------
# 1.0*z - 0.713 ± 0.013

# Gtls = TransferFunction{ControlSystems.SisoRational{Float64}}
#     1.848908051191616
# -------------------------
# 1.0*z - 0.774385918070221

# Gwtls = TransferFunction{ControlSystems.SisoRational{Float64}}
#    0.8180228878106678
# -------------------------
# 1.0*z - 0.891939152690534

# Gplr = TransferFunction{ControlSystems.SisoRational{Float64}}
#     0.8221837077656046
# --------------------------
# 1.0*z - 0.8896345125395438

# Gn = TransferFunction{ControlSystems.SisoRational{Float64}}
#     0.9347035105826179
# --------------------------
# 1.0*z - 0.8896345125395438
"><pre>e  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(N)
yn <span class="pl-k">=</span> y <span class="pl-k">+</span> e    <span class="pl-c"><span class="pl-c">#</span> Measurement signal with noise</span>
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,u,Δt)

na,nb,nc <span class="pl-k">=</span> <span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>

Gls      <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb, stochastic<span class="pl-k">=</span><span class="pl-c1">true</span>)     <span class="pl-c"><span class="pl-c">#</span> Regular least-squares estimation</span>
Gtls     <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb, estimator<span class="pl-k">=</span>tls)       <span class="pl-c"><span class="pl-c">#</span> Total least-squares estimation</span>
Gwtls    <span class="pl-k">=</span> <span class="pl-c1">arx</span>(d,na,nb, estimator<span class="pl-k">=</span><span class="pl-c1">wtls_estimator</span>(y,na,nb)) <span class="pl-c"><span class="pl-c">#</span> Weighted Total least-squares estimation</span>
Gplr, Gn <span class="pl-k">=</span> <span class="pl-c1">plr</span>(d,na,nb,nc, initial_order<span class="pl-k">=</span><span class="pl-c1">20</span>) <span class="pl-c"><span class="pl-c">#</span> Pseudo-linear regression</span>
<span class="pl-c1">@show</span> Gls; <span class="pl-c1">@show</span>  Gtls; <span class="pl-c1">@show</span>  Gwtls; <span class="pl-c1">@show</span>  Gplr; <span class="pl-c1">@show</span>  Gn;
<span class="pl-c"><span class="pl-c">#</span> TransferFunction{ControlSystems.SisoRational{MonteCarloMeasurements.Particles{Float64,500}}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.824 ± 0.029</span>
<span class="pl-c"><span class="pl-c">#</span> ---------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.713 ± 0.013</span>

<span class="pl-c"><span class="pl-c">#</span> Gtls = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     1.848908051191616</span>
<span class="pl-c"><span class="pl-c">#</span> -------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.774385918070221</span>

<span class="pl-c"><span class="pl-c">#</span> Gwtls = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>    0.8180228878106678</span>
<span class="pl-c"><span class="pl-c">#</span> -------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.891939152690534</span>

<span class="pl-c"><span class="pl-c">#</span> Gplr = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.8221837077656046</span>
<span class="pl-c"><span class="pl-c">#</span> --------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.8896345125395438</span>

<span class="pl-c"><span class="pl-c">#</span> Gn = TransferFunction{ControlSystems.SisoRational{Float64}}</span>
<span class="pl-c"><span class="pl-c">#</span>     0.9347035105826179</span>
<span class="pl-c"><span class="pl-c">#</span> --------------------------</span>
<span class="pl-c"><span class="pl-c">#</span> 1.0*z - 0.8896345125395438</span></pre></div>
<p>We now see that the estimate using standard least-squares is heavily biased and it is wrongly certain about the estimate (notice the ± in the transfer function coefficients). Regular Total least-squares does not work well in this example, since not all variables in the regressor contain equally much noise. Weighted total least-squares does a reasonable job at recovering the true model. Pseudo-linear regression also fares okay, while simultaneously estimating a noise model. The helper function <code>wtls_estimator(y,na,nb)</code> returns a function that performs <code>wtls</code> using appropriately sized covariance matrices, based on the length of <code>y</code> and the model orders. Weighted total least-squares estimation is provided by <a href="https://github.com/baggepinnen/TotalLeastSquares.jl">TotalLeastSquares.jl</a>. See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for more details.</p>
<p>Uncertain transfer function with <code>Particles</code> coefficients can be used like any other model. Try, e.g., <code>nyquistplot(Gls)</code> to get a Nyquist plot with confidence bounds.</p>
<p>See also function <code>arma</code> for estimation of signal models without inputs.</p>
<h2><a id="user-content-functions-1" class="anchor" aria-hidden="true" href="#functions-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functions</h2>
<ul>
<li><code>arx</code>: Transfer-function estimation using closed-form solution.</li>
<li><code>ar</code>: Estimate an AR model.</li>
<li><code>arma</code>: Estimate an ARMA model.</li>
<li><code>plr</code>: Transfer-function estimation using pseudo-linear regression</li>
<li><code>arxar</code>: Transfer-function estimation using generalized least squares method</li>
<li><code>getARXregressor/getARregressor</code>: For low-level control over the estimation
See docstrings for further help.</li>
</ul>
<h2><a id="user-content-model-based-spectral-estimation" class="anchor" aria-hidden="true" href="#model-based-spectral-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Model-based spectral estimation</h2>
<p>The model estimation procedures can be used to estimate spectrograms. This package extends some methods from DSP.jl to accept a estimation function as the second argument. To create a suitable such function, we provide the function <code>model_spectrum</code>. Usage is illustrated below.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using ControlSystemIdentification, DSP
T  = 1000
fs = 1
s = sin.((1:1/fs:T) .* 2pi/10) + 0.5randn(T)
S1 = spectrogram(s,window=hanning, fs=fs)            # Standard spectrogram
estimator = model_spectrum(ar,1/fs,6)
S2 = spectrogram(s,estimator,window=rect, fs=fs)     # Model-based spectrogram
plot(plot(S1,title=&quot;Standard Spectrogram&quot;),plot(S2,title=&quot;AR Spectrogram&quot;)) # Requires the package LPVSpectral.jl
"><pre><span class="pl-k">using</span> ControlSystemIdentification, DSP
T  <span class="pl-k">=</span> <span class="pl-c1">1000</span>
fs <span class="pl-k">=</span> <span class="pl-c1">1</span>
s <span class="pl-k">=</span> <span class="pl-c1">sin</span>.((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span>fs<span class="pl-k">:</span>T) <span class="pl-k">.*</span> <span class="pl-c1">2</span>pi<span class="pl-k">/</span><span class="pl-c1">10</span>) <span class="pl-k">+</span> <span class="pl-c1">0.5</span><span class="pl-c1">randn</span>(T)
S1 <span class="pl-k">=</span> <span class="pl-c1">spectrogram</span>(s,window<span class="pl-k">=</span>hanning, fs<span class="pl-k">=</span>fs)            <span class="pl-c"><span class="pl-c">#</span> Standard spectrogram</span>
estimator <span class="pl-k">=</span> <span class="pl-c1">model_spectrum</span>(ar,<span class="pl-c1">1</span><span class="pl-k">/</span>fs,<span class="pl-c1">6</span>)
S2 <span class="pl-k">=</span> <span class="pl-c1">spectrogram</span>(s,estimator,window<span class="pl-k">=</span>rect, fs<span class="pl-k">=</span>fs)     <span class="pl-c"><span class="pl-c">#</span> Model-based spectrogram</span>
<span class="pl-c1">plot</span>(<span class="pl-c1">plot</span>(S1,title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Standard Spectrogram<span class="pl-pds">"</span></span>),<span class="pl-c1">plot</span>(S2,title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>AR Spectrogram<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">#</span> Requires the package LPVSpectral.jl</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/ar_spectrogram.svg"><img src="figs/ar_spectrogram.svg" alt="window" style="max-width:100%;"></a></p>
<h1><a id="user-content-transfer-function-estimation-using-spectral-techniques" class="anchor" aria-hidden="true" href="#transfer-function-estimation-using-spectral-techniques"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Transfer-function estimation using spectral techniques</h1>
<h2><a id="user-content-nonparametric-estimation" class="anchor" aria-hidden="true" href="#nonparametric-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Nonparametric estimation</h2>
<p>Non-parametric estimation is provided through spectral estimation. To illustrate, we once again simulate some data:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="T          = 100000
h          = 1
sim(sys,u) = lsim(sys, u, 1:T)[1][:]
σy         = 0.5
sys        = tf(1,[1,2*0.1,0.1])
ωn         = sqrt(0.3)
sysn       = tf(σy*ωn,[1,2*0.1*ωn,ωn^2])

u  = randn(T)
y  = sim(sys, u)
yn = y + sim(sysn, randn(size(u)))
d  = iddata(y,u,h)
dn = iddata(yn,u,h)
"><pre>T          <span class="pl-k">=</span> <span class="pl-c1">100000</span>
h          <span class="pl-k">=</span> <span class="pl-c1">1</span>
<span class="pl-en">sim</span>(sys,u) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u, <span class="pl-c1">1</span><span class="pl-k">:</span>T)[<span class="pl-c1">1</span>][:]
σy         <span class="pl-k">=</span> <span class="pl-c1">0.5</span>
sys        <span class="pl-k">=</span> <span class="pl-c1">tf</span>(<span class="pl-c1">1</span>,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>])
ωn         <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">0.3</span>)
sysn       <span class="pl-k">=</span> <span class="pl-c1">tf</span>(σy<span class="pl-k">*</span>ωn,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span><span class="pl-k">*</span>ωn,ωn<span class="pl-k">^</span><span class="pl-c1">2</span>])

u  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(T)
y  <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u)
yn <span class="pl-k">=</span> y <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)))
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,h)
dn <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,u,h)</pre></div>
<p>We can now estimate the coherence function to get a feel for whether or nor our data seems to be generated by a linear system:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="k = coherence(d)  # Should be close to 1 if the system is linear and noise free
k = coherence(dn) # Slightly lower values are obtained if the system is subject to measurement noise
"><pre>k <span class="pl-k">=</span> <span class="pl-c1">coherence</span>(d)  <span class="pl-c"><span class="pl-c">#</span> Should be close to 1 if the system is linear and noise free</span>
k <span class="pl-k">=</span> <span class="pl-c1">coherence</span>(dn) <span class="pl-c"><span class="pl-c">#</span> Slightly lower values are obtained if the system is subject to measurement noise</span></pre></div>
<p>We can also estimate a transfer function using spectral techniques, the main entry point to this is the function <code>tfest</code>, which returns a transfer-function estimate and an estimate of the power-spectral density of the noise (note, the unit of the PSD is squared compared to a transfer function, hence the <code>√N</code> when plotting it in the code below):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="G,N = tfest(dn)
bodeplot([sys,sysn], exp10.(range(-3, stop=log10(pi), length=200)), layout=(1,3), plotphase=false, subplot=[1,2,2], size=(3*800, 600), ylims=(0.1,300), linecolor=:blue)

coherenceplot!(dn, subplot=3)
plot!(G, subplot=1, lab=&quot;G Est&quot;, alpha=0.3, title=&quot;Process model&quot;)
plot!(√N, subplot=2, lab=&quot;N Est&quot;, alpha=0.3, title=&quot;Noise model&quot;)
"><pre>G,N <span class="pl-k">=</span> <span class="pl-c1">tfest</span>(dn)
<span class="pl-c1">bodeplot</span>([sys,sysn], <span class="pl-c1">exp10</span>.(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">3</span>, stop<span class="pl-k">=</span><span class="pl-c1">log10</span>(<span class="pl-c1">pi</span>), length<span class="pl-k">=</span><span class="pl-c1">200</span>)), layout<span class="pl-k">=</span>(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>), plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>], size<span class="pl-k">=</span>(<span class="pl-c1">3</span><span class="pl-k">*</span><span class="pl-c1">800</span>, <span class="pl-c1">600</span>), ylims<span class="pl-k">=</span>(<span class="pl-c1">0.1</span>,<span class="pl-c1">300</span>), linecolor<span class="pl-k">=</span><span class="pl-c1">:blue</span>)

<span class="pl-c1">coherenceplot!</span>(dn, subplot<span class="pl-k">=</span><span class="pl-c1">3</span>)
<span class="pl-c1">plot!</span>(G, subplot<span class="pl-k">=</span><span class="pl-c1">1</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>G Est<span class="pl-pds">"</span></span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.3</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Process model<span class="pl-pds">"</span></span>)
<span class="pl-c1">plot!</span>(<span class="pl-k">√</span>N, subplot<span class="pl-k">=</span><span class="pl-c1">2</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>N Est<span class="pl-pds">"</span></span>, alpha<span class="pl-k">=</span><span class="pl-c1">0.3</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Noise model<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/bodecoher.png"><img src="figs/bodecoher.png" alt="window" style="max-width:100%;"></a></p>
<p>The left figure displays the Bode magnitude of the true system, together with the estimate (noisy), and the middle figure illustrates the estimated noise model. The right figure displays the coherence function, which is close to 1 everywhere except for at the resonance peak of the noise <code>log10(sqrt(0.3)) = -0.26</code>.</p>
<p>See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for more details.</p>
<h2><a id="user-content-parametric-estimation" class="anchor" aria-hidden="true" href="#parametric-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parametric estimation</h2>
<p>To estimate a parametric, rational transfer function from frequency-domain data, call <code>tfest</code> with an <code>FRD</code> object and an initial guess for the system model. This initial guess determines the number of coefficients in the numerator and denominator of the estimated model.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="G0 = tf(1.0, [1,1,1]) # Initial guess
G = tfest(d::FRD, G0)
"><pre>G0 <span class="pl-k">=</span> <span class="pl-c1">tf</span>(<span class="pl-c1">1.0</span>, [<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]) <span class="pl-c"><span class="pl-c">#</span> Initial guess</span>
G <span class="pl-k">=</span> <span class="pl-c1">tfest</span>(d<span class="pl-k">::</span><span class="pl-c1">FRD</span>, G0)</pre></div>
<p>Internally, Optim is using a gradient-based optimizer to find the optimal fit of the bode curve of the system. The defaut optimizer <code>BFGS</code> can be changed, see the docstring <code>?tfest</code>.</p>
<p>For a comparison between estimation in the time and frequency domains, see <a href="https://nbviewer.jupyter.org/github/JuliaControl/ControlExamples.jl/blob/master/identification_time_vs_freq.ipynb" rel="nofollow">this notebook</a>.</p>
<p>If the above problem is hard to solve, you may parametrize the model using, e.g., a Laguerre basis expansion, example:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="basis = laguerre_oo(1, 50) # Use 50 basis functions, the final model order may be reduced with baltrunc
Gest,p = tfest(d::FRD, basis)
"><pre>basis <span class="pl-k">=</span> <span class="pl-c1">laguerre_oo</span>(<span class="pl-c1">1</span>, <span class="pl-c1">50</span>) <span class="pl-c"><span class="pl-c">#</span> Use 50 basis functions, the final model order may be reduced with baltrunc</span>
Gest,p <span class="pl-k">=</span> <span class="pl-c1">tfest</span>(d<span class="pl-k">::</span><span class="pl-c1">FRD</span>, basis)</pre></div>
<h1><a id="user-content-impulse-response-estimation" class="anchor" aria-hidden="true" href="#impulse-response-estimation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Impulse-response estimation</h1>
<p>The functions <code>impulseest(h,y,u,order)</code> and <code>impulseestplot</code> performs impulse-response estimation by fitting a high-order FIR model.</p>
<p>Example</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="T = 200
h = 1
t = h:h:T
sim(sys,u) = lsim(sys, u, t)[1][:]
sys = c2d(tf(1,[1,2*0.1,0.1]),h)

u  = randn(length(t))
y  = sim(sys, u)
d  = iddata(y,u,h)

impulseestplot(d,50, lab=&quot;Estimate&quot;)
impulseplot!(sys,50, lab=&quot;True system&quot;)
"><pre>T <span class="pl-k">=</span> <span class="pl-c1">200</span>
h <span class="pl-k">=</span> <span class="pl-c1">1</span>
t <span class="pl-k">=</span> h<span class="pl-k">:</span>h<span class="pl-k">:</span>T
<span class="pl-en">sim</span>(sys,u) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u, t)[<span class="pl-c1">1</span>][:]
sys <span class="pl-k">=</span> <span class="pl-c1">c2d</span>(<span class="pl-c1">tf</span>(<span class="pl-c1">1</span>,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>]),h)

u  <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">length</span>(t))
y  <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u)
d  <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(y,u,h)

<span class="pl-c1">impulseestplot</span>(d,<span class="pl-c1">50</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Estimate<span class="pl-pds">"</span></span>)
<span class="pl-c1">impulseplot!</span>(sys,<span class="pl-c1">50</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True system<span class="pl-pds">"</span></span>)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/impulse.svg"><img src="figs/impulse.svg" alt="window" style="max-width:100%;"></a></p>
<p>See the <a href="https://github.com/JuliaControl/ControlExamples.jl">example notebooks</a> for more details.</p>
<h1><a id="user-content-validation" class="anchor" aria-hidden="true" href="#validation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Validation</h1>
<p>A number of functions are made available to assist in validation of the estimated models. We illustrate by an example</p>
<p>Generate some test data:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Random.seed!(1)
T          = 200
nx         = 2
nu         = 1
ny         = 1
x0         = randn(nx)
σy         = 0.5
sim(sys,u) = lsim(sys, u', 1:T)[1]'
sys        = tf(1,[1,2*0.1,0.1])
sysn       = tf(σy,[1,2*0.1,0.3])
# Training data
u          = randn(nu,T)
y          = sim(sys, u)
yn         = y + sim(sysn, randn(size(u)))
dn         = iddata(yn,u,1)
# Validation data
uv         = randn(nu,T)
yv         = sim(sys, uv)
ynv        = yv + sim(sysn, randn(size(uv)))
dv         = iddata(yv,uv,1)
dnv        = iddata(ynv,uv,1)
"><pre>Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">1</span>)
T          <span class="pl-k">=</span> <span class="pl-c1">200</span>
nx         <span class="pl-k">=</span> <span class="pl-c1">2</span>
nu         <span class="pl-k">=</span> <span class="pl-c1">1</span>
ny         <span class="pl-k">=</span> <span class="pl-c1">1</span>
x0         <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nx)
σy         <span class="pl-k">=</span> <span class="pl-c1">0.5</span>
<span class="pl-en">sim</span>(sys,u) <span class="pl-k">=</span> <span class="pl-c1">lsim</span>(sys, u<span class="pl-k">'</span>, <span class="pl-c1">1</span><span class="pl-k">:</span>T)[<span class="pl-c1">1</span>]'
sys        <span class="pl-k">=</span> <span class="pl-c1">tf</span>(<span class="pl-c1">1</span>,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.1</span>])
sysn       <span class="pl-k">=</span> <span class="pl-c1">tf</span>(σy,[<span class="pl-c1">1</span>,<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">0.1</span>,<span class="pl-c1">0.3</span>])
<span class="pl-c"><span class="pl-c">#</span> Training data</span>
u          <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nu,T)
y          <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, u)
yn         <span class="pl-k">=</span> y <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(u)))
dn         <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yn,u,<span class="pl-c1">1</span>)
<span class="pl-c"><span class="pl-c">#</span> Validation data</span>
uv         <span class="pl-k">=</span> <span class="pl-c1">randn</span>(nu,T)
yv         <span class="pl-k">=</span> <span class="pl-c1">sim</span>(sys, uv)
ynv        <span class="pl-k">=</span> yv <span class="pl-k">+</span> <span class="pl-c1">sim</span>(sysn, <span class="pl-c1">randn</span>(<span class="pl-c1">size</span>(uv)))
dv         <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(yv,uv,<span class="pl-c1">1</span>)
dnv        <span class="pl-k">=</span> <span class="pl-c1">iddata</span>(ynv,uv,<span class="pl-c1">1</span>)</pre></div>
<p>We then fit a couple of models, the flag <code>difficult=true</code> causes <code>pem</code> to solve an initial global optimization problem with constraints on the stability of <code>A-KC</code> to provide a good guess for the gradient-based solver</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="res = [pem(dn,nx=nx, iterations=1000, difficult=true, focus=:prediction) for nx = [1,3,4]]
"><pre>res <span class="pl-k">=</span> [<span class="pl-c1">pem</span>(dn,nx<span class="pl-k">=</span>nx, iterations<span class="pl-k">=</span><span class="pl-c1">1000</span>, difficult<span class="pl-k">=</span><span class="pl-c1">true</span>, focus<span class="pl-k">=</span><span class="pl-c1">:prediction</span>) <span class="pl-k">for</span> nx <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>]]</pre></div>
<p>After fitting the models, we validate the results using the validation data and the functions <code>simplot</code> and <code>predplot</code> (cf. Matlab sys.id's <code>compare</code>):</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="ω   = exp10.(range(-2, stop=log10(pi), length=150))
fig = plot(layout=4, size=(1000,600))
for i in eachindex(res)
    (sysh,x0h,opt) = res[i]
    simplot!( sysh,dnv,x0h; subplot=1, ploty=i==1)
    predplot!(sysh,dnv,x0h; subplot=2, ploty=i==1)
end
bodeplot!(ss.(getindex.(res,1)),                   ω, plotphase=false, subplot=3, title=&quot;Process&quot;, linewidth=2*[4 3 2 1])
bodeplot!(innovation_form.(getindex.(res,1)),      ω, plotphase=false, subplot=4, linewidth=2*[4 3 2 1])
bodeplot!(sys,                                     ω, plotphase=false, subplot=3, lab=&quot;True&quot;, linecolor=:blue, l=:dash, legend = :bottomleft, title=&quot;System model&quot;)
bodeplot!(innovation_form(ss(sys),syse=ss(sysn)),  ω, plotphase=false, subplot=4, lab=&quot;True&quot;, linecolor=:blue, l=:dash, ylims=(0.1, 100), legend = :bottomleft, title=&quot;Noise model&quot;)
display(fig)
"><pre>ω   <span class="pl-k">=</span> <span class="pl-c1">exp10</span>.(<span class="pl-c1">range</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>, stop<span class="pl-k">=</span><span class="pl-c1">log10</span>(<span class="pl-c1">pi</span>), length<span class="pl-k">=</span><span class="pl-c1">150</span>))
fig <span class="pl-k">=</span> <span class="pl-c1">plot</span>(layout<span class="pl-k">=</span><span class="pl-c1">4</span>, size<span class="pl-k">=</span>(<span class="pl-c1">1000</span>,<span class="pl-c1">600</span>))
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">eachindex</span>(res)
    (sysh,x0h,opt) <span class="pl-k">=</span> res[i]
    <span class="pl-c1">simplot!</span>( sysh,dnv,x0h; subplot<span class="pl-k">=</span><span class="pl-c1">1</span>, ploty<span class="pl-k">=</span>i<span class="pl-k">==</span><span class="pl-c1">1</span>)
    <span class="pl-c1">predplot!</span>(sysh,dnv,x0h; subplot<span class="pl-k">=</span><span class="pl-c1">2</span>, ploty<span class="pl-k">=</span>i<span class="pl-k">==</span><span class="pl-c1">1</span>)
<span class="pl-k">end</span>
<span class="pl-c1">bodeplot!</span>(<span class="pl-c1">ss</span>.(<span class="pl-c1">getindex</span>.(res,<span class="pl-c1">1</span>)),                   ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">3</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Process<span class="pl-pds">"</span></span>, linewidth<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span>[<span class="pl-c1">4</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>])
<span class="pl-c1">bodeplot!</span>(<span class="pl-c1">innovation_form</span>.(<span class="pl-c1">getindex</span>.(res,<span class="pl-c1">1</span>)),      ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">4</span>, linewidth<span class="pl-k">=</span><span class="pl-c1">2</span><span class="pl-k">*</span>[<span class="pl-c1">4</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>])
<span class="pl-c1">bodeplot!</span>(sys,                                     ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">3</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span>, linecolor<span class="pl-k">=</span><span class="pl-c1">:blue</span>, l<span class="pl-k">=</span><span class="pl-c1">:dash</span>, legend <span class="pl-k">=</span> <span class="pl-c1">:bottomleft</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>System model<span class="pl-pds">"</span></span>)
<span class="pl-c1">bodeplot!</span>(<span class="pl-c1">innovation_form</span>(<span class="pl-c1">ss</span>(sys),syse<span class="pl-k">=</span><span class="pl-c1">ss</span>(sysn)),  ω, plotphase<span class="pl-k">=</span><span class="pl-c1">false</span>, subplot<span class="pl-k">=</span><span class="pl-c1">4</span>, lab<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span>, linecolor<span class="pl-k">=</span><span class="pl-c1">:blue</span>, l<span class="pl-k">=</span><span class="pl-c1">:dash</span>, ylims<span class="pl-k">=</span>(<span class="pl-c1">0.1</span>, <span class="pl-c1">100</span>), legend <span class="pl-k">=</span> <span class="pl-c1">:bottomleft</span>, title<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Noise model<span class="pl-pds">"</span></span>)
<span class="pl-c1">display</span>(fig)</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="figs/val.svg"><img src="figs/val.svg" alt="window" style="max-width:100%;"></a></p>
<p>In the figure, simulation output is compared to the true model on the top left and prediction on top right. The system models and noise models are visualized in the bottom plots. Both high-order models capture the system dynamics well, but struggle slightly with capturing the gain of the noise dynamics.
The figure also indicates that a model with 4 poles performs best on both prediction and simulation data. The true system has 4 poles (two in the process and two in the noise process) so this is expected. However, the third order model performs almost equally well and may be a better choice.</p>
<h1><a id="user-content-other-resources" class="anchor" aria-hidden="true" href="#other-resources"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Other resources</h1>
<ul>
<li>For estimation of linear time-varying models (LTV), see <a href="https://github.com/baggepinnen/LTVModels.jl">LTVModels.jl</a>.</li>
<li>For estimation of linear and nonlinear grey-box models in continuous time, see <a href="http://docs.juliadiffeq.org/stable/analysis/parameter_estimation.html" rel="nofollow">DifferentialEquations.jl (parameter estimation)</a></li>
<li>Estimation of nonlinear black-box models in continuous time <a href="https://github.com/JuliaDiffEq/DiffEqFlux.jl/">DiffEqFlux.jl</a> and in discrete time <a href="https://github.com/FluxML/Flux.jl">Flux.jl</a></li>
<li>For more advanced spectral estimation, cross coherence, etc., see <a href="https://github.com/baggepinnen/LPVSpectral.jl">LPVSpectral.jl</a></li>
<li>This package interacts well with <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a>. See <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/controlsystems.jl">example file</a>.</li>
</ul>
</article></div>