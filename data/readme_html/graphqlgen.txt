<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-graphqlgenjl" class="anchor" aria-hidden="true" href="#graphqlgenjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GraphQLGen.jl</h1>
<p dir="auto">Generates Julia types and functions from GraphQL schema. See the <a href="./example">example</a> for usage.</p>
<p dir="auto">There's also an example of the <a href="./github-schema-example">official Github schema</a>.</p>
<p dir="auto"><strong>Caveats:</strong></p>
<blockquote>
<p dir="auto">NOTE !!! If you're using enum GraphQL types you will need to include <a href="https://github.com/fredrikekre/EnumX.jl">EnumX</a> with your code. This is because the standard <code>@enum</code> macro does not allow for fields of an Enum to be redefined.</p>
</blockquote>
<blockquote>
<p dir="auto">If an union GraphQLtype is detected as part of a graph cyle it's type is renamed to Any to get around parsing errors. An assert check may be added in the future so that there is <em>some form</em> of type checking.</p>
</blockquote>
<h2 dir="auto"><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>API</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&quot;&quot;&quot;
    function generate(
        codegen_dir::String,
        schema_paths::Vector{String};
        generate_types::Bool = true,
        generate_functions::Bool = true,
        generated_header::String = &quot;&quot;,
        to_skip::Set{Symbol} = Set{Symbol}(),
        scalar_type_map::Dict = Dict(),
    )

    function generate_from_schema(
        codegen_dir::String,
        schema::String;
        generate_types::Bool = true,
        generate_functions::Bool = true,
        generated_header::String = &quot;&quot;,
        to_skip::Set{Symbol} = Set{Symbol}(),
        scalar_type_map::Dict = Dict(),
    )

Generate Julia code files for GraphQL types and functions.

- &quot;graphqlgen_types.jl&quot;: contains all the GraphQL types
- &quot;graphqlgen_functions.jl&quot;: contains all the GraphQL functions (mutations, queries, subscriptions)

* `codegen_dir`: directory where the generated files will be saved
* `schema_paths`: list of paths to GraphQL schema files. This can be a file or a directory. If it's a directory, it will be recursively searched for GraphQL schema files.

* `generate_types`: whether to generate &quot;graphqlgen_types.jl&quot;
* `generate_functions`: whether to generate &quot;graphqlgen_functions.jl&quot;
* `generated_header`: header prepended to generated files
* `to_skip`: types or functions to skip generating
* `scalar_type_map`: mapping of GraphQL scalar types to their corresponding Julia types
&quot;&quot;&quot;"><pre><span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    function generate(</span>
<span class="pl-s">        codegen_dir::String,</span>
<span class="pl-s">        schema_paths::Vector{String};</span>
<span class="pl-s">        generate_types::Bool = true,</span>
<span class="pl-s">        generate_functions::Bool = true,</span>
<span class="pl-s">        generated_header::String = "",</span>
<span class="pl-s">        to_skip::Set{Symbol} = Set{Symbol}(),</span>
<span class="pl-s">        scalar_type_map::Dict = Dict(),</span>
<span class="pl-s">    )</span>
<span class="pl-s"></span>
<span class="pl-s">    function generate_from_schema(</span>
<span class="pl-s">        codegen_dir::String,</span>
<span class="pl-s">        schema::String;</span>
<span class="pl-s">        generate_types::Bool = true,</span>
<span class="pl-s">        generate_functions::Bool = true,</span>
<span class="pl-s">        generated_header::String = "",</span>
<span class="pl-s">        to_skip::Set{Symbol} = Set{Symbol}(),</span>
<span class="pl-s">        scalar_type_map::Dict = Dict(),</span>
<span class="pl-s">    )</span>
<span class="pl-s"></span>
<span class="pl-s">Generate Julia code files for GraphQL types and functions.</span>
<span class="pl-s"></span>
<span class="pl-s">- "graphqlgen_types.jl": contains all the GraphQL types</span>
<span class="pl-s">- "graphqlgen_functions.jl": contains all the GraphQL functions (mutations, queries, subscriptions)</span>
<span class="pl-s"></span>
<span class="pl-s">* `codegen_dir`: directory where the generated files will be saved</span>
<span class="pl-s">* `schema_paths`: list of paths to GraphQL schema files. This can be a file or a directory. If it's a directory, it will be recursively searched for GraphQL schema files.</span>
<span class="pl-s"></span>
<span class="pl-s">* `generate_types`: whether to generate "graphqlgen_types.jl"</span>
<span class="pl-s">* `generate_functions`: whether to generate "graphqlgen_functions.jl"</span>
<span class="pl-s">* `generated_header`: header prepended to generated files</span>
<span class="pl-s">* `to_skip`: types or functions to skip generating</span>
<span class="pl-s">* `scalar_type_map`: mapping of GraphQL scalar types to their corresponding Julia types</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></pre></div>
<blockquote>
<p dir="auto"><code>generate_from_schema</code> has the same API as <code>generate</code> but the second argument is the schema itself rather than the file(s) of the schema.</p>
</blockquote>
<h2 dir="auto"><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick Start</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Generate julia files in the GraphQLAPI directory based off all the files found in
# the schemas directory.
# 
# NOTE: You should do one call for all schema files rather than N seperate calls.
julia&gt; GraphQLGen.generate(&quot;GraphQLAPI&quot;, &quot;schemas/&quot;)

# This generates a module in the GraphQLAPI (intended to be used as a submodule of a project)
# The file structure will be

# | GraphQLAPI
# --- GraphQLAPI.jl
# --- graphqlgen_types.jl
# --- graphqlgen_functions.jl

# The contents of GraphQLAPI will be:

module GraphQLAPI

include(&quot;graphqlgen_types.jl&quot;)
include(&quot;graphqlgen_functions.jl&quot;)

end # module GraphQLAPI
"><pre><span class="pl-c"><span class="pl-c">#</span> Generate julia files in the GraphQLAPI directory based off all the files found in</span>
<span class="pl-c"><span class="pl-c">#</span> the schemas directory.</span>
<span class="pl-c"><span class="pl-c">#</span> </span>
<span class="pl-c"><span class="pl-c">#</span> NOTE: You should do one call for all schema files rather than N seperate calls.</span>
julia<span class="pl-k">&gt;</span> GraphQLGen<span class="pl-k">.</span><span class="pl-c1">generate</span>(<span class="pl-s"><span class="pl-pds">"</span>GraphQLAPI<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>schemas/<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> This generates a module in the GraphQLAPI (intended to be used as a submodule of a project)</span>
<span class="pl-c"><span class="pl-c">#</span> The file structure will be</span>

<span class="pl-c"><span class="pl-c">#</span> | GraphQLAPI</span>
<span class="pl-c"><span class="pl-c">#</span> --- GraphQLAPI.jl</span>
<span class="pl-c"><span class="pl-c">#</span> --- graphqlgen_types.jl</span>
<span class="pl-c"><span class="pl-c">#</span> --- graphqlgen_functions.jl</span>

<span class="pl-c"><span class="pl-c">#</span> The contents of GraphQLAPI will be:</span>

<span class="pl-k">module</span> GraphQLAPI

<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>graphqlgen_types.jl<span class="pl-pds">"</span></span>)
<span class="pl-c1">include</span>(<span class="pl-s"><span class="pl-pds">"</span>graphqlgen_functions.jl<span class="pl-pds">"</span></span>)

<span class="pl-k">end</span> <span class="pl-c"><span class="pl-c">#</span> module GraphQLAPI</span>
</pre></div>
<blockquote>
<p dir="auto">You do not need to use <code>GraphQLAPI.jl</code>, in-fact it may be preferable to just include the types and functions files themselves or create your own submodule.</p>
</blockquote>
<p dir="auto">Generated files:</p>
<ul dir="auto">
<li><code>graphqlgen_types.jl</code>: contains all the GraphQL types</li>
<li><code>graphqlgen_functions.jl</code>: contains all the GraphQL functions (mutations, queries, subscriptions). The intended use of these functions at the moment is to create easily create queries and variables such that they can be easily serialized for an HTTP request.</li>
</ul>
<h2 dir="auto"><a id="user-content-codegen-peculiarities" class="anchor" aria-hidden="true" href="#codegen-peculiarities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Codegen Peculiarities</h2>
<p dir="auto">Types may be ordered differently in the Julia file than the schema file. This is because
the Julia types must be ordered by usage. For example, if struct A uses struct B in a field
then B must appear before A in Julia code. This is also why all schema files should be parsed
at together. If there are types which reference eachother across files and code is generated
for each file separately, then the codegen can't ensure they will be ordered correctly.</p>
<p dir="auto">If there is a cycle then the types of the affected fields will be dropped altogether to ensure
they are not referenced out of turn.</p>
</article></div>