<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-rankedchoicesjl" class="anchor" aria-hidden="true" href="#rankedchoicesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>RankedChoices.jl</h1>
<h3 dir="auto"><a id="user-content-gleaning-insights-from-ordinal-preferences" class="anchor" aria-hidden="true" href="#gleaning-insights-from-ordinal-preferences"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Gleaning Insights from Ordinal Preferences</h3>
<p dir="auto">You've gone through the hard work of collecting a survey with ranked choices. You appreciate the beauty of this format, by which participants relay their preferences without getting caught up in allocating abstract units of utility. What next? It would be a shame to throw away any of the population dynamics conveyed through these rankings.</p>
<p dir="auto">This package was developed with the single aim of capturing the bevy of high-order relations between cohort preferences. It provides a flexible Bayesian model, implements two samplers, and exposes an arsenal of procedures to interpret resulting posteriors. Key features include mixtures of full-rank multivariate Gaussian cohorts, and the ability for one model to accommodate rankings between distinct sets of items.</p>
<p dir="auto">Idealistically, our elections should run on this kind of algorithm. See this <a href="https://myrl.marmarel.is/posts/ranked-choice-voting/" rel="nofollow">blog post</a> that elaborates further on the subject.</p>
<h3 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h3>
<p dir="auto"><code>pkg&gt; add RankedChoices</code></p>
<p dir="auto">(press <code>]</code> in the REPL to invoke the package manager on your current project)</p>
<h2 dir="auto"><a id="user-content-interface" class="anchor" aria-hidden="true" href="#interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interface</h2>
<p dir="auto">Here I detail how to parse rankings, handle the Gibbs sampler, and interpret the results. For instance,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# (n_respondents x ranking_size)
rankings = [
  &quot;B&quot; &quot;C&quot; &quot;D&quot;;
  &quot;A&quot; &quot;D&quot; &quot;C&quot;;
  &quot;B&quot; &quot;C&quot; &quot;E&quot;;
  &quot;A&quot; &quot;B&quot; &quot;&quot; ; # denote missing entries with empty strings
  &quot;D&quot; &quot;A&quot; &quot;B&quot;;
  &quot;A&quot; &quot;&quot;  &quot;&quot; ] # e.g...

# there are other ways to extract IssueVote structures
votes, candidates = parse_matrix(rankings)

n_candidates = length(candidates) # 5, per above
n_cohorts = 3
n_trials = 40_000

prior = make_impartial_prior(n_candidates, n_cohorts,
  precision_scale=1e1, precision_dof=1e2,
  mean_scale=1e0, dirichlet_weight=1e1)

simulation = HamiltonianSim(
  n_trajectories=1, collision_limit=128)

result = simulate(prior, simulation, votes, n_trials,
  n_burnin=10_000, seed=1337)
"><pre><span class="pl-c"><span class="pl-c">#</span> (n_respondents x ranking_size)</span>
rankings <span class="pl-k">=</span> [
  <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>;
  <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>;
  <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>E<span class="pl-pds">"</span></span>;
  <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> ; <span class="pl-c"><span class="pl-c">#</span> denote missing entries with empty strings</span>
  <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>;
  <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> ] <span class="pl-c"><span class="pl-c">#</span> e.g...</span>

<span class="pl-c"><span class="pl-c">#</span> there are other ways to extract IssueVote structures</span>
votes, candidates <span class="pl-k">=</span> <span class="pl-c1">parse_matrix</span>(rankings)

n_candidates <span class="pl-k">=</span> <span class="pl-c1">length</span>(candidates) <span class="pl-c"><span class="pl-c">#</span> 5, per above</span>
n_cohorts <span class="pl-k">=</span> <span class="pl-c1">3</span>
n_trials <span class="pl-k">=</span> <span class="pl-c1">40_000</span>

prior <span class="pl-k">=</span> <span class="pl-c1">make_impartial_prior</span>(n_candidates, n_cohorts,
  precision_scale<span class="pl-k">=</span><span class="pl-c1">1e1</span>, precision_dof<span class="pl-k">=</span><span class="pl-c1">1e2</span>,
  mean_scale<span class="pl-k">=</span><span class="pl-c1">1e0</span>, dirichlet_weight<span class="pl-k">=</span><span class="pl-c1">1e1</span>)

simulation <span class="pl-k">=</span> <span class="pl-c1">HamiltonianSim</span>(
  n_trajectories<span class="pl-k">=</span><span class="pl-c1">1</span>, collision_limit<span class="pl-k">=</span><span class="pl-c1">128</span>)

result <span class="pl-k">=</span> <span class="pl-c1">simulate</span>(prior, simulation, votes, n_trials,
  n_burnin<span class="pl-k">=</span><span class="pl-c1">10_000</span>, seed<span class="pl-k">=</span><span class="pl-c1">1337</span>)
</pre></div>
<h3 dir="auto"><a id="user-content-structures" class="anchor" aria-hidden="true" href="#structures"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Structures</h3>
<p dir="auto">The main data type to carry your observations is the <code>IssueVote</code>, which contains an array <code>choices</code> of <code>RankedChoice</code> immutable objects. They correspond to a participant's ranking of <code>1:n_candidates</code> items. All <code>RankedChoice</code>s of each <code>IssueVote</code> are static integer vectors of common length <code>R</code>, the maximum ranking size. A model actually consumes <code>MultiIssueVote</code> objects, which wrap an <code>IssueVote</code> tuple.</p>
<h3 dir="auto"><a id="user-content-parsing" class="anchor" aria-hidden="true" href="#parsing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Parsing</h3>
<p dir="auto">You produce <code>IssueVote(choices, n_candidates)</code> objects by manual construction or through...</p>
<ul dir="auto">
<li><code>parse_matrix(votes::Matrix{String})</code></li>
<li>the more versatile <code>parse_matrix(votes, candidates)</code> where you list off the candidate strings in your desired order, and unrecognized strings are tossed into the second return value.</li>
<li><code>read_csv(filename, candidates)</code></li>
<li><code>read_xlsx(filename, candidates)</code></li>
</ul>
<h3 dir="auto"><a id="user-content-simulators" class="anchor" aria-hidden="true" href="#simulators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Simulators</h3>
<p dir="auto">Two simulation tactics are exposed: <code>RejectionSim</code> and <code>HamiltonianSim</code>. The original and simpler implementation, <code>RejectionSim(n_sample_attempts::Int)</code>, converges in fewer iterations because its samples are independent. It is, however, drastically slower in handling large rankings. Please ensure that <code>n_sample_attempts</code> is large enough that the resultant <code>n_failures / (n_voters * n_iterations)</code> is close to zero.</p>
<p dir="auto">The snazzy <code>HamiltonianSim(n_trajectories::Int, collision_limit::Int)</code> is much more complex, but converges quickly even on large rankings. You can set parameter <code>n_trajectories := 1</code> if you don't mind consecutive samples being correlated. Additionally, <code>collision_limit</code> can be set to a relatively high number like <code>128</code>. It determines how many times a ball can bounce between the walls of a linearly constrained Gaussian before we give up early.</p>
<h3 dir="auto"><a id="user-content-conjugate-priors" class="anchor" aria-hidden="true" href="#conjugate-priors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Conjugate Priors</h3>
<p dir="auto">My sampler is Bayesian, and takes advantage of a number of conjugate priors. We typically seek to treat all cohorts and respondents equally a priori. Hence, I expose a method</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="prior = make_impartial_prior(n_total_candidates, n_cohorts;
  precision_scale, precision_dof, mean_scale, dirichlet_weight)"><pre>prior <span class="pl-k">=</span> <span class="pl-c1">make_impartial_prior</span>(n_total_candidates, n_cohorts;
  precision_scale, precision_dof, mean_scale, dirichlet_weight)</pre></div>
<p dir="auto">where...</p>
<ul dir="auto">
<li><code>precision_scale</code>, usually around or above unit, scales the diagonal matrix that parametrizes a Wishart prior for the precision matrix.</li>
<li><code>precision_dof</code> sets the strength of the Wishart prior for influencing precision matrices.</li>
<li><code>mean_scale</code>, which can stay unit, constrains the spread of the multivariate cohort means. In particular, it determines how much less the mean is spread out compared to the spread of the actual utilities.</li>
<li><code>dirichlet_weight</code>, typically greater than unit, determines how strongly to favor cohorts of equal proportion</li>
</ul>
<h3 dir="auto"><a id="user-content-sampler" class="anchor" aria-hidden="true" href="#sampler"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sampler</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="result = simulate(prior, simulation, votes, n_trials;
  n_burnin, seed, indifference=false, verbose=false)"><pre>result <span class="pl-k">=</span> <span class="pl-c1">simulate</span>(prior, simulation, votes, n_trials;
  n_burnin, seed, indifference<span class="pl-k">=</span><span class="pl-c1">false</span>, verbose<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto">The boolean flag <code>indifference</code> tells the sampler whether to treat incomplete rankings as implying that all unlisted candidates are lower than those listed (<code>indifference := false</code>) or not (<code>indifference := true</code>).</p>
<p dir="auto">More details on the core methods coming soon.</p>
</article></div>