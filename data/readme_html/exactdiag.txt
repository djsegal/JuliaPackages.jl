<div id="readme" class="rst" data-path="README.rst"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-exactdiag" class="anchor" aria-hidden="true" href="#exactdiag"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>ExactDiag</h1>
<a href="https://travis-ci.org/garrison/ExactDiag.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/5d61f9923f0a25ab1b3818f6415fcdb34d9fb037/68747470733a2f2f7472617669732d63692e6f72672f6761727269736f6e2f4578616374446961672e6a6c2e737667" data-canonical-src="https://travis-ci.org/garrison/ExactDiag.jl.svg" style="max-width:100%;">
</a>
<a href="https://coveralls.io/r/garrison/ExactDiag.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/747ab0b07e9077ee8d3b33f3911dd9050c7efbe6/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6761727269736f6e2f4578616374446961672e6a6c2f62616467652e737667" data-canonical-src="https://coveralls.io/repos/garrison/ExactDiag.jl/badge.svg" style="max-width:100%;">
</a>
<p>Very much a work in progress.</p>
<p>See also: <a href="https://github.com/garrison/UniqueVectors.jl">UniqueVectors</a>, LinTables (coming soon).  And also <a href="https://github.com/garrison/Bravais.jl">Bravais</a>.</p>
<a name="user-content-available-model-systems"></a>
<h2><a id="user-content-available-model-systems" class="anchor" aria-hidden="true" href="#available-model-systems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Available model systems</h2>
<a name="user-content-spin-1-2"></a>
<h3><a id="user-content-spin-12" class="anchor" aria-hidden="true" href="#spin-12"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Spin 1/2</h3>
<p>Spin up = 0, spin down = 1</p>
<a name="user-content-hard-core-bosons"></a>
<h3><a id="user-content-hard-core--bosons" class="anchor" aria-hidden="true" href="#hard-core--bosons"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hard-core (?) bosons</h3>
<p>Presence of particle = 1, absence = 0.</p>
<a name="user-content-fermionic-hubbard-models"></a>
<h3><a id="user-content-fermionic-hubbard-models" class="anchor" aria-hidden="true" href="#fermionic-hubbard-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Fermionic Hubbard models</h3>
<p>0,1,2,3</p>
<a name="user-content-diagonalization-of-translationally-invariant-system"></a>
<h2><a id="user-content-diagonalization-of-translationally-invariant-system" class="anchor" aria-hidden="true" href="#diagonalization-of-translationally-invariant-system"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Diagonalization of translationally invariant system</h2>
<pre>.. todo:: old assumptions: PBC, and no fermions involved.

</pre>
<p>Typically, our goal is to find one or more eigenstates of the Hamiltonian <tt>\hat{H}</tt>.  When <tt>\hat{H}</tt> is translation invariant, we can change our basis such that <tt>\hat{H}</tt> is diagonal in each momentum sector.  We can take advantage of this by then diagonalizing each sector independently, or diagonalizing just the sector(s) we are interested in.  This uses both less processor time and less memory for a given system size.</p>
<p>So how exactly do we diagonalize each momentum sector separately?</p>
<p>Consider a projection operator</p>
<pre>\hat{P}_\mathbf{k} \equiv \frac{1}{N} \sum_\mathbf{r} e^{i\mathbf{k}\cdot \mathbf{r}} \prod_{i=1}^{d} \hat{T}_i^{r_i}
</pre>
<p>where <tt>r_i</tt> is defined by <tt>\mathbf{r} = \sum_{i=1}^d r_i \mathbf{a}_i</tt> (where <tt>\mathbf{a}_i</tt> are the primitive vectors of the lattice), <tt>\hat{T}_i</tt> is the unit translation operator in the <tt>i</tt>'th direction of the lattice, and <tt>\mathbf{k}</tt> is some allowed momentum of the system.  (In a one dimensional spin-1/2 system of length <tt>L</tt> with PBC, the translation operator is defined such that <tt>\hat{T}_1 \vert \sigma_1 \cdots \sigma_{L-1} \sigma_L \rangle = \vert \sigma_L \sigma_1 \cdots \sigma_{L-1} \rangle</tt>, and <tt>k= \frac{2\pi k_\mathrm{idx}}{L}</tt> where <tt>k_\mathrm{idx} \in \mathbb{Z}_L</tt>.)</p>
<p>Since <tt>[\hat{H}, \hat{T}_i] = 0</tt>, it follows that <tt>[\hat{H}, \hat{P}_\mathbf{k}] = 0</tt>.  It can also be shown that <tt>\hat{P}_\mathbf{k}^\dagger = \hat{P}_\mathbf{k}</tt> and <tt>\hat{P}_\mathbf{k}^2 = \hat{P}_\mathbf{k}</tt>.  In other words, <tt>\hat{P}_\mathbf{k}</tt> is a Hermitian projection operator that commutes with the Hamiltonian.</p>
<p>We can use this operator to project an arbitrary "representative" state <tt>\vert r \rangle</tt> to a momentum state <tt>\hat{P}_\mathbf{k} \vert r \rangle</tt>.  If <tt>\hat{P}_\mathbf{k} \vert r \rangle = 0</tt>, there is no such state at momentum <tt>k</tt> represented by <tt>\vert r \rangle</tt>.  However, if <tt>\hat{P}_\mathbf{k} \vert r \rangle \ne 0</tt>, we can define a normalized state</p>
<pre>\vert r_\mathbf{k} \rangle \equiv \frac{1}{\mathcal{N}_{r_\mathbf{k}}} \hat{P}_\mathbf{k} \vert r \rangle
</pre>
<p>where <tt>\mathcal{N}_{r_\mathbf{k}} = \sqrt{\langle r \vert \hat{P}_\mathbf{k} \vert r \rangle}</tt> such that <tt>\langle r_\mathbf{k} \vert r_\mathbf{k} \rangle = 1</tt>.  Note that <tt>\vert r_\mathbf{k} \rangle</tt> is an eigenstate of <tt>\hat{T}_j</tt> with eigenvalue <tt>e^{-ik_j}</tt>.</p>
<p>For a concrete example, consider a 1D system with <tt>L=4</tt> and PBC.  The representative state <tt>\vert \uparrow \downarrow \downarrow \downarrow \rangle</tt> can exist at any available momentum in the system.  For instance, at <tt>k=\pi / 2</tt>, the corresponding momentum state becomes</p>
<pre>\vert \uparrow \downarrow \downarrow \downarrow _{\pi/2} \rangle
\equiv \frac{1}{2} \left[
\vert \uparrow \downarrow \downarrow \downarrow \rangle
+ i \vert \downarrow \uparrow \downarrow \downarrow \rangle
- \vert \downarrow \downarrow \uparrow \downarrow \rangle
- i \vert \downarrow \downarrow \downarrow \uparrow \rangle \right]
</pre>
<p>Now consider instead the representative state <tt>\vert \uparrow \downarrow \uparrow \downarrow \rangle</tt>.  There is no such state at momentum <tt>\pi/2</tt>, since <tt>\hat{P}_{\pi/2} \vert \uparrow \downarrow \uparrow \downarrow \rangle = 0</tt>.  However, there are states at momenta <tt>0</tt> and <tt>\pi</tt>.  For instance,</p>
<pre>\vert \uparrow \downarrow \uparrow \downarrow _\pi \rangle
\equiv \frac{1}{\sqrt{2}} \left[
\vert \uparrow \downarrow \uparrow \downarrow \rangle
- \vert \downarrow \uparrow \downarrow \uparrow \rangle
\right]
</pre>
<p>With this in mind we generally act as follows.  We choose a unique representative state for each class of states that are connected to each other by translation.  Then, given a momentum <tt>\mathbf{k}</tt>, we go through each representative state and calculate its normalization <tt>\mathcal{N}_{r_\mathbf{k}}</tt>.  We consider each state <tt>\vert r_\mathbf{k} \rangle</tt> where <tt>\mathcal{N}_{r_\mathbf{k}} \ne 0</tt> to be part of our basis in this momentum sector.  We can then evaluate the matrix elements, given by</p>
<pre>\langle r_\mathbf{k}^\prime \vert \hat{H} \vert r_\mathbf{k} \rangle
= \frac{1}{\mathcal{N}_{r_\mathbf{k}^\prime}\mathcal{N}_{r_\mathbf{k}}} \langle r^\prime \vert \hat{P}_\mathbf{k} \hat{H} \hat{P}_\mathbf{k} \vert r \rangle
= \frac{1}{\mathcal{N}_{r_\mathbf{k}^\prime}\mathcal{N}_{r_\mathbf{k}}} \langle r^\prime \vert \hat{P}_\mathbf{k} \hat{H} \vert r \rangle
</pre>
<p>where the last part uses <tt>[\hat{H}, \hat{P}_\mathbf{k}] = 0</tt> and <tt>\hat{P}_\mathbf{k}^2 = \hat{P}_\mathbf{k}</tt>.</p>
<p>We diagonalize <tt>\hat{H}</tt> in this basis given by <tt>\vert r_\mathbf{k} \rangle</tt>; that is, we diagonalize the matrix given by matrix elements <tt>\langle r_\mathbf{k}^\prime \vert \hat{H} \vert r_\mathbf{k} \rangle</tt>.  Given the eigenstates in this basis, we can recover our eigenstates in the original (position space) basis by evaluating <tt>\langle s \vert r_\mathbf{k} \rangle</tt> using the definition of <tt>\vert r_\mathbf{k} \rangle</tt> above.</p>
<p>NOTE: we want to be able to do both unitaries; transforming to momentum basis, and back from it to position basis.</p>
<a name="user-content-other-code-notes"></a>
<h2><a id="user-content-other-code-notes" class="anchor" aria-hidden="true" href="#other-code-notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Other code notes</h2>
<p><code>UniqueVectors</code> is used to assign each state (e.g. <code>[1, 0, 1, 1, 0]</code> in Julia land) to an index, and vice versa.  Given <tt>M</tt> unique states, the indices will range from <tt>1</tt> to <tt>M</tt>.</p>

</article></div>