<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-exaadmmjl" class="anchor" aria-hidden="true" href="#exaadmmjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ExaAdmm.jl</h1>
<p dir="auto"><a href="https://github.com/exanauts/ExaAdmm.jl/actions/workflows/ci.yml"><img src="https://github.com/exanauts/ExaAdmm.jl/actions/workflows/ci.yml/badge.svg" alt="" style="max-width: 100%;"></a> <a href="https://exanauts.github.io/ExaAdmm.jl/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a> <a href="https://zenodo.org/badge/latestdoi/412625681" rel="nofollow"><img src="https://camo.githubusercontent.com/8b5ddb64288c7cfd8a995ceeae7398f2ffaaea5cd85561c79bc16f1c857c1437/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3431323632353638312e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/412625681.svg" style="max-width: 100%;"></a></p>
<p dir="auto">ExaAdmm.jl implements the two-level alternating direction method of multipliers for solving the component-based decomposition of alternating current optimal power flow problems on GPUs.</p>
<h2 dir="auto"><a id="user-content-how-to-install" class="anchor" aria-hidden="true" href="#how-to-install"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to install</h2>
<p dir="auto">The package can be installed in the Julia REPL with the command below:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="] add ExaAdmm"><pre>] add ExaAdmm</pre></div>
<p dir="auto">Running the algorithms on the GPU requires either NVIDIA GPUs with <a href="https://github.com/JuliaGPU/CUDA.jl"><code>CUDA.jl</code></a> or <a href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions.jl</code></a> (KA) with the respective device support (e.g., <a href="https://github.com/JuliaGPU/AMDGPU.jl"><code>AMDGPU.jl</code></a> and <code>ROCKernels.jl</code>). Currently, only the ACOPF problem is supported using KA.</p>
<h2 dir="auto"><a id="user-content-how-to-run" class="anchor" aria-hidden="true" href="#how-to-run"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to run</h2>
<p dir="auto">Currently, <code>ExaAdmm.jl</code> supports electrical grid files in the MATLAB format. You can download them from <a href="https://github.com/MATPOWER/matpower">here</a>.
Below shows an example of solving <code>case1354pegase.m</code> using <code>ExaAdmm.jl</code> on an NVIDIA GPU</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ExaAdmm

env, mod = solve_acopf(
    &quot;case1354pegase.m&quot;;
    rho_pq=1e1,
    rho_va=1e3,
    outer_iterlim=20,
    inner_iterlim=20,
    scale=1e-4,
    tight_factor=0.99,
    use_gpu=true,
    verbose=1
);"><pre><span class="pl-k">using</span> ExaAdmm

env, mod <span class="pl-k">=</span> <span class="pl-c1">solve_acopf</span>(
    <span class="pl-s"><span class="pl-pds">"</span>case1354pegase.m<span class="pl-pds">"</span></span>;
    rho_pq<span class="pl-k">=</span><span class="pl-c1">1e1</span>,
    rho_va<span class="pl-k">=</span><span class="pl-c1">1e3</span>,
    outer_iterlim<span class="pl-k">=</span><span class="pl-c1">20</span>,
    inner_iterlim<span class="pl-k">=</span><span class="pl-c1">20</span>,
    scale<span class="pl-k">=</span><span class="pl-c1">1e-4</span>,
    tight_factor<span class="pl-k">=</span><span class="pl-c1">0.99</span>,
    use_gpu<span class="pl-k">=</span><span class="pl-c1">true</span>,
    verbose<span class="pl-k">=</span><span class="pl-c1">1</span>
);</pre></div>
<p dir="auto">and the same example on an AMD GPU:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ExaAdmm
using AMDGPU

ExaAdmm.KAArray{T}(n::Int, ::ROCBackend) where {T} = ROCArray{T}(undef, n)

env, mod = solve_acopf(
    &quot;case1354pegase.m&quot;;
    rho_pq=1e1,
    rho_va=1e3,
    outer_iterlim=20,
    inner_iterlim=20,
    scale=1e-4,
    tight_factor=0.99,
    use_gpu=true,
    ka_device = ROCBackend(),
    verbose=1
)"><pre><span class="pl-k">using</span> ExaAdmm
<span class="pl-k">using</span> AMDGPU

ExaAdmm<span class="pl-k">.</span><span class="pl-en">KAArray</span><span class="pl-c1">{T}</span>(n<span class="pl-k">::</span><span class="pl-c1">Int</span>, <span class="pl-k">::</span><span class="pl-c1">ROCBackend</span>) <span class="pl-k">where</span> {T} <span class="pl-k">=</span> <span class="pl-c1">ROCArray</span><span class="pl-c1">{T}</span>(undef, n)

env, mod <span class="pl-k">=</span> <span class="pl-c1">solve_acopf</span>(
    <span class="pl-s"><span class="pl-pds">"</span>case1354pegase.m<span class="pl-pds">"</span></span>;
    rho_pq<span class="pl-k">=</span><span class="pl-c1">1e1</span>,
    rho_va<span class="pl-k">=</span><span class="pl-c1">1e3</span>,
    outer_iterlim<span class="pl-k">=</span><span class="pl-c1">20</span>,
    inner_iterlim<span class="pl-k">=</span><span class="pl-c1">20</span>,
    scale<span class="pl-k">=</span><span class="pl-c1">1e-4</span>,
    tight_factor<span class="pl-k">=</span><span class="pl-c1">0.99</span>,
    use_gpu<span class="pl-k">=</span><span class="pl-c1">true</span>,
    ka_device <span class="pl-k">=</span> <span class="pl-c1">ROCBackend</span>(),
    verbose<span class="pl-k">=</span><span class="pl-c1">1</span>
)</pre></div>
<p dir="auto">The following table shows parameter values we used for solving pegase and ACTIVSg data.</p>
<table>
<thead>
<tr>
<th>Data</th>
<th>rho_pq</th>
<th>rho_va</th>
<th>scale</th>
<th>obj_scale</th>
</tr>
</thead>
<tbody>
<tr>
<td>1354pegase</td>
<td>1e1</td>
<td>1e3</td>
<td>1e-4</td>
<td>1.0</td>
</tr>
<tr>
<td>2869pegase</td>
<td>1e1</td>
<td>1e3</td>
<td>1e-4</td>
<td>1.0</td>
</tr>
<tr>
<td>9241pegase</td>
<td>5e1</td>
<td>5e3</td>
<td>1e-4</td>
<td>1.0</td>
</tr>
<tr>
<td>13659pegase</td>
<td>5e1</td>
<td>5e3</td>
<td>1e-4</td>
<td>1.0</td>
</tr>
<tr>
<td>ACTIVSg25k</td>
<td>3e3</td>
<td>3e4</td>
<td>1e-5</td>
<td>1.0</td>
</tr>
<tr>
<td>ACTIVSg70k</td>
<td>3e4</td>
<td>3e5</td>
<td>1e-5</td>
<td>2.0</td>
</tr>
</tbody>
</table>
<p dir="auto">We have used the same <code>tight_factor=0.99</code>, <code>outer_iterlim=20</code>, and <code>inner_iterlim=1000</code> for all of the above data.</p>
<h2 dir="auto"><a id="user-content-publications" class="anchor" aria-hidden="true" href="#publications"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Publications</h2>
<ul dir="auto">
<li>Youngdae Kim and Kibaek Kim. "Accelerated Computation and Tracking of AC Optimal Power Flow Solutions using GPUs" arXiv preprint arXiv:2110.06879, 2021</li>
<li>Youngdae Kim, Fran√ßois Pacaud, Kibaek Kim, and Mihai Anitescu. "Leveraging GPU batching for scalable nonlinear programming through massive lagrangian decomposition" arXiv preprint arXiv:2106.14995, 2021</li>
</ul>
<h2 dir="auto"><a id="user-content-acknowledgments" class="anchor" aria-hidden="true" href="#acknowledgments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgments</h2>
<p dir="auto">This research was supported by the Exascale ComputingProject (17-SC-20-SC),  a collaborative effort of the U.S. Department of Energy Office of Science and the National Nuclear Security Administration.
This material is based upon work supported by the U.S. Department of Energy, Office of Science, under contract number DE-AC02-06CH11357.</p>
</article></div>