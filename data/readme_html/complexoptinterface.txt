<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-complexoptinterface" class="anchor" aria-hidden="true" href="#complexoptinterface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ComplexOptInterface</h1>
<p dir="auto"><strong>This package is still in early development, feedback is welcome!</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>Build Status</strong></th>
<th align="center"><strong>Social</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://travis-ci.com/jump-dev/ComplexOptInterface.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/2334084c1a99feec49349c845baa7478e469c5858f9b7268b3d0d54ec44373a3/68747470733a2f2f7472617669732d63692e636f6d2f6a756d702d6465762f436f6d706c65784f7074496e746572666163652e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/jump-dev/ComplexOptInterface.jl.svg?branch=master" style="max-width: 100%;"></a></td>
<td align="center"><a href="https://gitter.im/JuliaOpt/JuMP-dev?utm_source=share-link&amp;utm_medium=link&amp;utm_campaign=share-link" rel="nofollow"><img src="https://camo.githubusercontent.com/5d051ccd113f87e787590cadd1441e0d1a2dc2bec69ccadd59398285555cfa5e/68747470733a2f2f6261646765732e6769747465722e696d2f4a756c69614f70742f4a754d502d6465762e737667" alt="Gitter" data-canonical-src="https://badges.gitter.im/JuliaOpt/JuMP-dev.svg" style="max-width: 100%;"></a></td>
</tr>
<tr>
<td align="center"><a href="http://codecov.io/github/jump-dev/ComplexOptInterface.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/aac62b7f6f1eefd0f422557fe7cfba145f6681be0e16e750dd907ff5b8abb761/687474703a2f2f636f6465636f762e696f2f6769746875622f6a756d702d6465762f436f6d706c65784f7074496e746572666163652e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="Codecov branch" data-canonical-src="http://codecov.io/github/jump-dev/ComplexOptInterface.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></td>
<td align="center"><a href="https://discourse.julialang.org/c/domain/opt" rel="nofollow"><img src="https://camo.githubusercontent.com/84c58cf3e4e5fca55b1789ed5e17eb34a65eb908eaa17b539ce195c5844223f7/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f656e2f612f61662f446973636f757273655f6c6f676f2e706e67" width="64" data-canonical-src="https://upload.wikimedia.org/wikipedia/en/a/af/Discourse_logo.png" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table>
<p dir="auto">An extension of MathOptInterface to complex sets.</p>
<h2 dir="auto"><a id="user-content-how-to-use" class="anchor" aria-hidden="true" href="#how-to-use"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use</h2>
<p dir="auto">Add to the JuMP model the bridges of this package with <code>add_all_bridges</code> and then you can create complex equality constraints and complex hermitian matrices:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP
import ComplexOptInterface
const COI = ComplexOptInterface

model = Model()
COI.add_all_bridges(model)
@variable(model, x in COI.ComplexPlane(), start = 5 + 6im, lower_bound = 1 + 2im, upper_bound = 3 + 4im)
@variable(model, Q[1:2, 1:2] in COI.HermitianPSDCone())
@constraint(model, (1 + 2im) * x + Q[1, 1] + Q[2, 2] * im == 1 + 2im)"><pre><span class="pl-k">using</span> JuMP
<span class="pl-k">import</span> ComplexOptInterface
<span class="pl-k">const</span> COI <span class="pl-k">=</span> ComplexOptInterface

model <span class="pl-k">=</span> <span class="pl-c1">Model</span>()
COI<span class="pl-k">.</span><span class="pl-c1">add_all_bridges</span>(model)
<span class="pl-c1">@variable</span>(model, x <span class="pl-k">in</span> COI<span class="pl-k">.</span><span class="pl-c1">ComplexPlane</span>(), start <span class="pl-k">=</span> <span class="pl-c1">5</span> <span class="pl-k">+</span> <span class="pl-c1">6im</span>, lower_bound <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span>, upper_bound <span class="pl-k">=</span> <span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">4im</span>)
<span class="pl-c1">@variable</span>(model, Q[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>] <span class="pl-k">in</span> COI<span class="pl-k">.</span><span class="pl-c1">HermitianPSDCone</span>())
<span class="pl-c1">@constraint</span>(model, (<span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span>) <span class="pl-k">*</span> x <span class="pl-k">+</span> Q[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">+</span> Q[<span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">*</span> im <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span>)</pre></div>
<h2 dir="auto"><a id="user-content-design-considerations" class="anchor" aria-hidden="true" href="#design-considerations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Design considerations</h2>
<p dir="auto">There are two types of complex sets:</p>
<ol dir="auto">
<li>Some sets have complex entries, i.e. <code>MOI.EqualTo{Complex{Float64}}</code>,</li>
<li>Some sets have real entries even if they model a complex mathematical set, i.e.
<code>HermitianPositiveSemidefiniteConeTriangle</code> where the imaginary part of the
off-diagonal entries are stored in separate output indices.
For instance, <code>[x y+zim; y-zim w]</code> is vectorized as
<code>[x, y, w, z]</code>.</li>
</ol>
<p dir="auto">Sets with complex entries <strong>should not</strong> be used with <code>VariableIndex</code> or <code>VectorOfVariables</code> constraints
as the variables in MathOptInterface are assumed to be real.
Indeed, for instance doing</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x, cx = MOI.add_constrained_variable(model, MOI.EqualTo(1 + 2im))"><pre>x, cx <span class="pl-k">=</span> MOI<span class="pl-k">.</span><span class="pl-c1">add_constrained_variable</span>(model, MOI<span class="pl-k">.</span><span class="pl-c1">EqualTo</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span>))</pre></div>
<p dir="auto">fallbacks to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = MOI.add_variable(model)
cx = MOI.add_constraint(model, x, MOI.EqualTo(1 + 2im))"><pre>x <span class="pl-k">=</span> MOI<span class="pl-k">.</span><span class="pl-c1">add_variable</span>(model)
cx <span class="pl-k">=</span> MOI<span class="pl-k">.</span><span class="pl-c1">add_constraint</span>(model, x, MOI<span class="pl-k">.</span><span class="pl-c1">EqualTo</span>(<span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2im</span>))</pre></div>
<p dir="auto">In the first line, the solvers create a real variable.
Moreover, in the bridge from <code>MOI.ScalarAffineFunction{Complex{T}}</code>-in-<code>EqualTo{Complex{T}}</code>
to <code>ScalarAffineFunction{T}</code>-in-<code>EqualTo{T}</code>, we assume that the variables are real
to split the equality in real and imaginary part.
So in conclusion, complex variables may violate assumptions in MOI so use it at your own risks.
Note that even if you add a <code>MOI.ScalarAffineFunction{Complex{T}}</code>-in-<code>EqualTo{Complex{T}}</code> constraint,
it may be bridged by a slack bridge into a variable constrained in <code>EqualTo{Complex{T}}</code>.
Luckily, this bridge might not be selected but remain causious with sets with complex entries.</p>
</article></div>