<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-jokerjailbreak" class="anchor" aria-hidden="true" href="#jokerjailbreak"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>JokerJailBreak</h1>
<p dir="auto">The purpose of this package is to simulate and play the game Joker Jail Break. Basic documentation for using the package is provided below.</p>
<h1 dir="auto"><a id="user-content-rules" class="anchor" aria-hidden="true" href="#rules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Rules</h1>
<p dir="auto">Joker jail break is a simple card matching game developed by Ramon Huiskamp. The goal is to remove the Joker from the jail cell. As shown below, the Joker is placed the center of a 3 X 3 matrix of card piles which serves as a jail cell. The corners have 3 cards and the other piles have 7 cards. The Joker can breakout once either the top, bottom, left or right pile is depleted. Joker cannot escape from the corners, but cards in those piles can be used strategically.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="resources/game.png"><img src="resources/game.png" style="max-width: 100%;"></a></p>
<p dir="auto">Cards are removed by selecting cards such that the sum of the black and sum of the red cards are equal. In some situations, a valid card selection does not exist. A card from the remaining deck can be placed on the Joker in an attempt to resolve the impasse. However, cards placed on the Joker must ultimately be removed, and a maximum of three cards can be placed on the Joker at any time. The game ends when Joker is free, or no moves are possible. An online version of Joker jail break can be found here: (<a href="https://wcordewiner.github.io/joker-jailbreak/" rel="nofollow">https://wcordewiner.github.io/joker-jailbreak/</a>)</p>
<h1 dir="auto"><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>API</h1>
<p dir="auto">At minimum, the API requires one to define a subtype of <code>AbstractPlayer</code>, and a corresponding <code>decide</code> function. Here is an outline of a player:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct Player &lt;: AbstractPlayer
    # optional fields
end"><pre><span class="pl-k">struct</span> Player <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractPlayer</span>
    <span class="pl-c"><span class="pl-c">#</span> optional fields</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Note that fields can be added as needed. The following code block shows the outline of the <code>decide</code> method, which returns two variables: <code>stop</code> which indicates whether the player stops the game, and <code>indices</code> which are the indices of the selected cards.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function decide(player::Player, board, card_counts, deck_size; kwargs...)
    # intentionally blank
    return stop,indices
end"><pre><span class="pl-k">function</span> <span class="pl-en">decide</span>(player<span class="pl-k">::</span><span class="pl-c1">Player</span>, board, card_counts, deck_size; kwargs<span class="pl-k">...</span>)
    <span class="pl-c"><span class="pl-c">#</span> intentionally blank</span>
    <span class="pl-k">return</span> stop,indices
<span class="pl-k">end</span></pre></div>
<p dir="auto">After defining the player subtype and <code>decide</code> function, the game can be simulated by creating an instance of a game, the player, and passing them to <code>simulate!</code>. A minimal example is provided in the following section.</p>
<p dir="auto">Three other methods in API can be optionally defined. <code>setup</code> allows you to configure the player before starting the game.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function setup!(player::Player, board, card_counts; kwargs...)
    # intentionally blank
    return nothing
end"><pre><span class="pl-k">function</span> <span class="pl-en">setup!</span>(player<span class="pl-k">::</span><span class="pl-c1">Player</span>, board, card_counts; kwargs<span class="pl-k">...</span>)
    <span class="pl-c"><span class="pl-c">#</span> intentionally blank</span>
    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">By default, only the number of rounds and the outcome of the game are collected. However, JokerJailBreak.jl provides two methods for custom data collection during the simulation: <code>update_data_round</code>, which is called after each round, and <code>update_data_end</code> which is called after the game has finished. To define custom data collection, first define a custom data type (e.g., <code>MyData</code>), and define the methods below:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function update_data_round!(game, player, data::MyData, stop; kwargs...)

    return nothing
end"><pre><span class="pl-k">function</span> <span class="pl-en">update_data_round!</span>(game, player, data<span class="pl-k">::</span><span class="pl-c1">MyData</span>, stop; kwargs<span class="pl-k">...</span>)

    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function update_data_end!(game, player, data:MyData, stop; kwargs...)

    return nothing
end"><pre><span class="pl-k">function</span> <span class="pl-en">update_data_end!</span>(game, player, data<span class="pl-k">:</span>MyData, stop; kwargs<span class="pl-k">...</span>)

    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<h1 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h1>
<p dir="auto">The following example illustrates how to develop a simple player. The first step is to use the required libraries.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JokerJailBreak
import JokerJailBreak: AbstractPlayer, decide
using StatsBase
using Random"><pre><span class="pl-k">using</span> JokerJailBreak
<span class="pl-k">import</span> JokerJailBreak<span class="pl-k">:</span> AbstractPlayer, decide
<span class="pl-k">using</span> StatsBase
<span class="pl-k">using</span> Random</pre></div>
<p dir="auto">Next, we will make a subtype of <code>AbstractPlayer</code> called <code>Player</code> so that we can extend the <code>decide</code> function. In practice, fields can be added to a subtype of <code>AbstractPlayer</code>, but it is not necessary for this example.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct Player &lt;: AbstractPlayer

end"><pre><span class="pl-k">struct</span> Player <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractPlayer</span>

<span class="pl-k">end</span></pre></div>
<p dir="auto">Now that we have defined our own subtype of <code>AbstractPlayer</code>, we can define the player's decision logic.
The player will select random pairs of cards until a match is found (e.g., 5 black, 5 red), or 1000 attemps have been made. If no matches are found, the player stops the game. The function <code>decide</code> will return two variables: <code>stop</code> which indicates whether the player stops the game, and <code>indices</code> which are the indices of the selected cards. The function <code>sample</code> from the package <code>StatsBase</code> will be used to sample pairs of card indices without replacement.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function decide(player::Player, board, card_counts, deck_size)
    indices = Int[]
    cnt = 0
    while cnt &lt; 1000 
        cnt += 1
        indices = sample(1:9, 2, replace=false)
        any(i -&gt; board[i] == nothing, indices) ? continue : nothing
        is_zero_sum(board, indices) ? break : nothing
    end
    stop = cnt &lt; 1000 ? false : true 
    cnt == 1000 ? empty!(indices) : nothing
    return stop,indices
end"><pre><span class="pl-k">function</span> <span class="pl-en">decide</span>(player<span class="pl-k">::</span><span class="pl-c1">Player</span>, board, card_counts, deck_size)
    indices <span class="pl-k">=</span> Int[]
    cnt <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> cnt <span class="pl-k">&lt;</span> <span class="pl-c1">1000</span> 
        cnt <span class="pl-k">+=</span> <span class="pl-c1">1</span>
        indices <span class="pl-k">=</span> <span class="pl-c1">sample</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">9</span>, <span class="pl-c1">2</span>, replace<span class="pl-k">=</span><span class="pl-c1">false</span>)
        <span class="pl-c1">any</span>(i <span class="pl-k">-&gt;</span> board[i] <span class="pl-k">==</span> <span class="pl-c1">nothing</span>, indices) <span class="pl-k">?</span> <span class="pl-k">continue</span> <span class="pl-k">:</span> <span class="pl-c1">nothing</span>
        <span class="pl-c1">is_zero_sum</span>(board, indices) <span class="pl-k">?</span> <span class="pl-k">break</span> <span class="pl-k">:</span> <span class="pl-c1">nothing</span>
    <span class="pl-k">end</span>
    stop <span class="pl-k">=</span> cnt <span class="pl-k">&lt;</span> <span class="pl-c1">1000</span> <span class="pl-k">?</span> <span class="pl-c1">false</span> <span class="pl-k">:</span> <span class="pl-c1">true</span> 
    cnt <span class="pl-k">==</span> <span class="pl-c1">1000</span> <span class="pl-k">?</span> <span class="pl-c1">empty!</span>(indices) <span class="pl-k">:</span> <span class="pl-c1">nothing</span>
    <span class="pl-k">return</span> stop,indices
<span class="pl-k">end</span></pre></div>
<p dir="auto">The last steop is to simulate the game with <code>simulate!</code>. The default data object with a round count and outcome indicator (win, not_winnable) will be returned if a custom data type is not passed.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="game = Game()
player = Player()
simulate!(game, player)"><pre>game <span class="pl-k">=</span> <span class="pl-c1">Game</span>()
player <span class="pl-k">=</span> <span class="pl-c1">Player</span>()
<span class="pl-c1">simulate!</span>(game, player)</pre></div>
<p dir="auto">One question you might want to answer is how often does this strategy solve the game? Let's wrap the code block above in a function.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function wrapper(;kwargs...)
    game = Game()
    player = Player()
    return simulate!(game, player; kwargs...)
end"><pre><span class="pl-k">function</span> <span class="pl-en">wrapper</span>(;kwargs<span class="pl-k">...</span>)
    game <span class="pl-k">=</span> <span class="pl-c1">Game</span>()
    player <span class="pl-k">=</span> <span class="pl-c1">Player</span>()
    <span class="pl-k">return</span> <span class="pl-c1">simulate!</span>(game, player; kwargs<span class="pl-k">...</span>)
<span class="pl-k">end</span></pre></div>
<p dir="auto">Now, let's set the seed of the random number generator and repeat the simulation 1,000 times.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Random.seed!(210)
data = map(x -&gt; wrapper(), 1:1000)
mean(x -&gt; x.outcome == :win, data)"><pre>Random<span class="pl-k">.</span><span class="pl-c1">seed!</span>(<span class="pl-c1">210</span>)
data <span class="pl-k">=</span> <span class="pl-c1">map</span>(x <span class="pl-k">-&gt;</span> <span class="pl-c1">wrapper</span>(), <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">1000</span>)
<span class="pl-c1">mean</span>(x <span class="pl-k">-&gt;</span> x<span class="pl-k">.</span>outcome <span class="pl-k">==</span> <span class="pl-c1">:win</span>, data)</pre></div>
<p dir="auto">As expected, the win probability is low: <code>0.002</code>.</p>
</article></div>