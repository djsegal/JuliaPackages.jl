<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-dataiteratorsjl" class="anchor" aria-hidden="true" href="#dataiteratorsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DataIterators.jl</h1>
<p>This small package is a work on progress on providing an iterator over data spread over multiple files.
It is inteded to facilitate training with minibatches, such that the iterator would provide minibatches of
constant size hiding the fact that data are spread.</p>
<p>Contains:</p>
<ul>
<li>FileIterator</li>
<li>InfiniteFileIterator</li>
<li>Iterator2Fun</li>
<li>CircularBuffer</li>
</ul>
<h3><a id="user-content-fileiterator" class="anchor" aria-hidden="true" href="#fileiterator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>FileIterator</h3>
<p>The best is to show a simplified example, in which the files system is simulated by a dictionary</p>
<pre><code>d = Dict("a" =&gt; [1 2 3 4 5], 
		"b" =&gt; [6 7], 
		"c" =&gt; [8 9 10 11])
</code></pre>
<p>and the loading function returns an element from the dictionary</p>
<pre><code>loadfun(f) = d[f]
</code></pre>
<p>The iterator <code>FileIterator(loadfun, files, bs))</code> uses loads data using load function <code>loadfun</code> from files and
outputs batches of size <code>bs</code>. At the moment it is assumed that files is a structure supporting linear indexing
(list of vectors). Furthermore, function <code>nobs</code> from MLDataPattern package is used to calculate number of samples in minibatch.
To concatenate data from two files, the package calls <code>cat(x, y; dims = ndims(x))</code>.</p>
<p>The complete above example is as follows</p>
<pre><code>d = Dict("a" =&gt; [1 2 3 4 5],
  "b" =&gt; [6 7],
  "c" =&gt; [8 9 10 11])
loadfun(f) = d[f]
collect(FileIterator(loadfun, ["a", "b", "c"], 2))
</code></pre>
<p>returns elements</p>
<pre><code>[1 2]
[3 4]
[5 6]
[7 8]
[9 10]
[11]
</code></pre>
<h3><a id="user-content-infinitefileiterator" class="anchor" aria-hidden="true" href="#infinitefileiterator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>InfiniteFileIterator</h3>
<p>Is similar in the spirit to FileIterator except that it provides infinite number of mini-batches. If the data are small and they are loaded in the first round, then the iterator keeps them and sample from them without repetition.</p>
<h3><a id="user-content-circularbuffer" class="anchor" aria-hidden="true" href="#circularbuffer"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CircularBuffer</h3>
<p><code>CircularBuffer(iterator, k)</code> does what its name suggests. Implements cache providing each sample at most k-times. Note that the implementation is not entirely correct at beggining and end.</p>
<h3><a id="user-content-iterator2fun" class="anchor" aria-hidden="true" href="#iterator2fun"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iterator2Fun</h3>
<p>Converts iterator to function call, hiding the state. The approach is not type safe!</p>
<h3><a id="user-content-distributediterator" class="anchor" aria-hidden="true" href="#distributediterator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DistributedIterator</h3>
<p>runs iterators on workers (remote processes) without moving states.
A simple example from taken from tests is below</p>
<pre><code>using Distributed, Test
addprocs(2)
@everywhere begin
 using DataIterators;
 d = Dict("a" =&gt; 10*myid().+[1 2 3 4 5],
         "b" =&gt; 10*myid().+[6 7]);
 loadfun(f) = d[f]
end 

ffl = DistributedIterator(fill(FileIterator(loadfun,["a","b"],3), 2), [2,3])
@testset "remote iterator" begin
	@test all(collect(ffl) .== [[21 22 23], [31 32 33], [24 25 26], [34 35 36], reshape([27], 1, 1), reshape([37],1 ,1), nothing])
end
</code></pre>
<p>** See unit-test for examples **</p>
</article></div>