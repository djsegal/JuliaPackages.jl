<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-hyperboliccrossapproxjl" class="anchor" aria-hidden="true" href="#hyperboliccrossapproxjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>HyperbolicCrossApprox.jl</h1>
<h1 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h1>
<p dir="auto">This package implements a hyperbolic cross sparse-grid method for approximating multivariate continuous functions with Chebyshev polynomials as basis functions.  Flexibility is given over the resulting grid through parameters that govern the maximum number of points along each spatial dimension and the number of layers along each spatial dimension.  The package also allows for isotropic and anisotropic grids.</p>
<p dir="auto">Hyperbolic cross approximation is a sparse-grid alternative to Smolyak's method.  Where existing treatments of the hyperbolic cross method are based on non-equispaced fast Fourier methods, the treatment in this code is based on Chebyshev polynomials with the coefficients in the approximating function constructed using Lagrange interpolation.</p>
<p dir="auto">This package draws on and is related to others I have written, specifically: ChebyshevApprox.jl and SmolyakApprox.jl.</p>
<p dir="auto">To install this package you need to type in the REPL</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(&quot;HyperbolicCrossApprox&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>HyperbolicCrossApprox<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Then the package can be used by typing</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using HyperbolicCrossApprox"><pre><span class="pl-k">using</span> HyperbolicCrossApprox</pre></div>
<h2 dir="auto"><a id="user-content-approximating-grid" class="anchor" aria-hidden="true" href="#approximating-grid"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Approximating grid</h2>
<p dir="auto">The nodes used to form the approximating grid can be computed using either the Chebyshev nodes (points of the first kind), Chebyshev extrema (points of the second kind), the extended Chebyshev nodes, Vertesi nodes, or Legendre nodes, with the approximating grid and the multi-index computed by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="grid, multi_ind = hyperbolic_cross_grid(chebyshev_nodes,d,k,domain)"><pre>grid, multi_ind <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_grid</span>(chebyshev_nodes,d,k,domain)</pre></div>
<p dir="auto">where <code>d</code> is the dimension of the function, <code>k</code> is the number of layers along each dimension, and domain is a 2d-array (2xd) containing the upper and lower bound on each variable.  If domain is not provided, then it is assumed that the variables reside on the [-1,1] interval.  If <code>k</code> is an integer, then an isotropic grid is computed whereas if <code>k</code> is an array of integers with length <code>d</code>, then an anisotropic grid is computed.  For the function above, the number of grid points along each spacial dimension is given by <code>n = 2k+1</code>.  Alternatively, the values for <code>k</code> and <code>n</code> can be provided separately (and hence not linked by <code>n=2k+1</code>) by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="grid, multi_ind = hyperbolic_cross_grid(chebyshev_nodes,d,k,n,domain)"><pre>grid, multi_ind <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_grid</span>(chebyshev_nodes,d,k,n,domain)</pre></div>
<p dir="auto">where <code>n</code> is either an interger or a 1d array of integers.</p>
<p dir="auto">In the functions above, <code>chebyshev_nodes</code> can be replaced with <code>chebyshev_extrema</code>, <code>chebyshev_extended</code>, <code>vertesi_nodes</code>, or <code>legendre_nodes</code>.</p>
<h2 dir="auto"><a id="user-content-polynomial-coefficients" class="anchor" aria-hidden="true" href="#polynomial-coefficients"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Polynomial coefficients</h2>
<p dir="auto">With the grid and multi-index in hand, we can compute the weights, or coefficients in the approximation, according to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="weights = hyperbolic_cross_weights(y,grid,multi_ind,domain)"><pre>weights <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_weights</span>(y,grid,multi_ind,domain)</pre></div>
<p dir="auto">where <code>y</code> is a 1d-array containing the evaluations at each grid point of the function being approximated.  The weights can be computed more efficiently by computing the inverse interpolation matrix (this generally needs to be done only once, outside any loops)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="inv_interp_mat = hyperbolic_cross_inverse_interpolation_matrix(grid,multi_ind,domain)"><pre>inv_interp_mat <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_inverse_interpolation_matrix</span>(grid,multi_ind,domain)</pre></div>
<p dir="auto">with the weights then computed through</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="weights = hyperbolic_cross_weights(y,inv_interp_mat)"><pre>weights <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_weights</span>(y,inv_interp_mat)</pre></div>
<h2 dir="auto"><a id="user-content-interpolation" class="anchor" aria-hidden="true" href="#interpolation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Interpolation</h2>
<p dir="auto">We can evaluate the hyperbolic cross approximation of the function at any point in the domain by</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="y_hat = hyperbolic_cross_evaluate(weights,point,multi_ind,domain)"><pre>y_hat <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_evaluate</span>(weights,point,multi_ind,domain)</pre></div>
<p dir="auto">where <code>point</code> (a 1d-array) is the point in the domain where the approximation is to be evaluated.</p>
<h2 dir="auto"><a id="user-content-derivatives-gradients-and-hessians" class="anchor" aria-hidden="true" href="#derivatives-gradients-and-hessians"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Derivatives, gradients, and hessians</h2>
<p dir="auto">Lastly, the package can also be used to compute derivatives of the approximating function, as per</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="deriv = hyperbolic_cross_derivative(weights,point,multi_ind,domain,pos)"><pre>deriv <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_derivative</span>(weights,point,multi_ind,domain,pos)</pre></div>
<p dir="auto">where <code>pos</code> is an integer reflecting the number of the variable being differentiated with respect to.  The package can compute gradients according to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="gradient = hyperbolic_cross_gradient(weights,point,multi_ind,domain)"><pre>gradient <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_gradient</span>(weights,point,multi_ind,domain)</pre></div>
<p dir="auto">and hessians according to</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="hess = hyperbolic_cross_hessian(weights,point,multi_ind,domain)"><pre>hess <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_hessian</span>(weights,point,multi_ind,domain)</pre></div>
<h2 dir="auto"><a id="user-content-multi-threading" class="anchor" aria-hidden="true" href="#multi-threading"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multi-threading</h2>
<p dir="auto">There are multi-threaded functions to compute the polynomial weights and the interpolation matrix.  These multi-threaded functions are accessed by adding <code>_threaded</code> to the end of the funtion, as per</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="weights = hyperbolic_cross_weights_threaded(y,inv_interp_mat)"><pre>weights <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_weights_threaded</span>(y,inv_interp_mat)</pre></div>
<h2 dir="auto"><a id="user-content-useful-structures" class="anchor" aria-hidden="true" href="#useful-structures"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Useful structures</h2>
<p dir="auto">The key structure to be aware of is the HCApproxPlan, which contains the key information needed to approximate a function.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="d = 3
k = 5
domain = [2.0 2.0 2.0; -2.0 -2.0 -2.0]
grid, mi = hyperbolic_cross_grid(chebyshev_nodes,d,k,domain)
plan = HCApproxPlan(grid,mi,domain)"><pre>d <span class="pl-k">=</span> <span class="pl-c1">3</span>
k <span class="pl-k">=</span> <span class="pl-c1">5</span>
domain <span class="pl-k">=</span> [<span class="pl-c1">2.0</span> <span class="pl-c1">2.0</span> <span class="pl-c1">2.0</span>; <span class="pl-k">-</span><span class="pl-c1">2.0</span> <span class="pl-k">-</span><span class="pl-c1">2.0</span> <span class="pl-k">-</span><span class="pl-c1">2.0</span>]
grid, mi <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_grid</span>(chebyshev_nodes,d,k,domain)
plan <span class="pl-k">=</span> <span class="pl-c1">HCApproxPlan</span>(grid,mi,domain)</pre></div>
<p dir="auto">or</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="plan = hyperbolic_cross_plan(chebyshev_nodes,d,k,n,domain)"><pre>plan <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_plan</span>(chebyshev_nodes,d,k,n,domain)</pre></div>
<p dir="auto">Once the approximation plan has been constructed it can be used to create functions to interpolate and to compute gradients and hessians.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f = hyperbolic_cross_interp(y,plan)
g = hyperbolic_cross_gradient(y,plan)
h = hyperbolic_cross_hessian(y,plan)

point = [1.0, 1.0, 1.0]

f(point)
g(point)
h(point)"><pre>f <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_interp</span>(y,plan)
g <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_gradient</span>(y,plan)
h <span class="pl-k">=</span> <span class="pl-c1">hyperbolic_cross_hessian</span>(y,plan)

point <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>]

<span class="pl-c1">f</span>(point)
<span class="pl-c1">g</span>(point)
<span class="pl-c1">h</span>(point)</pre></div>
<p dir="auto">There are multi-threaded versions of <code>hyperbolic_cross_interp</code>, <code>hyperbolic_cross_gradient</code>, and <code>hyperbolic_cross_hessian</code>.</p>
<h2 dir="auto"><a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related packages</h2>
<ul dir="auto">
<li>ChebyshevApprox.jl</li>
<li>SmolyakApprox.jl</li>
<li>PiecewiseLinearApprox.jl</li>
</ul>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">Some useful references are</p>
<p dir="auto">Dennis, R., (2021), "Using a Hyperbolic Cross to Solve Non-linear Macroeconomic Models", CAMA working paper number 93/2021, Australian National University.</p>
<p dir="auto">Döhler, M., Kunis, S., and D. Potts, (2010), "Nonequispaced Hyperbolic Cross Fast Fourier Transform", <em>SIAM Journal on Numerical Analysis</em>, 47, (6), pp. 4415-4428.</p>
<p dir="auto">Dũng, D., Temlyakov, V., and T. Ullrich, (2018), "Hyperbolic Cross Approximation", <em>Advanced Courses in Mathematics</em>, CRM Barcelona, Centre de Recerca Matemàtica, Birkhäuser.</p>
<p dir="auto">Shen, J., L-L. Wang, (2010), "Sparse Spectral Approximations of High-Dimensional Problems Based on Hyperbolic Cross" <em>SIAM Journal on Numerical Analysis</em>, 48, (3), pp. 1087-1109.</p>
</article></div>