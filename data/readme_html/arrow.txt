<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-deprecation-notice-" class="anchor" aria-hidden="true" href="#deprecation-notice-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><g-emoji class="g-emoji" alias="no_entry" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26d4.png">⛔</g-emoji>Deprecation Notice <g-emoji class="g-emoji" alias="no_entry" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26d4.png">⛔</g-emoji></h1>
<p dir="auto">This package is deprecated in favor of
<a href="https://github.com/JuliaData/Arrow.jl">JuliaData/Arrow.jl</a>.</p>
<p dir="auto">As of writing, this package is still used by Feather.jl which reads and writes legacy
feather v1 files.  However, as Feather v1 is deprecated in favor of Feather v2 which is
implemented by JuliaData/Arrow.jl, it is unlikely that Feather.jl will be maintained in
the future.  We recommend using either Feather.jl or pyarrow to convert your data to the
latest feather format.</p>
<h1 dir="auto"><a id="user-content-arrow" class="anchor" aria-hidden="true" href="#arrow"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Arrow</h1>
<p dir="auto"><a href="https://travis-ci.org/ExpandingMan/Arrow.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/cbd3bb1e9979cd2d5beb98627837391c6785dc375eca9ed031291d3f755826bb/68747470733a2f2f7472617669732d63692e6f72672f457870616e64696e674d616e2f4172726f772e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/ExpandingMan/Arrow.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/ExpandingMan/Arrow.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/2565d87057102a47cbc41d3715d31d1c789a8277dcba0f76fd4772f7cbcb045b/687474703a2f2f636f6465636f762e696f2f6769746875622f457870616e64696e674d616e2f4172726f772e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/ExpandingMan/Arrow.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">This is a pure Julia implementation of the <a href="https://arrow.apache.org" rel="nofollow">Apache Arrow</a> data standard.  This package provides Julia <code>AbstractVector</code> objects for
referencing data that conforms to the Arrow standard.  This allows users to seamlessly interface Arrow formatted data with a great deal of existing Julia code.</p>
<p dir="auto">Please see this <a href="https://arrow.apache.org/docs/memory_layout.html" rel="nofollow">document</a> for a description of the Arrow memory layout.</p>
<p dir="auto"><em><strong>WARNING</strong></em> As of right now this package uses Julia <code>Ptr</code> (pointer) objects and "unsafe" methods.  This is for performance reasons.  It should in principle be
possible to make this package completely safe with little to no loss in performance, but we are waiting on some performance improvements in <code>Base</code>.  While
Arrow.jl has been tested and should be safe with proper usage, it is up to the user to make sure that their Arrow.jl objects reference the appropriate locations
in data.  If the user, for example, uses an Arrow.jl object to reference data past the end of an array, the resulting program will segfault!</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Just do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import Pkg; Pkg.add(&quot;Arrow&quot;)"><pre><span class="pl-k">import</span> Pkg; Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>Arrow<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Arrow only has <code>CategoricalArrays</code> as a dependency (and <code>Missings</code> on 0.6).</p>
<h2 dir="auto"><a id="user-content-arrowvector-objects" class="anchor" aria-hidden="true" href="#arrowvector-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>ArrowVector</code> Objects</h2>
<p dir="auto">The <code>Arrow</code> package exposes several <code>ArrowVector{J} &lt;: AbstractVector{J}</code> objects.  These provide an interface to arrow formatted data as well as providing
methods to convert Julia objects to the Arrow data format.  The simplest of these is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Primitive{J} &lt;: ArrowVector{J}"><pre>Primitive{J} <span class="pl-k">&lt;:</span> <span class="pl-c1">ArrowVector{J}</span></pre></div>
<p dir="auto">This object maintains a reference to a data buffer (a <code>Vector{UInt8}</code>) and describes and contiguous subset of it.  It will automatically convert the underlying
data to the type <code>J</code> on demand.  The <code>Primitive</code> type can only describe bits type elements (i.e. types for which <code>isbits</code> is true, in particular not strings).  In the
following example we create a <code>Primitive</code> to address a subset of a buffer</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="data = [0, 2, 3, 5, 7, 0] # this will be the underlying data from which we create our buffer
buff = reinterpret(UInt8, data) # in this simple case the Arrow format and Julia's in-memory format coincide
p = Primitive{Int}(buff, 9, 4) # arguments are: buffer, start location, length

p[1] # returns 2
p[2:3] # returns the (non-arrow) Vector [3,5]
p[:] # returns the (non-arrow) Vector [2,3,5,7]

p[2] = 999 # assignment is supported for AbstractPrimitive types. this change is reflected in buff and data


q = Primitive([2,3,5,7]) # if we didn't already have a buffer we needed to reference, we can create one like this
q = arrowformat([2,3,5,7]) # the arrowformat function automatically determines the appropriate ArrowVector for the provided array
rawvalues(q) # this returns the created buffer as a Vector{UInt8}"><pre>data <span class="pl-k">=</span> [<span class="pl-c1">0</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>, <span class="pl-c1">7</span>, <span class="pl-c1">0</span>] <span class="pl-c"><span class="pl-c">#</span> this will be the underlying data from which we create our buffer</span>
buff <span class="pl-k">=</span> <span class="pl-c1">reinterpret</span>(UInt8, data) <span class="pl-c"><span class="pl-c">#</span> in this simple case the Arrow format and Julia's in-memory format coincide</span>
p <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{Int}</span>(buff, <span class="pl-c1">9</span>, <span class="pl-c1">4</span>) <span class="pl-c"><span class="pl-c">#</span> arguments are: buffer, start location, length</span>

p[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> returns 2</span>
p[<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">3</span>] <span class="pl-c"><span class="pl-c">#</span> returns the (non-arrow) Vector [3,5]</span>
p[:] <span class="pl-c"><span class="pl-c">#</span> returns the (non-arrow) Vector [2,3,5,7]</span>

p[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">999</span> <span class="pl-c"><span class="pl-c">#</span> assignment is supported for AbstractPrimitive types. this change is reflected in buff and data</span>


q <span class="pl-k">=</span> <span class="pl-c1">Primitive</span>([<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>]) <span class="pl-c"><span class="pl-c">#</span> if we didn't already have a buffer we needed to reference, we can create one like this</span>
q <span class="pl-k">=</span> <span class="pl-c1">arrowformat</span>([<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>]) <span class="pl-c"><span class="pl-c">#</span> the arrowformat function automatically determines the appropriate ArrowVector for the provided array</span>
<span class="pl-c1">rawvalues</span>(q) <span class="pl-c"><span class="pl-c">#</span> this returns the created buffer as a Vector{UInt8}</span></pre></div>
<p dir="auto">Here we see that indexing an <code>ArrowVector</code> returns ordinary Julia arrays containing the data stored in the Arrow buffer.  All other <code>ArrowVector</code> objects are
built out of combinations of <code>Primitive</code>s.</p>
<p dir="auto">Enter <code>?Primitive</code> in the REPL for a full list of constructors.</p>
<p dir="auto"><em><strong>Note:</strong></em> In what follows we show explicit methods for constructing each <code>ArrowVector</code> type from a raw data buffer.  This can become a bit confusing where
there are many sub-buffer locations to keep track of, so it is strongly suggested that you make use of the <code>Locate</code> interface described in the next section.</p>
<h3 dir="auto"><a id="user-content-the-nullableprimitive-type" class="anchor" aria-hidden="true" href="#the-nullableprimitive-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>NullablePrimitive</code> Type</h3>
<p dir="auto">The Arrow format also supports arrays with bits type elements that may be null.  For these we provide the <code>NullablePrimitive{J} &lt;: AbstractVector{Union{J,Missing}}</code> type.  Under the hood the
<code>NullablePrimitive</code> type is a pair of <code>Primitive</code>s: one references a <code>Primitive{UInt8}</code> bit mask describing which elements of the <code>NullablePrimitive</code> are null and the
other references the underlying data.  In the following example we create a <code>NullablePrimitive</code> from an existing buffer</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buff = [[0x0d]; reinterpret(UInt8, [2.0, 3.0, 5.0, 7.0])]  # bits(0x0d) == &quot;00001101&quot;
p = NullablePrimitive{Float64}(buff, 1, 2, 4) # arguments are: buffer, bitmask location, values location, length

p[1] # returns 2.0
p[2] # returns missing
p[1:4] # returns [2.0, missing, 5.0, 7.0]

p[2] = 3.0  # assignment also supported for NullablePrimitive, the change will be reflected in buff


q = NullablePrimitive([2.0,missing,5.0,7.0]) # if we didn't already have a buffer we needed to reference, we can create one
# the above will create seperate buffers for the bit mask and values. to create a contiguous buffer containing all we can do
q = NullablePrimitive(Array, [2.0,missing,5.0,7.0])
q = arrowformat([2.0,missing,5.0,7.0]) # you can also use arrowformat to automatically determine the ArrowVector type
rawvalues(bitmask(q)) # returns [0x0d]"><pre>buff <span class="pl-k">=</span> [[<span class="pl-c1">0x0d</span>]; <span class="pl-c1">reinterpret</span>(UInt8, [<span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span>, <span class="pl-c1">5.0</span>, <span class="pl-c1">7.0</span>])]  <span class="pl-c"><span class="pl-c">#</span> bits(0x0d) == "00001101"</span>
p <span class="pl-k">=</span> <span class="pl-c1">NullablePrimitive</span><span class="pl-c1">{Float64}</span>(buff, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>) <span class="pl-c"><span class="pl-c">#</span> arguments are: buffer, bitmask location, values location, length</span>

p[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> returns 2.0</span>
p[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> returns missing</span>
p[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span>] <span class="pl-c"><span class="pl-c">#</span> returns [2.0, missing, 5.0, 7.0]</span>

p[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">3.0</span>  <span class="pl-c"><span class="pl-c">#</span> assignment also supported for NullablePrimitive, the change will be reflected in buff</span>


q <span class="pl-k">=</span> <span class="pl-c1">NullablePrimitive</span>([<span class="pl-c1">2.0</span>,<span class="pl-c1">missing</span>,<span class="pl-c1">5.0</span>,<span class="pl-c1">7.0</span>]) <span class="pl-c"><span class="pl-c">#</span> if we didn't already have a buffer we needed to reference, we can create one</span>
<span class="pl-c"><span class="pl-c">#</span> the above will create seperate buffers for the bit mask and values. to create a contiguous buffer containing all we can do</span>
q <span class="pl-k">=</span> <span class="pl-c1">NullablePrimitive</span>(Array, [<span class="pl-c1">2.0</span>,<span class="pl-c1">missing</span>,<span class="pl-c1">5.0</span>,<span class="pl-c1">7.0</span>])
q <span class="pl-k">=</span> <span class="pl-c1">arrowformat</span>([<span class="pl-c1">2.0</span>,<span class="pl-c1">missing</span>,<span class="pl-c1">5.0</span>,<span class="pl-c1">7.0</span>]) <span class="pl-c"><span class="pl-c">#</span> you can also use arrowformat to automatically determine the ArrowVector type</span>
<span class="pl-c1">rawvalues</span>(<span class="pl-c1">bitmask</span>(q)) <span class="pl-c"><span class="pl-c">#</span> returns [0x0d]</span></pre></div>
<p dir="auto">Enter <code>?NullablePrimitive</code> in the REPL for a full list of constructors.</p>
<h3 dir="auto"><a id="user-content-the-list-type" class="anchor" aria-hidden="true" href="#the-list-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>List</code> Type</h3>
<p dir="auto">The underlying dataformat for arbitrary length objects such as strings is more complicated, so these objects require a dedicated type.  For these we provide
<code>List{J} &lt;: AbstractVector{J}</code>.  As well as containing the values contained by strings, these objects contain "offsets" for describing how long each string
should be.  The arrow format suggests that these offsets are <code>Int32</code>s and that there are <code>length(l)+1</code> of them.  For example</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="offs = reinterpret(UInt8, Int32[0,3,5,7])
vals = convert(Vector{UInt8}, &quot;abcdefg&quot;)
buff = [offs; vals]
# type parameters: List return type, offsets type (must be &lt;:Integer)
l = List{String,Int32}(buff, 1, length(offs)+1, 3, UInt8, length(vals)) # arguments are: buffer, offsets location, values location, length of List, value type, values length

# alternatively we can construct the values separately
v = Primitive{UInt8}(buff, length(offs)+1, length(vals))
l = List{String,Int32}(buff, 1, 3, v) # arguments are: buffer, offset location, length, values primitive

# or you can create each piece individually
o = Primitive{Int32}(buff, 1, 4)  # note that the Int32 type is required for offsets by the arrow format
v = Primitive{UInt8}(buff, length(offs)+1, length(vals))
l = List{String}(o, v)

l[1] # returns &quot;abc&quot;
l[2] # returns &quot;de&quot;
l[3] # returns &quot;fg&quot;
l[1:3] # returns a normal Vector{String} (copies data!)

l[1] = &quot;a&quot;  # ERROR: assignments are not currently supported for list types


m = List([&quot;abc&quot;, &quot;de&quot;, &quot;fg&quot;]) # just as in the other cases, you can create your own data
m = List(Array, [&quot;abc&quot;, &quot;de&quot;, &quot;fg&quot;]) # you can also require it all to be in a contiguous buffer
m = arrowformat([&quot;abc&quot;, &quot;de&quot;, &quot;fg&quot;]) # as always arrowformat automatically determines the ArrowVector type
rawvalues(offsets(m)) # returns reinterpret(UInt8, [0,3,5,7])
rawvalues(values(m)) # returns convert(Vector{UInt8}, &quot;abcdefg&quot;)"><pre>offs <span class="pl-k">=</span> <span class="pl-c1">reinterpret</span>(UInt8, Int32[<span class="pl-c1">0</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>])
vals <span class="pl-k">=</span> <span class="pl-c1">convert</span>(Vector{UInt8}, <span class="pl-s"><span class="pl-pds">"</span>abcdefg<span class="pl-pds">"</span></span>)
buff <span class="pl-k">=</span> [offs; vals]
<span class="pl-c"><span class="pl-c">#</span> type parameters: List return type, offsets type (must be &lt;:Integer)</span>
l <span class="pl-k">=</span> <span class="pl-c1">List</span><span class="pl-c1">{String,Int32}</span>(buff, <span class="pl-c1">1</span>, <span class="pl-c1">length</span>(offs)<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-c1">3</span>, UInt8, <span class="pl-c1">length</span>(vals)) <span class="pl-c"><span class="pl-c">#</span> arguments are: buffer, offsets location, values location, length of List, value type, values length</span>

<span class="pl-c"><span class="pl-c">#</span> alternatively we can construct the values separately</span>
v <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{UInt8}</span>(buff, <span class="pl-c1">length</span>(offs)<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-c1">length</span>(vals))
l <span class="pl-k">=</span> <span class="pl-c1">List</span><span class="pl-c1">{String,Int32}</span>(buff, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, v) <span class="pl-c"><span class="pl-c">#</span> arguments are: buffer, offset location, length, values primitive</span>

<span class="pl-c"><span class="pl-c">#</span> or you can create each piece individually</span>
o <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{Int32}</span>(buff, <span class="pl-c1">1</span>, <span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> note that the Int32 type is required for offsets by the arrow format</span>
v <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{UInt8}</span>(buff, <span class="pl-c1">length</span>(offs)<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-c1">length</span>(vals))
l <span class="pl-k">=</span> <span class="pl-c1">List</span><span class="pl-c1">{String}</span>(o, v)

l[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> returns "abc"</span>
l[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> returns "de"</span>
l[<span class="pl-c1">3</span>] <span class="pl-c"><span class="pl-c">#</span> returns "fg"</span>
l[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>] <span class="pl-c"><span class="pl-c">#</span> returns a normal Vector{String} (copies data!)</span>

l[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>  <span class="pl-c"><span class="pl-c">#</span> ERROR: assignments are not currently supported for list types</span>


m <span class="pl-k">=</span> <span class="pl-c1">List</span>([<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>de<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>fg<span class="pl-pds">"</span></span>]) <span class="pl-c"><span class="pl-c">#</span> just as in the other cases, you can create your own data</span>
m <span class="pl-k">=</span> <span class="pl-c1">List</span>(Array, [<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>de<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>fg<span class="pl-pds">"</span></span>]) <span class="pl-c"><span class="pl-c">#</span> you can also require it all to be in a contiguous buffer</span>
m <span class="pl-k">=</span> <span class="pl-c1">arrowformat</span>([<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>de<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>fg<span class="pl-pds">"</span></span>]) <span class="pl-c"><span class="pl-c">#</span> as always arrowformat automatically determines the ArrowVector type</span>
<span class="pl-c1">rawvalues</span>(<span class="pl-c1">offsets</span>(m)) <span class="pl-c"><span class="pl-c">#</span> returns reinterpret(UInt8, [0,3,5,7])</span>
<span class="pl-c1">rawvalues</span>(<span class="pl-c1">values</span>(m)) <span class="pl-c"><span class="pl-c">#</span> returns convert(Vector{UInt8}, "abcdefg")</span></pre></div>
<p dir="auto">Note that <code>List{J}</code> and <code>NullableList{J}</code> use the constructor <code>J(::AbstractVector{C})</code> where <code>C</code> is the values type (in the above example <code>UInt8</code>)</p>
<p dir="auto"><em><strong>WARNING:</strong></em> Currently the values of the offsets themselves are not bounds-checked for performance reasons.  This means you have to be extra sure that your
offsets are properly constructed.  It is recommended that you always use <code>arrowformat</code>, <code>List</code>, or <code>offsets</code> to construct offsets, this should not be done
manually.</p>
<p dir="auto">Enter <code>?List</code> in the REPL for a full list of constructors.</p>
<h3 dir="auto"><a id="user-content-the-nullablelist-type" class="anchor" aria-hidden="true" href="#the-nullablelist-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>NullableList</code> Type</h3>
<p dir="auto">Next we have the <code>NullableList{J} &lt;: AbstractVector{Union{J,Missing}}</code> type.  <code>NullableList</code> is to <code>List</code> as <code>NullablePrimitive</code> is to <code>Primitive</code>.  In addition
to offsets and values, it also contains a bit mask describing which elements are null.  By now you can probably predict what the example will look like</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="bmask = [0x05] # bits(0x05) == &quot;00000101&quot;
offs = reinterpret(UInt8, Int32[0,3,5,7])
vals = convert(Vector{UInt8}, &quot;abcdefg&quot;)
buff = [bmask; offs; vals]
l = NullableList{String,Int32}(buff, 1, 2, length(offs)+2, 3, UInt8, length(vals))
# arguments above are: buffer, bit mask location, offsets location, values location, list length, values type, values length

# again you can also provide each piece separately
b = Primitive{UInt8}(buff, 1, 1)  # required to have eltype UInt8
o = Primitive{Int32}(buff, 2, 4)  # required to have eltype Int32
v = Primitive{UInt8}(buff, length(offs)+2, length(vals))
l = NullableList{String,Int32}(b, o, v)

l[1] # returns &quot;abc&quot;
l[2] # returns missing
l[3] # returns &quot;fg&quot;

l[2] = &quot;de&quot;  # ERROR assignments not currently supported for list types


# you can also create lists of Primitives, though this may involve copying
l = NullableList{Primitive{UInt8},Int32}(b, o, v)


# by now all the ways of creating this from our own data should be familiar
m = NullableList([&quot;abc&quot;, missing, &quot;fg&quot;])
m = NullableList(Array, [&quot;abc&quot;, missing, &quot;fg&quot;])
m = arrowformat([&quot;abc&quot;, missing, &quot;fg&quot;])"><pre>bmask <span class="pl-k">=</span> [<span class="pl-c1">0x05</span>] <span class="pl-c"><span class="pl-c">#</span> bits(0x05) == "00000101"</span>
offs <span class="pl-k">=</span> <span class="pl-c1">reinterpret</span>(UInt8, Int32[<span class="pl-c1">0</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>])
vals <span class="pl-k">=</span> <span class="pl-c1">convert</span>(Vector{UInt8}, <span class="pl-s"><span class="pl-pds">"</span>abcdefg<span class="pl-pds">"</span></span>)
buff <span class="pl-k">=</span> [bmask; offs; vals]
l <span class="pl-k">=</span> <span class="pl-c1">NullableList</span><span class="pl-c1">{String,Int32}</span>(buff, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">length</span>(offs)<span class="pl-k">+</span><span class="pl-c1">2</span>, <span class="pl-c1">3</span>, UInt8, <span class="pl-c1">length</span>(vals))
<span class="pl-c"><span class="pl-c">#</span> arguments above are: buffer, bit mask location, offsets location, values location, list length, values type, values length</span>

<span class="pl-c"><span class="pl-c">#</span> again you can also provide each piece separately</span>
b <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{UInt8}</span>(buff, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)  <span class="pl-c"><span class="pl-c">#</span> required to have eltype UInt8</span>
o <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{Int32}</span>(buff, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> required to have eltype Int32</span>
v <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{UInt8}</span>(buff, <span class="pl-c1">length</span>(offs)<span class="pl-k">+</span><span class="pl-c1">2</span>, <span class="pl-c1">length</span>(vals))
l <span class="pl-k">=</span> <span class="pl-c1">NullableList</span><span class="pl-c1">{String,Int32}</span>(b, o, v)

l[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> returns "abc"</span>
l[<span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span> returns missing</span>
l[<span class="pl-c1">3</span>] <span class="pl-c"><span class="pl-c">#</span> returns "fg"</span>

l[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>de<span class="pl-pds">"</span></span>  <span class="pl-c"><span class="pl-c">#</span> ERROR assignments not currently supported for list types</span>


<span class="pl-c"><span class="pl-c">#</span> you can also create lists of Primitives, though this may involve copying</span>
l <span class="pl-k">=</span> <span class="pl-c1">NullableList</span><span class="pl-c1">{Primitive{UInt8},Int32}</span>(b, o, v)


<span class="pl-c"><span class="pl-c">#</span> by now all the ways of creating this from our own data should be familiar</span>
m <span class="pl-k">=</span> <span class="pl-c1">NullableList</span>([<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">missing</span>, <span class="pl-s"><span class="pl-pds">"</span>fg<span class="pl-pds">"</span></span>])
m <span class="pl-k">=</span> <span class="pl-c1">NullableList</span>(Array, [<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">missing</span>, <span class="pl-s"><span class="pl-pds">"</span>fg<span class="pl-pds">"</span></span>])
m <span class="pl-k">=</span> <span class="pl-c1">arrowformat</span>([<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, <span class="pl-c1">missing</span>, <span class="pl-s"><span class="pl-pds">"</span>fg<span class="pl-pds">"</span></span>])</pre></div>
<p dir="auto">Enter <code>?NullableList</code> in the REPL for a full list of constructors.</p>
<h3 dir="auto"><a id="user-content-the-dictencoding-type" class="anchor" aria-hidden="true" href="#the-dictencoding-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>DictEncoding</code> Type</h3>
<p dir="auto">The arrow format also supports dictionary encoding of arrays.  What this means is simply that instead of one array, there are two, a "short" array containing a
view values, and a "long" array which contains pointers to those values (required by the Arrow standard to be <code>Int32</code>).  This provides a way of compressing
arrays in which a relatively small number of values are repeated in large numbers.  Arrow.jl uses the Julia package
<a href="https://github.com/JuliaData/CategoricalArrays.jl">CategoricalArrays.jl</a> to support this functionality.  <code>CategoricalArray</code>s will be dictionary encoded by
default when converted to Arrow array objects.  One aspect of this that may seem confusing is that references are required to be 0-based indices, which is
contrary to the Julia 1-based approach we've used for everything else.  In practice this shouldn't matter much: references do not need to be constructed
manually.  See the following</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# in most real cases these would be constructed from data in one of the ways described above
refs = Primitive{Int32}([0, 1, 2, 0, 1, 3])
vals = List([&quot;fire&quot;, &quot;walk&quot;, &quot;with&quot;, &quot;me&quot;])
A = DictEncoding(refs, vals)

A[1] # returns &quot;fire&quot;
A[5] # return &quot;walk&quot;
A[[1,2,3,6]] # returns [&quot;fire&quot;, &quot;walk&quot;, &quot;with&quot;, &quot;me&quot;]


# you can also create your own from Julia data
B = DictEncoding([&quot;fire&quot;, &quot;walk&quot;, &quot;with&quot;, &quot;me&quot;])  # in this case there is no benefit to DictEncoding over List
# arrowformat will automatically convert any CategoricalArray object to an Arrow formatted DictEncoding
B = arrowformat(categorical([&quot;fire&quot;, &quot;walk&quot;, &quot;with&quot;, &quot;me&quot;]))"><pre><span class="pl-c"><span class="pl-c">#</span> in most real cases these would be constructed from data in one of the ways described above</span>
refs <span class="pl-k">=</span> <span class="pl-c1">Primitive</span><span class="pl-c1">{Int32}</span>([<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>])
vals <span class="pl-k">=</span> <span class="pl-c1">List</span>([<span class="pl-s"><span class="pl-pds">"</span>fire<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>walk<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>with<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>me<span class="pl-pds">"</span></span>])
A <span class="pl-k">=</span> <span class="pl-c1">DictEncoding</span>(refs, vals)

A[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> returns "fire"</span>
A[<span class="pl-c1">5</span>] <span class="pl-c"><span class="pl-c">#</span> return "walk"</span>
A[[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">6</span>]] <span class="pl-c"><span class="pl-c">#</span> returns ["fire", "walk", "with", "me"]</span>


<span class="pl-c"><span class="pl-c">#</span> you can also create your own from Julia data</span>
B <span class="pl-k">=</span> <span class="pl-c1">DictEncoding</span>([<span class="pl-s"><span class="pl-pds">"</span>fire<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>walk<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>with<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>me<span class="pl-pds">"</span></span>])  <span class="pl-c"><span class="pl-c">#</span> in this case there is no benefit to DictEncoding over List</span>
<span class="pl-c"><span class="pl-c">#</span> arrowformat will automatically convert any CategoricalArray object to an Arrow formatted DictEncoding</span>
B <span class="pl-k">=</span> <span class="pl-c1">arrowformat</span>(<span class="pl-c1">categorical</span>([<span class="pl-s"><span class="pl-pds">"</span>fire<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>walk<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>with<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>me<span class="pl-pds">"</span></span>]))</pre></div>
<p dir="auto">Note that indexing a <code>DictEncoding{T}</code> object will return objects of type <code>T</code> or <code>Vector{T}</code>.  The only exception is when indexing with a <code>:</code>, <code>A[:]</code>, in which
case a <code>CategoricalArray</code> will be returned (equivalently, this can be done with <code>categorical(A)</code>.  In order to retrieve slices as <code>CategoricalArray</code>, one should
use the <code>categorical</code> function, e.g. <code>categorical(A, slice)</code>.</p>
<h3 dir="auto"><a id="user-content-the-bitprimitive-and-nullablebitprimitive-types" class="anchor" aria-hidden="true" href="#the-bitprimitive-and-nullablebitprimitive-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>BitPrimitive</code> and <code>NullableBitPrimitive</code> Types</h3>
<p dir="auto">Because the Arrow format specifies that <code>Bool</code>s should be stored as single bits, a special type is required to store Arrow formatted <code>Bool</code> data.  These are
analogous to the Julia <code>BitVector</code> object.  Note that there is nothing stopping you from serializing Julia <code>Bool</code> (which are 8-bit), but these will not in
general be readable outside of Julia.  <code>arrowformat</code> will automatically convert <code>AbstractVector{Bool}</code> and <code>AbstractVector{Union{Bool,Missing}}</code> to
<code>BitPrimitive</code> and <code>NullableBitPrimitive</code> respectively.  These types also provide the usual constructors as seen for the other types above.</p>
<h2 dir="auto"><a id="user-content-serializing-julia-data" class="anchor" aria-hidden="true" href="#serializing-julia-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Serializing Julia Data</h2>
<p dir="auto">Nothing is stopping you from storing Julia bits-type data that is not necessarily specified by the Arrow format.  For example, a <code>Primitive{Complex128}</code> will
work just as expected.  <code>ArrowVector</code> objects were deliberately designed so that the way they construct their output depends <em>only</em> on their type parameter.
While <code>arrowformat</code> will pick the appropriate <code>ArrowVector</code> for Arrow formatting data, there are no "hidden conversions" happening under the hood: the type
parameter of your <code>ArrowVector</code> object is what you get.  You can therefore serialize any type for which <code>isbits</code> is true.  In principle you can also serialize
more complicated types using <code>List</code>s.  The only caveat is that any type not explicitly described in the Arrow standard will not in general be readable outside
of Julia.</p>
<h2 dir="auto"><a id="user-content-the-locate-interface" class="anchor" aria-hidden="true" href="#the-locate-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>Locate</code> Interface</h2>
<p dir="auto">Given a <code>Vector{UInt8}</code> locating your data objects can be rather pedantic, and the last thing you want to do is point your <code>ArrowVector</code> objects to the wrong
memory locations, as this will lead to scary undefined behavior.  Arrow provides an interface that will make this significantly easier provided your metadata is
sufficiently well organized (which it always should be).  This interface will also check to make sure the locations you specify have proper alignment (still
does not guarantee correctness!!).  The idea here is to create Julia <code>struct</code>s which somehow represent the metadata of the various objects you want to access.
In the following, assume you have defined</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct ObjMetadata
    # whatever is needed to locate objects and determine their types goes here. You can also use type parameters if you want
end"><pre><span class="pl-k">struct</span> ObjMetadata
    <span class="pl-c"><span class="pl-c">#</span> whatever is needed to locate objects and determine their types goes here. You can also use type parameters if you want</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">You are not limited to only having one such object, you can have arbitrarily many.  Once you define the appropriate methods (described below), all you need to
do is call</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="locate(data, T, obj)
# data is the data buffer; T is the return type of the container being constructed; obj is the ObjMetadata"><pre><span class="pl-c1">locate</span>(data, T, obj)
<span class="pl-c"><span class="pl-c">#</span> data is the data buffer; T is the return type of the container being constructed; obj is the ObjMetadata</span></pre></div>
<p dir="auto">This will automatically create the <code>ArrowVector</code> object that represents your data.
The type parameter you provide specifies the return type, for example you might construct a <code>List</code> with <code>locate(data, String, obj)</code> or a <code>NullableBitPrimitive</code>
with <code>locate(data, Union{Bool,Missing}, obj)</code>.</p>
<h3 dir="auto"><a id="user-content-minimal-interface" class="anchor" aria-hidden="true" href="#minimal-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Minimal Interface</h3>
<p dir="auto">The minimal way of implementing the locate interface requires defining some of the following methods</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Locate.length(obj::ObjMetadata) = # the length (in number of elements) of the ArrowVector
Locate.values(obj::ObjMetadata) = # location of values (i.e. return value data; char data for Lists)
Locate.valueslength(obj::ObjMetadata) = # the length of the values sub-buffer (in number of elements); not needed for Primitives, only Lists
Locate.bitmask(obj::ObjMetadata) = # location of null bitmask
Locate.offsets(obj::ObjMetadata) = # location of offsets buffer"><pre>Locate<span class="pl-k">.</span><span class="pl-en">length</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span> the length (in number of elements) of the ArrowVector</span>
Locate<span class="pl-k">.</span><span class="pl-en">values</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span> location of values (i.e. return value data; char data for Lists)</span>
Locate<span class="pl-k">.</span><span class="pl-en">valueslength</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span> the length of the values sub-buffer (in number of elements); not needed for Primitives, only Lists</span>
Locate<span class="pl-k">.</span><span class="pl-en">bitmask</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span> location of null bitmask</span>
Locate<span class="pl-k">.</span><span class="pl-en">offsets</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span> location of offsets buffer</span></pre></div>
<p dir="auto">Of course, you may only need to define a subset of these.  For example, if all you want are <code>Primitive</code>s, you need only define <code>Locate.length</code> and
<code>Locate.values</code>.  If you never need lists, you needn't define <code>Locate.valueslength</code> or <code>Locate.offsets</code>.</p>
<h3 dir="auto"><a id="user-content-overriding-defaults" class="anchor" aria-hidden="true" href="#overriding-defaults"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Overriding Defaults</h3>
<p dir="auto">The above interface may not be adequate for all purposes.  For example, if you only define the methods listed above, the offsets type will always default to
<code>Int32</code> (the Arrow format standard).  Furthermore, the type of <code>ArrowVector</code> will be determined by the desired return value (i.e. <code>Primitive</code> for bits-types,
<code>List</code> for strings, <code>NullablePrimitive</code> for <code>Union{T,Missing}</code> where <code>T</code> is a bits-type, etc.)  To override these defaults you can use more detailed methods:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# value data can be specified by defining the Locate.Values methods
# T is the value data type, but you may not need it because the overall container return type will override it
Locate.Values{T}(obj::ObjMetadata) = Locate.Values{T}(Locate.values(obj), Locate.valueslength(obj))

# you need a slightly different Values constructor for List values
# here T is the List return type so you can use it if you need to, but you may not
Locate.Values(::Type{T}, obj::ObjMetadata) where T = Locate.Values{UInt8}(Locate.values(obj), Locate.valueslength(obj))

# there's not really a reason to define Locate.Bitmask if you defined Locate.bitmask, but it's there
Locate.Bitmask(obj::ObjMetadata) = Locate.Bitmask(Locate.bitmask(obj))

# you can use Locate.Offsets to override the default offset type of Int32
Locate.Offsets(obj::ObjMetadata) = Locate.Offsets{Int64}(Locate.offsets(obj))

# as we described, you can also override the default container types, but this is not recommended
# it may be useful for custom types, but remember these won't in general be usable outside of Julia
Locate.containertype(::Type{CustomType}, obj::ObjMetadata) = NullablePrimitive # returned value should have no type paramters"><pre><span class="pl-c"><span class="pl-c">#</span> value data can be specified by defining the Locate.Values methods</span>
<span class="pl-c"><span class="pl-c">#</span> T is the value data type, but you may not need it because the overall container return type will override it</span>
Locate<span class="pl-k">.</span><span class="pl-en">Values</span><span class="pl-c1">{T}</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> Locate<span class="pl-k">.</span><span class="pl-c1">Values</span><span class="pl-c1">{T}</span>(Locate<span class="pl-k">.</span><span class="pl-c1">values</span>(obj), Locate<span class="pl-k">.</span><span class="pl-c1">valueslength</span>(obj))

<span class="pl-c"><span class="pl-c">#</span> you need a slightly different Values constructor for List values</span>
<span class="pl-c"><span class="pl-c">#</span> here T is the List return type so you can use it if you need to, but you may not</span>
Locate<span class="pl-k">.</span><span class="pl-en">Values</span>(<span class="pl-k">::</span><span class="pl-c1">Type{T}</span>, obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">where</span> T <span class="pl-k">=</span> Locate<span class="pl-k">.</span><span class="pl-c1">Values</span><span class="pl-c1">{UInt8}</span>(Locate<span class="pl-k">.</span><span class="pl-c1">values</span>(obj), Locate<span class="pl-k">.</span><span class="pl-c1">valueslength</span>(obj))

<span class="pl-c"><span class="pl-c">#</span> there's not really a reason to define Locate.Bitmask if you defined Locate.bitmask, but it's there</span>
Locate<span class="pl-k">.</span><span class="pl-en">Bitmask</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> Locate<span class="pl-k">.</span><span class="pl-c1">Bitmask</span>(Locate<span class="pl-k">.</span><span class="pl-c1">bitmask</span>(obj))

<span class="pl-c"><span class="pl-c">#</span> you can use Locate.Offsets to override the default offset type of Int32</span>
Locate<span class="pl-k">.</span><span class="pl-en">Offsets</span>(obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> Locate<span class="pl-k">.</span><span class="pl-c1">Offsets</span><span class="pl-c1">{Int64}</span>(Locate<span class="pl-k">.</span><span class="pl-c1">offsets</span>(obj))

<span class="pl-c"><span class="pl-c">#</span> as we described, you can also override the default container types, but this is not recommended</span>
<span class="pl-c"><span class="pl-c">#</span> it may be useful for custom types, but remember these won't in general be usable outside of Julia</span>
Locate<span class="pl-k">.</span><span class="pl-en">containertype</span>(<span class="pl-k">::</span><span class="pl-c1">Type{CustomType}</span>, obj<span class="pl-k">::</span><span class="pl-c1">ObjMetadata</span>) <span class="pl-k">=</span> NullablePrimitive <span class="pl-c"><span class="pl-c">#</span> returned value should have no type paramters</span></pre></div>
<p dir="auto">In the above we showed constructors receiving the arguments they <em>would</em> receive if you <em>only</em> defined the <code>Locate</code> methods listed in the previous section, but
of course you can make these constructors do anything you want, as long as return the proper type as an output.</p>
<h2 dir="auto"><a id="user-content-writing-data" class="anchor" aria-hidden="true" href="#writing-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Writing Data</h2>
<p dir="auto">Writing is somewhat simpler than reading as Arrow will figure out how to convert ordinary Julia data to Arrow formatted data for you.  In addition to
<code>arrowformat</code> the other two most important functions for writing data will be <code>rawpadded</code> and <code>writepadded</code>.  <code>rawpadded</code> takes a <code>Primitive</code> as argument and
returns a properly Arrow padded <code>Vector{UInt8}</code> appropriate for writing the data directly to an Arrow formatted buffer.  <code>writepadded</code> will write the properly
padded array to an <code>IO</code> object.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = NullableList(data)
writepadded(io, A, bitmask, offsets, values)  # write bitmask, offsets then values of A, all contiguously, all properly padded

B = DictEncoding(data)
writepadded(io, B, references)  # writes references
writepadded(io, levels(B), offsets, bitmask, values)  # writes the NullableList in a different order than above"><pre>A <span class="pl-k">=</span> <span class="pl-c1">NullableList</span>(data)
<span class="pl-c1">writepadded</span>(io, A, bitmask, offsets, values)  <span class="pl-c"><span class="pl-c">#</span> write bitmask, offsets then values of A, all contiguously, all properly padded</span>

B <span class="pl-k">=</span> <span class="pl-c1">DictEncoding</span>(data)
<span class="pl-c1">writepadded</span>(io, B, references)  <span class="pl-c"><span class="pl-c">#</span> writes references</span>
<span class="pl-c1">writepadded</span>(io, <span class="pl-c1">levels</span>(B), offsets, bitmask, values)  <span class="pl-c"><span class="pl-c">#</span> writes the NullableList in a different order than above</span></pre></div>
<p dir="auto">The following table show which sub-buffers are relevant for which <code>ArrowVector</code>s.  All sub-buffers can be accessed as <code>Primitive</code>s simply by doing, for example
<code>bitmask(l)</code> where <code>l isa ArrowVector{Union{T,Missing}} where T</code> returns the primitive representing the null bit mask.</p>
<table>
<thead>
<tr>
<th></th>
<th><code>values</code></th>
<th><code>bitmask</code></th>
<th><code>offsets</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Primitive</code></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><code>NullablePrimitive</code></td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>List</code></td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><code>NullableList</code></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>BitPrimitive</code></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><code>NullableBitPrimitive</code></td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p dir="auto"><code>DictEncoding</code> is a bit more complicated as it can contain any of the other types, but its references and data pool can be accessed with <code>references</code> and <code>pool</code>
respectively.</p>
<h2 dir="auto"><a id="user-content-datetime" class="anchor" aria-hidden="true" href="#datetime"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DateTime</h2>
<p dir="auto">Arrow.jl provides Arrow formatted date-time objects that have Julia equivalents.  These are <code>Arrow.Datestamp=&gt;Dates.Date</code>, <code>Arrow.Timestamp=&gt;Dates.DateTime</code> and
<code>Arrow.TimeOfDay=&gt;Dates.Time</code>.  The <code>arrowformat</code> function will automatically convert objects of the Julia <code>Dates</code> types to the appropriate Arrow format.  When
constructing the various <code>ArrowVector</code> objects, this conversion must be specified explicitly, e.g. with <code>Primitive{TimeOfDay}(v)</code> where <code>v::Vector{Dates.Time}</code>.
There is nothing stopping you from serializing the Julia <code>Dates</code> objects, but they are not in general readable outside of Julia.  The units in which <code>DateTime</code>
and <code>TimeOfDay</code> are stored can be specified with <code>Dates.TimePeriod</code>s.  For example, to store a <code>DateTime</code> with resolution of seconds, one should do
<code>convert(Timestamp{Dates.Second}, t)</code> where <code>t::DateTime</code>.</p>
<h2 dir="auto"><a id="user-content-working-example" class="anchor" aria-hidden="true" href="#working-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Working Example</h2>
<p dir="auto">For a working (but as of this writing still in-development) example of a package built with Arrow.jl see <a href="https://github.com/ExpandingMan/Feather.jl/tree/arrow1">this</a> fork of Feather.jl.</p>
<h2 dir="auto"><a id="user-content-todo" class="anchor" aria-hidden="true" href="#todo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>TODO</h2>
<p dir="auto">A lot of work still to be done:</p>
<ul dir="auto">
<li>Performance pass: performance seems ok according to basic sanity checks but it that code has neither been optimized nor thoroughly benchmarked.</li>
<li>Extensive unit tests needed: hopefully I'll get to more of this soon.</li>
<li>Support Arrow Structs.</li>
</ul>
</article></div>