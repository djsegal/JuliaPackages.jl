<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-tensarraysjl" class="anchor" aria-hidden="true" href="#tensarraysjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TensArrays.jl</h1>
<p>Kronecker product matrices that remember their tensor shape.</p>
<p>This a minimal package, to be included in other packages so that they can interoperate with <code>Tensars</code>.  For example Jacobian shapes.</p>
<p>Logic: if an operation is consistent with the tensor shapes, it returns a TensArray.  Otherwise, it lowers everything to Matrix.</p>
<p>Think about TensArray<em>vector and adjoint</em>TensArray.  In the unilinear case, the lowered vectors and matrices construct the same Tensars as their TensArrays do, so don't think too hard.</p>
<p>If Tensar stored a matrix, it could have the same in-memory layout as TensArray.  This would make conversion trivial.  In particular, Tensar can use the operations defined for TensArray, so there is no need to redefine broadcasting.  Except that Tensars should broadcast differently: an (xâŠ—y) tensar should broadcast along the y axis, but the TensArray is a column vector that should only broadcast over the whole plane.</p>
</article></div>