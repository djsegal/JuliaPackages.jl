<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-dicttools" class="anchor" aria-hidden="true" href="#dicttools"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DictTools</h1>
<p dir="auto"><a href="https://github.com/jlapeyre/DictTools.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/jlapeyre/DictTools.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jlapeyre/DictTools.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/d3cfe8ec4e2a76ffe48397ff34e298155c5eba948b7bb8fd8294a53213197953/68747470733a2f2f636f6465636f762e696f2f67682f6a6c6170657972652f44696374546f6f6c732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/jlapeyre/DictTools.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg" alt="Aqua QA" style="max-width: 100%;"></a>
<a href="https://github.com/aviatesk/JET.jl"><img src="https://camo.githubusercontent.com/3de76230f538a94a3ea8c5dc7c7abb94992d39a234fbb796184101d790424d9e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a45542e6a6c2d2545322539432538382545462542382538462d253233616134343434" alt="JET QA" data-canonical-src="https://img.shields.io/badge/JET.jl-%E2%9C%88%EF%B8%8F-%23aa4444" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/DictTools/2Dg1l?t=2" rel="nofollow"><img src="https://camo.githubusercontent.com/d562d6940227f25b7c1332b8acb39771bbc5e9706999adb2416833f3c8b3f4ab/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f44696374546f6f6c732f646570732e737667" alt="deps" data-canonical-src="https://juliahub.com/docs/DictTools/deps.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/DictTools/2Dg1l" rel="nofollow"><img src="https://camo.githubusercontent.com/5a89ba353127c7bee798389b4d282502e44af2cfd43869c186e9dba01d4d4a0f/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f44696374546f6f6c732f76657273696f6e2e737667" alt="version" data-canonical-src="https://juliahub.com/docs/DictTools/version.svg" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-count_map" class="anchor" aria-hidden="true" href="#count_map"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>count_map</code></h3>
<p dir="auto">The main feature of this package is <code>count_map</code>. For example <code>count_map(itr)</code> returns a <code>Dictionary</code> counting
the number of times each item in <code>itr</code> occurs.</p>
<p dir="auto">It differs from the one in <code>StatsBase</code> in a few ways.</p>
<ul dir="auto">
<li>It allows adding counts from any iterable rather than only <code>Vector</code>s.</li>
<li>It supports both <code>Dict</code> and <code>Dictionary</code>.</li>
<li>It is built on an abstraction that allows you update items via a function call.</li>
<li>It does not use radix sort to optimize the case that the data are <code>Int</code>s.</li>
</ul>
<h3 dir="auto"><a id="user-content-common-interface-to-dict-and-dictionary" class="anchor" aria-hidden="true" href="#common-interface-to-dict-and-dictionary"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Common interface to <code>Dict</code> and <code>Dictionary</code></h3>
<p dir="auto">Some tools to support <code>Dict</code> and <code>Dictionary</code> (and their abstract supertypes.)
In general, it is often not worth the trouble to support both <code>Dict</code> and <code>Dictionary</code> with a single interface.
But, sometimes it is, and these tools can be useful.</p>
<p dir="auto">We defined <code>_AbstractDict{T, V} = Union{AbstractDict{T,V}, AbstractDictionary{T,V}}</code>.</p>
<p dir="auto">To make the interfaces more compatible one <em>could</em> define the pirate method <code>Base.Dict(inds, vals) = Dict(zip(inds, vals))</code>.
But instead <code>DictTools</code> defines <code>construct(::Type{T&lt;:_AbstractDict}, inds, vals)</code> which provides a common interface for
construction. The latter is less convenient, but is not piracy.</p>
<h3 dir="auto"><a id="user-content-exported-functions-and-objects" class="anchor" aria-hidden="true" href="#exported-functions-and-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Exported functions and objects</h3>
<p dir="auto">docstrings may be more up to date than what appears below.</p>
<ul dir="auto">
<li>
<p dir="auto"><code>count_map([::Type{T}=Dictionary], itr, filt = x -&gt; true)</code></p>
<p dir="auto">Return a dictionary of type <code>T</code> whose keys are elements of <code>itr</code> and whose values count
how many times each occurs. Only elements of <code>itr</code> for which <code>filt</code> returns <code>true</code> are
counted.</p>
<p dir="auto"><code>count_map</code> has been tested for <code>T</code> being either <code>Dict</code> or <code>Dictionary</code>.</p>
<p dir="auto"><code>StatsBase.countmap</code> differs in that it has an optimization for integers and that <code>itr</code> of
indetermiate length is first collected internally.</p>
</li>
<li>
<p dir="auto"><code>add_counts!(dict::_AbstractDict{&lt;:Any,V}, itr, ncounts=one(V)) where V</code></p>
<p dir="auto">Add <code>ncounts</code> counts to <code>dict</code> for each key in <code>itr</code>. If <code>ncounts</code> is ommited,
add one count for each key.</p>
</li>
<li>
<p dir="auto"><code>_AbstractDict{T,V}</code></p>
<p dir="auto">Either an <code>AbstractDict</code> or an <code>AbstractDictionary</code>. A union type.
Here <code>_</code> indicates not a private identifier, but rather differentiates from <code>AbstractDict</code>.</p>
</li>
<li>
<p dir="auto"><code>_Dict{T,V}</code></p>
<p dir="auto">Either a <code>Dict</code> or a <code>Dictionary</code>. A union type</p>
</li>
<li>
<p dir="auto"><code>update!(dict::Union{Dict,Dictionary}, _key, func, default)</code></p>
<p dir="auto">If <code>dict</code> has key <code>_key</code>, replace the value by the result of calling <code>func</code> on the value.
Otherwise insert <code>default</code> for <code>_key</code>.</p>
<p dir="auto">This function may work if <code>dict</code> is some other <code>_AbstractDict</code>.</p>
<p dir="auto">In addition to dictionaries, <code>update!</code> and <code>add_counts!</code> also accept (some) <code>AbstractVector</code> types</p>
</li>
<li>
<p dir="auto"><code>update_map(::Type{T}=Dictionary, _keys, func, default)</code></p>
<p dir="auto">Like <code>count_map</code>, but instead of incrementing an existing value by one, it is replaced
by the result of calling <code>func</code> on it. Furthermore, the default is <code>default</code> rather than <code>1</code>.</p>
</li>
<li>
<p dir="auto"><code>DictTools.normalize(dict)</code></p>
<p dir="auto"><code>dict</code> is a dictionary of counts. The output is a dictionary with the same keys, and counts normalized to a probability distribution.</p>
</li>
<li>
<p dir="auto">Specialized method for <code>Dictionary</code> for the <a href="https://github.com/jlapeyre/ZChop.jl">ZChop.jl</a> package.</p>
</li>
<li>
<p dir="auto"><code>construct</code> to construct a <code>Dict</code> and <code>Dictionary</code> with one API</p>
</li>
<li>
<p dir="auto"><code>map_keys</code>, <code>map_keys!</code>
map_keys(dict::Dictionary, keymap_func, combine_func = +)</p>
<p dir="auto">Return a <code>Dictionary</code> whose keys are the image of <code>keys(dict)</code> under <code>keymap_func</code> and whose values
are created by accumulating with <code>combine_func</code> the values from the preimage of each key in the image of <code>keymap_func</code>.</p>
<p dir="auto">For example, suppose <code>combine_func</code> is <code>+</code>, and <code>keymap_func</code> is <code>iseven</code>, and the only even keys in <code>dict</code> are in key-value pairs
<code>(2, 9)</code>, <code>(4, 9)</code>, <code>(6, 9)</code>. Then the output <code>Dictionary</code> will contain the key-value pair <code>(true, 27)</code>.</p>
<p dir="auto"><code>map_keys</code> is useful for computing a marginal probability distribution.
If <code>dict</code> represents counts or a probability distribution, and <code>combine_func</code> is <code>+</code> and <code>keymap_func</code> is many-to-one for
some keys, then <code>map_keys</code> effects marginalization of the distribution.</p>
</li>
<li>
<p dir="auto"><code>collect_sparse</code>
Convert <code>dict</code> representing a sparse vector to a dense <code>Vector</code>. See doc string</p>
</li>
</ul>
</article></div>