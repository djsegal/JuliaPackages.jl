<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a href="https://bmxam.github.io/PetscWrap.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/32a535a58c99ab0db9628a55aae1e2986db282419fc1d0a15b1cdac215651fcc/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d7265642e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-red.svg" style="max-width: 100%;"></a>
<a href="https://bmxam.github.io/PetscWrap.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<h1 dir="auto"><a id="user-content-petscwrapjl" class="anchor" aria-hidden="true" href="#petscwrapjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PetscWrap.jl</h1>
<p dir="auto">PetscWrap.jl is a parallel Julia wrapper for the (awesome) <a href="https://www.mcs.anl.gov/petsc/" rel="nofollow">PETSc</a> library. It can be considered as a fork from the <a href="https://github.com/gridap/GridapPETSc.jl">GridapPetsc.jl</a> and <a href="https://github.com/JuliaParallel/PETSc.jl">Petsc.jl</a> projects : these two projects have extensively inspired this project, and some code has even been directly copied.</p>
<p dir="auto">Note that the primary objective of this project is to enable the wrapper of the SLEPc library through the <a href="https://github.com/bmxam/SlepcWrap.jl">SlepcWrap.jl</a> project.</p>
<p dir="auto">This project is only a wrapper to PETSc functions, the purpose is not to deliver a julia <code>Array</code> (it maybe be one day the purpose of a package <code>PetscArrays.jl</code>).</p>
<h2 dir="auto"><a id="user-content-how-to-install-it" class="anchor" aria-hidden="true" href="#how-to-install-it"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to install it</h2>
<p dir="auto">To install the package, use the Julia package manager:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; add PetscWrap"><pre>pkg<span class="pl-k">&gt;</span> add PetscWrap</pre></div>
<p dir="auto">If PETSc is not installed on your machine, it will be installed by the Julia package manager. Alternatively, if you already have a PETSc installation, <code>PetscWrap.jl</code> will select the install designated by <code>PETSC_DIR</code> and <code>PETSC_ARCH</code> environment variables.</p>
<p dir="auto">If you want, at any time, to modify the PETSc install used by the wrapper, just type</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pkg&gt; build PetscWrap"><pre>pkg<span class="pl-k">&gt;</span> build PetscWrap</pre></div>
<h2 dir="auto"><a id="user-content-contribute" class="anchor" aria-hidden="true" href="#contribute"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contribute</h2>
<p dir="auto">Any contribution(s) and/or remark(s) are welcome! If you need a function that is not wrapped yet but you don't think you are capable of contributing, post an issue with a minimum working example.</p>
<p dir="auto">Conventions to be applied in future versions ("fancy" stuff is not concerned):</p>
<ul dir="auto">
<li>all PETSc types should have the exact same name in Julia;</li>
<li>all PETSc functions should have the exact same name in julia, but without the type as a prefix, and with a lower case for the first letter. <code>VecSetValues</code> becomes <code>setValues</code>. This rule is not applied when the name conflicts with a name from <code>Base</code> (for instance <code>VecView</code> becomes <code>vecView</code> and not <code>view</code>);</li>
<li>all PETSc functions must have the same number of arguments and, if possible the same names in julia, except for out-of-place arguments.</li>
<li>functions arguments must all be typed. Additional functions, without type or with fewer args, can be defined if the original version is present.</li>
</ul>
<h2 dir="auto"><a id="user-content-petsc-compat" class="anchor" aria-hidden="true" href="#petsc-compat"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PETSc compat.</h2>
<p dir="auto">This version of PetscWrap.jl has been tested with petsc-3.19. Complex numbers are supported.</p>
<h2 dir="auto"><a id="user-content-how-to-use-it" class="anchor" aria-hidden="true" href="#how-to-use-it"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to use it</h2>
<p dir="auto">PETSc methods wrappers share the almost same name as their C equivalent (with the type) : for instance <code>MatSetValues</code> becomes <code>setValues</code>. Furthermore, an optional "higher level" API, referred to as "fancy", is exposed : for instance <code>create_matrix</code> or <code>A[i,j] = v</code>. Note that this second way of manipulating PETSc will evolve according the package's author needs while the first one will try to follow PETSc official API.</p>
<p dir="auto">You will find examples of use by building the documentation: <code>julia PetscWrap.jl/docs/make.jl</code>. Here is one of the examples:</p>
<h3 dir="auto"><a id="user-content-a-first-demo" class="anchor" aria-hidden="true" href="#a-first-demo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A first demo</h3>
<p dir="auto">This example serves as a test since this project doesn't have a "testing" procedure yet. In this example,
the equation <code>u'(x) = 2</code> with <code>u(0) = 0</code> is solved on the domain <code>[0,1]</code> using a backward finite
difference scheme.</p>
<p dir="auto">In this example, PETSc classic method names are used. For more fancy names, check the fancy version.</p>
<p dir="auto">Note that the way we achieve things in the document can be highly improved and the purpose of this example
is only demonstrate some method calls to give an overview.</p>
<p dir="auto">To run this example, execute : <code>mpirun -n your_favorite_positive_integer julia example1.jl</code></p>
<p dir="auto">Import package</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using PetscWrap"><pre><span class="pl-k">using</span> PetscWrap</pre></div>
<p dir="auto">Initialize PETSc. Command line arguments passed to Julia are parsed by PETSc. Alternatively, you can
also provide "command line arguments by defining them in a string, for instance
<code>PetscInitialize("-ksp_monitor_short -ksp_gmres_cgs_refinement_type refine_always")</code> or by providing each argument in
separate strings : <code>PetscInitialize(["-ksp_monitor_short", "-ksp_gmres_cgs_refinement_type", "refine_always")</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="PetscInitialize()"><pre><span class="pl-c1">PetscInitialize</span>()</pre></div>
<p dir="auto">Number of mesh points and mesh step</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n = 11
Δx = 1.0 / (n - 1)"><pre>n <span class="pl-k">=</span> <span class="pl-c1">11</span>
Δx <span class="pl-k">=</span> <span class="pl-c1">1.0</span> <span class="pl-k">/</span> (n <span class="pl-k">-</span> <span class="pl-c1">1</span>)</pre></div>
<p dir="auto">Create a matrix and a vector (you can specify the MPI communicator if you want)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = create(Mat)
b = create(Vec)"><pre>A <span class="pl-k">=</span> <span class="pl-c1">create</span>(Mat)
b <span class="pl-k">=</span> <span class="pl-c1">create</span>(Vec)</pre></div>
<p dir="auto">Set the size of the different objects, leaving PETSC to decide how to distribute. Note that we should
set the number of preallocated non-zeros to increase performance.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="setSizes(A, PETSC_DECIDE, PETSC_DECIDE, n, n)
setSizes(b, PETSC_DECIDE, n)"><pre><span class="pl-c1">setSizes</span>(A, PETSC_DECIDE, PETSC_DECIDE, n, n)
<span class="pl-c1">setSizes</span>(b, PETSC_DECIDE, n)</pre></div>
<p dir="auto">We can then use command-line options to set our matrix/vectors.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="setFromOptions(A)
setFromOptions(b)"><pre><span class="pl-c1">setFromOptions</span>(A)
<span class="pl-c1">setFromOptions</span>(b)</pre></div>
<p dir="auto">Finish the set up</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="setUp(A)
setUp(b)"><pre><span class="pl-c1">setUp</span>(A)
<span class="pl-c1">setUp</span>(b)</pre></div>
<p dir="auto">Let's build the right hand side vector. We first get the range of rows of <code>b</code> handled by the local processor.
As in PETSc, the <code>rstart, rend = *GetOwnershipRange</code> methods indicate the first row handled by the local processor
(starting at 0), and the last row (which is <code>rend-1</code>). This may be disturbing for non-regular PETSc users. Checkout
the fancy version of this example for a more Julia-like convention.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="b_start, b_end = getOwnershipRange(b)"><pre>b_start, b_end <span class="pl-k">=</span> <span class="pl-c1">getOwnershipRange</span>(b)</pre></div>
<p dir="auto">Now let's build the right hand side vector. Their are various ways to do this, this is just one.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n_loc = getLocalSize(b) # Note that n_loc = b_end - b_start...
setValues(b, collect(b_start:(b_end - 1)), 2 * ones(n_loc))"><pre>n_loc <span class="pl-k">=</span> <span class="pl-c1">getLocalSize</span>(b) <span class="pl-c"><span class="pl-c">#</span> Note that n_loc = b_end - b_start...</span>
<span class="pl-c1">setValues</span>(b, <span class="pl-c1">collect</span>(b_start<span class="pl-k">:</span>(b_end <span class="pl-k">-</span> <span class="pl-c1">1</span>)), <span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">ones</span>(n_loc))</pre></div>
<p dir="auto">And here is the differentiation matrix. Rembember that PETSc.MatSetValues simply ignores negatives rows indices.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A_start, A_end = getOwnershipRange(A)
for i = A_start:(A_end - 1)
    setValues(A, [i], [i - 1, i], [-1.0 1.0] / Δx, INSERT_VALUES) # setValues(A, I, J, V, INSERT_VALUES)
end"><pre>A_start, A_end <span class="pl-k">=</span> <span class="pl-c1">getOwnershipRange</span>(A)
<span class="pl-k">for</span> i <span class="pl-k">=</span> A_start<span class="pl-k">:</span>(A_end <span class="pl-k">-</span> <span class="pl-c1">1</span>)
    <span class="pl-c1">setValues</span>(A, [i], [i <span class="pl-k">-</span> <span class="pl-c1">1</span>, i], [<span class="pl-k">-</span><span class="pl-c1">1.0</span> <span class="pl-c1">1.0</span>] <span class="pl-k">/</span> Δx, INSERT_VALUES) <span class="pl-c"><span class="pl-c">#</span> setValues(A, I, J, V, INSERT_VALUES)</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">Set boundary condition (only the proc handling index <code>0</code> is acting)</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="(b_start == 0) &amp;&amp; setValue(b, 0, 0.0)"><pre>(b_start <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">setValue</span>(b, <span class="pl-c1">0</span>, <span class="pl-c1">0.0</span>)</pre></div>
<p dir="auto">Assemble matrices</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="assemblyBegin(A, MAT_FINAL_ASSEMBLY)
assemblyBegin(b)
assemblyEnd(A, MAT_FINAL_ASSEMBLY)
assemblyEnd(b)"><pre><span class="pl-c1">assemblyBegin</span>(A, MAT_FINAL_ASSEMBLY)
<span class="pl-c1">assemblyBegin</span>(b)
<span class="pl-c1">assemblyEnd</span>(A, MAT_FINAL_ASSEMBLY)
<span class="pl-c1">assemblyEnd</span>(b)</pre></div>
<p dir="auto">At this point, you can inspect <code>A</code> or <code>b</code> using a viewer (stdout by default), simply call</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="matView(A)
vecView(b)"><pre><span class="pl-c1">matView</span>(A)
<span class="pl-c1">vecView</span>(b)</pre></div>
<p dir="auto">Set up the linear solver</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ksp = create(KSP)
setOperators(ksp, A, A)
setFromOptions(ksp)
setUp(ksp)"><pre>ksp <span class="pl-k">=</span> <span class="pl-c1">create</span>(KSP)
<span class="pl-c1">setOperators</span>(ksp, A, A)
<span class="pl-c1">setFromOptions</span>(ksp)
<span class="pl-c1">setUp</span>(ksp)</pre></div>
<p dir="auto">Solve the system. We first allocate the solution using the <code>VecDuplicate</code> method.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = duplicate(b)
solve(ksp, b, x)"><pre>x <span class="pl-k">=</span> <span class="pl-c1">duplicate</span>(b)
<span class="pl-c1">solve</span>(ksp, b, x)</pre></div>
<p dir="auto">Print the solution</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vecView(x)"><pre><span class="pl-c1">vecView</span>(x)</pre></div>
<p dir="auto">Access the solution (this part is under development), getting a Julia array; and then restore it</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="array, ref = getArray(x) # do something with array
@show array
restoreArray(x, ref)"><pre>array, ref <span class="pl-k">=</span> <span class="pl-c1">getArray</span>(x) <span class="pl-c"><span class="pl-c">#</span> do something with array</span>
<span class="pl-c1">@show</span> array
<span class="pl-c1">restoreArray</span>(x, ref)</pre></div>
<p dir="auto">Free memory. Note that this call is faculative since, by default,
the julia GC will trigger a call to Petsc <code>destroy</code> to each object</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="destroy.((ksp, A, b, x))"><pre><span class="pl-c1">destroy</span>.((ksp, A, b, x))</pre></div>
<p dir="auto">Finalize Petsc. This call is faculative : it will be triggered automatically at the end of the script.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="PetscFinalize()
"><pre><span class="pl-c1">PetscFinalize</span>()
</pre></div>
</article></div>