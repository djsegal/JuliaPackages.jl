<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p><a href="https://travis-ci.org/acroy/Expokit.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/1018e05cf44a772e1fd2c6bf4abc6f0b429fc3a0d5d9e0ad1e7cba636df64b16/68747470733a2f2f7472617669732d63692e6f72672f6163726f792f4578706f6b69742e6a6c2e706e67" alt="Build Status" data-canonical-src="https://travis-ci.org/acroy/Expokit.jl.png" style="max-width:100%;"></a></p>
<h1><a id="user-content-expokit" class="anchor" aria-hidden="true" href="#expokit"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Expokit</h1>
<p>This package provides Julia implementations of some routines contained
in <a href="http://www.maths.uq.edu.au/expokit" rel="nofollow">EXPOKIT</a>. Those routines allow
an efficient calculation of the action of matrix exponentials on vectors
for large sparse matrices. For more details about the methods see
<em>R.B. Sidje, ACM Trans. Math. Softw., 24(1):130-156, 1998</em>
(or <a href="http://www.maths.uq.edu.au/expokit/paper.pdf" rel="nofollow">its preprint</a>).</p>
<p><strong>Note:</strong> Apart from <code>expmv</code> (which is called <code>expv</code> in EXPOKIT) also <code>phimv</code>, <code>padm</code> and <code>chbv</code> are available.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="Pkg.add(&quot;Expokit&quot;)
"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>Expokit<span class="pl-pds">"</span></span>)</pre></div>
<h2><a id="user-content-expmv" class="anchor" aria-hidden="true" href="#expmv"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>expmv</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="w = expmv!{T}( w::Vector{T}, t::Number, A, v::Vector{T}; kwargs...)
"><pre>w <span class="pl-k">=</span> <span class="pl-c1">expmv!</span><span class="pl-c1">{T}</span>( w<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, t<span class="pl-k">::</span><span class="pl-c1">Number</span>, A, v<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>; kwargs<span class="pl-k">...</span>)</pre></div>
<p>The function <code>expmv!</code> calculates <code>w = exp(t*A)*v</code>, where <code>A</code> is a
matrix or any type that supports <code>size</code>, <code>eltype</code> and <code>mul!</code> and <code>v</code> is a dense vector by using Krylov subspace projections. The result is
stored in <code>w</code>.</p>
<p>The following keywords are supported</p>
<ul>
<li><code>tol</code>: tolerance to control step size (default: <code>1e-7</code>)</li>
<li><code>m</code>: size of Krylov subspace (default: <code>min(30,size(A,1))</code>)</li>
<li><code>norm</code>: user-supplied function to calculate vector norm (dafault: <code>Base.norm</code>)</li>
<li><code>anorm</code>: operator/matrix norm of <code>A</code> to estimate first time-step (default: <code>opnorm(A, Inf)</code>)</li>
</ul>
<p>For convenience, the following versions of <code>expmv</code> are provided</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="v = expmv!{T}( t::Number, A, v::Vector{T}; kwargs...)
w = expmv{T}( t::Number, A, v::Vector{T}; kwargs...)
"><pre>v <span class="pl-k">=</span> <span class="pl-c1">expmv!</span><span class="pl-c1">{T}</span>( t<span class="pl-k">::</span><span class="pl-c1">Number</span>, A, v<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>; kwargs<span class="pl-k">...</span>)
w <span class="pl-k">=</span> <span class="pl-c1">expmv</span><span class="pl-c1">{T}</span>( t<span class="pl-k">::</span><span class="pl-c1">Number</span>, A, v<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>; kwargs<span class="pl-k">...</span>)</pre></div>
<h2><a id="user-content-phimv" class="anchor" aria-hidden="true" href="#phimv"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>phimv</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="w = phimv!{T}( w::Vector{T}, t::Number, A, u::Vector{T}, v::Vector{T}; kwargs...)
"><pre>w <span class="pl-k">=</span> <span class="pl-c1">phimv!</span><span class="pl-c1">{T}</span>( w<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, t<span class="pl-k">::</span><span class="pl-c1">Number</span>, A, u<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, v<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>; kwargs<span class="pl-k">...</span>)</pre></div>
<p>The function <code>phimv!</code> calculates <code>w = e^{tA}v + t φ(t A) u</code> with <code>φ(z) = (exp(z)-1)/z</code>, where <code>A</code> is a
matrix or any type that supports <code>size</code>, <code>eltype</code> and <code>mul!</code>, <code>u</code> and <code>v</code> are dense vectors by using Krylov subspace projections. The result is stored in <code>w</code>. The supported keywords are the same as for <code>expmv!</code>.</p>
<h2><a id="user-content-chbv" class="anchor" aria-hidden="true" href="#chbv"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>chbv</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="chbv!{T}(w::Vector{T}, A, v::Vector{T})
"><pre><span class="pl-c1">chbv!</span><span class="pl-c1">{T}</span>(w<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>, A, v<span class="pl-k">::</span><span class="pl-c1">Vector{T}</span>)</pre></div>
<p>The function <code>chbv!</code> calculates <code>w = exp(A)*v</code> using the partial fraction expansion of
the uniform rational Chebyshev approximation of type (14,14).</p>
<h2><a id="user-content-padm" class="anchor" aria-hidden="true" href="#padm"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>padm</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="padm(A; p=6)
"><pre><span class="pl-c1">padm</span>(A; p<span class="pl-k">=</span><span class="pl-c1">6</span>)</pre></div>
<p>The function <code>padm</code> calculates the matrix exponential <code>exp(A)</code> of <code>A</code> using the irreducible
(p,p)-degree rational Pade approximation to the exponential function.</p>
</article></div>