<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-doubleblas" class="anchor" aria-hidden="true" href="#doubleblas"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>DoubleBLAS</h1>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0058ce9713cb93a553c2f23207afbb49b1b852a70a4a24de20e2e816c58b299e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d6f72616e67652e737667"><img src="https://camo.githubusercontent.com/0058ce9713cb93a553c2f23207afbb49b1b852a70a4a24de20e2e816c58b299e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6966656379636c652d6578706572696d656e74616c2d6f72616e67652e737667" alt="Lifecycle" data-canonical-src="https://img.shields.io/badge/lifecycle-experimental-orange.svg" style="max-width: 100%;"></a>
<a href="https://github.com/RalphAS/DoubleBLAS.jl/actions"><img src="https://github.com/RalphAS/DoubleBLAS.jl/workflows/CI/badge.svg" alt="GitHub CI Build Status" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/RalphAS/DoubleBLAS.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/d4a129f91d03873056c73de164ae0bdeb1e3f2e954d34feb8b0a5a45e817d6e3/687474703a2f2f636f6465636f762e696f2f6769746875622f52616c706841532f446f75626c65424c41532e6a6c2f636f7665726167652e7376673f6272616e63683d6d61696e" alt="Coverage Status" data-canonical-src="http://codecov.io/github/RalphAS/DoubleBLAS.jl/coverage.svg?branch=main" style="max-width: 100%;"></a></p>
<p dir="auto">This package is a draft implementation of SIMD-based basic linear algebra
routines for matrices with element types from <a href="https://github.com/JuliaMath/DoubleFloats.jl">DoubleFloats.jl</a>.</p>
<p dir="auto">The package name is perhaps a bit misleading: only a modest fraction
of the BLAS forest is implemented, the interface is (mostly) Julian
rather then BLAS-like, and some extra related methods are
included to make important parts of <code>LinearAlgebra</code> and its supplements
work efficiently.</p>
<p dir="auto">The API is intended to be seamlessly compatible with the
<code>LinearAlgebra</code> standard library. That is, <code>using DoubleBLAS</code> will
extend various methods from <code>LinearAlgebra</code> so that frequent operations
such as matrix multiplication, LU and Cholesky factorization, and
<code>inv()</code> will employ more efficient methods than the generic ones.</p>
<h2 dir="auto"><a id="user-content-warning" class="anchor" aria-hidden="true" href="#warning"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Warning</h2>
<p dir="auto">The arithmetic used in this package is the straightforward
double-double variety which does not respect all IEEE-754
rules. (Kahan calls it "fast but grubby", but concedes that it may be
useful for linear algebra, so here we are.) Underflow is largely
similar to IEEE-754, but overflow and treatment of NaN and infinities
are non-conforming (and complicated). Users are advised to make sure
that vectors and matrices are scaled to avoid overflow. (This is good
advice in general for linear algebra, but especially important here.)</p>
<h2 dir="auto"><a id="user-content-multi-threading" class="anchor" aria-hidden="true" href="#multi-threading"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multi-threading</h2>
<p dir="auto">Multi-threading (MT) is enabled for some sufficiently large problems.
We use <code>Base.Threads</code> (q.v. in the Julia manual), limited by the
<code>JULIA_NUM_THREADS</code> environment variable. On many systems there is
significant overhead for MT, so heuristic thresholds for switching
from simple versions to MT are provided. These may be adjusted with
the <code>set_mt_threshold(n::Real, problem::Symbol)</code> function.  Someday
tuned values for a given system might be set during package
installation or initialization, but currently they are notional
or based on very limited testing.</p>
<h1 dir="auto"><a id="user-content-iterative-refinement" class="anchor" aria-hidden="true" href="#iterative-refinement"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Iterative refinement</h1>
<p dir="auto">DoubleFloats are especially useful for mixed-precision iterative
refinement.  This can be used to improve solutions of moderately
poorly-conditioned problems.
I didn't find an implementation in other well-known packages,
so I provide <code>refinedldiv</code> here:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; n=4096; A=rand(Double64,n,n); x=rand(Double64,n);
julia&gt; b=A*x;
julia&gt; F=lu(Float64.(A));
julia&gt; bf = Float64.(b);
julia&gt; xf = F \ bf;
julia&gt; norm(xf-x)/norm(x)
6.745241585354585e-11

julia&gt; xx,cvg = refinedldiv(A,F,b);
julia&gt; norm(xx-x)/norm(x)
2.1020613807856875066955678325842648e-27"><pre>julia<span class="pl-k">&gt;</span> n<span class="pl-k">=</span><span class="pl-c1">4096</span>; A<span class="pl-k">=</span><span class="pl-c1">rand</span>(Double64,n,n); x<span class="pl-k">=</span><span class="pl-c1">rand</span>(Double64,n);
julia<span class="pl-k">&gt;</span> b<span class="pl-k">=</span>A<span class="pl-k">*</span>x;
julia<span class="pl-k">&gt;</span> F<span class="pl-k">=</span><span class="pl-c1">lu</span>(<span class="pl-c1">Float64</span>.(A));
julia<span class="pl-k">&gt;</span> bf <span class="pl-k">=</span> <span class="pl-c1">Float64</span>.(b);
julia<span class="pl-k">&gt;</span> xf <span class="pl-k">=</span> F <span class="pl-k">\</span> bf;
julia<span class="pl-k">&gt;</span> <span class="pl-c1">norm</span>(xf<span class="pl-k">-</span>x)<span class="pl-k">/</span><span class="pl-c1">norm</span>(x)
<span class="pl-c1">6.745241585354585e-11</span>

julia<span class="pl-k">&gt;</span> xx,cvg <span class="pl-k">=</span> <span class="pl-c1">refinedldiv</span>(A,F,b);
julia<span class="pl-k">&gt;</span> <span class="pl-c1">norm</span>(xx<span class="pl-k">-</span>x)<span class="pl-k">/</span><span class="pl-c1">norm</span>(x)
<span class="pl-c1">2.1020613807856875066955678325842648e-27</span></pre></div>
<p dir="auto">This takes a couple of seconds vs. more than a minute for a full <code>Double64</code>
factorization (with several threads).</p>
<h1 dir="auto"><a id="user-content-acknowledgements" class="anchor" aria-hidden="true" href="#acknowledgements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgements</h1>
<p dir="auto">Most of the arithmetic was copied from DoubleFloats.jl and
AccurateArithmetic.jl. Linear algebra routines were adapted from the Julia
standard library.</p>
</article></div>