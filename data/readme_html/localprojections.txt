<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-localprojectionsjl" class="anchor" aria-hidden="true" href="#localprojectionsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LocalProjections.jl</h1>
<p dir="auto"><em>Local projection methods for impulse response estimation</em></p>
<p dir="auto"><a href="https://github.com/junyuan-chen/LocalProjections.jl/actions?query=workflow%3ACI-stable"><img src="https://github.com/junyuan-chen/LocalProjections.jl/workflows/CI-stable/badge.svg" alt="CI-stable" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/junyuan-chen/LocalProjections.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/96e324ba0590bb524f672cbeb2330b932369a249047b3ed84c4b54e264435209/68747470733a2f2f636f6465636f762e696f2f67682f6a756e7975616e2d6368656e2f4c6f63616c50726f6a656374696f6e732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/junyuan-chen/LocalProjections.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/LocalProjections/WJbkE" rel="nofollow"><img src="https://camo.githubusercontent.com/e96ee70a6941509258106e14bb162c0dbc7c0dbeecfee3c697842d064af465d4/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f4c6f63616c50726f6a656374696f6e732f76657273696f6e2e737667" alt="version" data-canonical-src="https://juliahub.com/docs/LocalProjections/version.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/LocalProjections/WJbkE" rel="nofollow"><img src="https://camo.githubusercontent.com/200ecf264c261eea5a557c67c042667e4611c7e9ef0f2d5cf013fdbf6bed5941/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f4c6f63616c50726f6a656374696f6e732f706b676576616c2e737667" alt="PkgEval" data-canonical-src="https://juliahub.com/docs/LocalProjections/pkgeval.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/junyuan-chen/LocalProjections.jl">LocalProjections.jl</a>
is a Julia package for estimating impulse response functions with local projection methods.
It follows the latest development in the econometric literature
and pursues reliable and efficient implementation.</p>
<h2 dir="auto"><a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features</h2>
<p dir="auto">A growing list of features includes the following:</p>
<ul dir="auto">
<li>Ordinary least squares local projections as in <a href="https://doi.org/10.1257/0002828053828518" rel="nofollow">Jordà (2005)</a></li>
<li>Instrumental variable (LP-IV) estimation and unit effect normalization as in <a href="https://doi.org/10.1111/ecoj.12593" rel="nofollow">Stock and Watson (2018)</a></li>
<li>Cumulative effects and state dependency as in <a href="https://doi.org/10.1086/696277" rel="nofollow">Ramey and Zubairy (2018)</a></li>
<li>Panel local projections with fixed effects as in <a href="https://dx.doi.org/10.1016/j.jinteco.2014.12.011" rel="nofollow">Jordà, Schularick and Taylor (2015)</a></li>
<li>Smooth local projections as in <a href="https://doi.org/10.1162/rest_a_00778" rel="nofollow">Barnichon and Brownlees (2019)</a></li>
<li>Equal-weighted cosine (EWC) test for HAR inference as in <a href="https://doi.org/10.1080/07350015.2018.1506926" rel="nofollow">Lazarus et al. (2018)</a></li>
</ul>
<h2 dir="auto"><a id="user-content-quick-start" class="anchor" aria-hidden="true" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick Start</h2>
<p dir="auto">Estimation for a given specification is conducted by calling the function <code>lp</code>.
An impulse response function with respect to a specific variable is then obtained via <code>irf</code>.
<a href="data">Example data</a> are included in this package for convenience.</p>
<p dir="auto">To reproduce the empirical illustration from
<a href="https://doi.org/10.1162/rest_a_00778" rel="nofollow">Barnichon and Brownlees (2019)</a>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LocalProjections, CSV
# Read example data from Barnichon and Brownlees (2019)
df = CSV.File(datafile(:bb))
# Specify names of the regressors
ns = (:ir, :pi, :yg)
# By default, conduct least-squares estimation
# Lags for the outcome variable and variables in `wnames` are included automatically
r_ls = lp(df, :yg, xnames=ns, wnames=ns, nlag=4, nhorz=20, minhorz=1)
# Collect the estimated impulse response function with respect to ir
f_ls = irf(r_ls, :yg, :ir)

# For smooth local projections, specify the estimator
est = SmoothLP(:ir, 3, 2, search=grid(194.0.*(1:0.5:10)), criterion=LOOCV())
r_sm = lp(est, df, :yg, xnames=ns, wnames=ns, nlag=4, nhorz=20, minhorz=1)
f_sm = irf(r_sm, :yg, :ir)"><pre><span class="pl-k">using</span> LocalProjections, CSV
<span class="pl-c"><span class="pl-c">#</span> Read example data from Barnichon and Brownlees (2019)</span>
df <span class="pl-k">=</span> CSV<span class="pl-k">.</span><span class="pl-c1">File</span>(<span class="pl-c1">datafile</span>(<span class="pl-c1">:bb</span>))
<span class="pl-c"><span class="pl-c">#</span> Specify names of the regressors</span>
ns <span class="pl-k">=</span> (<span class="pl-c1">:ir</span>, <span class="pl-c1">:pi</span>, <span class="pl-c1">:yg</span>)
<span class="pl-c"><span class="pl-c">#</span> By default, conduct least-squares estimation</span>
<span class="pl-c"><span class="pl-c">#</span> Lags for the outcome variable and variables in `wnames` are included automatically</span>
r_ls <span class="pl-k">=</span> <span class="pl-c1">lp</span>(df, <span class="pl-c1">:yg</span>, xnames<span class="pl-k">=</span>ns, wnames<span class="pl-k">=</span>ns, nlag<span class="pl-k">=</span><span class="pl-c1">4</span>, nhorz<span class="pl-k">=</span><span class="pl-c1">20</span>, minhorz<span class="pl-k">=</span><span class="pl-c1">1</span>)
<span class="pl-c"><span class="pl-c">#</span> Collect the estimated impulse response function with respect to ir</span>
f_ls <span class="pl-k">=</span> <span class="pl-c1">irf</span>(r_ls, <span class="pl-c1">:yg</span>, <span class="pl-c1">:ir</span>)

<span class="pl-c"><span class="pl-c">#</span> For smooth local projections, specify the estimator</span>
est <span class="pl-k">=</span> <span class="pl-c1">SmoothLP</span>(<span class="pl-c1">:ir</span>, <span class="pl-c1">3</span>, <span class="pl-c1">2</span>, search<span class="pl-k">=</span><span class="pl-c1">grid</span>(<span class="pl-c1">194.0</span><span class="pl-k">.*</span>(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0.5</span><span class="pl-k">:</span><span class="pl-c1">10</span>)), criterion<span class="pl-k">=</span><span class="pl-c1">LOOCV</span>())
r_sm <span class="pl-k">=</span> <span class="pl-c1">lp</span>(est, df, <span class="pl-c1">:yg</span>, xnames<span class="pl-k">=</span>ns, wnames<span class="pl-k">=</span>ns, nlag<span class="pl-k">=</span><span class="pl-c1">4</span>, nhorz<span class="pl-k">=</span><span class="pl-c1">20</span>, minhorz<span class="pl-k">=</span><span class="pl-c1">1</span>)
f_sm <span class="pl-k">=</span> <span class="pl-c1">irf</span>(r_sm, <span class="pl-c1">:yg</span>, <span class="pl-c1">:ir</span>)</pre></div>
<p dir="auto">To reproduce the cumulative multipliers from
<a href="https://doi.org/10.1086/696277" rel="nofollow">Ramey and Zubairy (2018)</a>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LocalProjections, CSV
# Read example data from Ramey and Zubairy (2018)
df = CSV.File(datafile(:rz))
# Replicate results in their Table 1
# Baseline linear specification with news shock
# `Cum()` is for cumulative effects
r1 = lp(df, Cum(:y), xnames=Cum(:g), wnames=(:newsy, :y, :g), iv=Cum(:g)=&gt;:newsy,
    nlag=4, nhorz=17, addylag=false, firststagebyhorz=true)
f1 = irf(r1, Cum(:y), Cum(:g))

# State-dependent specification with both news shock and Blanchard-Perotti shock
# Interactions with states are handled automatically for variables in `wnames`
# For other variables, interactions with states need to be constructed before calling `lp`
r2 = lp(df, Cum(:y), xnames=(Cum(:g,:rec), Cum(:g,:exp), :rec), wnames=(:newsy, :y, :g),
        iv=(Cum(:g,:rec), Cum(:g,:exp))=&gt;(:recnewsy, :expnewsy, :recg, :expg),
        states=(:rec, :exp), nlag=4, nhorz=16, minhorz=1, addylag=false, firststagebyhorz=true)
# Collect the estimated impulse response functions in each state separately
f2rec = irf(r2, Cum(:y), Cum(:g,:rec))
f2exp = irf(r2, Cum(:y), Cum(:g,:exp))"><pre><span class="pl-k">using</span> LocalProjections, CSV
<span class="pl-c"><span class="pl-c">#</span> Read example data from Ramey and Zubairy (2018)</span>
df <span class="pl-k">=</span> CSV<span class="pl-k">.</span><span class="pl-c1">File</span>(<span class="pl-c1">datafile</span>(<span class="pl-c1">:rz</span>))
<span class="pl-c"><span class="pl-c">#</span> Replicate results in their Table 1</span>
<span class="pl-c"><span class="pl-c">#</span> Baseline linear specification with news shock</span>
<span class="pl-c"><span class="pl-c">#</span> `Cum()` is for cumulative effects</span>
r1 <span class="pl-k">=</span> <span class="pl-c1">lp</span>(df, <span class="pl-c1">Cum</span>(<span class="pl-c1">:y</span>), xnames<span class="pl-k">=</span><span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>), wnames<span class="pl-k">=</span>(<span class="pl-c1">:newsy</span>, <span class="pl-c1">:y</span>, <span class="pl-c1">:g</span>), iv<span class="pl-k">=</span><span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>)<span class="pl-k">=&gt;</span><span class="pl-c1">:newsy</span>,
    nlag<span class="pl-k">=</span><span class="pl-c1">4</span>, nhorz<span class="pl-k">=</span><span class="pl-c1">17</span>, addylag<span class="pl-k">=</span><span class="pl-c1">false</span>, firststagebyhorz<span class="pl-k">=</span><span class="pl-c1">true</span>)
f1 <span class="pl-k">=</span> <span class="pl-c1">irf</span>(r1, <span class="pl-c1">Cum</span>(<span class="pl-c1">:y</span>), <span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>))

<span class="pl-c"><span class="pl-c">#</span> State-dependent specification with both news shock and Blanchard-Perotti shock</span>
<span class="pl-c"><span class="pl-c">#</span> Interactions with states are handled automatically for variables in `wnames`</span>
<span class="pl-c"><span class="pl-c">#</span> For other variables, interactions with states need to be constructed before calling `lp`</span>
r2 <span class="pl-k">=</span> <span class="pl-c1">lp</span>(df, <span class="pl-c1">Cum</span>(<span class="pl-c1">:y</span>), xnames<span class="pl-k">=</span>(<span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>,<span class="pl-c1">:rec</span>), <span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>,<span class="pl-c1">:exp</span>), <span class="pl-c1">:rec</span>), wnames<span class="pl-k">=</span>(<span class="pl-c1">:newsy</span>, <span class="pl-c1">:y</span>, <span class="pl-c1">:g</span>),
        iv<span class="pl-k">=</span>(<span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>,<span class="pl-c1">:rec</span>), <span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>,<span class="pl-c1">:exp</span>))<span class="pl-k">=&gt;</span>(<span class="pl-c1">:recnewsy</span>, <span class="pl-c1">:expnewsy</span>, <span class="pl-c1">:recg</span>, <span class="pl-c1">:expg</span>),
        states<span class="pl-k">=</span>(<span class="pl-c1">:rec</span>, <span class="pl-c1">:exp</span>), nlag<span class="pl-k">=</span><span class="pl-c1">4</span>, nhorz<span class="pl-k">=</span><span class="pl-c1">16</span>, minhorz<span class="pl-k">=</span><span class="pl-c1">1</span>, addylag<span class="pl-k">=</span><span class="pl-c1">false</span>, firststagebyhorz<span class="pl-k">=</span><span class="pl-c1">true</span>)
<span class="pl-c"><span class="pl-c">#</span> Collect the estimated impulse response functions in each state separately</span>
f2rec <span class="pl-k">=</span> <span class="pl-c1">irf</span>(r2, <span class="pl-c1">Cum</span>(<span class="pl-c1">:y</span>), <span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>,<span class="pl-c1">:rec</span>))
f2exp <span class="pl-k">=</span> <span class="pl-c1">irf</span>(r2, <span class="pl-c1">Cum</span>(<span class="pl-c1">:y</span>), <span class="pl-c1">Cum</span>(<span class="pl-c1">:g</span>,<span class="pl-c1">:exp</span>))</pre></div>
<p dir="auto">For panel local projections, specify the variable identifying each unit:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LocalProjections, CSV
# Example from Jordà's website using the macrohistory database
df = CSV.File(datafile(:jst))
ws = (:dlgrgdp, :dlgcpi, :dstir)
# Country fixed effects are included by default
# Compute cluster-robust standard errors via Vcov.jl
r = lp(df, :dlgrgdp, wnames=ws, nlag=3, nhorz=5, panelid=:iso, vce=cluster(:iso))
f = irf(r, :dlgrgdp, :dlgrgdp, lag=1)"><pre><span class="pl-k">using</span> LocalProjections, CSV
<span class="pl-c"><span class="pl-c">#</span> Example from Jordà's website using the macrohistory database</span>
df <span class="pl-k">=</span> CSV<span class="pl-k">.</span><span class="pl-c1">File</span>(<span class="pl-c1">datafile</span>(<span class="pl-c1">:jst</span>))
ws <span class="pl-k">=</span> (<span class="pl-c1">:dlgrgdp</span>, <span class="pl-c1">:dlgcpi</span>, <span class="pl-c1">:dstir</span>)
<span class="pl-c"><span class="pl-c">#</span> Country fixed effects are included by default</span>
<span class="pl-c"><span class="pl-c">#</span> Compute cluster-robust standard errors via Vcov.jl</span>
r <span class="pl-k">=</span> <span class="pl-c1">lp</span>(df, <span class="pl-c1">:dlgrgdp</span>, wnames<span class="pl-k">=</span>ws, nlag<span class="pl-k">=</span><span class="pl-c1">3</span>, nhorz<span class="pl-k">=</span><span class="pl-c1">5</span>, panelid<span class="pl-k">=</span><span class="pl-c1">:iso</span>, vce<span class="pl-k">=</span><span class="pl-c1">cluster</span>(<span class="pl-c1">:iso</span>))
f <span class="pl-k">=</span> <span class="pl-c1">irf</span>(r, <span class="pl-c1">:dlgrgdp</span>, <span class="pl-c1">:dlgrgdp</span>, lag<span class="pl-k">=</span><span class="pl-c1">1</span>)</pre></div>
<p dir="auto">For more details,
enter the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/#Help-mode" rel="nofollow">help</a> mode.</p>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto"><strong>Barnichon, Regis, and Christian Brownlees.</strong> 2019.
"Impulse Response Estimation by Smooth Local Projections."
<em>The Review of Economics and Statistics</em> 101 (3): 522-530.</p>
<p dir="auto"><strong>Jordà, Òscar.</strong> 2005. "Estimation and Inference of Impulse Responses by Local Projections."
<em>American Economic Review</em> 95 (1): 161-182.</p>
<p dir="auto"><strong>Jordà, Òscar., Moritz Schularick, and Alan M. Taylor.</strong> 2015.
"Betting the House."
<em>Journal of International Economics</em> 96 (S1): S2-S18.</p>
<p dir="auto"><strong>Lazarus, Eben, Daniel J. Lewis, James H. Stock, and Mark W. Watson.</strong> 2018.
"HAR Inference: Recommendations for Practice."
<em>Journal of Business &amp; Economic Statistics</em> 36 (4): 541-559.</p>
<p dir="auto"><strong>Li, Dake, Mikkel Plagborg-Møller, and Christian K. Wolf.</strong> 2021.
"Local Projections vs. VARs: Lessons from Thousands of DGPs." Unpublished.</p>
<p dir="auto"><strong>Montiel Olea, José Luis, and Mikkel Plagborg-Møller.</strong> 2021.
"Local Projection Inference is Simpler and More Robust Than You Think."
<em>Econometrica</em> 89 (4): 1789-1823.</p>
<p dir="auto"><strong>Plagborg-Møller, Mikkel, and Christian K. Wolf.</strong> 2021.
"Local Projections and VARs Estimate the Same Impulse Responses."
<em>Econometrica</em> 89 (2): 955-980.</p>
<p dir="auto"><strong>Ramey, Valerie A., and Sarah Zubairy.</strong> 2018.
"Government Spending Multipliers in Good Times and in Bad: Evidence from US Historical Data."
<em>Journal of Political Economy</em> 126 (2): 850-901.</p>
<p dir="auto"><strong>Stock, James H., and Mark W. Watson.</strong> 2018.
"Identification and Estimation of Dynamic Causal Effects in Macroeconomics Using External Instruments."
<em>The Economic Journal</em> 128 (610): 917-948.</p>
</article></div>