<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-updatableqrfactorizationsjl" class="anchor" aria-hidden="true" href="#updatableqrfactorizationsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>UpdatableQRFactorizations.jl</h1>
<p dir="auto"><a href="https://github.com/SebastianAment/UpdatableQRFactorizations.jl/actions/workflows/CI.yml"><img src="https://github.com/SebastianAment/UpdatableQRFactorizations.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/SebastianAment/UpdatableQRFactorizations.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/96758c069e80d18c46c1d5d340c164373aad9a1b17fd84a2b3731fc0ff457d10/68747470733a2f2f636f6465636f762e696f2f67682f53656261737469616e416d656e742f557064617461626c655152466163746f72697a6174696f6e732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d48504231544241594155" alt="codecov" data-canonical-src="https://codecov.io/gh/SebastianAment/UpdatableQRFactorizations.jl/branch/master/graph/badge.svg?token=HPB1TBAYAU" style="max-width: 100%;"></a></p>
<p dir="auto">This package contains implementations of efficient representations and updating algorithms for QR factorizations.
Notably, the implementations can scale to very high dimensions and moderately large numbers of columns even if memory is not abundant.</p>
<h2 dir="auto"><a id="user-content-basic-usage" class="anchor" aria-hidden="true" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic Usage</h2>
<p dir="auto">The following example highlights the basic usage of the package.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using UpdatableQRFactorizations
n, m = 32, 8
A = randn(n, m)
F = UpdatableQR(A)"><pre><span class="pl-k">using</span> UpdatableQRFactorizations
n, m <span class="pl-k">=</span> <span class="pl-c1">32</span>, <span class="pl-c1">8</span>
A <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, m)
F <span class="pl-k">=</span> <span class="pl-c1">UpdatableQR</span>(A)</pre></div>
<p dir="auto">The following snippet shows how to add a column to the factorization.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="b = randn(n)
add_column!(F, b)
println(Matrix(F) ≈ [A b])"><pre>b <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n)
<span class="pl-c1">add_column!</span>(F, b)
<span class="pl-c1">println</span>(<span class="pl-c1">Matrix</span>(F) <span class="pl-k">≈</span> [A b])</pre></div>
<p dir="auto">Lastly, we can also efficiently update the factorization upon removal of a column.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="remove_column!(F)
println(Matrix(F) ≈ A)"><pre><span class="pl-c1">remove_column!</span>(F)
<span class="pl-c1">println</span>(<span class="pl-c1">Matrix</span>(F) <span class="pl-k">≈</span> A)</pre></div>
<h2 dir="auto"><a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Documentation</h2>
<h3 dir="auto"><a id="user-content-initialization" class="anchor" aria-hidden="true" href="#initialization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Initialization</h3>
<p dir="auto">The <code>UpdatableGivensQR</code> structure is central to the package and can also be referred to as <code>UpdatableQR</code>, or <code>UQR</code>.
It holds storage for Givens rotations and the <code>R</code> matrix of a QR factorization and allows for efficient addition and deletion of columns.
See <code>add_column!</code> and <code>remove_column!</code>.
There are two primary ways of initializing such a structure.
First,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="UpdatableQR(A::AbstractMatrix, r::Int = size(A, 1))"><pre><span class="pl-c1">UpdatableQR</span>(A<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix</span>, r<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">size</span>(A, <span class="pl-c1">1</span>))</pre></div>
<p dir="auto">computes the QR factorization of <code>A</code> and pre-allocates enough memory for up to <code>r</code> columns total.
In cases where <code>n</code> is large, and in particular, if an <code>n</code> by <code>n</code> matrix does not fit in memory,
reducing the maximum allowed rank <code>r</code> is necessary to use this structure.
Note also that there is a mutating constructor</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="UpdatableQR!(A::AbstractMatrix, r::Int = size(A, 1)),"><pre><span class="pl-c1">UpdatableQR!</span>(A<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix</span>, r<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">size</span>(A, <span class="pl-c1">1</span>)),</pre></div>
<p dir="auto">which overwrites the input matrix <code>A</code> with the <code>R</code> matrix but allocates extra space for the representation of <code>Q</code>.
Second,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="UpdatableQR(n::Int, r::Int)"><pre><span class="pl-c1">UpdatableQR</span>(n<span class="pl-k">::</span><span class="pl-c1">Int</span>, r<span class="pl-k">::</span><span class="pl-c1">Int</span>)</pre></div>
<p dir="auto">initializes an empty QR factorization of size <code>n</code> by <code>0</code> with enough space to add <code>r</code> columns total.</p>
<h3 dir="auto"><a id="user-content-column-addition" class="anchor" aria-hidden="true" href="#column-addition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Column Addition</h3>
<p dir="auto">To add columns to the factorization, use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add_column!(F::UpdatableGivensQR, x::AbstractVector, k::Int = size(F, 2) + 1)."><pre><span class="pl-c1">add_column!</span>(F<span class="pl-k">::</span><span class="pl-c1">UpdatableGivensQR</span>, x<span class="pl-k">::</span><span class="pl-c1">AbstractVector</span>, k<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">size</span>(F, <span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span>).</pre></div>
<p dir="auto">Given an existing QR factorization <code>F</code> of a matrix, <code>add_column!</code> computes the factorization of
the same matrix after a new column <code>x</code> has been added as the <code>k</code>ᵗʰ column.
Computational complexity: <code>O(nm)</code> where <code>size(F) = (n, m)</code>.
This overwrites the existing factorization.
The package also supports the addition of multiple columns with a single call with performance benefits:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add_column!(F::UpdatableGivensQR, X::AbstractMatrix, k::AbstractArray{Int} = (size(F, 2) + 1) : (size(F, 2) + size(X, 2)))"><pre><span class="pl-c1">add_column!</span>(F<span class="pl-k">::</span><span class="pl-c1">UpdatableGivensQR</span>, X<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix</span>, k<span class="pl-k">::</span><span class="pl-c1">AbstractArray{Int}</span> <span class="pl-k">=</span> (<span class="pl-c1">size</span>(F, <span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">:</span> (<span class="pl-c1">size</span>(F, <span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">size</span>(X, <span class="pl-c1">2</span>)))</pre></div>
<p dir="auto">By default, both functions append the columns to the factorization.
If a different column ordering is desired, the index at which the columns should be added can be passed as the third argument.</p>
<h3 dir="auto"><a id="user-content-column-removal" class="anchor" aria-hidden="true" href="#column-removal"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Column Removal</h3>
<p dir="auto">To remove columns from a factorization, use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="remove_column!(F::UpdatableGivensQR, k::Int = size(F, 2))"><pre><span class="pl-c1">remove_column!</span>(F<span class="pl-k">::</span><span class="pl-c1">UpdatableGivensQR</span>, k<span class="pl-k">::</span><span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">size</span>(F, <span class="pl-c1">2</span>))</pre></div>
<p dir="auto">Updates the existing QR factorization <code>F</code> of a matrix to the factorization of
the same matrix after its kᵗʰ column has been deleted.
Computational complexity: <code>O(m²)</code> where <code>size(F) = (n, m)</code>.</p>
<h2 dir="auto"><a id="user-content-on-efficiency" class="anchor" aria-hidden="true" href="#on-efficiency"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>On Efficiency</h2>
<p dir="auto">First, note that the goal of this package is primarily to allow for the efficient updating of QR factorizations.
It is hard to beat <code>stdlib</code>'s <code>qr</code>, which links to LAPACK, for a factorization from scratch.
For a representative performance on a dual core 13'' MacBook Pro from 2017 for a moderately sized problem, see the following:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n, m = 1_000, 128;
A = randn(n, m);
b = randn(n);

@time F = UpdatableQR(A, 2m);
  0.018699 seconds (10 allocations: 10.241 MiB)
  
@time add_column!(F, b);
  0.000635 seconds (1 allocation: 1.141 KiB)
  
@time qr(A);
  0.006914 seconds (7 allocations: 1.047 MiB)

@time qr!(A);
  0.003037 seconds (5 allocations: 72.188 KiB)"><pre>n, m <span class="pl-k">=</span> <span class="pl-c1">1_000</span>, <span class="pl-c1">128</span>;
A <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, m);
b <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n);

<span class="pl-c1">@time</span> F <span class="pl-k">=</span> <span class="pl-c1">UpdatableQR</span>(A, <span class="pl-c1">2</span>m);
  <span class="pl-c1">0.018699</span> seconds (<span class="pl-c1">10</span> allocations<span class="pl-k">:</span> <span class="pl-c1">10.241</span> MiB)
  
<span class="pl-c1">@time</span> <span class="pl-c1">add_column!</span>(F, b);
  <span class="pl-c1">0.000635</span> seconds (<span class="pl-c1">1</span> allocation<span class="pl-k">:</span> <span class="pl-c1">1.141</span> KiB)
  
<span class="pl-c1">@time</span> <span class="pl-c1">qr</span>(A);
  <span class="pl-c1">0.006914</span> seconds (<span class="pl-c1">7</span> allocations<span class="pl-k">:</span> <span class="pl-c1">1.047</span> MiB)

<span class="pl-c1">@time</span> <span class="pl-c1">qr!</span>(A);
  <span class="pl-c1">0.003037</span> seconds (<span class="pl-c1">5</span> allocations<span class="pl-k">:</span> <span class="pl-c1">72.188</span> KiB)</pre></div>
<p dir="auto">Notably, <code>qr</code> is three times faster than <code>UpdatableQR</code> in constructing a factorization from scratch, but is significantly
slower than the addition of a single column, which is not supported by <code>qr</code> and would require a second factorization from scratch.</p>
<h2 dir="auto"><a id="user-content-on-scalability" class="anchor" aria-hidden="true" href="#on-scalability"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>On Scalability</h2>
<p dir="auto">The implementation contained herein represents Q implicitly by keeping track of the Givens rotations that constitute it,
allowing a scaling to very high <code>n</code> and moderate <code>m</code>.
This is in contrast to an existing implementation of updatable QR factorizations in <a href="https://github.com/oxfordcontrol/GeneralQP.jl/blob/master/src/linear_algebra.jl">GeneralQP.jl</a>,
which keeps the <code>n</code> by <code>n</code> Q matrix densely in memory and updates it upon column addition, prohibiting scaling to problems where <code>n</code> is large regardless of the number of columns <code>m</code>.</p>
<p dir="auto">In fact, on the same laptop as before, we can compute an updatable QR factorization in 1,000,000 dimensions in under a minute:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="n, m = 1_000_000, 128;
A = randn(n, m);
@time F = UpdatableQR(A, 2m);
39.086453 seconds (10 allocations: 10.490 GiB, 0.74% gc time)"><pre>n, m <span class="pl-k">=</span> <span class="pl-c1">1_000_000</span>, <span class="pl-c1">128</span>;
A <span class="pl-k">=</span> <span class="pl-c1">randn</span>(n, m);
<span class="pl-c1">@time</span> F <span class="pl-k">=</span> <span class="pl-c1">UpdatableQR</span>(A, <span class="pl-c1">2</span>m);
<span class="pl-c1">39.086453</span> seconds (<span class="pl-c1">10</span> allocations<span class="pl-k">:</span> <span class="pl-c1">10.490</span> GiB, <span class="pl-c1">0.74</span><span class="pl-k">%</span> gc time)</pre></div>
<p dir="auto">It is also notable that contructing the QR factorization from scratch with <code>stdlib</code>'s <code>qr</code> is again much faster</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@time qr(A);
  3.363778 seconds (112.75 k allocations: 983.465 MiB, 1.77% gc time, 1.34% compilation time).
 
@time qr!(A);
  3.058636 seconds (5 allocations: 72.188 KiB)"><pre><span class="pl-c1">@time</span> <span class="pl-c1">qr</span>(A);
  <span class="pl-c1">3.363778</span> seconds (<span class="pl-c1">112.75</span> k allocations<span class="pl-k">:</span> <span class="pl-c1">983.465</span> MiB, <span class="pl-c1">1.77</span><span class="pl-k">%</span> gc time, <span class="pl-c1">1.34</span><span class="pl-k">%</span> compilation time)<span class="pl-k">.</span>
 
<span class="pl-c1">@time</span> <span class="pl-c1">qr!</span>(A);
  <span class="pl-c1">3.058636</span> seconds (<span class="pl-c1">5</span> allocations<span class="pl-k">:</span> <span class="pl-c1">72.188</span> KiB)</pre></div>
<p dir="auto">However, subsequent addition of single columns beats calculating a factorization from scratch, even with the very efficient <code>qr</code></p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@time add_column!(F, b);
  0.599013 seconds (1 allocation: 1.141 KiB)"><pre><span class="pl-c1">@time</span> <span class="pl-c1">add_column!</span>(F, b);
  <span class="pl-c1">0.599013</span> seconds (<span class="pl-c1">1</span> allocation<span class="pl-k">:</span> <span class="pl-c1">1.141</span> KiB)</pre></div>
<p dir="auto">Future work on this package could improve on the performance difference between <code>qr</code> and <code>UpdatableQR</code> for a factorization from scratch.</p>
<h2 dir="auto"><a id="user-content-limitations" class="anchor" aria-hidden="true" href="#limitations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Limitations</h2>
<p dir="auto">At this point, UpdatableQRFactorizations.jl only supports factorizations of matrices with full column rank.
Further, no specialization for sparse matrices has been implemented, which might significantly improve performance in cases where sparsity is present.</p>
</article></div>