<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p align="center">
  <a target="_blank" rel="noopener noreferrer" href="./docs/src/assets/logo.png"><img src="./docs/src/assets/logo.png" alt="DirectSum.jl" style="max-width:100%;"></a>
</p>
<h1><a id="user-content-adapodejl" class="anchor" aria-hidden="true" href="#adapodejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Adapode.jl</h1>
<p><em>Adaptive multistep numerical ODE solver based on <a href="https://github.com/chakravala/Grassmann.jl">Grassmann.jl</a> element assembly</em></p>
<p><a href="https://zenodo.org/badge/latestdoi/223493781" rel="nofollow"><img src="https://camo.githubusercontent.com/4784b95ffdef2e53d627883046dc6682645c6d2d/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3232333439333738312e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/223493781.svg" style="max-width:100%;"></a>
<a href="https://grassmann.crucialflow.com/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/f7b92a177c912c1cc007fc9b40f17ff3ee3bb414/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Docs Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a>
<a href="https://grassmann.crucialflow.com/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/3e353c26ddfe819150acbc732248f4f2a37f5175/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Docs Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width:100%;"></a>
<a href="https://gitter.im/Grassmann-jl/community?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge" rel="nofollow"><img src="https://camo.githubusercontent.com/d8f28765f835be1a8faf096e59ca4e62de18fcc9/68747470733a2f2f6261646765732e6769747465722e696d2f47726173736d616e6e2d6a6c2f636f6d6d756e6974792e737667" alt="Gitter" data-canonical-src="https://badges.gitter.im/Grassmann-jl/community.svg" style="max-width:100%;"></a>
<a href="https://travis-ci.org/chakravala/Adapode.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a1983315cd296bb19a68efe5b6dde5df802181dd/68747470733a2f2f7472617669732d63692e6f72672f6368616b726176616c612f416461706f64652e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/chakravala/Adapode.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/chakravala/adapode-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c070b3c4f659c1f32fc0c5902874f9bcd7a32841/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f77707534337139326f303661666930613f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/wpu43q92o06afi0a?svg=true" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/chakravala/Adapode.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/1c5af0b2fb6c538b950d7c1b0bfc7551403a7868/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6368616b726176616c612f416461706f64652e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/chakravala/Adapode.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a>
<a href="https://codecov.io/github/chakravala/Adapode.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/3fbac0d51b3e2f60da2198b9104b9795ea075b02/68747470733a2f2f636f6465636f762e696f2f6769746875622f6368616b726176616c612f416461706f64652e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="https://codecov.io/github/chakravala/Adapode.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>This Julia project originally started as a FORTRAN 95 project called <a href="https://github.com/chakravala/adapode">adapode</a>.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-k">using</span> Grassmann, Adapode, Makie
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">basis</span>"</span>4<span class="pl-pds">"</span></span>; x0 <span class="pl-k">=</span> <span class="pl-c1">10.0</span>v2<span class="pl-k">+</span><span class="pl-c1">10.0</span>v3<span class="pl-k">+</span><span class="pl-c1">10.0</span>v4
<span class="pl-en">Lorenz</span>(x<span class="pl-k">::</span><span class="pl-c1">Chain{V}</span>) <span class="pl-k">where</span> V <span class="pl-k">=</span> <span class="pl-c1">Chain</span><span class="pl-c1">{V,1}</span>(
	<span class="pl-c1">1.0</span>,
	<span class="pl-c1">10.0</span>(x[<span class="pl-c1">3</span>]<span class="pl-k">-</span>x[<span class="pl-c1">2</span>]),
	x[<span class="pl-c1">2</span>]<span class="pl-k">*</span>(<span class="pl-c1">28.0</span><span class="pl-k">-</span>x[<span class="pl-c1">4</span>])<span class="pl-k">-</span>x[<span class="pl-c1">3</span>],
	x[<span class="pl-c1">2</span>]<span class="pl-k">*</span>x[<span class="pl-c1">3</span>]<span class="pl-k">-</span>(<span class="pl-c1">8</span><span class="pl-k">/</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>x[<span class="pl-c1">4</span>])
<span class="pl-c1">lines</span>(<span class="pl-c1">Point</span>.((<span class="pl-c1">V</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>)).(<span class="pl-c1">odesolve</span>(Lorenz,x0))))</pre></div>
<p>It is possible to work with L2 projection on a mesh with</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">L2Projector</span>(t,f;args<span class="pl-k">...</span>) <span class="pl-k">=</span> <span class="pl-c1">mesh</span>(t,color<span class="pl-k">=</span><span class="pl-k">\</span>(<span class="pl-c1">assemblemassfunction</span>(t,f)<span class="pl-k">...</span>);args<span class="pl-k">...</span>)
<span class="pl-c1">L2Projector</span>(<span class="pl-c1">initmesh</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">:</span><span class="pl-c1">1</span>)[<span class="pl-c1">3</span>],x<span class="pl-k">-&gt;</span>x[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-c1">sin</span>(x[<span class="pl-c1">2</span>]))
<span class="pl-c1">L2Projector</span>(<span class="pl-c1">initmesh</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">:</span><span class="pl-c1">1</span>)[<span class="pl-c1">3</span>],x<span class="pl-k">-&gt;</span><span class="pl-c1">2</span>x[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-c1">sin</span>(<span class="pl-c1">2</span>π<span class="pl-k">*</span>x[<span class="pl-c1">2</span>])<span class="pl-k">+</span><span class="pl-c1">3</span>)</pre></div>
<p>Partial differential equations can also be assembled with various additional methods:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-en">PoissonSolver</span>(p,e,t,c,f,κ,gD<span class="pl-k">=</span><span class="pl-c1">1</span>,gN<span class="pl-k">=</span><span class="pl-c1">0</span>) <span class="pl-k">=</span> <span class="pl-c1">mesh</span>(t,color<span class="pl-k">=</span><span class="pl-c1">solvepoisson</span>(t,e,c,f,κ,gD,gN))
<span class="pl-k">function</span> <span class="pl-en">solvepoisson</span>(t,e,c,f,κ,gD<span class="pl-k">=</span><span class="pl-c1">0</span>,gN<span class="pl-k">=</span><span class="pl-c1">0</span>)
    m <span class="pl-k">=</span> <span class="pl-c1">detsimplex</span>(t)
    b <span class="pl-k">=</span> <span class="pl-c1">assemblefunction</span>(t,f,m)
    A <span class="pl-k">=</span> <span class="pl-c1">assemblestiffness</span>(t,c,m)
    R,r <span class="pl-k">=</span> <span class="pl-c1">assemblerobin</span>(e,κ,gD,gN)
    <span class="pl-k">return</span> (A<span class="pl-k">+</span>R)<span class="pl-k">\</span>(b<span class="pl-k">+</span>r)
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">BackwardEulerHeat1D</span>()
    x,m <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0.01</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">100</span>; p,e,t <span class="pl-k">=</span> <span class="pl-c1">initmesh</span>(x)
    T <span class="pl-k">=</span> <span class="pl-c1">range</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0.5</span>,length<span class="pl-k">=</span>m<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">#</span> time grid</span>
    ξ <span class="pl-k">=</span> <span class="pl-c1">0.5</span><span class="pl-k">.-</span><span class="pl-c1">abs</span>.(<span class="pl-c1">0.5</span><span class="pl-k">.-</span>x) <span class="pl-c"><span class="pl-c">#</span> initial condition</span>
    A <span class="pl-k">=</span> <span class="pl-c1">assemblestiffness</span>(t) <span class="pl-c"><span class="pl-c">#</span> assemble(t,1,2x)</span>
    M,b <span class="pl-k">=</span> <span class="pl-c1">assemblemassfunction</span>(t,<span class="pl-c1">2</span>x)<span class="pl-k">.+</span><span class="pl-c1">assemblerobin</span>(e,<span class="pl-c1">1e6</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>)
    h <span class="pl-k">=</span> <span class="pl-c1">Float64</span>(T<span class="pl-k">.</span>step); LHS <span class="pl-k">=</span> M<span class="pl-k">+</span>h<span class="pl-k">*</span>A <span class="pl-c"><span class="pl-c">#</span> time step</span>
    <span class="pl-k">for</span> l <span class="pl-k">∈</span> <span class="pl-c1">1</span><span class="pl-k">:</span>m
        ξ <span class="pl-k">=</span> LHS<span class="pl-k">\</span>(M<span class="pl-k">*</span>ξ<span class="pl-k">+</span>h<span class="pl-k">*</span>b); l<span class="pl-k">%</span><span class="pl-c1">10</span><span class="pl-k">==</span><span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">println</span>(l<span class="pl-k">*</span>h)
    <span class="pl-k">end</span>
    <span class="pl-c1">mesh</span>(t,color<span class="pl-k">=</span>ξ)
<span class="pl-k">end</span>
<span class="pl-k">function</span> <span class="pl-en">PoissonAdaptive</span>(g,p,e,t,c<span class="pl-k">=</span><span class="pl-c1">1</span>,a<span class="pl-k">=</span><span class="pl-c1">0</span>,f<span class="pl-k">=</span><span class="pl-c1">1</span>)
    ϵ <span class="pl-k">=</span> <span class="pl-c1">1.0</span>
    <span class="pl-k">while</span> ϵ <span class="pl-k">&gt;</span> <span class="pl-c1">5e-5</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">length</span>(t) <span class="pl-k">&lt;</span> <span class="pl-c1">10000</span>
        m <span class="pl-k">=</span> <span class="pl-c1">detsimplex</span>(t)
        h <span class="pl-k">=</span> <span class="pl-c1">gradienthat</span>(t,m)
        A,M,b <span class="pl-k">=</span> <span class="pl-c1">assemble</span>(t,c,a,f,m,h)
        ξ <span class="pl-k">=</span> <span class="pl-c1">solvedirichlet</span>(A<span class="pl-k">+</span>M,b,e)
        η <span class="pl-k">=</span> <span class="pl-c1">jumps</span>(t,c,a,f,ξ,m,h)
        scene <span class="pl-k">=</span> <span class="pl-c1">mesh</span>(t,color<span class="pl-k">=</span>ξ,shading<span class="pl-k">=</span><span class="pl-c1">false</span>); <span class="pl-c1">display</span>(scene)
        <span class="pl-k">if</span> <span class="pl-c1">typeof</span>(g)<span class="pl-k">&lt;:</span><span class="pl-c1">AbstractRange</span>
            <span class="pl-c1">scatter!</span>(p,ξ,markersize<span class="pl-k">=</span><span class="pl-c1">0.01</span>)
        <span class="pl-k">else</span>
            <span class="pl-c1">wireframe!</span>(scene[<span class="pl-c1">end</span>][<span class="pl-c1">1</span>],color<span class="pl-k">=</span>(<span class="pl-c1">:red</span>,<span class="pl-c1">0.6</span>),linewidth<span class="pl-k">=</span><span class="pl-c1">3</span>)
        <span class="pl-k">end</span>
        ϵ <span class="pl-k">=</span> <span class="pl-c1">sqrt</span>(<span class="pl-c1">norm</span>(η)<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">/</span><span class="pl-c1">length</span>(η))
        <span class="pl-c1">println</span>(t,<span class="pl-s"><span class="pl-pds">"</span>, ϵ=$ϵ, α=<span class="pl-v">$(ϵ<span class="pl-k">/</span><span class="pl-c1">maximum</span>(η))</span><span class="pl-pds">"</span></span>); <span class="pl-c1">sleep</span>(<span class="pl-c1">0.5</span>)
        <span class="pl-c1">refinemesh!</span>(g,p,e,t,<span class="pl-c1">select</span>(η,ϵ),<span class="pl-s"><span class="pl-pds">"</span>regular<span class="pl-pds">"</span></span>)
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> g,p,e,t
<span class="pl-k">end</span>
<span class="pl-c1">PoissonAdaptive</span>(<span class="pl-c1">refinemesh</span>(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0.25</span><span class="pl-k">:</span><span class="pl-c1">1</span>)<span class="pl-k">...</span>,<span class="pl-c1">1</span>,<span class="pl-c1">0</span>,x<span class="pl-k">-&gt;</span><span class="pl-c1">exp</span>(<span class="pl-k">-</span><span class="pl-c1">100</span><span class="pl-c1">abs2</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">-</span><span class="pl-c1">0.5</span>)))</pre></div>
<p>More general problems for finite element boundary value problems are also enabled by mesh representations imported from external sources. These methods can automatically generalize to higher dimensional manifolds and is compatible with discrete differential geometry.</p>
</article></div>