<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><p><a href="https://travis-ci.org/tbreloff/QuickStructs.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/b4818b69ef04c187c1db5d172dc0e4d76a54bb54/68747470733a2f2f7472617669732d63692e6f72672f746272656c6f66662f517569636b537472756374732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/tbreloff/QuickStructs.jl.svg?branch=master" style="max-width:100%;"></a></p>
<h1><a id="user-content-quickstructs" class="anchor" aria-hidden="true" href="#quickstructs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>QuickStructs</h1>
<h3><a id="user-content-singlylinkedlist-and-doublylinkedlist" class="anchor" aria-hidden="true" href="#singlylinkedlist-and-doublylinkedlist"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SinglyLinkedList and DoublyLinkedList</h3>
<p>These are intended for efficient sorted insertion/deletion of a <code>SLLNode</code> and <code>DLLNode</code>.  Coupled with a hash to the node itself, deletion and search can be O(1) operations, while insertion is O(1) for a prespecified location, and at worst O(n) for sorted insertion.</p>
<p>Note: <code>push!</code> isn't defined for SinglyLinkedList to reiterate that inserting at the end of the list is O(n), and in this case DoublyLinkedList should be used instead, which is more flexible at the cost of a slight increase in memory usage and complexity.</p>
<h3><a id="user-content-circularbuffer-and-rollingwindow" class="anchor" aria-hidden="true" href="#circularbuffer-and-rollingwindow"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CircularBuffer and RollingWindow</h3>
<p>CircularBuffer is just a ring buffer with parametric type with idiomatic <code>push!</code> and iteration.  RollingWindow sits on top of Circular buffer to retain lags of a time series.  Create with a fixed <code>IntIterable</code>, which is a range or vector of Ints.  Extract lagged values into a <code>Vector{T}</code> using <code>toarray(window)</code>.</p>
</article></div>