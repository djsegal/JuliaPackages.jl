<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-pdesolver" class="anchor" aria-hidden="true" href="#pdesolver"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PDESolver</h1>
<p>PDESolver is a multi-physics solver primarily focused on Computational Fluid
Dynamics.  It has been designed from ground up to support optimization,
robust simulation, and parallel scalability.</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p>The obtain this package, do <code>Pkg.clone(url)</code>, then <code>Pkg.build("PDESolver")</code>.  This will install all dependences, including those not listed in Metadata.</p>
<p>The dependencies not listed in Metadata are:</p>
<p>ODLCommonTools</p>
<p>SummationByParts</p>
<p>PumiInterface</p>
<p>Petsc</p>
<p>PumiInterface and Petsc are the only packages with non-trivial installation requirements, although for most cases the defaults will work just fine.</p>
<p>See those packages for details.</p>
<h2><a id="user-content-developer-guide" class="anchor" aria-hidden="true" href="#developer-guide"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Developer Guide</h2>
<p>The abstraction hierarchy of the code is described in two documents.
<code>doc/interfaces.md</code> describes the required implementation and rationale for
the <code>AbstractMesh</code> and <code>AbstractSolutionData</code> types, as well as how different
parts of the code interact (ie. how the NonlinearSolvers interact with the
physics modules etc.).  <code>src/Readme.md</code> describes the user-facing interface
for the physics modules as well as what functions each physics module must
implement in order to be usable.</p>
<p>The code is organized as follows:</p>
<p>The code for evaluating the residual for an equation is in the src/solver directory.<br>
There are subdirectories for each physics.  Currently src/solver/euler is the most well developed physics.</p>
<p>The NonlinarSolvers module (<code>src/NonlinearSolvers</code>) implements both
time stepping methods for unsteady equations and non-linear root finding methods for steady problems.</p>
<p>The Utils module (<code>src/Utils</code>) contains auxiliary functions used by all
physics modules.</p>
<p>The Input module (<code>src/input</code>) parses input files, provides default values,
and checks for unrecognized keys.  <code>src/input/input_vals.txt</code> lists all
possible user-supplied keys. <code>src/input/input_vals_internal.txt</code> list keys
used internally by the solver.  Users should never specify these keys in an
input file.</p>
<p>The <code>src/mesh_files</code> contains meshes used by the tests.  Please use the
smallest meshes possible for tests.</p>
<p>The directory <code>src/simple_mesh</code> contains the files to create simple structured meshes.</p>
<p>The file <code>src/estimateMem.jl</code> reads the file counts.txt, which is written by the mesh initialization, and estimates the steady state memory usage of the solver.
While this is not an upper bounds, it has proven to be quite accurate.  It does not include memory used by any factorizations the linear solver might do.</p>
<h2><a id="user-content-visualization" class="anchor" aria-hidden="true" href="#visualization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Visualization</h2>
<p>Paraview is used for visualization.  High order elements (p&gt;2) are automatically
interpolated onto either a linear or quadratic mesh for visualization.
Empirically, this has been shown to produce better images than
sub-triangulating each element and doing an exact projection onto the finer
mesh.</p>
<h1><a id="user-content-version-history" class="anchor" aria-hidden="true" href="#version-history"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Version History</h1>
<ul>
<li>
<p>v0.1: the old master version (DG supported, I think)</p>
</li>
<li>
<p>v0.2: the work branch after the test system/frontend rewrite</p>
</li>
<li>
<p>v0.3: curvilinear entropy stable works (requires PumiInterface v0.3, SBP tag ticon_broken)</p>
</li>
<li>
<p>v0.4: curvilinear works (both entropy stable and Roe scheme)
introduced AbstractLinearOperator, AbstractPreconditioner, LinearSolver abstractions, Changed MPI initialization/finalization (PETSc too)</p>
</li>
<li>
<p>v0.5: add checkpointing, Linear solver/operator/preconditioner abstraction, explicit jacobian calculation,
more reliable MPI/PETSc initialization and finalization</p>
</li>
<li>
<p>v0.6: upgrade from Julia 0.4 to 0.6</p>
</li>
<li>
<p>v0.7: functional and residual reverse mode, serial and parallel</p>
</li>
<li>
<p>v0.8: add shock capturing, adjoint based error estimation, preliminary
h-adaptation, Local Projection stabilization, p-homotopy method for
solving high order shock problems, several steady examples</p>
</li>
</ul>
<p>Master branch:
<a href="https://travis-ci.org/OptimalDesignLab/PDESolver.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/cc0f17965c097a862604c34bc015f79040da243c/68747470733a2f2f7472617669732d63692e6f72672f4f7074696d616c44657369676e4c61622f504445536f6c7665722e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/OptimalDesignLab/PDESolver.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p>Work branch:
<a href="https://travis-ci.org/OptimalDesignLab/PDESolver.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a06b6a6af68bfb7d17a66c8b783e8a55f7b29f9f/68747470733a2f2f7472617669732d63692e6f72672f4f7074696d616c44657369676e4c61622f504445536f6c7665722e6a6c2e7376673f6272616e63683d776f726b" alt="Build Status" data-canonical-src="https://travis-ci.org/OptimalDesignLab/PDESolver.jl.svg?branch=work" style="max-width:100%;"></a></p>
<p>#<a href="https://codecov.io/gh/OptimalDesignLab/PDESolver.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/11060f32c20352df8f4713c423411bcb0455d900/68747470733a2f2f636f6465636f762e696f2f67682f4f7074696d616c44657369676e4c61622f504445536f6c7665722e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/OptimalDesignLab/PDESolver.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a>
<a href="http://www.optimaldesignlab.com/PDESolver.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/f7b92a177c912c1cc007fc9b40f17ff3ee3bb414/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width:100%;"></a></p>
</article></div>