<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-tracefunsjl" class="anchor" aria-hidden="true" href="#tracefunsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>TraceFuns.jl</h1>
<p dir="auto">The <code>trace</code> facility of Common Lisp has always been my favourite tool
for debugging or interactively exploring a code base. Yet, it seems to
be missing in almost any other language. Fortunately, the overdub
mechanism of <a href="https://github.com/JuliaLabs/Cassette.jl">Cassette.jl</a>
allows method tracing for Julia rather easily and here it is ...</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="help?&gt; @trace
  @trace expr [funs...]

  Trace all calls of the listed funs during evaluation of expr. If funs includes the symbol :all all function calls are traced.

  Examples
  ≡≡≡≡≡≡≡≡≡≡

  julia&gt; @trace 1 + 2 Base.:+
  0: +(1, 2) -- Method +(x::T, y::T) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:87
  0: +(1, 2) -&gt; 3
  3

  Be careful using :all as the output may be long ...
          
  julia&gt; @trace 1 * 2.0 :all
  0: *(1, 2.0) -- Method *(x::Number, y::Number) in Base at promotion.jl:380
     1: promote(1, 2.0) -- Method promote(x, y) in Base at promotion.jl:348
        ... long output clipped ...
     1: promote(1, 2.0) -&gt; (1.0, 2.0)
     1: *(1.0, 2.0) -- Method *(x::Float64, y::Float64) in Base at float.jl:405
         2: mul_float(1.0, 2.0) -- Primitive mul_float
         2: mul_float(1.0, 2.0) -&gt; 2.0
     1: *(1.0, 2.0) -&gt; 2.0
  0: *(1, 2.0) -&gt; 2.0
  2.0

  Tracing nicely illustrates recursive functions
      
  julia&gt; fibo(n::Integer) = if n &lt; 2 1 else fibo(n-1) + fibo(n-2) end
  fibo (generic function with 1 method)

  julia&gt; @trace fibo(3) fibo
  0: fibo(3) -- Method fibo(n::Integer) in Main at REPL[6]:1
     1: fibo(2) -- Method fibo(n::Integer) in Main at REPL[6]:1
         2: fibo(1) -- Method fibo(n::Integer) in Main at REPL[6]:1
         2: fibo(1) -&gt; 1
         2: fibo(0) -- Method fibo(n::Integer) in Main at REPL[6]:1
         2: fibo(0) -&gt; 1
     1: fibo(2) -&gt; 2
     1: fibo(1) -- Method fibo(n::Integer) in Main at REPL[6]:1
     1: fibo(1) -&gt; 1
  0: fibo(3) -&gt; 3
  3"><pre>help?<span class="pl-k">&gt;</span> <span class="pl-c1">@trace</span>
  <span class="pl-c1">@trace</span> expr [funs<span class="pl-k">...</span>]

  Trace all calls of the listed funs during evaluation of expr. If funs includes the symbol <span class="pl-c1">:all</span> all <span class="pl-k">function</span> calls are traced.

  Examples
  <span class="pl-k">≡≡≡≡≡≡≡≡≡≡</span>

  julia<span class="pl-k">&gt;</span> <span class="pl-c1">@trace</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2</span> Base.:<span class="pl-k">+</span>
  <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-k">+</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) <span class="pl-k">--</span> Method <span class="pl-k">+</span>(x<span class="pl-k">::</span><span class="pl-c1">T</span>, y<span class="pl-k">::</span><span class="pl-c1">T</span>) <span class="pl-k">where</span> T<span class="pl-k">&lt;:</span><span class="pl-c1">Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}</span> <span class="pl-k">in</span> Base at int<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">87</span>
  <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-k">+</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">3</span>
  <span class="pl-c1">3</span>

  Be careful <span class="pl-k">using</span> <span class="pl-c1">:all</span> <span class="pl-k">as</span> the output may be long <span class="pl-k">...</span>
          
  julia<span class="pl-k">&gt;</span> <span class="pl-c1">@trace</span> <span class="pl-c1">1</span> <span class="pl-k">*</span> <span class="pl-c1">2.0</span> <span class="pl-c1">:all</span>
  <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-k">*</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">--</span> Method <span class="pl-k">*</span>(x<span class="pl-k">::</span><span class="pl-c1">Number</span>, y<span class="pl-k">::</span><span class="pl-c1">Number</span>) <span class="pl-k">in</span> Base at promotion<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">380</span>
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-c1">promote</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">--</span> Method <span class="pl-c1">promote</span>(x, y) <span class="pl-k">in</span> Base at promotion<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">348</span>
        <span class="pl-k">...</span> long output clipped <span class="pl-k">...</span>
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-c1">promote</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">-&gt;</span> (<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>)
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-k">*</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">--</span> Method <span class="pl-k">*</span>(x<span class="pl-k">::</span><span class="pl-c1">Float64</span>, y<span class="pl-k">::</span><span class="pl-c1">Float64</span>) <span class="pl-k">in</span> Base at float<span class="pl-k">.</span>jl<span class="pl-k">:</span><span class="pl-c1">405</span>
         <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-c1">mul_float</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">--</span> Primitive mul_float
         <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-c1">mul_float</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">2.0</span>
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-k">*</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">2.0</span>
  <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-k">*</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2.0</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">2.0</span>
  <span class="pl-c1">2.0</span>

  Tracing nicely illustrates recursive functions
      
  julia<span class="pl-k">&gt;</span> <span class="pl-en">fibo</span>(n<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-k">=</span> <span class="pl-k">if</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span> <span class="pl-k">else</span> <span class="pl-c1">fibo</span>(n<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">fibo</span>(n<span class="pl-k">-</span><span class="pl-c1">2</span>) <span class="pl-k">end</span>
  fibo (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

  julia<span class="pl-k">&gt;</span> <span class="pl-c1">@trace</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">3</span>) fibo
  <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">3</span>) <span class="pl-k">--</span> Method <span class="pl-c1">fibo</span>(n<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-k">in</span> Main at REPL[<span class="pl-c1">6</span>]<span class="pl-k">:</span><span class="pl-c1">1</span>
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">2</span>) <span class="pl-k">--</span> Method <span class="pl-c1">fibo</span>(n<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-k">in</span> Main at REPL[<span class="pl-c1">6</span>]<span class="pl-k">:</span><span class="pl-c1">1</span>
         <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">1</span>) <span class="pl-k">--</span> Method <span class="pl-c1">fibo</span>(n<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-k">in</span> Main at REPL[<span class="pl-c1">6</span>]<span class="pl-k">:</span><span class="pl-c1">1</span>
         <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">1</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">1</span>
         <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">0</span>) <span class="pl-k">--</span> Method <span class="pl-c1">fibo</span>(n<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-k">in</span> Main at REPL[<span class="pl-c1">6</span>]<span class="pl-k">:</span><span class="pl-c1">1</span>
         <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">0</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">1</span>
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">2</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">2</span>
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">1</span>) <span class="pl-k">--</span> Method <span class="pl-c1">fibo</span>(n<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-k">in</span> Main at REPL[<span class="pl-c1">6</span>]<span class="pl-k">:</span><span class="pl-c1">1</span>
     <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">1</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">1</span>
  <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-c1">fibo</span>(<span class="pl-c1">3</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">3</span>
  <span class="pl-c1">3</span></pre></div>
<h2 dir="auto"><a id="user-content-known-issues" class="anchor" aria-hidden="true" href="#known-issues"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Known issues</h2>
<ul dir="auto">
<li>Tracing functions with keyword arguments is currently tricky, i.e.,
<code>@trace reduce(+, 1:2; init=0) reduce</code> will not show any trace
output and <code>@trace reduce(+, 1:2; init=0) Base.var"#reduce##kw".instance</code> is needed instead to see the
corresponding calls.</li>
</ul>
</article></div>