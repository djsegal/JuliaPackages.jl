<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-namedarrays" class="anchor" aria-hidden="true" href="#namedarrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>NamedArrays</h1>
<p>Julia type that implements a drop-in wrapper for <code>AbstractArray</code> type, providing named indices and dimensions.</p>
<p><a href="https://travis-ci.org/davidavdav/NamedArrays.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/2b565eb2e981e6830b5b6061e933077b7e76084769dd63bd9f181a21358c12ef/68747470733a2f2f7472617669732d63692e6f72672f646176696461766461762f4e616d65644172726179732e6a6c2e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/davidavdav/NamedArrays.jl.svg" style="max-width:100%;"></a>
<a href="http://pkg.julialang.org/?pkg=NamedArrays" rel="nofollow"><img src="https://camo.githubusercontent.com/aa873d358c430e3f38c91a1819b60b0044856e69d90f30d8edf6df43fb0550d6/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f4e616d65644172726179735f302e352e737667" alt="NamedArrays" data-canonical-src="http://pkg.julialang.org/badges/NamedArrays_0.5.svg" style="max-width:100%;"></a>
<a href="http://pkg.julialang.org/?pkg=NamedArrays" rel="nofollow"><img src="https://camo.githubusercontent.com/84f99a5583633a24c1fee2e44df3b0c16f2646829da4177f788b96e24a7b65bf/687474703a2f2f706b672e6a756c69616c616e672e6f72672f6261646765732f4e616d65644172726179735f302e362e737667" alt="NamedArrays" data-canonical-src="http://pkg.julialang.org/badges/NamedArrays_0.6.svg" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/davidavdav/NamedArrays.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/9ef5a2d448ffe6c209bd9cb6ac583c9935ff5d6ad76a31c209d263201e87cd41/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f646176696461766461762f4e616d65644172726179732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/davidavdav/NamedArrays.jl/badge.svg?branch=master" style="max-width:100%;"></a></p>
<h2><a id="user-content-idea" class="anchor" aria-hidden="true" href="#idea"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Idea</h2>
<p>We would want to have the possibility to give each row/column/... in
an Array names, as well as the array dimensions themselves.  This
could be used for pretty-printing, indexing, and perhaps even some
sort of dimension-checking in certain matrix computations.</p>
<p>In all other respects, a <code>NamedArray</code> should behave the same as the underlying <code>AbstractArray</code>.</p>
<p>A <code>NamedArray</code> should adhere to the <a href="https://docs.julialang.org/en/latest/manual/interfaces/#man-interface-array-1" rel="nofollow">interface definition</a> of an <code>AbstractArray</code> itself, if there are cases where this is not true, these should be considered bugs in the implementation of <code>NamedArrays</code>.</p>
<h2><a id="user-content-synopsis" class="anchor" aria-hidden="true" href="#synopsis"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Synopsis</h2>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using NamedArrays
n = NamedArray(rand(2,4))
@show n;

n = 2×4 Named Array{Float64,2}
A ╲ B │         1          2          3          4
──────┼───────────────────────────────────────────
1     │  0.833541   0.409606   0.203789   0.724494
2     │  0.458244   0.908721   0.808201  0.0580882

setnames!(n, [&quot;one&quot;, &quot;two&quot;], 1)         # give the names &quot;one&quot; and &quot;two&quot; to the rows (dimension 1)
n[&quot;one&quot;, 2:3]
n[&quot;two&quot;, :] = 11:14
n[Not(&quot;two&quot;), :] = 4:7                  # all rows but the one called &quot;two&quot;
@show n;

n = 2×4 Named Array{Float64,2}
A ╲ B │    1     2     3     4
──────┼───────────────────────
one   │  4.0   5.0   6.0   7.0
two   │ 11.0  12.0  13.0  14.0

@show sum(n, dims=1);

sum(n, dims=1) = 1×4 Named Array{Float64,2}
 A ╲ B │    1     2     3     4
───────┼───────────────────────
sum(A) │ 15.0  17.0  19.0  21.0
"><pre><span class="pl-k">using</span> NamedArrays
n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>(<span class="pl-c1">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">4</span>))
<span class="pl-c1">@show</span> n;

n <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">4</span> Named Array{Float64,<span class="pl-c1">2</span>}
A ╲ B │         <span class="pl-c1">1</span>          <span class="pl-c1">2</span>          <span class="pl-c1">3</span>          <span class="pl-c1">4</span>
──────┼───────────────────────────────────────────
<span class="pl-c1">1</span>     │  <span class="pl-c1">0.833541</span>   <span class="pl-c1">0.409606</span>   <span class="pl-c1">0.203789</span>   <span class="pl-c1">0.724494</span>
<span class="pl-c1">2</span>     │  <span class="pl-c1">0.458244</span>   <span class="pl-c1">0.908721</span>   <span class="pl-c1">0.808201</span>  <span class="pl-c1">0.0580882</span>

<span class="pl-c1">setnames!</span>(n, [<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>], <span class="pl-c1">1</span>)         <span class="pl-c"><span class="pl-c">#</span> give the names "one" and "two" to the rows (dimension 1)</span>
n[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">3</span>]
n[<span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>, :] <span class="pl-k">=</span> <span class="pl-c1">11</span><span class="pl-k">:</span><span class="pl-c1">14</span>
n[<span class="pl-c1">Not</span>(<span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>), :] <span class="pl-k">=</span> <span class="pl-c1">4</span><span class="pl-k">:</span><span class="pl-c1">7</span>                  <span class="pl-c"><span class="pl-c">#</span> all rows but the one called "two"</span>
<span class="pl-c1">@show</span> n;

n <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">4</span> Named Array{Float64,<span class="pl-c1">2</span>}
A ╲ B │    <span class="pl-c1">1</span>     <span class="pl-c1">2</span>     <span class="pl-c1">3</span>     <span class="pl-c1">4</span>
──────┼───────────────────────
one   │  <span class="pl-c1">4.0</span>   <span class="pl-c1">5.0</span>   <span class="pl-c1">6.0</span>   <span class="pl-c1">7.0</span>
two   │ <span class="pl-c1">11.0</span>  <span class="pl-c1">12.0</span>  <span class="pl-c1">13.0</span>  <span class="pl-c1">14.0</span>

<span class="pl-c1">@show</span> <span class="pl-c1">sum</span>(n, dims<span class="pl-k">=</span><span class="pl-c1">1</span>);

<span class="pl-en">sum</span>(n, dims<span class="pl-k">=</span><span class="pl-c1">1</span>) <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">4</span> Named Array{Float64,<span class="pl-c1">2</span>}
 A ╲ B │    <span class="pl-c1">1</span>     <span class="pl-c1">2</span>     <span class="pl-c1">3</span>     <span class="pl-c1">4</span>
───────┼───────────────────────
<span class="pl-c1">sum</span>(A) │ <span class="pl-c1">15.0</span>  <span class="pl-c1">17.0</span>  <span class="pl-c1">19.0</span>  <span class="pl-c1">21.0</span></pre></div>
<h2><a id="user-content-construction" class="anchor" aria-hidden="true" href="#construction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Construction</h2>
<h3><a id="user-content-default-names-for-indices-and-dimensions" class="anchor" aria-hidden="true" href="#default-names-for-indices-and-dimensions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Default names for indices and dimensions</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# NamedArray(a::Array)
n = NamedArray([1 2; 3 4])
# NamedArray{T}(dims...)
n = NamedArray{Int}(2, 2)
"><pre><span class="pl-c"><span class="pl-c">#</span> NamedArray(a::Array)</span>
n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>([<span class="pl-c1">1</span> <span class="pl-c1">2</span>; <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c"><span class="pl-c">#</span> NamedArray{T}(dims...)</span>
n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span><span class="pl-c1">{Int}</span>(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)</pre></div>
<p>These constructors add default names to the array of type String, <code>"1"</code>,
<code>"2"</code>, ... for each dimension, and names the dimensions <code>:A</code>, <code>:B</code>,
... (which will be all right for 26 dimensions to start with; 26
dimensions should be enough for anyone:-).  The former initializes
the NamedArray with the Array <code>a</code>, the latter makes an uninitialized
NamedArray of element type <code>T</code> with the specified dimensions <code>dims...</code>.</p>
<h3><a id="user-content-lower-level-constructors" class="anchor" aria-hidden="true" href="#lower-level-constructors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lower level constructors</h3>
<p>The key-lookup for names is implemented by using <code>DataStructures.OrderedDict</code>s for each dimension.  At a lower level, you can construct <code>NamedArrays</code> this way:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="using DataStructures
n = NamedArray([1 3; 2 4], ( OrderedDict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2), OrderedDict(&quot;C&quot;=&gt;1, &quot;D&quot;=&gt;2) ),
               (&quot;Rows&quot;, &quot;Cols&quot;))
@show n;

n = 2×2 Named Array{Int64,2}
Rows ╲ Cols │ C  D
────────────┼─────
A           │ 1  3
B           │ 2  4
"><pre><span class="pl-k">using</span> DataStructures
n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>([<span class="pl-c1">1</span> <span class="pl-c1">3</span>; <span class="pl-c1">2</span> <span class="pl-c1">4</span>], ( <span class="pl-c1">OrderedDict</span>(<span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">2</span>), <span class="pl-c1">OrderedDict</span>(<span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span><span class="pl-k">=&gt;</span><span class="pl-c1">2</span>) ),
               (<span class="pl-s"><span class="pl-pds">"</span>Rows<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Cols<span class="pl-pds">"</span></span>))
<span class="pl-c1">@show</span> n;

n <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">2</span> Named Array{Int64,<span class="pl-c1">2</span>}
Rows ╲ Cols │ C  D
────────────┼─────
A           │ <span class="pl-c1">1</span>  <span class="pl-c1">3</span>
B           │ <span class="pl-c1">2</span>  <span class="pl-c1">4</span></pre></div>
<p>This is the basic constructor for a namedarray.  The second argument <code>names</code> must be a tuple of <code>OrderedDict</code>s whose range (the values) are exacly covering the range <code>1:size(a,dim)</code> for each dimension.   The keys in the various dictionaries may be of mixed types, but after construction, the type of the names cannot be altered.  The third argument <code>dimnames</code> is a tuple of the names of the dimensions themselves, and these names may be of any type.</p>
<h3><a id="user-content-vectors-of-names" class="anchor" aria-hidden="true" href="#vectors-of-names"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Vectors of names</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="# NamedArray{T,N}(a::AbstractArray{T,N}, names::NTuple{N,Vector}, dimnames::NTuple{N})
n = NamedArray([1 3; 2 4], ( [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;] ), (&quot;Rows&quot;, &quot;Cols&quot;))
# NamedArray{T,N}(a::AbstractArray{T,N}, names::NTuple{N,Vector})
n = NamedArray([1 3; 2 4], ( [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;] ))
n = NamedArray([1, 2], ( [&quot;a&quot;, &quot;b&quot;], ))  # note the comma after [&quot;a&quot;, &quot;b&quot;] to ensure evaluation as tuple
"><pre><span class="pl-c"><span class="pl-c">#</span> NamedArray{T,N}(a::AbstractArray{T,N}, names::NTuple{N,Vector}, dimnames::NTuple{N})</span>
n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>([<span class="pl-c1">1</span> <span class="pl-c1">3</span>; <span class="pl-c1">2</span> <span class="pl-c1">4</span>], ( [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>], [<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>] ), (<span class="pl-s"><span class="pl-pds">"</span>Rows<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Cols<span class="pl-pds">"</span></span>))
<span class="pl-c"><span class="pl-c">#</span> NamedArray{T,N}(a::AbstractArray{T,N}, names::NTuple{N,Vector})</span>
n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>([<span class="pl-c1">1</span> <span class="pl-c1">3</span>; <span class="pl-c1">2</span> <span class="pl-c1">4</span>], ( [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>], [<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>] ))
n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], ( [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>], ))  <span class="pl-c"><span class="pl-c">#</span> note the comma after ["a", "b"] to ensure evaluation as tuple</span></pre></div>
<p>This is a more friendly version of the basic constructor, where the range of the dictionaries is automatically assigned the values <code>1:size(a, dim)</code> for the <code>names</code> in order. If <code>dimnames</code> is not specified, the default values will be used (<code>:A</code>, <code>:B</code>, etc.).</p>
<p>In principle, there is no limit imposed to the type of the <code>names</code> used, but we discourage the use of <code>Real</code>, <code>AbstractArray</code> and <code>Range</code>, because they have a special interpretation in <code>getindex()</code> and <code>setindex</code>.</p>
<h2><a id="user-content-indexing" class="anchor" aria-hidden="true" href="#indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Indexing</h2>
<h3><a id="user-content-integer-indices" class="anchor" aria-hidden="true" href="#integer-indices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Integer</code> indices</h3>
<p>Single and multiple integer indices work as for the undelying array:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n[1, 1]
n[1]
"><pre>n[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>]
n[<span class="pl-c1">1</span>]</pre></div>
<p>Because the constructed <code>NamedArray</code> itself is an <code>AbstractArray</code>, integer indices always have precedence:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="a = rand(2, 4)
dodgy = NamedArray(a, ([2, 1], [10, 20, 30, 40]))
dodgy[1, 1] == a[1, 1] ## true
dodgy[1, 10] ## BoundsError
"><pre>a <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>)
dodgy <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>(a, ([<span class="pl-c1">2</span>, <span class="pl-c1">1</span>], [<span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>, <span class="pl-c1">40</span>]))
dodgy[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">==</span> a[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span># true</span>
dodgy[<span class="pl-c1">1</span>, <span class="pl-c1">10</span>] <span class="pl-c"><span class="pl-c">#</span># BoundsError</span></pre></div>
<p>In some cases, e.g., with contingency tables, it would be very handy to be able to use named Integer indices.  In this case, in order to circumvent the normal <code>AbstractArray</code> interpretation of the index, you can wrap the indexing argument in the type <code>Name()</code></p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="dodgy[Name(1), Name(30)] == a[2, 3] ## true
"><pre>dodgy[<span class="pl-c1">Name</span>(<span class="pl-c1">1</span>), <span class="pl-c1">Name</span>(<span class="pl-c1">30</span>)] <span class="pl-k">==</span> a[<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] <span class="pl-c"><span class="pl-c">#</span># true</span></pre></div>
<h3><a id="user-content-named-indices" class="anchor" aria-hidden="true" href="#named-indices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Named indices</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n = NamedArray([1 2 3; 4 5 6], ([&quot;one&quot;, &quot;two&quot;], [:a, :b, :c]))
@show n;

n = 2×3 Named Array{Int64,2}
A ╲ B │ :a  :b  :c
──────┼───────────
one   │  1   2   3
two   │  4   5   6

n[&quot;one&quot;, :a] == 1 ## true
n[:, :b] == [2, 5] ## true
n[&quot;two&quot;, [1, 3]] == [4, 6] ## true
n[&quot;one&quot;, [:a, :b]] == [1, 2] ## true
"><pre>n <span class="pl-k">=</span> <span class="pl-c1">NamedArray</span>([<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>; <span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span>], ([<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>], [<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>, <span class="pl-c1">:c</span>]))
<span class="pl-c1">@show</span> n;

n <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> Named Array{Int64,<span class="pl-c1">2</span>}
A ╲ B │ <span class="pl-c1">:a</span>  <span class="pl-c1">:b</span>  <span class="pl-c1">:c</span>
──────┼───────────
one   │  <span class="pl-c1">1</span>   <span class="pl-c1">2</span>   <span class="pl-c1">3</span>
two   │  <span class="pl-c1">4</span>   <span class="pl-c1">5</span>   <span class="pl-c1">6</span>

n[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-c1">:a</span>] <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">#</span># true</span>
n[:, <span class="pl-c1">:b</span>] <span class="pl-k">==</span> [<span class="pl-c1">2</span>, <span class="pl-c1">5</span>] <span class="pl-c"><span class="pl-c">#</span># true</span>
n[<span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>, [<span class="pl-c1">1</span>, <span class="pl-c1">3</span>]] <span class="pl-k">==</span> [<span class="pl-c1">4</span>, <span class="pl-c1">6</span>] <span class="pl-c"><span class="pl-c">#</span># true</span>
n[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, [<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>]] <span class="pl-k">==</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-c"><span class="pl-c">#</span># true</span></pre></div>
<p>This is the main use of <code>NamedArrays</code>.  Names (keys) and arrays of names can be specified as an index, and these can be mixed with other forms of indexing.</p>
<h3><a id="user-content-slices" class="anchor" aria-hidden="true" href="#slices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Slices</h3>
<p>The example above just shows how the indexing works for the values, but there is a slight subtlety in how the return type of slices is determined</p>
<p>When a single element is selected by an index expression, a scalar value is returned.  When an array slice is selected, an attempt is made to return a NamedArray with the correct names for the dimensions.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="@show n[:, :b]; ## this expression drops the singleton dimensions, and hence the names

n[:, :b] = 2-element Named Array{Int64,1}
A   │
────┼──
one │ 2
two │ 5

@show n[[&quot;one&quot;], [:a]]; ## this expression keeps the names

n[[&quot;one&quot;], [:a]] = 1×1 Named Array{Int64,2}
A ╲ B │ :a
──────┼───
one   │  1
"><pre><span class="pl-c1">@show</span> n[:, <span class="pl-c1">:b</span>]; <span class="pl-c"><span class="pl-c">#</span># this expression drops the singleton dimensions, and hence the names</span>

n[:, <span class="pl-c1">:b</span>] <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">-</span>element Named Array{Int64,<span class="pl-c1">1</span>}
A   │
────┼──
one │ <span class="pl-c1">2</span>
two │ <span class="pl-c1">5</span>

<span class="pl-c1">@show</span> n[[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>], [<span class="pl-c1">:a</span>]]; <span class="pl-c"><span class="pl-c">#</span># this expression keeps the names</span>

n[[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>], [<span class="pl-c1">:a</span>]] <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">1</span> Named Array{Int64,<span class="pl-c1">2</span>}
A ╲ B │ <span class="pl-c1">:a</span>
──────┼───
one   │  <span class="pl-c1">1</span></pre></div>
<h3><a id="user-content-negation--complement" class="anchor" aria-hidden="true" href="#negation--complement"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Negation / complement</h3>
<p>There is a special type constructor <code>Not()</code>, whose function is to specify which elements to exclude from the array.  This is similar to negative indices in the language R.  The elements in <code>Not(elements...)</code> select all but the indicated elements from the array.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n[Not(1), :] == n[[2], :] ## true, note that `n` stays 2-dimensional
n[2, Not(:a)] == n[2, [:b, :c]] ## true
dodgy[1, Not(Name(30))] == dodgy[1, [1, 2, 4]] ## true
"><pre>n[<span class="pl-c1">Not</span>(<span class="pl-c1">1</span>), :] <span class="pl-k">==</span> n[[<span class="pl-c1">2</span>], :] <span class="pl-c"><span class="pl-c">#</span># true, note that `n` stays 2-dimensional</span>
n[<span class="pl-c1">2</span>, <span class="pl-c1">Not</span>(<span class="pl-c1">:a</span>)] <span class="pl-k">==</span> n[<span class="pl-c1">2</span>, [<span class="pl-c1">:b</span>, <span class="pl-c1">:c</span>]] <span class="pl-c"><span class="pl-c">#</span># true</span>
dodgy[<span class="pl-c1">1</span>, <span class="pl-c1">Not</span>(<span class="pl-c1">Name</span>(<span class="pl-c1">30</span>))] <span class="pl-k">==</span> dodgy[<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>]] <span class="pl-c"><span class="pl-c">#</span># true</span></pre></div>
<p>Both integers and names can be negated.</p>
<h3><a id="user-content-dictionary-style-indexing" class="anchor" aria-hidden="true" href="#dictionary-style-indexing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dictionary-style indexing</h3>
<p>You can also use a dictionary-style indexing, if you don't want to bother about the order of the dimensions, or make a slice using a specific named dimension:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n[:A =&gt; &quot;one&quot;] == [1, 2, 3]
n[:B =&gt; :c, :A =&gt; &quot;two&quot;] == 6
"><pre>n[<span class="pl-c1">:A</span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>] <span class="pl-k">==</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
n[<span class="pl-c1">:B</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">:c</span>, <span class="pl-c1">:A</span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>] <span class="pl-k">==</span> <span class="pl-c1">6</span></pre></div>
<p>This style cannot be mixed with other indexing styles, yet.</p>
<h3><a id="user-content-assignment" class="anchor" aria-hidden="true" href="#assignment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Assignment</h3>
<p>Most index types can be used for assignment as LHS</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="n[1, 1] = 0
n[&quot;one&quot;, :b] = 1
n[:, :c] = 101:102
n[:B=&gt;:b, :A=&gt;&quot;two&quot;] = 50
@show(n) # ==&gt;

n = 2×3 Named Array{Int64,2}
A ╲ B │  :a   :b   :c
──────┼──────────────
one   │   0    1  101
two   │   4   50  102
"><pre>n[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span>
n[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-c1">:b</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>
n[:, <span class="pl-c1">:c</span>] <span class="pl-k">=</span> <span class="pl-c1">101</span><span class="pl-k">:</span><span class="pl-c1">102</span>
n[<span class="pl-c1">:B</span><span class="pl-k">=&gt;</span><span class="pl-c1">:b</span>, <span class="pl-c1">:A</span><span class="pl-k">=&gt;</span><span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">50</span>
<span class="pl-c1">@show</span>(n) <span class="pl-c"><span class="pl-c">#</span> ==&gt;</span>

n <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">×</span><span class="pl-c1">3</span> Named Array{Int64,<span class="pl-c1">2</span>}
A ╲ B │  <span class="pl-c1">:a</span>   <span class="pl-c1">:b</span>   <span class="pl-c1">:c</span>
──────┼──────────────
one   │   <span class="pl-c1">0</span>    <span class="pl-c1">1</span>  <span class="pl-c1">101</span>
two   │   <span class="pl-c1">4</span>   <span class="pl-c1">50</span>  <span class="pl-c1">102</span></pre></div>
<h2><a id="user-content-general-functions" class="anchor" aria-hidden="true" href="#general-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>General functions</h2>
<h3><a id="user-content-access-to-the-names-of-the-indices-and-dimensions" class="anchor" aria-hidden="true" href="#access-to-the-names-of-the-indices-and-dimensions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Access to the names of the indices and dimensions</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="names(n::NamedArray) ## get all index names for all dimensions
names(n::NamedArray, dim::Integer) ## just for dimension `dim`
dimnames(n::NamedArray) ## the names of the dimensions

@show names(n);
names(n) = Array{T,1} where T[[&quot;one&quot;, &quot;two&quot;], Symbol[:a, :b, :c]]

@show names(n, 1)
names(n, 1) = [&quot;one&quot;, &quot;two&quot;]
2-element Array{String,1}:
 &quot;one&quot;
 &quot;two&quot;

@show dimnames(n);
dimnames(n) = Symbol[:A, :B]
"><pre><span class="pl-c1">names</span>(n<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>) <span class="pl-c"><span class="pl-c">#</span># get all index names for all dimensions</span>
<span class="pl-c1">names</span>(n<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>, dim<span class="pl-k">::</span><span class="pl-c1">Integer</span>) <span class="pl-c"><span class="pl-c">#</span># just for dimension `dim`</span>
<span class="pl-c1">dimnames</span>(n<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>) <span class="pl-c"><span class="pl-c">#</span># the names of the dimensions</span>

<span class="pl-c1">@show</span> <span class="pl-c1">names</span>(n);
<span class="pl-en">names</span>(n) <span class="pl-k">=</span> Array{T,<span class="pl-c1">1</span>} <span class="pl-k">where</span> T[[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>], Symbol[<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>, <span class="pl-c1">:c</span>]]

<span class="pl-c1">@show</span> <span class="pl-c1">names</span>(n, <span class="pl-c1">1</span>)
<span class="pl-en">names</span>(n, <span class="pl-c1">1</span>) <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>]
<span class="pl-c1">2</span><span class="pl-k">-</span>element Array{String,<span class="pl-c1">1</span>}<span class="pl-k">:</span>
 <span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>
 <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>

<span class="pl-c1">@show</span> <span class="pl-c1">dimnames</span>(n);
<span class="pl-en">dimnames</span>(n) <span class="pl-k">=</span> Symbol[<span class="pl-c1">:A</span>, <span class="pl-c1">:B</span>]</pre></div>
<h3><a id="user-content-setting-the-names-after-construction" class="anchor" aria-hidden="true" href="#setting-the-names-after-construction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Setting the names after construction</h3>
<p>Because the type of the keys are encoded in the type of the <code>NamedArray</code>, you can only change the names of indices if they have the same type as before.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content=" setnames!(n::NamedArray, names::Vector, dim::Integer)
 setnames!(n::NamedArray, name, dim::Int, index:Integer)
 setdimnames!(n::NamedArray, name, dim:Integer)
"><pre> <span class="pl-c1">setnames!</span>(n<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>, names<span class="pl-k">::</span><span class="pl-c1">Vector</span>, dim<span class="pl-k">::</span><span class="pl-c1">Integer</span>)
 <span class="pl-c1">setnames!</span>(n<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>, name, dim<span class="pl-k">::</span><span class="pl-c1">Int</span>, index<span class="pl-k">:</span>Integer)
 <span class="pl-c1">setdimnames!</span>(n<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>, name, dim<span class="pl-k">:</span>Integer)</pre></div>
<p>sets all the names of dimension <code>dim</code>, or only the name at index <code>index</code>, or the name of the dimension <code>dim</code>.</p>
<h3><a id="user-content-enameration" class="anchor" aria-hidden="true" href="#enameration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Enameration</h3>
<p>Similar to the iterator <code>enumerate</code> this package provides an <code>enamerate</code> function for iterating simultaneously over both names and values.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="enamerate(a::NamedArray)
"><pre><span class="pl-c1">enamerate</span>(a<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>)</pre></div>
<p>Example below:</p>
<div class="snippet-clipboard-content position-relative" data-snippet-clipboard-copy-content="n = NamedArray([1 2 3; 4 5 6], ([&quot;one&quot;, &quot;two&quot;], [:a, :b, :c]))
for (name,val) in enamerate(n)
           println(&quot;$name ==  $val&quot;)
       end
(&quot;one&quot;, :a) ==  1
(&quot;two&quot;, :a) ==  4
(&quot;one&quot;, :b) ==  2
(&quot;two&quot;, :b) ==  5
(&quot;one&quot;, :c) ==  3
(&quot;two&quot;, :c) ==  6
"><pre><code>n = NamedArray([1 2 3; 4 5 6], (["one", "two"], [:a, :b, :c]))
for (name,val) in enamerate(n)
           println("$name ==  $val")
       end
("one", :a) ==  1
("two", :a) ==  4
("one", :b) ==  2
("two", :b) ==  5
("one", :c) ==  3
("two", :c) ==  6
</code></pre></div>
<h3><a id="user-content-copy" class="anchor" aria-hidden="true" href="#copy"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Copy</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="copy(a::NamedArray)
"><pre><span class="pl-c1">copy</span>(a<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>)</pre></div>
<p>returns a copy of all the elements in a, and copies of the names, and returns a NamedArray</p>
<h3><a id="user-content-convert" class="anchor" aria-hidden="true" href="#convert"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Convert</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="convert(::Type{Array}, a::NamedArray)
"><pre><span class="pl-c1">convert</span>(<span class="pl-k">::</span><span class="pl-c1">Type{Array}</span>, a<span class="pl-k">::</span><span class="pl-c1">NamedArray</span>)</pre></div>
<p>converts a NamedArray to an Array by dropping all name information.  You can also directly access the underlying array using <code>n.array</code>, or use the accessor function <code>array(n)</code>.</p>
<h2><a id="user-content-methods-with-special-treatment-of-names--dimnames" class="anchor" aria-hidden="true" href="#methods-with-special-treatment-of-names--dimnames"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Methods with special treatment of names / dimnames</h2>
<h3><a id="user-content-concatenation" class="anchor" aria-hidden="true" href="#concatenation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Concatenation</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="hcat(V::NamedVector...)
"><pre><span class="pl-c1">hcat</span>(V<span class="pl-k">::</span><span class="pl-c1">NamedVector...</span>)</pre></div>
<p>concatenates (column) vectors to an array.  If the names are identical
for all vectors, these are retained in the results.  Otherwise
the names are reinitialized to the default "1", "2", ...</p>
<h3><a id="user-content-transposition" class="anchor" aria-hidden="true" href="#transposition"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Transposition</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="' ## transpose post-fix operator '
adjoint
transpose
permutedims
circshift
"><pre><span class="pl-s"><span class="pl-pds">'</span> ## transpose post-fix operator <span class="pl-pds">'</span></span>
adjoint
transpose
permutedims
circshift</pre></div>
<p>operate on the dimnames as well</p>
<h3><a id="user-content-reordering-of-dimensions-in-namedvectors" class="anchor" aria-hidden="true" href="#reordering-of-dimensions-in-namedvectors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reordering of dimensions in NamedVectors</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="nthperm
nthperm!
permute!
shuffle
shuffle!
reverse
reverse!
sort
sort!
"><pre>nthperm
nthperm!
permute!
shuffle
shuffle!
reverse
reverse!
sort
sort!</pre></div>
<p>operate on the names of the rows as well</p>
<h3><a id="user-content-broadcasts" class="anchor" aria-hidden="true" href="#broadcasts"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Broadcasts</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="broadcast
broadcast!
"><pre>broadcast
broadcast!</pre></div>
<p>These functions keep the names of the first argument</p>
<h3><a id="user-content-aggregates" class="anchor" aria-hidden="true" href="#aggregates"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Aggregates</h3>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="sum
prod
maximum
minimum
mean
std
"><pre>sum
prod
maximum
minimum
mean
std</pre></div>
<p>These functions, when operating along one dimension, keep the names in the other dimensions, and name the left over singleton dimension as <code>$function($dimname)</code>.</p>
<h2><a id="user-content-further-development" class="anchor" aria-hidden="true" href="#further-development"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Further Development</h2>
<p>The current goal is to reduce complexity of the implementation.  Where possible, we want to use more of the <code>Base.AbstractArray</code> implementation.</p>
<p>A longer term goal is to improve type stability, this might have a repercussion to the semantics of some operations.</p>
</article></div>