<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><em><strong>EfficientFrontier.jl</strong></em></p>
<p dir="auto"><a href="https://github.com/PharosAbad/EfficientFrontier.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/PharosAbad/EfficientFrontier.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://github.com/PharosAbad/EfficientFrontier.jl/wiki"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a></p>

<h1 align="center" dir="auto"><a id="user-content---entire-efficient-frontier-by-status-segment-method" class="anchor" aria-hidden="true" href="#--entire-efficient-frontier-by-status-segment-method"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
  Entire Efficient Frontier by Status-Segment Method
</h1>
<p align="center" dir="auto">
  <a href="#features">Features</a> •
  <a href="#installation">Installation</a> •
  <a href="#license-">License</a> •
  <a href="https://github.com/PharosAbad/EfficientFrontier.jl/wiki">Documentation</a>
</p>
<p dir="auto"><strong>EfficientFrontier.jl</strong> solves the following problem:</p>
<p dir="auto"><math-renderer class="js-display-math" style="display: block" data-static-url="https://github.githubassets.com/static" data-run-id="b798af5811fd99903e6d92f99b4e65ca">$$
\begin{array}
[c]{cl}
\min &amp; \frac{1}{2}\mathbf{z}^{\prime}\mathbf{Vz}-L\mathbf{z}^{\prime
}\boldsymbol{\mu}\\
s.t. &amp; \mathbf{Az}=\mathbf{b}\in\mathbb{R}^{M}\\
&amp; \mathbf{Gz}\leq\mathbf{g}\in\mathbb{R}^{J}\\
&amp; \boldsymbol{d}\leq\mathbf{z}\leq\boldsymbol{u}\in\mathbb{R}^{N}
\end{array}
$$</math-renderer></p>
<p dir="auto">with mean vector <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="b798af5811fd99903e6d92f99b4e65ca">$\boldsymbol{\mu}\in\mathbb{R}^{N}$</math-renderer> and variance matrix <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="b798af5811fd99903e6d92f99b4e65ca">$\mathbf{V}\in\mathbb{R}^{N\times N}$</math-renderer>. <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="b798af5811fd99903e6d92f99b4e65ca">$\textcolor{blue}{ Varying\ L\ from\ +\infty\ to\ 0}$</math-renderer>, all the efficient critical line segments are computed using <em>closed-form formulas</em>. And the full Efficient Frontier is recorded by corner portfolios connected by parabolas with <em>analytical</em> parameter.</p>
<p dir="auto">I can't wait to see: <a href="https://github.com/PharosAbad/EfficientFrontier.jl/wiki/A-Quick-Example"><strong>A Quick Example</strong></a></p>
<p dir="auto">The <em>Status-Segment Method</em> is a two-stage method:</p>
<ol dir="auto">
<li>find out the <em>status</em> of each asset, that is, whether the weight of the asset falls on the upper or lower bounds of the interval (<code>OUT</code>: <code>DN</code> or <code>UP</code>), or in the middle of the interval (<code>IN</code>).</li>
<li>find out the efficient <em>segment</em> of the CL (critical line), that is, the value range of the slope <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="b798af5811fd99903e6d92f99b4e65ca">$L$</math-renderer> in the EV plane.</li>
</ol>
<p dir="auto">Since the end points of the efficient segment of a CL provide the status information for the adjacent CLs, the efficient segment of an adjacent CL is found immediately. Therefore, as long as the status of any point on the efficient frontier is found, the entire efficient frontier can be found (one and all).</p>
<h2 dir="auto">
<a id="user-content-features" class="anchor" aria-hidden="true" href="#features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Features</h2>
<ul dir="auto">
<li>
<strong>Entire efficient frontier</strong>: calculate the entire efficient frontier, not just a single frontier portfolio</li>
<li>
<strong>Analytical solutions</strong>: use analytical solutions for calculations, not a numerical method that iterate to convergence (A working paper is coming soon).</li>
<li>
<strong>Faster</strong>: Even for a single frontier portfolio, our solution is faster and more accurate than the latest numerical methods such as <a href="https://github.com/oxfordcontrol/Clarabel.jl">Clarabel</a>, because we calculate through the analytical solution, rather than through numerical iteration to convergence.</li>
<li>
<strong>Versatile</strong>: from the simplest <a href="https://github.com/PharosAbad/EfficientFrontier.jl/blob/main/examples/frontier.jl">no short-sale</a> to most general model with <a href="https://github.com/PharosAbad/EfficientFrontier.jl/blob/main/examples/ungil.jl">lower and upper bounds, inequality constraints, and equality constraints</a>. Theoretically we require the variance matrix to be symmetric and positive definite, but in fact we only need the variance matrix subblocks of the IN set to be symmetric and positive definite. Please refer to <a href="https://github.com/PharosAbad/EfficientFrontier.jl/blob/main/examples/SP500.jl">SP500</a> for a rank-deficient example</li>
<li>
<strong>All-weather</strong>: The <a href="https://books.google.ch/books?id=eJ8QUsgfZ8wC" rel="nofollow">Critical Line Algorithm (CLA)</a> (Markowitz, 1956; <a href="https://github.com/PharosAbad/EfficientFrontier.jl/blob/main/examples/MarkowitzTodd2000.jl">Markowitz and Todd, 2000</a>) requires the model to be non-degenerate (there is only one asset toggling IN and OUT state). Or the perturbation method is used to solve the degenerated cases. Our calculations do not suffer from these problems, and we find <a href="https://github.com/PharosAbad/EfficientFrontier.jl/blob/main/examples/failCLA.jl">an example</a> of incorrect results obtained by CLA's perturbation algorithm</li>
<li>
<strong>Plugin</strong>: Simplex method and Combinatorial search method are built-in methods to identify the Status for first CL. <a href="https://github.com/PharosAbad/EfficientFrontier.jl/blob/main/examples/initClarabel.jl">An example</a> of <a href="https://github.com/PharosAbad/EfficientFrontier.jl/blob/main/examples/uClarabel.jl">plugin</a> using <a href="https://github.com/oxfordcontrol/Clarabel.jl">Clarabel</a> is provided, which finds the Status with the highest <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="b798af5811fd99903e6d92f99b4e65ca">$L$</math-renderer> value to start the calculation.</li>
<li>
<strong>Open Source</strong>: Our code is available on <a href="https://github.com/PharosAbad/EfficientFrontier.jl">GitHub</a> and distributed under the MIT License</li>
<li>
<strong>Arbitrary Precision Arithmetic</strong>: fully support for <code>BigFloat</code> from v0.2.0</li>
</ul>
<h2 dir="auto">
<a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto"><strong>EfficientFrontier.jl</strong> can be added by</p>
<ul dir="auto">
<li><code>import Pkg; Pkg.add("EfficientFrontier")</code></li>
<li><code>pkg&gt; add EfficientFrontier</code></li>
<li>
<code>pkg&gt; dev EfficientFrontier</code> for testing nightly version. To use the registered version again <code>pkg&gt; free EfficientFrontier</code>
</li>
</ul>
<h2 dir="auto">
<a id="user-content-license-" class="anchor" aria-hidden="true" href="#license-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>License <g-emoji class="g-emoji" alias="mag" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png">🔍</g-emoji></h2>
<p dir="auto">This project is licensed under the MIT License - see the <a href="LICENSE">LICENSE</a> file for details.</p>
</article></div>