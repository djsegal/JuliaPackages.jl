<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-computationalresources" class="anchor" aria-hidden="true" href="#computationalresources"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ComputationalResources</h1>
<p dir="auto"><a href="https://travis-ci.org/timholy/ComputationalResources.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/8ac53ccce8ac8e1e90ffe707c5815b9b40ba994fb05436f2b7c717241e03a89c/68747470733a2f2f7472617669732d63692e6f72672f74696d686f6c792f436f6d7075746174696f6e616c5265736f75726365732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/timholy/ComputationalResources.jl.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="http://codecov.io/github/timholy/ComputationalResources.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/2135a0eed9450d07f6940e14e54f3797573e3ba5ac8821792e7644437a69cb40/687474703a2f2f636f6465636f762e696f2f6769746875622f74696d686f6c792f436f6d7075746174696f6e616c5265736f75726365732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/timholy/ComputationalResources.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">A Julia package for choosing resources (hardware, libraries,
algorithms) for performing computations. It exports a set of types
that allow you to dispatch to different methods depending on the
selected resources. It also includes simple facilities that help
package authors manage the loading of code in a way that depends on
resource availability and user choice.</p>
<h1 dir="auto"><a id="user-content-resources" class="anchor" aria-hidden="true" href="#resources"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Resources</h1>
<p dir="auto">This package exports the following types of resources:</p>
<ul dir="auto">
<li>CPU1 (single-threaded computation)</li>
<li>CPUThreads (multi-threaded computation)</li>
<li>CPUProcesses (multi-process computation)</li>
<li>ArrayFireLibs (using the <a href="https://github.com/JuliaComputing/ArrayFire.jl">ArrayFire package</a>)</li>
<li>CUDALibs (GPU computation using NVIDIA's CUDA libraries)</li>
<li>OpenCLLibs (GPU computation using the OpenCL libraries)</li>
</ul>
<p dir="auto">Algorithm selection is performed by passing a resource instance as an
argument (conventionally, the first argument) to a function, where
<code>CPU1()</code> is the typical default. Instances of these types may
optionally store additional settings that you can customize; for
example you could define a <code>TimeOut</code> type:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct TimeOut
    seconds::Float64
end"><pre><span class="pl-k">struct</span> TimeOut
    seconds<span class="pl-k">::</span><span class="pl-c1">Float64</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">and then call some algorithm as</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="optimize(CPU1(TimeOut(3)), f, x)"><pre><span class="pl-c1">optimize</span>(<span class="pl-c1">CPU1</span>(<span class="pl-c1">TimeOut</span>(<span class="pl-c1">3</span>)), f, x)</pre></div>
<p dir="auto">As a package author, you could write <code>optimize</code> to check for the
timeout value and terminate early once this time has been exceeded.</p>
<h1 dir="auto"><a id="user-content-usage-as-a-user" class="anchor" aria-hidden="true" href="#usage-as-a-user"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage as a user</h1>
<p dir="auto">Begin your session with</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ComputationalResources"><pre><span class="pl-k">using</span> ComputationalResources</pre></div>
<p dir="auto">Then choose any resources you have available, for example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="addresource(ArrayFireLibs)"><pre><span class="pl-c1">addresource</span>(ArrayFireLibs)</pre></div>
<p dir="auto">It's important to do this before you load any packages supporting
<code>ArrayFire</code>-specific implementations; otherwise, calls such as</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="filter(ArrayFireLibs(), b, a, data)"><pre class="notranslate"><code>filter(ArrayFireLibs(), b, a, data)
</code></pre></div>
<p dir="auto">are likely to throw a <code>MethodError</code> because the relevant
specializations will not have been loaded.</p>
<p dir="auto">If you'd like to make your selection of available resources automatic,
you can add such lines to your <code>.juliarc.jl</code> file.</p>
<h1 dir="auto"><a id="user-content-usage-as-a-package-author" class="anchor" aria-hidden="true" href="#usage-as-a-package-author"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage as a package author</h1>
<p dir="auto">You can make the loading of code dependent upon the resources selected
by the user. We'll use the "Dummy" package as an example (see also the
<code>test/packages</code> folder for additional examples). This package could
have the following file structure:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="src/
  Dummy.jl
  DummyAF.jl
  ...
test/
  ..."><pre class="notranslate"><code>src/
  Dummy.jl
  DummyAF.jl
  ...
test/
  ...
</code></pre></div>
<p dir="auto">where <code>...</code> means additional files. <code>Dummy.jl</code> might start like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module Dummy

using ComputationalResources

# You need an __init__ function that will manage the loading of
# sub-modules that implement specializations for different
# computational resources
function __init__()
    # Enable `using` to load additional modules in this folder
    push!(LOAD_PATH, dirname(@__FILE__))
    # Now check for any resources that your package supports
    if haveresource(ArrayFireLibs)
        # User has indicated support for the ArrayFire libraries, so load your relevant code
        @eval using DummyAF
    end
    # Put additional resource checks here
    # Don't forget to clean up!
    pop!(LOAD_PATH)
end

# Now define the methods you'll export, using single-threaded CPU
# computations as the &quot;foundation&quot;
function foo(resource::CPU1, args...)
    # awesome algorithm goes here
end

# Typically you should select a default resource
foo(args...) = foo(CPU1(), args...)

end"><pre><span class="pl-k">module</span> Dummy

<span class="pl-k">using</span> ComputationalResources

<span class="pl-c"><span class="pl-c">#</span> You need an __init__ function that will manage the loading of</span>
<span class="pl-c"><span class="pl-c">#</span> sub-modules that implement specializations for different</span>
<span class="pl-c"><span class="pl-c">#</span> computational resources</span>
<span class="pl-k">function</span> <span class="pl-en">__init__</span>()
    <span class="pl-c"><span class="pl-c">#</span> Enable `using` to load additional modules in this folder</span>
    <span class="pl-c1">push!</span>(<span class="pl-c1">LOAD_PATH</span>, <span class="pl-c1">dirname</span>(<span class="pl-c1">@__FILE__</span>))
    <span class="pl-c"><span class="pl-c">#</span> Now check for any resources that your package supports</span>
    <span class="pl-k">if</span> <span class="pl-c1">haveresource</span>(ArrayFireLibs)
        <span class="pl-c"><span class="pl-c">#</span> User has indicated support for the ArrayFire libraries, so load your relevant code</span>
        <span class="pl-c1">@eval</span> <span class="pl-k">using</span> DummyAF
    <span class="pl-k">end</span>
    <span class="pl-c"><span class="pl-c">#</span> Put additional resource checks here</span>
    <span class="pl-c"><span class="pl-c">#</span> Don't forget to clean up!</span>
    <span class="pl-c1">pop!</span>(<span class="pl-c1">LOAD_PATH</span>)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Now define the methods you'll export, using single-threaded CPU</span>
<span class="pl-c"><span class="pl-c">#</span> computations as the "foundation"</span>
<span class="pl-k">function</span> <span class="pl-en">foo</span>(resource<span class="pl-k">::</span><span class="pl-c1">CPU1</span>, args<span class="pl-k">...</span>)
    <span class="pl-c"><span class="pl-c">#</span> awesome algorithm goes here</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Typically you should select a default resource</span>
<span class="pl-en">foo</span>(args<span class="pl-k">...</span>) <span class="pl-k">=</span> <span class="pl-c1">foo</span>(<span class="pl-c1">CPU1</span>(), args<span class="pl-k">...</span>)

<span class="pl-k">end</span></pre></div>
<p dir="auto">Your <code>DummyAF</code> module is implemented in <code>DummyAF.jl</code>, which might look like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module DummyAF

using ComputationalResources, Dummy, ArrayFire

function Dummy.foo(resource::ArrayFireLibs, args...)
    # specialization for the same computation, but using the ArrayFire libraries instead
end

end"><pre><span class="pl-k">module</span> DummyAF

<span class="pl-k">using</span> ComputationalResources, Dummy, ArrayFire

<span class="pl-k">function</span> Dummy<span class="pl-k">.</span><span class="pl-en">foo</span>(resource<span class="pl-k">::</span><span class="pl-c1">ArrayFireLibs</span>, args<span class="pl-k">...</span>)
    <span class="pl-c"><span class="pl-c">#</span> specialization for the same computation, but using the ArrayFire libraries instead</span>
<span class="pl-k">end</span>

<span class="pl-k">end</span></pre></div>
<p dir="auto">Note that the <code>ArrayFire</code> package was loaded by <code>DummyAF</code> but not by
<code>Dummy</code>; as a consequence, users who do not have this package
installed will not experience any errors. Assuming it's optional, you
should <em>not</em> add <code>ArrayFire</code> to your package's <code>REQUIRE</code> file.</p>
</article></div>