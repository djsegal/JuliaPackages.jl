<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-matdaemonjl" class="anchor" aria-hidden="true" href="#matdaemonjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MATDaemon.jl</h1>
<p dir="auto"><em>"Yes, of course duct tape works in a near-vacuum. Duct tape works anywhere. Duct tape is magic and should be worshiped." â€• Andy Weir, The Martian</em></p>
<p dir="auto"><a href="https://jondeuce.github.io/MATDaemon.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/jondeuce/MATDaemon.jl/actions?query=workflow%3ACI"><img src="https://github.com/jondeuce/MATDaemon.jl/workflows/CI/badge.svg" alt="build status" style="max-width: 100%;"></a>
<a href="http://codecov.io/github/jondeuce/MATDaemon.jl/branch/master" rel="nofollow"><img src="https://camo.githubusercontent.com/e063f06dbc7fb00b85aa28c98adf14bd7d03245b64da112fc26f14194761b383/68747470733a2f2f636f6465636f762e696f2f6769746875622f6a6f6e64657563652f4d41544461656d6f6e2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov.io" data-canonical-src="https://codecov.io/github/jondeuce/MATDaemon.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Call Julia from MATLAB using a Julia daemon launched by <a href="https://github.com/dmolina/DaemonMode.jl"><code>DaemonMode.jl</code></a>.</p>
<h2 dir="auto"><a id="user-content-quickstart" class="anchor" aria-hidden="true" href="#quickstart"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quickstart</h2>
<p dir="auto">Use the MATLAB function <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> to call Julia from MATLAB:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('sort', {rand(2,5)}, struct('dims', int64(2)))

ans =

    0.1270    0.2785    0.6324    0.8147    0.9575
    0.0975    0.5469    0.9058    0.9134    0.9649"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>sort<span class="pl-pds">'</span></span>, {<span class="pl-en">rand</span>(<span class="pl-c1">2</span>,<span class="pl-c1">5</span>)}, <span class="pl-en">struct</span>(<span class="pl-s"><span class="pl-pds">'</span>dims<span class="pl-pds">'</span></span>, <span class="pl-en">int64</span>(<span class="pl-c1">2</span>)))

ans <span class="pl-k">=</span>

    <span class="pl-c1">0.1270</span>    <span class="pl-c1">0.2785</span>    <span class="pl-c1">0.6324</span>    <span class="pl-c1">0.8147</span>    <span class="pl-c1">0.9575</span>
    <span class="pl-c1">0.0975</span>    <span class="pl-c1">0.5469</span>    <span class="pl-c1">0.9058</span>    <span class="pl-c1">0.9134</span>    <span class="pl-c1">0.9649</span></pre></div>
<p dir="auto">The positional arguments passed to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> are:</p>
<ol dir="auto">
<li>The Julia function to call, given as a MATLAB <code>char</code> array. This can be any Julia expression which evaluates to a function. For example, <code>'a=2; b=3; x -&gt; a*x+b'</code>. For convenience, the empty string <code>''</code> is interpreted as <code>'(args...; kwargs...) -&gt; nothing'</code>, returning <code>nothing</code> for any inputs. <strong>Note:</strong> expressions are wrapped in a <code>let</code> block and evaluated in the global scope</li>
<li>Positional arguments, given as a MATLAB <code>cell</code> array. For example, <code>args = {arg1, arg2, ...}</code></li>
<li>Keyword arguments, given as a MATLAB <code>struct</code>. For example, <code>kwargs = struct('key1', value1, 'key2', value2, ...)</code></li>
</ol>
<p dir="auto">The first time <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> is invoked:</p>
<ol dir="auto">
<li><code>MATDaemon.jl</code> will be installed into a local Julia project, if one does not already exist. By default, a folder <code>.jlcall</code> is created in the same folder as <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a></li>
<li>A Julia server will be started in the background using <a href="https://github.com/dmolina/DaemonMode.jl"><code>DaemonMode.jl</code></a></li>
</ol>
<p dir="auto">All subsequent calls to Julia are run on the Julia server.
The server will be automatically killed when MATLAB exits.</p>
<h3 dir="auto"><a id="user-content-restarting-the-julia-server" class="anchor" aria-hidden="true" href="#restarting-the-julia-server"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Restarting the Julia server</h3>
<p dir="auto">In the event that the Julia server reaches an undesired state, the server can be restarted by passing the <code>'restart'</code> flag with value <code>true</code>:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('', 'restart', true) % restarts the Julia server and returns nothing"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>restart<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">%</span> restarts the Julia server and returns nothing</span></pre></div>
<p dir="auto">Similarly, one can shutdown the Julia server without restarting it:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('', 'shutdown', true) % shuts down the Julia server and returns nothing"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>shutdown<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">%</span> shuts down the Julia server and returns nothing</span></pre></div>
<h3 dir="auto"><a id="user-content-setting-up-the-julia-environment" class="anchor" aria-hidden="true" href="#setting-up-the-julia-environment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Setting up the Julia environment</h3>
<p dir="auto">Before calling Julia functions, it may be necessary or convenient to first set up the Julia environment. For example, one may wish to
activate a local <a href="https://github.com/jondeuce/MATDaemon.jl#loading-code-from-a-local-project">project environment</a>,
run <a href="https://github.com/jondeuce/MATDaemon.jl#loading-setup-code">setup scripts</a>,
<a href="https://github.com/jondeuce/MATDaemon.jl#loading-setup-code">import modules</a> for later use,
or set the <a href="https://github.com/jondeuce/MATDaemon.jl#julia-multithreading">number of threads</a> for running multithreaded code.</p>
<p dir="auto">This setup can be conveniently executed at the start of your MATLAB script with a single call to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> as follows:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('', ...
    'project', '/path/to/MyProject', ... % activate a local Julia Project
    'setup', '/path/to/setup.jl', ... % run a setup script to load some custom Julia code
    'modules', {'MyProject', 'LinearAlgebra', 'Statistics'}, ... % load a custom module and some modules from Base Julia
    'threads', 'auto', ... % use the default number of Julia threads
    'restart', true ... % start a fresh Julia server environment
    )"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, ...
    <span class="pl-s"><span class="pl-pds">'</span>project<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>/path/to/MyProject<span class="pl-pds">'</span></span>, ...<span class="pl-c"> % activate a local Julia Project</span>
    <span class="pl-s"><span class="pl-pds">'</span>setup<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>/path/to/setup.jl<span class="pl-pds">'</span></span>, ...<span class="pl-c"> % run a setup script to load some custom Julia code</span>
    <span class="pl-s"><span class="pl-pds">'</span>modules<span class="pl-pds">'</span></span>, {<span class="pl-s"><span class="pl-pds">'</span>MyProject<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>LinearAlgebra<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Statistics<span class="pl-pds">'</span></span>}, ...<span class="pl-c"> % load a custom module and some modules from Base Julia</span>
    <span class="pl-s"><span class="pl-pds">'</span>threads<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>auto<span class="pl-pds">'</span></span>, ...<span class="pl-c"> % use the default number of Julia threads</span>
    <span class="pl-s"><span class="pl-pds">'</span>restart<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span> ...<span class="pl-c"> % start a fresh Julia server environment</span>
    )</pre></div>
<p dir="auto">See the corresponding sections below for more details about these flags.</p>
<h3 dir="auto"><a id="user-content-julia-multithreading" class="anchor" aria-hidden="true" href="#julia-multithreading"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Julia multithreading</h3>
<p dir="auto">The number of threads used by the Julia server can be set using the <code>'threads'</code> flag:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('() -&gt; Threads.nthreads()', 'threads', 8, 'restart', true)

ans =

  int64

   8"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>() -&gt; Threads.nthreads()<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>threads<span class="pl-pds">'</span></span>, <span class="pl-c1">8</span>, <span class="pl-s"><span class="pl-pds">'</span>restart<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span>)

ans <span class="pl-k">=</span>

  <span class="pl-smi">int64</span>

   <span class="pl-c1">8</span></pre></div>
<p dir="auto">The default value for <code>'threads'</code> is <code>'auto'</code>, deferring to Julia to choose the number of threads.</p>
<p dir="auto"><strong>Note:</strong> Julia cannot change the number of threads at runtime.
In order for the <code>'threads'</code> flag to take effect, the server must be restarted.</p>
<h3 dir="auto"><a id="user-content-loading-modules" class="anchor" aria-hidden="true" href="#loading-modules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Loading modules</h3>
<p dir="auto">Julia modules can be loaded and used:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('LinearAlgebra.norm', {[3.0; 4.0]}, 'modules', {'LinearAlgebra'})

ans =

     5"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>LinearAlgebra.norm<span class="pl-pds">'</span></span>, {[<span class="pl-c1">3.0</span>; <span class="pl-c1">4.0</span>]}, <span class="pl-s"><span class="pl-pds">'</span>modules<span class="pl-pds">'</span></span>, {<span class="pl-s"><span class="pl-pds">'</span>LinearAlgebra<span class="pl-pds">'</span></span>})

ans <span class="pl-k">=</span>

     <span class="pl-c1">5</span></pre></div>
<p dir="auto"><strong>Note:</strong> modules are loaded using <code>import</code>, not <code>using</code>. Module symbols must therefore be fully qualified, e.g. <code>LinearAlgebra.norm</code> in the above example as opposed to <code>norm</code>.</p>
<h3 dir="auto"><a id="user-content-persistent-environments" class="anchor" aria-hidden="true" href="#persistent-environments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Persistent environments</h3>
<p dir="auto">By default, previously loaded Julia code is available on subsequent calls to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a>.
For example, following the <a href="https://github.com/jondeuce/MATDaemon.jl#loading-modules">above call</a> to <code>LinearAlgebra.norm</code>, the <code>LinearAlgebra.det</code> function can be called without loading <code>LinearAlgebra</code> again:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('LinearAlgebra.det', {[1.0 2.0; 3.0 4.0]})

ans =

    -2"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>LinearAlgebra.det<span class="pl-pds">'</span></span>, {[<span class="pl-c1">1.0</span> <span class="pl-c1">2.0</span>; <span class="pl-c1">3.0</span> <span class="pl-c1">4.0</span>]})

ans <span class="pl-k">=</span>

    <span class="pl-k">-</span><span class="pl-c1">2</span></pre></div>
<h3 dir="auto"><a id="user-content-unique-environments" class="anchor" aria-hidden="true" href="#unique-environments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unique environments</h3>
<p dir="auto">Set the <code>'shared'</code> flag to <code>false</code> in order to evaluate each Julia call in a separate namespace on the Julia server:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="% Restart the server, setting 'shared' to false
&gt;&gt; jlcall('LinearAlgebra.norm', {[3.0; 4.0]}, 'modules', {'LinearAlgebra'}, 'restart', true, 'shared', false)

ans =

     5

% This call now errors, despite the above command loading the LinearAlgebra module, as LinearAlgebra.norm is evaluated in a new namespace
&gt;&gt; jlcall('LinearAlgebra.norm', {[3.0; 4.0]}, 'shared', false)
ERROR: LoadError: UndefVarError: LinearAlgebra not defined
Stacktrace:
 ..."><pre><span class="pl-c"><span class="pl-c">%</span> Restart the server, setting 'shared' to false</span>
&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>LinearAlgebra.norm<span class="pl-pds">'</span></span>, {[<span class="pl-c1">3.0</span>; <span class="pl-c1">4.0</span>]}, <span class="pl-s"><span class="pl-pds">'</span>modules<span class="pl-pds">'</span></span>, {<span class="pl-s"><span class="pl-pds">'</span>LinearAlgebra<span class="pl-pds">'</span></span>}, <span class="pl-s"><span class="pl-pds">'</span>restart<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">'</span>shared<span class="pl-pds">'</span></span>, <span class="pl-c1">false</span>)

ans <span class="pl-k">=</span>

     <span class="pl-c1">5</span>

<span class="pl-c"><span class="pl-c">%</span> This call now errors, despite the above command loading the LinearAlgebra module, as LinearAlgebra.norm is evaluated in a new namespace</span>
&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>LinearAlgebra.norm<span class="pl-pds">'</span></span>, {[<span class="pl-c1">3.0</span>; <span class="pl-c1">4.0</span>]}, <span class="pl-s"><span class="pl-pds">'</span>shared<span class="pl-pds">'</span></span>, <span class="pl-c1">false</span>)
<span class="pl-smi">ERROR</span><span class="pl-k">:</span> <span class="pl-smi">LoadError</span><span class="pl-k">:</span> <span class="pl-smi">UndefVarError</span><span class="pl-k">:</span> <span class="pl-smi">LinearAlgebra</span> <span class="pl-smi">not</span> <span class="pl-smi">defined</span>
<span class="pl-smi">Stacktrace</span><span class="pl-k">:</span>
 ...</pre></div>
<h3 dir="auto"><a id="user-content-unique-julia-instances" class="anchor" aria-hidden="true" href="#unique-julia-instances"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unique Julia instances</h3>
<p dir="auto">Instead of running Julia code on a persistent Julia server, unique Julia instances can be launched for each call to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> by passing the <code>'server'</code> flag with value <code>false</code>.</p>
<p dir="auto"><strong>Note:</strong> this may cause significant overhead when repeatedly calling <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> due to Julia package precompilation and loading:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; tic; jlcall('x -&gt; sum(abs2, x)', {1:5}, 'server', false); toc
Elapsed time is 4.181178 seconds. % call unique Julia instance

&gt;&gt; tic; jlcall('x -&gt; sum(abs2, x)', {1:5}, 'restart', true); toc
Elapsed time is 5.046929 seconds. % re-initialize Julia server

&gt;&gt; tic; jlcall('x -&gt; sum(abs2, x)', {1:5}); toc
Elapsed time is 0.267088 seconds. % call server; significantly faster"><pre>&gt;&gt; <span class="pl-smi">tic</span>; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>x -&gt; sum(abs2, x)<span class="pl-pds">'</span></span>, {<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>}, <span class="pl-s"><span class="pl-pds">'</span>server<span class="pl-pds">'</span></span>, <span class="pl-c1">false</span>); <span class="pl-smi">toc</span>
<span class="pl-en">Elapsed</span> <span class="pl-s">time is 4.181178 seconds. </span><span class="pl-c"><span class="pl-c">%</span> call unique Julia instance</span>

&gt;&gt; <span class="pl-smi">tic</span>; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>x -&gt; sum(abs2, x)<span class="pl-pds">'</span></span>, {<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>}, <span class="pl-s"><span class="pl-pds">'</span>restart<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span>); <span class="pl-smi">toc</span>
<span class="pl-en">Elapsed</span> <span class="pl-s">time is 5.046929 seconds. </span><span class="pl-c"><span class="pl-c">%</span> re-initialize Julia server</span>

&gt;&gt; <span class="pl-smi">tic</span>; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>x -&gt; sum(abs2, x)<span class="pl-pds">'</span></span>, {<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>}); <span class="pl-smi">toc</span>
<span class="pl-en">Elapsed</span> <span class="pl-s">time is 0.267088 seconds. </span><span class="pl-c"><span class="pl-c">%</span> call server; significantly faster</span></pre></div>
<h3 dir="auto"><a id="user-content-loading-code-from-a-local-project" class="anchor" aria-hidden="true" href="#loading-code-from-a-local-project"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Loading code from a local project</h3>
<p dir="auto">Code from a <a href="https://pkgdocs.julialang.org/v1/environments/" rel="nofollow">local Julia project</a> can be loaded and called:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('MyProject.my_function', args, kwargs, ...
    'project', '/path/to/MyProject', ...
    'modules', {'MyProject'})"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>MyProject.my_function<span class="pl-pds">'</span></span>, <span class="pl-smi">args</span>, <span class="pl-smi">kwargs</span>, ...
    <span class="pl-s"><span class="pl-pds">'</span>project<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>/path/to/MyProject<span class="pl-pds">'</span></span>, ...
    <span class="pl-s"><span class="pl-pds">'</span>modules<span class="pl-pds">'</span></span>, {<span class="pl-s"><span class="pl-pds">'</span>MyProject<span class="pl-pds">'</span></span>})</pre></div>
<p dir="auto"><strong>Note:</strong> the string passed via the <code>'project'</code> flag is simply forwarded to <code>Pkg.activate</code>; it is the user's responsibility to ensure that the project's dependencies have been installed.</p>
<h3 dir="auto"><a id="user-content-loading-setup-code" class="anchor" aria-hidden="true" href="#loading-setup-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Loading setup code</h3>
<p dir="auto">Julia functions may require or return types which cannot be directly passed from or loaded into MATLAB.
For example, suppose one would like to query <code>Base.VERSION</code>.
Naively calling <code>jlcall('() -&gt; Base.VERSION')</code> would fail, as <code>typeof(Base.VERSION)</code> is not a <code>String</code> but a <code>VersionNumber</code>.</p>
<p dir="auto">One possible remedy is to define a wrapper function in a Julia script:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# setup.jl
julia_version() = string(Base.VERSION)"><pre><span class="pl-c"><span class="pl-c">#</span> setup.jl</span>
<span class="pl-en">julia_version</span>() <span class="pl-k">=</span> <span class="pl-c1">string</span>(Base<span class="pl-k">.</span><span class="pl-c1">VERSION</span>)</pre></div>
<p dir="auto">Then, use the <code>'setup'</code> flag to pass the above script to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a>:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('julia_version', 'setup', '/path/to/setup.jl')

ans =

    '1.6.1'"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>julia_version<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>setup<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>/path/to/setup.jl<span class="pl-pds">'</span></span>)

ans <span class="pl-k">=</span>

    <span class="pl-s"><span class="pl-pds">'</span>1.6.1<span class="pl-pds">'</span></span></pre></div>
<p dir="auto">In this case, <code>jlcall('() -&gt; string(Base.VERSION)')</code> would work just as well.
In general, however, interfacing with complex Julia libraries using MATLAB types may be nontrivial, and the <code>'setup'</code> flag allows for the execution of arbitrary setup code.</p>
<p dir="auto"><strong>Note:</strong> the setup script is loaded into the global scope using <code>include</code>; when using <a href="https://github.com/jondeuce/MATDaemon.jl#persistent-environments">persistent environments</a>, symbols defined in the setup script will be available on subsequent calls to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a>.</p>
<h3 dir="auto"><a id="user-content-handling-julia-outputs" class="anchor" aria-hidden="true" href="#handling-julia-outputs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Handling Julia outputs</h3>
<p dir="auto">Output(s) from Julia are returned using the MATLAB <code>cell</code> array <a href="https://www.mathworks.com/help/matlab/ref/varargout.html" rel="nofollow"><code>varargout</code></a>, MATLAB's variable-length list of output arguments.
A helper function <code>MATDaemon.matlabify</code> is used to convert Julia values into MATLAB-compatible values.
Specifically, the following rules are used to populate <code>varargout</code> with the Julia output <code>y</code>:</p>
<ol dir="auto">
<li>If <code>y::Nothing</code>, then <code>varargout = {}</code> and no outputs are returned to MATLAB</li>
<li>If <code>y::Tuple</code>, then <code>length(y)</code> outputs are returned, with <code>varargout{i}</code> given by <code>matlabify(y[i])</code></li>
<li>Otherwise, one output is returned with <code>varargout{1}</code> given by <code>matlabify(y)</code></li>
</ol>
<p dir="auto">The following <code>matlabify</code> methods are defined by default:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="matlabify(x) = x # default fallback
matlabify(::Union{Nothing, Missing}) = zeros(0,0) # equivalent to MATLAB's []
matlabify(x::Symbol) = string(x)
matlabify(xs::Tuple) = Any[matlabify(x) for x in xs] # matlabify values
matlabify(xs::Union{&lt;:AbstractDict, &lt;:NamedTuple, &lt;:Base.Iterators.Pairs}) = Dict{String, Any}(string(k) =&gt; matlabify(v) for (k, v) in pairs(xs)) # convert keys to strings and matlabify values"><pre><span class="pl-en">matlabify</span>(x) <span class="pl-k">=</span> x <span class="pl-c"><span class="pl-c">#</span> default fallback</span>
<span class="pl-en">matlabify</span>(<span class="pl-k">::</span><span class="pl-c1">Union{Nothing, Missing}</span>) <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">#</span> equivalent to MATLAB's []</span>
<span class="pl-en">matlabify</span>(x<span class="pl-k">::</span><span class="pl-c1">Symbol</span>) <span class="pl-k">=</span> <span class="pl-c1">string</span>(x)
<span class="pl-en">matlabify</span>(xs<span class="pl-k">::</span><span class="pl-c1">Tuple</span>) <span class="pl-k">=</span> Any[<span class="pl-c1">matlabify</span>(x) <span class="pl-k">for</span> x <span class="pl-k">in</span> xs] <span class="pl-c"><span class="pl-c">#</span> matlabify values</span>
<span class="pl-en">matlabify</span>(xs<span class="pl-k">::</span><span class="pl-c1">Union{&lt;:AbstractDict, &lt;:NamedTuple, &lt;:Base.Iterators.Pairs}</span>) <span class="pl-k">=</span> <span class="pl-c1">Dict</span><span class="pl-c1">{String, Any}</span>(<span class="pl-c1">string</span>(k) <span class="pl-k">=&gt;</span> <span class="pl-c1">matlabify</span>(v) <span class="pl-k">for</span> (k, v) <span class="pl-k">in</span> <span class="pl-c1">pairs</span>(xs)) <span class="pl-c"><span class="pl-c">#</span> convert keys to strings and matlabify values</span></pre></div>
<p dir="auto"><strong>Note:</strong> MATLAB <code>cell</code> and <code>struct</code> types correspond to <code>Array{Any}</code> and <code>Dict{String, Any}</code> in Julia.</p>
<p dir="auto">Conversion via <code>matlabify</code> can easily be extended to additional types.
Returning to the example from the <a href="https://github.com/jondeuce/MATDaemon.jl#loading-setup-code">above section</a>, we can define a <code>matlabify</code> method for <code>Base.VersionNumber</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# setup.jl
MATDaemon.matlabify(v::Base.VersionNumber) = string(v)"><pre><span class="pl-c"><span class="pl-c">#</span> setup.jl</span>
MATDaemon<span class="pl-k">.</span><span class="pl-en">matlabify</span>(v<span class="pl-k">::</span><span class="pl-c1">Base.VersionNumber</span>) <span class="pl-k">=</span> <span class="pl-c1">string</span>(v)</pre></div>
<p dir="auto">Now, the return type will be automatically converted:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall('() -&gt; Base.VERSION', 'setup', '/path/to/setup.jl')

ans =

    '1.6.1'"><pre>&gt;&gt; <span class="pl-en">jlcall</span>(<span class="pl-s"><span class="pl-pds">'</span>() -&gt; Base.VERSION<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>setup<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>/path/to/setup.jl<span class="pl-pds">'</span></span>)

ans <span class="pl-k">=</span>

    <span class="pl-s"><span class="pl-pds">'</span>1.6.1<span class="pl-pds">'</span></span></pre></div>
<h3 dir="auto"><a id="user-content-performance" class="anchor" aria-hidden="true" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Performance</h3>
<p dir="auto">MATLAB inputs and Julia ouputs are passed back and forth between MATLAB and the <code>DaemonMode.jl</code> server by writing to temporary <code>.mat</code> files.
The location of these files can be configured with the <code>'infile'</code> and <code>'outfile'</code> flags, respectively.
Pointing these files to a ram-backed file system is recommended when possible (for example, the <code>/tmp</code> folder on Linux is usually ram-backed), as read/write speed will likely improve.
This is now the default; <code>'infile'</code> and <code>'outfile'</code> are created via the MATLAB <code>tempname</code> function (thanks to @mauro3 for this tip).</p>
<p dir="auto">Nevertheless, this naturally leads to some overhead when calling Julia, particularly when the MATLAB inputs and/or Julia outputs have large memory footprints.
It is therefore not recommended to use <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> in performance critical loops.</p>
<h2 dir="auto"><a id="user-content-matlab-and-julia-version-compatibility" class="anchor" aria-hidden="true" href="#matlab-and-julia-version-compatibility"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MATLAB and Julia version compatibility</h2>
<p dir="auto">This package has been tested on a variety of MATLAB versions.
However, for some versions of Julia and MATLAB, supported versions of external libraries may clash.
For example, running <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> using Julia v1.6.1 and MATLAB R2015b gives the following error:</p>
<div class="highlight highlight-source-matlab notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="&gt;&gt; jlcall

ERROR: Unable to load dependent library ~/.local/julia-1.6.1/bin/../lib/julia/libjulia-internal.so.1

Message: /usr/local/MATLAB/R2015b/sys/os/glnxa64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by ~/.local/julia-1.6.1/bin/../lib/julia/libjulia-internal.so.1)"><pre>&gt;&gt; <span class="pl-smi">jlcall</span>

<span class="pl-smi">ERROR</span><span class="pl-k">:</span> <span class="pl-smi">Unable</span> <span class="pl-smi">to</span> <span class="pl-smi">load</span> <span class="pl-smi">dependent</span> <span class="pl-smi">library</span> ~/.local<span class="pl-k">/</span><span class="pl-smi">julia</span><span class="pl-k">-</span><span class="pl-c1">1.6</span>.1<span class="pl-k">/</span><span class="pl-smi">bin</span>/../<span class="pl-smi">lib</span><span class="pl-k">/</span><span class="pl-smi">julia</span><span class="pl-k">/</span><span class="pl-smi">libjulia</span><span class="pl-k">-</span><span class="pl-smi">internal</span>.<span class="pl-smi">so</span>.1

<span class="pl-smi">Message</span><span class="pl-k">:</span> <span class="pl-k">/</span><span class="pl-smi">usr</span><span class="pl-k">/</span><span class="pl-smi">local</span><span class="pl-k">/</span><span class="pl-smi">MATLAB</span><span class="pl-k">/</span><span class="pl-smi">R2015b</span><span class="pl-k">/</span><span class="pl-smi">sys</span><span class="pl-k">/</span><span class="pl-smi">os</span><span class="pl-k">/</span><span class="pl-smi">glnxa64</span><span class="pl-k">/</span><span class="pl-smi">libstdc</span>++.so.6<span class="pl-k">:</span> <span class="pl-smi">version</span> `<span class="pl-smi">GLIBCXX_3</span>.4.20<span class="pl-k">'</span> <span class="pl-smi">not</span> <span class="pl-en">found</span> (<span class="pl-smi">required</span> <span class="pl-smi">by</span> ~/.local<span class="pl-k">/</span><span class="pl-smi">julia</span><span class="pl-k">-</span><span class="pl-c1">1.6</span>.1<span class="pl-k">/</span><span class="pl-smi">bin</span>/../<span class="pl-smi">lib</span><span class="pl-k">/</span><span class="pl-smi">julia</span><span class="pl-k">/</span><span class="pl-smi">libjulia</span><span class="pl-k">-</span><span class="pl-smi">internal</span>.<span class="pl-smi">so</span>.1)</pre></div>
<p dir="auto">This error results due to a clash of supported <code>libstdc++</code> versions, and does not occur when using e.g. Julia v1.5.4 with MATLAB R2015b, or Julia v1.6.1 with MATLAB R2020b.</p>
<p dir="auto">If you encounter this issue, see the <a href="https://github.com/JuliaLang/julia/blob/master/doc/build/build.md#required-build-tools-and-external-libraries"><code>Julia</code></a> and <a href="https://www.mathworks.com/support/requirements/supported-compilers.html" rel="nofollow"><code>MATLAB</code></a> documentation for information on mutually supported external libraries.</p>
<h2 dir="auto"><a id="user-content-about-this-package" class="anchor" aria-hidden="true" href="#about-this-package"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>About this package</h2>
<p dir="auto">This repository contains utilities for parsing and running Julia code, passing MATLAB arguments to Julia, and retrieving Julia outputs from MATLAB.</p>
<p dir="auto">The workhorse behind <code>MATDaemon.jl</code> and <a href="https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m"><code>jlcall.m</code></a> is <a href="https://github.com/dmolina/DaemonMode.jl"><code>DaemonMode.jl</code></a> which is used to start a persistent Julia server in the background.</p>
</article></div>