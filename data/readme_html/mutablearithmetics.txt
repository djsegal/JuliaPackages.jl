<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-mutablearithmeticsjl" class="anchor" aria-hidden="true" href="#mutablearithmeticsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>MutableArithmetics.jl</h1>
<p dir="auto"><a href="https://jump.dev/MutableArithmetics.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://jump.dev/MutableArithmetics.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/jump-dev/MutableArithmetics.jl/actions?query=workflow%3ACI"><img src="https://github.com/jump-dev/MutableArithmetics.jl/workflows/CI/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jump-dev/MutableArithmetics.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/10998004914c3d37ea5d1f9d361d9fb5647a49fbd627a8c69e58673c67796477/68747470733a2f2f636f6465636f762e696f2f67682f6a756d702d6465762f4d757461626c6541726974686d65746963732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/jump-dev/MutableArithmetics.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/MutableArithmetics/EoEec?t=2" rel="nofollow"><img src="https://camo.githubusercontent.com/83eb51640bcc86782cdad5b42f06bc749d0d24f064fa7cbdb908282f8ddcbb18/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f4d757461626c6541726974686d65746963732f646570732e737667" alt="deps" data-canonical-src="https://juliahub.com/docs/MutableArithmetics/deps.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/MutableArithmetics/EoEec" rel="nofollow"><img src="https://camo.githubusercontent.com/8539edc793cd4f4b4a5c3f69d53811a82c7ec0058abd6b13ec21fc6f03a51f69/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f4d757461626c6541726974686d65746963732f76657273696f6e2e737667" alt="version" data-canonical-src="https://juliahub.com/docs/MutableArithmetics/version.svg" style="max-width: 100%;"></a>
<a href="https://juliahub.com/ui/Packages/MutableArithmetics/EoEec" rel="nofollow"><img src="https://camo.githubusercontent.com/4a34eb760597a53debcb3980681b8247f07f2f05a74cc0b36093341298362183/68747470733a2f2f6a756c69616875622e636f6d2f646f63732f4d757461626c6541726974686d65746963732f706b676576616c2e737667" alt="pkgeval" data-canonical-src="https://juliahub.com/docs/MutableArithmetics/pkgeval.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><strong>MutableArithmetics</strong> (MA for short) is a <a href="http://julialang.org" rel="nofollow">Julia</a> package
which allows:</p>
<ul dir="auto">
<li>for mutable types to implement mutable arithmetics</li>
<li>for algorithms that could exploit mutable arithmetics to exploit them while
still being completely generic.</li>
</ul>
<p dir="auto">While in some cases, similar features have been included in packages
idiosyncratically, the goal of MutableArithmetics is to provide a generic
interface to allow anyone to make use of mutability when desired.</p>
<p dir="auto">The package allows a type to declare itself mutable through the <code>MA.mutability</code>
trait. Then the user can use the <code>MA.operate!!</code> function to write generic code
that works for arbitrary type while exploiting mutability of the type
if possible. More precisely:</p>
<ul dir="auto">
<li>The <code>MA.operate!!(op::Function, x, args...)</code> redirects to <code>op(x, args...)</code>
if <code>x</code> is not mutable or if the result of the operation cannot be stored in
<code>x</code>. Otherwise, it redirects to <code>MA.operate!(op, x, args...)</code>.</li>
<li><code>MA.operate!(op::Function, x, args...)</code> stores the result of the operation in
<code>x</code>. It is a <code>MethodError</code> if <code>x</code> is not mutable or if the result of the
operation cannot be stored in <code>x</code>.</li>
</ul>
<p dir="auto">So from a generic code perspective, <code>MA.operate!!</code> can be used when the value of
<code>x</code> is not used anywhere else. This allows the code to both work for mutable and
for non-mutable type.</p>
<p dir="auto">When the type is known to be mutable, <code>MA.operate!</code> can be used to make sure the
operation is done in-place. If it is not possible, the <code>MethodError</code> allows one
to easily fix the issue while <code>MA.operate!!</code> would have silently fallen back to
the non-mutating function.</p>
<p dir="auto">In conclusion, the distinction between <code>MA.operate!!</code> and <code>MA.operate!</code> covers
all use case while having an universal convention accross all operations.</p>
<h2 dir="auto"><a id="user-content-implementations" class="anchor" aria-hidden="true" href="#implementations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementations</h2>
<p dir="auto">The following types and packages implement the MutableArithmetics API:</p>
<ul dir="auto">
<li><code>Base.BigInt</code> in <code>src/interfaces/BigInt.jl</code>.</li>
<li><code>Base.BigFloat</code> in <code>src/interfaces/BigFloat.jl</code>.</li>
<li><code>Base.Array</code> in <code>src/interfaces/LinearAlgebra.jl</code>.</li>
<li><a href="https://github.com/JuliaMath/Polynomials.jl">Polynomials.jl</a> uses MA for its
<code>Polynomial</code> type</li>
<li><a href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl">MultivariatePolynomials</a>
uses MA for its multivariate polynomials, as well as its two implementations
in <a href="https://github.com/JuliaAlgebra/DynamicPolynomials.jl">DynamicPolynomials</a>
and <a href="https://github.com/JuliaAlgebra/TypedPolynomials.jl">TypedPolynomials</a></li>
<li><a href="https://github.com/jump-dev/JuMP.jl">JuMP</a> and
<a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface</a> use
MA for the scalar and quadratic functions used to define an optimization
program</li>
</ul>
<p dir="auto">In addition, the implementation of the following <code>Base</code> functionalities are
reimplemented using the MA API:</p>
<ul dir="auto">
<li>Matrix-matrix, matrix-vector and array-scalar multiplication including
<code>SparseArrays.AbstractSparseArray</code>, <code>LinearAlgebra.Adjoint</code>,
<code>LinearAlgebra.Transpose</code>, <code>LinearAlgebra.Symmetric</code>.</li>
<li><code>Base.sum</code>, <code>LinearAlgebra.dot</code> and <code>LinearAlgebra.diagm</code>.</li>
</ul>
<p dir="auto">These methods are reimplemented in this package for several reasons:</p>
<ul dir="auto">
<li>The implementation in <code>Base</code> does not exploit the mutability of the type
(except for <code>sum(::Vector{BigInt})</code> which has a specialized method) and
are hence much slower.</li>
<li>Some implementations in <code>Base</code> assume the following for the types <code>S</code>, <code>T</code> used satisfy:
<ul dir="auto">
<li><code>typeof(zero(T)) == T</code>, <code>typeof(one(T)) == T</code>, <code>typeof(S + T) == promote_type(S, T)</code>
or <code>typeof(S * T) == promote_type(S, T)</code> which is not true for
instance if <code>T</code> is a polynomial variable or the decision variable of an
optimization model.</li>
<li>The multiplication between elements of type <code>S</code> and <code>T</code> is commutative which
is not true for matrices or non-commutative polynomial variables.</li>
</ul>
</li>
</ul>
<p dir="auto">The trait defined in this package cannot make the methods for the functions
defined in Base to be dispatched to the implementations of this package.
For these to be used for a given type, it needs to inherit from <code>MA.AbstractMutable</code>.
Not that subtypes of <code>MA.AbstractMutable</code> are not necessarily mutable,
for instance, polynomial variables and the decision variable of an optimization
model are subtypes of <code>MA.AbstractMutable</code> but are not mutable.
The only purpose of this abstract type is to have <code>Base</code> methods to be dispatched
to the implementations of this package. See <code>src/dispatch.jl</code> for more details.</p>
<h2 dir="auto"><a id="user-content-quick-example--benchmark" class="anchor" aria-hidden="true" href="#quick-example--benchmark"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick Example &amp; Benchmark</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using BenchmarkTools
using MutableArithmetics
const MA = MutableArithmetics

n = 200
A = rand(-10:10, n, n)
b = rand(-10:10, n)
c = rand(-10:10, n)

# MA.mul works for arbitrary types
MA.mul(A, b)

A2 = big.(A)
b2 = big.(b)
c2 = big.(c)"><pre><span class="pl-k">using</span> BenchmarkTools
<span class="pl-k">using</span> MutableArithmetics
<span class="pl-k">const</span> MA <span class="pl-k">=</span> MutableArithmetics

n <span class="pl-k">=</span> <span class="pl-c1">200</span>
A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">10</span><span class="pl-k">:</span><span class="pl-c1">10</span>, n, n)
b <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">10</span><span class="pl-k">:</span><span class="pl-c1">10</span>, n)
c <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-k">-</span><span class="pl-c1">10</span><span class="pl-k">:</span><span class="pl-c1">10</span>, n)

<span class="pl-c"><span class="pl-c">#</span> MA.mul works for arbitrary types</span>
MA<span class="pl-k">.</span><span class="pl-c1">mul</span>(A, b)

A2 <span class="pl-k">=</span> <span class="pl-c1">big</span>.(A)
b2 <span class="pl-k">=</span> <span class="pl-c1">big</span>.(b)
c2 <span class="pl-k">=</span> <span class="pl-c1">big</span>.(c)</pre></div>
<p dir="auto">The default implementation <code>LinearAlgebra.generic_matvecmul!</code> does not exploit
the mutability of <code>BigInt</code> is quite slow and allocates a lot:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LinearAlgebra
trial = @benchmark LinearAlgebra.mul!($c2, $A2, $b2)
display(trial)

# output

BenchmarkTools.Trial: 407 samples with 1 evaluation.
 Range (min … max):   5.268 ms … 161.929 ms  ┊ GC (min … max):  0.00% … 73.90%
 Time  (median):      5.900 ms               ┊ GC (median):     0.00%
 Time  (mean ± σ):   12.286 ms ±  21.539 ms  ┊ GC (mean ± σ):  29.47% ± 14.50%

  █▃
  ██▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅█▆▇▅▅ ▆
  5.27 ms       Histogram: log(frequency) by time      80.6 ms &lt;

 Memory estimate: 3.66 MiB, allocs estimate: 197732."><pre><span class="pl-k">using</span> LinearAlgebra
trial <span class="pl-k">=</span> <span class="pl-c1">@benchmark</span> LinearAlgebra<span class="pl-k">.</span><span class="pl-c1">mul!</span>(<span class="pl-k">$</span>c2, <span class="pl-k">$</span>A2, <span class="pl-k">$</span>b2)
<span class="pl-c1">display</span>(trial)

<span class="pl-c"><span class="pl-c">#</span> output</span>

BenchmarkTools<span class="pl-k">.</span>Trial<span class="pl-k">:</span> <span class="pl-c1">407</span> samples with <span class="pl-c1">1</span> evaluation.
 Range (min … max)<span class="pl-k">:</span>   <span class="pl-c1">5.268</span> ms … <span class="pl-c1">161.929</span> ms  ┊ GC (min … max)<span class="pl-k">:</span>  <span class="pl-c1">0.00</span><span class="pl-k">%</span> … <span class="pl-c1">73.90</span><span class="pl-k">%</span>
 Time  (median)<span class="pl-k">:</span>      <span class="pl-c1">5.900</span> ms               ┊ GC (median)<span class="pl-k">:</span>     <span class="pl-c1">0.00</span><span class="pl-k">%</span>
 Time  (mean ± σ)<span class="pl-k">:</span>   <span class="pl-c1">12.286</span> ms ±  <span class="pl-c1">21.539</span> ms  ┊ GC (mean ± σ)<span class="pl-k">:</span>  <span class="pl-c1">29.47</span><span class="pl-k">%</span> ± <span class="pl-c1">14.50</span><span class="pl-k">%</span>

  █▃
  ██▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅█▆▇▅▅ ▆
  <span class="pl-c1">5.27</span> ms       Histogram<span class="pl-k">:</span> <span class="pl-c1">log</span>(frequency) by time      <span class="pl-c1">80.6</span> ms <span class="pl-k">&lt;</span>

 Memory estimate<span class="pl-k">:</span> <span class="pl-c1">3.66</span> MiB, allocs estimate<span class="pl-k">:</span> <span class="pl-c1">197732.</span></pre></div>
<p dir="auto">In <code>MA.operate!(::typeof(MA.add_mul), ::Vector, ::Matrix, ::Vector)</code>, we
exploit the mutability of <code>BigInt</code> through the MutableArithmetics API.
This provides a significant speedup and a drastic reduction of memory usage:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="trial2 = @benchmark MA.add_mul!!($c2, $A2, $b2)
display(trial2)

# output

BenchmarkTools.Trial: 4878 samples with 1 evaluation.
 Range (min … max):  908.860 μs …   1.758 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):       1.001 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):     1.021 ms ± 102.381 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▅
  ██▂▂▂▇▅▇▇▅▅▅▇▅▆▄▄▅▄▄▃▄▄▃▃▂▃▃▂▃▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  909 μs           Histogram: frequency by time         1.36 ms &lt;

 Memory estimate: 48 bytes, allocs estimate: 3."><pre>trial2 <span class="pl-k">=</span> <span class="pl-c1">@benchmark</span> MA<span class="pl-k">.</span><span class="pl-c1">add_mul!!</span>(<span class="pl-k">$</span>c2, <span class="pl-k">$</span>A2, <span class="pl-k">$</span>b2)
<span class="pl-c1">display</span>(trial2)

<span class="pl-c"><span class="pl-c">#</span> output</span>

BenchmarkTools<span class="pl-k">.</span>Trial<span class="pl-k">:</span> <span class="pl-c1">4878</span> samples with <span class="pl-c1">1</span> evaluation.
 Range (min … max)<span class="pl-k">:</span>  <span class="pl-c1">908.860</span> μs …   <span class="pl-c1">1.758</span> ms  ┊ GC (min … max)<span class="pl-k">:</span> <span class="pl-c1">0.00</span><span class="pl-k">%</span> … <span class="pl-c1">0.00</span><span class="pl-k">%</span>
 Time  (median)<span class="pl-k">:</span>       <span class="pl-c1">1.001</span> ms               ┊ GC (median)<span class="pl-k">:</span>    <span class="pl-c1">0.00</span><span class="pl-k">%</span>
 Time  (mean ± σ)<span class="pl-k">:</span>     <span class="pl-c1">1.021</span> ms ± <span class="pl-c1">102.381</span> μs  ┊ GC (mean ± σ)<span class="pl-k">:</span>  <span class="pl-c1">0.00</span><span class="pl-k">%</span> ± <span class="pl-c1">0.00</span><span class="pl-k">%</span>

  █▅
  ██▂▂▂▇▅▇▇▅▅▅▇▅▆▄▄▅▄▄▃▄▄▃▃▂▃▃▂▃▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  <span class="pl-c1">909</span> μs           Histogram<span class="pl-k">:</span> frequency by time         <span class="pl-c1">1.36</span> ms <span class="pl-k">&lt;</span>

 Memory estimate<span class="pl-k">:</span> <span class="pl-c1">48</span> bytes, allocs estimate<span class="pl-k">:</span> <span class="pl-c1">3.</span></pre></div>
<p dir="auto">There is still 48 bytes that are allocated, where does this come from ?
<code>MA.operate!(::typeof(MA.add_mul), ::BigInt, ::BigInt, ::BigInt)</code>
allocates a temporary <code>BigInt</code> to hold the result of the multiplication.
This buffer is allocated only once for the whole matrix-vector multiplication
through the system of buffers of MutableArithmetics.
If may Matrix-Vector products need to be computed, the buffer can even be allocated
outside of the matrix-vector product as follows:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="buffer = MA.buffer_for(MA.add_mul, typeof(c2), typeof(A2), typeof(b2))
trial3 = @benchmark MA.buffered_operate!!($buffer, MA.add_mul, $c2, $A2, $b2)
display(trial3)

# output

BenchmarkTools.Trial: 4910 samples with 1 evaluation.
 Range (min … max):  908.414 μs …   1.774 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     990.964 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):     1.014 ms ± 103.364 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▂
  ██▃▂▂▄▄▅▆▃▄▄▅▄▄▃▃▄▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  908 μs           Histogram: frequency by time         1.35 ms &lt;

 Memory estimate: 0 bytes, allocs estimate: 0."><pre>buffer <span class="pl-k">=</span> MA<span class="pl-k">.</span><span class="pl-c1">buffer_for</span>(MA<span class="pl-k">.</span>add_mul, <span class="pl-c1">typeof</span>(c2), <span class="pl-c1">typeof</span>(A2), <span class="pl-c1">typeof</span>(b2))
trial3 <span class="pl-k">=</span> <span class="pl-c1">@benchmark</span> MA<span class="pl-k">.</span><span class="pl-c1">buffered_operate!!</span>(<span class="pl-k">$</span>buffer, MA<span class="pl-k">.</span>add_mul, <span class="pl-k">$</span>c2, <span class="pl-k">$</span>A2, <span class="pl-k">$</span>b2)
<span class="pl-c1">display</span>(trial3)

<span class="pl-c"><span class="pl-c">#</span> output</span>

BenchmarkTools<span class="pl-k">.</span>Trial<span class="pl-k">:</span> <span class="pl-c1">4910</span> samples with <span class="pl-c1">1</span> evaluation.
 Range (min … max)<span class="pl-k">:</span>  <span class="pl-c1">908.414</span> μs …   <span class="pl-c1">1.774</span> ms  ┊ GC (min … max)<span class="pl-k">:</span> <span class="pl-c1">0.00</span><span class="pl-k">%</span> … <span class="pl-c1">0.00</span><span class="pl-k">%</span>
 Time  (median)<span class="pl-k">:</span>     <span class="pl-c1">990.964</span> μs               ┊ GC (median)<span class="pl-k">:</span>    <span class="pl-c1">0.00</span><span class="pl-k">%</span>
 Time  (mean ± σ)<span class="pl-k">:</span>     <span class="pl-c1">1.014</span> ms ± <span class="pl-c1">103.364</span> μs  ┊ GC (mean ± σ)<span class="pl-k">:</span>  <span class="pl-c1">0.00</span><span class="pl-k">%</span> ± <span class="pl-c1">0.00</span><span class="pl-k">%</span>

  █▂
  ██▃▂▂▄▄▅▆▃▄▄▅▄▄▃▃▄▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  <span class="pl-c1">908</span> μs           Histogram<span class="pl-k">:</span> frequency by time         <span class="pl-c1">1.35</span> ms <span class="pl-k">&lt;</span>

 Memory estimate<span class="pl-k">:</span> <span class="pl-c1">0</span> bytes, allocs estimate<span class="pl-k">:</span> <span class="pl-c1">0.</span></pre></div>
<p dir="auto">Note that there are now 0 allocations.</p>
</article></div>