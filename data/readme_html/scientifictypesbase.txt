<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-scientifictypesbasejl" class="anchor" aria-hidden="true" href="#scientifictypesbasejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ScientificTypesBase.jl</h1>
<table>
<thead>
<tr>
<th align="center">[Linux]</th>
<th align="center">Coverage</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://github.com/JuliaAI/ScientificTypesBase.jl/actions"><img src="https://github.com/JuliaAI/ScientificTypesBase.jl/workflows/CI/badge.svg" alt="Build status" style="max-width: 100%;"></a></td>
<td align="center"><a href="http://codecov.io/github/JuliaAI/ScientificTypesBase.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/7a48bd99cd6068c1ce0ec8f58718b7ce1ad478db7b4e471851a1b68c4de0f8a2/687474703a2f2f636f6465636f762e696f2f6769746875622f4a756c696141492f536369656e74696669635479706573426173652e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/JuliaAI/ScientificTypesBase.jl/coverage.svg?branch=master" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table>
<p dir="auto">A light-weight, dependency-free, Julia interface defining a collection
of types (without instances) for implementing conventions about the
scientific interpretation of data.</p>
<p dir="auto">This package makes a distinction between the <strong>machine type</strong> and
<strong>scientific type</strong> of a Julia object:</p>
<ul dir="auto">
<li>
<p dir="auto">The <em>machine type</em> refers to the Julia type being used to represent
the object (for instance, <code>Float64</code>).</p>
</li>
<li>
<p dir="auto">The <em>scientific type</em> is one of the types defined in this package
reflecting how the object should be <em>interpreted</em> (for instance,
<code>Continuous</code> or <code>Multiclass{3}</code>).</p>
</li>
</ul>
<p dir="auto">The distinction is useful because the same machine type is often used
to represent data with <em>differing</em> scientific interpretations - <code>Int</code>
is used for product numbers (a factor) but also for a person's weight
(a continuous variable) - while the same scientific type is frequently
represented by <em>different</em> machine types - both <code>Int</code> and <code>Float64</code>
are used to represent weights, for example.</p>
<p dir="auto">For implementation of a concrete convention assigning specific
scientific types (interpretations) to julia objects, see instead the
<a href="https://github.com/JuliaAI/ScientificTypes.jl">ScientificTypes.jl</a>
package.</p>
<p dir="auto">Formerly "ScientificTypesBase.jl" code lived at "ScientificTypes.jl".
Since version 2.0 the code at "ScientificTypes.jl" is code that
formerly resided at "MLJScientificTypes.jl" (now deprecated).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Finite{N}
├─ Multiclass{N}
└─ OrderedFactor{N}

Infinite
├─ Continuous
└─ Count

Image{W,H}
├─ ColorImage{W,H}
└─ GrayImage{W,H}

ScientificTimeType
├─ ScientificDate
├─ ScientificTime
└─ ScientificDateTime

Sampleable{Ω}
└─ Density{Ω}

Annotated{S}

AnnotationFor{S}

Multiset{S}

Table{K}

Textual

ManifoldPoint{MT}

Compositional{D}

Unknown"><pre class="notranslate"><code>Finite{N}
├─ Multiclass{N}
└─ OrderedFactor{N}

Infinite
├─ Continuous
└─ Count

Image{W,H}
├─ ColorImage{W,H}
└─ GrayImage{W,H}

ScientificTimeType
├─ ScientificDate
├─ ScientificTime
└─ ScientificDateTime

Sampleable{Ω}
└─ Density{Ω}

Annotated{S}

AnnotationFor{S}

Multiset{S}

Table{K}

Textual

ManifoldPoint{MT}

Compositional{D}

Unknown
</code></pre></div>
<blockquote>
<p dir="auto">Figure 1. The type hierarchy defined in ScientificTypesBase.jl (The Julia native <code>Missing</code> and <code>Nothing</code> type are also regarded as a scientific types).</p>
</blockquote>
<h4 dir="auto"><a id="user-content-contents" class="anchor" aria-hidden="true" href="#contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Contents</h4>
<ul dir="auto">
<li><a href="#who-is-this-repository-for">Who is this repository for?</a></li>
<li><a href="#what-is-provided-here">What's provided here?</a></li>
<li><a href="#defining-a-new-convention">Defining a new convention</a></li>
</ul>
<h2 dir="auto"><a id="user-content-who-is-this-repository-for" class="anchor" aria-hidden="true" href="#who-is-this-repository-for"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Who is this repository for?</h2>
<p dir="auto">This package should only be used by developers who intend to define
their own scientific type convention.  The
<a href="https://github.com/JuliaAI/ScientificTypes.jl">ScientificTypes.jl</a>
package (versions 2.0 and higher) implements such a convention, first
adopted in the <a href="https://github.com/JuliaAI/MLJ.jl">MLJ</a> universe, but
which can be adopted by other statistical and scientific software.</p>
<p dir="auto">The purpose of this package is to provide a mechanism for articulating
conventions around the scientific interpretation of data. With such a
convention in place, a numerical algorithm declares its data
requirements in terms of scientific types, the user has a convenient
way to check compliance of his data with that requirement, and the
developer understands precisely the constraints his data specification
places on the actual machine type of the data supplied.</p>
<h2 dir="auto"><a id="user-content-what-is-provided-here" class="anchor" aria-hidden="true" href="#what-is-provided-here"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What is provided here?</h2>
<h4 dir="auto"><a id="user-content-1-scientific-types" class="anchor" aria-hidden="true" href="#1-scientific-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>1. Scientific types</h4>
<p dir="auto">ScientificTypesBase provides the new julia types appearing in Figure 1
above, signifying "scientific type" for use in method dispatch (e.g.,
for trait values). Instances of the types play no role.</p>
<p dir="auto">The types <code>Finite{N}</code>, <code>Multiclass{N}</code> and <code>OrderedFactor{N}</code> are all
parametrised by the number of levels <code>N</code>, while <code>Image{W,H}</code>,
<code>GrayImage{W,H}</code> and <code>ColorImage{W,H}</code> are all parametrised by the
image width and height dimensions, <code>(W, H)</code>. The parameter <code>Ω</code> in
<code>Sampleable{Ω}</code> and <code>Density{Ω}</code> is the scientific type of the sample
space. The type <code>ManifoldPoint{MT}</code>, intended for points lying on a
manifold, is parameterized by the type <code>MT</code> of the manifold to which
the points belong.</p>
<p dir="auto">The scientific type <code>ScientificDate</code> is for representing dates (for
example, the 23rd of April, 2029), <code>ScientificTime</code> represents time
within a 24-hour day, while <code>ScientificDateTime</code> represents both a
time of day and date. These types mirror the types <code>Date</code>, <code>Time</code> and
<code>DateTime</code> from the Julia standard library Dates (and indeed, in the
convention defined in ScientificTypes.jl](<a href="https://github.com/JuliaAI/ScientificTypes.jl">https://github.com/JuliaAI/ScientificTypes.jl</a>)
the difference is only a formal one).</p>
<p dir="auto">The type parameter <code>K</code> in <code>Table{K}</code> is for conveying the scientific
type(s) of a table's columns. See <a href="#more-on-the-table-type">More on the <code>Table</code>
type</a>.</p>
<p dir="auto">The julia native types <code>Missing</code> and <code>Nothing</code> are also regarded as scientific
types.</p>
<h4 dir="auto"><a id="user-content-2-the-scitype-and-scitype-methods" class="anchor" aria-hidden="true" href="#2-the-scitype-and-scitype-methods"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>2. The <code>scitype</code> and <code>Scitype</code> methods</h4>
<p dir="auto">ScientificTypesBase provides a method <code>scitype</code> for articulating a
particular convention: <code>scitype(X, C())</code> is the scientific type of object
<code>X</code> under convention <code>C</code>. For example, in the <code>DefaultConvention</code> convention, implemented
by <a href="https://github.com/JuliaAI/ScientificTypes.jl">ScientificTypes</a>,
one has <code>scitype(3.14, Defaultconvention()) = Continuous</code> and
<code>scitype(42, Defaultconvention()) = Count</code>.</p>
<blockquote>
<p dir="auto"><em>Aside.</em> <code>scitype</code> is <em>not</em> a mapping of types to types but from
<em>instances</em> to types. This is because one may want to distinguish
the scientific type of objects having the same machine type. For
example, in the <code>DefaultConvention</code> implemented in ScientificTypes.jl, some
<code>CategoricalArrays.CategoricalValue</code> objects have the scitype
<code>OrderedFactor</code> but others are <code>Multiclass</code>. In CategoricalArrays.jl
the <code>ordered</code> attribute is not a type parameter and so it can only
be extracted from instances.</p>
</blockquote>
<p dir="auto">The developer implementing a particular scientific type convention
<a href="#defining-a-new-convention">overloads</a> the <code>scitype</code> method
appropriately. However, this package provides certain rudimentary
fallback behaviour:</p>
<p dir="auto"><strong>Property 0.</strong> For any convention <code>C</code>, <code>scitype(missing, C()) == Missing</code>
and <code>scitype(nothing, C()) == Nothing</code> (regarding <code>Missing</code> and <code>Nothing</code>
as native scientific types).</p>
<p dir="auto"><strong>Property 1.</strong> For any convention <code>C</code> <code>scitype(X, C()) == Unknown</code>, unless
<code>X</code> is a tuple, an abstract array, <code>nothing</code>, or <code>missing</code>.</p>
<p dir="auto"><strong>Property 2.</strong> For any convention <code>C</code>, The scitype of a <code>k</code>-tuple is
<code>Tuple{S1, S2, ..., Sk}</code> where <code>Sj</code> is the scitype of the <code>j</code>th element under
convention <code>C</code>.</p>
<p dir="auto">For example, in the <code>Defaultconvention</code> convention implemented
by <a href="https://github.com/JuliaAI/ScientificTypes.jl">ScientificTypes</a>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; scitype((1, 4.5), Defaultconvention())
Tuple{Count, Continuous}"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">scitype</span>((<span class="pl-c1">1</span>, <span class="pl-c1">4.5</span>), <span class="pl-c1">Defaultconvention</span>())
Tuple{Count, Continuous}</pre></div>
<p dir="auto"><strong>Property 3.</strong> For any given convention <code>C</code>, the scitype of an
<code>AbstractArray</code>, <code>A</code>, is always<code>AbstractArray{U}</code> where <code>U</code> is the union
of the scitypes of the elements of <code>A</code> under convention <code>C</code>, with one
exception: If <code>typeof(A) &lt;:AbstractArray{Union{Missing,T}}</code> for some <code>T</code>
different from <code>Any</code>, then the scitype of <code>A</code> is <code>AbstractArray{Union{Missing, U}}</code>,
where <code>U</code> is the union over all non-missing elements under convention <code>C</code>, <strong>even
if <code>A</code> has no missing elements.</strong></p>
<p dir="auto">This exception is made for performance reasons. In <code>DefaultConvention</code> implemented
by <a href="https://github.com/JuliaAI/ScientificTypes.jl">ScientificTypes</a>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; v = [1.3, 4.5, missing]
julia&gt; scitype(v, DefaultConvention())
AbstractArray{Union{Missing, Continuous}, 1}"><pre>julia<span class="pl-k">&gt;</span> v <span class="pl-k">=</span> [<span class="pl-c1">1.3</span>, <span class="pl-c1">4.5</span>, <span class="pl-c1">missing</span>]
julia<span class="pl-k">&gt;</span> <span class="pl-c1">scitype</span>(v, <span class="pl-c1">DefaultConvention</span>())
AbstractArray{Union{Missing, Continuous}, <span class="pl-c1">1</span>}</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; scitype(v[1:2], DefaultConvention())
AbstractArray{Union{Missing, Continuous},1}"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">scitype</span>(v[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>], <span class="pl-c1">DefaultConvention</span>())
AbstractArray{Union{Missing, Continuous},<span class="pl-c1">1</span>}</pre></div>
<blockquote>
<p dir="auto"><em>Performance note.</em> Computing type unions over large arrays is
expensive and, depending on the convention's implementation and the
array eltype, computing the scitype can be slow. In the common case
that the scitype of an array can be determined from the machine type
of the object alone, the implementer of a new connvention can speed
up compututations by implementing a <code>Scitype</code> method.  Do
<code>?ScientificTypesBase.Scitype</code> for details.</p>
</blockquote>
<h4 dir="auto"><a id="user-content-more-on-the-table-type" class="anchor" aria-hidden="true" href="#more-on-the-table-type"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>More on the <code>Table</code> type</h4>
<p dir="auto">An object of scitype <code>Table{K}</code> is expected to have a notion of
"columns", which are <code>AbstractVector</code>s, and the intention of the type
parameter <code>K</code> is to encode the scientific type(s) of its
columns. Specifically, developers are requested to adhere to the
following:</p>
<p dir="auto"><strong>Tabular data convention.</strong> If <code>scitype(X, C()) &lt;: Table</code>, for a given
convention <code>C</code> then in fact</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="scitype(X, C()) == Table{Union{scitype(c1, C), ..., scitype(cn, C)}}"><pre><span class="pl-c1">scitype</span>(X, <span class="pl-c1">C</span>()) <span class="pl-k">==</span> Table{Union{<span class="pl-c1">scitype</span>(c1, C), <span class="pl-k">...</span>, <span class="pl-c1">scitype</span>(cn, C)}}</pre></div>
<p dir="auto">where <code>c1</code>, <code>c2</code>, ..., <code>cn</code> are the columns of <code>X</code>. With this
definition, common type checks can be performed with tables.  For
instance, you could check that each column of <code>X</code> has an element
scitype that is either <code>Continuous</code> or <code>Finite</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="scitype(X, C()) &lt;: Table{&lt;:Union{AbstractVector{&lt;:Continuous}, AbstractVector{&lt;:Finite}}}"><pre lang="@example" class="notranslate"><code>scitype(X, C()) &lt;: Table{&lt;:Union{AbstractVector{&lt;:Continuous}, AbstractVector{&lt;:Finite}}}
</code></pre></div>
<p dir="auto">A built-in <code>Table</code> constructor provides a shorthand for the right-hand side:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="scitype(X, C()) &lt;: Table(Continuous, Finite)"><pre lang="@example" class="notranslate"><code>scitype(X, C()) &lt;: Table(Continuous, Finite)
</code></pre></div>
<p dir="auto">Note that <code>Table(Continuous, Finite)</code> is a <em>type</em> union and not a <code>Table</code> <em>instance</em>.</p>
<h2 dir="auto"><a id="user-content-defining-a-new-convention" class="anchor" aria-hidden="true" href="#defining-a-new-convention"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Defining a new convention</h2>
<p dir="auto">If you want to implement your own convention, you can consider the
<a href="https://github.com/JuliaAI/ScientificTypes.jl">ScientificTypes.jl</a>
as a blueprint.</p>
<p dir="auto">The steps below summarise the possible steps in defining such a convention:</p>
<ul dir="auto">
<li>declare a new convention,</li>
<li>add explicit <code>scitype</code> (and <code>Scitype</code>) definitions,</li>
<li>optionally define <code>coerce</code> methods for your convention</li>
</ul>
<p dir="auto">Each step is explained below, taking <code>DefaultConvenion</code> as an example.</p>
<h3 dir="auto"><a id="user-content-naming-the-convention" class="anchor" aria-hidden="true" href="#naming-the-convention"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Naming the convention</h3>
<p dir="auto">In the module, define a singleton as thus</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="struct MyConvention &lt;: ScientificTypesBase.Convention end"><pre><span class="pl-k">struct</span> MyConvention <span class="pl-k">&lt;:</span> <span class="pl-c1">ScientificTypesBase.Convention</span> <span class="pl-k">end</span></pre></div>
<h3 dir="auto"><a id="user-content-adding-explicit-scitype-declarations" class="anchor" aria-hidden="true" href="#adding-explicit-scitype-declarations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Adding explicit <code>scitype</code> declarations.</h3>
<p dir="auto">When overloading <code>scitype</code> one needs to dipatch over the convention,
as in this example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ScientificTypesBase.scitype(::Integer, ::MyConvention) = Count"><pre>ScientificTypesBase<span class="pl-k">.</span><span class="pl-en">scitype</span>(<span class="pl-k">::</span><span class="pl-c1">Integer</span>, <span class="pl-k">::</span><span class="pl-c1">MyConvention</span>) <span class="pl-k">=</span> Count</pre></div>
<p dir="auto">To avoid method ambiguities, avoid dispatching only on the first argument.
For example, defining</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ScientificTypesBase.scitype(::AbstractFloat, C) = Continous"><pre>ScientificTypesBase<span class="pl-k">.</span><span class="pl-en">scitype</span>(<span class="pl-k">::</span><span class="pl-c1">AbstractFloat</span>, C) <span class="pl-k">=</span> Continous</pre></div>
<p dir="auto">would lead to ambiguities in another package defining</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ScientificTypesBase.scitype(a, ::MyConvention) = Count"><pre>ScientificTypesBase<span class="pl-k">.</span><span class="pl-en">scitype</span>(a, <span class="pl-k">::</span><span class="pl-c1">MyConvention</span>) <span class="pl-k">=</span> Count</pre></div>
<p dir="auto">Since <code>ScientificTypesBase.jl</code> does not define a single-argument <code>scitype(X)</code> method, an implementation of a new scientific convention will typically want to explicitly implement the single argument method in their package, to save users from needing to explicitly specify a convention. That is, so the user can call <code>scitype(2.3)</code> instead of <code>scitype(2.3, MyConvention())</code>.</p>
<p dir="auto">For example, one declares:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="scitype(X) = scitype(X, MyConvention())"><pre><span class="pl-en">scitype</span>(X) <span class="pl-k">=</span> <span class="pl-c1">scitype</span>(X, <span class="pl-c1">MyConvention</span>())</pre></div>
<h3 dir="auto"><a id="user-content-defining-a-coerce-function" class="anchor" aria-hidden="true" href="#defining-a-coerce-function"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Defining a <code>coerce</code> function</h3>
<p dir="auto">It may be very useful to define a function to coerce machine types so
as to correct an unintended scientific interpretation, according to a
given convention.  In the <code>DefaultConvention</code> convention, this is implemented by
defining <code>coerce</code> methods (no stub provided by <code>ScientificTypesBase</code>)</p>
<p dir="auto">For instance consider the simplified:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function coerce(y::AbstractArray{T}, T2::Type{&lt;:Union{Missing, Continuous}}
                ) where T &lt;: Union{Missing, Real}
    return float(y)
end"><pre><span class="pl-k">function</span> <span class="pl-en">coerce</span>(y<span class="pl-k">::</span><span class="pl-c1">AbstractArray{T}</span>, T2<span class="pl-k">::</span><span class="pl-c1">Type{&lt;:Union{Missing, Continuous}}</span>
                ) <span class="pl-k">where</span> T <span class="pl-k">&lt;:</span> <span class="pl-c1">Union{Missing, Real}</span>
    <span class="pl-k">return</span> <span class="pl-c1">float</span>(y)
<span class="pl-k">end</span></pre></div>
<p dir="auto">Under this definition, <code>coerce([1, 2, 4], Continuous)</code> is mapped to
<code>[1.0, 2.0, 4.0]</code>, which has scitype <code>AbstractVector{Continuous}</code>.</p>
<p dir="auto">In the case of tabular data, one might additionally define <code>coerce</code>
methods to selectively coerce data in specified columns. See
<a href="https://github.com/JuliaAI/ScientificTypes.jl">ScientificTypes</a>
for examples.</p>
</article></div>