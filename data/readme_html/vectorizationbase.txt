<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-vectorizationbase" class="anchor" aria-hidden="true" href="#vectorizationbase"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>VectorizationBase</h1>
<p dir="auto"><a href="https://JuliaSIMD.github.io/VectorizationBase.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://JuliaSIMD.github.io/VectorizationBase.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/56f8252ba8e9d3f0b810769543f77823d2fe031ce560d4c2d69fb1fcad800383/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6c61746573742d626c75652e737667" alt="Latest" data-canonical-src="https://img.shields.io/badge/docs-latest-blue.svg" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaSIMD/VectorizationBase.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaSIMD/VectorizationBase.jl/workflows/CI/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaSIMD/VectorizationBase.jl/actions?query=workflow%3A%22CI+%28Julia+nightly%29%22"><img src="https://github.com/JuliaSIMD/VectorizationBase.jl/workflows/CI%20(Julia%20nightly)/badge.svg" alt="CI (Julia nightly)" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/JuliaSIMD/VectorizationBase.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/539df6ab88aa7c0dff2ce6e472757fc6f6caeca6b5aa401e4d818db5fe837b1b/68747470733a2f2f636f6465636f762e696f2f67682f4a756c696153494d442f566563746f72697a6174696f6e426173652e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/JuliaSIMD/VectorizationBase.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<hr>
<p dir="auto">This is a library providing basic SIMD support in Julia. VectorizationBase exists in large part to serve the needs of <a href="https://github.com/JuliaSIMD/LoopVectorization.jl">LoopVectorization.jl</a>'s code gen, prioritizing this over a stable user-facing API. Thus, you may wish to consider <a href="https://github.com/eschnett/SIMD.jl">SIMD.jl</a> as an alternative when writing explicit SIMD code in Julia. That said, the <code>Vec</code> and <code>VecUnroll</code> types are meant to "just work" as much as possible when passed to user-defined functions, so it should be reasonably stable in practice. Other parts of the code -- e.g, loading and storing vectors as well as the <code>stridedpointer</code> function -- will hopefully converge reasonably soon, and have support for various <code>AbstractArray</code> types propogated through the ecosystem by taking advantage of <a href="https://github.com/SciML/ArrayInterface.jl">ArrayInterface.jl</a>, so that VectorizationBase can begin to offer a stable, ergonomic, and well supported API fairly soon.</p>
<p dir="auto">It additionally provides some information on the host computer it is running on, which can be used to automate target-specific optimizations. Currently, x86_64 support is best on that front, but I'm looking to improve the quality of information provided for other architectures.</p>
<p dir="auto"><code>Vec</code>s are <code>Number</code>s and behave as a single objects; they just happen to contain multiple <code>Float64</code>. Therefore, it will behave like a single number rather than a collection with respect to indexing and reductions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using VectorizationBase

julia&gt; vx = Vec(ntuple(_ -&gt; 10randn(), VectorizationBase.pick_vector_width(Float64))...)
Vec{8,Float64}&lt;14.424983437388981, -7.7378330531368045, -3.499708331670689, -3.358981392002452, 22.519898671389406, -13.08647686033593, 13.96943264299162, -9.518537139443254&gt;

julia&gt; vx[1]
Vec{8,Float64}&lt;14.424983437388981, -7.7378330531368045, -3.499708331670689, -3.358981392002452, 22.519898671389406, -13.08647686033593, 13.96943264299162, -9.518537139443254&gt;

julia&gt; sum(vx)
Vec{8,Float64}&lt;14.424983437388981, -7.7378330531368045, -3.499708331670689, -3.358981392002452, 22.519898671389406, -13.08647686033593, 13.96943264299162, -9.518537139443254&gt;

julia&gt; a = 1.2;

julia&gt; a[1]
1.2

julia&gt; sum(a)
1.2"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> VectorizationBase

julia<span class="pl-k">&gt;</span> vx <span class="pl-k">=</span> <span class="pl-c1">Vec</span>(<span class="pl-c1">ntuple</span>(_ <span class="pl-k">-&gt;</span> <span class="pl-c1">10</span><span class="pl-c1">randn</span>(), VectorizationBase<span class="pl-k">.</span><span class="pl-c1">pick_vector_width</span>(Float64))<span class="pl-k">...</span>)
Vec{<span class="pl-c1">8</span>,Float64}<span class="pl-k">&lt;</span><span class="pl-c1">14.424983437388981</span>, <span class="pl-k">-</span><span class="pl-c1">7.7378330531368045</span>, <span class="pl-k">-</span><span class="pl-c1">3.499708331670689</span>, <span class="pl-k">-</span><span class="pl-c1">3.358981392002452</span>, <span class="pl-c1">22.519898671389406</span>, <span class="pl-k">-</span><span class="pl-c1">13.08647686033593</span>, <span class="pl-c1">13.96943264299162</span>, <span class="pl-k">-</span><span class="pl-c1">9.518537139443254</span><span class="pl-k">&gt;</span>

julia<span class="pl-k">&gt;</span> vx[<span class="pl-c1">1</span>]
Vec{<span class="pl-c1">8</span>,Float64}<span class="pl-k">&lt;</span><span class="pl-c1">14.424983437388981</span>, <span class="pl-k">-</span><span class="pl-c1">7.7378330531368045</span>, <span class="pl-k">-</span><span class="pl-c1">3.499708331670689</span>, <span class="pl-k">-</span><span class="pl-c1">3.358981392002452</span>, <span class="pl-c1">22.519898671389406</span>, <span class="pl-k">-</span><span class="pl-c1">13.08647686033593</span>, <span class="pl-c1">13.96943264299162</span>, <span class="pl-k">-</span><span class="pl-c1">9.518537139443254</span><span class="pl-k">&gt;</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(vx)
Vec{<span class="pl-c1">8</span>,Float64}<span class="pl-k">&lt;</span><span class="pl-c1">14.424983437388981</span>, <span class="pl-k">-</span><span class="pl-c1">7.7378330531368045</span>, <span class="pl-k">-</span><span class="pl-c1">3.499708331670689</span>, <span class="pl-k">-</span><span class="pl-c1">3.358981392002452</span>, <span class="pl-c1">22.519898671389406</span>, <span class="pl-k">-</span><span class="pl-c1">13.08647686033593</span>, <span class="pl-c1">13.96943264299162</span>, <span class="pl-k">-</span><span class="pl-c1">9.518537139443254</span><span class="pl-k">&gt;</span>

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-c1">1.2</span>;

julia<span class="pl-k">&gt;</span> a[<span class="pl-c1">1</span>]
<span class="pl-c1">1.2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">sum</span>(a)
<span class="pl-c1">1.2</span></pre></div>
<p dir="auto">To extract elements from a <code>Vec</code>, you call it, using parenthesis to index as you would in Fortran or MATLAB:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; vx(1), vx(2)
(14.424983437388981, -7.7378330531368045)

julia&gt; ntuple(vx, Val(8))
(14.424983437388981, -7.7378330531368045, -3.499708331670689, -3.358981392002452, 22.519898671389406, -13.08647686033593, 13.96943264299162, -9.518537139443254)

julia&gt; Tuple(vx) # defined for convenience
(14.424983437388981, -7.7378330531368045, -3.499708331670689, -3.358981392002452, 22.519898671389406, -13.08647686033593, 13.96943264299162, -9.518537139443254)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">vx</span>(<span class="pl-c1">1</span>), <span class="pl-c1">vx</span>(<span class="pl-c1">2</span>)
(<span class="pl-c1">14.424983437388981</span>, <span class="pl-k">-</span><span class="pl-c1">7.7378330531368045</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ntuple</span>(vx, <span class="pl-c1">Val</span>(<span class="pl-c1">8</span>))
(<span class="pl-c1">14.424983437388981</span>, <span class="pl-k">-</span><span class="pl-c1">7.7378330531368045</span>, <span class="pl-k">-</span><span class="pl-c1">3.499708331670689</span>, <span class="pl-k">-</span><span class="pl-c1">3.358981392002452</span>, <span class="pl-c1">22.519898671389406</span>, <span class="pl-k">-</span><span class="pl-c1">13.08647686033593</span>, <span class="pl-c1">13.96943264299162</span>, <span class="pl-k">-</span><span class="pl-c1">9.518537139443254</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">Tuple</span>(vx) <span class="pl-c"><span class="pl-c">#</span> defined for convenience</span>
(<span class="pl-c1">14.424983437388981</span>, <span class="pl-k">-</span><span class="pl-c1">7.7378330531368045</span>, <span class="pl-k">-</span><span class="pl-c1">3.499708331670689</span>, <span class="pl-k">-</span><span class="pl-c1">3.358981392002452</span>, <span class="pl-c1">22.519898671389406</span>, <span class="pl-k">-</span><span class="pl-c1">13.08647686033593</span>, <span class="pl-c1">13.96943264299162</span>, <span class="pl-k">-</span><span class="pl-c1">9.518537139443254</span>)</pre></div>
<p dir="auto">Unfortunately, this means no support for indexing with <code>begin</code>/<code>end</code>.</p>
<p dir="auto">Reductions are like the ordinary version, but prefixed with <code>v</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using VectorizationBase: vsum, vprod, vmaximum, vminimum

julia&gt; vsum(vx), sum(Tuple(vx))
(13.712777975180877, 13.712777975180877)

julia&gt; vprod(vx), prod(Tuple(vx))
(-5.141765647043406e7, -5.141765647043406e7)

julia&gt; vmaximum(vx), maximum(Tuple(vx))
(22.519898671389406, 22.519898671389406)

julia&gt; vminimum(vx), minimum(Tuple(vx))
(-13.08647686033593, -13.08647686033593)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> VectorizationBase<span class="pl-k">:</span> vsum, vprod, vmaximum, vminimum

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vsum</span>(vx), <span class="pl-c1">sum</span>(<span class="pl-c1">Tuple</span>(vx))
(<span class="pl-c1">13.712777975180877</span>, <span class="pl-c1">13.712777975180877</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vprod</span>(vx), <span class="pl-c1">prod</span>(<span class="pl-c1">Tuple</span>(vx))
(<span class="pl-k">-</span><span class="pl-c1">5.141765647043406e7</span>, <span class="pl-k">-</span><span class="pl-c1">5.141765647043406e7</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vmaximum</span>(vx), <span class="pl-c1">maximum</span>(<span class="pl-c1">Tuple</span>(vx))
(<span class="pl-c1">22.519898671389406</span>, <span class="pl-c1">22.519898671389406</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vminimum</span>(vx), <span class="pl-c1">minimum</span>(<span class="pl-c1">Tuple</span>(vx))
(<span class="pl-k">-</span><span class="pl-c1">13.08647686033593</span>, <span class="pl-k">-</span><span class="pl-c1">13.08647686033593</span>)</pre></div>
<p dir="auto">Here is an example of using <code>vload</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; A = rand(8,8);

julia&gt; vload(stridedpointer(A), (MM(W, 1), 1))
Vec{8, Float64}&lt;0.23659378106523243, 0.1572296679962767, 0.4139998988982545, 0.4068544124895789, 0.6365683129363592, 0.10041731176364777, 0.6198701180649783, 0.18351031426464992&gt;

julia&gt; A[1:W,1]'
1×8 adjoint(::Vector{Float64}) with eltype Float64:
 0.236594  0.15723  0.414  0.406854  0.636568  0.100417  0.61987  0.18351

julia&gt; vload(stridedpointer(A), (1, MM(W, 1)))
Vec{8, Float64}&lt;0.23659378106523243, 0.43800087768259754, 0.5833216557209256, 0.8076063696863035, 0.12069215155721758, 0.6015627184700922, 0.1390837892914757, 0.9139206013822945&gt;

julia&gt; A[1,1:W]'
1×8 adjoint(::Vector{Float64}) with eltype Float64:
 0.236594  0.438001  0.583322  0.807606  0.120692  0.601563  0.139084  0.913921

julia&gt; vload(stridedpointer(A), (MM(W,1), MM(W, 1)))
Vec{8, Float64}&lt;0.23659378106523243, 0.7580627352162604, 0.044776171518136954, 0.218587536875811, 0.4596625543892163, 0.2933303822991349, 0.30481677678671315, 0.3595115888246907&gt;

julia&gt; getindex.(Ref(A), 1:W, 1:W)'
1×8 adjoint(::Vector{Float64}) with eltype Float64:
 0.236594  0.758063  0.0447762  0.218588  0.459663  0.29333  0.304817  0.359512"><pre>julia<span class="pl-k">&gt;</span> A <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">8</span>,<span class="pl-c1">8</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vload</span>(<span class="pl-c1">stridedpointer</span>(A), (<span class="pl-c1">MM</span>(W, <span class="pl-c1">1</span>), <span class="pl-c1">1</span>))
Vec{<span class="pl-c1">8</span>, Float64}<span class="pl-k">&lt;</span><span class="pl-c1">0.23659378106523243</span>, <span class="pl-c1">0.1572296679962767</span>, <span class="pl-c1">0.4139998988982545</span>, <span class="pl-c1">0.4068544124895789</span>, <span class="pl-c1">0.6365683129363592</span>, <span class="pl-c1">0.10041731176364777</span>, <span class="pl-c1">0.6198701180649783</span>, <span class="pl-c1">0.18351031426464992</span><span class="pl-k">&gt;</span>

julia<span class="pl-k">&gt;</span> A[<span class="pl-c1">1</span><span class="pl-k">:</span>W,<span class="pl-c1">1</span>]<span class="pl-k">'</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">8</span> <span class="pl-c1">adjoint</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>) with eltype Float64<span class="pl-k">:</span>
 <span class="pl-c1">0.236594</span>  <span class="pl-c1">0.15723</span>  <span class="pl-c1">0.414</span>  <span class="pl-c1">0.406854</span>  <span class="pl-c1">0.636568</span>  <span class="pl-c1">0.100417</span>  <span class="pl-c1">0.61987</span>  <span class="pl-c1">0.18351</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vload</span>(<span class="pl-c1">stridedpointer</span>(A), (<span class="pl-c1">1</span>, <span class="pl-c1">MM</span>(W, <span class="pl-c1">1</span>)))
Vec{<span class="pl-c1">8</span>, Float64}<span class="pl-k">&lt;</span><span class="pl-c1">0.23659378106523243</span>, <span class="pl-c1">0.43800087768259754</span>, <span class="pl-c1">0.5833216557209256</span>, <span class="pl-c1">0.8076063696863035</span>, <span class="pl-c1">0.12069215155721758</span>, <span class="pl-c1">0.6015627184700922</span>, <span class="pl-c1">0.1390837892914757</span>, <span class="pl-c1">0.9139206013822945</span><span class="pl-k">&gt;</span>

julia<span class="pl-k">&gt;</span> A[<span class="pl-c1">1</span>,<span class="pl-c1">1</span><span class="pl-k">:</span>W]<span class="pl-k">'</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">8</span> <span class="pl-c1">adjoint</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>) with eltype Float64<span class="pl-k">:</span>
 <span class="pl-c1">0.236594</span>  <span class="pl-c1">0.438001</span>  <span class="pl-c1">0.583322</span>  <span class="pl-c1">0.807606</span>  <span class="pl-c1">0.120692</span>  <span class="pl-c1">0.601563</span>  <span class="pl-c1">0.139084</span>  <span class="pl-c1">0.913921</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">vload</span>(<span class="pl-c1">stridedpointer</span>(A), (<span class="pl-c1">MM</span>(W,<span class="pl-c1">1</span>), <span class="pl-c1">MM</span>(W, <span class="pl-c1">1</span>)))
Vec{<span class="pl-c1">8</span>, Float64}<span class="pl-k">&lt;</span><span class="pl-c1">0.23659378106523243</span>, <span class="pl-c1">0.7580627352162604</span>, <span class="pl-c1">0.044776171518136954</span>, <span class="pl-c1">0.218587536875811</span>, <span class="pl-c1">0.4596625543892163</span>, <span class="pl-c1">0.2933303822991349</span>, <span class="pl-c1">0.30481677678671315</span>, <span class="pl-c1">0.3595115888246907</span><span class="pl-k">&gt;</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">getindex</span>.(<span class="pl-c1">Ref</span>(A), <span class="pl-c1">1</span><span class="pl-k">:</span>W, <span class="pl-c1">1</span><span class="pl-k">:</span>W)<span class="pl-k">'</span>
<span class="pl-c1">1</span><span class="pl-k">×</span><span class="pl-c1">8</span> <span class="pl-c1">adjoint</span>(<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>) with eltype Float64<span class="pl-k">:</span>
 <span class="pl-c1">0.236594</span>  <span class="pl-c1">0.758063</span>  <span class="pl-c1">0.0447762</span>  <span class="pl-c1">0.218588</span>  <span class="pl-c1">0.459663</span>  <span class="pl-c1">0.29333</span>  <span class="pl-c1">0.304817</span>  <span class="pl-c1">0.359512</span></pre></div>
<p dir="auto">The basic idea is that you have a tuple of indices. The <code>MM</code> type indicates that it is vectorized. In the above example, we vectorize the load along colums, then rows, and then both. This is equivalent to loading the column, row, and diagonal.
Note that you can pass a <code>Mask</code> argument to mask off extra loads/stores.</p>
</article></div>