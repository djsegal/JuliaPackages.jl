<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto"><a id="user-content-combinat"></a></p>
<p dir="auto"><a id="user-content-combinat-1"></a></p>
<h1 dir="auto"><a id="user-content-combinat" class="anchor" aria-hidden="true" href="#combinat"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Combinat</h1>
<ul dir="auto">
<li><a href="index.md#Combinat">Combinat</a></li>
</ul>
<p dir="auto"><a id="user-content-combinat" href="#Combinat">#</a>
<strong><code>Combinat</code></strong> — <em>Module</em>.</p>
<p dir="auto">This  module is  a Julia  port of  some GAP  combinatorics and basic number theory. The only dependency is the package <code>Primes</code>.</p>
<p dir="auto">The list of functions it exports are:</p>
<p dir="auto">Classical enumerations:</p>
<p dir="auto"><a href="index.md#Combinat.combinations"><code>combinations</code></a>, <a href="index.md#Combinat.arrangements"><code>arrangements</code></a>, <a href="index.md#Combinat.permutations"><code>permutations</code></a>, <a href="index.md#Combinat.partitions"><code>partitions</code></a>, <a href="index.md#Combinat.partition_tuples"><code>partition_tuples</code></a>, <a href="index.md#Combinat.compositions"><code>compositions</code></a>, <a href="index.md#Combinat.multisets"><code>multisets</code></a></p>
<p dir="auto">functions to count them without computing them:</p>
<p dir="auto"><code>ncombinations</code>, <code>narrangements</code>, <code>npartitions</code>, <code>npartition_tuples</code>, <code>ncompositions</code>, <code>nmultisets</code></p>
<p dir="auto">some functions on partitions and permutations:</p>
<p dir="auto"><a href="index.md#Combinat.lcm_partitions"><code>lcm_partitions</code></a>, <a href="index.md#Combinat.gcd_partitions"><code>gcd_partitions</code></a>, <a href="index.md#Combinat.conjugate_partition"><code>conjugate_partition</code></a>, <a href="index.md#Combinat.dominates"><code>dominates</code></a>, <a href="index.md#Combinat.tableaux"><code>tableaux</code></a>, <a href="index.md#Combinat.robinson_schensted"><code>robinson_schensted</code></a></p>
<p dir="auto">counting functions:</p>
<p dir="auto"><a href="index.md#Combinat.bell"><code>bell</code></a>, <a href="index.md#Combinat.stirling1"><code>stirling1</code></a>, <a href="index.md#Combinat.stirling2"><code>stirling2</code></a>, <a href="index.md#Combinat.catalan-Tuple%7BInteger%7D"><code>catalan</code></a>, <a href="index.md#Combinat.bernoulli"><code>bernoulli</code></a></p>
<p dir="auto">number theory</p>
<p dir="auto"><a href="index.md#Combinat.divisors"><code>divisors</code></a>, <a href="index.md#Combinat.prime_residues"><code>prime_residues</code></a>, <a href="index.md#Combinat.primitiveroot"><code>primitiveroot</code></a></p>
<p dir="auto">some structural manipulations not yet in Julia:</p>
<p dir="auto"><a href="index.md#Combinat.groupby"><code>groupby</code></a>, <a href="index.md#Combinat.tally"><code>tally</code></a>, <a href="index.md#Combinat.tally_sorted"><code>tally_sorted</code></a>, <a href="index.md#Combinat.collectby"><code>collectby</code></a>, <a href="index.md#Combinat.unique_sorted!"><code>unique_sorted!</code></a></p>
<p dir="auto">matrix blocks:</p>
<p dir="auto"><a href="index.md#Combinat.blocks-Tuple%7BAbstractMatrix%7D"><code>blocks</code></a>, <a href="index.md#Combinat.diagblocks"><code>diagblocks</code></a></p>
<p dir="auto">Have  a  look  at  the  individual  docstrings  and  enjoy (any feedback is welcome).</p>
<p dir="auto">After   writing  most  of  this  module  I  became  aware  of  the  package <code>Combinatorics</code>  which has a  considerable overlap. However  there are some fundamental   disagreements   between   these   two  packages  which  makes <code>Combinatorics</code> not easily usable for me:</p>
<ul dir="auto">
<li>often I  use sorting  in algorithms  when <code>Combinatorics</code>  use hashing. Thus  the algorithms cannot be applied to the same objects (and sorting is  often  faster).  I  provide  optionally  a  hashing variant of some algorithms.</li>
<li><code>Combinatorics.combinations</code> does not include the empty set.</li>
<li>I use lower case for functions and Camel case for structs (Iterators). <code>Combinatorics</code>  does not have functions for classical enumerations but only (lowercase) iterators.</li>
</ul>
<p dir="auto">Some  less fundamental  disagreements is  disagreement on  names. However I would  welcome discussions  with the  authors of  <code>Combinatorics</code> to see if both packages could be made more compatible.</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1-L84">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.combinations" href="#Combinat.combinations">#</a>
<strong><code>Combinat.combinations</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>combinations(mset[,k];dict=false)</code>,  <code>ncombinations(mset[,k];dict=false)</code></p>
<p dir="auto"><code>combinations</code>   returns  all  combinations  of   the  multiset  <code>mset</code>  (a collection  or  iterable  with  possible  repetitions). If a second integer argument  <code>k</code> is given, it returns  the combinations with <code>k</code> elements. <code>k</code> may  also be a vector  of integers, then it  returns the combinations whose number of elements is one of these integers.</p>
<p dir="auto"><code>ncombinations</code> returns (faster) the number of combinations.</p>
<p dir="auto">A  <em>combination</em> is an unordered subsequence.</p>
<p dir="auto">By  default, the elements of <code>mset</code>  are assumed sortable and a combination is  represented by a sorted <code>Vector</code>.  The combinations with a fixed number <code>k</code>  of  elements  are  listed  in  lexicographic order. If the elements of <code>mset</code>  are not sortable but hashable, the keyword <code>dict=true</code> can be given and the (slightly slower) computation is done using a <code>Dict</code>.</p>
<p dir="auto">If  <code>mset</code> has  no repetitions,  the list  of all  combinations is just the <em>powerset</em> of <code>mset</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; ncombinations([1,2,2,3])
12

julia&gt; combinations([1,2,2,3])
12-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [1, 2]
 [1, 3]
 [2, 2]
 [2, 3]
 [1, 2, 2]
 [1, 2, 3]
 [2, 2, 3]
 [1, 2, 2, 3]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; ncombinations([1,2,2,3])
12

julia&gt; combinations([1,2,2,3])
12-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [1, 2]
 [1, 3]
 [2, 2]
 [2, 3]
 [1, 2, 2]
 [1, 2, 3]
 [2, 2, 3]
 [1, 2, 2, 3]
</code></pre></div>
<p dir="auto">The  combinations  are  implemented  by an iterator <code>Combinat.Combinations</code> which can enumerate the combinations of a large multiset.</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L419-L462">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.combinations" href="#Combinat.Combinations">#</a>
<strong><code>Combinat.Combinations</code></strong> — <em>Type</em>.</p>
<p dir="auto"><code>Combinat.Combinations(s[,k])</code>   is  an   iterator  which   enumerates  the combinations  of  the  multiset  <code>s</code>  (with  <code>k</code>  elements  if <code>k</code>given) in lexicographic  order. The elements of <code>s</code> must be sortable. If they are not but  hashable giving  the keyword  <code>dict=true</code> will  give an iterator for a non-sorted result.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; a=Combinat.Combinations(1:4);

julia&gt; collect(a)
16-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [4]
 [1, 2]
 [1, 3]
 [1, 4]
 [2, 3]
 [2, 4]
 [3, 4]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [2, 3, 4]
 [1, 2, 3, 4]

julia&gt; a=Combinat.Combinations([1,2,2,3,4,4],3)
Combinations([1, 2, 2, 3, 4, 4],3)

julia&gt; collect(a)
10-element Vector{Vector{Int64}}:
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 4]
 [2, 4, 4]
 [3, 4, 4]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; a=Combinat.Combinations(1:4);

julia&gt; collect(a)
16-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [4]
 [1, 2]
 [1, 3]
 [1, 4]
 [2, 3]
 [2, 4]
 [3, 4]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [2, 3, 4]
 [1, 2, 3, 4]

julia&gt; a=Combinat.Combinations([1,2,2,3,4,4],3)
Combinations([1, 2, 2, 3, 4, 4],3)

julia&gt; collect(a)
10-element Vector{Vector{Int64}}:
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 4]
 [2, 4, 4]
 [3, 4, 4]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L310-L354">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.arrangements" href="#Combinat.arrangements">#</a>
<strong><code>Combinat.arrangements</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>arrangements(mset[,k])</code>, <code>narrangements(mset[,k])</code></p>
<p dir="auto"><code>arrangements</code>  returns  the  arrangements  of  the  multiset <code>mset</code> (a not necessarily  sorted  collection  with  possible  repetitions).  If a second argument   <code>k</code>  is  given,  it  returns  arrangements  with  <code>k</code>  elements. <code>narrangements</code> returns (faster) the number of arrangements.</p>
<p dir="auto">An <em>arrangement</em> of <code>mset</code> with <code>k</code> elements is a subsequence of length <code>k</code> taken in arbitrary order, representated as a <code>Vector</code>. When <code>k==length(mset)</code> it is also called a permutation.</p>
<p dir="auto">As  an example of arrangements  of a multiset, think  of the game Scrabble. Suppose  you have the six  characters of the word  'settle' and you have to make a two letter word. Then the possibilities are given by</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; narrangements(&quot;settle&quot;,2)
14"><pre lang="julia-repl" class="notranslate"><code>julia&gt; narrangements("settle",2)
14
</code></pre></div>
<p dir="auto">while all possible words (including the empty one) are:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; narrangements(&quot;settle&quot;)
523"><pre lang="julia-repl" class="notranslate"><code>julia&gt; narrangements("settle")
523
</code></pre></div>
<p dir="auto">The  result returned  by 'arrangements'  is sorted  (the elements of <code>mset</code> must  be sortable), which means in  this example that the possibilities are listed  in the same  order as they  appear in the  dictionary. Here are the two-letter words:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; String.(arrangements(&quot;settle&quot;,2))
14-element Vector{String}:
 &quot;ee&quot;
 &quot;el&quot;
 &quot;es&quot;
 &quot;et&quot;
 &quot;le&quot;
 &quot;ls&quot;
 &quot;lt&quot;
 &quot;se&quot;
 &quot;sl&quot;
 &quot;st&quot;
 &quot;te&quot;
 &quot;tl&quot;
 &quot;ts&quot;
 &quot;tt&quot;"><pre lang="julia-repl" class="notranslate"><code>julia&gt; String.(arrangements("settle",2))
14-element Vector{String}:
 "ee"
 "el"
 "es"
 "et"
 "le"
 "ls"
 "lt"
 "se"
 "sl"
 "st"
 "te"
 "tl"
 "ts"
 "tt"
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L503-L552">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.permutations" href="#Combinat.permutations">#</a>
<strong><code>Combinat.permutations</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>permutations(n)</code></p>
<p dir="auto">returns  in lexicographic order the permutations of <code>1:n</code>. This is a faster version  of  <code>arrangements(1:n,n)</code>.  <code>permutations</code>  is  implemented  by an iterator  <code>Combinat.Permutations</code>  which  can  be  used  to  enumerate  the permutations of a large number.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; permutations(3)
6-element Vector{Any}:
 [1, 2, 3]
 [1, 3, 2]
 [2, 1, 3]
 [2, 3, 1]
 [3, 1, 2]
 [3, 2, 1]

julia&gt; sum(first(p) for p in Combinat.Permutations(5))
360"><pre lang="julia-repl" class="notranslate"><code>julia&gt; permutations(3)
6-element Vector{Any}:
 [1, 2, 3]
 [1, 3, 2]
 [2, 1, 3]
 [2, 3, 1]
 [3, 1, 2]
 [3, 2, 1]

julia&gt; sum(first(p) for p in Combinat.Permutations(5))
360
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L591-L612">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.partitions" href="#Combinat.partitions">#</a>
<strong><code>Combinat.partitions</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>partitions(n::Integer[,k])</code>, <code>npartitions(n::Integer[,k])</code></p>
<p dir="auto"><code>partitions</code>  returns in lexicographic order the partitions (with <code>k</code> parts if  <code>k</code>  is  given)  of  the  positive  integer <code>n</code> . <code>npartitions</code> returns (faster) the number of partitions.</p>
<p dir="auto">There are approximately <code>exp(π√(2n/3))/(4√3 n)</code> partitions of <code>n</code>.</p>
<p dir="auto">A   <em>partition</em>  is   a  decomposition   <code>n=p₁+p₂+…+pₖ</code>  in  integers  with <code>p₁≥p₂≥…≥pₖ&gt;0</code>, and is represented by the vector <code>p=[p₁,p₂,…,pₖ]</code>. We write <code>p⊢n</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; npartitions(7)
15

julia&gt; partitions(7)
15-element Vector{Vector{Int64}}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [2, 2, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [3, 2, 2]
 [3, 3, 1]
 [4, 1, 1, 1]
 [4, 2, 1]
 [4, 3]
 [5, 1, 1]
 [5, 2]
 [6, 1]
 [7]

julia&gt; npartitions(7,3)
4

julia&gt; partitions(7,3)
4-element Vector{Vector{Int64}}:
 [3, 2, 2]
 [3, 3, 1]
 [4, 2, 1]
 [5, 1, 1]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; npartitions(7)
15

julia&gt; partitions(7)
15-element Vector{Vector{Int64}}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [2, 2, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [3, 2, 2]
 [3, 3, 1]
 [4, 1, 1, 1]
 [4, 2, 1]
 [4, 3]
 [5, 1, 1]
 [5, 2]
 [6, 1]
 [7]

julia&gt; npartitions(7,3)
4

julia&gt; partitions(7,3)
4-element Vector{Vector{Int64}}:
 [3, 2, 2]
 [3, 3, 1]
 [4, 2, 1]
 [5, 1, 1]
</code></pre></div>
<p dir="auto">The partitions are implemented by an iterator <code>Combinat.Partitions</code> which can be used to enumerate the partitions of a large number.</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L732-L780">source</a><br></p>
<p dir="auto"><code>partitions(n::Integer,set::AbstractVector[,k])</code>, <code>npartitions(n::Integer,set::AbstractVector[,k])</code></p>
<p dir="auto">returns  the list  of partitions  of <code>n</code>  (with <code>k</code>  parts if <code>k</code> is given) restricted  to have parts in <code>set</code>. <code>npartitions</code> gives (faster) the number of such partitions.</p>
<p dir="auto">Let  us show how many ways there are to pay 17 cents using coins of 2,5 and 10 cents.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; npartitions(17,[10,5,2])
3

julia&gt; partitions(17,[10,5,2])
3-element Vector{Vector{Int64}}:
 [5, 2, 2, 2, 2, 2, 2]
 [5, 5, 5, 2]
 [10, 5, 2]

julia&gt; npartitions(17,[10,5,2],3) # pay with 3 coins
1

julia&gt; partitions(17,[10,5,2],3) 
1-element Vector{Vector{Int64}}:
 [10, 5, 2]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; npartitions(17,[10,5,2])
3

julia&gt; partitions(17,[10,5,2])
3-element Vector{Vector{Int64}}:
 [5, 2, 2, 2, 2, 2, 2]
 [5, 5, 5, 2]
 [10, 5, 2]

julia&gt; npartitions(17,[10,5,2],3) # pay with 3 coins
1

julia&gt; partitions(17,[10,5,2],3) 
1-element Vector{Vector{Int64}}:
 [10, 5, 2]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L814-L840">source</a><br></p>
<p dir="auto"><code>partitions(set::AbstractVector[,k])</code>, <code>npartitions(set::AbstractVector[,k])</code></p>
<p dir="auto">the  set of all unordered  partitions (in <code>k</code> sets  if <code>k</code> is given) of the set  <code>set</code> (a  collection without  repetitions). <code>npartitions</code>  returns the number of unordered partitions.</p>
<p dir="auto">An <em>unordered partition</em> of <code>set</code> is a set of pairwise disjoints sets whose union is equal to <code>set</code>, and is represented by a Vector of Vectors.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; npartitions(1:3)
5

julia&gt; partitions(1:3)
5-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 3]]
 [[1, 2], [3]]
 [[1, 3], [2]]
 [[1], [2, 3]]
 [[1], [2], [3]]

julia&gt; npartitions(1:4,2)
7

julia&gt; partitions(1:4,2)
7-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 3], [4]]
 [[1, 2, 4], [3]]
 [[1, 2], [3, 4]]
 [[1, 3, 4], [2]]
 [[1, 3], [2, 4]]
 [[1, 4], [2, 3]]
 [[1], [2, 3, 4]]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; npartitions(1:3)
5

julia&gt; partitions(1:3)
5-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 3]]
 [[1, 2], [3]]
 [[1, 3], [2]]
 [[1], [2, 3]]
 [[1], [2], [3]]

julia&gt; npartitions(1:4,2)
7

julia&gt; partitions(1:4,2)
7-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 3], [4]]
 [[1, 2, 4], [3]]
 [[1, 2], [3, 4]]
 [[1, 3, 4], [2]]
 [[1, 3], [2, 4]]
 [[1, 4], [2, 3]]
 [[1], [2, 3, 4]]
</code></pre></div>
<p dir="auto">Note  that <code>unique(sort.(partitions(mset[,k])))</code>  is a  version which works for a multiset <code>mset</code>. There is currently no ordered counterpart.</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L925-L962">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.partitions" href="#Combinat.Partitions">#</a>
<strong><code>Combinat.Partitions</code></strong> — <em>Type</em>.</p>
<p dir="auto"><code>Combinat.Partitions(n[,k])</code> is an iterator which enumerates the partitions of <code>n</code> (with <code>k</code>part if <code>k</code>given) in lexicographic order.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; a=Combinat.Partitions(5)
Partitions(5)

julia&gt; collect(a)
7-element Vector{Vector{Int64}}:
 [1, 1, 1, 1, 1]
 [2, 1, 1, 1]
 [2, 2, 1]
 [3, 1, 1]
 [3, 2]
 [4, 1]
 [5]

julia&gt; a=Combinat.Partitions(10,3)
Partitions(10,3)

julia&gt; collect(a)
8-element Vector{Vector{Int64}}:
 [4, 3, 3]
 [4, 4, 2]
 [5, 3, 2]
 [5, 4, 1]
 [6, 2, 2]
 [6, 3, 1]
 [7, 2, 1]
 [8, 1, 1]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; a=Combinat.Partitions(5)
Partitions(5)

julia&gt; collect(a)
7-element Vector{Vector{Int64}}:
 [1, 1, 1, 1, 1]
 [2, 1, 1, 1]
 [2, 2, 1]
 [3, 1, 1]
 [3, 2]
 [4, 1]
 [5]

julia&gt; a=Combinat.Partitions(10,3)
Partitions(10,3)

julia&gt; collect(a)
8-element Vector{Vector{Int64}}:
 [4, 3, 3]
 [4, 4, 2]
 [5, 3, 2]
 [5, 4, 1]
 [6, 2, 2]
 [6, 3, 1]
 [7, 2, 1]
 [8, 1, 1]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L642-L673">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.partition_tuples" href="#Combinat.partition_tuples">#</a>
<strong><code>Combinat.partition_tuples</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>partition_tuples(n,r)</code>, <code>npartition_tuples(n,r)</code></p>
<p dir="auto">the <code>r</code>-tuples of partitions that together partition <code>n</code>. <code>npartition_tuples</code> is the number of partition tuples.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; npartition_tuples(3,2)
10

julia&gt; partition_tuples(3,2)
10-element Vector{Vector{Vector{Int64}}}:
 [[1, 1, 1], []]
 [[1, 1], [1]]
 [[1], [1, 1]]
 [[], [1, 1, 1]]
 [[2, 1], []]
 [[1], [2]]
 [[2], [1]]
 [[], [2, 1]]
 [[3], []]
 [[], [3]]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; npartition_tuples(3,2)
10

julia&gt; partition_tuples(3,2)
10-element Vector{Vector{Vector{Int64}}}:
 [[1, 1, 1], []]
 [[1, 1], [1]]
 [[1], [1, 1]]
 [[], [1, 1, 1]]
 [[2, 1], []]
 [[1], [2]]
 [[2], [1]]
 [[], [2, 1]]
 [[3], []]
 [[], [3]]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1143-L1166">source</a><br></p>
<p dir="auto"><a id="user-content-combinat.compositions" href="#Combinat.compositions">#</a>
<strong><code>Combinat.compositions</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>compositions(n[,k];min=1)</code>, <code>ncompositions(n[,k];min=1)</code></p>
<p dir="auto">This  function returns the compositions of  <code>n</code> (the compositions of length <code>k</code>  if a second argument <code>k</code> is given), where a composition of the integer <code>n</code>  is a decomposition <code>n=p₁+…+pₖ</code> in  integers <code>≥min</code>, represented as the vector  <code>[p₁,…,pₖ]</code>. Unless <code>k</code> is given,  <code>min</code> must be <code>&gt;0</code>. Compositions are sometimes called ordered partitions.</p>
<p dir="auto"><code>ncompositions</code>  returns  (faster)  the  number  of compositions. There are <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9ed02b48b1186f939544ce51347f983c">$2^{n-1}$</math-renderer>  compositions of <code>n</code> in  integers <code>≥1</code>, and <code>binomial(n-1,k-1)</code> compositions of <code>n</code> in <code>k</code> parts <code>≥1</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; ncompositions(4)
8

julia&gt; compositions(4)
8-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [4]
 [1, 3]
 [2, 2]
 [3, 1]
 [1, 1, 2]
 [1, 2, 1]
 [2, 1, 1]
 [1, 1, 1, 1]

julia&gt; ncompositions(4,2)
3

julia&gt; compositions(4,2)
3-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [1, 3]
 [2, 2]
 [3, 1]

julia&gt; ncompositions(4,2;min=0)
5

julia&gt; compositions(4,2;min=0)
5-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [0, 4]
 [1, 3]
 [2, 2]
 [3, 1]
 [4, 0]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; ncompositions(4)
8

julia&gt; compositions(4)
8-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [4]
 [1, 3]
 [2, 2]
 [3, 1]
 [1, 1, 2]
 [1, 2, 1]
 [2, 1, 1]
 [1, 1, 1, 1]

julia&gt; ncompositions(4,2)
3

julia&gt; compositions(4,2)
3-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [1, 3]
 [2, 2]
 [3, 1]

julia&gt; ncompositions(4,2;min=0)
5

julia&gt; compositions(4,2;min=0)
5-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [0, 4]
 [1, 3]
 [2, 2]
 [3, 1]
 [4, 0]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1212-L1260">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.multisets" href="#Combinat.multisets">#</a>
<strong><code>Combinat.multisets</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>multisets(set,k)</code>, <code>nmultisets(set,k)</code></p>
<p dir="auto"><code>multisets</code>  returns  the  set  of  all  multisets of length <code>k</code> made of elements   of   the   set   <code>set</code>   (a   collection  without  repetitions). <code>nmultisets</code> returns the number of multisets.</p>
<p dir="auto">An  <em>multiset</em> of length <code>k</code> is  an unordered selection with repetitions of length  <code>k</code> from <code>set</code> and is represented  by a sorted vector of length <code>k</code> made  of elements  from <code>set</code>  (it is  also sometimes called a "combination with replacement").</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; multisets(1:4,3)
20-element Vector{Vector{Int64}}:
 [1, 1, 1]
 [1, 1, 2]
 [1, 1, 3]
 [1, 1, 4]
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 3]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 2]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 3]
 [2, 3, 4]
 [2, 4, 4]
 [3, 3, 3]
 [3, 3, 4]
 [3, 4, 4]
 [4, 4, 4]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; multisets(1:4,3)
20-element Vector{Vector{Int64}}:
 [1, 1, 1]
 [1, 1, 2]
 [1, 1, 3]
 [1, 1, 4]
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 3]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 2]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 3]
 [2, 3, 4]
 [2, 4, 4]
 [3, 3, 3]
 [3, 3, 4]
 [3, 4, 4]
 [4, 4, 4]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1290-L1326">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.lcm_partitions" href="#Combinat.lcm_partitions">#</a>
<strong><code>Combinat.lcm_partitions</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>lcm_partitions(p1,…,pn)</code></p>
<p dir="auto">each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p>
<p dir="auto">The result is the finest partition of <code>S</code> such that each argument partition refines it. It represents the 'or' of the equivalence relations represented by the arguments.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; lcm_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
2-element Vector{Vector{Int64}}:
 [1, 2, 5, 6]
 [3, 4]      "><pre lang="julia-repl" class="notranslate"><code>julia&gt; lcm_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
2-element Vector{Vector{Int64}}:
 [1, 2, 5, 6]
 [3, 4]      
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1384-L1401">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.gcd_partitions" href="#Combinat.gcd_partitions">#</a>
<strong><code>Combinat.gcd_partitions</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>gcd_partitions(p1,…,pn)</code></p>
<p dir="auto">Each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p>
<p dir="auto">The result is the coarsest partition which refines all argument partitions. It  represents the  'and' of  the equivalence  relations represented by the arguments.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; gcd_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
6-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; gcd_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
6-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1417-L1438">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.conjugate_partition" href="#Combinat.conjugate_partition">#</a>
<strong><code>Combinat.conjugate_partition</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>conjugate_partition(λ)</code></p>
<p dir="auto">returns  the  conjugate  partition  of  the  partition  <code>λ</code>,  that  is, the partition having the transposed of the Young diagram of <code>λ</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; conjugate_partition([4,2,1])
4-element Vector{Int64}:
 3
 2
 1
 1

julia&gt; conjugate_partition([6])
6-element Vector{Int64}:
 1
 1
 1
 1
 1
 1"><pre lang="julia-repl" class="notranslate"><code>julia&gt; conjugate_partition([4,2,1])
4-element Vector{Int64}:
 3
 2
 1
 1

julia&gt; conjugate_partition([6])
6-element Vector{Int64}:
 1
 1
 1
 1
 1
 1
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1565-L1588">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.dominates" href="#Combinat.dominates">#</a>
<strong><code>Combinat.dominates</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>dominates(λ,μ)</code></p>
<p dir="auto">The  dominance  order  on  partitions  is  an  important  partial  order in representation theory. <code>λ</code> dominates <code>μ</code> if and only if for all <code>i</code> we have <code>sum(λ[1:i])≥sum(μ[1:i])</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; dominates([5,4],[4,4,1])
true"><pre lang="julia-repl" class="notranslate"><code>julia&gt; dominates([5,4],[4,4,1])
true
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1596-L1607">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.tableaux" href="#Combinat.tableaux">#</a>
<strong><code>Combinat.tableaux</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>tableaux(S)</code></p>
<p dir="auto">if  <code>S</code>  is  a  partition  tuple,  returns  the  list  of standard tableaux associated  to the partition tuple <code>S</code>, that is a filling of the associated young  diagrams  with  the  numbers  <code>1:sum(sum,S)</code>  such  that the numbers increase across the rows and down the columns.</p>
<p dir="auto">If  <code>S</code> is a single partition, the standard tableaux for that partition are returned.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; tableaux([[2,1],[1]])
8-element Vector{Vector{Vector{Vector{Int64}}}}:
 [[[1, 2], [3]], [[4]]]
 [[[1, 2], [4]], [[3]]]
 [[[1, 3], [2]], [[4]]]
 [[[1, 3], [4]], [[2]]]
 [[[1, 4], [2]], [[3]]]
 [[[1, 4], [3]], [[2]]]
 [[[2, 3], [4]], [[1]]]
 [[[2, 4], [3]], [[1]]]

julia&gt; tableaux([2,2])
2-element Vector{Vector{Vector{Int64}}}:
 [[1, 2], [3, 4]]
 [[1, 3], [2, 4]]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; tableaux([[2,1],[1]])
8-element Vector{Vector{Vector{Vector{Int64}}}}:
 [[[1, 2], [3]], [[4]]]
 [[[1, 2], [4]], [[3]]]
 [[[1, 3], [2]], [[4]]]
 [[[1, 3], [4]], [[2]]]
 [[[1, 4], [2]], [[3]]]
 [[[1, 4], [3]], [[2]]]
 [[[2, 3], [4]], [[1]]]
 [[[2, 4], [3]], [[1]]]

julia&gt; tableaux([2,2])
2-element Vector{Vector{Vector{Int64}}}:
 [[1, 2], [3, 4]]
 [[1, 3], [2, 4]]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1616-L1644">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.robinson_schensted" href="#Combinat.robinson_schensted">#</a>
<strong><code>Combinat.robinson_schensted</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>robinson_schensted(p::AbstractVector{&lt;:Integer})</code></p>
<p dir="auto">returns  the pair of standard tableaux associated to the permutation <code>p</code> by the Robinson-Schensted correspondence.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; robinson_schensted([2,3,4,1])
([[1, 3, 4], [2]], [[1, 2, 3], [4]])"><pre lang="julia-repl" class="notranslate"><code>julia&gt; robinson_schensted([2,3,4,1])
([[1, 3, 4], [2]], [[1, 2, 3], [4]])
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1661-L1671">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.bell" href="#Combinat.bell">#</a>
<strong><code>Combinat.bell</code></strong> — <em>Function</em>.</p>
<p dir="auto">'bell(n)'</p>
<p dir="auto">The  Bell numbers are  defined by <code>bell(0)=1</code>  and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9ed02b48b1186f939544ce51347f983c">$bell(n+1)=∑_{k=0}^n {n \choose  k}bell(k)$</math-renderer>, or by the fact  that <code>bell(n)/n!</code> is the coefficient of <code>xⁿ</code> in the formal series <code>e^(eˣ-1)</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; bell.(0:6)
7-element Vector{Int64}:
   1
   1
   2
   5
  15
  52
 203

julia&gt; bell(14)
190899322

julia&gt; bell(big(30))
846749014511809332450147"><pre lang="julia-repl" class="notranslate"><code>julia&gt; bell.(0:6)
7-element Vector{Int64}:
   1
   1
   2
   5
  15
  52
 203

julia&gt; bell(14)
190899322

julia&gt; bell(big(30))
846749014511809332450147
</code></pre></div>
<p dir="auto">julia-repl</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1083-L1107">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.stirling1" href="#Combinat.stirling1">#</a>
<strong><code>Combinat.stirling1</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>stirling1(n,k)</code></p>
<p dir="auto">the  <em>Stirling  numbers  of  the  first  kind</em>  <code>S₁(n,k)</code>  are  defined  by <code>S₁(0,0)=1,   S₁(n,0)=S₁(0,k)=0</code>   if   <code>n,   k!=0</code>   and   the  recurrence <code>S₁(n,k)=(n-1)S₁(n-1,k)+S₁(n-1,k-1)</code>.</p>
<p dir="auto"><code>S₁(n,k)</code>  is the  number of  permutations of  <code>n</code> points  with <code>k</code> cycles. They   are   also   given   by   the   generating  function  <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9ed02b48b1186f939544ce51347f983c">$n!{x\choose n}=\sum_{k=0}^n(S₁(n,k) x^k)$</math-renderer>. Note the similarity to <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9ed02b48b1186f939544ce51347f983c">$x^n=\sum_{k=0}^n S₂(n,k)k!{x\choose k}$</math-renderer> (see  <code>stirling2</code>).  Also  the  definition of <code>S₁</code> implies  <code>S₁(n,k)=S₂(-k,-n)</code> if  <code>n,k&lt;0</code>. There  are many formulae relating Stirling  numbers of the first kind to Stirling numbers of the second kind, Bell numbers, and Binomial numbers.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; stirling1.(4,0:4) # Knuth calls this the trademark of S₁
5-element Vector{Int64}:
  0
  6
 11
  6
  1

julia&gt; [stirling1(n,k) for n in 0:6, k in 0:6] # similar to Pascal's triangle
7×7 Matrix{Int64}:
 1    0    0    0   0   0  0
 0    1    0    0   0   0  0
 0    1    1    0   0   0  0
 0    2    3    1   0   0  0
 0    6   11    6   1   0  0
 0   24   50   35  10   1  0
 0  120  274  225  85  15  1

julia&gt; stirling1(50,big(10)) # give `big` second argument to avoid overflow
101623020926367490059043797119309944043405505380503665627365376"><pre lang="julia-repl" class="notranslate"><code>julia&gt; stirling1.(4,0:4) # Knuth calls this the trademark of S₁
5-element Vector{Int64}:
  0
  6
 11
  6
  1

julia&gt; [stirling1(n,k) for n in 0:6, k in 0:6] # similar to Pascal's triangle
7×7 Matrix{Int64}:
 1    0    0    0   0   0  0
 0    1    0    0   0   0  0
 0    1    1    0   0   0  0
 0    2    3    1   0   0  0
 0    6   11    6   1   0  0
 0   24   50   35  10   1  0
 0  120  274  225  85  15  1

julia&gt; stirling1(50,big(10)) # give `big` second argument to avoid overflow
101623020926367490059043797119309944043405505380503665627365376
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L982-L1019">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.stirling2" href="#Combinat.stirling2">#</a>
<strong><code>Combinat.stirling2</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>stirling2(n,k)</code></p>
<p dir="auto">the  <em>Stirling  numbers  of  the  second  kind</em> are defined by <code>S₂(0,0)=1</code>, <code>S₂(n,0)=S₂(0,k)=0</code> if <code>n, k!=0</code> and <code>S₂(n,k)=k S₂(n-1,k)+S₂(n-1,k-1)</code>, and also as coefficients of the generating function <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9ed02b48b1186f939544ce51347f983c">$x^n=\sum_{k=0}^{n}S₂(n,k) k!{x\choose k}$</math-renderer>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; stirling2.(4,0:4)  # Knuth calls this the trademark of S₂
5-element Vector{Int64}:
 0
 1
 7
 6
 1

julia&gt; [stirling2(i,j) for i in 0:6, j in 0:6] # similar to Pascal's triangle
7×7 Matrix{Int64}:
 1  0   0   0   0   0  0 
 0  1   0   0   0   0  0
 0  1   1   0   0   0  0
 0  1   3   1   0   0  0
 0  1   7   6   1   0  0
 0  1  15  25  10   1  0
 0  1  31  90  65  15  1

julia&gt; stirling2(50,big(10)) # give `big` second argument to avoid overflow
26154716515862881292012777396577993781727011"><pre lang="julia-repl" class="notranslate"><code>julia&gt; stirling2.(4,0:4)  # Knuth calls this the trademark of S₂
5-element Vector{Int64}:
 0
 1
 7
 6
 1

julia&gt; [stirling2(i,j) for i in 0:6, j in 0:6] # similar to Pascal's triangle
7×7 Matrix{Int64}:
 1  0   0   0   0   0  0 
 0  1   0   0   0   0  0
 0  1   1   0   0   0  0
 0  1   3   1   0   0  0
 0  1   7   6   1   0  0
 0  1  15  25  10   1  0
 0  1  31  90  65  15  1

julia&gt; stirling2(50,big(10)) # give `big` second argument to avoid overflow
26154716515862881292012777396577993781727011
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1035-L1065">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.catalan-Tuple{Integer}" href="#Combinat.catalan-Tuple%7BInteger%7D">#</a>
<strong><code>Combinat.catalan</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>Catalan(n)</code> <code>n</code>-th Catalan Number</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; catalan(8)
1430

julia&gt; catalan(big(50))
1978261657756160653623774456"><pre lang="julia-repl" class="notranslate"><code>julia&gt; catalan(8)
1430

julia&gt; catalan(big(50))
1978261657756160653623774456
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1446-L1456">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.groupby" href="#Combinat.groupby">#</a>
<strong><code>Combinat.groupby</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>groupby(v,l)</code></p>
<p dir="auto">group  elements of collection <code>l</code> according  to the corresponding values in the collection <code>v</code> (which should have same length as <code>l</code>).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; groupby([31,28,31,30,31,30,31,31,30,31,30,31],
  [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])
Dict{Int64,Vector{Symbol}} with 3 entries:
  31 =&gt; Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]
  28 =&gt; Symbol[:Feb]
  30 =&gt; Symbol[:Apr, :Jun, :Sep, :Nov]"><pre lang="julia-rep1" class="notranslate"><code>julia&gt; groupby([31,28,31,30,31,30,31,31,30,31,30,31],
  [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])
Dict{Int64,Vector{Symbol}} with 3 entries:
  31 =&gt; Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]
  28 =&gt; Symbol[:Feb]
  30 =&gt; Symbol[:Apr, :Jun, :Sep, :Nov]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L97-L111">source</a><br></p>
<p dir="auto"><code>groupby(f::Function,l)</code></p>
<p dir="auto">group  elements of collection <code>l</code> according to the values taken by function <code>f</code> on them. The values of <code>f</code> must be hashable.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; groupby(iseven,1:10)
Dict{Bool, Vector{Int64}} with 2 entries:
  0 =&gt; [1, 3, 5, 7, 9]
  1 =&gt; [2, 4, 6, 8, 10]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; groupby(iseven,1:10)
Dict{Bool, Vector{Int64}} with 2 entries:
  0 =&gt; [1, 3, 5, 7, 9]
  1 =&gt; [2, 4, 6, 8, 10]
</code></pre></div>
<p dir="auto">Note:  keys of the result will  have type <code>Any</code> if <code>l</code>  is empty since I do not know how to access the return type of a function</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L118-L132">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.tally" href="#Combinat.tally">#</a>
<strong><code>Combinat.tally</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>tally(v;dict=false)</code></p>
<p dir="auto">counts how many times each element of collection or iterable <code>v</code> occurs and returns a sorted <code>Vector</code> of <code>elt=&gt;count</code> (a variation on StatsBase.countmap).  By default the  elements of <code>v</code>  must be sortable; if they  are not but hashable, giving the keyword <code>dict=true</code> uses a <code>Dict</code> to build (slightly slower) a non sorted result.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; tally(&quot;a tally test&quot;)
7-element Vector{Pair{Char, Int64}}:
 ' ' =&gt; 2
 'a' =&gt; 2
 'e' =&gt; 1
 'l' =&gt; 2
 's' =&gt; 1
 't' =&gt; 3
 'y' =&gt; 1"><pre lang="julia-repl" class="notranslate"><code>julia&gt; tally("a tally test")
7-element Vector{Pair{Char, Int64}}:
 ' ' =&gt; 2
 'a' =&gt; 2
 'e' =&gt; 1
 'l' =&gt; 2
 's' =&gt; 1
 't' =&gt; 3
 'y' =&gt; 1
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L180-L200">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.tally_sorted" href="#Combinat.tally_sorted">#</a>
<strong><code>Combinat.tally_sorted</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>tally_sorted(v)</code></p>
<p dir="auto"><code>tally_sorted</code>  is like <code>tally</code>  but works only  for a sorted iterable. The point is that it is <em>very</em> fast.</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L142-L147">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.collectby" href="#Combinat.collectby">#</a>
<strong><code>Combinat.collectby</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>collectby(f,v)</code></p>
<p dir="auto">group  the elements of <code>v</code> in packets  (<code>Vector</code>s) where <code>f</code> takes the same value.  The resulting <code>Vector{Vector}</code> is sorted  by the values of <code>f</code> (the values  of  <code>f</code>  must  be  sortable;  otherwise  you  can  use  the  slower <code>values(groupby(f,v))</code>).  Here <code>f</code> can  be a function  of one variable or a collection of same length as <code>v</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; l=[:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec];

julia&gt; collectby(x-&gt;first(string(x)),l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]

julia&gt; collectby(&quot;JFMAMJJASOND&quot;,l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; l=[:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec];

julia&gt; collectby(x-&gt;first(string(x)),l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]

julia&gt; collectby("JFMAMJJASOND",l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]
</code></pre></div>
<p dir="auto">julia-repl</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L211-L246">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.unique_sorted!" href="#Combinat.unique_sorted!">#</a>
<strong><code>Combinat.unique_sorted!</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>unique_sorted!(v::Vector)</code> faster than unique! for sorted <code>v</code></p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L272">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.intersect_sorted" href="#Combinat.intersect_sorted">#</a>
<strong><code>Combinat.intersect_sorted</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>intersect_sorted(a,b)</code></p>
<p dir="auto">intersects  <code>a</code> and <code>b</code> assumed to be  both sorted (and their elements have an  <code>isless</code> method). This is many  times faster than <code>intersect</code>.</p>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L284-L289">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.diagblocks" href="#Combinat.diagblocks">#</a>
<strong><code>Combinat.diagblocks</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>diagblocks(M::Matrix)</code></p>
<p dir="auto"><code>M</code>  should  be  a  square  matrix.  Define  a  graph  <code>G</code>  with vertices <code>1:size(M,1)</code> and with an edge between <code>i</code>  and <code>j</code> if either <code>M[i,j]</code> or <code>M[j,i]</code> is not zero or <code>false</code>. <code>diagblocks</code> returns a vector of vectors <code>I</code>  such that  <code>I[1]</code>,<code>I[2]</code>, etc..  are the  vertices in each connected component  of <code>G</code>.  In other  words, <code>M[I[1],I[1]]</code>,<code>M[I[2],I[2]]</code>,etc... are diagonal blocks of <code>M</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[0 0 0 1;0 0 1 0;0 1 0 0;1 0 0 0]
4×4 Matrix{Int64}:
 0  0  0  1
 0  0  1  0
 0  1  0  0
 1  0  0  0

julia&gt; diagblocks(m)
2-element Vector{Vector{Int64}}:
 [1, 4]
 [2, 3]

julia&gt; m[[1,4],[1,4]]
2×2 Matrix{Int64}:
 0  1
 1  0"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[0 0 0 1;0 0 1 0;0 1 0 0;1 0 0 0]
4×4 Matrix{Int64}:
 0  0  0  1
 0  0  1  0
 0  1  0  0
 1  0  0  0

julia&gt; diagblocks(m)
2-element Vector{Vector{Int64}}:
 [1, 4]
 [2, 3]

julia&gt; m[[1,4],[1,4]]
2×2 Matrix{Int64}:
 0  1
 1  0
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1459-L1487">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.blocks-Tuple{AbstractMatrix}" href="#Combinat.blocks-Tuple%7BAbstractMatrix%7D">#</a>
<strong><code>Combinat.blocks</code></strong> — <em>Method</em>.</p>
<p dir="auto"><code>blocks(M:AbstractMatrix)</code></p>
<p dir="auto">Finds  if the  matrix  <code>M</code> admits a block decomposition.</p>
<p dir="auto">Define  a bipartite  graph <code>G</code>  with vertices  <code>axes(M,1)</code>, <code>axes(M,2)</code> and with an edge between <code>i</code> and <code>j</code> if <code>M[i,j]</code> is not zero. BlocksMat returns a  list of pairs of  lists <code>I</code> such that  <code>I[i]</code>, etc.. are the vertices in the <code>i</code>-th connected component of <code>G</code>. In other words, <code>M[I[1][1],I[1][2]], M[I[2][1],I[2][2]]</code>,etc... are blocks of <code>M</code>.</p>
<p dir="auto">This  function may  also be  applied to  boolean matrices.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; m=[1 0 0 0;0 1 0 0;1 0 1 0;0 0 0 1;0 0 1 0]
5×4 Matrix{Int64}:
 1  0  0  0
 0  1  0  0
 1  0  1  0
 0  0  0  1
 0  0  1  0

julia&gt; blocks(m)
3-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 3, 5], [1, 3])
 ([2], [2])
 ([4], [4])

julia&gt; m[[1,3,5,2,4],[1,3,2,4]]
5×4 Matrix{Int64}:
 1  0  0  0
 1  1  0  0
 0  1  0  0
 0  0  1  0
 0  0  0  1"><pre lang="julia-repl" class="notranslate"><code>julia&gt; m=[1 0 0 0;0 1 0 0;1 0 1 0;0 0 0 1;0 0 1 0]
5×4 Matrix{Int64}:
 1  0  0  0
 0  1  0  0
 1  0  1  0
 0  0  0  1
 0  0  1  0

julia&gt; blocks(m)
3-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 3, 5], [1, 3])
 ([2], [2])
 ([4], [4])

julia&gt; m[[1,3,5,2,4],[1,3,2,4]]
5×4 Matrix{Int64}:
 1  0  0  0
 1  1  0  0
 0  1  0  0
 0  0  1  0
 0  0  0  1
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1504-L1540">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.bernoulli" href="#Combinat.bernoulli">#</a>
<strong><code>Combinat.bernoulli</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>bernoulli(n)</code> the <code>n</code>-th <em>Bernoulli number</em>  <code>Bₙ</code> as a <code>Rational{BigInt}</code></p>
<p dir="auto"><code>Bₙ</code> is defined by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="9ed02b48b1186f939544ce51347f983c">$B₀=1, B_n=-\sum_{k=0}^{n-1}((n+1\choose k)B_k)/(n+1)$</math-renderer>. <code>Bₙ/n!</code> is the coefficient of  <code>xⁿ</code> in the power series of  <code>x/(eˣ-1)</code>. Except for <code>B₁=-1/2</code>  the Bernoulli numbers for odd indices are zero.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; bernoulli(4)
-1//30

julia&gt; bernoulli(10)
5//66

julia&gt; bernoulli(12) # there is no simple pattern in Bernoulli numbers
-691//2730

julia&gt; bernoulli(50) # and they grow fairly fast
495057205241079648212477525//66"><pre lang="julia_repl" class="notranslate"><code>julia&gt; bernoulli(4)
-1//30

julia&gt; bernoulli(10)
5//66

julia&gt; bernoulli(12) # there is no simple pattern in Bernoulli numbers
-691//2730

julia&gt; bernoulli(50) # and they grow fairly fast
495057205241079648212477525//66
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1760-L1780">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.prime_residues" href="#Combinat.prime_residues">#</a>
<strong><code>Combinat.prime_residues</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>prime_residues(n)</code> the numbers less than <code>n</code> and prime to <code>n</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; [prime_residues(24)]
1-element Vector{Vector{Int64}}:
 [1, 5, 7, 11, 13, 17, 19, 23]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; [prime_residues(24)]
1-element Vector{Vector{Int64}}:
 [1, 5, 7, 11, 13, 17, 19, 23]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1701-L1708">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.primitiveroot" href="#Combinat.primitiveroot">#</a>
<strong><code>Combinat.primitiveroot</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>primitiveroot(m::Integer)</code>  a primitive root <code>mod.  m</code>, that is generating multiplicatively  <code>prime_residues(m)</code>, or nothing if  there is no primitive root <code>mod. m</code>.</p>
<p dir="auto">A  primitive root exists if <code>m</code> is of the form <code>4</code>, <code>2p^a</code> or <code>p^a</code> for <code>p</code> prime&gt;2.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; primitiveroot(23)
5"><pre lang="julia-repl" class="notranslate"><code>julia&gt; primitiveroot(23)
5
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1731-L1743">source</a><br></p>
<p dir="auto"><a id="user-content-Combinat.divisors" href="#Combinat.divisors">#</a>
<strong><code>Combinat.divisors</code></strong> — <em>Function</em>.</p>
<p dir="auto"><code>divisors(n)</code> the increasing list of divisors of <code>n</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="julia&gt; [divisors(24)]
1-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 6, 8, 12, 24]"><pre lang="julia-repl" class="notranslate"><code>julia&gt; [divisors(24)]
1-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 6, 8, 12, 24]
</code></pre></div>
<p dir="auto"><a href="https://github.com/jmichel7/Combinat.jl/blob/0ccb35b88449e3fa2e6d38e667c3b3b0ff8fef1e/src/Combinat.jl#L1718-L1725">source</a><br></p>
</article></div>