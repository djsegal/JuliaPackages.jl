<div id="readme" class="md" data-path="Readme.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-rutherfordjl-generic-ui-programming" class="anchor" aria-hidden="true" href="#rutherfordjl-generic-ui-programming"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Rutherford.jl: Generic UI Programming</h1>
<p>Julia is the first language to implement a really good generic programming system. Rutherford.jl aims to extend this capability into UI programming where there are a couple complications.</p>
<p>Firstly, UIs mutate the data that they depend on. With a normal function if your data isn't in the right format you will just convert it and move on. But with UIs you also need to convert the mutations. And since those mutations are generated dynamically and asynchronously that's not so easy to do.</p>
<p>Secondly, UI's have opinions. Normally functions are computing something that is well defined and either right or wrong. But UI's aren't that. For any given data there are many sensible UIs that could be generated for it and the difference between them can be as trivial as a colour change.</p>
<p>Ultimately what these two things mean is that as the author of a generic UI you need to assume that you don't know how to access the data you are presenting, you don't know how to mutate it, and you don't even know exactly what the end user wants the UI to look like. At this point you might think writing generic UIs is a fools errand. But it's not. There is still a lot that you can do. Firstly you can define the structure of the UI. You can define the interactions that users can perform and it and you can describe the mutations that will result. And you can even provide sensible defaults for all the end user specific stuff like how to access data, how things should look, and how the mutations should be interpreted. Which will ultimately mean that the end user can plonk your UI component into their's and then gradually specialise certain functions until it works.</p>
<p>The solution to all this is surprisingly simple. UIs can naturally be described using a tree data structure. So making the behaviour of this tree generic is just a matter of using custom types to uniquely tag each part of the tree that we think the end user might want to specialise. With this in mind we can now take a look at the API.</p>
<h2><a id="user-content-api" class="anchor" aria-hidden="true" href="#api"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API</h2>
<ol>
<li><code>@component(name::Symbol)</code> This creates a type that can be used in a UI tree and will enable end users to specialise the rest of Rutherford.jl's API on them</li>
<li><code>draw([::Context,] data)</code> As the user of someone else's component or datatype, you can override the default rendering by defining a draw method for the context you are using it in.</li>
<li><code>doodle([::Component,] data)</code> If you are creating a Component you should define the 2 argument version. If you a creating a DataType you should define the single argument version</li>
<li><code>data(::Context)</code> This is where the <code>data</code> parameter for <code>draw</code> is generated. In here you should get the data that will be presented by a component and convert it into the format the component is expecting</li>
</ol>
<h2><a id="user-content-juno" class="anchor" aria-hidden="true" href="#juno"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Juno</h2>
<p>Juno integration is just a matter of loading one file on the Atom side and one on the Julia side.</p>
<p>Add this to your <code>~/.atom/init.coffee</code></p>
<div class="highlight highlight-source-js"><pre><span class="pl-en">require</span> <span class="pl-s1">process</span><span class="pl-kos">.</span><span class="pl-c1">env</span><span class="pl-kos">.</span><span class="pl-c1">HOME</span> <span class="pl-c1">+</span> <span class="pl-s">"/.kip/repos/jkroso/Rutherford.jl/juno.js"</span></pre></div>
<p>Add This to your <code>~/.julia/config/startup.jl</code></p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">eval</span>(:(<span class="pl-c1">isinteractive</span>() <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">@use</span> <span class="pl-s"><span class="pl-pds">"</span>github.com/jkroso/Rutherford.jl/draw.jl<span class="pl-pds">"</span></span>))</pre></div>
<p>And you will probably want to add some keyboard shortcuts to your <code>~/.atom/keymap.cson</code></p>
<div class="highlight highlight-source-coffee"><pre><span class="pl-s"><span class="pl-pds">'</span>.platform-darwin .item-views &gt; atom-text-editor[data-grammar="source julia"]:not([mini])<span class="pl-pds">'</span></span><span class="pl-k">:</span>
  <span class="pl-s"><span class="pl-pds">'</span>cmd-ctrl-enter<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>julia-client:eval-block<span class="pl-pds">'</span></span>
  <span class="pl-s"><span class="pl-pds">'</span>cmd-alt-ctrl-enter<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>julia-client:eval-each<span class="pl-pds">'</span></span>
  <span class="pl-s"><span class="pl-pds">'</span>cmd-ctrl-backspace<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>julia-client:reset-module<span class="pl-pds">'</span></span></pre></div>
</article></div>