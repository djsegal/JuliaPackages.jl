<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-lazystartupjl" class="anchor" aria-hidden="true" href="#lazystartupjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LazyStartup.jl</h1>
<p dir="auto"><a href="https://github.com/wangl-cc/LazyStartup.jl/actions/workflows/ci.yml"><img src="https://github.com/wangl-cc/LazyStartup.jl/actions/workflows/ci.yml/badge.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/wangl-cc/LazyStartup.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/293a3d1ef18a20d84dde87ad71418c3d85278c94c0936102c30819b4157fc108/68747470733a2f2f636f6465636f762e696f2f67682f77616e676c2d63632f4c617a79537461727475702e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/wangl-cc/LazyStartup.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://github.com/wangl-cc/LazyStartup.jl/blob/master/LICENSE"><img src="https://camo.githubusercontent.com/73eec95e63c2034438976708556487fa8c097202fadb2fb00a7a0f45863ea0c7/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f77616e676c2d63632f4c617a79537461727475702e6a6c" alt="GitHub" data-canonical-src="https://img.shields.io/github/license/wangl-cc/LazyStartup.jl" style="max-width: 100%;"></a></p>
<p dir="auto">A simple package provides a way to delay the execution of startup code until it is needed by REPL.
It might be useful if loading <code>startup.jl</code> will take a long time.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">For a <code>startup.jl</code> file like this:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Revise

function f()
    # do something
end"><pre><span class="pl-k">using</span> Revise

<span class="pl-k">function</span> <span class="pl-en">f</span>()
    <span class="pl-c"><span class="pl-c">#</span> do something</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">This code will be executed before start the REPL,
and can be delayed by <code>@lazy_startup</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LazyStartup # NOTE: this package must be loaded in startup.jl

atreplinit() do repl
  lazy_startup_init!() # NOTE: this function must be called in atreplinit and after `REPL.numbered_prompt!`
end

@lazy_startup using Revise import * using * include(*)

@lazy_startup function f()
    # do something
end"><pre><span class="pl-k">using</span> LazyStartup <span class="pl-c"><span class="pl-c">#</span> NOTE: this package must be loaded in startup.jl</span>

<span class="pl-c1">atreplinit</span>() <span class="pl-k">do</span> repl
  <span class="pl-c1">lazy_startup_init!</span>() <span class="pl-c"><span class="pl-c">#</span> NOTE: this function must be called in atreplinit and after `REPL.numbered_prompt!`</span>
<span class="pl-k">end</span>

<span class="pl-c1">@lazy_startup</span> <span class="pl-k">using</span> Revise <span class="pl-k">import</span> <span class="pl-k">*</span> <span class="pl-k">using</span> <span class="pl-k">*</span> <span class="pl-c1">include</span>(<span class="pl-k">*</span>)

<span class="pl-c1">@lazy_startup</span> <span class="pl-k">function</span> <span class="pl-en">f</span>()
    <span class="pl-c"><span class="pl-c">#</span> do something</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">The first argument of <code>@lazy_startup</code> is the expression to be evaluated,
and rest of the arguments are patterns to match expressions input in the REPL,
where <code>*</code> is a wildcard to match anything;
if pattern is not provided, it will be generated automatically
(rules for generating patterns see below).
Here, the expression <code>using Revise</code> will be evaluated
when <code>import</code>, <code>using</code> any module or <code>include</code> any file;
and the expression <code>function f() ...</code> will be evaluated when it's used.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; isdefined(Main, :Revise)
false

julia&gt; using Test

julia&gt; isdefined(Main, :Revise)
true

julia&gt; isdefined(Main, :f)
false

julia&gt; f()

julia&gt; isdefined(Main, :f)
true"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">isdefined</span>(Main, <span class="pl-c1">:Revise</span>)
<span class="pl-c1">false</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Test

julia<span class="pl-k">&gt;</span> <span class="pl-c1">isdefined</span>(Main, <span class="pl-c1">:Revise</span>)
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">isdefined</span>(Main, <span class="pl-c1">:f</span>)
<span class="pl-c1">false</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>()

julia<span class="pl-k">&gt;</span> <span class="pl-c1">isdefined</span>(Main, <span class="pl-c1">:f</span>)
<span class="pl-c1">true</span></pre></div>
<p dir="auto"><strong>Limitation</strong>: Using this package may increase startup time by about 0.1-0.5 seconds (compile time).
Therefore this package is only recommended for code that significantly affects startup time,
such as loading packages.</p>
<h2 dir="auto"><a id="user-content-define-pattern" class="anchor" aria-hidden="true" href="#define-pattern"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Define Pattern</h2>
<p dir="auto">There are some examples for how to define patterns:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LazyStartup

# match import, using, and function call
@lazy_startup using Revise import * using * include(*)
# match symbol
@lazy_startup begin
  const FOO = 1
  foo(::Any) = FOO + 1
end foo
# match function call, the brackets are required
# without brackets, the pattern will be a symbol
@lazy_startup begin
  bar(::Any) = 1
  bar(::Int) = 2
end bar()
# match macro call, the brackets are optional for single pattern
# but required for multiple patterns
@lazy_startup using Test @test
@lazy_startup using BenchmarkTools @btime() @benchmark()"><pre><span class="pl-k">using</span> LazyStartup

<span class="pl-c"><span class="pl-c">#</span> match import, using, and function call</span>
<span class="pl-c1">@lazy_startup</span> <span class="pl-k">using</span> Revise <span class="pl-k">import</span> <span class="pl-k">*</span> <span class="pl-k">using</span> <span class="pl-k">*</span> <span class="pl-c1">include</span>(<span class="pl-k">*</span>)
<span class="pl-c"><span class="pl-c">#</span> match symbol</span>
<span class="pl-c1">@lazy_startup</span> <span class="pl-k">begin</span>
  <span class="pl-k">const</span> FOO <span class="pl-k">=</span> <span class="pl-c1">1</span>
  <span class="pl-en">foo</span>(<span class="pl-k">::</span><span class="pl-c1">Any</span>) <span class="pl-k">=</span> FOO <span class="pl-k">+</span> <span class="pl-c1">1</span>
<span class="pl-k">end</span> foo
<span class="pl-c"><span class="pl-c">#</span> match function call, the brackets are required</span>
<span class="pl-c"><span class="pl-c">#</span> without brackets, the pattern will be a symbol</span>
<span class="pl-c1">@lazy_startup</span> <span class="pl-k">begin</span>
  <span class="pl-en">bar</span>(<span class="pl-k">::</span><span class="pl-c1">Any</span>) <span class="pl-k">=</span> <span class="pl-c1">1</span>
  <span class="pl-en">bar</span>(<span class="pl-k">::</span><span class="pl-c1">Int</span>) <span class="pl-k">=</span> <span class="pl-c1">2</span>
<span class="pl-k">end</span> <span class="pl-c1">bar</span>()
<span class="pl-c"><span class="pl-c">#</span> match macro call, the brackets are optional for single pattern</span>
<span class="pl-c"><span class="pl-c">#</span> but required for multiple patterns</span>
<span class="pl-c1">@lazy_startup</span> <span class="pl-k">using</span> Test <span class="pl-c1">@test</span>
<span class="pl-c1">@lazy_startup</span> <span class="pl-k">using</span> BenchmarkTools <span class="pl-c1">@btime</span>() <span class="pl-c1">@benchmark</span>()</pre></div>
<p dir="auto"><strong>NOTE</strong>: The pattern matching is not sensitive for order and number of arguments.
Thus, <code>bar()</code> will match <code>bar()</code>, <code>bar(x)</code>, <code>bar(x, y)</code>, and with more arguments.
Similarly, <code>@test</code> will match <code>@test</code>, <code>@test x</code>, <code>@test x y</code>, and with more arguments.</p>
<h2 dir="auto"><a id="user-content-default-pattern" class="anchor" aria-hidden="true" href="#default-pattern"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Default Pattern</h2>
<p dir="auto">If pattern is not provided, patterns will be generated automatically.</p>
<table>
<thead>
<tr>
<th align="left">Expression</th>
<th align="left">Pattern</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Declare variable: <code>v = 1</code> or <code>const v = 1</code></td>
<td align="left">Variable name <code>v</code></td>
</tr>
<tr>
<td align="left">Function definition: <code>f() = 1</code> or <code>function f(); end</code></td>
<td align="left">Function name <code>f</code></td>
</tr>
<tr>
<td align="left">macro definition: <code>macro f(); end</code></td>
<td align="left">Macro name <code>@f</code></td>
</tr>
<tr>
<td align="left">Import modules: <code>import A</code></td>
<td align="left">Module name <code>A</code></td>
</tr>
<tr>
<td align="left">Import submodule: <code>import A.B</code></td>
<td align="left">Submodule name <code>B</code></td>
</tr>
<tr>
<td align="left">Import function: <code>import A.f</code></td>
<td align="left">Function name <code>f</code></td>
</tr>
<tr>
<td align="left">Import and rename module: <code>import A as B</code></td>
<td align="left">Renamed module name <code>B</code></td>
</tr>
<tr>
<td align="left">Import and rename function: <code>import A.f as g</code> or <code>import A: f as g</code></td>
<td align="left">Renamed function name <code>g</code></td>
</tr>
<tr>
<td align="left">Others</td>
<td align="left">A wildcard <code>*</code></td>
</tr>
</tbody>
</table>
<p dir="auto">For other expressions, the pattern wildcard <code>*</code> will match anything,
which means that the expression will evaluate after any input in the REPL.
To avoid confusion, those expressions will show an info message,
which can be silenced by set environment variable <code>JULIA_LAZY_STARTUP_SILENT</code> to <code>true</code>.</p>
<p dir="auto">Besides, most of overhead causes by automatical parttern.
Thus, specify all pattern manually may be helpful for startup time.</p>
</article></div>