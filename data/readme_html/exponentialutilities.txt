<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-exponentialutilities" class="anchor" aria-hidden="true" href="#exponentialutilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ExponentialUtilities</h1>
<p><a href="https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" rel="nofollow"><img src="https://camo.githubusercontent.com/063a520f1733d1b53d1e2fdb37b70a8016dd36f6/68747470733a2f2f6261646765732e6769747465722e696d2f4a756c69614469666645712f4c6f6262792e737667" alt="Join the chat at https://gitter.im/JuliaDiffEq/Lobby" data-canonical-src="https://badges.gitter.im/JuliaDiffEq/Lobby.svg" style="max-width:100%;"></a>
<a href="https://travis-ci.org/JuliaDiffEq/ExponentialUtilities.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/b88a70e6266afee9896e1c247b4591be16569e00/68747470733a2f2f7472617669732d63692e6f72672f4a756c69614469666645712f4578706f6e656e7469616c5574696c69746965732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/JuliaDiffEq/ExponentialUtilities.jl.svg?branch=master" style="max-width:100%;"></a>
<a href="https://ci.appveyor.com/project/MSeeker1340/exponentialutilities-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/0891f3a34987b9934801bcd4efb3b748fa8c5878/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6565777731716d3572726639383462633f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/eeww1qm5rrf984bc?svg=true" style="max-width:100%;"></a>
<a href="https://coveralls.io/github/JuliaDiffEq/ExponentialUtilities.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/6a567bef1c062e35e9f7f7bba7019f3a53b42a23/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f4a756c69614469666645712f4578706f6e656e7469616c5574696c69746965732e6a6c2f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/JuliaDiffEq/ExponentialUtilities.jl/badge.svg?branch=master" style="max-width:100%;"></a>
<a href="https://codecov.io/gh/JuliaDiffEq/ExponentialUtilities.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e88d874c1e413e73ce667c3a261be86a988252c1/68747470733a2f2f636f6465636f762e696f2f67682f4a756c69614469666645712f4578706f6e656e7469616c5574696c69746965732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/JuliaDiffEq/ExponentialUtilities.jl/branch/master/graph/badge.svg" style="max-width:100%;"></a></p>
<p>ExponentialUtilities is a package of utility functions used by the exponential integrators in OrdinaryDiffEq. It is a lightweight pure Julia package with no external dependencies, so it can also be used independently.</p>
<h2><a id="user-content-matrix-phi-vector-product" class="anchor" aria-hidden="true" href="#matrix-phi-vector-product"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matrix-phi-vector product</h2>
<p>The main functionality of ExponentialUtilities is the computation of matrix-phi-vector products. The phi functions are defined as</p>
<pre><code>ϕ_0(z) = exp(z)
ϕ_(k+1)(z) = (ϕ_k(z) - 1) / z
</code></pre>
<p>In exponential algorithms, products in the form of <code>ϕ_m(tA)b</code> is frequently encountered. Instead of computing the matrix function first and then computing the matrix-vector product, the common alternative is to construct a <a href="https://en.wikipedia.org/wiki/Krylov_subspace" rel="nofollow">Krylov subspace</a> <code>K_m(A,b)</code> and then approximate the matrix-phi-vector product.</p>
<h3><a id="user-content-expv-and-phiv" class="anchor" aria-hidden="true" href="#expv-and-phiv"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expv</code> and <code>phiv</code></h3>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">expv</span>(t,A,b;kwargs) <span class="pl-k">-&gt;</span> <span class="pl-c1">exp</span>(tA)b
<span class="pl-c1">phiv</span>(t,A,b,k;kwargs) <span class="pl-k">-&gt;</span> [ϕ<span class="pl-c1">_0</span>(tA)b ϕ<span class="pl-c1">_1</span>(tA)b <span class="pl-k">...</span> ϕ<span class="pl-c1">_k</span>(tA)b][, errest]</pre></div>
<p>For <code>phiv</code>, <em>all</em> <code>ϕ_m(tA)b</code> products up to order <code>k</code> is returned as a matrix. This is because it's more economical to produce all the results at once than individually. A second output is returned if <code>errest=true</code> in <code>kwargs</code>. The error estimate is given for the second-to-last product, using the last product as an estimator. If <code>correct=true</code>, then <code>ϕ_0</code> through <code>ϕ_(k-1)</code> are updated using the last Arnoldi vector. The correction algorithm is described in [1].</p>
<p>You can adjust how the Krylov subspace is constructed by setting various keyword arguments. See the Arnoldi iteration section for more details.</p>
<h3><a id="user-content-expv_timestep-and-phiv_timestep" class="anchor" aria-hidden="true" href="#expv_timestep-and-phiv_timestep"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expv_timestep</code> and <code>phiv_timestep</code></h3>
<p>Unlike <code>expv</code> and <code>phiv</code>, the timestepping methods divide <code>t</code> into smaller time steps and compute the product step-by-step. By doing this in smaller chunks, the methods allow for finer error control as well as adaptation. The timestepping algorithm is described in [1], which is based upon the numerical package Expokit [2].</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">exp_timestep</span>(ts,A,b;kwargs) <span class="pl-k">-&gt;</span> U</pre></div>
<p>Evaluates the matrix exponentiation-vector product <code>u = exp(tA)b</code> using time stepping.</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">phiv_timestep</span>(ts,A,[b_0 b_1 <span class="pl-k">...</span> b_p];kwargs) <span class="pl-k">-&gt;</span> U</pre></div>
<p>Evaluates the linear combination of phi-vector products <code>u = ϕ_0(tA)b_0 + tϕ_1(tA)b_1 + ... + t^pϕ_p(tA)b_p</code> using time stepping.</p>
<p>In both cases, <code>ts</code> is an array of time snapshots for u, with <code>U[:,j] ≈ u(ts[j])</code>. <code>ts</code> can also be just one value, in which case only the end result is returned and <code>U</code> is a vector.</p>
<p>Apart from keyword arguments that affect the computation of Krylov subspaces (see the Arnoldi iteration section), you can also adjust the timestepping behavior using the arguments. By setting <code>adaptive=true</code>, the time step and Krylov subsapce size adaptation scheme of Niesen &amp; Wright is used and the relative tolerance of which can be set using the keyword parameter <code>tol</code>. The <code>delta</code> and <code>gamma</code> parameter of the adaptation scheme can also be adjusted. The <code>tau</code> parameter adjusts the size of the timestep (and for <code>adaptive=true</code>, the initial timestep). By default, it is calculated using a heuristic formula by Niesen &amp; Wright.</p>
<h3><a id="user-content-support-for-matrix-free-operators" class="anchor" aria-hidden="true" href="#support-for-matrix-free-operators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Support for matrix-free operators</h3>
<p>You can use any object as the "matrix" <code>A</code> as long as it implements the following linear operator interface:</p>
<ul>
<li><code>Base.eltype(A)</code></li>
<li><code>Base.size(A, dim)</code></li>
<li><code>LinearAlgebra.mul!(y, A, x)</code> (for computing <code>y = A * x</code> in place).</li>
<li><code>LinearAlgebra.opnorm(A, p=Inf)</code>. If this is not implemented or the default implementation can be slow, you can manually pass in the operator norm (a rough estimate is fine) using the keyword argument <code>opnorm</code>.</li>
<li><code>LinearAlgebra.ishermitian(A)</code>. If this is not implemented or the default implementation can be slow, you can manually pass in the value using the keyword argument <code>ishermitian</code>.</li>
</ul>
<h2><a id="user-content-matrix-phi-function-phi" class="anchor" aria-hidden="true" href="#matrix-phi-function-phi"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matrix-phi function <code>phi</code></h2>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">phi</span>(z,k[;cache]) <span class="pl-k">-&gt;</span> [ϕ<span class="pl-c1">_0</span>(z),ϕ<span class="pl-c1">_1</span>(z),<span class="pl-k">...</span>,ϕ<span class="pl-c1">_k</span>(z)]</pre></div>
<p>Compute ϕ function directly. <code>z</code> can both be a scalar or a <code>AbstractMatrix</code> (note that unlike the previous functions, you <em>need</em> to use a concrete matrix). This is used by the caching versions of the ExpRK integrators to precompute the operators.</p>
<p>Instead of using the recurrence relation, which is numerically unstable, a formula given by Sidje is used [2].</p>
<h2><a id="user-content-arnoldi-iteration-arnoldi" class="anchor" aria-hidden="true" href="#arnoldi-iteration-arnoldi"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arnoldi iteration <code>arnoldi</code></h2>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">arnoldi</span>(A,b[;m,tol,opnorm,iop,cache]) <span class="pl-k">-&gt;</span> Ks</pre></div>
<p>Performs <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration" rel="nofollow">Arnoldi iterations</a> to obtain the Krylov subspace <code>K_m(A,b)</code>. The result is a <code>KrylovSubspace</code> that can be used by <code>phiv</code> via the alternative interface</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">phiv</span>(t,Ks,k;kwargs) <span class="pl-k">-&gt;</span> [ϕ<span class="pl-c1">_0</span>(tA)b ϕ<span class="pl-c1">_1</span>(tA)b <span class="pl-k">...</span> ϕ<span class="pl-c1">_k</span>(tA)b][, errest]</pre></div>
<p>The reason for having this alternative interface is that we may want to compute <code>ϕ_m(tA)b</code> for different values of <code>t</code>. In this case, we can compute <code>Ks</code> just once (which is expensive) and follow up with several <code>phiv</code> calls using <code>Ks</code> (which is not as expensive).</p>
<p>For <code>arnoldi</code>, if <code>A</code> is hermitian, then the more efficient <a href="https://en.wikipedia.org/wiki/Lanczos_algorithm" rel="nofollow">Lanczos algorithm</a> is used instead. For cases when <code>A</code> is almost hermitian or when accuracy is not important, the incomplete orthogonalization procedure (IOP) can be used by setting the IOP length <code>iop</code> in <code>kwargs</code>.</p>
<p>For the other keyword arguments, <code>m</code> determines the dimension of the Krylov subspace and <code>tol</code> is the relative tolerance used to determine the "happy-breakdown" condition. You can also set custom operator norm in <code>opnorm</code>, e.g. efficient norm estimation functions instead of the default <code>LinearAlgebra.opnorm</code>. Only <code>opnorm(A, Inf)</code> needs to be defined.</p>
<h2><a id="user-content-_exp" class="anchor" aria-hidden="true" href="#_exp"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>_exp!</code></h2>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">_exp</span>(A)</pre></div>
<p>A pure Julia implementation of a non-allocating matrix exponential using the Destructive matrix exponential using algorithm
from Higham, 2008. Mostly generic, though the coefficients are geared towards 64-bit floating point calculations, and the
use of BLAS requires a <code>StridedMatrix</code>.</p>
<h2><a id="user-content-exp_generic" class="anchor" aria-hidden="true" href="#exp_generic"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>exp_generic</code></h2>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">exp</span>(x, vk<span class="pl-k">=</span><span class="pl-c1">Val</span><span class="pl-c1">{10}</span>())</pre></div>
<p>A pure Julia generic implementation of the exponential function using the
<a href="https://doi.org/10.1137/04061101X" rel="nofollow">scaling and squaring method</a>, working on any <code>x</code> for which the functions
<code>LinearAlgebra.opnorm</code>, <code>+</code>, <code>*</code>, <code>^</code>, and <code>/</code> (including addition with UniformScaling objects) are defined.
Use the argument <code>vk</code> to adjust the number of terms used in the Pade approximants at compile time.</p>
<h2><a id="user-content-advanced-features" class="anchor" aria-hidden="true" href="#advanced-features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced features</h2>
<p>"In-place" versions for <code>phi</code>, <code>arnoldi</code>, <code>expv</code>, <code>phiv</code>, <code>expv_timestep</code> and <code>phiv_timestep</code> are available as <code>phi!</code>, <code>arnoldi!</code>, <code>expv!</code>, <code>phiv!</code>, <code>expv_timestep!</code> and <code>phiv_timestep!</code>. You can refer to the docstrings for more information.</p>
<p>In addition, you may provide pre-allocated caches to the functions to further improve efficiency. In particular, dedicated cache types for <code>expv!</code> and <code>phiv!</code> are available as <code>ExpvCache</code> and <code>PhivCache</code>. Both of them can be dynamically resized, which is crucial for the adaptive <code>phiv_timestep!</code> method.</p>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>References</h2>
<p>[1] Niesen, J., &amp; Wright, W. (2009). A Krylov subspace algorithm for evaluating the φ-functions in exponential integrators. arXiv preprint arXiv:0907.4631.</p>
<p>[2] Sidje, R. B. (1998). Expokit: a software package for computing matrix exponentials. ACM Transactions on Mathematical Software (TOMS), 24(1), 130-15.</p>
<p>[3] Koskela, A. (2015). Approximating the matrix exponential of an advection-diffusion operator using the incomplete orthogonalization method. In Numerical Mathematics and Advanced Applications-ENUMATH 2013 (pp. 345-353). Springer, Cham.</p>
<p>[4] HIGHAM, N. J. (2005). "THE SCALING AND SQUARING METHOD FOR THE MATRIX EXPONENTIAL REVISITED." SIAM J. MATRIX ANAL. APPL.Vol. 26, No. 4, pp. 1179–1193</p>
</article></div>