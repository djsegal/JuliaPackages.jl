<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-finitediff" class="anchor" aria-hidden="true" href="#finitediff"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FiniteDiff</h1>
<p dir="auto"><a href="https://julialang.zulipchat.com/#narrow/stream/279055-sciml-bridged" rel="nofollow"><img src="https://camo.githubusercontent.com/667867fc71b8b3c9ed350ce154a04d38adca002ecfa38edf519284e0365ee553/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d5a756c6970266d6573736167653d6368617426636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="Join the chat at https://julialang.zulipchat.com #sciml-bridged" data-canonical-src="https://img.shields.io/static/v1?label=Zulip&amp;message=chat&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a>
<a href="https://docs.sciml.ai/FiniteDiff/stable/" rel="nofollow"><img src="https://camo.githubusercontent.com/88037a523f970520933771e764f5abff55de9382efc91cd89dd43ef0bb49a85f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d5363694d4c2d626c75652e737667" alt="Global Docs" data-canonical-src="https://img.shields.io/badge/docs-SciML-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://app.codecov.io/gh/JuliaDiff/FiniteDiff.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/c7d85567dbee4b1bdcea633c560598960d0c6fcb55a683f67485b8544eaf608d/68747470733a2f2f636f6465636f762e696f2f67682f4a756c6961446966662f46696e697465446966662e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/JuliaDiff/FiniteDiff.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaDiff/FiniteDiff.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDiff/FiniteDiff.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a></p>
<p dir="auto"><a href="https://github.com/SciML/ColPrac"><img src="https://camo.githubusercontent.com/a6c1efcb19a957860ecb25966a730260b03d6e05380d0c27992ee7f9e3b1feb3/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436f6c507261632d436f6e7472696275746f72277325323047756964652d626c756576696f6c6574" alt="ColPrac: Contributor's Guide on Collaborative Practices for Community Packages" data-canonical-src="https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet" style="max-width: 100%;"></a>
<a href="https://github.com/SciML/SciMLStyle"><img src="https://camo.githubusercontent.com/3e16f03bad047817fbc07f49307817ed7919ef79c339dc75ad4ce813012c3e0b/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d636f64652532307374796c65266d6573736167653d5363694d4c26636f6c6f723d393535386232266c6162656c436f6c6f723d333839383236" alt="SciML Code Style" data-canonical-src="https://img.shields.io/static/v1?label=code%20style&amp;message=SciML&amp;color=9558b2&amp;labelColor=389826" style="max-width: 100%;"></a></p>
<p dir="auto">This package is for calculating derivatives, gradients, Jacobians, Hessians,
etc. numerically. This library is for maximizing speed while giving a usable
interface to end users in a way that specializes on array types and sparsity.
Included is:</p>
<ul dir="auto">
<li>Fully non-allocating mutable forms for fast array support</li>
<li>Fully non-mutating forms for static array support</li>
<li>Coloring vectors for efficient calculation of sparse Jacobians</li>
<li>GPU-compatible, to the extent that you can be with finite differencing.</li>
</ul>
<p dir="auto">If you want the fastest versions, create a cache and repeatedly call the
differencing functions at different <code>x</code> values (or with different <code>f</code> functions),
while if you want a quick and dirty numerical answer, directly call a differencing
function.</p>
<p dir="auto"><strong>For analogous sparse differentiation with automatic differentiation, see <a href="https://github.com/JuliaDiff/SparseDiffTools.jl">SparseDiffTools.jl</a>.</strong></p>
<h4 dir="auto"><a id="user-content-finitediffjl-vs-finitedifferencesjl" class="anchor" aria-hidden="true" href="#finitediffjl-vs-finitedifferencesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FiniteDiff.jl vs FiniteDifferences.jl</h4>
<p dir="auto"><a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> and <a href="https://github.com/JuliaDiff/FiniteDifferences.jl">FiniteDifferences.jl</a>
are similar libraries: both calculate approximate derivatives numerically.
You should definitely use one or the other, rather than the legacy <a href="https://github.com/JuliaMath/Calculus.jl">Calculus.jl</a> finite differencing, or reimplementing it yourself.
At some point in the future they might merge, or one might depend on the other.
Right now here are the differences:</p>
<ul dir="auto">
<li>FiniteDifferences.jl supports basically any type, where as FiniteDiff.jl supports only array-ish types</li>
<li>FiniteDifferences.jl supports higher order approximation</li>
<li>FiniteDiff.jl is carefully optimized to minimize allocations</li>
<li>FiniteDiff.jl supports coloring vectors for efficient calculation of sparse Jacobians</li>
</ul>
<h2 dir="auto"><a id="user-content-tutorials" class="anchor" aria-hidden="true" href="#tutorials"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorials</h2>
<h3 dir="auto"><a id="user-content-tutorial-1-fast-dense-jacobians" class="anchor" aria-hidden="true" href="#tutorial-1-fast-dense-jacobians"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorial 1: Fast Dense Jacobians</h3>
<p dir="auto">It's always fun to start out with a tutorial before jumping into the details!
Suppose we had the functions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FiniteDiff, StaticArrays

fcalls = 0
function f(dx,x) # in-place
  global fcalls += 1
  for i in 2:length(x)-1
    dx[i] = x[i-1] - 2x[i] + x[i+1]
  end
  dx[1] = -2x[1] + x[2]
  dx[end] = x[end-1] - 2x[end]
  nothing
end

const N = 10
handleleft(x,i) = i==1 ? zero(eltype(x)) : x[i-1]
handleright(x,i) = i==length(x) ? zero(eltype(x)) : x[i+1]
function g(x) # out-of-place
  global fcalls += 1
  @SVector [handleleft(x,i) - 2x[i] + handleright(x,i) for i in 1:N]
end"><pre><span class="pl-k">using</span> FiniteDiff, StaticArrays

fcalls <span class="pl-k">=</span> <span class="pl-c1">0</span>
<span class="pl-k">function</span> <span class="pl-en">f</span>(dx,x) <span class="pl-c"><span class="pl-c">#</span> in-place</span>
  <span class="pl-k">global</span> fcalls <span class="pl-k">+=</span> <span class="pl-c1">1</span>
  <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">length</span>(x)<span class="pl-k">-</span><span class="pl-c1">1</span>
    dx[i] <span class="pl-k">=</span> x[i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">-</span> <span class="pl-c1">2</span>x[i] <span class="pl-k">+</span> x[i<span class="pl-k">+</span><span class="pl-c1">1</span>]
  <span class="pl-k">end</span>
  dx[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">2</span>x[<span class="pl-c1">1</span>] <span class="pl-k">+</span> x[<span class="pl-c1">2</span>]
  dx[<span class="pl-c1">end</span>] <span class="pl-k">=</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">-</span> <span class="pl-c1">2</span>x[<span class="pl-c1">end</span>]
  <span class="pl-c1">nothing</span>
<span class="pl-k">end</span>

<span class="pl-k">const</span> N <span class="pl-k">=</span> <span class="pl-c1">10</span>
<span class="pl-en">handleleft</span>(x,i) <span class="pl-k">=</span> i<span class="pl-k">==</span><span class="pl-c1">1</span> <span class="pl-k">?</span> <span class="pl-c1">zero</span>(<span class="pl-c1">eltype</span>(x)) <span class="pl-k">:</span> x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]
<span class="pl-en">handleright</span>(x,i) <span class="pl-k">=</span> i<span class="pl-k">==</span><span class="pl-c1">length</span>(x) <span class="pl-k">?</span> <span class="pl-c1">zero</span>(<span class="pl-c1">eltype</span>(x)) <span class="pl-k">:</span> x[i<span class="pl-k">+</span><span class="pl-c1">1</span>]
<span class="pl-k">function</span> <span class="pl-en">g</span>(x) <span class="pl-c"><span class="pl-c">#</span> out-of-place</span>
  <span class="pl-k">global</span> fcalls <span class="pl-k">+=</span> <span class="pl-c1">1</span>
  <span class="pl-c1">@SVector</span> [<span class="pl-c1">handleleft</span>(x,i) <span class="pl-k">-</span> <span class="pl-c1">2</span>x[i] <span class="pl-k">+</span> <span class="pl-c1">handleright</span>(x,i) <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>N]
<span class="pl-k">end</span></pre></div>
<p dir="auto">and we wanted to calculate the derivatives of them. The simplest thing we can
do is ask for the Jacobian. If we want to allocate the result, we'd use the
allocating function <code>finite_difference_jacobian</code> on a 1-argument function <code>g</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = @SVector rand(N)
FiniteDiff.finite_difference_jacobian(g,x)

#=
10×10 SArray{Tuple{10,10},Float64,2,100} with indices SOneTo(10)×SOneTo(10):
 -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0
  1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0
  0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0
  0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0
  0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0
  0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0
  0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0
  0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0
  0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0
  0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0
=#"><pre>x <span class="pl-k">=</span> <span class="pl-c1">@SVector</span> <span class="pl-c1">rand</span>(N)
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian</span>(g,x)

<span class="pl-c"><span class="pl-c">#=</span></span>
<span class="pl-c">10×10 SArray{Tuple{10,10},Float64,2,100} with indices SOneTo(10)×SOneTo(10):</span>
<span class="pl-c"> -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0</span>
<span class="pl-c"><span class="pl-c">=#</span></span></pre></div>
<p dir="auto">FiniteDiff.jl assumes you're a smart cookie, and so if you used an
out-of-place function then it'll not mutate vectors at all, and is thus compatible
with objects like StaticArrays and will give you a fast Jacobian.</p>
<p dir="auto">But if you wanted to use mutation, then we'd have to use the in-place function
<code>f</code> and call the mutating form:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = rand(10)
output = zeros(10,10)
FiniteDiff.finite_difference_jacobian!(output,f,x)
output

#=
10×10 Array{Float64,2}:
 -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0
  1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0
  0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0
  0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0
  0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0
  0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0
  0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0
  0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0
  0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0
  0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0
=#"><pre>x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10</span>)
output <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">10</span>,<span class="pl-c1">10</span>)
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(output,f,x)
output

<span class="pl-c"><span class="pl-c">#=</span></span>
<span class="pl-c">10×10 Array{Float64,2}:</span>
<span class="pl-c"> -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0   0.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0   1.0</span>
<span class="pl-c">  0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0  -2.0</span>
<span class="pl-c"><span class="pl-c">=#</span></span></pre></div>
<p dir="auto">But what if you want this to be completely non-allocating on your mutating form?
Then you need to preallocate a cache:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="cache = FiniteDiff.JacobianCache(x)"><pre>cache <span class="pl-k">=</span> FiniteDiff<span class="pl-k">.</span><span class="pl-c1">JacobianCache</span>(x)</pre></div>
<p dir="auto">and now using this cache avoids allocating:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@time FiniteDiff.finite_difference_jacobian!(output,f,x,cache) # 0.000008 seconds (7 allocations: 224 bytes)"><pre><span class="pl-c1">@time</span> FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(output,f,x,cache) <span class="pl-c"><span class="pl-c">#</span> 0.000008 seconds (7 allocations: 224 bytes)</span></pre></div>
<p dir="auto">And that's pretty much it! Gradients and Hessians work similarly: out of place
doesn't index, and in-place avoids allocations. Either way, you're fast. GPUs
etc. all work.</p>
<h3 dir="auto"><a id="user-content-tutorial-2-fast-sparse-jacobians" class="anchor" aria-hidden="true" href="#tutorial-2-fast-sparse-jacobians"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorial 2: Fast Sparse Jacobians</h3>
<p dir="auto">Now let's exploit sparsity. If we knew the sparsity pattern we could write it
down analytically as a sparse matrix, but let's assume we don't. Thus we can
use <a href="https://github.com/JuliaDiffEq/SparsityDetection.jl">SparsityDetection.jl</a>
to automatically get the sparsity pattern of the Jacobian as a sparse matrix:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SparsityDetection, SparseArrays
in = rand(10)
out = similar(in)
sparsity_pattern = sparsity!(f,out,in)
sparsejac = Float64.(sparse(sparsity_pattern))"><pre><span class="pl-k">using</span> SparsityDetection, SparseArrays
in <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10</span>)
out <span class="pl-k">=</span> <span class="pl-c1">similar</span>(in)
sparsity_pattern <span class="pl-k">=</span> <span class="pl-c1">sparsity!</span>(f,out,in)
sparsejac <span class="pl-k">=</span> <span class="pl-c1">Float64</span>.(<span class="pl-c1">sparse</span>(sparsity_pattern))</pre></div>
<p dir="auto">Then we can use <a href="https://github.com/JuliaDiffEq/SparseDiffTools.jl">SparseDiffTools.jl</a>
to get the color vector:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using SparseDiffTools
colors = matrix_colors(sparsejac)"><pre><span class="pl-k">using</span> SparseDiffTools
colors <span class="pl-k">=</span> <span class="pl-c1">matrix_colors</span>(sparsejac)</pre></div>
<p dir="auto">Now we can do sparse differentiation by passing the color vector and the sparsity
pattern:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sparsecache = FiniteDiff.JacobianCache(x,colorvec=colors,sparsity=sparsejac)
FiniteDiff.finite_difference_jacobian!(sparsejac,f,x,sparsecache)"><pre>sparsecache <span class="pl-k">=</span> FiniteDiff<span class="pl-k">.</span><span class="pl-c1">JacobianCache</span>(x,colorvec<span class="pl-k">=</span>colors,sparsity<span class="pl-k">=</span>sparsejac)
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(sparsejac,f,x,sparsecache)</pre></div>
<p dir="auto">Note that the number of <code>f</code> evaluations to fill a Jacobian is <code>1+maximum(colors)</code>.
By default, <code>colors=1:length(x)</code>, so in this case we went from 10 function calls
to 4. The sparser the matrix, the more the gain! We can measure this as well:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="fcalls = 0
FiniteDiff.finite_difference_jacobian!(output,f,x,cache)
fcalls #11

fcalls = 0
FiniteDiff.finite_difference_jacobian!(sparsejac,f,x,sparsecache)
fcalls #4"><pre>fcalls <span class="pl-k">=</span> <span class="pl-c1">0</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(output,f,x,cache)
fcalls <span class="pl-c"><span class="pl-c">#</span>11</span>

fcalls <span class="pl-k">=</span> <span class="pl-c1">0</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(sparsejac,f,x,sparsecache)
fcalls <span class="pl-c"><span class="pl-c">#</span>4</span></pre></div>
<h3 dir="auto"><a id="user-content-tutorial-3-fast-tridiagonal-jacobians" class="anchor" aria-hidden="true" href="#tutorial-3-fast-tridiagonal-jacobians"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorial 3: Fast Tridiagonal Jacobians</h3>
<p dir="auto">Handling dense matrices? Easy. Handling sparse matrices? Cool stuff. Automatically
specializing on the exact structure of a matrix? Even better. FiniteDiff can
specialize on types which implement the
<a href="https://github.com/JuliaDiffEq/ArrayInterfaceCore.jl">ArrayInterfaceCore.jl</a> interface.
This includes:</p>
<ul dir="auto">
<li>Diagonal</li>
<li>Bidiagonal</li>
<li>UpperTriangular and LowerTriangular</li>
<li>Tridiagonal and SymTridiagonal</li>
<li><a href="https://github.com/JuliaMatrices/BandedMatrices.jl">BandedMatrices.jl</a></li>
<li><a href="https://github.com/JuliaMatrices/BlockBandedMatrices.jl">BlockBandedMatrices.jl</a></li>
</ul>
<p dir="auto">Our previous example had a Tridiagonal Jacobian, so let's use this. If we just
do</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ArrayInterfaceCore, LinearAlgebra
tridiagjac = Tridiagonal(output)
colors = matrix_colors(jac)"><pre><span class="pl-k">using</span> ArrayInterfaceCore, LinearAlgebra
tridiagjac <span class="pl-k">=</span> <span class="pl-c1">Tridiagonal</span>(output)
colors <span class="pl-k">=</span> <span class="pl-c1">matrix_colors</span>(jac)</pre></div>
<p dir="auto">we get the analytical solution to the optimal matrix colors for our structured
Jacobian. Now we can use this in our differencing routines:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="tridiagcache = FiniteDiff.JacobianCache(x,colorvec=colors,sparsity=tridiagjac)
FiniteDiff.finite_difference_jacobian!(tridiagjac,f,x,tridiagcache)"><pre>tridiagcache <span class="pl-k">=</span> FiniteDiff<span class="pl-k">.</span><span class="pl-c1">JacobianCache</span>(x,colorvec<span class="pl-k">=</span>colors,sparsity<span class="pl-k">=</span>tridiagjac)
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(tridiagjac,f,x,tridiagcache)</pre></div>
<p dir="auto">It'll use a special iteration scheme dependent on the matrix type to accelerate
it beyond general sparse usage.</p>
<h3 dir="auto"><a id="user-content-tutorial-4-fast-block-banded-matrices" class="anchor" aria-hidden="true" href="#tutorial-4-fast-block-banded-matrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Tutorial 4: Fast Block Banded Matrices</h3>
<p dir="auto">Now let's showcase a difficult example. Say we had a large system of partial
differential equations, with a function like:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function pde(out, x)
	x = reshape(x, 100, 100)
	out = reshape(out, 100, 100)
	for i in 1:100
		for j in 1:100
			out[i, j] = x[i, j] + x[max(i -1, 1), j] + x[min(i+1, size(x, 1)), j] +  x[i, max(j-1, 1)]  + x[i, min(j+1, size(x, 2))]
		end
	end
	return vec(out)
end
x = rand(10000)"><pre><span class="pl-k">function</span> <span class="pl-en">pde</span>(out, x)
	x <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(x, <span class="pl-c1">100</span>, <span class="pl-c1">100</span>)
	out <span class="pl-k">=</span> <span class="pl-c1">reshape</span>(out, <span class="pl-c1">100</span>, <span class="pl-c1">100</span>)
	<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>
		<span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>
			out[i, j] <span class="pl-k">=</span> x[i, j] <span class="pl-k">+</span> x[<span class="pl-c1">max</span>(i <span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span>), j] <span class="pl-k">+</span> x[<span class="pl-c1">min</span>(i<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-c1">size</span>(x, <span class="pl-c1">1</span>)), j] <span class="pl-k">+</span>  x[i, <span class="pl-c1">max</span>(j<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span>)]  <span class="pl-k">+</span> x[i, <span class="pl-c1">min</span>(j<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-c1">size</span>(x, <span class="pl-c1">2</span>))]
		<span class="pl-k">end</span>
	<span class="pl-k">end</span>
	<span class="pl-k">return</span> <span class="pl-c1">vec</span>(out)
<span class="pl-k">end</span>
x <span class="pl-k">=</span> <span class="pl-c1">rand</span>(<span class="pl-c1">10000</span>)</pre></div>
<p dir="auto">In this case, we can see that our sparsity pattern is a BlockBandedMatrix, so
let's specialize the Jacobian calculation on this fact:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using FillArrays, BlockBandedMatrices
Jbbb = BandedBlockBandedMatrix(Ones(10000, 10000), fill(100, 100), fill(100, 100), (1, 1), (1, 1))
colorsbbb = ArrayInterfaceCore.matrix_colors(Jbbb)
bbbcache = FiniteDiff.JacobianCache(x,colorvec=colorsbbb,sparsity=Jbbb)
FiniteDiff.finite_difference_jacobian!(Jbbb, pde, x, bbbcache)"><pre><span class="pl-k">using</span> FillArrays, BlockBandedMatrices
Jbbb <span class="pl-k">=</span> <span class="pl-c1">BandedBlockBandedMatrix</span>(<span class="pl-c1">Ones</span>(<span class="pl-c1">10000</span>, <span class="pl-c1">10000</span>), <span class="pl-c1">fill</span>(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>), <span class="pl-c1">fill</span>(<span class="pl-c1">100</span>, <span class="pl-c1">100</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">1</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">1</span>))
colorsbbb <span class="pl-k">=</span> ArrayInterfaceCore<span class="pl-k">.</span><span class="pl-c1">matrix_colors</span>(Jbbb)
bbbcache <span class="pl-k">=</span> FiniteDiff<span class="pl-k">.</span><span class="pl-c1">JacobianCache</span>(x,colorvec<span class="pl-k">=</span>colorsbbb,sparsity<span class="pl-k">=</span>Jbbb)
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(Jbbb, pde, x, bbbcache)</pre></div>
<p dir="auto">And boom, a fast Jacobian filling algorithm on your special matrix.</p>
<h2 dir="auto"><a id="user-content-general-structure" class="anchor" aria-hidden="true" href="#general-structure"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>General Structure</h2>
<p dir="auto">The general structure of the library is as follows. You can call the differencing
functions directly and this will allocate a temporary cache to solve the problem
with. To make this non-allocating for repeat calls, you can call the cache
construction functions. Each cache construction function has two possibilities:
one version where you give it prototype arrays and it generates the cache
variables, and one fully non-allocating version where you give it the cache
variables. This is summarized as:</p>
<ul dir="auto">
<li>Just want a quick derivative? Calculating once? Call the differencing function.</li>
<li>Going to calculate the derivative multiple times but don't have cache arrays
around? Use the allocating cache and then pass this into the differencing
function (this will allocate only in the one cache construction).</li>
<li>Have cache variables around from your own algorithm and want to re-use them
in the differencing functions? Use the non-allocating cache construction
and pass the cache to the differencing function.</li>
</ul>
<h2 dir="auto"><a id="user-content-f-definitions" class="anchor" aria-hidden="true" href="#f-definitions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>f Definitions</h2>
<p dir="auto">In all functions, the inplace form is <code>f!(dx,x)</code> while the out of place form is <code>dx = f(x)</code>.</p>
<h2 dir="auto"><a id="user-content-colorvec-vectors" class="anchor" aria-hidden="true" href="#colorvec-vectors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>colorvec Vectors</h2>
<p dir="auto">colorvec vectors are allowed to be supplied to the Jacobian routines, and these are
the directional derivatives for constructing the Jacobian. For example, an accurate
NxN tridiagonal Jacobian can be computed in just 4 <code>f</code> calls by using
<code>colorvec=repeat(1:3,N÷3)</code>. For information on automatically generating colorvec
vectors of sparse matrices, see <a href="https://github.com/JuliaDiff/SparseDiffTools.jl">SparseDiffTools.jl</a>.</p>
<p dir="auto">Hessian coloring support is coming soon!</p>
<h2 dir="auto"><a id="user-content-scalar-derivatives" class="anchor" aria-hidden="true" href="#scalar-derivatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Scalar Derivatives</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FiniteDiff.finite_difference_derivative(f, x::T, fdtype::Type{T1}=Val{:central},
    returntype::Type{T2}=eltype(x), f_x::Union{Nothing,T}=nothing)"><pre>FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_derivative</span>(f, x<span class="pl-k">::</span><span class="pl-c1">T</span>, fdtype<span class="pl-k">::</span><span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:central</span>},
    returntype<span class="pl-k">::</span><span class="pl-c1">Type{T2}</span><span class="pl-k">=</span><span class="pl-c1">eltype</span>(x), f_x<span class="pl-k">::</span><span class="pl-c1">Union{Nothing,T}</span><span class="pl-k">=</span><span class="pl-c1">nothing</span>)</pre></div>
<h2 dir="auto"><a id="user-content-multi-point-derivatives" class="anchor" aria-hidden="true" href="#multi-point-derivatives"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Multi-Point Derivatives</h2>
<h3 dir="auto"><a id="user-content-differencing-calls" class="anchor" aria-hidden="true" href="#differencing-calls"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Differencing Calls</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Cache-less but non-allocating if `fx` and `epsilon` are supplied
# fx must be f(x)
FiniteDiff.finite_difference_derivative(
    f,
    x          :: AbstractArray{&lt;:Number},
    fdtype     :: Type{T1} = Val{:central},
    returntype :: Type{T2} = eltype(x),      # return type of f
    fx         :: Union{Nothing,AbstractArray{&lt;:Number}} = nothing,
    epsilon    :: Union{Nothing,AbstractArray{&lt;:Real}} = nothing;
    [epsilon_factor])

FiniteDiff.finite_difference_derivative!(
    df         :: AbstractArray{&lt;:Number},
    f,
    x          :: AbstractArray{&lt;:Number},
    fdtype     :: Type{T1} = Val{:central},
    returntype :: Type{T2} = eltype(x),
    fx         :: Union{Nothing,AbstractArray{&lt;:Number}} = nothing,
    epsilon    :: Union{Nothing,AbstractArray{&lt;:Real}}   = nothing;
    [epsilon_factor])

# Cached
FiniteDiff.finite_difference_derivative!(
    df::AbstractArray{&lt;:Number},
    f,
    x::AbstractArray{&lt;:Number},
    cache::DerivativeCache{T1,T2,fdtype,returntype};
    [epsilon_factor])"><pre><span class="pl-c"><span class="pl-c">#</span> Cache-less but non-allocating if `fx` and `epsilon` are supplied</span>
<span class="pl-c"><span class="pl-c">#</span> fx must be f(x)</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_derivative</span>(
    f,
    x          <span class="pl-k">::</span> <span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">:central</span>},
    returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span> <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(x),      <span class="pl-c"><span class="pl-c">#</span> return type of f</span>
    fx         <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Number}}</span> <span class="pl-k">=</span> <span class="pl-c1">nothing</span>,
    epsilon    <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Real}}</span> <span class="pl-k">=</span> <span class="pl-c1">nothing</span>;
    [epsilon_factor])

FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_derivative!</span>(
    df         <span class="pl-k">::</span> <span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    f,
    x          <span class="pl-k">::</span> <span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">:central</span>},
    returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span> <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(x),
    fx         <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Number}}</span> <span class="pl-k">=</span> <span class="pl-c1">nothing</span>,
    epsilon    <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Real}}</span>   <span class="pl-k">=</span> <span class="pl-c1">nothing</span>;
    [epsilon_factor])

<span class="pl-c"><span class="pl-c">#</span> Cached</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_derivative!</span>(
    df<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    f,
    x<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    cache<span class="pl-k">::</span><span class="pl-c1">DerivativeCache{T1,T2,fdtype,returntype}</span>;
    [epsilon_factor])</pre></div>
<h3 dir="auto"><a id="user-content-allocating-and-non-allocating-constructor" class="anchor" aria-hidden="true" href="#allocating-and-non-allocating-constructor"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Allocating and Non-Allocating Constructor</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FiniteDiff.DerivativeCache(
    x          :: AbstractArray{&lt;:Number},
    fx         :: Union{Nothing,AbstractArray{&lt;:Number}} = nothing,
    epsilon    :: Union{Nothing,AbstractArray{&lt;:Real}} = nothing,
    fdtype     :: Type{T1} = Val{:central},
    returntype :: Type{T2} = eltype(x))"><pre>FiniteDiff<span class="pl-k">.</span><span class="pl-c1">DerivativeCache</span>(
    x          <span class="pl-k">::</span> <span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    fx         <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Number}}</span> <span class="pl-k">=</span> <span class="pl-c1">nothing</span>,
    epsilon    <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Real}}</span> <span class="pl-k">=</span> <span class="pl-c1">nothing</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">:central</span>},
    returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span> <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(x))</pre></div>
<p dir="auto">This allocates either <code>fx</code> or <code>epsilon</code> if these are nothing and they are needed.
<code>fx</code> is the current call of <code>f(x)</code> and is required for forward-differencing
(otherwise is not necessary).</p>
<h2 dir="auto"><a id="user-content-gradients" class="anchor" aria-hidden="true" href="#gradients"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Gradients</h2>
<p dir="auto">Gradients are either a vector-&gt;scalar map <code>f(x)</code>, or a scalar-&gt;vector map
<code>f(fx,x)</code> if <code>inplace=Val{true}</code> and <code>fx=f(x)</code> if <code>inplace=Val{false}</code>.</p>
<h3 dir="auto"><a id="user-content-differencing-calls-1" class="anchor" aria-hidden="true" href="#differencing-calls-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Differencing Calls</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Cache-less
FiniteDiff.finite_difference_gradient(
    f,
    x,
    fdtype::Type{T1}=Val{:central},
    returntype::Type{T2}=eltype(x),
    inplace::Type{Val{T3}}=Val{true};
    [epsilon_factor])
FiniteDiff.finite_difference_gradient!(
    df,
    f,
    x,
    fdtype::Type{T1}=Val{:central},
    returntype::Type{T2}=eltype(df),
    inplace::Type{Val{T3}}=Val{true};
    [epsilon_factor])

# Cached
FiniteDiff.finite_difference_gradient!(
    df::AbstractArray{&lt;:Number},
    f,
    x::AbstractArray{&lt;:Number},
    cache::GradientCache;
    [epsilon_factor])"><pre><span class="pl-c"><span class="pl-c">#</span> Cache-less</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_gradient</span>(
    f,
    x,
    fdtype<span class="pl-k">::</span><span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:central</span>},
    returntype<span class="pl-k">::</span><span class="pl-c1">Type{T2}</span><span class="pl-k">=</span><span class="pl-c1">eltype</span>(x),
    inplace<span class="pl-k">::</span><span class="pl-c1">Type{Val{T3}}</span><span class="pl-k">=</span>Val{<span class="pl-c1">true</span>};
    [epsilon_factor])
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_gradient!</span>(
    df,
    f,
    x,
    fdtype<span class="pl-k">::</span><span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:central</span>},
    returntype<span class="pl-k">::</span><span class="pl-c1">Type{T2}</span><span class="pl-k">=</span><span class="pl-c1">eltype</span>(df),
    inplace<span class="pl-k">::</span><span class="pl-c1">Type{Val{T3}}</span><span class="pl-k">=</span>Val{<span class="pl-c1">true</span>};
    [epsilon_factor])

<span class="pl-c"><span class="pl-c">#</span> Cached</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_gradient!</span>(
    df<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    f,
    x<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    cache<span class="pl-k">::</span><span class="pl-c1">GradientCache</span>;
    [epsilon_factor])</pre></div>
<h3 dir="auto"><a id="user-content-allocating-cache-constructor" class="anchor" aria-hidden="true" href="#allocating-cache-constructor"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Allocating Cache Constructor</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FiniteDiff.GradientCache(
    df         :: Union{&lt;:Number,AbstractArray{&lt;:Number}},
    x          :: Union{&lt;:Number, AbstractArray{&lt;:Number}},
    fdtype     :: Type{T1} = Val{:central},
    returntype :: Type{T2} = eltype(df),
    inplace    :: Type{Val{T3}} = Val{true})"><pre>FiniteDiff<span class="pl-k">.</span><span class="pl-c1">GradientCache</span>(
    df         <span class="pl-k">::</span> <span class="pl-c1">Union{&lt;:Number,AbstractArray{&lt;:Number}}</span>,
    x          <span class="pl-k">::</span> <span class="pl-c1">Union{&lt;:Number, AbstractArray{&lt;:Number}}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">:central</span>},
    returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span> <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(df),
    inplace    <span class="pl-k">::</span> <span class="pl-c1">Type{Val{T3}}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">true</span>})</pre></div>
<h3 dir="auto"><a id="user-content-non-allocating-cache-constructor" class="anchor" aria-hidden="true" href="#non-allocating-cache-constructor"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Non-Allocating Cache Constructor</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FiniteDiff.GradientCache(
    fx         :: Union{Nothing,&lt;:Number,AbstractArray{&lt;:Number}},
    c1         :: Union{Nothing,AbstractArray{&lt;:Number}},
    c2         :: Union{Nothing,AbstractArray{&lt;:Number}},
    c3         :: Union{Nothing,AbstractArray{&lt;:Number}},
    fdtype     :: Type{T1} = Val{:central},
    returntype :: Type{T2} = eltype(fx),
    inplace    :: Type{Val{T3}} = Val{true})"><pre>FiniteDiff<span class="pl-k">.</span><span class="pl-c1">GradientCache</span>(
    fx         <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,&lt;:Number,AbstractArray{&lt;:Number}}</span>,
    c1         <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Number}}</span>,
    c2         <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Number}}</span>,
    c3         <span class="pl-k">::</span> <span class="pl-c1">Union{Nothing,AbstractArray{&lt;:Number}}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">:central</span>},
    returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span> <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(fx),
    inplace    <span class="pl-k">::</span> <span class="pl-c1">Type{Val{T3}}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">true</span>})</pre></div>
<p dir="auto">Note that here <code>fx</code> is a cached function call of <code>f</code>. If you provide <code>fx</code>, then
<code>fx</code> will be used in the forward differencing method to skip a function call.
It is on you to make sure that you update <code>cache.fx</code> every time before
calling <code>FiniteDiff.finite_difference_gradient!</code>. If <code>fx</code> is an immutable, e.g. a scalar or
a <code>StaticArray</code>, <code>cache.fx</code> should be updated using <code>@set</code> from <a href="https://github.com/jw3126/Setfield.jl">Setfield.jl</a>.
A good use of this is if you have a cache array for the output of <code>fx</code> already being used, you can make it alias
into the differencing algorithm here.</p>
<h2 dir="auto"><a id="user-content-jacobians" class="anchor" aria-hidden="true" href="#jacobians"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Jacobians</h2>
<p dir="auto">Jacobians are for functions <code>f!(fx,x)</code> when using in-place <code>finite_difference_jacobian!</code>,
and <code>fx = f(x)</code> when using out-of-place <code>finite_difference_jacobian</code>. The out-of-place
jacobian will return a similar type as <code>jac_prototype</code> if it is not a <code>nothing</code>. For non-square
Jacobians, a cache which specifies the vector <code>fx</code> is required.</p>
<p dir="auto">For sparse differentiation, pass a <code>colorvec</code> of matrix colors. <code>sparsity</code> should be a sparse
or structured matrix (<code>Tridiagonal</code>, <code>Banded</code>, etc. according to the ArrayInterfaceCore.jl specs)
to allow for decompression, otherwise the result will be the colorvec compressed Jacobian.</p>
<h3 dir="auto"><a id="user-content-differencing-calls-2" class="anchor" aria-hidden="true" href="#differencing-calls-2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Differencing Calls</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Cache-less
FiniteDiff.finite_difference_jacobian(
    f,
    x          :: AbstractArray{&lt;:Number},
    fdtype     :: Type{T1}=Val{:central},
    returntype :: Type{T2}=eltype(x),
    relstep=default_relstep(fdtype, eltype(x)),
    absstep=relstep,
    colorvec = 1:length(x),
    sparsity = nothing,
    jac_prototype = nothing)

finite_difference_jacobian!(J::AbstractMatrix,
    f,
    x::AbstractArray{&lt;:Number},
    fdtype     :: Type{T1}=Val{:forward},
    returntype :: Type{T2}=eltype(x),
    f_in       :: Union{T2,Nothing}=nothing;
    relstep=default_relstep(fdtype, eltype(x)),
    absstep=relstep,
    colorvec = 1:length(x),
    sparsity = ArrayInterfaceCore.has_sparsestruct(J) ? J : nothing)

# Cached
FiniteDiff.finite_difference_jacobian(
    f,
    x,
    cache::JacobianCache;
    relstep=default_relstep(fdtype, eltype(x)),
    absstep=relstep,
    colorvec = cache.colorvec,
    sparsity = cache.sparsity,
    jac_prototype = nothing)

FiniteDiff.finite_difference_jacobian!(
    J::AbstractMatrix{&lt;:Number},
    f,
    x::AbstractArray{&lt;:Number},
    cache::JacobianCache;
    relstep=default_relstep(fdtype, eltype(x)),
    absstep=relstep,
    colorvec = cache.colorvec,
    sparsity = cache.sparsity)"><pre><span class="pl-c"><span class="pl-c">#</span> Cache-less</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian</span>(
    f,
    x          <span class="pl-k">::</span> <span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:central</span>},
    returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span><span class="pl-k">=</span><span class="pl-c1">eltype</span>(x),
    relstep<span class="pl-k">=</span><span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
    absstep<span class="pl-k">=</span>relstep,
    colorvec <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(x),
    sparsity <span class="pl-k">=</span> <span class="pl-c1">nothing</span>,
    jac_prototype <span class="pl-k">=</span> <span class="pl-c1">nothing</span>)

<span class="pl-c1">finite_difference_jacobian!</span>(J<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix</span>,
    f,
    x<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:forward</span>},
    returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span><span class="pl-k">=</span><span class="pl-c1">eltype</span>(x),
    f_in       <span class="pl-k">::</span> <span class="pl-c1">Union{T2,Nothing}</span><span class="pl-k">=</span><span class="pl-c1">nothing</span>;
    relstep<span class="pl-k">=</span><span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
    absstep<span class="pl-k">=</span>relstep,
    colorvec <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(x),
    sparsity <span class="pl-k">=</span> ArrayInterfaceCore<span class="pl-k">.</span><span class="pl-c1">has_sparsestruct</span>(J) <span class="pl-k">?</span> J <span class="pl-k">:</span> <span class="pl-c1">nothing</span>)

<span class="pl-c"><span class="pl-c">#</span> Cached</span>
FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian</span>(
    f,
    x,
    cache<span class="pl-k">::</span><span class="pl-c1">JacobianCache</span>;
    relstep<span class="pl-k">=</span><span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
    absstep<span class="pl-k">=</span>relstep,
    colorvec <span class="pl-k">=</span> cache<span class="pl-k">.</span>colorvec,
    sparsity <span class="pl-k">=</span> cache<span class="pl-k">.</span>sparsity,
    jac_prototype <span class="pl-k">=</span> <span class="pl-c1">nothing</span>)

FiniteDiff<span class="pl-k">.</span><span class="pl-c1">finite_difference_jacobian!</span>(
    J<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix{&lt;:Number}</span>,
    f,
    x<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    cache<span class="pl-k">::</span><span class="pl-c1">JacobianCache</span>;
    relstep<span class="pl-k">=</span><span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
    absstep<span class="pl-k">=</span>relstep,
    colorvec <span class="pl-k">=</span> cache<span class="pl-k">.</span>colorvec,
    sparsity <span class="pl-k">=</span> cache<span class="pl-k">.</span>sparsity)</pre></div>
<h3 dir="auto"><a id="user-content-allocating-cache-constructor-1" class="anchor" aria-hidden="true" href="#allocating-cache-constructor-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Allocating Cache Constructor</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FiniteDiff.JacobianCache(
              x,
              fdtype     :: Type{T1} = Val{:central},
              returntype :: Type{T2} = eltype(x),
              colorvec = 1:length(x)
              sparsity = nothing)"><pre>FiniteDiff<span class="pl-k">.</span><span class="pl-c1">JacobianCache</span>(
              x,
              fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">:central</span>},
              returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span> <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(x),
              colorvec <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(x)
              sparsity <span class="pl-k">=</span> <span class="pl-c1">nothing</span>)</pre></div>
<p dir="auto">This assumes the Jacobian is square.</p>
<h3 dir="auto"><a id="user-content-non-allocating-cache-constructor-1" class="anchor" aria-hidden="true" href="#non-allocating-cache-constructor-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Non-Allocating Cache Constructor</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FiniteDiff.JacobianCache(
              x1 ,
              fx ,
              fx1,
              fdtype     :: Type{T1} = Val{:central},
              returntype :: Type{T2} = eltype(fx),
              colorvec = 1:length(x1),
              sparsity = nothing)"><pre>FiniteDiff<span class="pl-k">.</span><span class="pl-c1">JacobianCache</span>(
              x1 ,
              fx ,
              fx1,
              fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span> <span class="pl-k">=</span> Val{<span class="pl-c1">:central</span>},
              returntype <span class="pl-k">::</span> <span class="pl-c1">Type{T2}</span> <span class="pl-k">=</span> <span class="pl-c1">eltype</span>(fx),
              colorvec <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">length</span>(x1),
              sparsity <span class="pl-k">=</span> <span class="pl-c1">nothing</span>)</pre></div>
<h2 dir="auto"><a id="user-content-hessians" class="anchor" aria-hidden="true" href="#hessians"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hessians</h2>
<p dir="auto">Hessians are for functions <code>f(x)</code> which return a scalar.</p>
<h3 dir="auto"><a id="user-content-differencing-calls-3" class="anchor" aria-hidden="true" href="#differencing-calls-3"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Differencing Calls</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#Cacheless
finite_difference_hessian(f, x::AbstractArray{&lt;:Number},
    fdtype     :: Type{T1}=Val{:hcentral},
    inplace    :: Type{Val{T2}} = x isa StaticArray ? Val{true} : Val{false};
    relstep=default_relstep(fdtype, eltype(x)),
    absstep=relstep)

finite_difference_hessian!(H::AbstractMatrix,f,
    x::AbstractArray{&lt;:Number},
    fdtype     :: Type{T1}=Val{:hcentral},
    inplace    :: Type{Val{T2}} = x isa StaticArray ? Val{true} : Val{false};
    relstep=default_relstep(fdtype, eltype(x)),
    absstep=relstep)

#Cached
finite_difference_hessian(
    f,x,
    cache::HessianCache{T,fdtype,inplace};
    relstep=default_relstep(fdtype, eltype(x)),
    absstep=relstep)

finite_difference_hessian!(H,f,x,
                           cache::HessianCache{T,fdtype,inplace};
                           relstep = default_relstep(fdtype, eltype(x)),
                           absstep = relstep)"><pre><span class="pl-c"><span class="pl-c">#</span>Cacheless</span>
<span class="pl-c1">finite_difference_hessian</span>(f, x<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:hcentral</span>},
    inplace    <span class="pl-k">::</span> <span class="pl-c1">Type{Val{T2}}</span> <span class="pl-k">=</span> x <span class="pl-k">isa</span> StaticArray <span class="pl-k">?</span> Val{<span class="pl-c1">true</span>} <span class="pl-k">:</span> Val{<span class="pl-c1">false</span>};
    relstep<span class="pl-k">=</span><span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
    absstep<span class="pl-k">=</span>relstep)

<span class="pl-c1">finite_difference_hessian!</span>(H<span class="pl-k">::</span><span class="pl-c1">AbstractMatrix</span>,f,
    x<span class="pl-k">::</span><span class="pl-c1">AbstractArray{&lt;:Number}</span>,
    fdtype     <span class="pl-k">::</span> <span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:hcentral</span>},
    inplace    <span class="pl-k">::</span> <span class="pl-c1">Type{Val{T2}}</span> <span class="pl-k">=</span> x <span class="pl-k">isa</span> StaticArray <span class="pl-k">?</span> Val{<span class="pl-c1">true</span>} <span class="pl-k">:</span> Val{<span class="pl-c1">false</span>};
    relstep<span class="pl-k">=</span><span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
    absstep<span class="pl-k">=</span>relstep)

<span class="pl-c"><span class="pl-c">#</span>Cached</span>
<span class="pl-c1">finite_difference_hessian</span>(
    f,x,
    cache<span class="pl-k">::</span><span class="pl-c1">HessianCache{T,fdtype,inplace}</span>;
    relstep<span class="pl-k">=</span><span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
    absstep<span class="pl-k">=</span>relstep)

<span class="pl-c1">finite_difference_hessian!</span>(H,f,x,
                           cache<span class="pl-k">::</span><span class="pl-c1">HessianCache{T,fdtype,inplace}</span>;
                           relstep <span class="pl-k">=</span> <span class="pl-c1">default_relstep</span>(fdtype, <span class="pl-c1">eltype</span>(x)),
                           absstep <span class="pl-k">=</span> relstep)</pre></div>
<h3 dir="auto"><a id="user-content-allocating-cache-calls" class="anchor" aria-hidden="true" href="#allocating-cache-calls"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Allocating Cache Calls</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="HessianCache(x,fdtype::Type{T1}=Val{:hcentral},
                        inplace::Type{Val{T2}} = x isa StaticArray ? Val{true} : Val{false})"><pre><span class="pl-c1">HessianCache</span>(x,fdtype<span class="pl-k">::</span><span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:hcentral</span>},
                        inplace<span class="pl-k">::</span><span class="pl-c1">Type{Val{T2}}</span> <span class="pl-k">=</span> x <span class="pl-k">isa</span> StaticArray <span class="pl-k">?</span> Val{<span class="pl-c1">true</span>} <span class="pl-k">:</span> Val{<span class="pl-c1">false</span>})</pre></div>
<h3 dir="auto"><a id="user-content-non-allocating-cache-calls" class="anchor" aria-hidden="true" href="#non-allocating-cache-calls"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Non-Allocating Cache Calls</h3>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="HessianCache(xpp,xpm,xmp,xmm,
                      fdtype::Type{T1}=Val{:hcentral},
                      inplace::Type{Val{T2}} = x isa StaticArray ? Val{true} : Val{false})"><pre><span class="pl-c1">HessianCache</span>(xpp,xpm,xmp,xmm,
                      fdtype<span class="pl-k">::</span><span class="pl-c1">Type{T1}</span><span class="pl-k">=</span>Val{<span class="pl-c1">:hcentral</span>},
                      inplace<span class="pl-k">::</span><span class="pl-c1">Type{Val{T2}}</span> <span class="pl-k">=</span> x <span class="pl-k">isa</span> StaticArray <span class="pl-k">?</span> Val{<span class="pl-c1">true</span>} <span class="pl-k">:</span> Val{<span class="pl-c1">false</span>})</pre></div>
</article></div>