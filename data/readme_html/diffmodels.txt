<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-diffmodelsjl" class="anchor" aria-hidden="true" href="#diffmodelsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DiffModels.jl</h1>
<p><a href="https://travis-ci.org/DrugowitschLab/DiffModels.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/2106ceda7d5e18b60fa9e3ecda3d1a515e135234/68747470733a2f2f7472617669732d63692e6f72672f447275676f7769747363684c61622f446966664d6f64656c732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/DrugowitschLab/DiffModels.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p><a href="https://coveralls.io/github/DrugowitschLab/DiffModels.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/d951783ef74fe88f9c1360f683e16486dbe43305/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f447275676f7769747363684c61622f446966664d6f64656c732e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/DrugowitschLab/DiffModels.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a></p>
<p><a href="http://codecov.io/github/DrugowitschLab/DiffModels.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/c604b166491c6a0b0586313de7732f858043cf1a/687474703a2f2f636f6465636f762e696f2f6769746875622f447275676f7769747363684c61622f446966664d6f64656c732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/DrugowitschLab/DiffModels.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>A Julia package for simulating diffusion models and compute their first passage time densities.</p>
<p><em>No guarantee is provided for the correctness of the implementation.</em></p>
<p>The code is licensed under the MIT License.</p>
<h2><a id="user-content-content" class="anchor" aria-hidden="true" href="#content"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Content</h2>
<p>The library provides Julia classes and functions to define diffusion models, sample their first-passage times and boundaries, and compute their first-passage time density functions. For now, only diffusion models with two absorbing boundaries are supported. The library supports time-changing boundaries and drifts.</p>
<p>The diffusion models assume a drifting and diffusing particle <em>x(t)</em> that starts at <em>x(0) = 0</em>and whose time-course follows</p>
<p><em>dx = mu(t) dt + sig(t) dW</em> ,</p>
<p>where <em>mu(t)</em> is the current drift, <em>sig(t)</em> is the current diffusion standard deviation (for now assumed to be <em>sig(t)=1</em>, always), and <em>dW</em> is a Wiener process. Diffusion is terminated as soon as the particle reaches either the upper boundary <em>theta_u(t)</em> or lower boundary <em>theta_t(t)</em>. The library requires <em>theta_u(0) &gt; 0</em> and <em>theta_l(0) &lt; 0</em>. The time at which either boundary is reached is the first-passage time. The associated densities, <em>g_u(t)</em> and <em>g_l(t)</em>, are the joint densities over bounds and first-passage times, such that</p>
<p><em>integral_0^infinity (g_u(t) + g_l(t)) dt = 1</em> .</p>
<p>The library provides specialised classes for time-invariant drifts, <em>mu(t) = mu_0</em> for all <em>t</em>, time-invariant bounds, <em>theta(t) = theta_0</em> for all <em>t</em>, symmetric bounds, <em>theta_l(t) = - theta_u(t)</em> (see below).</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<h3><a id="user-content-julia-07x-and-above" class="anchor" aria-hidden="true" href="#julia-07x-and-above"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Julia 0.7.x and above</h3>
<p>The easiest way to install DiffModels.jl is by using the Julia Package Manager at the Julia Pkg prompt:</p>
<pre><code>pkg&gt; add https://github.com/DrugowitschLab/DiffModels.jl
</code></pre>
<h3><a id="user-content-julia-06x" class="anchor" aria-hidden="true" href="#julia-06x"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Julia 0.6.x</h3>
<p>For installation with Julia 0.6.x, use the following command at the Julia prompt:</p>
<pre><code>julia&gt; Pkg.clone("git://github.com/DrugowitschLab/DiffModels.jl.git")
</code></pre>
<p>Then call <code>Pkg.dir()</code> to find the package installation directly, open a terminal and navigate to this directory. For there, use</p>
<pre><code># cd DiffModels
# git checkout 1cd0b4a418a9d78f6f19442526cb9de91507bbbe
</code></pre>
<p>in the terminal to roll back to the last version compatible with Julia 0.6.x.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The library is based on assembling diffusion models from drift and boundary specifications. If not constant, all drifts/boundaries are specified by vectors in time steps of <em>dt</em>, with the first vector element corresponding to <em>t=0</em>. In most cases, these vectors need to be sufficiently long to cover the whole time of relevance. The first-passage times cannot computed beyond this time, and samples cannot be drawn after it. This restriction does not apply to time-invariant drifts/bounds, which do not feature this limitation.</p>
<h3><a id="user-content-drift" class="anchor" aria-hidden="true" href="#drift"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Drift</h3>
<p>The available drifts are defined in <a href="src/drift.jl">src/drift.jl</a>. All drifts are based on the abstract base class <code>AbstractDrift</code>. The following constructors are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">ConstDrift</span>(mu<span class="pl-k">::</span><span class="pl-c1">Real</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarDrift</span>(mu<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarDrift</span>(mu<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>, maxt<span class="pl-k">::</span><span class="pl-c1">Real</span>)</pre></div>
<p><code>ConstDrift</code> is a constant drift of size <code>mu</code>. <code>dt</code> needs to be nonetheless specified, to evaluate the step size for diffusion model sampling. <code>VarDrift</code> is a drift that changes over time according to the <code>mu</code> vector that specifies this drift in steps of <code>dt</code>. If <code>maxt</code> is given, the <code>mu</code> vector is extended by repeating its last element until time <code>maxt</code>.</p>
<h3><a id="user-content-boundaries" class="anchor" aria-hidden="true" href="#boundaries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Boundaries</h3>
<p>The available boundaries are defined in <a href="src/bound.jl">src/bound.jl</a>. Single boundaries are based on the abstract base class 'AbstractBound'. For such boundaries, the following constructors are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">ConstBound</span>(b<span class="pl-k">::</span><span class="pl-c1">Real</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">LinearBound</span>(b0<span class="pl-k">::</span><span class="pl-c1">Real</span>, bslope<span class="pl-k">::</span><span class="pl-c1">Real</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarBound</span>(b<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, bg<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarBound</span>(b<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)</pre></div>
<p><code>ConstBound</code> is a constant boundary at <code>b</code>. <code>LinearBound</code> is a linearly changing boundary that, at time <code>t</code> is located at <code>b0 + t * bslope</code>. <code>VarBound</code> is a time-varying boundary that changes over time according to the vector <code>b</code> in steps of <code>dt</code>. <code>bg</code> is its time derivative, and needs to contain the same number of elements as <code>b</code>. If not specified (last constructor), it is estimated from <code>b</code> by finite differences.</p>
<p>Boundary pairs are based on the abstract base class <code>AbstractBounds</code>. For such pairs, the following constructors are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">SymBounds</span>(b<span class="pl-k">::</span><span class="pl-c1">T</span>) <span class="pl-k">where</span> T <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractBound</span>
typealias VarSymBounds SymBounds{VarBound}
typealias LinearSymBounds SymBounds{LinearBound}
typealias ConstSymBounds SymBounds{ConstBound}

<span class="pl-c1">AsymBounds</span>(upper<span class="pl-k">::</span><span class="pl-c1">T1</span>, lower<span class="pl-k">::</span><span class="pl-c1">T2</span>) <span class="pl-k">where</span> {T1 <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractBound</span>, T2 <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractBound</span>}
VarAsymBounds AsymBounds{VarBound, VarBound}
ConstAsymBounds AsymBounds{ConstBound, ConstBound}

typealias ConstBounds <span class="pl-c1">Union</span>(ConstSymBounds, ConstAsymBounds)</pre></div>
<p><code>SymBounds</code> and <code>AsymBounds</code> specify symmetric boundaries (around zero) and asymmetric boundaries, respectively. <code>SymBounds</code> needs to be constructed with the upper boundary, and the lower boundaries is mirrored around zero. <code>AsymBounds</code> is constructed with two boundaries, where <code>upper</code> is the upper boundary, and <code>lower</code> is the <em>negative</em> lower boundary.</p>
<h3><a id="user-content-first-passage-time-densities" class="anchor" aria-hidden="true" href="#first-passage-time-densities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>First-passage time densities</h3>
<p>In the most general case, the first-passage time densities are computed by</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pdf</span>(d<span class="pl-k">::</span><span class="pl-c1">AbstractDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">AbstractBounds</span>, tmax<span class="pl-k">::</span><span class="pl-c1">Real</span>)</pre></div>
<p>This function returns the vectors <code>g1</code> and <code>g2</code> that contain the densities for the upper and the lower boundary, respecively, in steps of <code>dt</code> (as specified by drift and bounds) up to time <code>tmax</code>.</p>
<p>For some combination of constant drifts and constant boundaries, significantly more efficient functions are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pdf</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, tmax<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">pdfu</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, t<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
<span class="pl-c1">pdfl</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, t<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
<span class="pl-c1">pdful</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, t<span class="pl-k">::</span><span class="pl-c1">Float64</span>)</pre></div>
<p><code>pdf</code> returns two vectors, <code>g1</code> and <code>g2</code>, as before. <code>pdfu</code> and <code>pdfl</code> compute the first-passage time density at the upper and lower boundary, respecively, only at time <code>t</code>. <code>pdful</code> returns both densities for this time.</p>
<h3><a id="user-content-drawing-first-passage-time-and-boundary-samples" class="anchor" aria-hidden="true" href="#drawing-first-passage-time-and-boundary-samples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Drawing first-passage time and boundary samples</h3>
<p>Diffusion model sampling is based on the <code>Sampler</code> framework from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>. The basic idea to is create a sampler <code>s</code> from a drift/boundary specification, on which <code>rand(s)</code> is called. All calls to <code>rand(s)</code> return a <code>t, bound</code> pair, where <code>t</code> is the first-passage time, and <code>bound</code> is <code>true</code> if the upper boundary was reached, and <code>false</code> otherwise. Currently, the following samplers exist:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">sampler</span>(d<span class="pl-k">::</span><span class="pl-c1">AbstractDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">AbstractBounds</span>)
<span class="pl-c1">sampler</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstSymBounds</span>)
<span class="pl-c1">sampler</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstAsymBounds</span>)</pre></div>
<p>The first sampler is a generic diffusion model sampler that draws samples by simulating full trajectories in steps of <code>dt</code>. All samples beyond the time that the drift/bound are specified return <code>t = Inf</code> and a random <code>bound</code>. The other samplers use a specialised and significantly faster method, based on rejection sampling.</p>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>References</h2>
<p>In general, the library computes the first-passage time densities by finding the solution to an integral equation, as described in</p>
<p>Smith PL (2000). <a href="http://dx.doi.org/10.1006/jmps.1999.1260" rel="nofollow">Stochastic Dynamic Models of Response Time and Accuracy: A Foundational Primer</a>. <em>Journal of Mathematical Psychology</em>, 44 (3). 408-463.</p>
<p>For constant drift and bounds, it instead uses a much faster method, based on an infinite series expansion of these densities, as described in</p>
<p>Cox DR and Miller HD (1965). <em>The Theory of Stochastic Processes</em>. John Wiley &amp; Sons, Inc.</p>
<p>and</p>
<p>Navarro DJ and Fuss IG (2009). <a href="http://dx.doi.org/10.1016/j.jmp.2009.02.003" rel="nofollow">Fast and accurate calculations for first-passage times in Wiener diffusion models</a>. <em>Journal of Mathematical Psychology</em>, 53, 222-230.</p>
<p>Samples are in the most general case drawn by simulating trajectories by the Euler–Maruyama method. For diffusion models with constant drift and (symmetric or asymmetric) boundaries, the following significantly faster method based on rejection sampling is used:</p>
<p>Drugowitsch J (2016). <a href="http://dx.doi.org/10.1038/srep20490" rel="nofollow">Fast and accurate Monte Carlo sampling of first-passage times from Wiener diffusion models</a>. <em>Scientific Reports</em> 6, 20490; doi: 10.1038/srep20490.</p>
</article></div>