<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-diffmodelsjl" class="anchor" aria-hidden="true" href="#diffmodelsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DiffModels.jl</h1>
<p><a href="https://travis-ci.org/DrugowitschLab/DiffModels.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/2106ceda7d5e18b60fa9e3ecda3d1a515e135234/68747470733a2f2f7472617669732d63692e6f72672f447275676f7769747363684c61622f446966664d6f64656c732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/DrugowitschLab/DiffModels.jl.svg?branch=master" style="max-width:100%;"></a></p>
<p><a href="https://coveralls.io/github/DrugowitschLab/DiffModels.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/d951783ef74fe88f9c1360f683e16486dbe43305/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f447275676f7769747363684c61622f446966664d6f64656c732e6a6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/DrugowitschLab/DiffModels.jl/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a></p>
<p><a href="http://codecov.io/github/DrugowitschLab/DiffModels.jl?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/c604b166491c6a0b0586313de7732f858043cf1a/687474703a2f2f636f6465636f762e696f2f6769746875622f447275676f7769747363684c61622f446966664d6f64656c732e6a6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/DrugowitschLab/DiffModels.jl/coverage.svg?branch=master" style="max-width:100%;"></a></p>
<p>A Julia package for simulating diffusion models and compute their first passage time densities.</p>
<p><em>No guarantee is provided for the correctness of the implementation.</em></p>
<p>The code is licensed under the MIT License.</p>
<h2><a id="user-content-content" class="anchor" aria-hidden="true" href="#content"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Content</h2>
<p>The library provides Julia classes and functions to define diffusion models, sample their first-passage times and boundaries, and compute their first-passage time density functions. For now, only diffusion models with two absorbing boundaries are supported. The library supports time-changing boundaries and drifts.</p>
<p>The diffusion models assume a drifting and diffusing particle <em>x(t)</em> that starts at <em>x(0) = 0</em>and whose time-course follows</p>
<p><em>dx = mu(t) dt + sig(t) dW</em> ,</p>
<p>where <em>mu(t)</em> is the current drift, <em>sig(t)</em> is the current diffusion standard deviation (for now assumed to be <em>sig(t)=1</em>, always), and <em>dW</em> is a Wiener process. Diffusion is terminated as soon as the particle reaches either the upper boundary <em>theta_u(t)</em> or lower boundary <em>theta_t(t)</em>. The library requires <em>theta_u(0) &gt; 0</em> and <em>theta_l(0) &lt; 0</em>. The time at which either boundary is reached is the first-passage time. The associated densities, <em>g_u(t)</em> and <em>g_l(t)</em>, are the joint densities over bounds and first-passage times, such that</p>
<p><em>integral_0^infinity (g_u(t) + g_l(t)) dt = 1</em> .</p>
<p>The library provides specialised classes for time-invariant drifts, <em>mu(t) = mu_0</em> for all <em>t</em>, time-invariant bounds, <em>theta(t) = theta_0</em> for all <em>t</em>, symmetric bounds, <em>theta_l(t) = - theta_u(t)</em> (see below).</p>
<h2><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<h3><a id="user-content-julia-07x-and-above" class="anchor" aria-hidden="true" href="#julia-07x-and-above"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Julia 0.7.x and above</h3>
<p>The easiest way to install DiffModels.jl is by using the Julia Package Manager at the Julia Pkg prompt:</p>
<pre><code>pkg&gt; add https://github.com/DrugowitschLab/DiffModels.jl
</code></pre>
<h3><a id="user-content-julia-06x" class="anchor" aria-hidden="true" href="#julia-06x"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Julia 0.6.x</h3>
<p>For installation with Julia 0.6.x, use the following command at the Julia prompt:</p>
<pre><code>julia&gt; Pkg.clone("git://github.com/DrugowitschLab/DiffModels.jl.git")
</code></pre>
<p>Then call <code>Pkg.dir()</code> to find the package installation directly, open a terminal and navigate to this directory. For there, use</p>
<pre><code># cd DiffModels
# git checkout 1cd0b4a418a9d78f6f19442526cb9de91507bbbe
</code></pre>
<p>in the terminal to roll back to the last version compatible with Julia 0.6.x.</p>
<h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p>The library is based on assembling diffusion models from drift and boundary specifications. If not constant, all drifts/boundaries are specified by vectors in time steps of <em>dt</em>, with the first vector element corresponding to <em>t=0</em>. In most cases, these vectors need to be sufficiently long to cover the whole time of relevance. The first-passage times cannot computed beyond this time, and samples cannot be drawn after it. This restriction does not apply to time-invariant drifts/bounds, which do not feature this limitation.</p>
<h3><a id="user-content-drift" class="anchor" aria-hidden="true" href="#drift"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Drift</h3>
<p>The available drifts are defined in <a href="src/drift.jl">src/drift.jl</a>. All drifts are based on the abstract base class <code>AbstractDrift</code>. The following constructors are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">ConstDrift</span>(mu<span class="pl-k">::</span><span class="pl-c1">Real</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarDrift</span>(mu<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarDrift</span>(mu<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>, maxt<span class="pl-k">::</span><span class="pl-c1">Real</span>)</pre></div>
<p><code>ConstDrift</code> is a constant drift of size <code>mu</code>. <code>dt</code> needs to be nonetheless specified, to evaluate the step size for diffusion model sampling. <code>VarDrift</code> is a drift that changes over time according to the <code>mu</code> vector that specifies this drift in steps of <code>dt</code>. If <code>maxt</code> is given, the <code>mu</code> vector is extended by repeating its last element until time <code>maxt</code>.</p>
<h3><a id="user-content-boundaries" class="anchor" aria-hidden="true" href="#boundaries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Boundaries</h3>
<p>The available boundaries are defined in <a href="src/bound.jl">src/bound.jl</a>. Single boundaries are based on the abstract base class 'AbstractBound'. For such boundaries, the following constructors are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">ConstBound</span>(b<span class="pl-k">::</span><span class="pl-c1">Real</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">LinearBound</span>(b0<span class="pl-k">::</span><span class="pl-c1">Real</span>, bslope<span class="pl-k">::</span><span class="pl-c1">Real</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarBound</span>(b<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, bg<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">VarBound</span>(b<span class="pl-k">::</span><span class="pl-c1">Vector{Float64}</span>, dt<span class="pl-k">::</span><span class="pl-c1">Real</span>)</pre></div>
<p><code>ConstBound</code> is a constant boundary at <code>b</code>. <code>LinearBound</code> is a linearly changing boundary that, at time <code>t</code> is located at <code>b0 + t * bslope</code>. <code>VarBound</code> is a time-varying boundary that changes over time according to the vector <code>b</code> in steps of <code>dt</code>. <code>bg</code> is its time derivative, and needs to contain the same number of elements as <code>b</code>. If not specified (last constructor), it is estimated from <code>b</code> by finite differences.</p>
<p>Boundary pairs are based on the abstract base class <code>AbstractBounds</code>. For such pairs, the following constructors are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">SymBounds</span>(b<span class="pl-k">::</span><span class="pl-c1">T</span>) <span class="pl-k">where</span> T <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractBound</span>
typealias VarSymBounds SymBounds{VarBound}
typealias LinearSymBounds SymBounds{LinearBound}
typealias ConstSymBounds SymBounds{ConstBound}

<span class="pl-c1">AsymBounds</span>(upper<span class="pl-k">::</span><span class="pl-c1">T1</span>, lower<span class="pl-k">::</span><span class="pl-c1">T2</span>) <span class="pl-k">where</span> {T1 <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractBound</span>, T2 <span class="pl-k">&lt;:</span> <span class="pl-c1">AbstractBound</span>}
VarAsymBounds AsymBounds{VarBound, VarBound}
ConstAsymBounds AsymBounds{ConstBound, ConstBound}

typealias ConstBounds <span class="pl-c1">Union</span>(ConstSymBounds, ConstAsymBounds)</pre></div>
<p><code>SymBounds</code> and <code>AsymBounds</code> specify symmetric boundaries (around zero) and asymmetric boundaries, respectively. <code>SymBounds</code> needs to be constructed with the upper boundary, and the lower boundaries is mirrored around zero. <code>AsymBounds</code> is constructed with two boundaries, where <code>upper</code> is the upper boundary, and <code>lower</code> is the <em>negative</em> lower boundary.</p>
<h3><a id="user-content-first-passage-time-densities" class="anchor" aria-hidden="true" href="#first-passage-time-densities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>First-passage time densities</h3>
<p>In the most general case, the first-passage time densities are computed by</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pdf</span>(d<span class="pl-k">::</span><span class="pl-c1">AbstractDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">AbstractBounds</span>, tmax<span class="pl-k">::</span><span class="pl-c1">Real</span>)</pre></div>
<p>This function returns the vectors <code>g1</code> and <code>g2</code> that contain the densities for the upper and the lower boundary, respecively, in steps of <code>dt</code> (as specified by drift and bounds) up to time <code>tmax</code>.</p>
<p>For some combination of constant drifts and constant boundaries, significantly more efficient functions are available:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">pdf</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, tmax<span class="pl-k">::</span><span class="pl-c1">Real</span>)
<span class="pl-c1">pdfu</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, t<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
<span class="pl-c1">pdfl</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, t<span class="pl-k">::</span><span class="pl-c1">Float64</span>)
<span class="pl-c1">pdful</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstBounds</span>, t<span class="pl-k">::</span><span class="pl-c1">Float64</span>)</pre></div>
<p><code>pdf</code> returns two vectors, <code>g1</code> and <code>g2</code>, as before. <code>pdfu</code> and <code>pdfl</code> compute the first-passage time density at the upper and lower boundary, respecively, only at time <code>t</code>. <code>pdful</code> returns both densities for this time.</p>
<h3><a id="user-content-drawing-first-passage-time-and-boundary-samples" class="anchor" aria-hidden="true" href="#drawing-first-passage-time-and-boundary-samples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Drawing first-passage time and boundary samples</h3>
<p>Diffusion model sampling is based on the <code>Sampler</code> framework from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>. The basic idea to is create a sampler <code>s</code> from a drift/boundary specification, on which <code>rand(s)</code> is called. All calls to <code>rand(s)</code> return a <code>t, bound</code> pair, where <code>t</code> is the first-passage time, and <code>bound</code> is <code>true</code> if the upper boundary was reached, and <code>false</code> otherwise. Currently, the following samplers exist:</p>
<div class="highlight highlight-source-julia"><pre><span class="pl-c1">sampler</span>(d<span class="pl-k">::</span><span class="pl-c1">AbstractDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">AbstractBounds</span>)
<span class="pl-c1">sampler</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstSymBounds</span>)
<span class="pl-c1">sampler</span>(d<span class="pl-k">::</span><span class="pl-c1">ConstDrift</span>, b<span class="pl-k">::</span><span class="pl-c1">ConstAsymBounds</span>)</pre></div>
<p>The first sampler is a generic diffusion model sampler that draws samples by simulating full trajectories in steps of <code>dt</code>. All samples beyond the time that the drift/bound are specified return <code>t = Inf</code> and a random <code>bound</code>. The other samplers use a specialised and significantly faster method, based on rejection sampling.</p>
<h2><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>References</h2>
<p>In general, the library computes the first-passage time densities by finding the solution to an integral equation, as described in</p>
<p>Smith PL (2000). <a href="http://dx.doi.org/10.1006/jmps.1999.1260" rel="nofollow">Stochastic Dynamic Models of Response Time and Accuracy: A Foundational Primer</a>. <em>Journal of Mathematical Psychology</em>, 44 (3). 408-463.</p>
<p>For constant drift and bounds, it instead uses a much faster method, based on an infinite series expansion of these densities, as described in</p>
<p>Cox DR and Miller HD (1965). <em>The Theory of Stochastic Processes</em>. John Wiley &amp; Sons, Inc.</p>
<p>and</p>
<p>Navarro DJ and Fuss IG (2009). <a href="http://dx.doi.org/10.1016/j.jmp.2009.02.003" rel="nofollow">Fast and accurate calculations for first-passage times in Wiener diffusion models</a>. <em>Journal of Mathematical Psychology</em>, 53, 222-230.</p>
<p>Samples are in the most general case drawn by simulating trajectories by the Eulerâ€“Maruyama method. For diffusion models with constant drift and (symmetric or asymmetric) boundaries, the following significantly faster method based on rejection sampling is used:</p>
<p>Drugowitsch J (2016). <a href="http://dx.doi.org/10.1038/srep20490" rel="nofollow">Fast and accurate Monte Carlo sampling of first-passage times from Wiener diffusion models</a>. <em>Scientific Reports</em> 6, 20490; doi: 10.1038/srep20490.</p>
</article></div>