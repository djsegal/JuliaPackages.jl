<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-memoizationjl" class="anchor" aria-hidden="true" href="#memoizationjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Memoization.jl</h1>
<p dir="auto"><a href="https://travis-ci.com/marius311/Memoization.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/e3f85ef93247f3e92c4fd79554efe7fc365519ef2fcf0c0b0595efd8daf8081e/68747470733a2f2f7472617669732d63692e636f6d2f6d61726975733331312f4d656d6f697a6174696f6e2e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/marius311/Memoization.jl.svg?branch=master" style="max-width: 100%;"></a></p>
<p dir="auto">Easily and efficiently memoize any function call, function, closure, or callable object in Julia.</p>
<h2 dir="auto"><a id="user-content-example-usage" class="anchor" aria-hidden="true" href="#example-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example Usage</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
julia&gt; using Memoization

julia&gt; @memoize f(x) = (println(&quot;Computed $x&quot;); x) # memoize a function

julia&gt; f(2)
Computed 2
2

julia&gt; f(2)
2

julia&gt; g(x) = (println(&quot;Computed $x&quot;); x)

julia&gt; @memoize g(2) # memoize a single function call
Computed 2
2

julia&gt; @memoize g(2)
2"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> Memoization

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@memoize</span> <span class="pl-en">f</span>(x) <span class="pl-k">=</span> (<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computed <span class="pl-v">$x</span><span class="pl-pds">"</span></span>); x) <span class="pl-c"><span class="pl-c">#</span> memoize a function</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">2</span>)
Computed <span class="pl-c1">2</span>
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">2</span>)
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-en">g</span>(x) <span class="pl-k">=</span> (<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computed <span class="pl-v">$x</span><span class="pl-pds">"</span></span>); x)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@memoize</span> <span class="pl-c1">g</span>(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> memoize a single function call</span>
Computed <span class="pl-c1">2</span>
<span class="pl-c1">2</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@memoize</span> <span class="pl-c1">g</span>(<span class="pl-c1">2</span>)
<span class="pl-c1">2</span></pre></div>
<h2 dir="auto"><a id="user-content-highlights" class="anchor" aria-hidden="true" href="#highlights"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Highlights</h2>
<ul dir="auto">
<li>
<p dir="auto">You can <code>@memoize</code> a function definition, in which case every call to that function will be memoized, or you can <code>@memoize</code> a single function-call to any Julia function, in which case only that call is memoized.</p>
<p dir="auto">Note that memoized function-calls can be slightly less performant and may give incorrect results if the function is redefined, see limitations below. Functions memoized at their definition are optimally performant and will always give the right result even if some methods are redefined.</p>
</li>
<li>
<p dir="auto">All function definition or function call forms with args and/or kwargs and/or type parameters work.</p>
</li>
<li>
<p dir="auto">The function or function call remains inferrable.</p>
</li>
<li>
<p dir="auto">You can choose the cache type, e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@memoize Dict f(x) = ...
@memoize LRU(maxsize=5) f(x) = ...      # using https://github.com/JuliaCollections/LRUCache.jl"><pre><span class="pl-c1">@memoize</span> Dict <span class="pl-en">f</span>(x) <span class="pl-k">=</span> <span class="pl-k">...</span>
<span class="pl-c1">@memoize</span> <span class="pl-en">LRU</span>(maxsize<span class="pl-k">=</span><span class="pl-c1">5</span>) <span class="pl-en">f</span>(x) <span class="pl-k">=</span> <span class="pl-k">...</span>      <span class="pl-c"><span class="pl-c">#</span> using https://github.com/JuliaCollections/LRUCache.jl</span></pre></div>
<p dir="auto">The specifier should be a type which can be called without arguments to create the cache, or an expression which creates an instance of a cache (note: cache creation is delayed until the first time a function is called, so it is not possible to pass a pre-instantiated cache).</p>
<p dir="auto">The default cache type is <code>IdDict</code> which
counts arguments the same if they <code>===</code> each other. Another common choice is <code>Dict</code> which memoizes based on if they <code>==</code> each other (this is probably useful if you want to count e.g. vectors which contain the same entries as the same, but will lead to somewhat slower cache lookup).</p>
</li>
<li>
<p dir="auto">You can clear the cache for a given function at any time with <code>Memoization.empty_cache!(f)</code>.</p>
</li>
<li>
<p dir="auto">You can also clear all caches for all functions with <code>Memoization.empty_all_caches!()</code>.</p>
</li>
<li>
<p dir="auto">You can call memoized functions during precompilation. The memoized results are then stored in the precompiled module and will not be recomputed at runtime. Note, however, if memoized results are not serializable (e.g. Channels or FFT plans or you just don't want them saved), you should manually call <code>empty_cache!</code> at the end of precompilation, e.g. in the top-level of your module or at the end of your <code>SnoopPrecompile.@precompile_all_calls</code> block.</p>
</li>
</ul>
<p dir="auto">Additionally, for memoized function definitions:</p>
<ul dir="auto">
<li>
<p dir="auto">Multiple memoized methods for the same function can be defined across different modules.</p>
</li>
<li>
<p dir="auto">You can memoize some methods of a function but not others, e.g.:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; @memoize f(x) = (println(&quot;Computed $x&quot;); x)
f (generic function with 1 method)

julia&gt; f(x,y) = (println(&quot;Computed $x,$y&quot;); f(x+y))
f (generic function with 2 methods)

julia&gt; f(1,2)
Computed 1,2
Computed 3
3

julia&gt; f(1,2)
Computed 1,2
3

julia&gt; f(1,2)
Computed 1,2
3"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@memoize</span> <span class="pl-en">f</span>(x) <span class="pl-k">=</span> (<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computed <span class="pl-v">$x</span><span class="pl-pds">"</span></span>); x)
f (generic <span class="pl-k">function</span> with <span class="pl-c1">1</span> method)

julia<span class="pl-k">&gt;</span> <span class="pl-en">f</span>(x,y) <span class="pl-k">=</span> (<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computed <span class="pl-v">$x</span>,<span class="pl-v">$y</span><span class="pl-pds">"</span></span>); <span class="pl-c1">f</span>(x<span class="pl-k">+</span>y))
f (generic <span class="pl-k">function</span> with <span class="pl-c1">2</span> methods)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)
Computed <span class="pl-c1">1</span>,<span class="pl-c1">2</span>
Computed <span class="pl-c1">3</span>
<span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)
Computed <span class="pl-c1">1</span>,<span class="pl-c1">2</span>
<span class="pl-c1">3</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>)
Computed <span class="pl-c1">1</span>,<span class="pl-c1">2</span>
<span class="pl-c1">3</span></pre></div>
</li>
<li>
<p dir="auto">You can memoize individual instances of closures, e.g.:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="
julia&gt; function make_func(x)
           @memoize func(y) = (println(&quot;Computed $x,$y&quot;); (x,y))
       end;

julia&gt; f = make_func(1);

julia&gt; f(3)
Computed 1,3
(1, 3)

julia&gt; f(3)
(1, 3)

julia&gt; g = make_func(2);

julia&gt; g(3)
Computed 2,3
(2, 3)

julia&gt; g(3)
(2, 3)

julia&gt; f(3) # note both f and g memoized separately at this point
(1, 3)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">make_func</span>(x)
           <span class="pl-c1">@memoize</span> <span class="pl-en">func</span>(y) <span class="pl-k">=</span> (<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computed <span class="pl-v">$x</span>,<span class="pl-v">$y</span><span class="pl-pds">"</span></span>); (x,y))
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> f <span class="pl-k">=</span> <span class="pl-c1">make_func</span>(<span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">3</span>)
Computed <span class="pl-c1">1</span>,<span class="pl-c1">3</span>
(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">3</span>)
(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> g <span class="pl-k">=</span> <span class="pl-c1">make_func</span>(<span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">g</span>(<span class="pl-c1">3</span>)
Computed <span class="pl-c1">2</span>,<span class="pl-c1">3</span>
(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">g</span>(<span class="pl-c1">3</span>)
(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">f</span>(<span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span> note both f and g memoized separately at this point</span>
(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>)</pre></div>
</li>
<li>
<p dir="auto">You can memoize individual instances of "callables", e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; struct Foo
           x
       end

julia&gt; @memoize (f::Foo)(x) = (println(&quot;Computed $(f.x), $x&quot;); (f.x, x))

julia&gt; foo1 = Foo(1);

julia&gt; foo1(3)
Computed 1,3
(1,3)

julia&gt; foo1(3)
(1,3)

julia&gt; foo2 = Foo(2);

julia&gt; foo2(3)
Computed 2,3
(2,3)

julia&gt; foo2(3)
(2,3)

julia&gt; foo1(3) # note both foo1 and foo2 memoized separately at this point
(1,3)"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> Foo
           x
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">@memoize</span> (f<span class="pl-k">::</span><span class="pl-c1">Foo</span>)(x) <span class="pl-k">=</span> (<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Computed <span class="pl-v">$(f<span class="pl-k">.</span>x)</span>, <span class="pl-v">$x</span><span class="pl-pds">"</span></span>); (f<span class="pl-k">.</span>x, x))

julia<span class="pl-k">&gt;</span> foo1 <span class="pl-k">=</span> <span class="pl-c1">Foo</span>(<span class="pl-c1">1</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo1</span>(<span class="pl-c1">3</span>)
Computed <span class="pl-c1">1</span>,<span class="pl-c1">3</span>
(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo1</span>(<span class="pl-c1">3</span>)
(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> foo2 <span class="pl-k">=</span> <span class="pl-c1">Foo</span>(<span class="pl-c1">2</span>);

julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo2</span>(<span class="pl-c1">3</span>)
Computed <span class="pl-c1">2</span>,<span class="pl-c1">3</span>
(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo2</span>(<span class="pl-c1">3</span>)
(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">foo1</span>(<span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span> note both foo1 and foo2 memoized separately at this point</span>
(<span class="pl-c1">1</span>,<span class="pl-c1">3</span>)</pre></div>
</li>
</ul>
<h2 dir="auto"><a id="user-content-limitations" class="anchor" aria-hidden="true" href="#limitations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Limitations</h2>
<ul dir="auto">
<li>
<p dir="auto">Memoized function-calls can become out-of-date if the function is redefined, e.g.:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="f(x) = x
@memoize f(2)
f(x) = x^2
@memoize f(2) # incorrectly returns 2, not 4"><pre><span class="pl-en">f</span>(x) <span class="pl-k">=</span> x
<span class="pl-c1">@memoize</span> <span class="pl-c1">f</span>(<span class="pl-c1">2</span>)
<span class="pl-en">f</span>(x) <span class="pl-k">=</span> x<span class="pl-k">^</span><span class="pl-c1">2</span>
<span class="pl-c1">@memoize</span> <span class="pl-c1">f</span>(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> incorrectly returns 2, not 4</span></pre></div>
<p dir="auto">To fix this, manually call <code>Memoization.empty_cache!(f)</code> after redefining the function. Function memoized at their definition do not suffer from this problem.</p>
</li>
<li>
<p dir="auto">You cannot switch the cache type within the same session. E.g. you cannot do <code>@memoize Dict foo() = ...</code> and then later <code>@memoize IdDict foo() = ...</code>. You must restart your Julia session for this.</p>
</li>
<li>
<p dir="auto">This package is not thread-safe with either <code>Dict</code> or <code>IdDict</code>. However, if a thread-safe cache is used (e.g. <a href="https://github.com/wherrera10/ThreadSafeDicts.jl">ThreadSafeDicts.jl</a>), then memoizing top-level functions is thread-safe. Memoizing closures and callables is not yet thread-safe with any cache type.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-notes" class="anchor" aria-hidden="true" href="#notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Notes</h2>
<p dir="auto">This package can be used as a drop-in replacement for <a href="https://github.com/JuliaCollections/Memoize.jl">Memoize.jl</a>, and, as of this writing, has fewer limitations.</p>
<p dir="auto">The design is partly inspired by both <a href="https://github.com/JuliaCollections/Memoize.jl">Memoize.jl</a> and <a href="https://stackoverflow.com/a/52084004/1078529" rel="nofollow">this</a> Stack Overflow comment.</p>
</article></div>