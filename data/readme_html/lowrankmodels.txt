<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-lowrankmodelsjl" class="anchor" aria-hidden="true" href="#lowrankmodelsjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>LowRankModels.jl</h1>
<p dir="auto"><a href="https://travis-ci.com/madeleineudell/LowRankModels.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/ff7d5bd7e78a86097b0d2dccf97d7b9483b48f662384839c81368454cde65835/68747470733a2f2f7472617669732d63692e636f6d2f6d6164656c65696e657564656c6c2f4c6f7752616e6b4d6f64656c732e6a6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.com/madeleineudell/LowRankModels.jl.svg?branch=master" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/jiahao/lowrankmodels-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/458d45cbf09b2a5cec9cb2ca4eeb69e9a1f50f15e09b39e30f63ed932f54fed1/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6a6a6b31706f6977746e666c6336316d3f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/jjk1poiwtnflc61m?svg=true" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/jiahao/LowRankModels.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a4dffb644f6dd65aa69f6bea6df1a2c7ef7ffef69d38b2f6bf08551ebd04fd84/68747470733a2f2f636f6465636f762e696f2f67682f6a696168616f2f4c6f7752616e6b4d6f64656c732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/jiahao/LowRankModels.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto"><code>LowRankModels.jl</code> is a Julia package for modeling and fitting generalized low rank models (GLRMs).
GLRMs model a data array by a low rank matrix, and
include many well known models in data analysis, such as
principal components analysis (PCA), matrix completion, robust PCA,
nonnegative matrix factorization, k-means, and many more.</p>
<p dir="auto">For more information on GLRMs, see <a href="https://people.orie.cornell.edu/mru8/doc/udell16_glrm.pdf" rel="nofollow">our paper</a>.
There is a <a href="https://github.com/udellgroup/pyglrm">python interface</a> to this package,
and a GLRM implementation in
<a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/glrm.html" rel="nofollow">the H2O machine learning platform</a>
with interfaces in a variety of languages.</p>
<p dir="auto"><code>LowRankModels.jl</code> makes it easy to mix and match loss functions and regularizers
to construct a model suitable for a particular data set.
In particular, it supports</p>
<ul dir="auto">
<li>using different loss functions for different columns of the data array,
which is useful when data types are heterogeneous
(e.g., real, boolean, and ordinal columns);</li>
<li>fitting the model to only <em>some</em> of the entries in the table, which is useful for data tables with many missing (unobserved) entries; and</li>
<li>adding offsets and scalings to the model without destroying sparsity,
which is useful when the data is poorly scaled.</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">To install, just call</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Pkg.add(&quot;LowRankModels&quot;)"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>LowRankModels<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">at the Julia prompt.</p>
<h1 dir="auto"><a id="user-content-generalized-low-rank-models" class="anchor" aria-hidden="true" href="#generalized-low-rank-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Generalized Low Rank Models</h1>
<p dir="auto">GLRMs form a low rank model for tabular data <code>A</code> with <code>m</code> rows and <code>n</code> columns,
which can be input as an array or any array-like object (for example, a data frame).
It is fine if only some of the entries have been observed
(i.e., the others are <code>missing</code>); the GLRM will only be fit on the <code>!ismissing</code> entries.
The desired model is specified by choosing a rank <code>k</code> for the model,
an array of loss functions <code>losses</code>, and two regularizers, <code>rx</code> and <code>ry</code>.
The data is modeled as <code>X'*Y</code>, where <code>X</code> is a <code>k</code>x<code>m</code> matrix and <code>Y</code> is a <code>k</code>x<code>n</code> matrix.
<code>X</code> and <code>Y</code> are found by solving the optimization problem</p>

<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="minimize sum_{(i,j) in obs} losses[j]((X'*Y)[i,j], A[i,j]) + sum_i rx(X[:,i]) + sum_j ry(Y[:,j])"><pre class="notranslate"><code>minimize sum_{(i,j) in obs} losses[j]((X'*Y)[i,j], A[i,j]) + sum_i rx(X[:,i]) + sum_j ry(Y[:,j])
</code></pre></div>
<p dir="auto">The basic type used by LowRankModels.jl is the GLRM. To form a GLRM,
the user specifies</p>
<ul dir="auto">
<li>the data <code>A</code> (any <code>AbstractArray</code>, such as an array, a sparse matrix, or a data frame)</li>
<li>the array of loss functions <code>losses</code></li>
<li>the regularizers <code>rx</code> and <code>ry</code></li>
<li>the rank <code>k</code></li>
</ul>
<p dir="auto">The user may also specify</p>
<ul dir="auto">
<li>the observed entries <code>obs</code></li>
<li>starting matrices X₀ and Y₀</li>
</ul>
<p dir="auto"><code>obs</code> is a list of tuples of the indices of the observed entries in the matrix,
and may be omitted if all the entries in the matrix have been observed.
If <code>A</code> is a sparse matrix, implicit zeros are interpreted
as missing entries by default;
see the discussion of <a href="#fitting-sparse-matrices">sparse matrices</a> below for more details.
<code>X₀</code> and <code>Y₀</code> are initialization
matrices that represent a starting guess for the optimization.</p>
<p dir="auto">Losses and regularizers must be of type <code>Loss</code> and <code>Regularizer</code>, respectively,
and may be chosen from a list of supported losses and regularizers, which include</p>
<p dir="auto">Losses:</p>
<ul dir="auto">
<li>quadratic loss <code>QuadLoss</code></li>
<li>hinge loss <code>HingeLoss</code></li>
<li>logistic loss <code>LogisticLoss</code></li>
<li>Poisson loss <code>PoissonLoss</code></li>
<li>weighted hinge loss <code>WeightedHingeLoss</code></li>
<li>l1 loss <code>L1Loss</code></li>
<li>ordinal hinge loss <code>OrdinalHingeLoss</code></li>
<li>periodic loss <code>PeriodicLoss</code></li>
<li>multinomial categorical loss <code>MultinomialLoss</code></li>
<li>multinomial ordinal (aka ordered logit) loss <code>OrderedMultinomialLoss</code></li>
<li>bigger-vs-smaller loss <code>BvSLoss</code> (for ordinal data)</li>
<li>one-vs all-loss <code>OvALoss</code> (for categorical data)</li>
</ul>
<p dir="auto">The constructors for all the ordinal and categorical losses take as an
argument  the maximum (or both minimum and maximum) value the variable may  take.
Using the one-vs-all loss is equivalent to transforming a categorical value
to a one-hot vector and using a binary loss on each entry in that vector.
Using the bigger-vs-smaller loss is equivalent to transforming the ordinal value
to a Boolean vector and using a binary loss on each entry in that vector.
By default,  the binary loss used is the logistic loss.</p>
<p dir="auto">Regularizers:</p>
<ul dir="auto">
<li>quadratic regularization <code>QuadReg</code></li>
<li>constrained squared euclidean norm <code>QuadConstraint</code></li>
<li>l1 regularization <code>OneReg</code></li>
<li>no regularization <code>ZeroReg</code></li>
<li>nonnegative constraint <code>NonNegConstraint</code> (e.g., for nonnegative matrix factorization)</li>
<li>1-sparse constraint <code>OneSparseConstraint</code> (e.g., for orthogonal NNMF)</li>
<li>unit 1-sparse constraint <code>UnitOneSparseConstraint</code> (e.g., for k-means)</li>
<li>simplex constraint <code>SimplexConstraint</code></li>
<li>l1 regularization, combined with nonnegative constraint <code>NonNegOneReg</code></li>
<li>fix features at values <code>y0</code> <code>FixedLatentFeaturesConstraint(y0)</code></li>
</ul>
<p dir="auto">Each of these losses and regularizers can be scaled
(for example, to increase the importance of the loss relative to the regularizer)
by calling <code>mul!(loss, newscale)</code>.
Users may also implement their own losses and regularizers,
or adjust internal parameters of the losses and regularizers;
see <a href="src/losses.jl">losses.jl</a> and <a href="src/regularizers.jl">regularizers.jl</a> for more details.</p>
<h2 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<p dir="auto">For example, the following code forms a k-means model with <code>k=5</code> on the <code>100</code>x<code>100</code> matrix <code>A</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using LowRankModels
m, n, k = 100, 100, 5
losses = QuadLoss() # minimize squared distance to cluster centroids
rx = UnitOneSparseConstraint() # each row is assigned to exactly one cluster
ry = ZeroReg() # no regularization on the cluster centroids
glrm = GLRM(A, losses, rx, ry, k)"><pre><span class="pl-k">using</span> LowRankModels
m, n, k <span class="pl-k">=</span> <span class="pl-c1">100</span>, <span class="pl-c1">100</span>, <span class="pl-c1">5</span>
losses <span class="pl-k">=</span> <span class="pl-c1">QuadLoss</span>() <span class="pl-c"><span class="pl-c">#</span> minimize squared distance to cluster centroids</span>
rx <span class="pl-k">=</span> <span class="pl-c1">UnitOneSparseConstraint</span>() <span class="pl-c"><span class="pl-c">#</span> each row is assigned to exactly one cluster</span>
ry <span class="pl-k">=</span> <span class="pl-c1">ZeroReg</span>() <span class="pl-c"><span class="pl-c">#</span> no regularization on the cluster centroids</span>
glrm <span class="pl-k">=</span> <span class="pl-c1">GLRM</span>(A, losses, rx, ry, k)</pre></div>
<p dir="auto">To fit the model, call</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="X, Y, ch = fit!(glrm)"><pre>X, Y, ch <span class="pl-k">=</span> <span class="pl-c1">fit!</span>(glrm)</pre></div>
<p dir="auto">which runs an alternating directions proximal gradient method on <code>glrm</code> to find the
<code>X</code> and <code>Y</code> minimizing the objective function.
(<code>ch</code> gives the convergence history; see
<a href="#technical-details">Technical details</a>
below for more information.)</p>
<p dir="auto">The <code>losses</code> argument can also be an array of loss functions,
with one for each column (in order). For example,
for a data set with 3 columns, you could use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="losses = Loss[QuadLoss(), LogisticLoss(), HingeLoss()]"><pre>losses <span class="pl-k">=</span> Loss[<span class="pl-c1">QuadLoss</span>(), <span class="pl-c1">LogisticLoss</span>(), <span class="pl-c1">HingeLoss</span>()]</pre></div>
<p dir="auto">Similiarly, the <code>ry</code> argument can be an array of regularizers,
with one for each column (in order). For example,
for a data set with 3 columns, you could use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="ry = Regularizer[QuadReg(1), QuadReg(10), FixedLatentFeaturesConstraint([1.,2.,3.])]"><pre>ry <span class="pl-k">=</span> Regularizer[<span class="pl-c1">QuadReg</span>(<span class="pl-c1">1</span>), <span class="pl-c1">QuadReg</span>(<span class="pl-c1">10</span>), <span class="pl-c1">FixedLatentFeaturesConstraint</span>([<span class="pl-c1">1.</span>,<span class="pl-c1">2.</span>,<span class="pl-c1">3.</span>])]</pre></div>
<p dir="auto">This regularizes the first to columns of <code>Y</code> with <code>||Y[:,1]||^2 + 10||Y[:,2]||^2</code>
and constrains the third (and last) column of <code>Y</code> to be equal to <code>[1,2,3]</code>.</p>
<p dir="auto"><a href="examples/simple_glrms.jl">More examples here.</a></p>
<h1 dir="auto"><a id="user-content-missing-data" class="anchor" aria-hidden="true" href="#missing-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Missing data</h1>
<p dir="auto">If not all entries are present in your data table, just tell the GLRM
which observations to fit the model to by listing tuples of their indices in <code>obs</code>,
e.g., if <code>obs=[(1,2), (5,3)]</code>, exactly two entries have been observed.
Then initialize the model using</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="GLRM(A, losses, rx, ry, k, obs=obs)"><pre><span class="pl-c1">GLRM</span>(A, losses, rx, ry, k, obs<span class="pl-k">=</span>obs)</pre></div>
<p dir="auto">If <code>A</code> is a DataFrame and you just want the model to ignore
any entry that is <code>missing</code>, you can use</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="obs = observations(A)"><pre>obs <span class="pl-k">=</span> <span class="pl-c1">observations</span>(A)</pre></div>
<h1 dir="auto"><a id="user-content-standard-low-rank-models" class="anchor" aria-hidden="true" href="#standard-low-rank-models"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Standard low rank models</h1>
<p dir="auto">Low rank models can easily be used to fit standard models such as PCA, k-means, and nonnegative matrix factorization.
The following functions are available:</p>
<ul dir="auto">
<li><code>pca</code>: principal components analysis</li>
<li><code>qpca</code>: quadratically regularized principal components analysis</li>
<li><code>rpca</code>: robust principal components analysis</li>
<li><code>nnmf</code>: nonnegative matrix factorization</li>
<li><code>k-means</code>: k-means</li>
</ul>
<p dir="auto">See <a href="src/simple_glrms.jl">the code</a> for usage.
Any keyword argument valid for a <code>GLRM</code> object,
such as an initial value for <code>X</code> or <code>Y</code>
or a list of observations,
can also be used with these standard low rank models.</p>
<h1 dir="auto"><a id="user-content-scaling-and-offsets-" class="anchor" aria-hidden="true" href="#scaling-and-offsets-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Scaling and offsets <a name="user-content-scaling"></a></h1>
<p dir="auto">If you choose, LowRankModels.jl can add an offset to your model and scale the loss
functions and regularizers so all columns have the same pull in the model.
Simply call</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="glrm = GLRM(A, losses, rx, ry, k, offset=true, scale=true)"><pre>glrm <span class="pl-k">=</span> <span class="pl-c1">GLRM</span>(A, losses, rx, ry, k, offset<span class="pl-k">=</span><span class="pl-c1">true</span>, scale<span class="pl-k">=</span><span class="pl-c1">true</span>)</pre></div>
<p dir="auto">This transformation generalizes standardization, a common preprocessing technique applied before PCA.
(For more about offsets and scaling, see the code or the paper.)</p>
<p dir="auto">You can also add offsets and scalings to previously unscaled models:</p>
<ul dir="auto">
<li>Add an offset to the model (by applying no regularization to the last row
of the matrix <code>Y</code>, and enforcing that the last column of <code>X</code> be all 1s) using</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="add_offset!(glrm)"><pre><span class="pl-c1">add_offset!</span>(glrm)</pre></div>
<ul dir="auto">
<li>Scale the loss functions and regularizers by calling</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="equilibrate_variance!(glrm)"><pre><span class="pl-c1">equilibrate_variance!</span>(glrm)</pre></div>
<ul dir="auto">
<li>Scale only the columns associated to <code>QuadLoss</code> or <code>HuberLoss</code> loss functions.</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="prob_scale!(glrm)"><pre><span class="pl-c1">prob_scale!</span>(glrm)</pre></div>
<h1 dir="auto"><a id="user-content-fitting-dataframes" class="anchor" aria-hidden="true" href="#fitting-dataframes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Fitting DataFrames</h1>
<p dir="auto">Perhaps all this sounds like too much work. Perhaps you happen to have a
<a href="https://github.com/JuliaStats/DataFrames.jl">DataFrame</a> <code>df</code> lying around
that you'd like a low rank (e.g., <code>k=2</code>) model for. For example,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import RDatasets
df = RDatasets.dataset(&quot;psych&quot;, &quot;msq&quot;)"><pre><span class="pl-k">import</span> RDatasets
df <span class="pl-k">=</span> RDatasets<span class="pl-k">.</span><span class="pl-c1">dataset</span>(<span class="pl-s"><span class="pl-pds">"</span>psych<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>msq<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">Never fear! Just call</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="glrm, labels = GLRM(df, k)
X, Y, ch = fit!(glrm)"><pre>glrm, labels <span class="pl-k">=</span> <span class="pl-c1">GLRM</span>(df, k)
X, Y, ch <span class="pl-k">=</span> <span class="pl-c1">fit!</span>(glrm)</pre></div>
<p dir="auto">This will fit a GLRM with rank <code>k</code> to your data,
using a QuadLoss loss for real valued columns,
HingeLoss loss for boolean columns,
and ordinal HingeLoss loss for integer columns,
a small amount of QuadLoss regularization,
and scaling and adding an offset to the model as described <a href="#scaling">here</a>.
It returns the column labels for the columns it fit, along with the model.
Right now, all other data types are ignored.
<code>NaN</code> values are treated as missing values (<code>missing</code>s) and ignored in the fit.</p>
<p dir="auto">The full call signature is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function GLRM(df::DataFrame, k::Int;
              losses = Loss[], rx = QuadReg(.01), ry = QuadReg(.01),
              offset = true, scale = false,
              prob_scale = true, NaNs_to_NAs = true)"><pre><span class="pl-k">function</span> <span class="pl-en">GLRM</span>(df<span class="pl-k">::</span><span class="pl-c1">DataFrame</span>, k<span class="pl-k">::</span><span class="pl-c1">Int</span>;
              losses <span class="pl-k">=</span> Loss[], rx <span class="pl-k">=</span> <span class="pl-c1">QuadReg</span>(.<span class="pl-c1">01</span>), ry <span class="pl-k">=</span> <span class="pl-c1">QuadReg</span>(.<span class="pl-c1">01</span>),
              offset <span class="pl-k">=</span> <span class="pl-c1">true</span>, scale <span class="pl-k">=</span> <span class="pl-c1">false</span>,
              prob_scale <span class="pl-k">=</span> <span class="pl-c1">true</span>, NaNs_to_NAs <span class="pl-k">=</span> <span class="pl-c1">true</span>)</pre></div>
<p dir="auto">You can modify the losses or regularizers, or turn off offsets or scaling,
using these keyword arguments.</p>
<p dir="auto">Or to specify a map from data types to losses, define a new <code>loss_map</code> from datatypes to losses (like probabilistic_losses, below):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="probabilistic_losses = Dict{Symbol, Any}(
    :real        =&gt; QuadLoss,
    :bool        =&gt; LogisticLoss,
    :ord         =&gt; MultinomialOrdinalLoss,
    :cat         =&gt; MultinomialLoss
)"><pre>probabilistic_losses <span class="pl-k">=</span> <span class="pl-c1">Dict</span><span class="pl-c1">{Symbol, Any}</span>(
    <span class="pl-c1">:real</span>        <span class="pl-k">=&gt;</span> QuadLoss,
    <span class="pl-c1">:bool</span>        <span class="pl-k">=&gt;</span> LogisticLoss,
    <span class="pl-c1">:ord</span>         <span class="pl-k">=&gt;</span> MultinomialOrdinalLoss,
    <span class="pl-c1">:cat</span>         <span class="pl-k">=&gt;</span> MultinomialLoss
)</pre></div>
<p dir="auto">and input an array of datatypes (one for each column of your data frame: <code>GLRM(A, k, datatypes; loss_map = loss_map)</code>. The full call signature is</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function GLRM(df::DataFrame, k::Int, datatypes::Array{Symbol,1};
              loss_map = probabilistic_losses,
              rx = QuadReg(.01), ry = QuadReg(.01),
              offset = true, scale = false, prob_scale = true,
              transform_data_to_numbers = true, NaNs_to_NAs = true)"><pre><span class="pl-k">function</span> <span class="pl-en">GLRM</span>(df<span class="pl-k">::</span><span class="pl-c1">DataFrame</span>, k<span class="pl-k">::</span><span class="pl-c1">Int</span>, datatypes<span class="pl-k">::</span><span class="pl-c1">Array{Symbol,1}</span>;
              loss_map <span class="pl-k">=</span> probabilistic_losses,
              rx <span class="pl-k">=</span> <span class="pl-c1">QuadReg</span>(.<span class="pl-c1">01</span>), ry <span class="pl-k">=</span> <span class="pl-c1">QuadReg</span>(.<span class="pl-c1">01</span>),
              offset <span class="pl-k">=</span> <span class="pl-c1">true</span>, scale <span class="pl-k">=</span> <span class="pl-c1">false</span>, prob_scale <span class="pl-k">=</span> <span class="pl-c1">true</span>,
              transform_data_to_numbers <span class="pl-k">=</span> <span class="pl-c1">true</span>, NaNs_to_NAs <span class="pl-k">=</span> <span class="pl-c1">true</span>)</pre></div>
<p dir="auto">You can modify the losses or regularizers, or turn off offsets or scaling,
using these keyword arguments.</p>
<p dir="auto">To fit a data frame with categorical values, you can use the function
<code>expand_categoricals!</code> to turn categorical columns into a Boolean column for each
level of the categorical variable.
For example, <code>expand_categoricals!(df, [:gender])</code> will replace the gender
column with a column corresponding to <code>gender=male</code>,
a column corresponding to <code>gender=female</code>, and other columns corresponding to
labels outside the gender binary, if they appear in the data set.</p>
<p dir="auto">You can use the model to get some intuition for the data set. For example,
try plotting the columns of <code>Y</code> with the labels; you might see
that similar features are close to each other!</p>
<h1 dir="auto"><a id="user-content-fitting-sparse-matrices" class="anchor" aria-hidden="true" href="#fitting-sparse-matrices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Fitting Sparse Matrices</h1>
<p dir="auto">If you have a very large, sparsely observed dataset, then you may want to
encode your data as a
<a href="http://julia-demo.readthedocs.org/en/latest/stdlib/sparse.html" rel="nofollow">sparse matrix</a>.
By default, <code>LowRankModels</code> interprets the sparse entries of a sparse
matrix as missing entries (i.e. <code>NA</code> values). There is no need to
pass the indices of observed entries (<code>obs</code>) -- this is done
automatically when <code>GLRM(A::SparseMatrixCSC,...)</code> is called.
In addition, calling <code>fit!(glrm)</code> when <code>glrm.A</code> is a sparse matrix
will use the sparse variant of the proximal gradient descent algorithm,
<code>fit!(glrm, SparseProxGradParams(); kwargs...)</code>.</p>
<p dir="auto">If, instead, you'd like to interpret the sparse entries as zeros, rather
than missing or <code>NA</code> entries, use:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="glrm = GLRM(...; sparse_na=false)"><pre>glrm <span class="pl-k">=</span> <span class="pl-c1">GLRM</span>(<span class="pl-k">...</span>; sparse_na<span class="pl-k">=</span><span class="pl-c1">false</span>)</pre></div>
<p dir="auto">In this case, the dataset is dense in terms of observations, but sparse
in terms of nonzero values. Thus, it may make more sense to fit the
model with the vanilla proximal gradient descent algorithm,
<code>fit!(glrm, ProxGradParams(); kwargs...)</code>.</p>
<h1 dir="auto"><a id="user-content-parallel-fitting-experimental" class="anchor" aria-hidden="true" href="#parallel-fitting-experimental"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Parallel fitting (experimental)</h1>
<p dir="auto">LowRankModels makes use of Julia v0.5's new multithreading functionality
to fit models in parallel.
To fit a LowRankModel in parallel using multithreading,
simply set the number of threads
from the command line before starting Julia: e.g.,</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="export JULIA_NUM_THREADS=4"><pre><span class="pl-k">export</span> JULIA_NUM_THREADS=4</pre></div>
<h1 dir="auto"><a id="user-content-technical-details" class="anchor" aria-hidden="true" href="#technical-details"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Technical details</h1>
<h2 dir="auto"><a id="user-content-optimization" class="anchor" aria-hidden="true" href="#optimization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Optimization</h2>
<p dir="auto">The function <code>fit!</code> uses an alternating directions proximal gradient method
to minimize the objective. This method is <em>not</em> guaranteed to converge to
the optimum, or even to a local minimum. If your code is not converging
or is converging to a model you dislike, there are a number of parameters you can tweak.</p>
<h3 dir="auto"><a id="user-content-warm-start" class="anchor" aria-hidden="true" href="#warm-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Warm start</h3>
<p dir="auto">The algorithm starts with <code>glrm.X</code> and <code>glrm.Y</code> as the initial estimates
for <code>X</code> and <code>Y</code>. If these are not given explicitly, they will be initialized randomly.
If you have a good guess for a model, try setting them explicitly.
If you think that you're getting stuck in a local minimum, try reinitializing your
GLRM (so as to construct a new initial random point) and see if the model you obtain improves.</p>
<p dir="auto">The function <code>fit!</code> sets the fields <code>glrm.X</code> and <code>glrm.Y</code>
after fitting the model. This is particularly useful if you want to use
the model you generate as a warm start for further iterations.
If you prefer to preserve the original <code>glrm.X</code> and <code>glrm.Y</code> (e.g., for cross validation),
you should call the function <code>fit</code>, which does not mutate its arguments.</p>
<p dir="auto">You can even start with an easy-to-optimize loss function, run <code>fit!</code>,
change the loss function (<code>glrm.losses = newlosses</code>),
and keep going from your warm start by calling <code>fit!</code> again to fit
the new loss functions.</p>
<h3 dir="auto"><a id="user-content-initialization" class="anchor" aria-hidden="true" href="#initialization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Initialization</h3>
<p dir="auto">If you don't have a good guess at a warm start for your model, you might try
one of the initializations provided in <code>LowRankModels</code>.</p>
<ul dir="auto">
<li><code>init_svd!</code> initializes the model as the truncated SVD of the matrix of observed entries, with unobserved entries filled in with zeros. This initialization is known to result in provably good solutions for a number of "PCA-like" problems. See <a href="https://people.orie.cornell.edu/mru8/doc/udell16_glrm.pdf" rel="nofollow">our paper</a> for details.</li>
<li><code>init_kmeanspp!</code> initializes the model using a modification of the <a href="https://en.wikipedia.org/wiki/K-means_clustering" rel="nofollow">kmeans++</a> algorithm for data sets with missing entries; see <a href="https://people.orie.cornell.edu/mru8/doc/udell16_glrm.pdf" rel="nofollow">our paper</a> for details. This works well for fitting clustering models, and may help in achieving better fits for nonnegative matrix factorization problems as well.</li>
<li><code>init_nndsvd!</code> initializes the model using a modification of the <a href="https://github.com/JuliaStats/NMF.jl/blob/master/src/initialization.jl#L18">NNDSVD</a> algorithm as implemented by the <a href="https://github.com/JuliaStats/NMF.jl">NMF</a> package. This modification handles data sets with missing entries by replacing missing entries with zeros. Optionally, by setting the argument <code>max_iters=n</code> with <code>n&gt;0</code>, it will iteratively replace missing entries by their values as imputed by the NNDSVD, and call NNDSVD again on the new matrix. (This procedure is similar to the <a href="http://dl.acm.org/citation.cfm?id=1859931" rel="nofollow">soft impute</a> method of Mazumder, Hastie and Tibshirani for matrix completion.)</li>
</ul>
<h3 dir="auto"><a id="user-content-parameters" class="anchor" aria-hidden="true" href="#parameters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Parameters</h3>
<p dir="auto">As mentioned earlier, <code>LowRankModels</code> uses alternating proximal
gradient descent to derive estimates of <code>X</code> and <code>Y</code>. This can be done
by two slightly different procedures: (A) compute the full
reconstruction, <code>X' * Y</code>, to compute the gradient and objective function;
(B) only compute the model estimate for entries of <code>A</code> that are observed.
The first method is likely preferred when there are few missing entries
for <code>A</code> because of hardware level optimizations
(e.g. chunking the operations so they just fit in various caches). The
second method is likely preferred when there are many missing entries of
<code>A</code>.</p>
<p dir="auto">To fit with the first (dense) method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="fit!(glrm, ProxGradParams(); kwargs...)"><pre><span class="pl-c1">fit!</span>(glrm, <span class="pl-c1">ProxGradParams</span>(); kwargs<span class="pl-k">...</span>)</pre></div>
<p dir="auto">To fit with the second (sparse) method:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="fit!(glrm, SparseProxGradParams(); kwargs...)"><pre><span class="pl-c1">fit!</span>(glrm, <span class="pl-c1">SparseProxGradParams</span>(); kwargs<span class="pl-k">...</span>)</pre></div>
<p dir="auto">The first method is used by default if <code>glrm.A</code> is a standard
matrix/array. The second method is used by default if <code>glrm.A</code> is a
<code>SparseMatrixCSC</code>.</p>
<p dir="auto"><code>ProxGradParams()</code> and <code>SparseProxGradParams()</code> run these respective
methods with the default parameters:</p>
<ul dir="auto">
<li><code>stepsize</code>: The step size controls the speed of convergence.
Small step sizes will slow convergence, while large ones will cause
divergence. <code>stepsize</code> should be of order 1.</li>
<li><code>abs_tol</code>: The algorithm stops when the decrease in the
objective per iteration is less than <code>abs_tol*length(obs)</code>.</li>
<li><code>rel_tol</code>: The algorithm stops when the decrease in the
objective per iteration is less than <code>rel_tol</code>.</li>
<li><code>max_iter</code>: The algorithm also stops if maximum number of rounds
<code>max_iter</code> has been reached.</li>
<li><code>min_stepsize</code>: The algorithm also stops if <code>stepsize</code> decreases below
this limit.</li>
<li><code>inner_iter</code>: specifies how many proximal gradient steps to take on <code>X</code>
before moving on to <code>Y</code> (and vice versa).</li>
</ul>
<p dir="auto">The default parameters are: <code>ProxGradParams(stepsize=1.0;max_iter=100,inner_iter=1,abs_tol=0.00001,rel_tol=0.0001,min_stepsize=0.01*stepsize)</code></p>
<h3 dir="auto"><a id="user-content-convergence" class="anchor" aria-hidden="true" href="#convergence"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Convergence</h3>
<p dir="auto"><code>ch</code> gives the convergence history so that the success of the optimization can be monitored;
<code>ch.objective</code> stores the objective values, and <code>ch.times</code> captures the times these objective values were achieved.
Try plotting this to see if you just need to increase <code>max_iter</code> to converge to a better model.</p>
<h1 dir="auto"><a id="user-content-imputation" class="anchor" aria-hidden="true" href="#imputation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Imputation</h1>
<p dir="auto">After fitting a GLRM, you can use it to impute values of <code>A</code> in
four different ways:</p>
<ul dir="auto">
<li><code>impute(glrm)</code> gives the maximum likelihood estimates for each entry</li>
<li><code>impute_missing(glrm)</code> imputes missing entries and leaves observed entries unchanged</li>
<li><code>sample(glrm)</code> gives a draw from the posterior distribution, conditioned on the fit values of <code>X</code> and <code>Y</code>, for each entry</li>
<li><code>sample_missing(glrm)</code> samples missing entries and leaves observed entries unchanged</li>
</ul>
<h1 dir="auto"><a id="user-content-cross-validation" class="anchor" aria-hidden="true" href="#cross-validation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Cross validation</h1>
<p dir="auto">A number of useful functions are available to help you check whether a given low rank model overfits to the test data set.
These functions should help you choose adequate regularization for your model.</p>
<h2 dir="auto"><a id="user-content-cross-validation-1" class="anchor" aria-hidden="true" href="#cross-validation-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Cross validation</h2>
<ul dir="auto">
<li>
<p dir="auto"><code>cross_validate(glrm::GLRM, nfolds=5, params=Params(); verbose=false, use_folds=None, error_fn=objective, init=None)</code>: performs n-fold cross validation and returns average loss among all folds. More specifically, splits observations in <code>glrm</code> into <code>nfolds</code> groups, and builds new GLRMs, each with one group of observations left out. Fits each GLRM to the training set (the observations revealed to each GLRM) and returns the average loss on the test sets (the observations left out of each GLRM).</p>
<p dir="auto"><strong>Optional arguments:</strong></p>
<ul dir="auto">
<li><code>use_folds</code>: build <code>use_folds</code> new GLRMs instead of <code>n_folds</code> new GLRMs, each with <code>1/nfolds</code> of the entries left out. (<code>use_folds</code> defaults to <code>nfolds</code>.)</li>
<li><code>error_fn</code>: use a custom error function to evaluate the fit, rather than the objective. For example, one might use the imputation error by setting <code>error_fn = error_metric</code>.</li>
<li><code>init</code>: initialize the fit using a particular procedure. For example, consider <code>init=init_svd!</code>. See <a href="#initialization">Initialization</a> for more options.</li>
</ul>
</li>
<li>
<p dir="auto"><code>cv_by_iter(glrm::GLRM, holdout_proportion=.1, params=Params(1,1,.01,.01), niters=30; verbose=true)</code>: computes the test error and train error of the GLRM as it is trained. Splits the observations into a training set (<code>1-holdout_proportion</code> of the original observations) and a test set (<code>holdout_proportion</code> of the original observations). Performs <code>params.maxiter</code> iterations of the fitting algorithm on the training set <code>niters</code> times, and returns the test and train error as a function of iteration.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-regularization-paths" class="anchor" aria-hidden="true" href="#regularization-paths"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Regularization paths</h2>
<ul dir="auto">
<li><code>regularization_path(glrm::GLRM; params=Params(), reg_params=exp10.(range(2,stop=-2,length=5)), holdout_proportion=.1, verbose=true, ch::ConvergenceHistory=ConvergenceHistory("reg_path"))</code>: computes the train and test error for GLRMs varying the scaling of the regularization through any scaling factor in the array <code>reg_params</code>.</li>
</ul>
<h2 dir="auto"><a id="user-content-utilities" class="anchor" aria-hidden="true" href="#utilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Utilities</h2>
<ul dir="auto">
<li><code>get_train_and_test(obs, m, n, holdout_proportion=.1)</code>: splits observations <code>obs</code> into a train and test set. <code>m</code> and <code>n</code> must be at least as large as the maximal value of the first or second elements of the tuples in <code>observations</code>, respectively. Returns <code>observed_features</code> and <code>observed_examples</code> for both train and test sets.</li>
</ul>
<h2 dir="auto"><a id="user-content-scikitlearn" class="anchor" aria-hidden="true" href="#scikitlearn"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ScikitLearn</h2>
<p dir="auto">This library implements the
<a href="https://github.com/cstjean/ScikitLearn.jl">ScikitLearn.jl</a> interface. These
models are available: <code>SkGLRM, PCA, QPCA, NNMF, KMeans, RPCA</code>. See their
docstrings for more information (e.g. <code>?QPCA</code>). All models support the
<code>ScikitLearnBase.fit!</code> and <code>ScikitLearnBase.transform</code> interface. Examples:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="## Apply PCA to the iris dataset
using LowRankModels
import ScikitLearnBase
using RDatasets    # may require Pkg.add(&quot;RDatasets&quot;)

A = convert(Matrix, dataset(&quot;datasets&quot;, &quot;iris&quot;)[[:SepalLength, :SepalWidth, :PetalLength, :PetalWidth]])
ScikitLearnBase.fit_transform!(PCA(k=3, max_iter=500), A)"><pre><span class="pl-c"><span class="pl-c">#</span># Apply PCA to the iris dataset</span>
<span class="pl-k">using</span> LowRankModels
<span class="pl-k">import</span> ScikitLearnBase
<span class="pl-k">using</span> RDatasets    <span class="pl-c"><span class="pl-c">#</span> may require Pkg.add("RDatasets")</span>

A <span class="pl-k">=</span> <span class="pl-c1">convert</span>(Matrix, <span class="pl-c1">dataset</span>(<span class="pl-s"><span class="pl-pds">"</span>datasets<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>iris<span class="pl-pds">"</span></span>)[[<span class="pl-c1">:SepalLength</span>, <span class="pl-c1">:SepalWidth</span>, <span class="pl-c1">:PetalLength</span>, <span class="pl-c1">:PetalWidth</span>]])
ScikitLearnBase<span class="pl-k">.</span><span class="pl-c1">fit_transform!</span>(<span class="pl-c1">PCA</span>(k<span class="pl-k">=</span><span class="pl-c1">3</span>, max_iter<span class="pl-k">=</span><span class="pl-c1">500</span>), A)</pre></div>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="## Fit K-Means to a fake dataset of two Gaussians
using LowRankModels
import ScikitLearnBase

# Generate two disjoint Gaussians with 100 and 50 points
gaussian1 = randn(100, 2) + 5
gaussian2 = randn(50, 2) - 10
# Merge them into a single dataset
A = vcat(gaussian1, gaussian2)

model = ScikitLearnBase.fit!(LowRankModels.KMeans(), A)
# Count how many points are assigned to each Gaussians (should be 100 and 50)
Set(sum(ScikitLearnBase.transform(model, A), 1))"><pre><span class="pl-c"><span class="pl-c">#</span># Fit K-Means to a fake dataset of two Gaussians</span>
<span class="pl-k">using</span> LowRankModels
<span class="pl-k">import</span> ScikitLearnBase

<span class="pl-c"><span class="pl-c">#</span> Generate two disjoint Gaussians with 100 and 50 points</span>
gaussian1 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">100</span>, <span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">5</span>
gaussian2 <span class="pl-k">=</span> <span class="pl-c1">randn</span>(<span class="pl-c1">50</span>, <span class="pl-c1">2</span>) <span class="pl-k">-</span> <span class="pl-c1">10</span>
<span class="pl-c"><span class="pl-c">#</span> Merge them into a single dataset</span>
A <span class="pl-k">=</span> <span class="pl-c1">vcat</span>(gaussian1, gaussian2)

model <span class="pl-k">=</span> ScikitLearnBase<span class="pl-k">.</span><span class="pl-c1">fit!</span>(LowRankModels<span class="pl-k">.</span><span class="pl-c1">KMeans</span>(), A)
<span class="pl-c"><span class="pl-c">#</span> Count how many points are assigned to each Gaussians (should be 100 and 50)</span>
<span class="pl-c1">Set</span>(<span class="pl-c1">sum</span>(ScikitLearnBase<span class="pl-k">.</span><span class="pl-c1">transform</span>(model, A), <span class="pl-c1">1</span>))</pre></div>
<p dir="auto">See also <a href="https://github.com/cstjean/ScikitLearn.jl/blob/master/examples/Plot_Kmeans_Digits_Julia.ipynb">this notebook demonstrating K-Means</a>.</p>
<p dir="auto">These models can be used inside a <a href="http://scikitlearnjl.readthedocs.io/en/latest/pipelines/" rel="nofollow">ScikitLearn pipeline</a>, and every hyperparameter can be <a href="http://scikitlearnjl.readthedocs.io/en/latest/model_selection/" rel="nofollow">tuned with GridSearchCV</a>.</p>
<h1 dir="auto"><a id="user-content-citing-this-package" class="anchor" aria-hidden="true" href="#citing-this-package"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citing this package</h1>
<p dir="auto">If you use LowRankModels for published work,
we encourage you to cite the software.</p>
<p dir="auto">Use the following BibTeX citation:</p>
<div class="highlight highlight-text-bibtex notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@article{glrm,
    title = {Generalized Low Rank Models},
    author ={Madeleine Udell and Horn, Corinne and Zadeh, Reza and Boyd, Stephen},
    doi = {10.1561/2200000055},
    year = {2016},
    archivePrefix = &quot;arXiv&quot;,
    eprint = {1410.0342},
    primaryClass = &quot;stat-ml&quot;,
    journal = {Foundations and Trends in Machine Learning},
    number = {1},
    volume = {9},
    issn = {1935-8237},
    url = {http://dx.doi.org/10.1561/2200000055},
}"><pre><span class="pl-k">@article</span>{<span class="pl-en">glrm</span>,
    <span class="pl-s">title</span> = <span class="pl-s"><span class="pl-pds">{</span>Generalized Low Rank Models<span class="pl-pds">}</span></span>,
    <span class="pl-s">author</span> =<span class="pl-s"><span class="pl-pds">{</span>Madeleine Udell and Horn, Corinne and Zadeh, Reza and Boyd, Stephen<span class="pl-pds">}</span></span>,
    <span class="pl-s">doi</span> = <span class="pl-s"><span class="pl-pds">{</span>10.1561/2200000055<span class="pl-pds">}</span></span>,
    <span class="pl-s">year</span> = <span class="pl-s"><span class="pl-pds">{</span>2016<span class="pl-pds">}</span></span>,
    <span class="pl-s">archivePrefix</span> = <span class="pl-s"><span class="pl-pds">"</span>arXiv<span class="pl-pds">"</span></span>,
    <span class="pl-s">eprint</span> = <span class="pl-s"><span class="pl-pds">{</span>1410.0342<span class="pl-pds">}</span></span>,
    <span class="pl-s">primaryClass</span> = <span class="pl-s"><span class="pl-pds">"</span>stat-ml<span class="pl-pds">"</span></span>,
    <span class="pl-s">journal</span> = <span class="pl-s"><span class="pl-pds">{</span>Foundations and Trends in Machine Learning<span class="pl-pds">}</span></span>,
    <span class="pl-s">number</span> = <span class="pl-s"><span class="pl-pds">{</span>1<span class="pl-pds">}</span></span>,
    <span class="pl-s">volume</span> = <span class="pl-s"><span class="pl-pds">{</span>9<span class="pl-pds">}</span></span>,
    <span class="pl-s">issn</span> = <span class="pl-s"><span class="pl-pds">{</span>1935-8237<span class="pl-pds">}</span></span>,
    <span class="pl-s">url</span> = <span class="pl-s"><span class="pl-pds">{</span>http://dx.doi.org/10.1561/2200000055<span class="pl-pds">}</span></span>,
}</pre></div>
</article></div>