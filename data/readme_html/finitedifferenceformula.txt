<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-finitedifferenceformula" class="anchor" aria-hidden="true" href="#finitedifferenceformula"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>FiniteDifferenceFormula</h1>
<p dir="auto">This Julia package, also ported to Python, <a href="https://github.com/fdformula/FiniteDifferenceFormula.py">https://github.com/fdformula/FiniteDifferenceFormula.py</a>, provides a general
finite difference formula generator and a tool kit for teaching/learning the finite difference method. It generates finite
difference formulas for derivatives of various orders by using Taylor series expansions of a function at evenly spaced
points. It also gives the truncation error of a formula in the big-O notation. We can use it to generate new formulas
in addition to verification of known ones. By changing decimal places, we can also see how rounding errors may affect
a result.</p>
<p dir="auto">Beware, though formulas are mathematically correct, they may not be numerically useful.
This is true especially when we derive formulas for a derivative of higher order. For
example, run compute(9,-5:5), provided by this package, to generate a 10-point
central formula for the 9-th derivative. The formula is mathematically correct, but it
can hardly be put into use for numerical computing without, if possible, rewriting it
in a special way. Similarly, the more points are used, the more precise a formula
is mathematically. However, due to rounding errors, this may not be true numerically.</p>
<p dir="auto">To run the code, you need the Julia programming language (<a href="https://julialang.org/" rel="nofollow">https://julialang.org/</a>).</p>
<h2 dir="auto"><a id="user-content-how-to-install-the-package" class="anchor" aria-hidden="true" href="#how-to-install-the-package"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How to install the package</h2>
<p dir="auto">In Julia REPL, execute the following two commands in order.</p>
<ol dir="auto">
<li>import Pkg</li>
<li>Pkg.add("FiniteDifferenceFormula")</li>
</ol>
<h2 dir="auto"><a id="user-content-the-package-exports-the-following-functions" class="anchor" aria-hidden="true" href="#the-package-exports-the-following-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The package exports the following functions</h2>
<p dir="auto"><code>activatejuliafunction</code>, <code>compute</code>, <code>decimalplaces</code>, <code>find</code>, <code>findbackward</code>,
<code>findforward</code>, <code>formula</code>, <code>formulas</code>, <code>loadcomputingresults</code>, <code>taylor</code>,
<code>taylorcoefs</code>, <code>tcoefs</code>, <code>truncationerror</code>, <code>verifyformula</code></p>
<h3 dir="auto"><a id="user-content-functions-compute-find-findforward-and-findbackward" class="anchor" aria-hidden="true" href="#functions-compute-find-findforward-and-findbackward"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>functions, <code>compute</code>, <code>find</code>, <code>findforward</code>, and <code>findbackward</code></h3>
<p dir="auto">All take the same arguments (n, points, printformulaq = false).</p>
<h4 dir="auto"><a id="user-content-input" class="anchor" aria-hidden="true" href="#input"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Input</h4>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="            n: the n-th order derivative to be found
       points: in the format of a range, start : stop, or a vector
printformulaq: print the computed formula or not"><pre class="notranslate"><code>            n: the n-th order derivative to be found
       points: in the format of a range, start : stop, or a vector
printformulaq: print the computed formula or not
</code></pre></div>
<table>
<thead>
<tr>
<th>points</th>
<th>The points/nodes to be used</th>
</tr>
</thead>
<tbody>
<tr>
<td>-3:2</td>
<td>x[i-3], x[i-2], x[i-1], x[i], x[i+1], x[i+2]</td>
</tr>
<tr>
<td>[1 0 1 -1]</td>
<td>x[i-1], x[i], x[i+1]</td>
</tr>
</tbody>
</table>
<p dir="auto">A vector can be like [1, 0, 2] or [1 0 2]. It will be rearranged so that elements are ordered
from lowest to highest with duplicate ones removed.</p>
<h4 dir="auto"><a id="user-content-output" class="anchor" aria-hidden="true" href="#output"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Output</h4>
<p dir="auto">Each function returns a tuple, (n, points, k[:], m), where n, points, k[:] and m are described below.
With the information, you may generate functions for any programming language of your choice.</p>
<p dir="auto">While 'compute' may fail to find a formula using the points, others try to find one, if possible,
by using fewer points in different ways. (See the docstring of each function by, say,
<code>?fd.find</code> after <code>import FiniteDifferenceFormula as fd</code>, in Julia REPL.)</p>
<p dir="auto">The algorithm uses the linear combination of f(x[i+j]) = f(x[i] + jh), where h is the increment
in x and j ∈ points, to eliminate f(x[i]), f'(x[i]), f''(x[i]), ..., so that the first nonzero
term of the Taylor series of the linear combination is f^(n)(x[i]):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="k[1]*f(x[i+points[1]]) + k[2]*f(x[i+points[2]]) + ... + k[len]*f(x[i+points[len]]) = m*f^(n)(x[i]) + ..., m &gt; 0"><pre>k[<span class="pl-c1">1</span>]<span class="pl-k">*</span><span class="pl-en">f</span>(x[i<span class="pl-k">+</span>points[<span class="pl-c1">1</span>]]) <span class="pl-k">+</span> k[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-en">f</span>(x[i<span class="pl-k">+</span>points[<span class="pl-c1">2</span>]]) <span class="pl-k">+</span> <span class="pl-k">...</span> <span class="pl-k">+</span> k[len]<span class="pl-k">*</span><span class="pl-en">f</span>(x[i<span class="pl-k">+</span>points[len]]) <span class="pl-k">=</span> m<span class="pl-k">*</span>f<span class="pl-k">^</span>(n)(x[i]) <span class="pl-k">+</span> <span class="pl-k">...</span>, m <span class="pl-k">&gt;</span> <span class="pl-c1">0</span></pre></div>
<p dir="auto">where len = length(points). It is this equation that gives the formula for computing f^(n)(x[i])
and the truncation error in the big-O notation as well.</p>
<h3 dir="auto"><a id="user-content-function-loadcomputingresultsresults" class="anchor" aria-hidden="true" href="#function-loadcomputingresultsresults"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>loadcomputingresults</code>(results)</h3>
<p dir="auto">The function loads results, a tuple of the form (n, points, k, m), returned by <code>compute</code>.
For example, it may take hours to compute/find formulas invloving hundreds of points. In this
case, we can save the results in a text file and come back later to work on the results
with <code>activatejuliafunction</code>, <code>formula</code>, <code>truncationerror</code>, and so on.</p>
<h3 dir="auto"><a id="user-content-function-formula" class="anchor" aria-hidden="true" href="#function-formula"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>formula</code>()</h3>
<p dir="auto">The function generates and lists</p>
<ol dir="auto">
<li>
<p dir="auto">k[1]*f(x[i+points[1]]) + k[2]*f(x[i+points[2]]) + ... + k[len]*f(x[i+points[len]])
= m*f^(n)(x[i]) + ..., m &gt; 0</p>
</li>
<li>
<p dir="auto">The formula for f^(n)(x[i]), including estimation of accuracy in the big-O notation.</p>
</li>
<li>
<p dir="auto">Julia function(s) for f^(n)(x[i]).</p>
</li>
</ol>
<h3 dir="auto"><a id="user-content-function-truncationerror" class="anchor" aria-hidden="true" href="#function-truncationerror"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>truncationerror</code>()</h3>
<p dir="auto">The function returns a tuple, (n, "O(h^n)"), the truncation error of the newly computed finite
difference formula in the big-O notation.</p>
<h3 dir="auto"><a id="user-content-function-decimalplaces-or-decimalplacesn" class="anchor" aria-hidden="true" href="#function-decimalplaces-or-decimalplacesn"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>decimalplaces</code>() or <code>decimalplaces</code>(n)</h3>
<p dir="auto">Without an argument, the function returns current decimal places. With argument n, it sets the
decimal places to be n for generating Julia function(s) for formulas if n is a nonnegative
integer. It returns the (new) default decimal places. Without/before calling the function, 16
decimal places are used by default.</p>
<p dir="auto">This function can only affect Julia functions with the suffix "d" such as fd1stderiv2ptcentrald.
See function activatejuliafunction().</p>
<h3 dir="auto"><a id="user-content-function-activatejuliafunction" class="anchor" aria-hidden="true" href="#function-activatejuliafunction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>activatejuliafunction</code>()</h3>
<p dir="auto">Call this function to activate the Julia function(s) for the newly computed finite
difference formula. For example, after compute(1, -1:1) and decimalplaces(4), it activates the
following Julia functions.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="fd1stderiv2ptcentrale(f, x, i, h)  = ( -f(x[i-1]) + f(x[i+1]) ) / (2 * h)
fd1stderiv2ptcentrale1(f, x, i, h) = ( -1/2 * f(x[i-1]) + 1/2 * f(x[i+1]) ) / h
fd1stderiv2ptcentrald(f, x, i, h)  = ( -0.5000 * f(x[i-1]) + 0.5000 * f(x[i+1]) ) / h"><pre><span class="pl-en">fd1stderiv2ptcentrale</span>(f, x, i, h)  <span class="pl-k">=</span> ( <span class="pl-k">-</span><span class="pl-c1">f</span>(x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">+</span> <span class="pl-c1">f</span>(x[i<span class="pl-k">+</span><span class="pl-c1">1</span>]) ) <span class="pl-k">/</span> (<span class="pl-c1">2</span> <span class="pl-k">*</span> h)
<span class="pl-en">fd1stderiv2ptcentrale1</span>(f, x, i, h) <span class="pl-k">=</span> ( <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">f</span>(x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">f</span>(x[i<span class="pl-k">+</span><span class="pl-c1">1</span>]) ) <span class="pl-k">/</span> h
<span class="pl-en">fd1stderiv2ptcentrald</span>(f, x, i, h)  <span class="pl-k">=</span> ( <span class="pl-k">-</span><span class="pl-c1">0.5000</span> <span class="pl-k">*</span> <span class="pl-c1">f</span>(x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">+</span> <span class="pl-c1">0.5000</span> <span class="pl-k">*</span> <span class="pl-c1">f</span>(x[i<span class="pl-k">+</span><span class="pl-c1">1</span>]) ) <span class="pl-k">/</span> h</pre></div>
<p dir="auto">The suffixes 'e' and 'd' stand for 'exact' and 'decimal', respectively. No suffix? It is "exact".
After activating the function(s), we can evaluate right away in the present Julia REPL session. For example,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="FiniteDifferenceFormula.fd1stderiv2ptcentrale(sin, 0:0.01:pi, 3, 0.01)"><pre>FiniteDifferenceFormula<span class="pl-k">.</span><span class="pl-c1">fd1stderiv2ptcentrale</span>(sin, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0.01</span><span class="pl-k">:</span><span class="pl-c1">pi</span>, <span class="pl-c1">3</span>, <span class="pl-c1">0.01</span>)</pre></div>
<p dir="auto">Below is the output of activatejuliafunction(). It gives us the first chance to examine the usability
of the computed or tested formula.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import FiniteDifferenceFormula as fd
f, x, i, h = sin, 0:0.01:10, 501, 0.01
fd.fd1stderiv2ptcentrale(f, x, i, h)   # result: 0.2836574577837647, relative error = 0.00166666%
fd.fd1stderiv2ptcentrale1(f, x, i, h)  # result: 0.2836574577837647, relative error = 0.00166666%
fd.fd1stderiv2ptcentrald(f, x, i, h)   # result: 0.2836574577837647, relative error = 0.00166666%
                                       # cp:     0.2836621854632262"><pre><span class="pl-k">import</span> FiniteDifferenceFormula <span class="pl-k">as</span> fd
f, x, i, h <span class="pl-k">=</span> sin, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0.01</span><span class="pl-k">:</span><span class="pl-c1">10</span>, <span class="pl-c1">501</span>, <span class="pl-c1">0.01</span>
fd<span class="pl-k">.</span><span class="pl-c1">fd1stderiv2ptcentrale</span>(f, x, i, h)   <span class="pl-c"><span class="pl-c">#</span> result: 0.2836574577837647, relative error = 0.00166666%</span>
fd<span class="pl-k">.</span><span class="pl-c1">fd1stderiv2ptcentrale1</span>(f, x, i, h)  <span class="pl-c"><span class="pl-c">#</span> result: 0.2836574577837647, relative error = 0.00166666%</span>
fd<span class="pl-k">.</span><span class="pl-c1">fd1stderiv2ptcentrald</span>(f, x, i, h)   <span class="pl-c"><span class="pl-c">#</span> result: 0.2836574577837647, relative error = 0.00166666%</span>
                                       <span class="pl-c"><span class="pl-c">#</span> cp:     0.2836621854632262</span></pre></div>
<h3 dir="auto"><a id="user-content-function-activatejuliafunctionn-points-k-m-or-verifyformulan-points-k-m" class="anchor" aria-hidden="true" href="#function-activatejuliafunctionn-points-k-m-or-verifyformulan-points-k-m"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>activatejuliafunction</code>(n, points, k, m) or <code>verifyformula</code>(n, points, k, m)</h3>
<p dir="auto">They are the same. Each allows users to load a formula from some source to test and see if it is correct.
If it is valid, its truncation error in the big-O notation can be determined. Furthermore, if the input
data is not for a valid formula, it tries also to find one, if possible, using n and points.</p>
<p dir="auto">Here, n is the order of a derivative, points are a list, k is a list of the corresponding
coefficients of a formula, and m is the coefficient of the term f^(n)(x[i]) in the linear
combination of f(x[i+j]), where j ∈ points. In general, m is the coefficient of h^n in the
denominator of a formula. For example,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import FiniteDifferenceFormula as fd
fd.activatejuliafunction(2, [-1 0 2 3 6], [12 21 2 -3 -9], -12)
fd.truncationerror()
fd.activatejuliafunction(4, 0:4, [2//5 -8//5 12//5 -8//3 2//5], 5)
fd.activatejuliafunction(4, [0, 1, 2, 3, 4], [2/5 -8/5 12/5 -8/3 2/5], 5)
fd.activatejuliafunction(2, [-1 2 0 2 3 6], [1.257 21.16 2.01 -3.123 -9.5], -12)"><pre><span class="pl-k">import</span> FiniteDifferenceFormula <span class="pl-k">as</span> fd
fd<span class="pl-k">.</span><span class="pl-c1">activatejuliafunction</span>(<span class="pl-c1">2</span>, [<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">6</span>], [<span class="pl-c1">12</span> <span class="pl-c1">21</span> <span class="pl-c1">2</span> <span class="pl-k">-</span><span class="pl-c1">3</span> <span class="pl-k">-</span><span class="pl-c1">9</span>], <span class="pl-k">-</span><span class="pl-c1">12</span>)
fd<span class="pl-k">.</span><span class="pl-c1">truncationerror</span>()
fd<span class="pl-k">.</span><span class="pl-c1">activatejuliafunction</span>(<span class="pl-c1">4</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">4</span>, [<span class="pl-c1">2</span><span class="pl-k">//</span><span class="pl-c1">5</span> <span class="pl-k">-</span><span class="pl-c1">8</span><span class="pl-k">//</span><span class="pl-c1">5</span> <span class="pl-c1">12</span><span class="pl-k">//</span><span class="pl-c1">5</span> <span class="pl-k">-</span><span class="pl-c1">8</span><span class="pl-k">//</span><span class="pl-c1">3</span> <span class="pl-c1">2</span><span class="pl-k">//</span><span class="pl-c1">5</span>], <span class="pl-c1">5</span>)
fd<span class="pl-k">.</span><span class="pl-c1">activatejuliafunction</span>(<span class="pl-c1">4</span>, [<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], [<span class="pl-c1">2</span><span class="pl-k">/</span><span class="pl-c1">5</span> <span class="pl-k">-</span><span class="pl-c1">8</span><span class="pl-k">/</span><span class="pl-c1">5</span> <span class="pl-c1">12</span><span class="pl-k">/</span><span class="pl-c1">5</span> <span class="pl-k">-</span><span class="pl-c1">8</span><span class="pl-k">/</span><span class="pl-c1">3</span> <span class="pl-c1">2</span><span class="pl-k">/</span><span class="pl-c1">5</span>], <span class="pl-c1">5</span>)
fd<span class="pl-k">.</span><span class="pl-c1">activatejuliafunction</span>(<span class="pl-c1">2</span>, [<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">0</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">6</span>], [<span class="pl-c1">1.257</span> <span class="pl-c1">21.16</span> <span class="pl-c1">2.01</span> <span class="pl-k">-</span><span class="pl-c1">3.123</span> <span class="pl-k">-</span><span class="pl-c1">9.5</span>], <span class="pl-k">-</span><span class="pl-c1">12</span>)</pre></div>
<h3 dir="auto"><a id="user-content-function-taylorcoefsj-n--10-or-tcoefsj-n--10" class="anchor" aria-hidden="true" href="#function-taylorcoefsj-n--10-or-tcoefsj-n--10"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>taylorcoefs</code>(j, n = 10) or <code>tcoefs</code>(j, n = 10)</h3>
<p dir="auto">The function returns the coefficients of the first n terms of the Taylor series of f(x[i+j])
about x[i].</p>
<h3 dir="auto"><a id="user-content-function-taylorj-n--10" class="anchor" aria-hidden="true" href="#function-taylorj-n--10"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>taylor</code>(j, n = 10)</h3>
<p dir="auto">The function prints the first n terms of the Taylor series of f(x[i+j]) about x[i].</p>
<h3 dir="auto"><a id="user-content-function-taylorcoefs-n--10-or-taylorpoints-k-n--10" class="anchor" aria-hidden="true" href="#function-taylorcoefs-n--10-or-taylorpoints-k-n--10"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>taylor</code>(coefs, n = 10) or <code>taylor</code>(points, k, n = 10)</h3>
<p dir="auto">The function prints the first n nonzero terms of a Taylor series of which the coefficients are
provided in <code>coefs</code> or given through <code>points</code> and <code>k[:]</code> as in the linear combination
<code>k[1]*f(x[i+points[1]]) + k[2]*f(x[i+points[2]]) + ...</code> It provides also another way
to verify if a formula is correct.</p>
<h3 dir="auto"><a id="user-content-function-formulasorders--1-2-3-min_num_of_points--2-max_num_of_points--5" class="anchor" aria-hidden="true" href="#function-formulasorders--1-2-3-min_num_of_points--2-max_num_of_points--5"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>function <code>formulas</code>(orders = [1, 2, 3], min_num_of_points = 2, max_num_of_points = 5)</h3>
<p dir="auto">By default, the function prints all forward, backward, and central finite difference formulas for
the 1st, 2nd, and 3rd derivatives, using 2 to 5 points.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import FiniteDifferenceFormula as fd
fd.compute(1, 0:2, true)                   # find, generate, and print &quot;3&quot;-point forward formula for f'(x[i])
fd.compute(2, -3:0, true)                  # find, generate, and print &quot;4&quot;-point backward formula for f''(x[i])
fd.compute(3, -9:9)                        # find &quot;19&quot;-point central formula for f'''(x[i])
fd.decimalplaces(6)                        # use 6 decimal places to generate Julia functions of computed formulas
fd.compute(2, [-3 -2 1 2 7])               # find formula for f''(x[i]) using points x[i+j], j = -3, -2, 1, 2, and 7
fd.compute(1,-230:230)                     # find &quot;461&quot;-point central formula for f'(x[i]). it may take hours!
fd.formula()                               # generate and print the formula computed last time you called compute(...)
fd.truncationerror()                       # print and return the truncation error of the newly computed formula
fd.taylor(-2, 5)                           # print the first 5 terms of the Taylor series of f(x[i-2]) about x[i]

coefs = 2*fd.tcoefs(0) - 5*fd.tcoefs(1) + 4*fd.tcoefs(2) - fd.tcoefs(5);
fd.taylor(coefs, 7)                        # print the 1st 7 nonzero terms of the Taylor series of 2f(x[i]) - 5f(x[i+1]) + 4f(x[i+2]) - f(x[i+5])

fd.taylor([0, 1, 2, 5], [2, -5, 4, -1], 7) # same as above

fd.activatejuliafunction()                 # activate Julia function(s) of the newly computed formula in present REPL session
fd.verifyformula(1, 2:3, [-4, 5], 6)       # verify if f'(x[i]) = (-4f(x[i+2] + 5f(x[i+3)) / (6h) is a valid formula
fd.formulas(2, 5, 9)                       # print all forward, backword, and central formulas for the 2nd derivative, using 5 to 9 points
fd.formulas([1, 2, 4], 5, 9)               # print all forward, backword, and central formulas for the 1st, 2nd, and 4th derivatives, using 5 to 9 points"><pre><span class="pl-k">import</span> FiniteDifferenceFormula <span class="pl-k">as</span> fd
fd<span class="pl-k">.</span><span class="pl-c1">compute</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">true</span>)                   <span class="pl-c"><span class="pl-c">#</span> find, generate, and print "3"-point forward formula for f'(x[i])</span>
fd<span class="pl-k">.</span><span class="pl-c1">compute</span>(<span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">0</span>, <span class="pl-c1">true</span>)                  <span class="pl-c"><span class="pl-c">#</span> find, generate, and print "4"-point backward formula for f''(x[i])</span>
fd<span class="pl-k">.</span><span class="pl-c1">compute</span>(<span class="pl-c1">3</span>, <span class="pl-k">-</span><span class="pl-c1">9</span><span class="pl-k">:</span><span class="pl-c1">9</span>)                        <span class="pl-c"><span class="pl-c">#</span> find "19"-point central formula for f'''(x[i])</span>
fd<span class="pl-k">.</span><span class="pl-c1">decimalplaces</span>(<span class="pl-c1">6</span>)                        <span class="pl-c"><span class="pl-c">#</span> use 6 decimal places to generate Julia functions of computed formulas</span>
fd<span class="pl-k">.</span><span class="pl-c1">compute</span>(<span class="pl-c1">2</span>, [<span class="pl-k">-</span><span class="pl-c1">3</span> <span class="pl-k">-</span><span class="pl-c1">2</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">7</span>])               <span class="pl-c"><span class="pl-c">#</span> find formula for f''(x[i]) using points x[i+j], j = -3, -2, 1, 2, and 7</span>
fd<span class="pl-k">.</span><span class="pl-c1">compute</span>(<span class="pl-c1">1</span>,<span class="pl-k">-</span><span class="pl-c1">230</span><span class="pl-k">:</span><span class="pl-c1">230</span>)                     <span class="pl-c"><span class="pl-c">#</span> find "461"-point central formula for f'(x[i]). it may take hours!</span>
fd<span class="pl-k">.</span><span class="pl-c1">formula</span>()                               <span class="pl-c"><span class="pl-c">#</span> generate and print the formula computed last time you called compute(...)</span>
fd<span class="pl-k">.</span><span class="pl-c1">truncationerror</span>()                       <span class="pl-c"><span class="pl-c">#</span> print and return the truncation error of the newly computed formula</span>
fd<span class="pl-k">.</span><span class="pl-c1">taylor</span>(<span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">5</span>)                           <span class="pl-c"><span class="pl-c">#</span> print the first 5 terms of the Taylor series of f(x[i-2]) about x[i]</span>

coefs <span class="pl-k">=</span> <span class="pl-c1">2</span><span class="pl-k">*</span>fd<span class="pl-k">.</span><span class="pl-c1">tcoefs</span>(<span class="pl-c1">0</span>) <span class="pl-k">-</span> <span class="pl-c1">5</span><span class="pl-k">*</span>fd<span class="pl-k">.</span><span class="pl-c1">tcoefs</span>(<span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-c1">4</span><span class="pl-k">*</span>fd<span class="pl-k">.</span><span class="pl-c1">tcoefs</span>(<span class="pl-c1">2</span>) <span class="pl-k">-</span> fd<span class="pl-k">.</span><span class="pl-c1">tcoefs</span>(<span class="pl-c1">5</span>);
fd<span class="pl-k">.</span><span class="pl-c1">taylor</span>(coefs, <span class="pl-c1">7</span>)                        <span class="pl-c"><span class="pl-c">#</span> print the 1st 7 nonzero terms of the Taylor series of 2f(x[i]) - 5f(x[i+1]) + 4f(x[i+2]) - f(x[i+5])</span>

fd<span class="pl-k">.</span><span class="pl-c1">taylor</span>([<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">5</span>], [<span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">5</span>, <span class="pl-c1">4</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>], <span class="pl-c1">7</span>) <span class="pl-c"><span class="pl-c">#</span> same as above</span>

fd<span class="pl-k">.</span><span class="pl-c1">activatejuliafunction</span>()                 <span class="pl-c"><span class="pl-c">#</span> activate Julia function(s) of the newly computed formula in present REPL session</span>
fd<span class="pl-k">.</span><span class="pl-c1">verifyformula</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">3</span>, [<span class="pl-k">-</span><span class="pl-c1">4</span>, <span class="pl-c1">5</span>], <span class="pl-c1">6</span>)       <span class="pl-c"><span class="pl-c">#</span> verify if f'(x[i]) = (-4f(x[i+2] + 5f(x[i+3)) / (6h) is a valid formula</span>
fd<span class="pl-k">.</span><span class="pl-c1">formulas</span>(<span class="pl-c1">2</span>, <span class="pl-c1">5</span>, <span class="pl-c1">9</span>)                       <span class="pl-c"><span class="pl-c">#</span> print all forward, backword, and central formulas for the 2nd derivative, using 5 to 9 points</span>
fd<span class="pl-k">.</span><span class="pl-c1">formulas</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>], <span class="pl-c1">5</span>, <span class="pl-c1">9</span>)               <span class="pl-c"><span class="pl-c">#</span> print all forward, backword, and central formulas for the 1st, 2nd, and 4th derivatives, using 5 to 9 points</span></pre></div>
</article></div>