<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-survivalsignaturejl" class="anchor" aria-hidden="true" href="#survivalsignaturejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SurvivalSignature.jl</h1>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/friesischscott/SurvivalSignature.jl/actions/workflows/ci.yml/badge.svg"><img src="https://github.com/friesischscott/SurvivalSignature.jl/actions/workflows/ci.yml/badge.svg" alt="CI" style="max-width: 100%;"></a> <a href="https://codecov.io/gh/FriesischScott/SurvivalSignature.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/402ccff9461be425f013e4f79dc989081eca783b37144a6c70f8157dae76666e/68747470733a2f2f636f6465636f762e696f2f67682f46726965736973636853636f74742f537572766976616c5369676e61747572652e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e7376673f746f6b656e3d313936374d3236415445" alt="codecov" data-canonical-src="https://codecov.io/gh/FriesischScott/SurvivalSignature.jl/branch/master/graph/badge.svg?token=1967M26ATE" style="max-width: 100%;"></a> <a href="https://doi.org/10.5281/zenodo.4306113" rel="nofollow"><img src="https://camo.githubusercontent.com/e01cdf4b170150694932d0d701ac6e4950a4b6fbcdc413161f663870557727db/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f444f492f31302e353238312f7a656e6f646f2e343330363131332e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/DOI/10.5281/zenodo.4306113.svg" style="max-width: 100%;"></a></p>
<p dir="auto">Julia package for the computation of survival signatures as introduced by <a href="https://doi.org/10.1007/978-3-642-30662-4_8" rel="nofollow">Coolen et al. (2013)</a>.</p>
<p dir="auto">In addition to the regular analytical computations, this package contains a Monte Carlo simulation based algorithm to approximate the survival signature for systems where the computational demand for the standard approach is too high. If you use this package for a publication, please cite <a href="https://doi.org/10.1016/j.ress.2021.107935" rel="nofollow">Behrensdorf et al. (2021)</a>.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<h3 dir="auto"><a id="user-content-exact-computation" class="anchor" aria-hidden="true" href="#exact-computation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Exact computation</h3>
<p dir="auto">Consider a simple system of six components divided into two types.</p>
<p align="center" dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="img/system.svg"><img src="img/system.svg" style="max-width: 100%;"></a>
</p>
<p dir="auto">Computing the survival signature for any system requires three definitions: the system, the component types, and a structure function. Start by defining the system as an adjacency matrix and the types as a dictionary.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="A = zeros(6, 6)
A[1, [2, 3]] .= 1.0
A[2, [4, 5]] .= 1.0
A[3, [4, 6]] .= 1.0
A[4, [5, 6]] .= 1.0

types = Dict(1 =&gt; [1, 2, 5], 2 =&gt; [3, 4, 6])"><pre>A <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(<span class="pl-c1">6</span>, <span class="pl-c1">6</span>)
A[<span class="pl-c1">1</span>, [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>]] <span class="pl-k">.=</span> <span class="pl-c1">1.0</span>
A[<span class="pl-c1">2</span>, [<span class="pl-c1">4</span>, <span class="pl-c1">5</span>]] <span class="pl-k">.=</span> <span class="pl-c1">1.0</span>
A[<span class="pl-c1">3</span>, [<span class="pl-c1">4</span>, <span class="pl-c1">6</span>]] <span class="pl-k">.=</span> <span class="pl-c1">1.0</span>
A[<span class="pl-c1">4</span>, [<span class="pl-c1">5</span>, <span class="pl-c1">6</span>]] <span class="pl-k">.=</span> <span class="pl-c1">1.0</span>

types <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">5</span>], <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> [<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>])</pre></div>
<p dir="auto"><code>SurvivalSignature.jl</code> provides a simple structure function to check <em>s-t-connectivity</em>, suitable for reliability block diagrams. The function <code>s_t_connectivity(nodes, source, target)</code> returns new function which accepts a system and vector of functioning components as arguments.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# returns a new function (system::Array{Float64,2}, x::Vector)
φ = s_t_connectivity([1:6;], [1], [5, 6])"><pre><span class="pl-c"><span class="pl-c">#</span> returns a new function (system::Array{Float64,2}, x::Vector)</span>
φ <span class="pl-k">=</span> <span class="pl-c1">s_t_connectivity</span>([<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">6</span>;], [<span class="pl-c1">1</span>], [<span class="pl-c1">5</span>, <span class="pl-c1">6</span>])</pre></div>
<p dir="auto">Next, the survival signature is calculated by running</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Φ = survivalsignature(A, types, φ)"><pre>Φ <span class="pl-k">=</span> <span class="pl-c1">survivalsignature</span>(A, types, φ)</pre></div>
<p dir="auto">resulting in the following signature</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="4×4 Matrix{Float64}:
 0.0  0.0  0.0       0.0
 0.0  0.0  0.111111  0.333333
 0.0  0.0  0.444444  0.666667
 1.0  1.0  1.0       1.0"><pre><span class="pl-c1">4</span><span class="pl-k">×</span><span class="pl-c1">4</span> Matrix{Float64}<span class="pl-k">:</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>       <span class="pl-c1">0.0</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.111111</span>  <span class="pl-c1">0.333333</span>
 <span class="pl-c1">0.0</span>  <span class="pl-c1">0.0</span>  <span class="pl-c1">0.444444</span>  <span class="pl-c1">0.666667</span>
 <span class="pl-c1">1.0</span>  <span class="pl-c1">1.0</span>  <span class="pl-c1">1.0</span>       <span class="pl-c1">1.0</span></pre></div>
<h3 dir="auto"><a id="user-content-approximation" class="anchor" aria-hidden="true" href="#approximation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Approximation</h3>
<p dir="auto">If exact computation of the survival signature is not possible for the desired system, it can be approximated using Monte Carlo simulation by providing a desired number of samples to use per entry of the survival signature and optional target coefficient of variation.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Φ, cov = survivalsignature(A, types, φ, 10000, 0.001)"><pre>Φ, cov <span class="pl-k">=</span> <span class="pl-c1">survivalsignature</span>(A, types, φ, <span class="pl-c1">10000</span>, <span class="pl-c1">0.001</span>)</pre></div>
<p dir="auto">In addition to the survival signature this will return the coefficients of variation for each entry.</p>
<h3 dir="auto"><a id="user-content-preprocessing" class="anchor" aria-hidden="true" href="#preprocessing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Preprocessing</h3>
<p dir="auto">Both the analytical solution and the approximation accept an optional preprocessor to exclude entries of the survival signature based on some prior knowledge.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Φ, cov = survivalsignature(A, types, φ, preprocessor)
Φ = survivalsignature(A, types, φ, 10000, 0.001, preprocessor)"><pre>Φ, cov <span class="pl-k">=</span> <span class="pl-c1">survivalsignature</span>(A, types, φ, preprocessor)
Φ <span class="pl-k">=</span> <span class="pl-c1">survivalsignature</span>(A, types, φ, <span class="pl-c1">10000</span>, <span class="pl-c1">0.001</span>, preprocessor)</pre></div>
<p dir="auto">A valid preprocessor is a function which takes the survival signature and a system as arguments. At the time of preprocessing the signature passed to the function will be <code>Inf</code> for all entries. Entries are excluded from computation by setting them to zero. The preprocessor must modify the signature in place and return <code>nothing</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function preprocessor!(Φ, system)
    # exclude entries by setting them to 0
    return nothing
end"><pre><span class="pl-k">function</span> <span class="pl-en">preprocessor!</span>(Φ, system)
    <span class="pl-c"><span class="pl-c">#</span> exclude entries by setting them to 0</span>
    <span class="pl-k">return</span> <span class="pl-c1">nothing</span>
<span class="pl-k">end</span></pre></div>
<p dir="auto">A preprocessor using percolation is included as <code>percolation_preprocessor!(Φ, A)</code>.</p>
<h3 dir="auto"><a id="user-content-reliability-analysis" class="anchor" aria-hidden="true" href="#reliability-analysis"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Reliability Analysis</h3>
<p dir="auto">If the cdfs of the failure time distributions for each component type are known, the reliability can be computed analytically using distributions from <code>Distributions.jl</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="distributions = Dict(1 =&gt; Exponential(1), 2 =&gt; Weibull(2, 1))
time = [0:0.001:1;]

P = reliability(time, Φ, distributions)"><pre>distributions <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Exponential</span>(<span class="pl-c1">1</span>), <span class="pl-c1">2</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">Weibull</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1</span>))
time <span class="pl-k">=</span> [<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">0.001</span><span class="pl-k">:</span><span class="pl-c1">1</span>;]

P <span class="pl-k">=</span> <span class="pl-c1">reliability</span>(time, Φ, distributions)</pre></div>
<p dir="auto">Alternatively, the reliability can be approximated by providing a <code>NxM Matrix{Float64}</code> of failure times where <code>N</code> is the number of samples and <code>M</code> the number of components.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="P = reliability(time, Φ, types, failures)"><pre>P <span class="pl-k">=</span> <span class="pl-c1">reliability</span>(time, Φ, types, failures)</pre></div>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">Behrensdorf, J., Regenhardt, T.-E., Broggi, M., Beer, M. (2021) Numerically efficient computation of the survival signature for the reliability analysis of large networks, <em>Reliability Engineering &amp; System Safety</em>, 107935, <a href="https://doi.org/10.1016/j.ress.2021.107935" rel="nofollow">https://doi.org/10.1016/j.ress.2021.107935</a>.</p>
<p dir="auto">Coolen F.P.A., Coolen-Maturi T. (2013) Generalizing the Signature to Systems with Multiple Types of Components. <em>In: Zamojski W., Mazurkiewicz J., Sugier J., Walkowiak T., Kacprzyk J. (eds) Complex Systems and Dependability. Advances in Intelligent and Soft Computing</em>, 170. Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/978-3-642-30662-4_8" rel="nofollow">https://doi.org/10.1007/978-3-642-30662-4_8</a></p>
</article></div>