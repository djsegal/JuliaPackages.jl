<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-immersedlayersjl" class="anchor" aria-hidden="true" href="#immersedlayersjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ImmersedLayers.jl</h1>
<p dir="auto"><em>Tools for solving partial differential equations by immersing surfaces and their operations in Cartesian grids</em></p>
<table>
<thead>
<tr>
<th align="center">Documentation</th>
<th align="center">Build Status</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://JuliaIBPM.github.io/ImmersedLayers.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a> <a href="https://JuliaIBPM.github.io/ImmersedLayers.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></td>
<td align="center"><a href="https://github.com/JuliaIBPM/ImmersedLayers.jl/actions"><img src="https://github.com/JuliaIBPM/ImmersedLayers.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width: 100%;"></a> <a href="https://codecov.io/gh/JuliaIBPM/ImmersedLayers.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/a2f5a4207a3abd9e19b8d147688be16f750dc925e39997f883e2fd458d3b2d18/68747470733a2f2f636f6465636f762e696f2f67682f4a756c69614942504d2f496d6d65727365644c61796572732e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/JuliaIBPM/ImmersedLayers.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/JuliaIBPM/ImmersedLayers.jl/master/PoissonDiamonds.svg"><img src="https://raw.githubusercontent.com/JuliaIBPM/ImmersedLayers.jl/master/PoissonDiamonds.svg" width="400" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-package-objective" class="anchor" aria-hidden="true" href="#package-objective"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Package objective</h2>
<p dir="auto">The objective of this package is to implement tools and operations for solving
partial differential equations (PDEs) on Cartesian grids. Objects in the domain
of interest are handled by immersing them into the grid (rather than creating
a grid that conforms to their shape). The package implements</p>
<ul dir="auto">
<li>the tools for regularizing and interpolating data between discretely-represented surfaces and Cartesian grids</li>
<li>discrete Heaviside functions that mask the regions interior or exterior of surfaces</li>
<li>discrete differential operators that immerse surface data into the grid (i.e., "layers")</li>
<li>an easy framework for specifying a user-defined PDE problem and creating the caches and functions (e.g., boundary conditions, forcing, time marching) that fully implement this problem</li>
<li>several examples of prototypical PDEs, both time-invariant and time-varying</li>
</ul>
<p dir="auto">The <a href="https://JuliaIBPM.github.io/ImmersedLayers.jl/stable" rel="nofollow">documentation</a> provides several illustrative examples. Much of the underlying machinery in this package is based on the <a href="https://github.com/JuliaIBPM/CartesianGrids.jl">CartesianGrids.jl</a> and <a href="https://github.com/JuliaIBPM/RigidBodyTools.jl">RigidBodyTools.jl</a> packages. At this time, the package only implements these in two spatial dimensions. The operators and tools are described in detail in [1], but a summary is given below.</p>
<h2 dir="auto"><a id="user-content-background" class="anchor" aria-hidden="true" href="#background"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Background</h2>
<p dir="auto">A lot of problems in physics involve surfaces and their interaction with fields
in a higher-dimensional space. One way to facilitate this interaction
is by "immersing" the surface data, as well as the associated operations on these data, into the higher-dimensional space, and similarly, allowing data in the
higher-dimensional space to be restricted to the surface. Underlying these is
the concept of a "masked" field, which takes a certain continuous form on one
side of a surface and another form on the other side. A Heaviside function H can be used to write this mathematically [1]:</p>
<p dir="auto">f = H(χ) f⁺ + H(-χ) f⁻</p>
<p dir="auto">where χ is a level set function, taking a positive value on the + side of the surface and negative value on the - side. The χ=0 level set implicitly defines the surface. Also, the gradient of χ is proportional to the unit normal vector, <strong>n</strong>. In fact, we can always choose this function so that it <em>is</em> the local normal.</p>
<p dir="auto">A really neat thing happens when we take a spatial derivative of f. For example, the gradient:</p>
<p dir="auto">∇f = H(χ) ∇f⁺  + H(-χ) ∇f⁻ + δ(χ)n(f⁺ - f⁻)</p>
<p dir="auto">Then, we get a masked form of the gradient fields of f on either side, <em>plus</em> a term involving the jump in f across the surface, times the normal vector, times the Dirac delta function δ(χ). This last factor is the immersion operator: it immerses the surface jump in f into the higher-dimensional space. Other derivatives (e.g., curl, divergence of vector fields) lead to immersion similar terms. If we the divergence of the gradient above, we get a Poisson equation with two immersion terms:</p>
<p dir="auto">∇²f = H(χ) ∇²f⁺ + H(-χ) ∇²f⁻ + δ(χ)n⋅(∇f⁺ - ∇f⁻) +  ∇⋅[δ(χ)n(f⁺ - f⁻)]</p>
<p dir="auto">The last two terms are single and double layers, in the language of the theory of potentials. Generically, in any partial differential equation, we refer to these terms as <strong>immersed layers</strong>.</p>
<p dir="auto">So standard partial differential equations can be adapted for the masked fields, so that the equations are augmented with the surface quantities. Restriction, δᵀ(χ), is the transpose of immersion. It arises when we wish to impose constraints on the surface behavior; we can instead apply this constraint to the restricted form of the masked field, e.g., setting it to a prescribed value, fᵦ, on the surface:</p>
<p dir="auto">δᵀ(χ) f = fᵦ</p>
<p dir="auto">In a computational environment, we discretize the fields on both the surface as well as in the higher-dimensional space, so this immersion process involves <em>regularization</em> (the discrete form of immersion) and <em>interpolation</em> (the discrete form of restriction), defined with the help of a discrete version of the Dirac delta function, the "DDF". We discretize the higher-dimensional space with the a staggered Cartesian grid, using tools in the <code>CartesianGrids.jl</code> package.</p>
<p dir="auto">For example, to regularize surface scalar data to the cell centers of the grid,
we use a matrix operator, Rc. Alternatively, for regularizing vector surface data to cell faces, we use Rf. Each of these has a transpose, used for interpolation of the grid data to the surface points, e.g, Rcᵀ.</p>
<p dir="auto">When we combine these operations with the standard differential operators on the grid, we get a powerful set of tools for numerically solving PDEs.</p>
<h2 dir="auto"><a id="user-content-see-it-in-action" class="anchor" aria-hidden="true" href="#see-it-in-action"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>See it in action</h2>
<p dir="auto">This method is used in various downstream packages, including</p>
<ul dir="auto">
<li><a href="https://github.com/JuliaIBPM/ViscousFlow.jl">ViscousFlow.jl</a> (For computing viscous incompressible flows)</li>
<li><a href="https://github.com/JuliaIBPM/GridPotentialFlow.jl">GridPotentialFlow.jl</a> (For computing potential flows)</li>
</ul>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">This package works on Julia <code>1.4</code> and above and is registered in the general Julia registry. To install from the REPL, type
e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="] add ImmersedLayers"><pre>] add ImmersedLayers</pre></div>
<p dir="auto">Then, in any version, type</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; using ImmersedLayers"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> ImmersedLayers</pre></div>
<p dir="auto">The plots in this documentation are generated using <a href="http://docs.juliaplots.org/latest/" rel="nofollow">Plots.jl</a>.
You might want to install that, too, to follow the examples.</p>
<h2 dir="auto"><a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<p dir="auto">[1] Eldredge, J. D. (2022) "A method of immersed layers on Cartesian grids, with application to incompressible flows," Journal of Computational Physics 448: 110716.</p>
</article></div>