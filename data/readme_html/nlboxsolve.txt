<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-nlboxsolvejl" class="anchor" aria-hidden="true" href="#nlboxsolvejl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>NLboxsolve.jl</h1>
<h1 dir="auto"><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h1>
<p dir="auto">NLboxsolve.jl is a package containing a small collection of algorithms for solving systems of non-linear equations subject to box-constraints: <code>F(x) = 0</code>, <code> lb &lt;= x &lt;= ub</code> (element-by-element), where it is assumed that the box-constraint admits a solution.  The package can also solve mixed complementarity problems, leveraging the non-linear box-solvers to do so.</p>
<p dir="auto">The collection contains seven algorithms for solving box-constrained non-linear systems: one based on Newton's (or Newton-Raphson's) method, two based on Levenberg-Marquardt, two trust region methods, and two based on Newton-Krylov methods, one of which is Jacobian-free.</p>
<h1 dir="auto"><a id="user-content-installing" class="anchor" aria-hidden="true" href="#installing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installing</h1>
<p dir="auto">NLboxsolve.jl is a registered package that can be installed using the package manager.  To do so, type the following in the REPL:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Pkg
Pkg.add(&quot;NLboxsolve&quot;)"><pre><span class="pl-k">using</span> Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>NLboxsolve<span class="pl-pds">"</span></span>)</pre></div>
<h1 dir="auto"><a id="user-content-solving-box-constrained-systems-of-equations" class="anchor" aria-hidden="true" href="#solving-box-constrained-systems-of-equations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Solving box-constrained systems of equations</h1>
<h2 dir="auto"><a id="user-content-formulating-a-problem" class="anchor" aria-hidden="true" href="#formulating-a-problem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Formulating a problem</h2>
<p dir="auto">The key elements to a problem are a vector-function containing the system of equations to be solved: <code>F(x)</code>, an initial guess at the solution, <code>x</code> (1d-array), and the lower, <code>lb</code> (1d-array with default enteries equaling -Inf), and upper, <code>ub</code> (1d-array with default enteries equaling Inf) bounds that form the box-constraint.  With these objects defined, we solve the system using:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="soln = nlboxsolve(F,x,lb,ub)"><pre>soln <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(F,x,lb,ub)</pre></div>
<p dir="auto">A Jacobian function can also be provided:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="soln = nlboxsolve(F,J,x,lb,ub)"><pre>soln <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(F,J,x,lb,ub)</pre></div>
<p dir="auto">The function, <code>F</code> and the Jacobian function, <code> J</code> can be in-place, meaning that they can take as their first argument a preallocated array.</p>
<p dir="auto">Of course there are optional arguments.  The general function call allows up to six keyword arguments, for example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="soln = nlboxsolve(F,x,lb,ub,xtol=1e-10,ftol=1e-10,iterations=200,method=:jfnk,sparsejac=:yes,krylovdim=20)"><pre>soln <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(F,x,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-10</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-10</span>,iterations<span class="pl-k">=</span><span class="pl-c1">200</span>,method<span class="pl-k">=</span><span class="pl-c1">:jfnk</span>,sparsejac<span class="pl-k">=</span><span class="pl-c1">:yes</span>,krylovdim<span class="pl-k">=</span><span class="pl-c1">20</span>)</pre></div>
<p dir="auto">where <code>xtol</code> is the convergence tolerance applied to the solution point, <code>x</code>, (default = 1e-8), <code>ftol</code> is the convergence tolerance applied to <code>F(x)</code> (default = 1e-8), <code>iterations</code> is the maximum number of iterations (default = 100), <code>method</code> specifies the algorithm used (default = :lm_ar), <code>sparsejac</code> selects whether a sparse Jacobian should be used (default = :no), and <code>krylovdim</code> (default = 30) is specific to the two Newton-Krylov methods (and ignored for the other methods).</p>
<h2 dir="auto"><a id="user-content-the-solution-algorithms" class="anchor" aria-hidden="true" href="#the-solution-algorithms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The solution algorithms</h2>
<p dir="auto">The solution algorithms are the following:</p>
<ul dir="auto">
<li>Constrained Newton-Raphson (method = :nr)</li>
<li>Kanzow, Yamashita, and Fukushima (2004) (method = :lm_kyf)</li>
<li>Amini and Rostami (2016) (method = :lm_ar) (this is the default method)</li>
<li>Kimiaei (2017) (method = :tr) (this is a nonmonotone adaptive trust region method)</li>
<li>Bellavia, Macconi, and Pieraccini (2012) (method = :dogleg) (Sometimes known as CoDoSol)</li>
<li>Chen and Vuik (2016) (method = :nk)</li>
<li>Jacobian-free Newton Krylov (method = :jfnk)</li>
</ul>
<p dir="auto">Each algorithm returns the solution in a structure that has the following fields:</p>
<ul dir="auto">
<li>solution_method</li>
<li>initial</li>
<li>zero</li>
<li>fzero</li>
<li>xdist</li>
<li>fdist</li>
<li>iters</li>
<li>trace</li>
</ul>
<p dir="auto">which are (hopefully) self-explanatory, but to be explicit the value for <code>x</code> that satisfies <code>F(x) = 0</code> is given by the <code>zero</code> field.  The nature of the convergence (or non-convergence) can be determined from <code>fzero</code>, <code>xdist</code>, <code>fdist</code>, and <code>iters</code>. The path taken by the solver is stored in the <code>trace</code> field.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">As a first example, consider the following 'fivediagonal' function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function fivediagonal(x)

    f = similar(x)

    f[1]     = 4.0*(x[1] - x[2]^2) + x[2] - x[3]^2
    f[2]     = 8.0*x[2]*(x[2]^2 - x[1]) - 2.0*(1.0 - x[2]) + 4.0*(x[2] - x[3]^2) + x[3] - x[4]^2
    f[end-1] = 8.0*x[end-1]*(x[end-1]^2 - x[end-2]) - 2.0*(1.0 - x[end-1]) + 4.0*(x[end-1] - x[end]^2) 
             + x[end-2]^2 - x[end-3]
    f[end]   = 8.0*x[end]*(x[end]^2 - x[end-1]) - 2*(1.0 - x[end]) + x[end-1]^2 - x[end-2]    
    for i = 3:length(x)-2
        f[i] = 8.0*x[i]*(x[i]^2 - x[i-1]) - 2.0*(1.0 - x[i]) + 4.0*(x[i] - x[i+1]^2) + x[i-1]^2 
             - x[i-2] + x[i+1] - x[i+2]^2
    end

    return f

end

function fivediagonal!(f,x)

    f[1]     = 4.0*(x[1] - x[2]^2) + x[2] - x[3]^2
    f[2]     = 8.0*x[2]*(x[2]^2 - x[1]) - 2.0*(1.0 - x[2]) + 4.0*(x[2] - x[3]^2) + x[3] - x[4]^2
    f[end-1] = 8.0*x[end-1]*(x[end-1]^2 - x[end-2]) - 2.0*(1.0 - x[end-1]) + 4.0*(x[end-1] - x[end]^2) 
             + x[end-2]^2 - x[end-3]
    f[end]   = 8.0*x[end]*(x[end]^2 - x[end-1]) - 2*(1.0 - x[end]) + x[end-1]^2 - x[end-2]    
    for i = 3:length(x)-2
        f[i] = 8.0*x[i]*(x[i]^2 - x[i-1]) - 2.0*(1.0 - x[i]) + 4.0*(x[i] - x[i+1]^2) + x[i-1]^2 
            - x[i-2] + x[i+1] - x[i+2]^2
    end

end

n = 5000
x0 = [2.0 for _ in 1:n]
soln_a = nlboxsolve(fivediagonal,x0,xtol=1e-15,ftol=1e-15,krylovdim=80,method=:jfnk)
soln_b = nlboxsolve(fivediagonal!,x0,xtol=1e-15,ftol=1e-15,krylovdim=80,method=:jfnk)"><pre><span class="pl-k">function</span> <span class="pl-en">fivediagonal</span>(x)

    f <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)

    f[<span class="pl-c1">1</span>]     <span class="pl-k">=</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[<span class="pl-c1">1</span>] <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> x[<span class="pl-c1">2</span>] <span class="pl-k">-</span> x[<span class="pl-c1">3</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>
    f[<span class="pl-c1">2</span>]     <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[<span class="pl-c1">2</span>]<span class="pl-k">*</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">2.0</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]) <span class="pl-k">+</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[<span class="pl-c1">2</span>] <span class="pl-k">-</span> x[<span class="pl-c1">3</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> x[<span class="pl-c1">3</span>] <span class="pl-k">-</span> x[<span class="pl-c1">4</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>
    f[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">*</span>(x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">2</span>]) <span class="pl-k">-</span> <span class="pl-c1">2.0</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">+</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">-</span> x[<span class="pl-c1">end</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) 
             <span class="pl-k">+</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">3</span>]
    f[<span class="pl-c1">end</span>]   <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[<span class="pl-c1">end</span>]<span class="pl-k">*</span>(x[<span class="pl-c1">end</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">2</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span>]) <span class="pl-k">+</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">2</span>]    
    <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">length</span>(x)<span class="pl-k">-</span><span class="pl-c1">2</span>
        f[i] <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[i]<span class="pl-k">*</span>(x[i]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">2.0</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[i]) <span class="pl-k">+</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[i] <span class="pl-k">-</span> x[i<span class="pl-k">+</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> 
             <span class="pl-k">-</span> x[i<span class="pl-k">-</span><span class="pl-c1">2</span>] <span class="pl-k">+</span> x[i<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">-</span> x[i<span class="pl-k">+</span><span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>
    <span class="pl-k">end</span>

    <span class="pl-k">return</span> f

<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">fivediagonal!</span>(f,x)

    f[<span class="pl-c1">1</span>]     <span class="pl-k">=</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[<span class="pl-c1">1</span>] <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> x[<span class="pl-c1">2</span>] <span class="pl-k">-</span> x[<span class="pl-c1">3</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>
    f[<span class="pl-c1">2</span>]     <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[<span class="pl-c1">2</span>]<span class="pl-k">*</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">2.0</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]) <span class="pl-k">+</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[<span class="pl-c1">2</span>] <span class="pl-k">-</span> x[<span class="pl-c1">3</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> x[<span class="pl-c1">3</span>] <span class="pl-k">-</span> x[<span class="pl-c1">4</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>
    f[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">*</span>(x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">2</span>]) <span class="pl-k">-</span> <span class="pl-c1">2.0</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">+</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">-</span> x[<span class="pl-c1">end</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) 
             <span class="pl-k">+</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">3</span>]
    f[<span class="pl-c1">end</span>]   <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[<span class="pl-c1">end</span>]<span class="pl-k">*</span>(x[<span class="pl-c1">end</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">2</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span>]) <span class="pl-k">+</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">end</span><span class="pl-k">-</span><span class="pl-c1">2</span>]    
    <span class="pl-k">for</span> i <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">:</span><span class="pl-c1">length</span>(x)<span class="pl-k">-</span><span class="pl-c1">2</span>
        f[i] <span class="pl-k">=</span> <span class="pl-c1">8.0</span><span class="pl-k">*</span>x[i]<span class="pl-k">*</span>(x[i]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">-</span> <span class="pl-c1">2.0</span><span class="pl-k">*</span>(<span class="pl-c1">1.0</span> <span class="pl-k">-</span> x[i]) <span class="pl-k">+</span> <span class="pl-c1">4.0</span><span class="pl-k">*</span>(x[i] <span class="pl-k">-</span> x[i<span class="pl-k">+</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>) <span class="pl-k">+</span> x[i<span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> 
            <span class="pl-k">-</span> x[i<span class="pl-k">-</span><span class="pl-c1">2</span>] <span class="pl-k">+</span> x[i<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">-</span> x[i<span class="pl-k">+</span><span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span>
    <span class="pl-k">end</span>

<span class="pl-k">end</span>

n <span class="pl-k">=</span> <span class="pl-c1">5000</span>
x0 <span class="pl-k">=</span> [<span class="pl-c1">2.0</span> <span class="pl-k">for</span> _ <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>n]
soln_a <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(fivediagonal,x0,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,krylovdim<span class="pl-k">=</span><span class="pl-c1">80</span>,method<span class="pl-k">=</span><span class="pl-c1">:jfnk</span>)
soln_b <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(fivediagonal!,x0,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,krylovdim<span class="pl-k">=</span><span class="pl-c1">80</span>,method<span class="pl-k">=</span><span class="pl-c1">:jfnk</span>)</pre></div>
<p dir="auto">Now consider the smaller problem:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function example(x)

    f = similar(x)

    f[1] = x[1]^2 + x[2]^2 - x[1]
    f[2] = x[1]^2 - x[2]^2 - x[2]

    return f

end

function example!(f,x)

    f[1] = x[1]^2 + x[2]^2 - x[1]
    f[2] = x[1]^2 - x[2]^2 - x[2]

end"><pre><span class="pl-k">function</span> <span class="pl-en">example</span>(x)

    f <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)

    f[<span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">1</span>]
    f[<span class="pl-c1">2</span>] <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]

    <span class="pl-k">return</span> f

<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">example!</span>(f,x)

    f[<span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">+</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">1</span>]
    f[<span class="pl-c1">2</span>] <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span> <span class="pl-k">-</span> x[<span class="pl-c1">2</span>]

<span class="pl-k">end</span></pre></div>
<p dir="auto">To obtain one solution we can use:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x0 = [-0.6, 0.5]
lb = [-0.5, -0.2]
ub = [0.5, 0.4]
soln_c = nlboxsolve(example,x0,lb,ub,ftol=1e-15,xtol=1e-15,method=:lm)"><pre>x0 <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">0.6</span>, <span class="pl-c1">0.5</span>]
lb <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">0.5</span>, <span class="pl-k">-</span><span class="pl-c1">0.2</span>]
ub <span class="pl-k">=</span> [<span class="pl-c1">0.5</span>, <span class="pl-c1">0.4</span>]
soln_c <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(example,x0,lb,ub,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,method<span class="pl-k">=</span><span class="pl-c1">:lm</span>)</pre></div>
<p dir="auto">To obtain a second solution:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x0 = [0.8, 0.6]
lb = [0.5, 0.0]
ub = [1.0, 1.0]
soln_d = nlboxsolve(example!,x0,lb,ub,ftol=1e-15,xtol=1e-15,method=:lm)"><pre>x0 <span class="pl-k">=</span> [<span class="pl-c1">0.8</span>, <span class="pl-c1">0.6</span>]
lb <span class="pl-k">=</span> [<span class="pl-c1">0.5</span>, <span class="pl-c1">0.0</span>]
ub <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>]
soln_d <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(example!,x0,lb,ub,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,method<span class="pl-k">=</span><span class="pl-c1">:lm</span>)</pre></div>
<p dir="auto">As a final example---one involving the use of a user defined Jacobian---, consider the problem borrowed from the package NLsolve.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function f(x)

    F = similar(x)

    F[1] = (x[1]+3)*(x[2]^3-7)+18
    F[2] = sin(x[2]*exp(x[1])-1)

    return F

end

function j(x)

    J = zeros(Number,2,2)

    J[1, 1] = x[2]^3-7
    J[1, 2] = 3*x[2]^2*(x[1]+3)
    u = exp(x[1])*cos(x[2]*exp(x[1])-1)
    J[2, 1] = x[2]*u
    J[2, 2] = u

    return J

end

function f!(F, x)
    F[1] = (x[1]+3)*(x[2]^3-7)+18
    F[2] = sin(x[2]*exp(x[1])-1)
end

function j!(J, x)
    J[1, 1] = x[2]^3-7
    J[1, 2] = 3*x[2]^2*(x[1]+3)
    u = exp(x[1])*cos(x[2]*exp(x[1])-1)
    J[2, 1] = x[2]*u
    J[2, 2] = u
end

x0 = [0.1, 1.2]
lb = [0.0, 0.0]
ub = [5.0, 5.0]
soln_e = nlboxsolve(f,j,x0,lb,ub,xtol=1e-15,ftol=1e-15,method=:nr)
soln_f = nlboxsolve(f,j!,x0,lb,ub,xtol=1e-15,ftol=1e-15,method=:nr)
soln_g = nlboxsolve(f!,j,x0,lb,ub,xtol=1e-15,ftol=1e-15,method=:nr)
soln_h = nlboxsolve(f!,j!,x0,lb,ub,xtol=1e-15,ftol=1e-15,method=:nr)"><pre><span class="pl-k">function</span> <span class="pl-en">f</span>(x)

    F <span class="pl-k">=</span> <span class="pl-c1">similar</span>(x)

    F[<span class="pl-c1">1</span>] <span class="pl-k">=</span> (x[<span class="pl-c1">1</span>]<span class="pl-k">+</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">7</span>)<span class="pl-k">+</span><span class="pl-c1">18</span>
    F[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">sin</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>])<span class="pl-k">-</span><span class="pl-c1">1</span>)

    <span class="pl-k">return</span> F

<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">j</span>(x)

    J <span class="pl-k">=</span> <span class="pl-c1">zeros</span>(Number,<span class="pl-c1">2</span>,<span class="pl-c1">2</span>)

    J[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">7</span>
    J[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">*</span>x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>(x[<span class="pl-c1">1</span>]<span class="pl-k">+</span><span class="pl-c1">3</span>)
    u <span class="pl-k">=</span> <span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>])<span class="pl-k">*</span><span class="pl-c1">cos</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>])<span class="pl-k">-</span><span class="pl-c1">1</span>)
    J[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>]<span class="pl-k">*</span>u
    J[<span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> u

    <span class="pl-k">return</span> J

<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">f!</span>(F, x)
    F[<span class="pl-c1">1</span>] <span class="pl-k">=</span> (x[<span class="pl-c1">1</span>]<span class="pl-k">+</span><span class="pl-c1">3</span>)<span class="pl-k">*</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">7</span>)<span class="pl-k">+</span><span class="pl-c1">18</span>
    F[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">sin</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>])<span class="pl-k">-</span><span class="pl-c1">1</span>)
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">j!</span>(J, x)
    J[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-c1">7</span>
    J[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">*</span>x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>(x[<span class="pl-c1">1</span>]<span class="pl-k">+</span><span class="pl-c1">3</span>)
    u <span class="pl-k">=</span> <span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>])<span class="pl-k">*</span><span class="pl-c1">cos</span>(x[<span class="pl-c1">2</span>]<span class="pl-k">*</span><span class="pl-c1">exp</span>(x[<span class="pl-c1">1</span>])<span class="pl-k">-</span><span class="pl-c1">1</span>)
    J[<span class="pl-c1">2</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>]<span class="pl-k">*</span>u
    J[<span class="pl-c1">2</span>, <span class="pl-c1">2</span>] <span class="pl-k">=</span> u
<span class="pl-k">end</span>

x0 <span class="pl-k">=</span> [<span class="pl-c1">0.1</span>, <span class="pl-c1">1.2</span>]
lb <span class="pl-k">=</span> [<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>]
ub <span class="pl-k">=</span> [<span class="pl-c1">5.0</span>, <span class="pl-c1">5.0</span>]
soln_e <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(f,j,x0,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,method<span class="pl-k">=</span><span class="pl-c1">:nr</span>)
soln_f <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(f,j!,x0,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,method<span class="pl-k">=</span><span class="pl-c1">:nr</span>)
soln_g <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(f!,j,x0,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,method<span class="pl-k">=</span><span class="pl-c1">:nr</span>)
soln_h <span class="pl-k">=</span> <span class="pl-c1">nlboxsolve</span>(f!,j!,x0,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-15</span>,method<span class="pl-k">=</span><span class="pl-c1">:nr</span>)</pre></div>
<h1 dir="auto"><a id="user-content-solving-mixed-complementarity-problems" class="anchor" aria-hidden="true" href="#solving-mixed-complementarity-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Solving Mixed Complementarity Problems</h1>
<p dir="auto">For a vector-function <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$F(x) = [f_i(x)]$</math-renderer> with <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$l_i \le x_i \le u_i$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$i = 1...n$</math-renderer>, a mixed complementarity problem is one that can be expressed as: find <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$x$</math-renderer> in the box govorned by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$[l,u]$</math-renderer> such that for all <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$i = 1,...,n$</math-renderer> either:</p>
<ul dir="auto">
<li>i) <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$f_i(x) = 0$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$l_i &amp;lt; x_i &amp;lt; u_i$</math-renderer>, or</li>
<li>ii) <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$f_i(x) &amp;gt; 0$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$x_i = l_i$</math-renderer>, or</li>
<li>iii) <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$f_i(x) &amp;lt; 0$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$x_i = u_i$</math-renderer>.</li>
</ul>
<p dir="auto">The appropriate assignment of variables to functions is dictated by the problem being solved.  Mixed complementarity problems can be reformulated in different ways, some of which allow them to be solved using the tools developed for solving box-constrained systems of nonlinear equations.  This package allows three reformulations:</p>
<ul dir="auto">
<li>The "mid" reformulation recasts the problem as: <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$h_i(x) = x_i - mid(l_i,u_i,x_i-f_i(x))$</math-renderer> and seeks to solve <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$H(x) = 0$</math-renderer>, <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$l \le x \le u$</math-renderer>.  This reformulation is selected with <code>reformulation = :mid</code> (this reformulation is the default).</li>
<li>The Fischer-Burmeister reformulation makes use of the transform: <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$h_i(x) = \sqrt{x_i^2 + f_i(x)^2} - x_i - f_i(x)$</math-renderer>.  This reformulation is selected with <code>reformulation = :fb</code>.</li>
<li>The Chen-Harker-Kanzow-Smale reformulation makes use of the transform: <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="59b93d321862577fb0c2066db58f0d61">$h_i(x) = \sqrt{(x_i - f_i(x))^2} - x_i - f_i(x)$</math-renderer>.  This reformulation is selected with <code>reformulation = :chks</code>.</li>
</ul>
<h2 dir="auto">
<a id="user-content-formulating-a-problem-1" class="anchor" aria-hidden="true" href="#formulating-a-problem-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Formulating a problem</h2>
<p dir="auto">As previously, the key elements to a problem are a vector-function containing the system of equations to be solved: <code>F(x)</code>, an initial guess at the solution, <code>x</code> (1d-array), and the lower, <code>lb</code> (1d-array with default enteries equaling -Inf), and upper, <code>ub</code> (1d-array with default enteries equaling Inf) bounds that form the box-constraint.  With these objects defined, we solve the system using:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="soln = mcpsolve(F,x,lb,ub)"><pre>soln <span class="pl-k">=</span> <span class="pl-c1">mcpsolve</span>(F,x,lb,ub)</pre></div>
<ul dir="auto">
<li>The vector-function that is passed to mcpsolve() can be in-place.</li>
<li>The solvers that underpin <code>mcpsolve()</code> are those accessable through the <code>nlboxsolve()</code> function.</li>
</ul>
<p dir="auto">The general function call allows up to seven keyword arguments, for example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="soln = mcpsolve(F,x,lb,ub,xtol=1e-10,ftol=1e-10,iterations=200,reformulation=:mid,method=:nr,sparsejac=:yes,krylovdim=20)"><pre>soln <span class="pl-k">=</span> <span class="pl-c1">mcpsolve</span>(F,x,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-10</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-10</span>,iterations<span class="pl-k">=</span><span class="pl-c1">200</span>,reformulation<span class="pl-k">=</span><span class="pl-c1">:mid</span>,method<span class="pl-k">=</span><span class="pl-c1">:nr</span>,sparsejac<span class="pl-k">=</span><span class="pl-c1">:yes</span>,krylovdim<span class="pl-k">=</span><span class="pl-c1">20</span>)</pre></div>
<p dir="auto">where <code>xtol</code> is the convergence tolerance applied to the solution point, <code>x</code>, (default = 1e-8), <code>ftol</code> is the convergence tolerance applied to <code>F(x)</code> (default = 1e-8), <code>iterations</code> is the maximum number of iterations (default = 100), <code>reformulation</code> selects the transform used to reformulate the problem (default = :mid), <code>method</code> specifies the algorithm used (default = :lm_ar), <code>sparsejac</code> selects whether a sparse Jacobian should be used (default = :no), and <code>krylovdim</code> (default = 30) is specific to the Newton-Krylov methods (and ignored for the other methods).</p>
<h2 dir="auto">
<a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example</h2>
<p dir="auto">Consider the following function:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function simple(x::Array{T,1}) where {T&lt;:Number}

    f = Array{T,1}(undef,length(x))

    f[1] = x[1]^3 - 8
    f[2] = x[2] - x[3] + x[2]^3 + 3
    f[3] = x[2] + x[3] + 2*x[3]^3 - 3
    f[4] = x[4] + 2*x[4]^3

    return f

end

function simple!(f::Array{T,1},x::Array{T,1}) where {T&lt;:Number}

    f[1] = x[1]^3 - 8
    f[2] = x[2] - x[3] + x[2]^3 + 3
    f[3] = x[2] + x[3] + 2*x[3]^3 - 3
    f[4] = x[4] + 2*x[4]^3

end

x0 = [0.5,0.5,0.5,0.5]
lb = [-1.0,-1.0,-1.0,-1.0]
ub = [1.0,1.0,1.0,1.0]
solna = mcpsolve(simple,x0,lb,ub,xtol=1e-8,ftol=1e-8,reformulation=:mid,method=:nr)
solnb = mcpsolve(simple!,x0,lb,ub,xtol=1e-8,ftol=1e-8,reformulation=:mid,method=:nr)"><pre><span class="pl-k">function</span> <span class="pl-en">simple</span>(x<span class="pl-k">::</span><span class="pl-c1">Array{T,1}</span>) <span class="pl-k">where</span> {T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>}

    f <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-c1">{T,1}</span>(undef,<span class="pl-c1">length</span>(x))

    f[<span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">8</span>
    f[<span class="pl-c1">2</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>] <span class="pl-k">-</span> x[<span class="pl-c1">3</span>] <span class="pl-k">+</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">3</span>
    f[<span class="pl-c1">3</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>] <span class="pl-k">+</span> x[<span class="pl-c1">3</span>] <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>x[<span class="pl-c1">3</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">3</span>
    f[<span class="pl-c1">4</span>] <span class="pl-k">=</span> x[<span class="pl-c1">4</span>] <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>x[<span class="pl-c1">4</span>]<span class="pl-k">^</span><span class="pl-c1">3</span>

    <span class="pl-k">return</span> f

<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">simple!</span>(f<span class="pl-k">::</span><span class="pl-c1">Array{T,1}</span>,x<span class="pl-k">::</span><span class="pl-c1">Array{T,1}</span>) <span class="pl-k">where</span> {T<span class="pl-k">&lt;:</span><span class="pl-c1">Number</span>}

    f[<span class="pl-c1">1</span>] <span class="pl-k">=</span> x[<span class="pl-c1">1</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">8</span>
    f[<span class="pl-c1">2</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>] <span class="pl-k">-</span> x[<span class="pl-c1">3</span>] <span class="pl-k">+</span> x[<span class="pl-c1">2</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">3</span>
    f[<span class="pl-c1">3</span>] <span class="pl-k">=</span> x[<span class="pl-c1">2</span>] <span class="pl-k">+</span> x[<span class="pl-c1">3</span>] <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>x[<span class="pl-c1">3</span>]<span class="pl-k">^</span><span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">3</span>
    f[<span class="pl-c1">4</span>] <span class="pl-k">=</span> x[<span class="pl-c1">4</span>] <span class="pl-k">+</span> <span class="pl-c1">2</span><span class="pl-k">*</span>x[<span class="pl-c1">4</span>]<span class="pl-k">^</span><span class="pl-c1">3</span>

<span class="pl-k">end</span>

x0 <span class="pl-k">=</span> [<span class="pl-c1">0.5</span>,<span class="pl-c1">0.5</span>,<span class="pl-c1">0.5</span>,<span class="pl-c1">0.5</span>]
lb <span class="pl-k">=</span> [<span class="pl-k">-</span><span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">1.0</span>,<span class="pl-k">-</span><span class="pl-c1">1.0</span>]
ub <span class="pl-k">=</span> [<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">1.0</span>]
solna <span class="pl-k">=</span> <span class="pl-c1">mcpsolve</span>(simple,x0,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>,reformulation<span class="pl-k">=</span><span class="pl-c1">:mid</span>,method<span class="pl-k">=</span><span class="pl-c1">:nr</span>)
solnb <span class="pl-k">=</span> <span class="pl-c1">mcpsolve</span>(simple!,x0,lb,ub,xtol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>,ftol<span class="pl-k">=</span><span class="pl-c1">1e-8</span>,reformulation<span class="pl-k">=</span><span class="pl-c1">:mid</span>,method<span class="pl-k">=</span><span class="pl-c1">:nr</span>)</pre></div>
<h1 dir="auto">
<a id="user-content-related-packages" class="anchor" aria-hidden="true" href="#related-packages"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Related packages</h1>
<ul dir="auto">
<li>NLsolve.jl</li>
<li>Complementarity.jl</li>
<li>NonlinearSolvers,jl</li>
<li>NonlinearSolve.jl</li>
</ul>
<h1 dir="auto">
<a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h1>
<p dir="auto">Amini, K., and F. Rostami, (2016), "Three-Steps Modified Levenberg-Marquardt Method with a New Line Search for Systems of Nonlinear Equations", <em>Journal of Computational and Applied Mathematics</em>, 300, pp. 30–42.</p>
<p dir="auto">Bellavia, S., Macconi, M., and S. Pieraccini, (2012), "Constrained Dogleg Methods for Nonlinear Systems with Simple Bounds", <em>Computational Optimization and Applications</em>, 53, pp. 771–794.</p>
<p dir="auto">Chen, J., and C. Vuik, (2016), "Globalization Technique for Projected Newton-Krylov Methods", <em>International Journal for Numerical Methods in Engineering</em>, 110, pp.661–674.</p>
<p dir="auto">Kanzow, C., Yamashita, N., and M. Fukushima, (2004), "Levenberg–Marquardt Methods with Strong Local Convergence Properties for Solving Nonlinear Equations with Convex Constraints", <em>Journal of Computational and Applied Mathematics</em>, 172, pp. 375–397.</p>
<p dir="auto">Kimiaei, M., (2017), "A New-Class of Nonmonotone Adaptive Trust-Region Methods for Nonlinear Equations with Box Constraints", <em>Calcolo</em>, 54, pp. 769-812.</p>
</article></div>