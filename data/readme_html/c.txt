<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1><a id="user-content-cbindingjl" class="anchor" aria-hidden="true" href="#cbindingjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>CBinding.jl</h1>
<p>Features of this package are now available as <a href="https://github.com/analytech-solutions/CBinding.jl">https://github.com/analytech-solutions/CBinding.jl</a></p>
<h1><a id="user-content-cjl" class="anchor" aria-hidden="true" href="#cjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>C.jl</h1>
<p><a href="https://github.com/analytech-solutions/C.jl/actions"><img src="https://github.com/analytech-solutions/C.jl/workflows/CI/badge.svg" alt="Build Status" style="max-width:100%;"></a></p>
<p>Use C.jl to automatically create C library bindings with Julia at runtime!</p>
<p>Package C support features:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> fully supports C's <code>struct</code>, <code>union</code>, and <code>enum</code> types</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> alignment strategies</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> bit fields</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> nested types</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> anonymous types</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> type qualifiers</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> variadic functions</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> unknown-length arrays</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> inline functions (todo)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> typed function pointers</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> function calling conventions</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> automatic callback function pointers</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> documentation generation</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> macros (work-in-progress)</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> fully supports insane C (i.e. <code>extern struct { int i; } g[2], func();</code>)</li>
</ul>
<p>Read on to learn how to automatically create C library bindings, or <a href="#using-cjl-generated-bindings">learn how to use the generated bindings</a>.</p>
<h1><a id="user-content-create-bindings-with-cjl" class="anchor" aria-hidden="true" href="#create-bindings-with-cjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Create bindings with <code>C.jl</code></h1>
<p>First, set up a compiler context to collect C expressions (at the module scope, or at the REPL).</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; using C

julia&gt; c``
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> C

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span><span class="pl-pds">`</span></span></pre></div>
<p>Notice that <code>c`...`</code> is a command macro (with the backticks) and is the means of specifying command line arguments to the Clang parser.
Each time such a command macro is used, a new compiler context is started for the module creating it.
A more real-life example might look like:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; libpath = find_libpath();

julia&gt; c`-std=c99 -Wall -DGO_FAST=1 -Imylib/include -L$(libpath) -lmylib`
"><pre>julia<span class="pl-k">&gt;</span> libpath <span class="pl-k">=</span> <span class="pl-c1">find_libpath</span>();

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span>-std=c99 -Wall -DGO_FAST=1 -Imylib/include -L$(libpath) -lmylib<span class="pl-pds">`</span></span></pre></div>
<p>The compiler context also finds the paths of all specified libraries so it can use them in any bindings that are created.</p>
<p>Next the <code>c"..."</code> string macro can be used to input C code and automatically create the equivalent Julia types, global variable bindings, and function bindings.
It is often the case that the C code will span multiple lines, so the triple-quoted variant (<code>c"""..."""</code>) is most effective for this usage.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; c&quot;&quot;&quot;
         struct S;
         struct T {
           int i;
           struct S *s;
           struct T *t;
         };
         
         extern void func(struct S *s, struct T t);
       &quot;&quot;&quot;;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct S;</span>
<span class="pl-s">         struct T {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">           struct S *s;</span>
<span class="pl-s">           struct T *t;</span>
<span class="pl-s">         };</span>
<span class="pl-s">         </span>
<span class="pl-s">         extern void func(struct S *s, struct T t);</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;</pre></div>
<p>That's it...
That's all that is needed to create a couple C types and a function binding in Julia, but actually, it gets even easier!</p>
<p>C API's usually come with header files, so let's just use those to create the Julia bindings and save some effort.
By default, bindings are generated from the code directly written in C string macros and header files explicitly included in them, but not headers included by those headers.
<a href="#options-for-c">See the <code>i</code> string macro option</a>) to allow parsing certain implicitly included headers as well.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; c&quot;&quot;&quot;
         #include &lt;mylib/header.h&gt;
       &quot;&quot;&quot;;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         #include &lt;mylib/header.h&gt;</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;</pre></div>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> all C types are defined in Julia</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> C function and global variable bindings defined</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> the C API is documented and exported by the enclosing module</li>
</ul>
<p>All done in just a few lines of code!
<a href="#a-complete-example">Take a look at the complete example below</a> or continue reading to learn about some more details.</p>
<h2><a id="user-content-some-gory-details" class="anchor" aria-hidden="true" href="#some-gory-details"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Some gory details</h2>
<p>The C expressions are parsed and immediately converted to Julia code.
In fact, the generated Julia code can be inspected using <code>@macroexpand</code>, like this:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; @macroexpand c&quot;&quot;&quot;
         struct S;
         struct T {
           int i;
           struct S *s;
           struct T *t;
         };
         
         extern void func(struct S *s, struct T t);
       &quot;&quot;&quot;
  ⋮
YIKES!
  ⋮
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-c1">@macroexpand</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct S;</span>
<span class="pl-s">         struct T {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">           struct S *s;</span>
<span class="pl-s">           struct T *t;</span>
<span class="pl-s">         };</span>
<span class="pl-s">         </span>
<span class="pl-s">         extern void func(struct S *s, struct T t);</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>
  ⋮
YIKES!
  ⋮</pre></div>
<p>In order to support the fully automatic conversion and avoid name collisions, the names of C types or functions are mangled a bit to work in Julia.
Therefore everything generated by C.jl can be accessed with the <code>c"..."</code> string macro (<a href="#using-cjl-generated-bindings">more about this below</a>) to indicate that it lives in C-land.
As an example, the function <code>func</code> above is available in Julia as <code>c"func"</code>.
It is possible to store the generated bindings to more user-friendly names (this can sometimes be automated, <a href="#options-for-c">see the <code>j</code> option</a>).
Placing each C declaration in its own macro helps when doing this manually, like:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; const S = c&quot;&quot;&quot;
         struct S;
       &quot;&quot;&quot;;

julia&gt; const T = c&quot;&quot;&quot;
         struct T {
           int i;
           struct S *s;
           struct T *t;
         };
       &quot;&quot;&quot;;

julia&gt; c&quot;&quot;&quot;
         extern void func(struct S *s, struct T t);
       &quot;&quot;&quot;j;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> S <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct S;</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;

julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> T <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct T {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">           struct S *s;</span>
<span class="pl-s">           struct T *t;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         extern void func(struct S *s, struct T t);</span>
<span class="pl-s">       <span class="pl-pds">"""j</span></span>;</pre></div>
<p>Constructs from the standard C library headers are currently not being emitted by C.jl, but other packages may be developed to provide a unified source for them.
For now, dependencies on C library or other libraries should be placed before any C code blocks referencing them.
Most often it is only a few <code>using</code> and <code>const</code> statements.</p>
<h2><a id="user-content-a-complete-example" class="anchor" aria-hidden="true" href="#a-complete-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>A complete example</h2>
<p>Finally, an example of what a package using C.jl might look like:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="module LibFoo
  module libfoo
    import Foo_jll
    using C
    
    # libfoo has libbar as a dep, and LibBar has bindings for it
    using LibBar: libbar
    
    # set up the parser
    let
      incdir = joinpath(dirname(dirname(Foo_jll.libfoo_path)), &quot;include&quot;)
      libdir = dirname(Foo_jll.libfoo_path)
      
      c`-std=c99 -fparse-all-comments -I$(incdir) -L$(libdir) -lfoo`
    end
    
    # libfoo refers to some std C sized types (eventually made available with something like `using C99`)
    const c&quot;int32_t&quot;  = Int32
    const c&quot;int64_t&quot;  = Int64
    const c&quot;uint32_t&quot; = UInt32
    const c&quot;uint64_t&quot; = UInt64
    
    # generate bindings for libfoo
    c&quot;&quot;&quot;
      #include &lt;libfoo/header-1.h&gt;
      #include &lt;libfoo/header-2.h&gt;
    &quot;&quot;&quot;
    
    # any other bindings not in headers
    c&quot;&quot;&quot;
      struct FooStruct {
        struct BarStruct bs;
      };
      
      extern struct FooStruct *foo_like_its_the_80s(int i);
    &quot;&quot;&quot;
  end
  
  
  # high-level Julian interface to libfoo
  using C
  using .libfoo
  
  function foo(i)
    ptr = c&quot;foo_like_its_the_80s&quot;(Cint(i-1))
    try
      return JulianFoo(ptr[])
    finally
      Libc.free(ptr)
    end
  end
end
"><pre><span class="pl-k">module</span> LibFoo
  <span class="pl-k">module</span> libfoo
    <span class="pl-k">import</span> Foo_jll
    <span class="pl-k">using</span> C
    
    <span class="pl-c"><span class="pl-c">#</span> libfoo has libbar as a dep, and LibBar has bindings for it</span>
    <span class="pl-k">using</span> LibBar<span class="pl-k">:</span> libbar
    
    <span class="pl-c"><span class="pl-c">#</span> set up the parser</span>
    <span class="pl-k">let</span>
      incdir <span class="pl-k">=</span> <span class="pl-c1">joinpath</span>(<span class="pl-c1">dirname</span>(<span class="pl-c1">dirname</span>(Foo_jll<span class="pl-k">.</span>libfoo_path)), <span class="pl-s"><span class="pl-pds">"</span>include<span class="pl-pds">"</span></span>)
      libdir <span class="pl-k">=</span> <span class="pl-c1">dirname</span>(Foo_jll<span class="pl-k">.</span>libfoo_path)
      
      <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span>-std=c99 -fparse-all-comments -I$(incdir) -L$(libdir) -lfoo<span class="pl-pds">`</span></span>
    <span class="pl-k">end</span>
    
    <span class="pl-c"><span class="pl-c">#</span> libfoo refers to some std C sized types (eventually made available with something like `using C99`)</span>
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>int32_t<span class="pl-pds">"</span></span>  <span class="pl-k">=</span> Int32
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>int64_t<span class="pl-pds">"</span></span>  <span class="pl-k">=</span> Int64
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>uint32_t<span class="pl-pds">"</span></span> <span class="pl-k">=</span> UInt32
    <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>uint64_t<span class="pl-pds">"</span></span> <span class="pl-k">=</span> UInt64
    
    <span class="pl-c"><span class="pl-c">#</span> generate bindings for libfoo</span>
    <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">      #include &lt;libfoo/header-1.h&gt;</span>
<span class="pl-s">      #include &lt;libfoo/header-2.h&gt;</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    
    <span class="pl-c"><span class="pl-c">#</span> any other bindings not in headers</span>
    <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">      struct FooStruct {</span>
<span class="pl-s">        struct BarStruct bs;</span>
<span class="pl-s">      };</span>
<span class="pl-s">      </span>
<span class="pl-s">      extern struct FooStruct *foo_like_its_the_80s(int i);</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
  <span class="pl-k">end</span>
  
  
  <span class="pl-c"><span class="pl-c">#</span> high-level Julian interface to libfoo</span>
  <span class="pl-k">using</span> C
  <span class="pl-k">using</span> <span class="pl-k">.</span>libfoo
  
  <span class="pl-k">function</span> <span class="pl-en">foo</span>(i)
    ptr <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>foo_like_its_the_80s<span class="pl-pds">"</span></span>(<span class="pl-c1">Cint</span>(i<span class="pl-k">-</span><span class="pl-c1">1</span>))
    <span class="pl-k">try</span>
      <span class="pl-k">return</span> <span class="pl-c1">JulianFoo</span>(ptr[])
    <span class="pl-k">finally</span>
      Libc<span class="pl-k">.</span><span class="pl-c1">free</span>(ptr)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>
<h2><a id="user-content-options-for-c" class="anchor" aria-hidden="true" href="#options-for-c"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Options for <code>c"..."</code></h2>
<p>The string macro has some options to handle more complex use cases.
Occasionally it is necessary to include or define C code that is just a dependency and should not be exported or perhaps excluded from the generated bindings altogether.
These kinds of situations can be handled with combinations of the following string macro suffixes.</p>
<ul>
<li><code>i</code> - also parse implicitly included headers that are related (in the same directory or subdirectories of it) to explicitly included headers</li>
<li><code>j</code> - also define bindings with Julian names (name collisions likely)</li>
<li><code>p</code> - mark the C code as "private" content that will not be exported</li>
<li><code>q</code> - quietly parse the block of C code, suppressing any compiler messages</li>
<li><code>r</code> - the C code is only a reference to something in C-land and bindings are not to be generated</li>
<li><code>s</code> - skip creating bindings for this block of C code</li>
<li><code>u</code> - leave this block of C code undocumented</li>
</ul>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; c&quot;&quot;&quot;
         #include &lt;stdio.h&gt;  // provides FILE type, but skip emitting bindings for this block
       &quot;&quot;&quot;s;

julia&gt; c&quot;&quot;&quot;
         struct File {  // do not include this type in module exports, and suppress compiler messages
          FILE *f;
         };
       &quot;&quot;&quot;pq;
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         #include &lt;stdio.h&gt;  // provides FILE type, but skip emitting bindings for this block</span>
<span class="pl-s">       <span class="pl-pds">"""s</span></span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct File {  // do not include this type in module exports, and suppress compiler messages</span>
<span class="pl-s">          FILE *f;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""pq</span></span>;</pre></div>
<h1><a id="user-content-using-cjl-generated-bindings" class="anchor" aria-hidden="true" href="#using-cjl-generated-bindings"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using <code>C.jl</code>-generated bindings</h1>
<p>The <code>c"..."</code> string macro can be used to refer to any of the types, global variables, or functions generated by C.jl.
When simply referencing the C content, setting up a compiler context (i.e. using <code>c`...`</code>) is not necessary.</p>
<p>The <code>c"..."</code> string macro can take on two meanings depending on the content placed in it.
So to guarantee it is interpreted as a reference to something in C, rather than a block of C code to create bindings with, include an <code>r</code> in the string macro options.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; module MyLib  # generally some C bindings are defined elsewhere
         using C
         
         c`-std=c99 -Wall -Imy/include`
         
         c&quot;&quot;&quot;
           struct S;
           struct T {
             int i;
             struct S *s;
             struct T *t;
           };
           
           extern void func(struct S *s, struct T t);
         &quot;&quot;&quot;
       end

julia&gt; using C, .MyLib

julia&gt; c&quot;struct T&quot; &lt;: Cstruct
true

julia&gt; c&quot;struct T&quot;r &lt;: Cstruct  # use 'r' option to guarantee it is treated as a reference
true

julia&gt; t = c&quot;struct T&quot;(i = 123);

julia&gt; t.i
123
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">module</span> MyLib  <span class="pl-c"><span class="pl-c">#</span> generally some C bindings are defined elsewhere</span>
         <span class="pl-k">using</span> C
         
         <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span>-std=c99 -Wall -Imy/include<span class="pl-pds">`</span></span>
         
         <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">           struct S;</span>
<span class="pl-s">           struct T {</span>
<span class="pl-s">             int i;</span>
<span class="pl-s">             struct S *s;</span>
<span class="pl-s">             struct T *t;</span>
<span class="pl-s">           };</span>
<span class="pl-s">           </span>
<span class="pl-s">           extern void func(struct S *s, struct T t);</span>
<span class="pl-s">         <span class="pl-pds">"""</span></span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> C, <span class="pl-k">.</span>MyLib

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct T<span class="pl-pds">"</span></span> <span class="pl-k">&lt;:</span> <span class="pl-c1">Cstruct</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct T<span class="pl-pds">"r</span></span> <span class="pl-k">&lt;:</span> <span class="pl-c1">Cstruct</span>  <span class="pl-c"><span class="pl-c">#</span> use 'r' option to guarantee it is treated as a reference</span>
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> t <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct T<span class="pl-pds">"</span></span>(i <span class="pl-k">=</span> <span class="pl-c1">123</span>);

julia<span class="pl-k">&gt;</span> t<span class="pl-k">.</span>i
<span class="pl-c1">123</span></pre></div>
<p>The user-defined types (<code>enum</code>, <code>struct</code>, and <code>union</code>) are referenced just as they are in C (e.g. <code>c"enum E"</code>, <code>c"struct S"</code>, and <code>c"union U"</code>).
All other types, pointers, arrays, global variables, enumeration constants, functions, etc. are also referenced just as they are in C.
Here is a quick reference for C string macro usage:</p>
<ul>
<li><code>c"int"</code> - the <code>Cint</code> type</li>
<li><code>c"int[2]"</code> - a length-2 static array <code>Cint</code>'s</li>
<li><code>c"int[2][4]"</code> - a length-2 static array of length-4 static arrays of <code>Cint</code>'s</li>
<li><code>c"int *"</code> - pointer to a <code>Cint</code></li>
<li><code>c"int **"</code> - pointer to a pointer to a <code>Cint</code></li>
<li><code>c"int const **"</code> - pointer to a pointer to a read-only <code>Cint</code></li>
<li><code>c"enum MyUnion"</code> - a user-defined C <code>enum</code> type</li>
<li><code>c"union MyUnion"</code> - a user-defined C <code>union</code> type</li>
<li><code>c"struct MyStruct"</code> - a user-defined C <code>struct</code> type</li>
<li><code>c"struct MyStruct *"</code> - a pointer to a user-defined C <code>struct</code> type</li>
<li><code>c"struct MyStruct [2]"</code> - a length-2 static array of user-defined C <code>struct</code> type</li>
<li><code>c"MyStruct"</code> - a user-defined <code>typedef</code>-ed type</li>
<li><code>c"MyStruct *"</code> - a pointer to a user-defined <code>typedef</code>-ed type</li>
<li><code>c"printf"</code> - the printf function</li>
<li><code>c"int (*)(int, int)"</code> - a function pointer</li>
<li><code>c"int (*)(char const *, ...)"</code> - a variadic function pointer</li>
</ul>
<p>The following examples demonstrate how to refer to C-land content that resides in other modules and is not exported/imported:</p>
<ul>
<li><code>c"SomeModule.SubModule.enum MyUnion"</code></li>
<li><code>c"SomeModule.SubModule.struct MyStruct *"</code></li>
<li><code>c"SomeModule.SubModule.printf"</code></li>
<li><code>c"int (*)(Some.Other.Module.struct MyStruct *, ...)"</code></li>
</ul>
<p>The C string macro can also be used to expose Julia content to C-land.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; const c&quot;IntPtr&quot; = Cptr{Cint};

julia&gt; c&quot;void (*)(IntPtr, IntPtr *, IntPtr[2])&quot; &lt;: Cptr{&lt;:Cfunction}
true
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>IntPtr<span class="pl-pds">"</span></span> <span class="pl-k">=</span> Cptr{Cint};

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>void (*)(IntPtr, IntPtr *, IntPtr[2])<span class="pl-pds">"</span></span> <span class="pl-k">&lt;:</span> <span class="pl-c1">Cptr{&lt;:Cfunction}</span>
<span class="pl-c1">true</span></pre></div>
<p>Type qualifiers are carried over from the C code.
As an example, <code>int const *</code> is a pointer to a read-only integer in is represented by C.jl as the type <code>Cptr{Cconst{Cint}}</code>.
The <code>unqualifiedtype(T)</code> can be used to strip away the type qualifiers to get to the core type, so <code>unqualifiedtype(Cconst{Cint}) === Cint</code>.</p>
<p><a href="#any-gotchas">As mentioned above</a>, the <code>bitstype(T)</code> function can be used to acquire the concrete bits type of user-defined C types as well.</p>
<h2><a id="user-content-working-with-c-objects" class="anchor" aria-hidden="true" href="#working-with-c-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Working with C objects</h2>
<p>User-defined aggregate types (<code>struct</code> and <code>union</code>) have several ways to be constructed.</p>
<ul>
<li><code>t = c"struct T"()</code> - zero-ed immutable object</li>
<li><code>t = c"struct T"(i = 123)</code> - zero-ed immutable object with field <code>i</code> initialized to 123</li>
<li><code>t = c"struct T"(t, i = 321)</code> - copy of <code>t</code> with field <code>i</code> initialized to 321</li>
</ul>
<p>These types are immutable structs and changing fields will have no effect.
Nested calls are also possible, and performance should match that of accessing fields within standard Julia immutable structs.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; c`` ; c&quot;&quot;&quot;
         struct A {
           struct {
             int i;
           };
           struct {
             struct {
               int i;
             } c;
           } b;
         };
       &quot;&quot;&quot;;

julia&gt; a = c&quot;struct A&quot;()

julia&gt; a.i
0

julia&gt; a.b.c.i
0

julia&gt; a = c&quot;struct A&quot;(i = 123, b = (c = (i = 321,),))

julia&gt; a.i
123

julia&gt; a.b.c.i
321

"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>`</span><span class="pl-pds">`</span></span> ; <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct A {</span>
<span class="pl-s">           struct {</span>
<span class="pl-s">             int i;</span>
<span class="pl-s">           };</span>
<span class="pl-s">           struct {</span>
<span class="pl-s">             struct {</span>
<span class="pl-s">               int i;</span>
<span class="pl-s">             } c;</span>
<span class="pl-s">           } b;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct A<span class="pl-pds">"</span></span>()

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>i
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>b<span class="pl-k">.</span>c<span class="pl-k">.</span>i
<span class="pl-c1">0</span>

julia<span class="pl-k">&gt;</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>struct A<span class="pl-pds">"</span></span>(i <span class="pl-k">=</span> <span class="pl-c1">123</span>, b <span class="pl-k">=</span> (c <span class="pl-k">=</span> (i <span class="pl-k">=</span> <span class="pl-c1">321</span>,),))

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>i
<span class="pl-c1">123</span>

julia<span class="pl-k">&gt;</span> a<span class="pl-k">.</span>b<span class="pl-k">.</span>c<span class="pl-k">.</span>i
<span class="pl-c1">321</span>
</pre></div>
<h2><a id="user-content-working-with-pointers" class="anchor" aria-hidden="true" href="#working-with-pointers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Working with pointers</h2>
<p>C.jl also works elegantly with pointers to aggregate types.
Pointers are followed through fields and array elements as they are accessed, and they can be dereferenced with <code>ptr[]</code> or written to with <code>ptr[] = val</code>.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; ptr = Libc.malloc(a);  # allocate a `struct A` as a copy of `a`

julia&gt; ptr.i
Cptr{Int32}(0x0000000003458810)

julia&gt; ptr.i[]
123

julia&gt; ptr.b.c.i
Cptr{Int32}(0x0000000003458814)

julia&gt; ptr.b.c.i[]
321

julia&gt; ptr.b.c.i[] = 42
42

julia&gt; Libc.free(ptr)  # deallocate it
"><pre>julia<span class="pl-k">&gt;</span> ptr <span class="pl-k">=</span> Libc<span class="pl-k">.</span><span class="pl-c1">malloc</span>(a);  <span class="pl-c"><span class="pl-c">#</span> allocate a `struct A` as a copy of `a`</span>

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>i
<span class="pl-c1">Cptr</span><span class="pl-c1">{Int32}</span>(<span class="pl-c1">0x0000000003458810</span>)

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>i[]
<span class="pl-c1">123</span>

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>b<span class="pl-k">.</span>c<span class="pl-k">.</span>i
<span class="pl-c1">Cptr</span><span class="pl-c1">{Int32}</span>(<span class="pl-c1">0x0000000003458814</span>)

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>b<span class="pl-k">.</span>c<span class="pl-k">.</span>i[]
<span class="pl-c1">321</span>

julia<span class="pl-k">&gt;</span> ptr<span class="pl-k">.</span>b<span class="pl-k">.</span>c<span class="pl-k">.</span>i[] <span class="pl-k">=</span> <span class="pl-c1">42</span>
<span class="pl-c1">42</span>

julia<span class="pl-k">&gt;</span> Libc<span class="pl-k">.</span><span class="pl-c1">free</span>(ptr)  <span class="pl-c"><span class="pl-c">#</span> deallocate it</span></pre></div>
<p>An exception to the rule is bitfields.
It is not possible to refer to bitfields with a pointer, so access to bitfields is automatically dereferenced.</p>
<h2><a id="user-content-working-with-arrays" class="anchor" aria-hidden="true" href="#working-with-arrays"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Working with arrays</h2>
<p>Included with C.jl is a static array type which works as one expects.
However, when using a subscript with a pointer to an array, a properly typed pointer to the element specified is returned and must be dereferenced.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; c&quot;&quot;&quot;
         typedef struct {
           int i;
         } IntArray[4];
       &quot;&quot;&quot;;

julia&gt; ptr = Libc.malloc(c&quot;IntArray&quot;);

julia&gt; ptr[4].i
Cptr{Int32}(0x00000000023d8194)

julia&gt; ptr[4].i[] = 123
123

julia&gt; Libc.free(ptr)  # deallocate it
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         typedef struct {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">         } IntArray[4];</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>;

julia<span class="pl-k">&gt;</span> ptr <span class="pl-k">=</span> Libc<span class="pl-k">.</span><span class="pl-c1">malloc</span>(<span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>IntArray<span class="pl-pds">"</span></span>);

julia<span class="pl-k">&gt;</span> ptr[<span class="pl-c1">4</span>]<span class="pl-k">.</span>i
<span class="pl-c1">Cptr</span><span class="pl-c1">{Int32}</span>(<span class="pl-c1">0x00000000023d8194</span>)

julia<span class="pl-k">&gt;</span> ptr[<span class="pl-c1">4</span>]<span class="pl-k">.</span>i[] <span class="pl-k">=</span> <span class="pl-c1">123</span>
<span class="pl-c1">123</span>

julia<span class="pl-k">&gt;</span> Libc<span class="pl-k">.</span><span class="pl-c1">free</span>(ptr)  <span class="pl-c"><span class="pl-c">#</span> deallocate it</span></pre></div>
<h2><a id="user-content-using-c-bindings" class="anchor" aria-hidden="true" href="#using-c-bindings"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using C bindings</h2>
<p>Bindings to global variables also behave as if they are pointers, and must be dereferenced to be read or written, but any fields and elements can be followed through with pointers.
Bindings to functions are direct, but getting the pointer to a bound function can be done with the <code>func[]</code> syntax.</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; c&quot;func&quot;(Cint(1), Cint(2));  # call the C function directly

julia&gt; funcptr = c&quot;func&quot;[]
Cptr{Cfunction{Int32, Tuple{Int32, Int32}, :cdecl}}(0x00007f8f50722b10)

julia&gt; funcptr(Cint(1), Cint(2));  # call the C function pointer
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>func<span class="pl-pds">"</span></span>(<span class="pl-c1">Cint</span>(<span class="pl-c1">1</span>), <span class="pl-c1">Cint</span>(<span class="pl-c1">2</span>));  <span class="pl-c"><span class="pl-c">#</span> call the C function directly</span>

julia<span class="pl-k">&gt;</span> funcptr <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>func<span class="pl-pds">"</span></span>[]
<span class="pl-c1">Cptr</span><span class="pl-c1">{Cfunction{Int32, Tuple{Int32, Int32}, :cdecl}}</span>(<span class="pl-c1">0x00007f8f50722b10</span>)

julia<span class="pl-k">&gt;</span> <span class="pl-c1">funcptr</span>(<span class="pl-c1">Cint</span>(<span class="pl-c1">1</span>), <span class="pl-c1">Cint</span>(<span class="pl-c1">2</span>));  <span class="pl-c"><span class="pl-c">#</span> call the C function pointer</span></pre></div>
<h2><a id="user-content-using-julia-functions-in-c" class="anchor" aria-hidden="true" href="#using-julia-functions-in-c"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using Julia functions in C</h2>
<p>Providing a Julia method to C as a callback function has never been easier!
Just pass it as an argument to the C.jl function binding or function pointer.
Assuming a binding to a C function, like <code>void set_callback(int (*cb)(int, int))</code> exists:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; function myadd(a, b)  # a callback function to give to C
         return a+b
       end;

julia&gt; c&quot;set_callback&quot;(myadd)  # that's it!

julia&gt; function saferadd(a::Cint, b::Cint)::Cint  # a safer callback function might require type paranoia
         return a+b
       end;

julia&gt; c&quot;set_callback&quot;(saferadd)
"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">myadd</span>(a, b)  <span class="pl-c"><span class="pl-c">#</span> a callback function to give to C</span>
         <span class="pl-k">return</span> a<span class="pl-k">+</span>b
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>set_callback<span class="pl-pds">"</span></span>(myadd)  <span class="pl-c"><span class="pl-c">#</span> that's it!</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">saferadd</span>(a<span class="pl-k">::</span><span class="pl-c1">Cint</span>, b<span class="pl-k">::</span><span class="pl-c1">Cint</span>)<span class="pl-k">::</span><span class="pl-c1">Cint</span>  <span class="pl-c"><span class="pl-c">#</span> a safer callback function might require type paranoia</span>
         <span class="pl-k">return</span> a<span class="pl-k">+</span>b
       <span class="pl-k">end</span>;

julia<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"</span>set_callback<span class="pl-pds">"</span></span>(saferadd)</pre></div>
<h1><a id="user-content-any-gotchas" class="anchor" aria-hidden="true" href="#any-gotchas"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Any gotchas?</h1>
<p>Inline functions and macros are not yet implemented, but they will be added in future releases.</p>
<p>Since Julia does not yet provide <code>incomplete type</code> (please voice your support of the feature here: <a href="https://github.com/JuliaLang/julia/issues/269">https://github.com/JuliaLang/julia/issues/269</a>), abstract types are used to allow forward declarations in C.
Therefore, referencing C types usually refers to the abstract type which can have significant implications when creating Julia arrays, using <code>ccall</code>, etc.
The following example illustrates this kind of unexpected behavior:</p>
<div class="highlight highlight-source-julia position-relative" data-snippet-clipboard-copy-content="julia&gt; struct X
         i::Cint
       end

julia&gt; const Y = c&quot;&quot;&quot;
         struct Y {
           int i;
         };
       &quot;&quot;&quot;

julia&gt; [X(123)] isa Vector{X}
true

julia&gt; [Y(i=123)] isa Vector{Y}
false

julia&gt; [Y(i=123)] isa Vector{bitstype(Y)}
true

"><pre>julia<span class="pl-k">&gt;</span> <span class="pl-k">struct</span> X
         i<span class="pl-k">::</span><span class="pl-c1">Cint</span>
       <span class="pl-k">end</span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">const</span> Y <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">c</span>"""</span></span>
<span class="pl-s">         struct Y {</span>
<span class="pl-s">           int i;</span>
<span class="pl-s">         };</span>
<span class="pl-s">       <span class="pl-pds">"""</span></span>

julia<span class="pl-k">&gt;</span> [<span class="pl-c1">X</span>(<span class="pl-c1">123</span>)] <span class="pl-k">isa</span> Vector{X}
<span class="pl-c1">true</span>

julia<span class="pl-k">&gt;</span> [<span class="pl-c1">Y</span>(i<span class="pl-k">=</span><span class="pl-c1">123</span>)] <span class="pl-k">isa</span> Vector{Y}
<span class="pl-c1">false</span>

julia<span class="pl-k">&gt;</span> [<span class="pl-c1">Y</span>(i<span class="pl-k">=</span><span class="pl-c1">123</span>)] <span class="pl-k">isa</span> Vector{<span class="pl-c1">bitstype</span>(Y)}
<span class="pl-c1">true</span>
</pre></div>
<p>The <code>bitstype(T)</code> function can be used to acquire the concrete bits type of any C type when the distinction matters.</p>
<p>Another implementation detail worth noting is that function bindings are brought into Julia as singleton constants, not as actual functions.
This approach allows a user to obtain function pointers from C functions in case one must be used as a callback function.
Therefore, attaching other methods to a bound C function is not possible.</p>
<p>It is also sometimes necessary to use the <code>c"..."</code> mangled names directly in Julia (for instance in the REPL help mode).
Until consistent, universal support for the string macro is available, the mangled names can be used directly as <code>var"c\"...\""</code>, like <code>help?&gt; var"c\"struct Y\""</code>.</p>
</article></div>