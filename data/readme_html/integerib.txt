<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-integeribjl" class="anchor" aria-hidden="true" href="#integeribjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>IntegerIB.jl</h1>
<p dir="auto">A julia module to apply the <strong>information bottleneck</strong> for clustering when dealing with <strong>categorical data</strong>. It is now part of the package <a href="https://github.com/johncwok/CategoricalTimeSeries.jl">CategoricalTimeSeries.jl</a></p>
<table>
<thead>
<tr>
<th align="center"><strong>Appveyor</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><a href="https://ci.appveyor.com/project/johncwok/integerib-jl" rel="nofollow"><img src="https://camo.githubusercontent.com/8fc867fef2c4bc8067931b41227c6dd0880c19b893f4b949cef5f68a372e1b8d/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f31626b776a35343662706a636a3133683f7376673d74727565" alt="Build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/1bkwj546bpjcj13h?svg=true" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table>
<p dir="auto">The information bottleneck concept can be used in the context of categorical data analysis to do <strong>clustering</strong>,
or in other words, to look for categories which have equivalent functions. <br>
Given a time-series, it looks for a <strong>concise representation</strong> of the data that preserves as much <strong>meaningful information</strong> as possible.
In a sense, it is a lossy compression algorithm. The information to preserve can be seen as the ability to make predictions :
given a specific <strong>context</strong>, how much of what is coming next can we predict ? <br>
The goal of this algorithm is to cluster categorical data while preserving predictive power. To learn more about the information bottleneck
you can look at <em><a href="https://arxiv.org/abs/1604.00268" rel="nofollow">https://arxiv.org/abs/1604.00268</a></em> or <em><a href="https://doi.org/10.1080/09298215.2015.1036888" rel="nofollow">https://doi.org/10.1080/09298215.2015.1036888</a></em></p>
<h2 dir="auto"><a id="user-content-quick-overview" class="anchor" aria-hidden="true" href="#quick-overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Quick overview</h2>
<p dir="auto">To do a simple IB clustering of categorical data do as follow, you just need to instantiate a model and optimize it:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="data = readdlm(&quot;/path/to/data/&quot;)
model = IB(x) #you can call IB(x, beta). beta is a real number that controls the amount of compression.
IB_optimize!(model) "><pre>data <span class="pl-k">=</span> <span class="pl-c1">readdlm</span>(<span class="pl-s"><span class="pl-pds">"</span>/path/to/data/<span class="pl-pds">"</span></span>)
model <span class="pl-k">=</span> <span class="pl-c1">IB</span>(x) <span class="pl-c"><span class="pl-c">#</span>you can call IB(x, beta). beta is a real number that controls the amount of compression.</span>
<span class="pl-c1">IB_optimize!</span>(model) </pre></div>
<p dir="auto">Then, to see the results :</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="print_results(model)"><pre><span class="pl-c1">print_results</span>(model)</pre></div>
<p dir="auto">Rows are clusters and columns correspond to the input categories. The result is the probability <code>p(t|x)</code> of a category belonging to a given cluster. Since most of the probabilities are very low, <code>print_results</code> <strong>sets every <code>p(t|x)</code> &gt; 0.1 to 1, 0 otherwise</strong> for ease of readability (see further usage for more options).</p>
<h4 dir="auto"><a id="user-content-example" class="anchor" aria-hidden="true" href="#example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>example:</h4>
<p dir="auto">Here is a concrete example with a dataset chorales from Bach. The input categories are the 7 types of diatonic chords described in classical music theory.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="bach = CSV.read(&quot;..\\data\\bach_histogram&quot;)
pxy = Matrix(bach)./sum(Matrix(bach))
model = IB(pxy, 1000) #You can also instantiate 'model' with a probability distribution instead of a time-series.
IB_optimize!(model)
print_results(model)"><pre>bach <span class="pl-k">=</span> CSV<span class="pl-k">.</span><span class="pl-c1">read</span>(<span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-cce">\\</span>data<span class="pl-cce">\\</span>bach_histogram<span class="pl-pds">"</span></span>)
pxy <span class="pl-k">=</span> <span class="pl-c1">Matrix</span>(bach)<span class="pl-k">./</span><span class="pl-c1">sum</span>(<span class="pl-c1">Matrix</span>(bach))
model <span class="pl-k">=</span> <span class="pl-c1">IB</span>(pxy, <span class="pl-c1">1000</span>) <span class="pl-c"><span class="pl-c">#</span>You can also instantiate 'model' with a probability distribution instead of a time-series.</span>
<span class="pl-c1">IB_optimize!</span>(model)
<span class="pl-c1">print_results</span>(model)</pre></div>
<p dir="auto">The output is in perfect accordance with western music theory. It tells us that we can group category 1, 3 and 6 together : this corresponds to the <code>tonic</code> function in classical harmony. Category 2 and 4 have been clustered together, this is what harmony calls <code>subdominant</code>. Finall category 5 and 7 are joined : this is the <code>dominant</code> function.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/34754896/90241511-7c625300-de2b-11ea-800d-3cee1da9fdf5.PNG"><img src="https://user-images.githubusercontent.com/34754896/90241511-7c625300-de2b-11ea-800d-3cee1da9fdf5.PNG" width="400" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-further-usage" class="anchor" aria-hidden="true" href="#further-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Further usage</h2>
<h4 dir="auto"><a id="user-content-types-of-algorithm" class="anchor" aria-hidden="true" href="#types-of-algorithm"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Types of algorithm:</h4>
<p dir="auto">You can choose between the original IB algorithm (Tishby, 1999) which does <em>soft</em> clustering or the <em>deterministic</em> IB algorithm (DJ Strouse, 2016) doing <em>hard</em> clustering. The former seems to produce more meaningfull clustering. When instantiating a model <code>IB(x::Array{Float64,1}, Î² = 200, algorithm = "IB")</code>, change the argument <code>algorithm</code> to "DIB" to use the deterministic IB algorithm.</p>
<h4 dir="auto"><a id="user-content-changing-default-parameters" class="anchor" aria-hidden="true" href="#changing-default-parameters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Changing default parameters:</h4>
<p dir="auto">The two most important parameters for this kind of IB clustering are the amount <strong>compression</strong> and the definition of <strong>relevant context</strong>.<br></p>
<ul dir="auto">
<li>
<p dir="auto">The amount of compression is governed by the parameter <code>Î²</code> which you provide when instantiating an IB model <code>IB(x::Array{Float64,1}, Î² = 200, algorithm = "IB")</code>. The smaller <code>Î²</code> is, the more compression. The higher <code>Î²</code>, the bigger the mutual information I(X;T) between cluster and original category is. <br>
There are two undesirable situations :</p>
<ul dir="auto">
<li>if <code>Î²</code> is too small, maximal compression is achieved and all information is lost.</li>
<li>if <code>Î²</code> is too high, there is effectively no compression. With "DIB" algorithm, this can even happen even for <code>Î²</code> &gt; ~5. <strong>In the case of the "IB" algorithm this doesn't happen</strong>, however for <code>Î²</code> values &gt; ~1000, the algorithm doesnt optimize anything because all metrics are effectively 0. In practice, when using the "IB" algorithm, a high <code>Î²</code> value (~200) is a good starting point.<br></li>
</ul>
</li>
<li>
<p dir="auto">The definition of <strong>context</strong> is essential to specify what the meaningfull information to preserve is. The default behavior is to care about predictions, context is defined  as the next element. For example, if we have a time-series <code>x = ["a","b","c","a","b"]</code>, the context vector y is <code>y = ["b","c","a","b"]</code>. We try to compress <code>x</code> in a representation that share as much informations with <code>y</code> as possible. Other definition of the context are possible : one can take the next element and the previous one. To do that that you would call :</p>
</li>
</ul>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="data = CSV.read(&quot;..\\data\\coltrane&quot;)
context = get_y(data, &quot;an&quot;) # &quot;an&quot; stands for adjacent neighbors.
model = IB(data, context, 500) # giving the context as input during instantiation.
IB_optimize!(model)"><pre>data <span class="pl-k">=</span> CSV<span class="pl-k">.</span><span class="pl-c1">read</span>(<span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-cce">\\</span>data<span class="pl-cce">\\</span>coltrane<span class="pl-pds">"</span></span>)
context <span class="pl-k">=</span> <span class="pl-c1">get_y</span>(data, <span class="pl-s"><span class="pl-pds">"</span>an<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">#</span> "an" stands for adjacent neighbors.</span>
model <span class="pl-k">=</span> <span class="pl-c1">IB</span>(data, context, <span class="pl-c1">500</span>) <span class="pl-c"><span class="pl-c">#</span> giving the context as input during instantiation.</span>
<span class="pl-c1">IB_optimize!</span>(model)</pre></div>
<h4 dir="auto"><a id="user-content-other-functionalities" class="anchor" aria-hidden="true" href="#other-functionalities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Other functionalities</h4>
<p dir="auto">To get the value of the different <strong>metrics</strong> (<em>H(T), I(X;T), I(Y;T)</em> and <em>L</em>) use the <code>calc_metrics(model::IB)</code> function. <br></p>
<p dir="auto">Since the algorithm is not 100% guaranteed to converge to a <strong>global maxima</strong>, you can use the <code>search_optima!(model::IB, n_iter = 10000)</code> to initialize and optimize your model <code>n_iter</code> times and select the optimization with the lowest <code>L</code> value. This is an in-place modification so you do not need to call <code>IB_optimize!(model::IB)</code> after calling <code>search_optima!</code>.<br></p>
<p dir="auto">If you want to get the <strong>raw probabilities</strong> <code>p(t|x)</code> after optimization (<code>print_results</code> filters it for ease of readability), you can access them with :</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="pt_x = model.qt_x"><pre>pt_x <span class="pl-k">=</span> model<span class="pl-k">.</span>qt_x</pre></div>
<p dir="auto">Similarly, you can also get p(y|t) or p(t) with <code>model.qy_t</code> and <code>model.qt</code>.<br></p>
<p dir="auto">Finally, the function <code>get_IB_curve(m::IB, start = 0.1, stop = 400, step = 0.05; glob = false)</code> lets you plot the <strong>"optimal" IB curve</strong>. Here is an example with the bach chorale dataset:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using Plots
bach = CSV.read(&quot;..\\data\\bach_histogram&quot;)
pxy = Matrix(bach)./sum(Matrix(bach))
model = IB(pxy, 1000)
x, y = get_IB_curve(model)
a = plot(x, y, color = &quot;black&quot;, linewidth = 2, label = &quot;Optimal IB curve&quot;, title = &quot;Optimal IB curve \n Bach's chorale dataset&quot;)
scatter!(a, x, y, color = &quot;black&quot;, markersize = 1.7, xlabel = &quot;I(X;T) \n&quot;, ylabel = &quot;- \n I(Y;T)&quot;, label = &quot;&quot;, legend = :topleft)"><pre><span class="pl-k">using</span> Plots
bach <span class="pl-k">=</span> CSV<span class="pl-k">.</span><span class="pl-c1">read</span>(<span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-cce">\\</span>data<span class="pl-cce">\\</span>bach_histogram<span class="pl-pds">"</span></span>)
pxy <span class="pl-k">=</span> <span class="pl-c1">Matrix</span>(bach)<span class="pl-k">./</span><span class="pl-c1">sum</span>(<span class="pl-c1">Matrix</span>(bach))
model <span class="pl-k">=</span> <span class="pl-c1">IB</span>(pxy, <span class="pl-c1">1000</span>)
x, y <span class="pl-k">=</span> <span class="pl-c1">get_IB_curve</span>(model)
a <span class="pl-k">=</span> <span class="pl-c1">plot</span>(x, y, color <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>black<span class="pl-pds">"</span></span>, linewidth <span class="pl-k">=</span> <span class="pl-c1">2</span>, label <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Optimal IB curve<span class="pl-pds">"</span></span>, title <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Optimal IB curve <span class="pl-cce">\n</span> Bach's chorale dataset<span class="pl-pds">"</span></span>)
<span class="pl-c1">scatter!</span>(a, x, y, color <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>black<span class="pl-pds">"</span></span>, markersize <span class="pl-k">=</span> <span class="pl-c1">1.7</span>, xlabel <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>I(X;T) <span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ylabel <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>- <span class="pl-cce">\n</span> I(Y;T)<span class="pl-pds">"</span></span>, label <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, legend <span class="pl-k">=</span> <span class="pl-c1">:topleft</span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/34754896/90395817-72438d00-e095-11ea-8872-3030db40539c.PNG"><img src="https://user-images.githubusercontent.com/34754896/90395817-72438d00-e095-11ea-8872-3030db40539c.PNG" width="600" style="max-width: 100%;"></a></p>
<h3 dir="auto"><a id="user-content-citing" class="anchor" aria-hidden="true" href="#citing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citing</h3>
<p dir="auto">If you used this module in a scientific publication, please consider citing the package it came from:</p>
<div class="highlight highlight-text-bibtex notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@article{nelias2021categoricaltimeseries,
  title={CategoricalTimeSeries. jl: A toolbox for categorical time-series analysis},
  author={Nelias, Corentin},
  journal={Journal of Open Source Software},
  volume={6},
  number={67},
  pages={3733},
  year={2021}
}"><pre><span class="pl-k">@article</span>{<span class="pl-en">nelias2021categoricaltimeseries</span>,
  <span class="pl-s">title</span>=<span class="pl-s"><span class="pl-pds">{</span>CategoricalTimeSeries. jl: A toolbox for categorical time-series analysis<span class="pl-pds">}</span></span>,
  <span class="pl-s">author</span>=<span class="pl-s"><span class="pl-pds">{</span>Nelias, Corentin<span class="pl-pds">}</span></span>,
  <span class="pl-s">journal</span>=<span class="pl-s"><span class="pl-pds">{</span>Journal of Open Source Software<span class="pl-pds">}</span></span>,
  <span class="pl-s">volume</span>=<span class="pl-s"><span class="pl-pds">{</span>6<span class="pl-pds">}</span></span>,
  <span class="pl-s">number</span>=<span class="pl-s"><span class="pl-pds">{</span>67<span class="pl-pds">}</span></span>,
  <span class="pl-s">pages</span>=<span class="pl-s"><span class="pl-pds">{</span>3733<span class="pl-pds">}</span></span>,
  <span class="pl-s">year</span>=<span class="pl-s"><span class="pl-pds">{</span>2021<span class="pl-pds">}</span></span>
}</pre></div>
<h4 dir="auto"><a id="user-content-installation--import" class="anchor" aria-hidden="true" href="#installation--import"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation &amp; import:</h4>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Using Pkg
Pkg.clone(âhttps://github.com/johncwok/IntegerIB.jl.gitâ)
Using IntegerIB"><pre>Using Pkg
Pkg<span class="pl-k">.</span><span class="pl-c1">clone</span>(âhttps<span class="pl-k">:</span><span class="pl-k">//</span>github<span class="pl-k">.</span>com<span class="pl-k">/</span>johncwok<span class="pl-k">/</span>IntegerIB<span class="pl-k">.</span>jl<span class="pl-k">.</span>gitâ)
Using IntegerIB</pre></div>
<h2 dir="auto"><a id="user-content-acknowledgments" class="anchor" aria-hidden="true" href="#acknowledgments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Acknowledgments</h2>
<p dir="auto">Special thanks to Nori jacoby from whom I learned a lot on the subject. The IB part of this code was tested with his data and reproduces his results. <br>
The present implementation is adapted from DJ Strouse's paper <a href="https://arxiv.org/abs/1604.00268" rel="nofollow">https://arxiv.org/abs/1604.00268</a> and his python implementation.</p>
<h2 dir="auto"><a id="user-content-to-do" class="anchor" aria-hidden="true" href="#to-do"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>To-do</h2>
<ul dir="auto">
<li>improve display of results (with PrettyTables.jl ?)</li>
<li>Implement simulated annealing to get global maxima in a more consistent fashion.</li>
</ul>
</article></div>