<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-advancedhmcjl" class="anchor" aria-hidden="true" href="#advancedhmcjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>AdvancedHMC.jl</h1>
<p dir="auto"><a href="https://github.com/TuringLang/AdvancedHMC.jl/actions/workflows/CI.yml"><img src="https://github.com/TuringLang/AdvancedHMC.jl/actions/workflows/CI.yml/badge.svg" alt="CI" style="max-width: 100%;"></a>
<a href="https://zenodo.org/badge/latestdoi/72657907" rel="nofollow"><img src="https://camo.githubusercontent.com/7bcbc74ccf13c7b3586ecda436cc657e1e0ce4fa4b54ca97b576353c9e953eb8/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f37323635373930372e737667" alt="DOI" data-canonical-src="https://zenodo.org/badge/72657907.svg" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/TuringLang/AdvancedHMC.jl?branch=kx%2Fbug-fix" rel="nofollow"><img src="https://camo.githubusercontent.com/e3ba0c45f77b02ad7e686ce4a8233297e3eab43bcd84113db49f1b62db71d453/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f547572696e674c616e672f416476616e636564484d432e6a6c2f62616467652e7376673f6272616e63683d6b782532466275672d666978" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/TuringLang/AdvancedHMC.jl/badge.svg?branch=kx%2Fbug-fix" style="max-width: 100%;"></a>
<a href="https://turing.ml/stable/docs/library/advancedhmc/" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="Stable" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://turinglang.github.io/AdvancedHMC.jl/dev/" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a></p>
<p dir="auto">AdvancedHMC.jl provides a robust, modular and efficient implementation of advanced HMC algorithms. An illustrative example for AdvancedHMC's usage is given below. AdvancedHMC.jl is part of <a href="https://github.com/TuringLang/Turing.jl">Turing.jl</a>, a probabilistic programming library in Julia.
If you are interested in using AdvancedHMC.jl through a probabilistic programming language, please check it out!</p>
<p dir="auto"><strong>Interfaces</strong></p>
<ul dir="auto">
<li><a href="https://github.com/salilab/hmc"><code>IMP.hmc</code></a>: an experimental Python module for the Integrative Modeling Platform, which uses AdvancedHMC in its backend to sample protein structures.</li>
</ul>
<p dir="auto"><strong>NEWS</strong></p>
<ul dir="auto">
<li>We presented a paper for AdvancedHMC.jl at <a href="http://approximateinference.org/" rel="nofollow">AABI</a> 2019 in Vancouver, Canada. (<a href="http://proceedings.mlr.press/v118/xu20a.html" rel="nofollow">abs</a>, <a href="http://proceedings.mlr.press/v118/xu20a/xu20a.pdf" rel="nofollow">pdf</a>, <a href="https://openreview.net/forum?id=rJgzckn4tH" rel="nofollow">OpenReview</a>)</li>
<li>We presented a poster for AdvancedHMC.jl at <a href="https://mc-stan.org/events/stancon2019Cambridge/" rel="nofollow">StanCon 2019</a> in Cambridge, UK. (<a href="https://github.com/TuringLang/AdvancedHMC.jl/files/3730367/StanCon-AHMC.pdf">pdf</a>)</li>
</ul>
<p dir="auto"><strong>API CHANGES</strong></p>
<ul dir="auto">
<li>[v0.2.22] Three functions are renamed.
<ul dir="auto">
<li><code>Preconditioner(metric::AbstractMetric)</code> -&gt; <code>MassMatrixAdaptor(metric)</code> and</li>
<li><code>NesterovDualAveraging(δ, integrator::AbstractIntegrator)</code> -&gt; <code>StepSizeAdaptor(δ, integrator)</code></li>
<li><code>find_good_eps</code> -&gt; <code>find_good_stepsize</code></li>
</ul>
</li>
<li>[v0.2.15] <code>n_adapts</code> is no longer needed to construct <code>StanHMCAdaptor</code>; the old constructor is deprecated.</li>
<li>[v0.2.8] Two Hamiltonian trajectory sampling methods are renamed to avoid a name clash with Distributions.
<ul dir="auto">
<li><code>Multinomial</code> -&gt; <code>MultinomialTS</code></li>
<li><code>Slice</code> -&gt; <code>SliceTS</code></li>
</ul>
</li>
<li>[v0.2.0] The gradient function passed to <code>Hamiltonian</code> is supposed to return a value-gradient tuple now.</li>
</ul>
<h2 dir="auto"><a id="user-content-a-minimal-example---sampling-from-a-multivariate-gaussian-using-nuts" class="anchor" aria-hidden="true" href="#a-minimal-example---sampling-from-a-multivariate-gaussian-using-nuts"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A minimal example - sampling from a multivariate Gaussian using NUTS</h2>
<p dir="auto">In this section we demonstrate a minimal example of sampling from a multivariate Gaussian (10 dimensional) using the no U-turn sampler (NUTS). Below we describe the major components of the Hamiltonian system which are essential to sample using this approach:</p>
<ul dir="auto">
<li><strong>Metric</strong>: In many sampling problems the sample space is usually associated with a metric, that allows us to measure the distance between any two points, and other similar quantities. In the example in this section, we use a special metric called the <strong>Euclidean Metric</strong>, represented with a <code>D × D</code> matrix from which we can compute distances.</li>
</ul>
<details>
 <summary>Further details about the Metric component</summary>
 The Euclidean metric is also known as the mass matrix in the physical perspective. For available metrics refer <a href="#hamiltonian-mass-matrix-metric">Hamiltonian mass matrix</a>.
</details>
<ul dir="auto">
<li><strong>Leapfrog integration</strong>: Leapfrog integration is a second-order numerical method for integrating differential equations (In this case they are, equations of motion for the relative position of one particle with respect to the other). The order of this integration signifies its rate of convergence. Any alogrithm with a finite time step size will have numerical errors and the order is related to this error. For a second-order algorithm, this error scales as the second power of the time step, hence, the name second-order. High-order intergrators are usually complex to code and have a limited region of convergence, hence they do not allow arbitrarily large time steps. A second-order integrator is suitable for our purpose, hence we opt for the leapfrog integrator. It is called <code>leapfrog</code> due to the ways this algorithm is written, where the positions and velocities of particles <code>leap over</code> each other.</li>
</ul>
<details>
 <summary>About the leapfrog integration scheme</summary>
 Suppose <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">${\bf x}$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">${\bf v}$</math-renderer> are the position and velocity of an individual particle respectively; <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$i$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$i+1$</math-renderer> are the indices for time values <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$t_i$</math-renderer> and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$t_{i+1}$</math-renderer> respectively; <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$dt = t_{i+1} - t_i$</math-renderer> is the time step size (constant and regularly spaced intervals); and <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">${\bf a}$</math-renderer> is the acceleration induced on a particle by the forces of all other particles. Furthermore, suppose positions are defined at times <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$t_i, t_{i+1}, t_{i+2}, \dots $</math-renderer>, spaced at constant intervals <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$dt$</math-renderer>, the velocities are defined at halfway times in between, denoted by <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$t_{i-1/2}, t_{i+1/2}, t_{i+3/2}, \dots $</math-renderer>, where <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$t_{i+1} - t_{i + 1/2} = t_{i + 1/2} - t_i = dt / 2$</math-renderer>, and the accelerations <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">${\bf a}$</math-renderer> are defined only on integer times, just like the positions. Then the leapfrog integration scheme is given as: <math-renderer class="js-inline-math" style="display: inline" data-static-url="https://github.githubassets.com/static" data-run-id="1e326db5d754ebc78cad889abe123afb">$x_{i} = x_{i-1} + v_{i-1/2} dt; \quad v_{i+1/2} = v_{i-1/2} + a_i dt$</math-renderer>. For available integrators refer <a href="#integrator-integrator">Integrator</a>.
</details>
<ul dir="auto">
<li>
<strong>Proposal for trajectories (static or dynamic)</strong>: Different types of proposals can be used, which maybe static or dynamic. At each iteration of any variant of the HMC algorithm there are two main steps - the first step changes the momentum and the second step may change both the position and the momentum of a particle.</li>
</ul>
<details>
 <summary>More about the proposals</summary>
 In the classical HMC approach, during the first step, new values for the momentum variables are randomly drawn from their Gaussian distribution, independently of the current values of the position variables. Whereas, during the second step, a Metropolis update is performed, using Hamiltonian dynamics to provide a new state. For available proposals refer <a href="#proposal-proposal">Proposal</a>.
</details>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using AdvancedHMC, ForwardDiff
using LogDensityProblems
using LinearAlgebra

# Define the target distribution using the `LogDensityProblem` interface
struct LogTargetDensity
    dim::Int
end
LogDensityProblems.logdensity(p::LogTargetDensity, θ) = -sum(abs2, θ) / 2  # standard multivariate normal
LogDensityProblems.dimension(p::LogTargetDensity) = p.dim
LogDensityProblems.capabilities(::Type{LogTargetDensity}) = LogDensityProblems.LogDensityOrder{0}()

# Choose parameter dimensionality and initial parameter value
D = 10; initial_θ = rand(D)
ℓπ = LogTargetDensity(D)

# Set the number of samples to draw and warmup iterations
n_samples, n_adapts = 2_000, 1_000

# Define a Hamiltonian system
metric = DiagEuclideanMetric(D)
hamiltonian = Hamiltonian(metric, ℓπ, ForwardDiff)

# Define a leapfrog solver, with initial step size chosen heuristically
initial_ϵ = find_good_stepsize(hamiltonian, initial_θ)
integrator = Leapfrog(initial_ϵ)

# Define an HMC sampler, with the following components
#   - multinomial sampling scheme,
#   - generalised No-U-Turn criteria, and
#   - windowed adaption for step-size and diagonal mass matrix
proposal = NUTS{MultinomialTS, GeneralisedNoUTurn}(integrator)
adaptor = StanHMCAdaptor(MassMatrixAdaptor(metric), StepSizeAdaptor(0.8, integrator))

# Run the sampler to draw samples from the specified Gaussian, where
#   - `samples` will store the samples
#   - `stats` will store diagnostic statistics for each sample
samples, stats = sample(hamiltonian, proposal, initial_θ, n_samples, adaptor, n_adapts; progress=true)"><pre><span class="pl-k">using</span> AdvancedHMC, ForwardDiff
<span class="pl-k">using</span> LogDensityProblems
<span class="pl-k">using</span> LinearAlgebra

<span class="pl-c"><span class="pl-c">#</span> Define the target distribution using the `LogDensityProblem` interface</span>
<span class="pl-k">struct</span> LogTargetDensity
    dim<span class="pl-k">::</span><span class="pl-c1">Int</span>
<span class="pl-k">end</span>
LogDensityProblems<span class="pl-k">.</span><span class="pl-en">logdensity</span>(p<span class="pl-k">::</span><span class="pl-c1">LogTargetDensity</span>, θ) <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">sum</span>(abs2, θ) <span class="pl-k">/</span> <span class="pl-c1">2</span>  <span class="pl-c"><span class="pl-c">#</span> standard multivariate normal</span>
LogDensityProblems<span class="pl-k">.</span><span class="pl-en">dimension</span>(p<span class="pl-k">::</span><span class="pl-c1">LogTargetDensity</span>) <span class="pl-k">=</span> p<span class="pl-k">.</span>dim
LogDensityProblems<span class="pl-k">.</span><span class="pl-en">capabilities</span>(<span class="pl-k">::</span><span class="pl-c1">Type{LogTargetDensity}</span>) <span class="pl-k">=</span> LogDensityProblems<span class="pl-k">.</span><span class="pl-c1">LogDensityOrder</span><span class="pl-c1">{0}</span>()

<span class="pl-c"><span class="pl-c">#</span> Choose parameter dimensionality and initial parameter value</span>
D <span class="pl-k">=</span> <span class="pl-c1">10</span>; initial_θ <span class="pl-k">=</span> <span class="pl-c1">rand</span>(D)
ℓπ <span class="pl-k">=</span> <span class="pl-c1">LogTargetDensity</span>(D)

<span class="pl-c"><span class="pl-c">#</span> Set the number of samples to draw and warmup iterations</span>
n_samples, n_adapts <span class="pl-k">=</span> <span class="pl-c1">2_000</span>, <span class="pl-c1">1_000</span>

<span class="pl-c"><span class="pl-c">#</span> Define a Hamiltonian system</span>
metric <span class="pl-k">=</span> <span class="pl-c1">DiagEuclideanMetric</span>(D)
hamiltonian <span class="pl-k">=</span> <span class="pl-c1">Hamiltonian</span>(metric, ℓπ, ForwardDiff)

<span class="pl-c"><span class="pl-c">#</span> Define a leapfrog solver, with initial step size chosen heuristically</span>
initial_ϵ <span class="pl-k">=</span> <span class="pl-c1">find_good_stepsize</span>(hamiltonian, initial_θ)
integrator <span class="pl-k">=</span> <span class="pl-c1">Leapfrog</span>(initial_ϵ)

<span class="pl-c"><span class="pl-c">#</span> Define an HMC sampler, with the following components</span>
<span class="pl-c"><span class="pl-c">#</span>   - multinomial sampling scheme,</span>
<span class="pl-c"><span class="pl-c">#</span>   - generalised No-U-Turn criteria, and</span>
<span class="pl-c"><span class="pl-c">#</span>   - windowed adaption for step-size and diagonal mass matrix</span>
proposal <span class="pl-k">=</span> <span class="pl-c1">NUTS</span><span class="pl-c1">{MultinomialTS, GeneralisedNoUTurn}</span>(integrator)
adaptor <span class="pl-k">=</span> <span class="pl-c1">StanHMCAdaptor</span>(<span class="pl-c1">MassMatrixAdaptor</span>(metric), <span class="pl-c1">StepSizeAdaptor</span>(<span class="pl-c1">0.8</span>, integrator))

<span class="pl-c"><span class="pl-c">#</span> Run the sampler to draw samples from the specified Gaussian, where</span>
<span class="pl-c"><span class="pl-c">#</span>   - `samples` will store the samples</span>
<span class="pl-c"><span class="pl-c">#</span>   - `stats` will store diagnostic statistics for each sample</span>
samples, stats <span class="pl-k">=</span> <span class="pl-c1">sample</span>(hamiltonian, proposal, initial_θ, n_samples, adaptor, n_adapts; progress<span class="pl-k">=</span><span class="pl-c1">true</span>)</pre></div>
<h3 dir="auto">
<a id="user-content-parallel-sampling" class="anchor" aria-hidden="true" href="#parallel-sampling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Parallel sampling</h3>
<p dir="auto">AdvancedHMC enables parallel sampling (either distributed or multi-thread) via Julia's <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/" rel="nofollow">parallel computing functions</a>.
It also supports vectorized sampling for static HMC and has been discussed in more detail in the documentation <a href="https://turing.ml/dev/docs/library/advancedhmc/parallel_sampling" rel="nofollow">here</a>.</p>
<p dir="auto">The below example utilizes the <code>@threads</code> macro to sample 4 chains across 4 threads.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Ensure that julia was launched with appropriate number of threads
println(Threads.nthreads())

# Number of chains to sample
nchains = 4

# Cache to store the chains
chains = Vector{Any}(undef, nchains)

# The `samples` from each parallel chain is stored in the `chains` vector 
# Adjust the `verbose` flag as per need
Threads.@threads for i in 1:nchains
  samples, stats = sample(hamiltonian, proposal, initial_θ, n_samples, adaptor, n_adapts; verbose=false)
  chains[i] = samples
end"><pre><span class="pl-c"><span class="pl-c">#</span> Ensure that julia was launched with appropriate number of threads</span>
<span class="pl-c1">println</span>(Threads<span class="pl-k">.</span><span class="pl-c1">nthreads</span>())

<span class="pl-c"><span class="pl-c">#</span> Number of chains to sample</span>
nchains <span class="pl-k">=</span> <span class="pl-c1">4</span>

<span class="pl-c"><span class="pl-c">#</span> Cache to store the chains</span>
chains <span class="pl-k">=</span> <span class="pl-c1">Vector</span><span class="pl-c1">{Any}</span>(undef, nchains)

<span class="pl-c"><span class="pl-c">#</span> The `samples` from each parallel chain is stored in the `chains` vector </span>
<span class="pl-c"><span class="pl-c">#</span> Adjust the `verbose` flag as per need</span>
Threads<span class="pl-k">.</span><span class="pl-c1">@threads</span> <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">:</span>nchains
  samples, stats <span class="pl-k">=</span> <span class="pl-c1">sample</span>(hamiltonian, proposal, initial_θ, n_samples, adaptor, n_adapts; verbose<span class="pl-k">=</span><span class="pl-c1">false</span>)
  chains[i] <span class="pl-k">=</span> samples
<span class="pl-k">end</span></pre></div>
<h3 dir="auto">
<a id="user-content-gpu-sampling-with-cuda" class="anchor" aria-hidden="true" href="#gpu-sampling-with-cuda"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GPU Sampling with CUDA</h3>
<p dir="auto">There is experimental support for running static HMC on the GPU using CUDA.
To do so the user needs to have <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> installed, ensure the logdensity of the <code>Hamiltonian</code> can be executed on the GPU and that the initial points are a <code>CuArray</code>.
A small working example can be found at <code>test/cuda.jl</code>.</p>
<h2 dir="auto">
<a id="user-content-api-and-supported-hmc-algorithms" class="anchor" aria-hidden="true" href="#api-and-supported-hmc-algorithms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>API and supported HMC algorithms</h2>
<p dir="auto">An important design goal of AdvancedHMC.jl is modularity; we would like to support algorithmic research on HMC.
This modularity means that different HMC variants can be easily constructed by composing various components, such as preconditioning metric (i.e. mass matrix), leapfrog integrators,  trajectories (static or dynamic), and adaption schemes etc.
The minimal example above can be modified to suit particular inference problems by picking components from the list below.</p>
<h3 dir="auto">
<a id="user-content-hamiltonian-mass-matrix-metric" class="anchor" aria-hidden="true" href="#hamiltonian-mass-matrix-metric"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hamiltonian mass matrix (<code>metric</code>)</h3>
<ul dir="auto">
<li>Unit metric: <code>UnitEuclideanMetric(dim)</code>
</li>
<li>Diagonal metric: <code>DiagEuclideanMetric(dim)</code>
</li>
<li>Dense metric: <code>DenseEuclideanMetric(dim)</code>
</li>
</ul>
<p dir="auto">where <code>dim</code> is the dimensionality of the sampling space.</p>
<h3 dir="auto">
<a id="user-content-integrator-integrator" class="anchor" aria-hidden="true" href="#integrator-integrator"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Integrator (<code>integrator</code>)</h3>
<ul dir="auto">
<li>Ordinary leapfrog integrator: <code>Leapfrog(ϵ)</code>
</li>
<li>Jittered leapfrog integrator with jitter rate <code>n</code>: <code>JitteredLeapfrog(ϵ, n)</code>
</li>
<li>Tempered leapfrog integrator with tempering rate <code>a</code>: <code>TemperedLeapfrog(ϵ, a)</code>
</li>
</ul>
<p dir="auto">where <code>ϵ</code> is the step size of leapfrog integration.</p>
<h3 dir="auto">
<a id="user-content-proposal-proposal" class="anchor" aria-hidden="true" href="#proposal-proposal"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Proposal (<code>proposal</code>)</h3>
<ul dir="auto">
<li>Static HMC with a fixed number of steps (<code>n_steps</code>) (Neal, R. M. (2011)): <code>StaticTrajectory(integrator, n_steps)</code>
</li>
<li>HMC with a fixed total trajectory length (<code>trajectory_length</code>) (Neal, R. M. (2011)): <code>HMCDA(integrator, trajectory_length)</code>
</li>
<li>Original NUTS with slice sampling (Hoffman, M. D., &amp; Gelman, A. (2014)): <code>NUTS{SliceTS,ClassicNoUTurn}(integrator)</code>
</li>
<li>Generalised NUTS with slice sampling (Betancourt, M. (2017)): <code>NUTS{SliceTS,GeneralisedNoUTurn}(integrator)</code>
</li>
<li>Original NUTS with multinomial sampling (Betancourt, M. (2017)): <code>NUTS{MultinomialTS,ClassicNoUTurn}(integrator)</code>
</li>
<li>Generalised NUTS with multinomial sampling (Betancourt, M. (2017)): <code>NUTS{MultinomialTS,GeneralisedNoUTurn}(integrator)</code>
</li>
</ul>
<h3 dir="auto">
<a id="user-content-adaptor-adaptor" class="anchor" aria-hidden="true" href="#adaptor-adaptor"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Adaptor (<code>adaptor</code>)</h3>
<ul dir="auto">
<li>Adapt the mass matrix <code>metric</code> of the Hamiltonian dynamics: <code>mma = MassMatrixAdaptor(metric)</code>
<ul dir="auto">
<li>This is lowered to <code>UnitMassMatrix</code>, <code>WelfordVar</code> or <code>WelfordCov</code> based on the type of the mass matrix <code>metric</code>
</li>
</ul>
</li>
<li>Adapt the step size of the leapfrog integrator <code>integrator</code>: <code>ssa = StepSizeAdaptor(δ, integrator)</code>
<ul dir="auto">
<li>It uses Nesterov's dual averaging with <code>δ</code> as the target acceptance rate.</li>
</ul>
</li>
<li>Combine the two above <em>naively</em>: <code>NaiveHMCAdaptor(mma, ssa)</code>
</li>
<li>Combine the first two using Stan's windowed adaptation: <code>StanHMCAdaptor(mma, ssa)</code>
</li>
</ul>
<h3 dir="auto">
<a id="user-content-gradients" class="anchor" aria-hidden="true" href="#gradients"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Gradients</h3>
<p dir="auto"><code>AdvancedHMC</code> supports both AD-based (<code>Zygote</code>, <code>Tracker</code> and <code>ForwardDiff</code>) and user-specified gradients. In order to use user-specified gradients, please replace <code>ForwardDiff</code> with <code>ℓπ_grad</code> in the <code>Hamiltonian</code>  constructor, where the gradient function <code>ℓπ_grad</code> should return a tuple containing both the log-posterior and its gradient.</p>
<p dir="auto">All the combinations are tested in <a href="https://github.com/TuringLang/AdvancedHMC.jl/blob/master/test/sampler.jl">this file</a> except from using tempered leapfrog integrator together with adaptation, which we found unstable empirically.</p>
<h2 dir="auto">
<a id="user-content-the-sample-function-signature-in-detail" class="anchor" aria-hidden="true" href="#the-sample-function-signature-in-detail"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>sample</code> function signature in detail</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="function sample(
    rng::Union{AbstractRNG, AbstractVector{&lt;:AbstractRNG}},
    h::Hamiltonian,
    κ::HMCKernel,
    θ::AbstractVector{&lt;:AbstractFloat},
    n_samples::Int,
    adaptor::AbstractAdaptor=NoAdaptation(),
    n_adapts::Int=min(div(n_samples, 10), 1_000);
    drop_warmup=false,
    verbose::Bool=true,
    progress::Bool=false,
)"><pre><span class="pl-k">function</span> <span class="pl-en">sample</span>(
    rng<span class="pl-k">::</span><span class="pl-c1">Union{AbstractRNG, AbstractVector{&lt;:AbstractRNG}}</span>,
    h<span class="pl-k">::</span><span class="pl-c1">Hamiltonian</span>,
    κ<span class="pl-k">::</span><span class="pl-c1">HMCKernel</span>,
    θ<span class="pl-k">::</span><span class="pl-c1">AbstractVector{&lt;:AbstractFloat}</span>,
    n_samples<span class="pl-k">::</span><span class="pl-c1">Int</span>,
    adaptor<span class="pl-k">::</span><span class="pl-c1">AbstractAdaptor</span><span class="pl-k">=</span><span class="pl-c1">NoAdaptation</span>(),
    n_adapts<span class="pl-k">::</span><span class="pl-c1">Int</span><span class="pl-k">=</span><span class="pl-c1">min</span>(<span class="pl-c1">div</span>(n_samples, <span class="pl-c1">10</span>), <span class="pl-c1">1_000</span>);
    drop_warmup<span class="pl-k">=</span><span class="pl-c1">false</span>,
    verbose<span class="pl-k">::</span><span class="pl-c1">Bool</span><span class="pl-k">=</span><span class="pl-c1">true</span>,
    progress<span class="pl-k">::</span><span class="pl-c1">Bool</span><span class="pl-k">=</span><span class="pl-c1">false</span>,
)</pre></div>
<p dir="auto">Draw <code>n_samples</code> samples using the proposal <code>κ</code> under the Hamiltonian system <code>h</code></p>
<ul dir="auto">
<li>The randomness is controlled by <code>rng</code>.
<ul dir="auto">
<li>If <code>rng</code> is not provided, <code>GLOBAL_RNG</code> will be used.</li>
</ul>
</li>
<li>The initial point is given by <code>θ</code>.</li>
<li>The adaptor is set by <code>adaptor</code>, for which the default is no adaptation.
<ul dir="auto">
<li>It will perform <code>n_adapts</code> steps of adaptation, for which the default is <code>1_000</code> or 10% of <code>n_samples</code>, whichever is lower.</li>
</ul>
</li>
<li>
<code>drop_warmup</code> specifies whether to drop samples.</li>
<li>
<code>verbose</code> controls the verbosity.</li>
<li>
<code>progress</code> controls whether to show the progress meter or not.</li>
</ul>
<p dir="auto">Note that the function signature of the <code>sample</code> function exported by <code>AdvancedHMC.jl</code> differs from the <a href="https://turing.ml/dev/docs/using-turing/guide#modelling-syntax-explained" rel="nofollow"><code>sample</code></a> function used by <code>Turing.jl</code>. We refer to the documentation of <code>Turing.jl</code> for more details on the latter.</p>
<h2 dir="auto">
<a id="user-content-citing-advancedhmcjl" class="anchor" aria-hidden="true" href="#citing-advancedhmcjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citing AdvancedHMC.jl</h2>
<p dir="auto">If you use AdvancedHMC.jl for your own research, please consider citing the following publication:</p>
<p dir="auto">Kai Xu, Hong Ge, Will Tebbutt, Mohamed Tarek, Martin Trapp, Zoubin Ghahramani: "AdvancedHMC.jl: A robust, modular and efficient implementation of advanced HMC algorithms.", <em>Symposium on Advances in Approximate Bayesian Inference</em>, 2020. (<a href="http://proceedings.mlr.press/v118/xu20a.html" rel="nofollow">abs</a>, <a href="http://proceedings.mlr.press/v118/xu20a/xu20a.pdf" rel="nofollow">pdf</a>)</p>
<p dir="auto">with the following BibTeX entry:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@inproceedings{xu2020advancedhmc,
  title={AdvancedHMC. jl: A robust, modular and efficient implementation of advanced HMC algorithms},
  author={Xu, Kai and Ge, Hong and Tebbutt, Will and Tarek, Mohamed and Trapp, Martin and Ghahramani, Zoubin},
  booktitle={Symposium on Advances in Approximate Bayesian Inference},
  pages={1--10},
  year={2020},
  organization={PMLR}
}"><pre class="notranslate"><code>@inproceedings{xu2020advancedhmc,
  title={AdvancedHMC. jl: A robust, modular and efficient implementation of advanced HMC algorithms},
  author={Xu, Kai and Ge, Hong and Tebbutt, Will and Tarek, Mohamed and Trapp, Martin and Ghahramani, Zoubin},
  booktitle={Symposium on Advances in Approximate Bayesian Inference},
  pages={1--10},
  year={2020},
  organization={PMLR}
}
</code></pre></div>
<p dir="auto">If you using AdvancedHMC.jl directly through Turing.jl, please consider citing the following publication:</p>
<p dir="auto">Hong Ge, Kai Xu, and Zoubin Ghahramani: "Turing: a language for flexible probabilistic inference.", <em>International Conference on Artificial Intelligence and Statistics</em>, 2018. (<a href="http://proceedings.mlr.press/v84/ge18b.html" rel="nofollow">abs</a>, <a href="http://proceedings.mlr.press/v84/ge18b/ge18b.pdf" rel="nofollow">pdf</a>)</p>
<p dir="auto">with the following BibTeX entry:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@inproceedings{ge2018turing,
  title={Turing: A language for flexible probabilistic inference},
  author={Ge, Hong and Xu, Kai and Ghahramani, Zoubin},
  booktitle={International Conference on Artificial Intelligence and Statistics},
  pages={1682--1690},
  year={2018},
  organization={PMLR}
}"><pre class="notranslate"><code>@inproceedings{ge2018turing,
  title={Turing: A language for flexible probabilistic inference},
  author={Ge, Hong and Xu, Kai and Ghahramani, Zoubin},
  booktitle={International Conference on Artificial Intelligence and Statistics},
  pages={1682--1690},
  year={2018},
  organization={PMLR}
}
</code></pre></div>
<h2 dir="auto">
<a id="user-content-references" class="anchor" aria-hidden="true" href="#references"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>References</h2>
<ol dir="auto">
<li>
<p dir="auto">Neal, R. M. (2011). MCMC using Hamiltonian dynamics. Handbook of Markov chain Monte Carlo, 2(11), 2. (<a href="https://arxiv.org/pdf/1206.1901" rel="nofollow">arXiv</a>)</p>
</li>
<li>
<p dir="auto">Betancourt, M. (2017). A Conceptual Introduction to Hamiltonian Monte Carlo. <a href="https://arxiv.org/abs/1701.02434" rel="nofollow">arXiv preprint arXiv:1701.02434</a>.</p>
</li>
<li>
<p dir="auto">Girolami, M., &amp; Calderhead, B. (2011). Riemann manifold Langevin and Hamiltonian Monte Carlo methods. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 73(2), 123-214. (<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2010.00765.x" rel="nofollow">arXiv</a>)</p>
</li>
<li>
<p dir="auto">Betancourt, M. J., Byrne, S., &amp; Girolami, M. (2014). Optimizing the integrator step size for Hamiltonian Monte Carlo. <a href="https://arxiv.org/pdf/1411.6669" rel="nofollow">arXiv preprint arXiv:1411.6669</a>.</p>
</li>
<li>
<p dir="auto">Betancourt, M. (2016). Identifying the optimal integration time in Hamiltonian Monte Carlo. <a href="https://arxiv.org/abs/1601.00225" rel="nofollow">arXiv preprint arXiv:1601.00225</a>.</p>
</li>
<li>
<p dir="auto">Hoffman, M. D., &amp; Gelman, A. (2014). The No-U-Turn Sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research, 15(1), 1593-1623. (<a href="http://arxiv.org/abs/1111.4246" rel="nofollow">arXiv</a>)</p>
</li>
</ol>
</article></div>