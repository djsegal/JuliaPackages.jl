<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-sparsevariablesjl" class="anchor" aria-hidden="true" href="#sparsevariablesjl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>SparseVariables.jl</h1>
<p dir="auto"><a href="https://github.com/hellemo/SparseVariables.jl/actions?query=workflow%3ACI"><img src="https://github.com/hellemo/SparseVariables.jl/workflows/CI/badge.svg?branch=main" alt="Build Status" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/hellemo/SparseVariables.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/cba964a65afa85e3ffa1b55b5c61c5761bda702ceeab1cf8c23a20530f4a96ff/68747470733a2f2f636f6465636f762e696f2f67682f68656c6c656d6f2f5370617273655661726961626c65732e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e7376673f746f6b656e3d324c5847565530345953" alt="codecov" data-canonical-src="https://codecov.io/gh/hellemo/SparseVariables.jl/branch/main/graph/badge.svg?token=2LXGVU04YS" style="max-width: 100%;"></a></p>
<p dir="auto">Add container type(s) for improved performance and easier handling of sparse data
and sparse arrays of optimizaton variables in <a href="https://jump.dev/JuMP.jl/stable/" rel="nofollow">JuMP</a>.</p>
<p dir="auto">Watch the JuliaCon/JuMP-dev 2022 lightning talk and check out the <a href="%22docs/notebook_juliacon2022.jl%22">notebook with examples and bencmarks</a>:</p>
<p dir="auto"><a href="https://youtu.be/YuDvfZo9W5A" rel="nofollow"><img src="https://camo.githubusercontent.com/dff4033d2d4e7c70809c5a5e80e1116c14966e7c0bedbb4346101fb406a4a75c/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f59754476665a6f395735412f332e6a7067" alt="SparseVariables - Efficient sparse modelling with JuMP" data-canonical-src="https://img.youtube.com/vi/YuDvfZo9W5A/3.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">2022-09: Updated benchmarks of time spent on model construction with different number of variables (see <a href="benchmark/benchmark.jl">benchmark notebook for details</a>) with additional types <code>IndexedVarArray</code> (model_indexed) and <code>SparseAxisArray</code> (model_sparse_aa) on current julia master:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="benchmark/res.svg"><img src="benchmark/res.svg" alt="" style="max-width: 100%;"></a></p>
<p dir="auto">Benchmarks with time spent on model construction with different level of sparsity:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="benchmark/sparsity.svg"><img src="benchmark/sparsity.svg" alt="" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using JuMP
using SparseVariables

const SV = SparseVariables

m = Model()

cars = [&quot;ford&quot;, &quot;bmw&quot;, &quot;opel&quot;]
years = [2000, 2001, 2002, 2003]

car_cost = SparseArray(Dict(
    (&quot;ford&quot;, 2000) =&gt; 100,
    (&quot;ford&quot;, 2001) =&gt; 150,
    (&quot;bmw&quot;, 2001) =&gt; 200,
    (&quot;bmw&quot;, 2002) =&gt; 300
    ))


# Empty variables with 2 indices and allowed index values specified
# by `car` and `year`, using `container=IndexedVarArray`
@variable(m, y[car=cars, year=years]; container=IndexedVarArray)
@variable(m, z[car=cars, year=years]; container=IndexedVarArray)
# Dynamic creation of variables
for (cr, yr) in keys(car_cost)
    insertvar!(y, cr, yr)
end

# Inserting values not in the defined value sets errors:
for c in [&quot;opel&quot;, &quot;tesla&quot;, &quot;nikola&quot;]
    insertvar!(z, c, 2002)
end

# Skip tests for allowed values for maximum performance.
# Note that this will allow creating values outside the defined
# sets, as long as the type is correct.
for c in [&quot;opel&quot;, &quot;tesla&quot;, &quot;nikola&quot;]
    unsafe_insertvar!(z, c, 2002)
end

# Inefficient iteration, but 0 contribution for non-existing variables
@constraint(m, sum(y[c,i] + z[c,i] for c in cars, i in years) &lt;= 300)

# Slicing over selected indices
@constraint(m, sum(y[:, 2000]) &lt;= 300)

# Efficient filtering using select syntax
for i in years
    @constraint(m, sum(car_cost[c,i] * y[c,i] for (c,i) in SV.select(y, :, i)) &lt;= 300)
end

# Filter using functions on indices
@constraint(m, sum(z[endswith(&quot;a&quot;), iseven]) &gt;= 1)"><pre><span class="pl-k">using</span> JuMP
<span class="pl-k">using</span> SparseVariables

<span class="pl-k">const</span> SV <span class="pl-k">=</span> SparseVariables

m <span class="pl-k">=</span> <span class="pl-c1">Model</span>()

cars <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>ford<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bmw<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>opel<span class="pl-pds">"</span></span>]
years <span class="pl-k">=</span> [<span class="pl-c1">2000</span>, <span class="pl-c1">2001</span>, <span class="pl-c1">2002</span>, <span class="pl-c1">2003</span>]

car_cost <span class="pl-k">=</span> <span class="pl-c1">SparseArray</span>(<span class="pl-c1">Dict</span>(
    (<span class="pl-s"><span class="pl-pds">"</span>ford<span class="pl-pds">"</span></span>, <span class="pl-c1">2000</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">100</span>,
    (<span class="pl-s"><span class="pl-pds">"</span>ford<span class="pl-pds">"</span></span>, <span class="pl-c1">2001</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">150</span>,
    (<span class="pl-s"><span class="pl-pds">"</span>bmw<span class="pl-pds">"</span></span>, <span class="pl-c1">2001</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">200</span>,
    (<span class="pl-s"><span class="pl-pds">"</span>bmw<span class="pl-pds">"</span></span>, <span class="pl-c1">2002</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">300</span>
    ))


<span class="pl-c"><span class="pl-c">#</span> Empty variables with 2 indices and allowed index values specified</span>
<span class="pl-c"><span class="pl-c">#</span> by `car` and `year`, using `container=IndexedVarArray`</span>
<span class="pl-c1">@variable</span>(m, y[car<span class="pl-k">=</span>cars, year<span class="pl-k">=</span>years]; container<span class="pl-k">=</span>IndexedVarArray)
<span class="pl-c1">@variable</span>(m, z[car<span class="pl-k">=</span>cars, year<span class="pl-k">=</span>years]; container<span class="pl-k">=</span>IndexedVarArray)
<span class="pl-c"><span class="pl-c">#</span> Dynamic creation of variables</span>
<span class="pl-k">for</span> (cr, yr) <span class="pl-k">in</span> <span class="pl-c1">keys</span>(car_cost)
    <span class="pl-c1">insertvar!</span>(y, cr, yr)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Inserting values not in the defined value sets errors:</span>
<span class="pl-k">for</span> c <span class="pl-k">in</span> [<span class="pl-s"><span class="pl-pds">"</span>opel<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>tesla<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>nikola<span class="pl-pds">"</span></span>]
    <span class="pl-c1">insertvar!</span>(z, c, <span class="pl-c1">2002</span>)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Skip tests for allowed values for maximum performance.</span>
<span class="pl-c"><span class="pl-c">#</span> Note that this will allow creating values outside the defined</span>
<span class="pl-c"><span class="pl-c">#</span> sets, as long as the type is correct.</span>
<span class="pl-k">for</span> c <span class="pl-k">in</span> [<span class="pl-s"><span class="pl-pds">"</span>opel<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>tesla<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>nikola<span class="pl-pds">"</span></span>]
    <span class="pl-c1">unsafe_insertvar!</span>(z, c, <span class="pl-c1">2002</span>)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Inefficient iteration, but 0 contribution for non-existing variables</span>
<span class="pl-c1">@constraint</span>(m, <span class="pl-c1">sum</span>(y[c,i] <span class="pl-k">+</span> z[c,i] <span class="pl-k">for</span> c <span class="pl-k">in</span> cars, i <span class="pl-k">in</span> years) <span class="pl-k">&lt;=</span> <span class="pl-c1">300</span>)

<span class="pl-c"><span class="pl-c">#</span> Slicing over selected indices</span>
<span class="pl-c1">@constraint</span>(m, <span class="pl-c1">sum</span>(y[:, <span class="pl-c1">2000</span>]) <span class="pl-k">&lt;=</span> <span class="pl-c1">300</span>)

<span class="pl-c"><span class="pl-c">#</span> Efficient filtering using select syntax</span>
<span class="pl-k">for</span> i <span class="pl-k">in</span> years
    <span class="pl-c1">@constraint</span>(m, <span class="pl-c1">sum</span>(car_cost[c,i] <span class="pl-k">*</span> y[c,i] <span class="pl-k">for</span> (c,i) <span class="pl-k">in</span> SV<span class="pl-k">.</span><span class="pl-c1">select</span>(y, :, i)) <span class="pl-k">&lt;=</span> <span class="pl-c1">300</span>)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Filter using functions on indices</span>
<span class="pl-c1">@constraint</span>(m, <span class="pl-c1">sum</span>(z[<span class="pl-c1">endswith</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>), iseven]) <span class="pl-k">&gt;=</span> <span class="pl-c1">1</span>)</pre></div>
<h2 dir="auto"><a id="user-content-solution-information" class="anchor" aria-hidden="true" href="#solution-information"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Solution information</h2>
<p dir="auto">The <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> support has now been <a href="https://github.com/jump-dev/JuMP.jl/pull/3104" data-hovercard-type="pull_request" data-hovercard-url="/jump-dev/JuMP.jl/pull/3104/hovercard">upstreamed to JuMP</a>, and is also supported for <code>IndexedVarArray</code>s:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using HiGHS

# Solve m
set_optimizer(m, HiGHS.Optimizer)
optimize!(m)

# Fetch solution
tab = JuMP.Containers.rowtable(value, y)

# Save to CSV
using CSV
CSV.write(&quot;result.csv&quot;, tab)

# Convert to DataFrame
using DataFrames
DataFrame(tab)

# Pretty print
using PrettyTables
pretty_table(tab)"><pre><span class="pl-k">using</span> HiGHS

<span class="pl-c"><span class="pl-c">#</span> Solve m</span>
<span class="pl-c1">set_optimizer</span>(m, HiGHS<span class="pl-k">.</span>Optimizer)
<span class="pl-c1">optimize!</span>(m)

<span class="pl-c"><span class="pl-c">#</span> Fetch solution</span>
tab <span class="pl-k">=</span> JuMP<span class="pl-k">.</span>Containers<span class="pl-k">.</span><span class="pl-c1">rowtable</span>(value, y)

<span class="pl-c"><span class="pl-c">#</span> Save to CSV</span>
<span class="pl-k">using</span> CSV
CSV<span class="pl-k">.</span><span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>result.csv<span class="pl-pds">"</span></span>, tab)

<span class="pl-c"><span class="pl-c">#</span> Convert to DataFrame</span>
<span class="pl-k">using</span> DataFrames
<span class="pl-c1">DataFrame</span>(tab)

<span class="pl-c"><span class="pl-c">#</span> Pretty print</span>
<span class="pl-k">using</span> PrettyTables
<span class="pl-c1">pretty_table</span>(tab)</pre></div>
</article></div>