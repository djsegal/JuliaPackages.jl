<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-calling-python-functions-from-the-julia-language" class="anchor" aria-hidden="true" href="#calling-python-functions-from-the-julia-language"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calling Python functions from the Julia language</h1>
<p dir="auto"><a href="https://github.com/JuliaPy/PyCall.jl/actions?query=workflow%3A%22Test+with+system+Python%22"><img src="https://github.com/JuliaPy/PyCall.jl/workflows/Test%20with%20system%20Python/badge.svg" alt="Test with system Python" style="max-width: 100%;"></a>
<a href="https://github.com/JuliaPy/PyCall.jl/actions?query=workflow%3A%22Test+with+conda%22"><img src="https://github.com/JuliaPy/PyCall.jl/workflows/Test%20with%20conda/badge.svg" alt="Test with conda" style="max-width: 100%;"></a>
<a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/P/PyCall.html" rel="nofollow"><img src="https://camo.githubusercontent.com/1041daa66b437df9464694b9547a14d58d7f0510d2089e51f45b8bb630f434f9/68747470733a2f2f6a756c696163692e6769746875622e696f2f4e616e6f736f6c646965725265706f7274732f706b676576616c5f6261646765732f502f507943616c6c2e6e616d65642e737667" alt="PkgEval" data-canonical-src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/P/PyCall.named.svg" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/JuliaPy/PyCall.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/8efa7c6c19daae2d54cc1456c1f72ca632ecba24412040fd4c941136566bc036/68747470733a2f2f636f6465636f762e696f2f67682f4a756c696150792f507943616c6c2e6a6c2f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/JuliaPy/PyCall.jl/branch/master/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">This package provides the ability to directly call and <strong>fully
interoperate with Python</strong> from <a href="https://julialang.org/" rel="nofollow">the Julia
language</a>.  You can import arbitrary Python
modules from Julia, call Python functions (with automatic conversion
of types between Julia and Python), define Python classes from Julia
methods, and share large data structures between Julia and Python
without copying them.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">Within Julia, just use the package manager to run <code>Pkg.add("PyCall")</code> to
install the files. Julia 0.7 or later is required.</p>
<p dir="auto">The latest development version of PyCall is available from
<a href="https://github.com/JuliaPy/PyCall.jl">https://github.com/JuliaPy/PyCall.jl</a>.  If you want to switch to
this after installing the package, run:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="Pkg.add(PackageSpec(name=&quot;PyCall&quot;, rev=&quot;master&quot;))
Pkg.build(&quot;PyCall&quot;)"><pre>Pkg<span class="pl-k">.</span><span class="pl-c1">add</span>(<span class="pl-c1">PackageSpec</span>(name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>PyCall<span class="pl-pds">"</span></span>, rev<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>master<span class="pl-pds">"</span></span>))
Pkg<span class="pl-k">.</span><span class="pl-c1">build</span>(<span class="pl-s"><span class="pl-pds">"</span>PyCall<span class="pl-pds">"</span></span>)</pre></div>
<p dir="auto">By default on Mac and Windows systems, <code>Pkg.add("PyCall")</code>
or <code>Pkg.build("PyCall")</code> will use the
<a href="https://github.com/Luthaf/Conda.jl">Conda.jl</a> package to install a
minimal Python distribution (via
<a href="https://conda.io/projects/conda/en/latest/glossary.html#miniconda-glossary" rel="nofollow">Miniconda</a>)
that is private to Julia (not in your <code>PATH</code>).  You can use the <code>Conda</code> Julia
package to install more Python packages, and <code>import Conda</code> to print
the <code>Conda.PYTHONDIR</code> directory where <code>python</code> was installed.
On GNU/Linux systems, PyCall will default to using
the <code>python3</code> program (if any, otherwise <code>python</code>) in your PATH.</p>
<p dir="auto">The advantage of a Conda-based configuration is particularly
compelling if you are installing PyCall in order to use packages like
<a href="https://github.com/JuliaPy/PyPlot.jl">PyPlot.jl</a> or
<a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, as these can then
automatically install their Python dependencies.  (To exploit this in
your own packages, use the <code>pyimport_conda</code> function described below.)</p>
<h3 dir="auto"><a id="user-content-specifying-the-python-version" class="anchor" aria-hidden="true" href="#specifying-the-python-version"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Specifying the Python version</h3>
<p dir="auto">If you want to use a different version of Python than the default, you
can change the Python version by setting the <code>PYTHON</code> environment variable
to the path of the <code>python</code> (or <code>python3</code> etc.) executable and then re-running <code>Pkg.build("PyCall")</code>.
In Julia:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="ENV[&quot;PYTHON&quot;] = &quot;... path of the python executable ...&quot;
# ENV[&quot;PYTHON&quot;] = raw&quot;C:\Python310-x64\python.exe&quot; # example for Windows, &quot;raw&quot; to not have to escape: &quot;C:\\Python310-x64\\python.exe&quot;

# ENV[&quot;PYTHON&quot;] = &quot;/usr/bin/python3.10&quot;           # example for *nix
Pkg.build(&quot;PyCall&quot;)"><pre class="notranslate"><code>ENV["PYTHON"] = "... path of the python executable ..."
# ENV["PYTHON"] = raw"C:\Python310-x64\python.exe" # example for Windows, "raw" to not have to escape: "C:\\Python310-x64\\python.exe"

# ENV["PYTHON"] = "/usr/bin/python3.10"           # example for *nix
Pkg.build("PyCall")
</code></pre></div>
<p dir="auto">Note also that you will need to re-run <code>Pkg.build("PyCall")</code> if your
<code>python</code> program changes significantly (e.g. you switch to a new
Python distro, or you switch from Python 2 to Python 3).</p>
<p dir="auto">To force Julia to use its own Python distribution, via Conda, simply
set <code>ENV["PYTHON"]</code> to the empty string <code>""</code> and re-run <code>Pkg.build("PyCall")</code>.</p>
<p dir="auto">The current Python version being used is stored in the <code>pyversion</code>
global variable of the <code>PyCall</code> module.  You can also look at
<code>PyCall.libpython</code> to find the name of the Python library or
<code>PyCall.pyprogramname</code> for the <code>python</code> program name.  If it is
using the Conda Python, <code>PyCall.conda</code> will be <code>true</code>.</p>
<p dir="auto">(Technically, PyCall does not use the <code>python</code> program per se: it links
directly to the <code>libpython</code> library.  But it finds the location of
<code>libpython</code> by running <code>python</code> during <code>Pkg.build</code>.)</p>
<p dir="auto">Subsequent builds of PyCall (e.g. when you update the package via
<code>Pkg.update</code>) will use the same Python executable name by default,
unless you set the <code>PYTHON</code> environment variable or delete the file
<code>Pkg.dir("PyCall","deps","PYTHON")</code>.</p>
<p dir="auto"><strong>Note:</strong> If you use Python
<a href="https://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow">virtualenvs</a>,
then be aware that PyCall <em>uses the virtualenv it was built with</em> by
default, even if you switch virtualenvs.  If you want to switch PyCall
to use a different virtualenv, then you should switch virtualenvs and
run <code>rm(Pkg.dir("PyCall","deps","PYTHON")); Pkg.build("PyCall")</code>.
Alternatively, see <a href="#python-virtual-environments">Python virtual environments</a>
section below for switching virtual environment at run-time.</p>
<p dir="auto"><strong>Note:</strong> Usually, the necessary libraries are installed along with
Python, but <a href="https://github.com/JuliaPy/PyCall.jl/issues/122" data-hovercard-type="issue" data-hovercard-url="/JuliaPy/PyCall.jl/issues/122/hovercard">pyenv on MacOS</a>
requires you to install it with <code>env PYTHON_CONFIGURE_OPTS="--enable-framework" pyenv install 3.4.3</code>.  The Enthought Canopy Python distribution is
currently <a href="https://github.com/JuliaPy/PyCall.jl/issues/42" data-hovercard-type="issue" data-hovercard-url="/JuliaPy/PyCall.jl/issues/42/hovercard">not supported</a>.
As a general rule, we tend to recommend the <a href="https://store.continuum.io/cshop/anaconda/" rel="nofollow">Anaconda Python
distribution</a> on MacOS and
Windows, or using the Julia Conda package, in order to minimize headaches.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">Here is a simple example to call Python's <code>math.sin</code> function:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using PyCall
math = pyimport(&quot;math&quot;)
math.sin(math.pi / 4) # returns ≈ 1/√2 = 0.70710678..."><pre class="notranslate"><code>using PyCall
math = pyimport("math")
math.sin(math.pi / 4) # returns ≈ 1/√2 = 0.70710678...
</code></pre></div>
<p dir="auto">Type conversions are automatically performed for numeric, boolean,
string, IO stream, date/period, and function types, along with tuples,
arrays/lists, and dictionaries of these types. (Python functions can
be converted/passed to Julia functions and vice versa!)  Other types
are supported via the generic PyObject type, below.</p>
<p dir="auto">Multidimensional arrays exploit the NumPy array interface for
conversions between Python and Julia.  By default, they are passed
from Julia to Python without making a copy, but from Python to Julia a
copy is made; no-copy conversion of Python to Julia arrays can be achieved
with the <code>PyArray</code> type below.</p>
<p dir="auto">Keyword arguments can also be passed. For example, matplotlib's
<a href="https://matplotlib.org/" rel="nofollow">pyplot</a> uses keyword arguments to specify plot
options, and this functionality is accessed from Julia by:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="plt = pyimport(&quot;matplotlib.pyplot&quot;)
x = range(0;stop=2*pi,length=1000); y = sin.(3*x + 4*cos.(2*x));
plt.plot(x, y, color=&quot;red&quot;, linewidth=2.0, linestyle=&quot;--&quot;)
plt.show()"><pre class="notranslate"><code>plt = pyimport("matplotlib.pyplot")
x = range(0;stop=2*pi,length=1000); y = sin.(3*x + 4*cos.(2*x));
plt.plot(x, y, color="red", linewidth=2.0, linestyle="--")
plt.show()
</code></pre></div>
<p dir="auto">However, for better integration with Julia graphics backends and to
avoid the need for the <code>show</code> function, we recommend using matplotlib
via the Julia <a href="https://github.com/JuliaPy/PyPlot.jl">PyPlot module</a>.</p>
<p dir="auto">Arbitrary Julia functions can be passed to Python routines taking
function arguments.  For example, to find the root of cos(x) - x,
we could call the Newton solver in scipy.optimize via:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="so = pyimport(&quot;scipy.optimize&quot;)
so.newton(x -&gt; cos(x) - x, 1)"><pre class="notranslate"><code>so = pyimport("scipy.optimize")
so.newton(x -&gt; cos(x) - x, 1)
</code></pre></div>
<p dir="auto">A macro exists for mimicking Python's "with statement". For example:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@pywith pybuiltin(&quot;open&quot;)(&quot;file.txt&quot;,&quot;w&quot;) as f begin
    f.write(&quot;hello&quot;)
end"><pre class="notranslate"><code>@pywith pybuiltin("open")("file.txt","w") as f begin
    f.write("hello")
end
</code></pre></div>
<p dir="auto">The type of <code>f</code> can be specified with <code>f::T</code> (for example, to override automatic
conversion, use <code>f::PyObject</code>). Similarly, if the context manager returns a type
which is automatically converted to a Julia type, you will have override this
via <code>@pywith EXPR::PyObject ...</code>.</p>
<p dir="auto">If you are already familiar with Python, it perhaps is easier to use
<code>py"..."</code> and <code>py"""..."""</code> which are equivalent to Python's
<a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow"><code>eval</code></a> and
<a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow"><code>exec</code></a>,
respectively:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="py&quot;&quot;&quot;
import numpy as np

def sinpi(x):
    return np.sin(np.pi * x)
&quot;&quot;&quot;
py&quot;sinpi&quot;(1)"><pre><span class="pl-c1">py</span><span class="pl-pds">"""</span><span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-k">import</span> numpy <span class="pl-k">as</span> np</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-k">def</span> <span class="pl-en">sinpi</span>(<span class="pl-smi">x</span>):</span>
<span class="pl-s1">    <span class="pl-k">return</span> np.sin(np.pi <span class="pl-k">*</span> x)</span>
<span class="pl-s1"></span><span class="pl-pds">"""</span>
<span class="pl-s"><span class="pl-pds"><span class="pl-c1">py</span>"</span>sinpi<span class="pl-pds">"</span></span>(<span class="pl-c1">1</span>)</pre></div>
<p dir="auto">You can also execute a whole script <code>"foo.py"</code> via <code>@pyinclude("foo.py")</code> as if you had pasted it into a <code>py"""..."""</code> string.</p>
<p dir="auto">When creating a Julia module, it is a useful pattern to define Python
functions or classes in Julia's <code>__init__</code> and then use it in Julia
function with <code>py"..."</code>.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="module MyModule

using PyCall

function __init__()
    py&quot;&quot;&quot;
    import numpy as np

    def one(x):
        return np.sin(x) ** 2 + np.cos(x) ** 2
    &quot;&quot;&quot;
end

two(x) = py&quot;one&quot;(x) + py&quot;one&quot;(x)

end"><pre><span class="pl-k">module</span> MyModule

<span class="pl-k">using</span> PyCall

<span class="pl-k">function</span> <span class="pl-en">__init__</span>()
    <span class="pl-c1">py</span><span class="pl-pds">"""</span><span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">import</span> numpy <span class="pl-k">as</span> np</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">def</span> <span class="pl-en">one</span>(<span class="pl-smi">x</span>):</span>
<span class="pl-s1">        <span class="pl-k">return</span> np.sin(x) <span class="pl-k">**</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> np.cos(x) <span class="pl-k">**</span> <span class="pl-c1">2</span></span>
<span class="pl-s1"></span>    <span class="pl-pds">"""</span>
<span class="pl-k">end</span>

<span class="pl-en">two</span>(x) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">py</span>"</span>one<span class="pl-pds">"</span></span>(x) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds"><span class="pl-c1">py</span>"</span>one<span class="pl-pds">"</span></span>(x)

<span class="pl-k">end</span></pre></div>
<p dir="auto">Note that Python code in <code>py"..."</code> of above example is evaluated in a
Python namespace dedicated to <code>MyModule</code>.  Thus, Python function <code>one</code>
cannot be accessed outside <code>MyModule</code>.</p>
<h2 dir="auto"><a id="user-content-troubleshooting" class="anchor" aria-hidden="true" href="#troubleshooting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Troubleshooting</h2>
<p dir="auto">Here are solutions to some common problems:</p>
<ul dir="auto">
<li>By default, PyCall <a href="https://github.com/JuliaPy/PyCall.jl/issues/48" data-hovercard-type="issue" data-hovercard-url="/JuliaPy/PyCall.jl/issues/48/hovercard">doesn't include the current directory in the Python search path</a>.   If you want to do that (in order to load a Python module from the current directory), just run <code>pushfirst!(pyimport("sys")."path", "")</code>.</li>
</ul>
<h2 dir="auto"><a id="user-content-python-object-interfaces" class="anchor" aria-hidden="true" href="#python-object-interfaces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Python object interfaces</h2>
<p dir="auto">PyCall provides many routines for
manipulating Python objects in Julia via a type <code>PyObject</code> described
below.  These can be used to have greater control over the types and
data passed between Julia and Python, as well as to access additional
Python functionality (especially in conjunction with the low-level interfaces
described later).</p>
<h3 dir="auto"><a id="user-content-types" class="anchor" aria-hidden="true" href="#types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Types</h3>
<h4 dir="auto"><a id="user-content-pyobject" class="anchor" aria-hidden="true" href="#pyobject"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PyObject</h4>
<p dir="auto">The PyCall module also provides a new type <code>PyObject</code> (a wrapper around
<code>PyObject*</code> in Python's C API) representing a reference to a Python object.</p>
<p dir="auto">Constructors <code>PyObject(o)</code> are provided for a number of Julia types,
and PyCall also supplies <code>convert(T, o::PyObject)</code> to convert
PyObjects back into Julia types <code>T</code>.  Currently, the types supported
are numbers (integer, real, and complex), booleans, strings, IO streams,
dates/periods, and functions, along with tuples and arrays/lists
thereof, but more are planned.  (Julia symbols are converted to Python
strings.)</p>
<p dir="auto">Given <code>o::PyObject</code>, <code>o.attribute</code> in Julia is equivalent to <code>o.attribute</code>
in Python, with automatic type conversion.  To get an attribute as a
<code>PyObject</code> without type conversion, do <code>o."attribute"</code> instead.
The <code>keys(o::PyObject)</code> function returns an array of the available
attribute symbols.</p>
<p dir="auto">Given <code>o::PyObject</code>, <code>get(o, key)</code> is equivalent to <code>o[key]</code> in
Python, with automatic type conversion.  To get as a <code>PyObject</code>
without type conversion, do <code>get(o, PyObject, key)</code>, or more generally
<code>get(o, SomeType, key)</code>.  You can also supply a default value to use
if the key is not found by <code>get(o, key, default)</code> or <code>get(o, SomeType, key, default)</code>.  Similarly, <code>set!(o, key, val)</code> is equivalent to
<code>o[key] = val</code> in Python, and <code>delete!(o, key)</code> is equivalent to <code>del o[key]</code> in Python.   For one or more <em>integer</em> indices, <code>o[i]</code> in Julia
is equivalent to <code>o[i-1]</code> in Python.</p>
<p dir="auto">You can call an <code>o::PyObject</code> via <code>o(args...)</code> just like in Python
(assuming that the object is callable in Python).  The explicit
<code>pycall</code> form is still useful in Julia if you want to specify the
return type.</p>
<p dir="auto"><code>pystr(o)</code> and <code>pyrepr(o)</code> are analogous to <code>str</code> and <code>repr</code> in Python, respectively.</p>
<h4 dir="auto"><a id="user-content-arrays-and-pyarray" class="anchor" aria-hidden="true" href="#arrays-and-pyarray"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Arrays and PyArray</h4>
<h5 dir="auto"><a id="user-content-from-julia-to-python" class="anchor" aria-hidden="true" href="#from-julia-to-python"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>From Julia to Python</h5>
<p dir="auto">Assuming you have NumPy installed (true by default if you use Conda),
then a Julia <code>a::Array</code> of NumPy-compatible elements is converted
by <code>PyObject(a)</code> into a NumPy wrapper for the <em>same data</em>, i.e. without
copying the data.  Julia arrays are stored in <a href="https://en.wikipedia.org/wiki/Row-major_order" rel="nofollow">column-major order</a>,
and since NumPy supports column-major arrays this is not a problem.</p>
<p dir="auto">However, the <em>default</em> ordering of NumPy arrays created in <em>Python</em> is row-major, and some Python packages will throw an error if you try to pass them column-major NumPy arrays.  To deal with this, you can use <code>PyReverseDims(a)</code> to pass a Julia array as a row-major NumPy array with the dimensions <em>reversed</em>. For example, if <code>a</code> is a 3x4x5 Julia array, then <code>PyReverseDims(a)</code> passes it as a 5x4x3 NumPy row-major array (without making a copy of the underlying data).</p>
<p dir="auto">A <code>Vector{UInt8}</code> object in Julia, by default, is converted to a Python
<code>bytearray</code> object.   If you want a <code>bytes</code> object instead, you can use
the function <code>pybytes(a)</code>.</p>
<h5 dir="auto"><a id="user-content-from-python-to-julia" class="anchor" aria-hidden="true" href="#from-python-to-julia"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>From Python to Julia</h5>
<p dir="auto">Multidimensional NumPy arrays (<code>ndarray</code>) are supported and can be
converted to the native Julia <code>Array</code> type, which makes a copy of the data.</p>
<p dir="auto">Alternatively, the PyCall module also provides a new type <code>PyArray</code> (a
subclass of <code>AbstractArray</code>) which implements a no-copy wrapper around
a NumPy array (currently of numeric types or objects only).  Just use
<code>PyArray</code> as the return type of a <code>pycall</code> returning an <code>ndarray</code>, or
call <code>PyArray(o::PyObject)</code> on an <code>ndarray</code> object <code>o</code>.  (Technically,
a <code>PyArray</code> works for any Python object that uses the NumPy array
interface to provide a data pointer and shape information.)</p>
<p dir="auto">Conversely, when passing arrays <em>to</em> Python, Julia <code>Array</code> types are
converted to <code>PyObject</code> types <em>without</em> making a copy via NumPy,
e.g. when passed as <code>pycall</code> arguments.</p>
<h4 dir="auto"><a id="user-content-pyvector" class="anchor" aria-hidden="true" href="#pyvector"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PyVector</h4>
<p dir="auto">The PyCall module provides a new type <code>PyVector</code> (a subclass of
<code>AbstractVector</code>) which implements a no-copy wrapper around an
arbitrary Python list or sequence object.  (Unlike <code>PyArray</code>, the
<code>PyVector</code> type is not limited to <code>NumPy</code> arrays, although using
<code>PyArray</code> for the latter is generally more efficient.)  Just use
<code>PyVector</code> as the return type of a <code>pycall</code> returning a list or
sequence object (including tuples), or call <code>PyVector(o::PyObject)</code> on
a sequence object <code>o</code>.</p>
<p dir="auto">A <code>v::PyVector</code> supports the usual <code>v[index]</code> referencing and assignment,
along with <code>delete!</code> and <code>pop!</code> operations.  <code>copy(v)</code> converts <code>v</code> to
an ordinary Julia <code>Vector</code>.</p>
<h4 dir="auto"><a id="user-content-pydict" class="anchor" aria-hidden="true" href="#pydict"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PyDict</h4>
<p dir="auto">Similar to <code>PyVector</code>, PyCall also provides a type <code>PyDict</code> (a subclass
of <code>Association</code>) that implements a no-copy wrapper around a Python
dictionary (or any object implementing the mapping protocol).  Just
use <code>PyDict</code> as the return type of a <code>pycall</code> returning a dictionary,
or call <code>PyDict(o::PyObject)</code> on a dictionary object <code>o</code>.  By
default, a <code>PyDict</code> is an <code>Any =&gt; Any</code> dictionary (or actually <code>PyAny =&gt; PyAny</code>) that performs runtime type inference, but if your Python
dictionary has known, fixed types you can instead use <code>PyDict{K,V}</code> given
the key and value types <code>K</code> and <code>V</code> respectively.</p>
<p dir="auto">Currently, passing Julia dictionaries to Python makes a copy of the Julia
dictionary.</p>
<h4 dir="auto"><a id="user-content-pytextio" class="anchor" aria-hidden="true" href="#pytextio"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PyTextIO</h4>
<p dir="auto">Julia <code>IO</code> streams are converted into Python objects implementing the
<a href="https://docs.python.org/3/library/io.html#io.RawIOBase" rel="nofollow">RawIOBase</a>
interface, so they can be used for binary I/O in Python.  However,
some Python code (notably unpickling) expects a stream implementing
the
<a href="https://docs.python.org/3/library/io.html#io.TextIOBase" rel="nofollow">TextIOBase</a>
interface, which differs from RawIOBase mainly in that <code>read</code> an
<code>readall</code> functions return strings rather than byte arrays.  If you
need to pass an <code>IO</code> stream as a text-IO object, just call
<code>PyTextIO(io::IO)</code> to convert it.</p>
<p dir="auto">(There doesn't seem to be any good way to determine automatically
whether Python wants a stream argument to return strings or binary
data.  Also, unlike Python, Julia does not open files separately in
"text" or "binary" modes, so we cannot determine the conversion simply
from how the file was opened.)</p>
<h4 dir="auto"><a id="user-content-pyany" class="anchor" aria-hidden="true" href="#pyany"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>PyAny</h4>
<p dir="auto">The <code>PyAny</code> type is used in conversions to tell PyCall to detect the
Python type at runtime and convert to the corresponding native Julia
type.  That is, <code>pycall(func, PyAny, ...)</code> and <code>convert(PyAny, o::PyObject)</code> both automatically convert their result to a native
Julia type (if possible).   This is convenient, but will lead
to slightly worse performance (due to the overhead of runtime type-checking
and the fact that the Julia JIT compiler can no longer infer the type).</p>
<h3 dir="auto"><a id="user-content-calling-python" class="anchor" aria-hidden="true" href="#calling-python"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calling Python</h3>
<p dir="auto">In most cases, PyCall automatically makes the
appropriate type conversions to Julia types based on runtime
inspection of the Python objects.  However greater control over these
type conversions (e.g. to use a no-copy <code>PyArray</code> for a Python
multidimensional array rather than copying to an <code>Array</code>) can be
achieved by using the lower-level functions below.  Using <code>pycall</code> in
cases where the Python return type is known can also improve
performance, both by eliminating the overhead of runtime type inference
and also by providing more type information to the Julia compiler.</p>
<ul dir="auto">
<li>
<p dir="auto"><code>pycall(function::PyObject, returntype::Type, args...)</code>.   Call the given
Python <code>function</code> (typically looked up from a module) with the given
<code>args...</code> (of standard Julia types which are converted automatically to
the corresponding Python types if possible), converting the return value
to <code>returntype</code> (use a <code>returntype</code> of <code>PyObject</code> to return the unconverted
Python object reference, or of <code>PyAny</code> to request an automated conversion).
For convenience, a macro <code>@pycall</code> exists which automatically converts
<code>@pycall function(args...)::returntype</code> into
<code>pycall(function,returntype,args...)</code>.</p>
</li>
<li>
<p dir="auto"><code>py"..."</code> evaluates <code>"..."</code> as Python code, equivalent to
Python's <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow"><code>eval</code></a> function, and returns the result
converted to <code>PyAny</code>.  Alternatively, <code>py"..."o</code> returns the raw <code>PyObject</code>
(which can then be manually converted if desired).   You can interpolate
Julia variables and other expressions into the Python code (except for into
Python strings contained in Python code), with <code>$</code>,
which interpolates the <em>value</em> (converted to <code>PyObject</code>) of the given
expression---data is not passed as a string, so this is different from
ordinary Julia string interpolation.  e.g. <code>py"sum($([1,2,3]))"</code> calls the
Python <code>sum</code> function on the Julia array <code>[1,2,3]</code>, returning <code>6</code>.
In contrast, if you use <code>$$</code> before the interpolated expression, then
the value of the expression is inserted as a string into the Python code,
allowing you to generate Python code itself via Julia expressions.
For example, if <code>x="1+1"</code> in Julia, then <code>py"$x"</code> returns the string <code>"1+1"</code>,
but <code>py"$$x"</code> returns <code>2</code>.
If you use <code>py"""..."""</code> to pass a <em>multi-line</em> string, the string can
contain arbitrary Python code (not just a single expression) to be evaluated,
but the return value is <code>nothing</code>; this is useful e.g. to define pure-Python
functions, and is equivalent to Python's
<a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow"><code>exec</code></a> function.
(If you define a Python global <code>g</code> in a multiline <code>py"""..."""</code>
string, you can retrieve it in Julia by subsequently evaluating <code>py"g"</code>.)</p>
<p dir="auto">When <code>py"..."</code> is used inside a Julia module, it uses a Python namespace
dedicated to this Julia module.  Thus, you can define Python function
using <code>py"""...."""</code> in your module without worrying about name clash
with other Python code.  Note that Python functions <em>must</em> be defined in
<code>__init__</code>.  Side-effect in Python occurred at top-level Julia scope
cannot be used at run-time for precompiled modules.</p>
<p dir="auto">You can also execute a Python script file <code>"foo.py"</code> by running <code>@pyinclude("foo.py")</code>, and it will be as if you had pasted the
script into a <code>py"..."</code> string.  (<code>@pyinclude</code> does not support
interpolating Julia variables with <code>$var</code>, however — the script
must be pure Python.)</p>
</li>
<li>
<p dir="auto"><code>pybuiltin(s)</code>: Look up <code>s</code> (a string or symbol) among the global Python
builtins.  If <code>s</code> is a string it returns a <code>PyObject</code>, while if <code>s</code> is a
symbol it returns the builtin converted to <code>PyAny</code>.  (You can also use <code>py"s"</code>
to look up builtins or other Python globals.)</p>
</li>
</ul>
<p dir="auto">Occasionally, you may need to pass a keyword argument to Python that
is a <a href="https://en.wikipedia.org/wiki/Reserved_word" rel="nofollow">reserved word</a> in Julia.
For example, calling <code>f(x, function=g)</code> will fail because <code>function</code> is
a reserved word in Julia. In such cases, you can use the lower-level
Julia syntax <code>f(x; :function=&gt;g)</code>.</p>
<h3 dir="auto"><a id="user-content-calling-julia-from-python" class="anchor" aria-hidden="true" href="#calling-julia-from-python"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Calling Julia from Python</h3>
<p dir="auto">Julia functions get converted to callable Python objects, so you
can easily call Julia from Python via callback function arguments.
The <a href="https://github.com/JuliaPy/pyjulia">pyjulia module</a> allows you
to call Julia directly from Python, and also uses PyCall to do its
conversions.</p>
<p dir="auto">A Julia function <code>f(args...)</code> is ordinarily converted to a callable
Python object <code>p(args...)</code> that first converts its Python arguments
into Julia arguments by the default <code>PyAny</code> conversion, calls <code>f</code>,
then converts the Julia return value of <code>f</code> back into a Python object
with the default <code>PyObject(...)</code> conversion.    However, you can
exert lower-level control over these argument/return conversions
by calling <code>pyfunction(f, ...)</code> or <code>pyfunctionret(f, ...)</code>; see the
documentation <code>?pyfunction</code> and <code>?pyfunctionret</code> for more information.</p>
<h3 dir="auto"><a id="user-content-defining-python-classes" class="anchor" aria-hidden="true" href="#defining-python-classes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Defining Python Classes</h3>
<p dir="auto"><code>@pydef</code> creates a Python class whose methods are implemented in Julia.
For instance,</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="P = pyimport(&quot;numpy.polynomial&quot;)
@pydef mutable struct Doubler &lt;: P.Polynomial
    function __init__(self, x=10)
        self.x = x
    end
    my_method(self, arg1::Number) = arg1 + 20
    x2.get(self) = self.x * 2
    function x2.set!(self, new_val)
        self.x = new_val / 2
    end
end
Doubler().x2"><pre class="notranslate"><code>P = pyimport("numpy.polynomial")
@pydef mutable struct Doubler &lt;: P.Polynomial
    function __init__(self, x=10)
        self.x = x
    end
    my_method(self, arg1::Number) = arg1 + 20
    x2.get(self) = self.x * 2
    function x2.set!(self, new_val)
        self.x = new_val / 2
    end
end
Doubler().x2
</code></pre></div>
<p dir="auto">is essentially equivalent to the following Python code:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="import numpy.polynomial
class Doubler(numpy.polynomial.Polynomial):
    def __init__(self, x=10):
        self.x = x
    def my_method(self, arg1): return arg1 + 20
    @property
    def x2(self): return self.x * 2
    @x2.setter
    def x2(self, new_val):
        self.x = new_val / 2
Doubler().x2"><pre class="notranslate"><code>import numpy.polynomial
class Doubler(numpy.polynomial.Polynomial):
    def __init__(self, x=10):
        self.x = x
    def my_method(self, arg1): return arg1 + 20
    @property
    def x2(self): return self.x * 2
    @x2.setter
    def x2(self, new_val):
        self.x = new_val / 2
Doubler().x2
</code></pre></div>
<p dir="auto">The method arguments and return values are automatically converted between Julia and Python. All Python special methods are supported (<code>__len__</code>, <code>__add__</code>, etc.).</p>
<p dir="auto"><code>@pydef</code> allows for multiple inheritance of Python classes:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@pydef mutable struct SomeType &lt;: (BaseClass1, BaseClass2)
    ...
end"><pre class="notranslate"><code>@pydef mutable struct SomeType &lt;: (BaseClass1, BaseClass2)
    ...
end
</code></pre></div>
<p dir="auto">Here's another example using <a href="https://wiki.python.org/moin/TkInter" rel="nofollow">Tkinter</a>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using PyCall
tk = pyimport(&quot;Tkinter&quot;)

@pydef mutable struct SampleApp &lt;: tk.Tk
    __init__(self, args...; kwargs...) = begin
        tk.Tk.__init__(self, args...; kwargs...)
        self.label = tk.Label(text=&quot;Hello, world!&quot;)
        self.label.pack(padx=10, pady=10)
    end
end

app = SampleApp()
app.mainloop()"><pre class="notranslate"><code>using PyCall
tk = pyimport("Tkinter")

@pydef mutable struct SampleApp &lt;: tk.Tk
    __init__(self, args...; kwargs...) = begin
        tk.Tk.__init__(self, args...; kwargs...)
        self.label = tk.Label(text="Hello, world!")
        self.label.pack(padx=10, pady=10)
    end
end

app = SampleApp()
app.mainloop()
</code></pre></div>
<p dir="auto">Class variables are also supported:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="using PyCall
@pydef mutable struct ObjectCounter
    obj_count = 0 # Class variable
    function __init__(::PyObject)
        ObjectCounter.obj_count += 1
    end
end"><pre class="notranslate"><code>using PyCall
@pydef mutable struct ObjectCounter
    obj_count = 0 # Class variable
    function __init__(::PyObject)
        ObjectCounter.obj_count += 1
    end
end
</code></pre></div>
<h3 dir="auto"><a id="user-content-gui-event-loops" class="anchor" aria-hidden="true" href="#gui-event-loops"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GUI Event Loops</h3>
<p dir="auto">For Python packages that have a graphical user interface (GUI),
notably plotting packages like matplotlib (or MayaVi or Chaco), it is
convenient to start the GUI event loop (which processes things like
mouse clicks) as an asynchronous task within Julia, so that the GUI is
responsive without blocking Julia's input prompt.  PyCall includes
functions to implement these event loops for some of the most common
cross-platform <a href="https://en.wikipedia.org/wiki/Widget_toolkit" rel="nofollow">GUI
toolkits</a>:
<a href="http://www.wxwidgets.org/" rel="nofollow">wxWidgets</a>, <a href="http://www.gtk.org/" rel="nofollow">GTK+</a>
version 2 (via <a href="http://www.pygtk.org/" rel="nofollow">PyGTK</a>) or version 3 (via
<a href="https://pygobject.readthedocs.io/en/latest/" rel="nofollow">PyGObject</a>), and
<a href="http://qt-project.org/" rel="nofollow">Qt</a> (via the <a href="https://wiki.python.org/moin/PyQt4" rel="nofollow">PyQt4</a>
or <a href="http://qt-project.org/wiki/PySide" rel="nofollow">PySide</a> Python modules).</p>
<p dir="auto">You can set a GUI event loop via:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>pygui_start(gui::Symbol=pygui())</code>.  Here, <code>gui</code> is either <code>:wx</code>,
<code>:gtk</code>, <code>:gtk3</code>, <code>:tk</code>, or <code>:qt</code> to start the respective toolkit's
event loop.  (<code>:qt</code> will use PyQt4 or PySide, preferring the former;
if you need to require one or the other you can instead use
<code>:qt_pyqt4</code> or <code>:qt_pyside</code>, respectively.) It defaults to the
return value of <code>pygui()</code>, which returns a current default GUI (see
below).  Passing a <code>gui</code> argument also changes the default GUI,
equivalent to calling <code>pygui(gui)</code> below.  You may start event loops
for more than one GUI toolkit (to run simultaneously).  Calling
<code>pygui_start</code> more than once for a given toolkit does nothing
(except to change the current <code>pygui</code> default).</p>
</li>
<li>
<p dir="auto"><code>pygui()</code>: return the current default GUI toolkit (<code>Symbol</code>).  If
the default GUI has not been set already, this is the first of
<code>:tk</code>, <code>:qt</code>, <code>:wx</code>, <code>:gtk</code>, or <code>:gtk3</code> for which the corresponding
Python package is installed.  <code>pygui(gui::Symbol)</code> changes the
default GUI to <code>gui</code>.</p>
</li>
<li>
<p dir="auto"><code>pygui_stop(gui::Symbol=pygui())</code>: Stop any running event loop for <code>gui</code>
(which defaults to the current return value of <code>pygui</code>).  Returns
<code>true</code> if an event loop was running, and <code>false</code> otherwise.</p>
</li>
</ul>
<p dir="auto">To use these GUI facilities with some Python libraries, it is enough
to simply start the appropriate toolkit's event-loop before importing
the library.  However, in other cases it is necessary to explicitly
tell the library which GUI toolkit to use and that an interactive mode
is desired.  To make this even easier, it is convenient to have
wrapper modules around popular Python libraries, such as the <a href="https://github.com/JuliaPy/PyPlot.jl">PyPlot
module</a> for Julia.</p>
<h3 dir="auto"><a id="user-content-low-level-python-api-access" class="anchor" aria-hidden="true" href="#low-level-python-api-access"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Low-level Python API access</h3>
<p dir="auto">If you want to call low-level functions in the Python C API, you can
do so using <code>ccall</code>.</p>
<ul dir="auto">
<li>
<p dir="auto">Use <code>@pysym(func::Symbol)</code> to get a function pointer to pass to <code>ccall</code>
given a symbol <code>func</code> in the Python API.  e.g. you can call
<code>int Py_IsInitialized()</code> by <code>ccall(@pysym(:Py_IsInitialized), Int32, ())</code>.</p>
</li>
<li>
<p dir="auto">PyCall defines the typealias <code>PyPtr</code> for <code>PythonObject*</code> argument types,
and <code>PythonObject</code> (see above) arguments are correctly converted to this
type.  <code>PythonObject(p::PyPtr)</code> creates a Julia wrapper around a
<code>PyPtr</code> return value.</p>
</li>
<li>
<p dir="auto">Use <code>PyObject</code> and the <code>convert</code> routines mentioned above to convert
Julia types to/from <code>PyObject*</code> references.</p>
</li>
<li>
<p dir="auto">If a new reference is returned by a Python function, immediately
convert the <code>PyPtr</code> return values to <code>PythonObject</code> objects in order to
have their Python reference counts decremented when the object is
garbage collected in Julia.  i.e. <code>PythonObject(ccall(func, PyPtr, ...))</code>.
<strong>Important</strong>: for Python routines that return a borrowed reference,
you should instead do <code>pyincref(PyObject(...))</code> to obtain a new
reference.</p>
</li>
<li>
<p dir="auto">You can call <code>pyincref(o::PyObject)</code> and <code>pydecref(o::PyObject)</code> to
manually increment/decrement the reference count.  This is sometimes
needed when low-level functions steal a reference or return a borrowed one.</p>
</li>
<li>
<p dir="auto">The function <code>pyerr_check(msg::AbstractString)</code> can be used to check if a
Python exception was thrown, and throw a Julia exception (which includes
both <code>msg</code> and the Python exception object) if so.  The Python
exception status may be cleared by calling <code>pyerr_clear()</code>.</p>
</li>
<li>
<p dir="auto">The function <code>pytype_query(o::PyObject)</code> returns a native Julia
type that <code>o</code> can be converted into, if possible, or <code>PyObject</code> if not.</p>
</li>
<li>
<p dir="auto"><code>pyisinstance(o::PyObject, t::Symbol)</code> can be used to query whether
<code>o</code> is of a given Python type (where <code>t</code> is the identifier of a global
<code>PyTypeObject</code> in the Python C API), e.g. <code>pyisinstance(o, :PyDict_Type)</code>
checks whether <code>o</code> is a Python dictionary.  Alternatively,
<code>pyisinstance(o::PyObject, t::PyObject)</code> performs the same check
given a Python type object <code>t</code>.  <code>pytypeof(o::PyObject)</code> returns the
Python type of <code>o</code>, equivalent to <code>type(o)</code> in Python.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-using-pycall-from-julia-modules" class="anchor" aria-hidden="true" href="#using-pycall-from-julia-modules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using PyCall from Julia Modules</h3>
<p dir="auto">You can use PyCall from any Julia code, including within Julia modules. However, some care is required when using PyCall from <a href="https://docs.julialang.org/en/latest/manual/modules/#module-initialization-and-precompilation" rel="nofollow">precompiled Julia modules</a>. The key thing to remember is that <em>all Python objects</em> (any <code>PyObject</code>) contain <em>pointers</em> to memory allocated by the Python runtime, and such pointers <em>cannot be saved</em> in precompiled constants.   (When a precompiled library is reloaded, these pointers will not contain valid memory addresses.)</p>
<p dir="auto">The solution is fairly simple:</p>
<ul dir="auto">
<li>
<p dir="auto">Python objects that you create in functions called <em>after</em> the module is loaded are always safe.</p>
</li>
<li>
<p dir="auto">If you want to store a Python object in a global variable that is initialized automatically when the module is loaded, then initialize the variable in your module's <code>__init__</code> function.  For a type-stable global constant, initialize the constant to <code>PyNULL()</code> at the top level, and then use the <code>copy!</code> function in your module's <code>__init__</code> function to mutate it to its actual value.</p>
</li>
</ul>
<p dir="auto">For example, suppose your module uses the <code>scipy.optimize</code> module, and you want to load this module when your module is loaded and store it in a global constant <code>scipy_opt</code>.  You could do:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="__precompile__() # this module is safe to precompile
module MyModule
using PyCall

const scipy_opt = PyNULL()

function __init__()
    copy!(scipy_opt, pyimport_conda(&quot;scipy.optimize&quot;, &quot;scipy&quot;))
end

end"><pre><span class="pl-c1">__precompile__</span>() <span class="pl-c"><span class="pl-c">#</span> this module is safe to precompile</span>
<span class="pl-k">module</span> MyModule
<span class="pl-k">using</span> PyCall

<span class="pl-k">const</span> scipy_opt <span class="pl-k">=</span> <span class="pl-c1">PyNULL</span>()

<span class="pl-k">function</span> <span class="pl-en">__init__</span>()
    <span class="pl-c1">copy!</span>(scipy_opt, <span class="pl-c1">pyimport_conda</span>(<span class="pl-s"><span class="pl-pds">"</span>scipy.optimize<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>scipy<span class="pl-pds">"</span></span>))
<span class="pl-k">end</span>

<span class="pl-k">end</span></pre></div>
<p dir="auto">Then you can access the <code>scipy.optimize</code> functions as <code>scipy_opt.newton</code>
and so on.</p>
<p dir="auto">Here, instead of <code>pyimport</code>, we have used the function <code>pyimport_conda</code>.   The second argument is the name of the <a href="https://docs.continuum.io/anaconda/pkg-docs" rel="nofollow">Anaconda package</a> that provides this module.   This way, if importing <code>scipy.optimize</code> fails because the user hasn't installed <code>scipy</code>, it will either (a) automatically install <code>scipy</code> and retry the <code>pyimport</code> if PyCall is configured to use the <a href="https://github.com/Luthaf/Conda.jl">Conda</a> Python install (or
any other Anaconda-based Python distro for which the user has installation privileges), or (b) throw an error explaining that <code>scipy</code> needs to be installed, and explain how to configure PyCall to use Conda so that it can be installed automatically.   More generally, you can call <code>pyimport_conda(module, package, channel)</code> to specify an optional Anaconda "channel" for installing non-standard Anaconda packages.</p>
<h2 dir="auto"><a id="user-content-python-virtual-environments" class="anchor" aria-hidden="true" href="#python-virtual-environments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Python virtual environments</h2>
<p dir="auto">Python virtual environments created by <a href="https://docs.python.org/3/library/venv.html" rel="nofollow"><code>venv</code></a> and <a href="https://virtualenv.pypa.io/en/latest/" rel="nofollow"><code>virtualenv</code></a>
can be used from <code>PyCall</code>, <em>provided that the Python executable used
in the virtual environment is linked against the same <code>libpython</code> used
by <code>PyCall</code></em>.  Note that virtual environments created by <code>conda</code> are not
supported.</p>
<p dir="auto">To use <code>PyCall</code> with a certain virtual environment, set the environment
variable <code>PYCALL_JL_RUNTIME_PYTHON</code> <em>before</em> importing <code>PyCall</code> to
path to the Python executable.  For example:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="$ source PATH/TO/bin/activate  # activate virtual environment in system shell

$ julia  # start Julia
...

julia&gt; ENV[&quot;PYCALL_JL_RUNTIME_PYTHON&quot;] = Sys.which(&quot;python&quot;)
&quot;PATH/TO/bin/python3&quot;

julia&gt; using PyCall

julia&gt; pyimport(&quot;sys&quot;).executable
&quot;PATH/TO/bin/python3&quot;"><pre><span class="pl-k">$</span> source PATH<span class="pl-k">/</span>TO<span class="pl-k">/</span>bin<span class="pl-k">/</span>activate  <span class="pl-c"><span class="pl-c">#</span> activate virtual environment in system shell</span>

<span class="pl-k">$</span> julia  <span class="pl-c"><span class="pl-c">#</span> start Julia</span>
<span class="pl-k">...</span>

julia<span class="pl-k">&gt;</span> <span class="pl-c1">ENV</span>[<span class="pl-s"><span class="pl-pds">"</span>PYCALL_JL_RUNTIME_PYTHON<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> Sys<span class="pl-k">.</span><span class="pl-c1">which</span>(<span class="pl-s"><span class="pl-pds">"</span>python<span class="pl-pds">"</span></span>)
<span class="pl-s"><span class="pl-pds">"</span>PATH/TO/bin/python3<span class="pl-pds">"</span></span>

julia<span class="pl-k">&gt;</span> <span class="pl-k">using</span> PyCall

julia<span class="pl-k">&gt;</span> <span class="pl-c1">pyimport</span>(<span class="pl-s"><span class="pl-pds">"</span>sys<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>executable
<span class="pl-s"><span class="pl-pds">"</span>PATH/TO/bin/python3<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">Similarly, the <code>PYTHONHOME</code> path can be changed by the environment variable
<code>PYCALL_JL_RUNTIME_PYTHONHOME</code>.</p>
<h2 dir="auto"><a id="user-content-author" class="anchor" aria-hidden="true" href="#author"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Author</h2>
<p dir="auto">This package was written by <a href="https://math.mit.edu/~stevenj/" rel="nofollow">Steven G. Johnson</a>.</p>
</article></div>