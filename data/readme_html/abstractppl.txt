<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-abstractppljl" class="anchor" aria-hidden="true" href="#abstractppljl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>AbstractPPL.jl</h1>
<p dir="auto"><a href="https://github.com/TuringLang/AbstractPPL.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/TuringLang/AbstractPPL.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="CI" style="max-width: 100%;"></a>
<a href="https://github.com/TuringLang/AbstractPPL.jl/actions/workflows/IntegrationTest.yml?query=branch%3Amain"><img src="https://github.com/TuringLang/AbstractPPL.jl/actions/workflows/IntegrationTest.yml/badge.svg?branch=main" alt="IntegrationTest" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/TuringLang/AbstractPPL.jl?branch=main" rel="nofollow"><img src="https://camo.githubusercontent.com/bc540bb403d35ca7fc210fb137659693c60791cea9002aa26274c01367a61039/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f547572696e674c616e672f416273747261637450504c2e6a6c2f62616467652e7376673f6272616e63683d6d61696e" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/TuringLang/AbstractPPL.jl/badge.svg?branch=main" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/TuringLang/AbstractPPL.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/9af9e57a7dd3debbd53ce7803d076321d159a98b29a1f83cd2bee322c7c45f80/68747470733a2f2f636f6465636f762e696f2f67682f547572696e674c616e672f416273747261637450504c2e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Codecov" data-canonical-src="https://codecov.io/gh/TuringLang/AbstractPPL.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<p dir="auto">A light-weight package to factor out interfaces and associated APIs for modelling languages for
probabilistic programming.  High level goals are:</p>
<ul dir="auto">
<li>Definition of an interface of few abstract types and a small set of functions that should be
supported by all <a href="./src/abstractprobprog.jl">probabilistic programs</a> and <a href="./src/abstractmodeltrace.jl">trace
types</a>.</li>
<li>Provision of some commonly used functionality and data structures, e.g., for managing <a href="./src/varname.jl">variable names</a> and
traces.</li>
</ul>
<p dir="auto">This should facilitate reuse of functions in modelling languages, to allow end users to handle
models in a consistent way, and to simplify interaction between different languages and sampler
implementations, from very rich, dynamic languages like Turing.jl to highly constrained or
simplified models such as GPs, GLMs, or plain log-density problems.</p>
<p dir="auto">A more short term goal is to start a process of cleanly refactoring and justifying parts of
DynamicPPL.jl’s design, and hopefully to get on closer terms with Soss.jl.</p>
<h2 dir="auto"><a id="user-content-abstractprobabilisticprogram-interface-still-somewhat-drafty" class="anchor" aria-hidden="true" href="#abstractprobabilisticprogram-interface-still-somewhat-drafty"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>AbstractProbabilisticProgram</code> interface (still somewhat drafty)</h2>
<p dir="auto">There are at least two somewhat incompatible conventions used for the term “model”.  None of this is
particularly exact, but:</p>
<ul dir="auto">
<li>In Turing.jl, if you write down a <code>@model</code> function and call it on arguments, you get a model
object paired with (a possibly empty set of) observations. This can be treated as instantiated
“conditioned” object with fixed values for parameters and observations.</li>
<li>In Soss.jl, “model” is used for a symbolic “generative” object from which concrete functions, such as
densities and sampling functions, can be derived, <em>and</em> which you can later condition on (and in
turn get a conditional density etc.).</li>
</ul>
<p dir="auto">Relevant discussions:
<a href="https://julialang.zulipchat.com/#narrow/stream/234072-probprog/topic/Naming.20the.20.22likelihood.22.20thingy" rel="nofollow">1</a>,
<a href="https://github.com/TuringLang/AbstractPPL.jl/discussions/10" data-hovercard-type="discussion" data-hovercard-url="/TuringLang/AbstractPPL.jl/discussions/10/hovercard">2</a>.</p>
<h3 dir="auto"><a id="user-content-tldr" class="anchor" aria-hidden="true" href="#tldr"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>TL/DR:</h3>
<p dir="auto">There are three interrelating aspects that this interface intends to standardize:</p>
<ul dir="auto">
<li>Density calculation</li>
<li>Sampling</li>
<li>“Conversions” between different conditionings of models</li>
</ul>
<p dir="auto">Therefore, the interface consists of an <code>AbstractProbabilisticProgram</code> supertype, together with
functions</p>
<ul dir="auto">
<li><code>condition(::Model, ::Trace) -&gt; ConditionedModel</code></li>
<li><code>decondition(::ConditionedModel) -&gt; GenerativeModel</code></li>
<li><code>sample(::Model, ::Sampler = Exact(), [Int])</code> (from <code>AbstractMCMC.sample</code>)</li>
<li><code>logdensityof(::Model, ::Trace)</code> and <code>densityof(::Model, ::Trace)</code> (from
<a href="https://github.com/JuliaMath/DensityInterface.jl">DensityInterface.jl</a>)</li>
</ul>
<h3 dir="auto"><a id="user-content-traces--probability-expressions" class="anchor" aria-hidden="true" href="#traces--probability-expressions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Traces &amp; probability expressions</h3>
<p dir="auto">First, an infrastructural requirement which we will need below to write things out.</p>
<p dir="auto">The kinds of models we consider are, at least in a theoretical sense, distributions over <em>traces</em> –
types which carry collections of values together with their names.  Existing realizations of these
are <code>VarInfo</code> in Turing.jl, choice maps in Gen.jl, and the usage of named tuples in Soss.jl.</p>
<p dir="auto">Traces solve the problem of having to name random variables in function calls, and in samples from
models.  In essence, every concrete trace type will just be a fancy kind of dictionary from variable
names (ideally, <code>VarName</code>s) to values.</p>
<p dir="auto">Since we have to use this kind of mapping a lot in the specification of the interface, let’s for now
just choose some arbitrary macro-like syntax like the following:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="@T(Y[1] = …, Z = …)"><pre><span class="pl-c1">@T</span>(Y[<span class="pl-c1">1</span>] <span class="pl-k">=</span> …, Z <span class="pl-k">=</span> …)</pre></div>
<p dir="auto">Some more ideas for this kind of object can be found at the end.</p>
<h3 dir="auto"><a id="user-content-conversions" class="anchor" aria-hidden="true" href="#conversions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>“Conversions”</h3>
<p dir="auto">The purpose of this part is to provide common names for how we want a model instance to be
understood.  As we have seen, in some modelling languages, model instances are primarily generative,
with some parameters fixed, while other instance types pair model instances conditioned on
observations.  What I call “conversions” here is just an interface to transform between these two
views and unify the involved objects under one language.</p>
<p dir="auto">Let’s start from a generative model with parameter <code>μ</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# (hypothetical) generative spec a la Soss
@generative_model function foo_gen(μ)
    X ~ Normal(0, μ)
    Y[1] ~ Normal(X)
    Y[2] ~ Normal(X + 1)
end"><pre><span class="pl-c"><span class="pl-c">#</span> (hypothetical) generative spec a la Soss</span>
<span class="pl-c1">@generative_model</span> <span class="pl-k">function</span> <span class="pl-en">foo_gen</span>(μ)
    X <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>, μ)
    Y[<span class="pl-c1">1</span>] <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(X)
    Y[<span class="pl-c1">2</span>] <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(X <span class="pl-k">+</span> <span class="pl-c1">1</span>)
<span class="pl-k">end</span></pre></div>
<p dir="auto">Applying the “constructor” <code>foo_gen</code> now means to fix the parameter, and should return a concrete
object of the generative type:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g = foo_gen(μ=…)::SomeGenerativeModel"><pre>g <span class="pl-k">=</span> <span class="pl-c1">foo_gen</span>(μ<span class="pl-k">=</span>…)<span class="pl-k">::</span><span class="pl-c1">SomeGenerativeModel</span></pre></div>
<p dir="auto">With this kind of object, we should be able to sample and calculate joint log-densities from, i.e.,
over the combined trace space of <code>X</code>, <code>Y[1]</code>, and <code>Y[2]</code> – either directly, or by deriving the
respective functions (e.g., by converting form a symbolic representation).</p>
<p dir="auto">For model types that contain enough structural information, it should then be possible to condition
on observed values and obtain a conditioned model:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="condition(g, @T(Y = …))::SomeConditionedModel"><pre><span class="pl-c1">condition</span>(g, <span class="pl-c1">@T</span>(Y <span class="pl-k">=</span> …))<span class="pl-k">::</span><span class="pl-c1">SomeConditionedModel</span></pre></div>
<p dir="auto">For this operation, there will probably exist syntactic sugar in the form of</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g | @T(Y = …)"><pre>g <span class="pl-k">|</span> <span class="pl-c1">@T</span>(Y <span class="pl-k">=</span> …)</pre></div>
<p dir="auto">Now, if we start from a Turing.jl-like model instead, with the “observation part” already specified,
we have a situation like this, with the observations <code>Y</code> fixed in the instantiation:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# conditioned spec a la DPPL
@model function foo(Y, μ)
    X ~ Normal(0, μ)
    Y[1] ~ Normal(X)
    Y[2] ~ Normal(X + 1)
end

m = foo(Y=…, μ=…)::SomeConditionedModel"><pre><span class="pl-c"><span class="pl-c">#</span> conditioned spec a la DPPL</span>
<span class="pl-c1">@model</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(Y, μ)
    X <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(<span class="pl-c1">0</span>, μ)
    Y[<span class="pl-c1">1</span>] <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(X)
    Y[<span class="pl-c1">2</span>] <span class="pl-k">~</span> <span class="pl-c1">Normal</span>(X <span class="pl-k">+</span> <span class="pl-c1">1</span>)
<span class="pl-k">end</span>

m <span class="pl-k">=</span> <span class="pl-c1">foo</span>(Y<span class="pl-k">=</span>…, μ<span class="pl-k">=</span>…)<span class="pl-k">::</span><span class="pl-c1">SomeConditionedModel</span></pre></div>
<p dir="auto">From this we can, if supported, go back to the generative form via <code>decondition</code>, and back via
<code>condition</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="decondition(m) == g::SomeGenerativeModel
m == condition(g, @T(Y = …))"><pre><span class="pl-c1">decondition</span>(m) <span class="pl-k">==</span> g<span class="pl-k">::</span><span class="pl-c1">SomeGenerativeModel</span>
m <span class="pl-k">==</span> <span class="pl-c1">condition</span>(g, <span class="pl-c1">@T</span>(Y <span class="pl-k">=</span> …))</pre></div>
<p dir="auto">(with equality in distribution).</p>
<p dir="auto">In the case of Turing.jl, the object <code>m</code> would at the same time contain the information about the
generative and posterior distribution <code>condition</code> and <code>decondition</code> can simply return different
kinds of “tagged” model types which put the model specification into a certain context.</p>
<p dir="auto">Soss.jl pretty much already works like the examples above, with one model object being either a
<code>JointModel</code> or a <code>ConditionedModel</code>, and the <code>|</code> syntax just being sugar for the latter.</p>
<p dir="auto">A hypothetical <code>DensityModel</code>, or something like the types from LogDensityProblems.jl, would be a
case for a model type that does not support the structural operations <code>condition</code> and
<code>decondition</code>.</p>
<p dir="auto">The invariances between these operations should follow normal rules of probability theory.  Not all
methods or directions need to be supported for every modelling language; in this case, a
<code>MethodError</code> or some other runtime error should be raised.</p>
<p dir="auto">There is no strict requirement for generative models and conditioned models to have different types
or be tagged with variable names etc.  This is a choice to be made by the concrete implementation.</p>
<p dir="auto">Decomposing models into prior and observation distributions is not yet specified; the former is
rather easy, since it is only a marginal of the generative distribution, while the latter requires
more structural information.  Perhaps both can be generalized under the <code>query</code> function I discuss
at the end.</p>
<h3 dir="auto"><a id="user-content-sampling" class="anchor" aria-hidden="true" href="#sampling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Sampling</h3>
<p dir="auto">Sampling in this case refers to producing values from the distribution specified in a model
instance, either following the distribution exactly, or approximating it through a Monte Carlo
algorithm.</p>
<p dir="auto">All sampleable model instances are assumed to implement the <code>AbstractMCMC</code> interface – i.e., at
least <a href="https://github.com/TuringLang/AbstractMCMC.jl#sampling-step"><code>step</code></a>, and accordingly
<code>sample</code>, <code>steps</code>, <code>Samples</code>.  The most important aspect is <code>sample</code>, though, which plays the role
of <code>rand</code> for distributions.</p>
<p dir="auto">The results of <code>sample</code> generalize <code>rand</code> – while <code>rand(d, N)</code> is assumed to give you iid samples,
<code>sample(m, sampler, N)</code> returns a sample from a sequence (known as chain in the case of MCMC) of
length <code>N</code> approximating <code>m</code>’s distribution by a specific sampling algorithm (which of course
subsumes the case that <code>m</code> can be sampled from exactly, in which case the “chain” actually is iid).</p>
<p dir="auto">Depending on which kind of sampling is supported, several methods may be supported.  In the case of
a (posterior) conditioned model with no known sampling procedure, we just have what is given through
<code>AbstractMCMC</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sample([rng], m, N, sampler; [args…]) # chain of length N using `sampler`"><pre><span class="pl-c1">sample</span>([rng], m, N, sampler; [args…]) <span class="pl-c"><span class="pl-c">#</span> chain of length N using `sampler`</span></pre></div>
<p dir="auto">In the case of a generative model, or a posterior model with exact solution, we can have some more
methods without the need to specify a sampler:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sample([rng], m; [args…])    # one random sample
sample([rng], m, N; [args…]) # N iid samples; equivalent to `rand` in certain cases"><pre><span class="pl-c1">sample</span>([rng], m; [args…])    <span class="pl-c"><span class="pl-c">#</span> one random sample</span>
<span class="pl-c1">sample</span>([rng], m, N; [args…]) <span class="pl-c"><span class="pl-c">#</span> N iid samples; equivalent to `rand` in certain cases</span></pre></div>
<p dir="auto">It should be possible to implement this by a special sampler, say, <code>Exact</code> (name still to be
discussed), that can then also be reused for generative sampling:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="step(g, spl = Exact(), state = nothing) # IID sample from exact distribution with trivial state
sample(g, Exact(), [N]) "><pre class="notranslate"><code>step(g, spl = Exact(), state = nothing) # IID sample from exact distribution with trivial state
sample(g, Exact(), [N]) 
</code></pre></div>
<p dir="auto">with dispatch failing for models types for which exact sampling is not possible (or not
implemented).</p>
<p dir="auto">This could even be useful for Monte Carlo methods not being based on Markov Chains, e.g.,
particle-based sampling using a return type with weights, or rejection sampling.</p>
<p dir="auto">Not all variants need to be supported – for example, a posterior model might not support
<code>sample(m)</code> when exact sampling is not possible, only <code>sample(m, N, alg)</code> for Markov chains.</p>
<p dir="auto"><code>rand</code> is then just a special case when “trivial” exact sampling works for a model, e.g. a joint
model.</p>
<h3 dir="auto"><a id="user-content-density-evaluation" class="anchor" aria-hidden="true" href="#density-evaluation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Density Evaluation</h3>
<p dir="auto">Since the different “versions” of how a model is to be understood as generative or conditioned are
to be expressed in the type or dispatch they support, there should be no need for separate functions
<code>logjoint</code>, <code>loglikelihood</code>, etc., which force these semantic distinctions on the implementor; we
therefore adapt the interface of
<a href="https://github.com/JuliaMath/DensityInterface.jl">DensityInterface.jl</a>.  Its main function
<code>logdensityof</code> should suffice for variants, with the distinction being made by the capabilities of
the concrete model instance.</p>
<p dir="auto">DensityInterface.jl also requires the trait function <code>DensityKind</code>, which is set to <code>HasDensity()</code>
for the <code>AbstractProbabilisticProgram</code> type.  Additional functions</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="DensityInterface.densityof(d, x) = exp(logdensityof(d, x))
DensityInterface.logdensityof(d) = Base.Fix1(logdensityof, d)
DensityInterface.densityof(d) = Base.Fix1(densityof, d)"><pre class="notranslate"><code>DensityInterface.densityof(d, x) = exp(logdensityof(d, x))
DensityInterface.logdensityof(d) = Base.Fix1(logdensityof, d)
DensityInterface.densityof(d) = Base.Fix1(densityof, d)
</code></pre></div>
<p dir="auto">are provided automatically (repeated here for clarity).</p>
<p dir="auto">Note that <code>logdensityof</code> strictly generalizes <code>logpdf</code>, since the posterior density will of course
in general be unnormalized and hence not a probability density.</p>
<p dir="auto">The evaluation will usually work with the internal, concrete trace type, like <code>VarInfo</code> in
Turing.jl:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="logdensityof(m, vi)"><pre><span class="pl-c1">logdensityof</span>(m, vi)</pre></div>
<p dir="auto">But the user will more likely work on the interface using probability expressions:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="logdensityof(m, @T(X = …))"><pre><span class="pl-c1">logdensityof</span>(m, <span class="pl-c1">@T</span>(X <span class="pl-k">=</span> …))</pre></div>
<p dir="auto">(Note that this would replace the current <code>prob</code> string macro in Turing.jl.)</p>
<p dir="auto">Densities need (and usually, will) not be normalized.</p>
<h4 dir="auto"><a id="user-content-implementation-notes" class="anchor" aria-hidden="true" href="#implementation-notes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementation notes</h4>
<p dir="auto">It should be able to make this fall back on the internal method with the right definition and
implementation of <code>maketrace</code>:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="logdensityof(m, t::ProbabilityExpression) = logdensityof(m, maketrace(m, t))"><pre><span class="pl-en">logdensityof</span>(m, t<span class="pl-k">::</span><span class="pl-c1">ProbabilityExpression</span>) <span class="pl-k">=</span> <span class="pl-c1">logdensityof</span>(m, <span class="pl-c1">maketrace</span>(m, t))</pre></div>
<p dir="auto">There is one open question – should normalized and unnormalized densities be able to be
distinguished?  This could be done by dispatch as well, e.g., if the caller wants to make sure
normalization:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="logdensityof(g, @T(X = …, Y = …, Z = …); normalized=Val{true})"><pre class="notranslate"><code>logdensityof(g, @T(X = …, Y = …, Z = …); normalized=Val{true})
</code></pre></div>
<p dir="auto">Although there is proably a better way through traits; maybe like for arrays, with
<code>NormalizationStyle(g, t) = IsNormalized()</code>?</p>
<h2 dir="auto"><a id="user-content-more-on-probability-expressions" class="anchor" aria-hidden="true" href="#more-on-probability-expressions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>More on probability expressions</h2>
<p dir="auto">Note that this needs to be a macro, if written this way, since the keys may themselves be more
complex than just symbols (e.g., indexed variables.)  (Don’t hang yourselves up on that <code>@T</code> name
though, this is just a working draft.)</p>
<p dir="auto">The idea here is to standardize the construction (and manipulation) of <em>abstract probability
expressions</em>, plus the interface for turning them into concrete traces for a specific model – like
<a href="https://juliastats.org/StatsModels.jl/stable/formula/#Modeling-tabular-data" rel="nofollow"><code>@formula</code></a> and
<a href="https://juliastats.org/StatsModels.jl/stable/internals/#Semantics-time-(apply_schema)" rel="nofollow"><code>apply_schema</code></a>
from StatsModels.jl are doing.</p>
<p dir="auto">Maybe the following would suffice to do that:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="maketrace(m, t)::tracetype(m, t)"><pre><span class="pl-c1">maketrace</span>(m, t)<span class="pl-k">::</span><span class="pl-c1">tracetype</span>(m, t)</pre></div>
<p dir="auto">where <code>maketrace</code> produces a concrete trace corresponding to <code>t</code> for the model <code>m</code>, and <code>tracetype</code>
is the corresponding <code>eltype</code>–like function giving you the concrete trace type for a certain model
and probability expression combination.</p>
<p dir="auto">Possible extensions of this idea:</p>
<ul dir="auto">
<li>Pearl-style do-notation: <code>@T(Y = y | do(X = x))</code></li>
<li>Allowing free variables, to specify model transformations: <code>query(m, @T(X | Y))</code></li>
<li>“Graph queries”: <code>@T(X | Parents(X))</code>, <code>@T(Y | Not(X))</code> (a nice way to express Gibbs conditionals!)</li>
<li>Predicate style for “measure queries”: <code>@T(X &lt; Y + Z)</code></li>
</ul>
<p dir="auto">The latter applications are the reason I originally liked the idea of the macro being called <code>@P</code>
(or even <code>@𝓅</code> or <code>@ℙ</code>), since then it would look like a “Bayesian probability expression”: <code>@P(X &lt; Y + Z)</code>.  But this would not be so meaningful in the case of representing a trace instance.</p>
<p dir="auto">Perhaps both <code>@T</code> and <code>@P</code> can coexist, and both produce different kinds of <code>ProbabilityExpression</code>
objects?</p>
<p dir="auto">NB: the exact details of this kind of “schema application”, and what results from it, will need to
be specified in the interface of <code>AbstractModelTrace</code>, aka “the new <code>VarInfo</code>”.</p>
<h1 dir="auto"><a id="user-content-abstractmodeltracevarinfo-interface-draft" class="anchor" aria-hidden="true" href="#abstractmodeltracevarinfo-interface-draft"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>AbstractModelTrace</code>/<code>VarInfo</code> interface draft</h1>
<p dir="auto"><strong>This part is even draftier than the above – we’ll try out things in DynamicPPL.jl first</strong></p>
<h2 dir="auto"><a id="user-content-background" class="anchor" aria-hidden="true" href="#background"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Background</h2>
<h3 dir="auto"><a id="user-content-why-do-we-do-this" class="anchor" aria-hidden="true" href="#why-do-we-do-this"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Why do we do this?</h3>
<p dir="auto">As I have said before:</p>
<blockquote>
<p dir="auto">There are many aspects that make VarInfo a very complex data structure.</p>
</blockquote>
<p dir="auto">Currently, there is an insane amount of complexity and implementation details in DynamicPPL.jl’s
<code>varinfo.jl</code>, which has been rewritten multiple times with different concerns in mind – most times
to improve concrete needs of Turing.jl, such as type stability, or requirements of specific
samplers.</p>
<p dir="auto">This unfortunately makes <code>VarInfo</code> extremely opaque: it is hard to refactor without breaking
anything (nobody really dares touching it), and a lot of knowledge about Turing.jl/DynamicPPL.jl
internals is needed in order to judge the effects of changes.</p>
<h3 dir="auto"><a id="user-content-design-choices" class="anchor" aria-hidden="true" href="#design-choices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Design choices</h3>
<p dir="auto">Recently, @torfjelde <a href="https://github.com/TuringLang/DynamicPPL.jl/pull/267/files">has shown</a> that a
much simpler implementation is feasible – basically, just a wrapped <code>NamedTuple</code> with a minimal
interface.</p>
<p dir="auto">The purpose of this proposal is twofold: first, to think about what a sufficient interface for
<code>AbstractModelTrace</code>, the abstract supertype of <code>VarInfo</code>, should be, to allow multiple specialized
variants and refactor the existing ones (typed/untyped and simple).  Second, to view the problem as
the design of an abstract data type: the specification of construction and modification mechanisms
for a dictionary-like structure.</p>
<p dir="auto">Related previous discussions:</p>
<ul dir="auto">
<li><a href="https://github.com/TuringLang/AbstractPPL.jl/discussions/7" data-hovercard-type="discussion" data-hovercard-url="/TuringLang/AbstractPPL.jl/discussions/7/hovercard">Discussion about <code>VarName</code></a></li>
<li><a href="https://github.com/TuringLang/AbstractPPL.jl/discussions/5" data-hovercard-type="discussion" data-hovercard-url="/TuringLang/AbstractPPL.jl/discussions/5/hovercard"><code>AbstractVarInfo</code> representation</a></li>
</ul>
<p dir="auto">Additionally (but closely related), the second part tries to formalize the “subsumption” mechanism
of <code>VarName</code>s, and its interaction with using <code>VarName</code>s as keys/indices.</p>
<p dir="auto">Our discussions take place in what is a bit of a fuzzy zone between the part that is really
“abstract”, and meant for the wider purpuse of AbstractPPL.jl – the implementation of probabilistic
programming systems in general – and our concrete needs within DPPL.  I hope to always stay abstract
and reusable; and there are already a couple of candidates for APPL clients other than DPPL, which
will hopefully keep us focused: simulation based calibration, SimplePPL (a BUGS-like frontend), and
ParetoSmoothing.jl.</p>
<h3 dir="auto"><a id="user-content-what-is-going-to-change" class="anchor" aria-hidden="true" href="#what-is-going-to-change"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What is going to change?</h3>
<ul dir="auto">
<li>For the end user of Turing.jl: nothing.  You usually don’t use <code>VarInfo</code>, or the raw evaluator
interface, anyways.  (Although if the newer data structures are more user-friendly, they might occur
in more places in the future?)</li>
<li>For people having a look into code using <code>VarInfo</code>, or starting to hack on Turing.jl/DPPL.jl: a
huge reduction in cognitive complexity.  <code>VarInfo</code> implementations should be readable on their own,
and the implemented functions layed out somewhere.  Its usages should look like for any other nice,
normal data structure.</li>
<li>For core DPPL.jl implementors: same as the previous, plus: a standard against which to improve and
test <code>VarInfo</code>, and a clearly defined design space for new data structures.</li>
<li>For AbstractPPL.jl clients/PPL implementors: an interface to program against (as with the rest of
APPL), and an existing set of well-specified, flexible trace data types with different
characteristics.</li>
</ul>
<p dir="auto">And in terms of implementation work in DPPL.jl: once the interface is fixed (or even during fixing
it), varinfo.jl will undergo a heavy refactoring – which should make it <em>simpler</em>! (No three
different getter functions with slightly different semantics, etc…).</p>
<h2 dir="auto"><a id="user-content-property-interface" class="anchor" aria-hidden="true" href="#property-interface"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Property interface</h2>
<p dir="auto">The basic idea is for all <code>VarInfo</code>s to behave like ordered dictionaries with <code>VarName</code> keys – all
common operations should just work.  There are two things that make them more special, though:</p>
<ol dir="auto">
<li>
<p dir="auto">“Fancy indexing”: since <code>VarName</code>s are structured themselves, the <code>VarInfo</code> should be have a bit
like a trie, in the sense that all prefixes of stored keys should be retrievable.  Also,
subsumption of <code>VarName</code>s should be respected (see end of this document):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vi[@varname(x.a)] = [1,2,3]
vi[@varname(x.b)] = [4,5,6]
vi[@varname(x.a[2])] == 2
vi[@varname(x)] == (; a = [1,2,3], b = [4,5,6])"><pre>vi[<span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a)] <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]
vi[<span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>b)] <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>]
vi[<span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a[<span class="pl-c1">2</span>])] <span class="pl-k">==</span> <span class="pl-c1">2</span>
vi[<span class="pl-c1">@varname</span>(x)] <span class="pl-k">==</span> (; a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>], b <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>])</pre></div>
<p dir="auto">Generalizations that go beyond simple cases (those that you can imagine by storing individual
<code>setfield!</code>s in a tree) need not be implemented in the beginning; e.g.,</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vi[@varname(x[1])] = 1
vi[@varname(x[2])] = 2
keys(vi) == [x[1], x[2]]

vi[@varname(x)] = [1,2]
keys(vi) == [x]"><pre>vi[<span class="pl-c1">@varname</span>(x[<span class="pl-c1">1</span>])] <span class="pl-k">=</span> <span class="pl-c1">1</span>
vi[<span class="pl-c1">@varname</span>(x[<span class="pl-c1">2</span>])] <span class="pl-k">=</span> <span class="pl-c1">2</span>
<span class="pl-c1">keys</span>(vi) <span class="pl-k">==</span> [x[<span class="pl-c1">1</span>], x[<span class="pl-c1">2</span>]]

vi[<span class="pl-c1">@varname</span>(x)] <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>]
<span class="pl-c1">keys</span>(vi) <span class="pl-k">==</span> [x]</pre></div>
</li>
<li>
<p dir="auto">(<em>This has to be discussed further.</em>)  Information other than the sampled values, such as flags,
metadata, pointwise likelihoods, etc., can in principle be stored in multiple of these “<code>VarInfo</code>
dicts” with parallel structure.  For efficiency, it is thinkable to devise a design such that
multiple fields can be stored under the same indexing structure.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vi[@varname(x[1])] == 1
vi[@varname(x[1])].meta[&quot;bla&quot;] == false"><pre>vi[<span class="pl-c1">@varname</span>(x[<span class="pl-c1">1</span>])] <span class="pl-k">==</span> <span class="pl-c1">1</span>
vi[<span class="pl-c1">@varname</span>(x[<span class="pl-c1">1</span>])]<span class="pl-k">.</span>meta[<span class="pl-s"><span class="pl-pds">"</span>bla<span class="pl-pds">"</span></span>] <span class="pl-k">==</span> <span class="pl-c1">false</span></pre></div>
<p dir="auto">or something in that direction.</p>
<p dir="auto">(This is logically equivalent to a dictionary with named tuple values.  Maybe we can do what
<a href="https://github.com/JuliaData/TypedTables.jl/blob/main/src/DictTable.jl"><code>DictTable</code></a> does?)</p>
<p dir="auto">The old <code>order</code> field, indicating at which position in the evaluator function a variable has
been added (essentially a counter of insertions) can actually be left out completely, since the
dictionary is specified to be ordered by insertion.</p>
<p dir="auto">The important question here is: should the “joint data structure” behave like a dictionary of
<code>NamedTuple</code>s (<code>eltype(vi) == @NamedTuple{value::T, ℓ::Float64, meta}</code>), or like a struct of
dicts with shared keys (<code>eltype(vi.value) &lt;: T</code>, <code>eltype(vi.ℓ) &lt;: Float64</code>, …)?</p>
</li>
</ol>
<p dir="auto">The required dictionary functions are about the following:</p>
<ul dir="auto">
<li>Pure functions:
<ul dir="auto">
<li><code>iterate</code>, yielding pairs of <code>VarName</code> and the stored value</li>
<li><code>IteratorEltype == HasEltype()</code>, <code>IteratorSize = HasLength()</code></li>
<li><code>keys</code>, <code>values</code>, <code>pairs</code>, <code>length</code> consistent with <code>iterate</code></li>
<li><code>eltype</code>, <code>keytype</code>, <code>valuetype</code></li>
<li><code>get</code>, <code>getindex</code>, <code>haskey</code> for indexing by <code>VarName</code></li>
<li><code>merge</code> to join two <code>VarInfo</code>s</li>
</ul>
</li>
<li>Mutating functions:
<ul dir="auto">
<li><code>insert!!</code>, <code>set!!</code></li>
<li><code>merge!!</code> to add and join elements (TODO: think about <code>merge</code>)</li>
<li><code>setindex!!</code></li>
<li><code>empty!!</code>, <code>delete!!</code>, <code>unset!!</code> (<em>Are these really used anywhere? Not having them makes persistent
implementations much easier!</em>)</li>
</ul>
</li>
</ul>
<p dir="auto">I believe that adopting the interface of
<a href="https://github.com/andyferris/Dictionaries.jl">Dictionaries.jl</a>, not <code>Base.AbstractDict</code>, would be
ideal, since their approach make key sharing and certain operations naturally easy (particularly
“broadcast-style”, i.e., transformations on the values, but not the keys).</p>
<p dir="auto">Other <code>Base</code> functions, like <code>enumerate</code>, should follow from the above.</p>
<p dir="auto"><code>length</code> might appear weird – but it should definitely be consistent with the iterator.</p>
<p dir="auto">It would be really cool if <code>merge</code> supported the combination of distinct types of implementations,
e.g., a dynamic and a tuple-based part.</p>
<p dir="auto">To support both mutable and immutable/persistent implementations, let’s require consistent
BangBang.jl style mutators throughout.</p>
<h2 dir="auto"><a id="user-content-transformationsbijectors" class="anchor" aria-hidden="true" href="#transformationsbijectors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Transformations/Bijectors</h2>
<p dir="auto">Transformations should ideally be handled explicitely and from outside: automatically by the
compiler macro, or at the places required by samplers.</p>
<p dir="auto">Implementation-wise, they can probably be expressed as folds?</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="map(v -&gt; link(v.dist, v.value), vi)"><pre><span class="pl-c1">map</span>(v <span class="pl-k">-&gt;</span> <span class="pl-c1">link</span>(v<span class="pl-k">.</span>dist, v<span class="pl-k">.</span>value), vi)</pre></div>
<h2 dir="auto"><a id="user-content-linearization" class="anchor" aria-hidden="true" href="#linearization"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Linearization</h2>
<p dir="auto">There are multiple possible approaches to handle this:</p>
<ol dir="auto">
<li>As a special case of conversion: <code>Vector(vi)</code></li>
<li><code>copy!(vals_array, vi)</code>.</li>
<li>As a fold: <code>mapreduce(v -&gt; vec(v.value), append!, vi, init=Float64[])</code></li>
</ol>
<p dir="auto">Also here, I think that the best implementation would be through a fold.  Variants (1) or (2) might
additionally be provided as syntactic sugar.</p>
<hr>
<h1 dir="auto"><a id="user-content-varname-based-axioms" class="anchor" aria-hidden="true" href="#varname-based-axioms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>VarName</code>-based axioms</h1>
<p dir="auto">What follows is mostly an attempt to formalize subsumption.</p>
<p dir="auto">First, remember that in Turing.jl we can always work with <em>concretized</em> <code>VarName</code>s: <code>begin</code>/<code>end</code>,
<code>:</code>, and boolean indexing are all turned into some form of concrete cartesian or array indexing
(assuming <a href="https://github.com/TuringLang/AbstractPPL.jl/issues/35" data-hovercard-type="issue" data-hovercard-url="/TuringLang/AbstractPPL.jl/issues/35/hovercard">this suggestion</a> being
implemented).  This makes all index comparisons static.</p>
<p dir="auto">Now, <code>VarName</code>s have a compositional structure: they can be built by composing a root variable with
more and more lenses (<code>VarName{v}()</code> starts off with an <code>IdentityLens</code>):</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="julia&gt; vn = VarName{:x}() ∘ Setfield.IndexLens((1:10, 1) ∘ Setfield.IndexLens((2, )))
x[1:10,1][2]"><pre>julia<span class="pl-k">&gt;</span> vn <span class="pl-k">=</span> <span class="pl-c1">VarName</span><span class="pl-c1">{:x}</span>() <span class="pl-k">∘</span> Setfield<span class="pl-k">.</span><span class="pl-c1">IndexLens</span>((<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>, <span class="pl-c1">1</span>) <span class="pl-k">∘</span> Setfield<span class="pl-k">.</span><span class="pl-c1">IndexLens</span>((<span class="pl-c1">2</span>, )))
x[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>,<span class="pl-c1">1</span>][<span class="pl-c1">2</span>]</pre></div>
<p dir="auto">(<em>Note that the composition function, <code>∘</code>, is really in wrong order; but this is a heritage of
Setfield.jl.</em>)</p>
<p dir="auto">By “subsumption”, we mean the notion of a <code>VarName</code> expressing a more nested path than another one:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="subsumes(@varname(x.a), @varname(x.a[1]))
@varname(x.a) ⊒ @varname(x.a[1]) # \sqsupseteq
@varname(x.a) ⋢ @varname(x.a[1]) # \nsqsubseteq"><pre><span class="pl-c1">subsumes</span>(<span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a), <span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a[<span class="pl-c1">1</span>]))
<span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a) ⊒ <span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a[<span class="pl-c1">1</span>]) <span class="pl-c"><span class="pl-c">#</span> \sqsupseteq</span>
<span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a) ⋢ <span class="pl-c1">@varname</span>(x<span class="pl-k">.</span>a[<span class="pl-c1">1</span>]) <span class="pl-c"><span class="pl-c">#</span> \nsqsubseteq</span></pre></div>
<p dir="auto">Thus, we have the following axioms for <code>VarName</code>s (“variables” are <code>VarName{n}()</code>):</p>
<ol dir="auto">
<li><code>x ⊑ x</code> for all variables <code>x</code></li>
<li><code>x ≍ y</code> for <code>x ≠ y</code> (i.e., distinct variables are incomparable; <code>x ⋢ y</code> and <code>y ⋢ x</code>) (<code>≍</code> is <code>\asymp</code>)</li>
<li><code>x ∘ ℓ ⊑ x</code> for all variables <code>x</code> and lenses <code>ℓ</code></li>
<li><code>x ∘ ℓ₁ ⊑ x ∘ ℓ₂ ⇔ ℓ₁ ⊑ ℓ₂</code></li>
</ol>
<p dir="auto">For the last axiom to work, we also have to define subsumption of individual, non-composed lenses:</p>
<ol dir="auto">
<li><code>PropertyLens(a) == PropertyLens(b) ⇔ a == b</code>, for all symbols <code>a</code>, <code>b</code></li>
<li><code>FunctionLens(f) == FunctionLens(g) ⇔ f == g</code> (under extensional equality; I’m only mentioning
this in case we ever generalize to Bijector-ed variables like <code>@varname(log(x))</code>)</li>
<li><code>IndexLens(ι₁) ⊑ IndexLens(ι₂)</code> if the index tuple <code>ι₂</code> covers all indices in <code>ι₁</code>; for example,
<code>_[1, 2:10] ⊑ _[1:10, 1:20]</code>.  (<em>This is a bit fuzzy and not all corner cases have been
considered yet!</em>)</li>
<li><code>IdentityLens() == IdentityLens()</code></li>
<li><code>ℓ₁ ≍ ℓ₂</code>, otherwise</li>
</ol>
<p dir="auto">Together, this should make <code>VarName</code>s under subsumption a reflexive poset.</p>
<p dir="auto">The fundamental requirement for <code>VarInfo</code>s is then:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="vi[x ∘ ℓ] == get(vi[x], ℓ)"><pre class="notranslate"><code>vi[x ∘ ℓ] == get(vi[x], ℓ)
</code></pre></div>
<p dir="auto">So we always want the following to work, automatically:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vi = insert!!(vi, vn, x)
vi[vn] == x"><pre>vi <span class="pl-k">=</span> <span class="pl-c1">insert!!</span>(vi, vn, x)
vi[vn] <span class="pl-k">==</span> x</pre></div>
<p dir="auto">(the trivial case), and</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="x = set!!(x, ℓ₁, a)
x = set!!(x, ℓ₂, b)
vi = insert!!(vi, vn, x)
vi[vn ∘ ℓ₁] == a
vi[vn ∘ ℓ₂] == b"><pre>x <span class="pl-k">=</span> <span class="pl-c1">set!!</span>(x, ℓ₁, a)
x <span class="pl-k">=</span> <span class="pl-c1">set!!</span>(x, ℓ₂, b)
vi <span class="pl-k">=</span> <span class="pl-c1">insert!!</span>(vi, vn, x)
vi[vn <span class="pl-k">∘</span> ℓ₁] <span class="pl-k">==</span> a
vi[vn <span class="pl-k">∘</span> ℓ₂] <span class="pl-k">==</span> b</pre></div>
<p dir="auto">since <code>vn</code> subsumes both <code>vn ∘ ℓ₁</code> and <code>vn ∘ ℓ₂</code>.</p>
<p dir="auto">Whether the opposite case is supported may depend on the implementation.  The most complicated part
is “unification”:</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vi = insert!!(vi, vn ∘ ℓ₁, a)
vi = insert!!(vi, vn ∘ ℓ₂, b)
get(vi[vn], ℓ₁) == a
get(vi[vn], ℓ₂) == b"><pre>vi <span class="pl-k">=</span> <span class="pl-c1">insert!!</span>(vi, vn <span class="pl-k">∘</span> ℓ₁, a)
vi <span class="pl-k">=</span> <span class="pl-c1">insert!!</span>(vi, vn <span class="pl-k">∘</span> ℓ₂, b)
<span class="pl-c1">get</span>(vi[vn], ℓ₁) <span class="pl-k">==</span> a
<span class="pl-c1">get</span>(vi[vn], ℓ₂) <span class="pl-k">==</span> b</pre></div>
<p dir="auto">where <code>vn ∘ ℓ₁</code> and <code>vn ∘ ℓ₂</code> need to be recognized as “children” of a common parent <code>vn</code>.</p>
</article></div>