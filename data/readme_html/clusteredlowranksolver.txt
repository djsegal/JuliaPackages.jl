<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><h1 dir="auto"><a id="user-content-clusteredlowranksolver" class="anchor" aria-hidden="true" href="#clusteredlowranksolver"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>ClusteredLowRankSolver</h1>
<p dir="auto"><a href="https://nanleij.github.io/ClusteredLowRankSolver.jl/stable" rel="nofollow"><img src="https://camo.githubusercontent.com/c97f0a5f2ae95755f64a27f1aa8d9a17462941fd3d6c907c7630abd5d3e60acf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d737461626c652d626c75652e737667" alt="" data-canonical-src="https://img.shields.io/badge/docs-stable-blue.svg" style="max-width: 100%;"></a>
<a href="https://nanleij.github.io/ClusteredLowRankSolver.jl/dev" rel="nofollow"><img src="https://camo.githubusercontent.com/7fcec4b2d3ab291529fce8ef6a4fcd4129a0683b2f5d5fe2f5c648f02db8b616/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d6465762d626c75652e737667" alt="Dev" data-canonical-src="https://img.shields.io/badge/docs-dev-blue.svg" style="max-width: 100%;"></a>
<a href="https://codecov.io/gh/nanleij/ClusteredLowRankSolver.jl" rel="nofollow"><img src="https://camo.githubusercontent.com/66df0a568009762f989e188938b674415d26662b9fd95e410414af8804dd28a1/68747470733a2f2f636f6465636f762e696f2f67682f6e616e6c65696a2f436c757374657265644c6f7752616e6b536f6c7665722e6a6c2f6272616e63682f6d61696e2f67726170682f62616467652e737667" alt="Coverage" data-canonical-src="https://codecov.io/gh/nanleij/ClusteredLowRankSolver.jl/branch/main/graph/badge.svg" style="max-width: 100%;"></a></p>
<h2 dir="auto"><a id="user-content-clustered-low-rank-semidefinite-programs" class="anchor" aria-hidden="true" href="#clustered-low-rank-semidefinite-programs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Clustered Low-Rank Semidefinite Programs</h2>
<p dir="auto">A clustered low-rank semidefinite program is a semidefinite program in equality form including free scalar variables, where the constraint matrices corresponding to positive semidefinite variables have a low-rank structure. The program is clustered in the sense that two constraints in different clusters do not use the same positive semidefinite matrix variables.
An example where such a clustered low-rank SDP appears is by sampling (low-rank) sums-of-squares constraints. In the interface we focus on this application.</p>
<h2 dir="auto"><a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">After installing Julia, run Julia and install the package with e.g.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="]add ClusteredLowRankSolver"><pre class="notranslate"><code>]add ClusteredLowRankSolver
</code></pre></div>
<p dir="auto">Press <code>backspace</code> to go back to the REPL from the package environment.</p>
<h2 dir="auto"><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">Use the package with <code>using ClusteredLowRankSolver</code>. See the <a href="https://nanleij.github.io/ClusteredLowRankSolver.jl/stable" rel="nofollow">documentation</a> for instructions on using the interface. Below we show how to model a small polynomial optimization problem.</p>
<p dir="auto">To use <code>n</code> threads, start Julia with the option <code>-t n</code>.
On Windows using multiple threads may lead to crashes or wrong answers when using free variables.</p>
<h2 dir="auto"><a id="user-content-examples" class="anchor" aria-hidden="true" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">Consider the problem of finding the minimum of a univariate polynomial p(x) over [-1,1], i.e., the maximal λ such that p(x)-λ &gt;=0. Relaxing the constraint gives p(x)-λ = s_1(x) + (1-x^2) * s_2(x) , i.e., s_1(x) + (1-x^2) * s_2(x) + λ = p where s_i are sum-of-squares polynomials.</p>
<div class="highlight highlight-source-julia notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="using ClusteredLowRankSolver, AbstractAlgebra
using BasesAndSamples # To generate the samples

# Set up the polynomial space and define the polynomial to be optimized:
R, (x,) = PolynomialRing(RealField,[&quot;x&quot;])
p = 1-x-x^3+x^6
# The degree of the basis for the sums-of-squares polynomials we want to use:
d = 3

# For the constraint we consider the part for the free variables and the part for the
# positive semidefinite matrix variables separately
free_dict = Dict(λ =&gt; 1)  

# The matrix variables come from the sum-of-squares parts, since s_i(x) is a sum-of-squares
# if and only if s_i(x) = ⟨b(x)b(x)^T, Y⟩ for some Y ⪰ 0 and vector of basis polynomials b(x)
matrix_dict = Dict()
# Both SOS parts have the same total degree, but different weights
matrix_dict[Block(:SOS1)] = LowRankMatPol([R(1)], [[x^k for k=0:d]])
matrix_dict[Block(:SOS2)] = LowRankMatPol([1-x^2], [[x^k for k=0:d-1]])

# Chebyshev points in [-1,1]:
samples = sample_points_chebyshev(2d)
# Create the constraint:
con = Constraint(p, matrix_dict, free_dict, samples)

# we want to maximize λ
obj = Objective(0, Dict(), Dict(λ =&gt; 1))

# Maximize the objective with constraint `con`
sos = LowRankSOSProblem(true, obj, [con])
# Convert the SOS problem to a clustered low-rank SDP
sdp = ClusteredLowRankSDP(sos)
# Solve the sdp with the standard parameters
status, result = solvesdp(sdp)"><pre><span class="pl-k">using</span> ClusteredLowRankSolver, AbstractAlgebra
<span class="pl-k">using</span> BasesAndSamples <span class="pl-c"><span class="pl-c">#</span> To generate the samples</span>

<span class="pl-c"><span class="pl-c">#</span> Set up the polynomial space and define the polynomial to be optimized:</span>
R, (x,) <span class="pl-k">=</span> <span class="pl-c1">PolynomialRing</span>(RealField,[<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>])
p <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">-</span>x<span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">3</span><span class="pl-k">+</span>x<span class="pl-k">^</span><span class="pl-c1">6</span>
<span class="pl-c"><span class="pl-c">#</span> The degree of the basis for the sums-of-squares polynomials we want to use:</span>
d <span class="pl-k">=</span> <span class="pl-c1">3</span>

<span class="pl-c"><span class="pl-c">#</span> For the constraint we consider the part for the free variables and the part for the</span>
<span class="pl-c"><span class="pl-c">#</span> positive semidefinite matrix variables separately</span>
free_dict <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(λ <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>)  

<span class="pl-c"><span class="pl-c">#</span> The matrix variables come from the sum-of-squares parts, since s_i(x) is a sum-of-squares</span>
<span class="pl-c"><span class="pl-c">#</span> if and only if s_i(x) = ⟨b(x)b(x)^T, Y⟩ for some Y ⪰ 0 and vector of basis polynomials b(x)</span>
matrix_dict <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()
<span class="pl-c"><span class="pl-c">#</span> Both SOS parts have the same total degree, but different weights</span>
matrix_dict[<span class="pl-c1">Block</span>(<span class="pl-c1">:SOS1</span>)] <span class="pl-k">=</span> <span class="pl-c1">LowRankMatPol</span>([<span class="pl-c1">R</span>(<span class="pl-c1">1</span>)], [[x<span class="pl-k">^</span>k <span class="pl-k">for</span> k<span class="pl-k">=</span><span class="pl-c1">0</span><span class="pl-k">:</span>d]])
matrix_dict[<span class="pl-c1">Block</span>(<span class="pl-c1">:SOS2</span>)] <span class="pl-k">=</span> <span class="pl-c1">LowRankMatPol</span>([<span class="pl-c1">1</span><span class="pl-k">-</span>x<span class="pl-k">^</span><span class="pl-c1">2</span>], [[x<span class="pl-k">^</span>k <span class="pl-k">for</span> k<span class="pl-k">=</span><span class="pl-c1">0</span><span class="pl-k">:</span>d<span class="pl-k">-</span><span class="pl-c1">1</span>]])

<span class="pl-c"><span class="pl-c">#</span> Chebyshev points in [-1,1]:</span>
samples <span class="pl-k">=</span> <span class="pl-c1">sample_points_chebyshev</span>(<span class="pl-c1">2</span>d)
<span class="pl-c"><span class="pl-c">#</span> Create the constraint:</span>
con <span class="pl-k">=</span> <span class="pl-c1">Constraint</span>(p, matrix_dict, free_dict, samples)

<span class="pl-c"><span class="pl-c">#</span> we want to maximize λ</span>
obj <span class="pl-k">=</span> <span class="pl-c1">Objective</span>(<span class="pl-c1">0</span>, <span class="pl-c1">Dict</span>(), <span class="pl-c1">Dict</span>(λ <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>))

<span class="pl-c"><span class="pl-c">#</span> Maximize the objective with constraint `con`</span>
sos <span class="pl-k">=</span> <span class="pl-c1">LowRankSOSProblem</span>(<span class="pl-c1">true</span>, obj, [con])
<span class="pl-c"><span class="pl-c">#</span> Convert the SOS problem to a clustered low-rank SDP</span>
sdp <span class="pl-k">=</span> <span class="pl-c1">ClusteredLowRankSDP</span>(sos)
<span class="pl-c"><span class="pl-c">#</span> Solve the sdp with the standard parameters</span>
status, result <span class="pl-k">=</span> <span class="pl-c1">solvesdp</span>(sdp)</pre></div>
<p dir="auto">More examples are available in the <a href="https://nanleij.github.io/ClusteredLowRankSolver.jl/stable" rel="nofollow">documentation</a>. For the code examples described in the documentation and more, see the <a href="https://github.com/nanleij/ClusteredLowRankSolver.jl/tree/main/examples">examples</a> folder.</p>
<h2 dir="auto"><a id="user-content-citing-clusteredlowranksolver" class="anchor" aria-hidden="true" href="#citing-clusteredlowranksolver"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Citing ClusteredLowRankSolver</h2>
<p dir="auto">If you use <code>ClusteredLowRankSolver.jl</code> in a publication please consider citing</p>
<ul dir="auto">
<li>D. de Laat and N. Leijenhorst, <em>Solving clustered low-rank semidefinite programs arising from polynomial optimization</em>, Preprint (2022), <a href="https://arxiv.org/abs/2202.12077" rel="nofollow">arXiv:2202.12077</a></li>
</ul>
</article></div>