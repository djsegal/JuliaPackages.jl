hyperspecialize hyperspecialize proud hack julia package designed resolve method ambiguity errors automating task redefining functions specific types explain solution example suppose peter friend jarrett developed eponymous modules peter jarrett follows module peter import base struct peternumber base peternumber peternumber export peternumber module jarrett import base struct jarrettnumber base jarrettnumber jarrettnumber export jarrettnumber peter jarrett defined fun numeric types look happens user tries peter jarrett julia using peter julia using jarrett julia peternumber peternumber julia jarrettnumber jarrettnumber julia friends error methoderror peternumber jarrettnumber ambiguous candidates jarrettnumber mainjarrett repl peternumber mainpeter repl fix define peternumber jarrettnumber oh peternumber jarrettnumber methods applicable neither method specific julia decide method user decide defining specific method question role developers play resolution ambiguity developers coordinate efforts agree types interact define methods interaction solution unrealistic poses undue burden communication developers multiple behaviors desired interaction types example definitions behavior desired user developer write library run modifed execution environment cassette solution creates contexts multiple dispatch single developer define ambiguous methods concrete subtypes base provide utilities extend definitions example peter define concrete subtypes base ambiguity default jarrett definition unless user peter definition hyperspecialize designed standardize provide utilities latter approach load dependent solution peter decided hyperspecialize definition looks replicable base peternumber hyperspecialize peternumber solution replicate definition concrete subtypes list subtypes depends module load peter module loaded following behavior julia friends jarrettnumberpeternumber jarrett module loaded following behavior julia friends peternumberjarrettnumber explicit solution peter unpredictable behavior decides explicitly define load types code defined concrete subtypes base concretize macro define subtypes definition looks concretize mynumber bigfloat float float float bool bigint int int int int int uint uint uint uint uint replicable base peternumber hyperspecialize mynumber peternumber peter defined concrete subtypes user specific definition type consider happens peter package jarrett package loaded julia friends jarrettnumberpeternumber julia using hyperspecialize julia widen petermynumber jarrettnumber settypebigint bool uint float float int int float jarrettnumber uint uint uint bigfloat int uint int int julia friends peternumberjarrettnumber mynumber type tag peter module widened definition peternumber jarrettnumber peter package jarrett module defines generic method chosen user widens peter definition include jarrettnumber triggering specific definition evaluated peter module specific method peter package chosen opt join suppose jarrett thinking method ambiguities peter package decides hyperspecialize jarret added concretize mynumber bigfloat float float float bool bigint int int int int int uint uint uint uint uint replicable base hyperspecialize mynumber jarrettnumber jarrettnumber module behavior follows julia error promotion exists peternumber jarrettnumber stacktrace errorstring type string type errorjl promotetosupertype promotionjl inlined promoteresult promotionjl inlined promotetype promotionjl inlined promote promotionjl inlined promote promotionjl inlined peternumber jarrettnumber promotionjl toplevel scope method adding peternumber jarrettnumber user explicitly using widen peter jarrett mynumber type tag user chooses widen jarrett definitions julia widen jarrettmynumber peternumber settypebigint bool uint float float int int float peternumber uint uint uint bigfloat int uint int int julia jarrettnumberpeternumber user instead chooses widen peter definitions julia widen petermynumber jarrettnumber settypebigint bool uint float float int int float uint uint uint bigfloat int uint jarrettnumber int int julia peternumberjarrettnumber getting started library provides functions managing defintions replicate types replicated concretization user enumerate types definition replicated type tags describe particular set types type tag arguments macros interpreted literally symbols set types referred concretization specify concretization type tag using concretize macro concretize key int specify type concretize key int float float expand concretization type tag widen macro widen key bigfloat bool query concretization type tag concretization macro concretization key type tags modulelocal scope module specified interpreted belonging module expanded type tag form modkey specify module type tag argument macro concretization mod key concretization type tag key module mod tag default concretization corresponding concrete subtypes whatever symbol key means evaluated mod tag name please define concretization replicable heart hyperspecialize package replicable macro promises replicate definition combinations types concretization type tags appear definition replicable takes argument code replicated global scope current module specify type tags hyperspecialize macro types concretization tag substituted following example module foo concretize mykey int float replicable bar hyperspecialize mykey hyperspecialize mykey execute following code global scope foo bar int int bar float int bar int float bar float float loaded foo module calls widen foo mykey float following code execute global scope foo bar float float bar int float bar float float bar float int bar float float notice earlier definitions repeated fine print example module idea simple details data precompilation data stored const global dictionaries named hyperspecialize module calls concretize note happen implicitly methods called expect concretization exist reason simple concretize type tag module package calling eval modules widen types call widen type key module init function module documentation init hyperspecialize main drawbacks hyperspecialize package macros generate definitions function definition includes hyperspecialized type tags mathematical operators alleviated using julia promotion rules define unambiguous promotetype stands reduce methods defined situations sufficient concretize type tag union concrete types base strategy unlikely method redefined using types drawback user manually choose desired behavior ambiguity related internal type user resolve third drawback methods create ambiguity desired user forced choose global behavior problematic library widened type tag choice short hyperspecialize user types concretized resolution method ambiguities major benefit using hyperspecialize typebased api forced adopt functionbased api difficulties involved using hyperspecialize using contextual dispatch solution cassette chosen example function define promotion rules avoid ambiguities type ambiguities occur definition promotetype funct