attrs attribtures treatment deserve dynamic dispatch implement extensible mechanism user provided attributes background julia makes overload property access via basegetproperty basesetproperty symbols name property makes easier dynamic scenarios python interoperability huge drawback coded related properties single type single extended julian using dynamic dispatch usual extensibility multiple dimensions love performance basegetproperty inlining getpropertysetproperty package tries adress performance consider code struct foo int function computey foo return inline function base getproperty foo symbol return getfield return computey error type typeof field foo codenative foo output text pushq rax movabsq juliagetproperty rax movabsq rsi imm xbccf callq rax leaq raxrax rax popq rcx retq nop getproperty inlined getproperty calling computey calls getproperty lowering compiler rightfully refuses recursive inlining partial inlining appreciate fix replace getfield break cycle call graph package provides similar solution via literalattrs macro macro replaces property access literalgetattr literalsetattr avoid cyclic call graph using attrs defattrs foo literalattrs function computey foo return inline attrs getattr foo attr computey codenative foo output text movq rdi rax leaq raxrax rax retq nopl rax computey inlined define type usual struct mytype type opt attrs package using attrs defattrs mytype defattrs myothertype abstractfloat integer define attributes gettatr settattr methods type literalattrs macro inlining inline literalattrs attrs getattr mytype attrfoo inline literalattrs attrs setattr mytype attrfoo type usual mytype literalattr