dynamicgrids generalised framework building performance gridbased spatial simulations including cellular automata allowing wider range behaviours random jumps interactions multiple grids extended dispersaljl modelling organism dispersal processes dynamicgridsgtkjl provides simple live interface dynamicgridsinteractjl live control model parameters simulation runs realtime visual feedback manual parametrisation model exploration dynamicgrids run rules single cpus threaded cpus cuda gpus simulation runtime usually measured fractions dispersal simulation quarantine interactions using dispersaljl custom rules gtkouput dynamicgridsgtk note indicative realtime framerate laptop dynamicgridsjl simulation run script running included game life model life using dynamicgrids crayons init rand bool output reploutput init tspan fps color crayon foreground red background black bold true sim output life define scratch actually implementation life neighbors moore data hood bornsurvive false false false true false false false false false false false true true false false false false false bornsurvive sum hood sim output life game life simulation displayed directly terminal concepts framework highly customisable central ideas define simulation grids rules outputs grids simulations run grids derived init single abstractarray namedtuple multiple abstractarray grids griddata types single array source destination arrays maintain independence cell reads writes required padded otherwise altered specific performance optimisations broadcasted getindex operations guaranteed grid regular array useful running simulations manually step grid contents grids contain simple values types sarray fieldvector custom structs grids updated rule run cell timestep note grids mutable objects array mutable struct undefined behaviour dynamicgridsjl deepcopy grids frames expensive successive frames contain objects mutable objects gpus relatively slow cpus instead regular immutable structs staticarraysjl arrays update using set setfieldjl accessorsjl functional programming approaches objectoriented ones init init grid contain whatever initialisation data required start simulation array type size element type providing initial conditions init rand float init grid attached output output arrayoutput init tspan passed sim preference init attached output type size sim output ruleset init init multiple grids init namedtuple equalsized arrays matching names ruleset init predator rand prey rand handling passing correct grids rule automated dynamicgridsjl cost abstraction rule specify grids require using type parameters dimensional spatial init grids dimensionaldatajl geodatajl propagate model return output explicit dimensions plot correctly map using plotsjl shape files observation easily added grids grids containing custom types caveats define basezero element type bitstype performance tuple define zero array bitstype define zero sarray staticarraysjl contents grid custom structs defne zero multivalues grid element type define method dynamicgridstorgb returns argb imageoutput isless reploutput definition multiplication scalar real addition required convolution kernels rules rules hold parameters running simulation applied applyrule method called active cells grid rules flavours outlined docs allows using specialised methods types rules ecoding assumtions behaviours greatly improve performance efficient caches parallelisation rules collected ruleset additional arguments control simulation ruleset ruleset life opt sparseopt proc cugpu multiple rules combined ruleset simply passed sim directly rule run grid sequence using appropriate optimisations depending parent types rule ruleset ruleset rule rule timestep day opt sparseopt proc threadedcpu output outputs storing viewing simulation interchangeably depending arrayoutput simple storage structure performancesimulations outputs initialised init array requires simulation frames preallocate simulation runs output arrayoutput init tspan reploutput shown graphicoutput useful checking simulation terminal ssh output reploutput init tspan imageoutput complex class outputs allowing color visual simulations using colorschemesjl display multiple grids using color composites layouts shown quarantine simulation dynamicgridsinteractjl provides simulation interfaces juno jupyter web pages electron apps live interactive control parameters using modelparametersjl dynamicgridsgtkjl simple graphical output gtk packages kept separate avoid dependencies graphical simulations outputs easy write performance applications benefit writing custom output reduce memory using transformedouput performance dynamicgridsjl dominated cache interactions reducing memory positive effects example forest fire example implements classic stochastic forest fire model benchmarks note imagemagickjl installed gif output define forest fire algorithm sets current cell burning neighbor burning dead cells life living cells spontaneously catch fire using dynamicgrids colorschemes colors benchmarktools const dead alive burning neighborsrule probcombustion probregrowth neighbors moore data neighborhood cell cell alive burning neighborhood burning else rand probcombustion burning alive elseif cell burning dead else rand probregrowth alive dead set init array output using gtk window init fill alive output gifoutput init filename forestfiregif tspan fps minval dead maxval burning scheme colorschemes rainbow zerocolor rgb run simulation save gif completes sim output neighborsrule timing simulation steps performance particular cpu six cores x speedup using indicates scaling benchoutput resultoutput init tspan julia btime sim benchoutput neighborsrule ms allocations mib julia btime sim benchoutput neighborsrule proc threadedcpu ms allocations mib invert algorithm setting cells neighborhood burning current cell burning using setneighbors rule setneighborsrule probcombustion probregrowth setneighbors moore data neighborhood cell cell dead rand probregrowth data alive elseif cell burning pos positions neighborhood datapos alive datapos burning data dead elseif cell alive rand probcombustion data burning note using add instead set grid value directly usually risks errors multiple cells set values set currently living cell burning timestep matter happens multiple times result fairly sparse simulation rule faster julia btime sim benchoutput setneighborsrule ms allocations mib julia btime sim benchoutput setneighborsrule proc threadedcpu ms allocations mib scaling x cores method machine lot cores slightly rewrite rules gpu rand available gpu kernel method faster demonstrate using multiple grids setgrid call cudarand entire parent array rand grid using setgrid rule using cudakernels cuda randomiser setgrid tuplerand randgrid cuda rand parent randgrid define neighbors version gpu using rand grid values instead rand neighborsgpu probcombustion probregrowth neighbors tupleffrandff moore data neighborhood cell rand cell alive burning neighborhood burning else rand probcombustion burning alive elseif cell burning dead else rand probregrowth alive dead setneighbors version gpu setneighborsgpu probcombustion probregrowth setneighbors tupleffrandff moore data neighborhood cell rand cell dead rand probregrowth data ff alive elseif cell burning pos positions neighborhood data ff pos alive data ff pos burning data ff dead elseif cell alive rand probcombustion data ff burning benchmark version gtx gpu despite overhead reading writing grids faster benchoutputrand resultoutput ff init rand zeros size init tspan julia btime sim benchoutputrand randomiser neighborsgpu proc cugpu ms allocations mib julia btime sim benchoutputrand randomiser setneighborsgpu proc cugpu ms allocations mib running rule rate billion times timings improved maybe using grids int int memory cache stop