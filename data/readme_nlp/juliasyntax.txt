juliasyntax julia frontend written julia goals lossless parsing julia code precise source mapping production quality error recovery reporting unit testing parser structure similar julia flispbased parser speedy interactive editing compilation api support sorts tooling grow encompass rest compiler frontend macro expansion desugaring lowering steps mature replace julia flispbased reference frontend core design opinions parser implementation independent tree data structures parsestream interface tree data structures layered balance losslessness abstraction generality syntaxnode ast layered top greennode lossless parse tree tree types fancy parser generators marginal production compilers boring flexible recursive descent parser status juliasyntaxjl highly compatible julia reference parser parses base standard libraries correctly registry incompatibilities base tests tree data structures usable apis evolve try various converting expr stable helps talk juliacon covered aspects package examples parsing piece code currently looks various forms juliasyntaxparse function demonstrate juliasyntaxparse offering finegrained control source ast syntaxnode call dump means call infix flag julia using juliasyntax julia parsestmt syntaxnode filename foojl line col tree filename call foo jl parens call internally representation syntax trivia whitespace comments seen raw green tree representation greennode ranges left byte ranges flags nontrivia tokens note parentheses trivia tree representation despite parsing julia text greentree parsestmt juliasyntax greennode text call parens call identifier whitespace whitespace identifier identifier greennode stores byte ranges token strings shown supplying source text string julia stdout mime textplain greentree text call parens call identifier whitespace whitespace identifier identifier julia expr produced julia juliasyntax parsestmt expr using juliasyntax default parser juliasyntax default julia parser include files parse code metaparse etc call julia juliasyntaxenableincore causes startup latency reduce create custom system image running code sysimagecompilejl julia script directly using shell unix julia resultingsysimage using custom sysimage advantage package precompilation juliasyntax parser vscode juliasyntax default parser julia vscode add following startupjl file atreplinit repl eval begin import juliasyntax juliasyntax enableincore true reduce startup latency combine custom system described julia vscode docs combined precompile execution file sysimageprecompileexecjl additional detail discussion issue parser implementation goal losslessly represent source text tree called lossless syntax tree sometimes called concrete syntax tree term parse tree formal grammar language including grammar hacks required solve ambiguities etc avoid term juliasyntax recursive descent parser closely follows level structure flisp reference parser makes code familiar reduces porting bugs lot flexibility designing diagnostics tree data structures compatibility julia versions etc choose parser generator marginal production compilers parsing greatly expressive flexible auxiliary code written lexing version tokenizejl modified match parsing newlinecontaining whitespace emitted separate tokens inside string interpolations emitted separately string strings delimiters separate tokens actual string string additional contextual keywords var doc added moved subcategory keywords nonterminal kinds added probably factored various bugs fixed additions julia versions copy tokenize lives juliasyntax source tree due volume changes required churn settles figure unfork lexer parsing parsestream main parser innovation parsestream interface provides stream interface writing parser parser depend produce concrete tree data structure parsing phase output spans postprocessed various tree data structures required design rustanalyzer simpler implementation parsing proceeds recursive descent parser consumes flat list lexed tokens input using peek examine tokens bump consume parser produces flat list text spans output using bump transfer tokens output position emit nonterminal ranges diagnostics emitted separate text spans whitespace comments automatically bump ed handled explicitly exception syntactically relevant newlines space sensitive mode parser modes passed call tree using parsestate output spans track byte range syntax stored integer tag flags tag makes spans sum type type tracked explicitly outside julia type system lossless parsing output spans cover entire input text using bump position emit natural ensures spans cleanly nested children contained entirely parents siblings spans emitted source parent spans emitted children properties output spans naturally isomorphic green tree terminology roslyn compiler tree construction buildtree function performs depth traversal parsestream output spans allowing assembled concrete tree data structure example using greennode data type build top define buildtree ast type syntaxnode normal julia expr error recovery goal parser produce formed hierarchical structure source text interactive tools source text contains errors job parser include recovery heuristics concretely parser juliasyntax produce green tree formed sense greennode defined layout children means greennode syntaxnode transformation deterministic tools assume valid ast valid mean allow tree contain following types error nodes missing tokens nodes added placeholders complete piece syntax example parse call call xxx xxx placeholder error node sequence unexpected tokens removed collecting children error node treating syntax trivia ast construction example parsed green tree call error ast call encode simplest downstream tools question error triviaflag set unexpected syntax syntax trees julia expr abstract syntax tree store precise source locations deal syntax trivia whitespace comments tree types juliasyntax juliasyntax currently deals types trees greennode minimal lossless syntax tree nodes store length bytes text syntax trivia included list children children strictly source syntaxnode abstract syntax tree absolute position pointer source text children strictly source leaf nodes store values text trivia ignored mapping trivia nodes associated greentree nodes expr conversion target compatibility julia ast structures section describe features julia ast structures concatenation syntax concatenation syntax comes syntax forms traditional hcat vcat row deal concatenation matrix construction dimensions ncat nrow syntax deals concatenation array construction arbitrary dimensions write ncat concatenation third dimension stored head flags syntaxnode trees arg expr trees semantically syntax ncat vcat ncat hcat row nrow vertical concatenation dimension vertical concatenation dimension semicolons newlines julia printtree expr vcat julia printtree expr vcat horizontal concatenation dimension horizontal concatenation dimension spaces double semicolons julia printtree expr hcat julia printtree expr ncat mixed concatenation concatenation dimensions spaces single semicolons newlines producing mixture vcat row expressions julia printtree julia printtree expr vcat expr row expr row dimensional concatenation results nested ncat nrow example julia printtree expr ncat expr nrow expr nrow expr nrow tree differences greennode expr tree structure greennode syntaxnode similar julia expr data structure various differences source children children trees strictly source consequences expr reorders child expressions infix postfix operator calls operator name child position parsed call infix flag indicates infix child position exprcall generators represented source single node multiple nested flatten generator expressions linenumbernode syntax nodes inherently stores source position linenumbernode expr consistent redundant block sometimes expr redundant block constructs store linenumbernode blocks try consistently block hand short form function syntax block conditional elseif block body anonymous functions argument lists block regardless form bindings faithful representation source text avoid premature lowering premature lowering removed preferring represent source text closely macrocall allow users easily distinguish macrocalls parentheses parentheses represented node parens hand retains braces node distinguish ternary syntax immediately lowered node parses expr global const const global normalized parser expr conversion ast flatter lowered lambda parser body parsed call tuple block body lowered dot inside parser docstrings doc lowered coredoc juxtaposition juxtapose lowering immediately return value zero children lowering return containers string constructs string constructs container node single token useful tooling tokens source text separating delimiters text delimit removes class tokenization errors parser deal string string wrap strings contain single string chunk char literals wrapped char containing character literal string delimiters backticks cmdstring var syntax var head parser splits triple quoted strings string chunks interspersed whitespace trivia improvements ast inconsistencies dotted call syntax consistent dotcall head standalone dotted operators parsed op example parsed call keyword syntax kw avoid various inconsistencies ambiguities unadorned postfix adjoint parsed call syntactic operator consistency suffixed versions improvements awkward ast forms frakentuples multiple parameter blocks flattened parent tuple instead using nested parameters nodes using try catch else finally parsed catch else finally children avoid awkwardness optional child nodes expr representation dotted import path syntax import parsed importpath bare nestedquoted expression representation flags child nodes represent difference struct mutable struct module baremodule multiple iterations header bs body represented cartesianiterator head block lists iterators neither semantically syntactically sequence statements unlike block generators detail tree differences generators flattened generators uniquely problematic julia ast respect key rule normally expect children ast node contiguous range source text example xy xs ys parsed normal loop mean xs ys pushxy collection xy prefix body innermost loop following standard julia ast flatten generator generator xy ys xs note tree flattened xy ys xs iterations opposite source green tree strictly source deviate julia ast deal cartesian products iterators separated commas cartesianiterator blocks loops presence multiple iterator blocks flatten head distinguish flattened iterators nested flattens generators expr forms reconstructed form tree structure resembles source closely example xy xs ys parsed generator xy xs ys cartesian iteration xy xs ys parsed generator xy cartesianiterator xs ys whitespace trivia inside strings triple quoted strings indentation string data excluded string content green tree treated separate whitespace trivia tokens separation formatting easier reasoning goes escaping newlines following whitespace backslashes normal strings detecting string trivia parsing means string content split tokens wrap string interpolations individual chunks reassembled expr construction alternative reuse string cmdstring kinds string chunks interpolation example following julia fragment parsed string flag string means triple quoted string looking green tree indentation marked trivia julia text stdout mimetextplain parseallgreennode text rulestatement text identifier whitespace whitespace string string whitespace identifier string whitespace string string nodes wrapped string cmdstring strings surrounded node string interpolated literals parses string makes string handling simpler systematic interpolations triple strings embedded trivia treated container attach delimiting quotes goes command strings wrapped cmdstring regardless multiple pieces due triplequoted dedenting otherwise desugaring closure blocks reference parser represents syntax closure argument body call tuple block body reference parser nested closure head implied surface syntax suggests premature desugaring step instead emit flatter structure call tuple block body syntax kinds track type syntax nodes syntax stored explicitly node integer tag effectively makes node type sum type type system sense type tracked explicitly outside julia type system managing type explicitly brings benefits code data structures manipulating syntax nodes concretely typed view compiler control data layout pack bits flags bits desired predicates isoperator extremely efficient meaning bits applied tree data structures manipulated pattern matching code efficient set kinds closed compilation arguably downsides normal julia dispatch express dispatch syntax luckily pattern matching macro provide elegant expressing algorithms extensible set kinds node kinds data fields syntax tree generic fields cater kinds consider analogy normal julia ast quotenode single field vs expr generic head args fields disadvantage code processes specific generic code processing kinds generic concrete data layout faster differences flisp parser comparisons packages section practically flisp parser classic recursive descent parser looks modifies output tree produced tried eliminate pattern favor lookahead poorly parser emitting stream node spans strict source constraints confusing reason code occasion solve genuine ambiguities julia code parsed top finite lookahead eg kw vs ambiguity parentheses using functions lookbehind resetnode code structure structural changes avoided porting particular nearly function names parsing productions replaced predicates prefixed is notable differences parsearglist parseparen combined function parsebrackets function deals odd corner ast emitted mixing parentheses particular regard determining block syntax separators keyword parameters determining emit parameter sections based context emitting keyvalue pairs kw depending context parseresword entered rearranged avoid parsing reserved words parseatom inside parseunaryprefix instead detect reserved words enter parseresword earlier flisp parser bugs behaviors bugs replicate name compatibility warning macro module paths allow calls weird stateful semantics rand base core info hi misplaced macro module paths parsed odd brokenlooking ast macrocall quote probably rejected operator prefix call syntax keyword parameters separated commas tuple produced instead const global allow chained assignment hand constant const const parsing ncat array concatenation syntax braces strange ast parses bracescat probably bracescat nrow analogy produces bracescat row export rejected export parses fine trycatchfinally finally clause allowed catch executes afterward presumably mistake pretty awful parsing flisp parser confused correctly parsed exprvect maybe fixed xs accepted parsed strangely octal escape sequences saturate reported errors eg results xff inconsistent baseparsetypeint leading dots import paths operatornamed modules parsed dotted operators relative path ie import parsing import whereas import consistency parsing import looking output disregards parentheses lead odd results example parses keyword call function keyword arguably assignment hexfloat literals trailing example xpf flisp code treated float literals intentional julialangjulia officially supported julia bug arises set pred charhex parse accepting hex exponent digits detected invalid except trailing processed isnumtokbase begin parsed keywords indexing typed comprehensions initially look distinguished indexing handle token safe treat begin keywords afterwards reference parser handles newline foo begin true foo begin true juliasyntax handles parsing ast oddities warts questionable allowed forms various allowed syntaxes fairly easily detected parser rejected lowering allow building dsls fine allowed syntaxes useful dsls macro allowed anonymous macros abstract type subtype comparisons allowed makes sense produces bracescat row pretty weird outer xs parses outer makes real sense context using form lowering error kw inconsistencies apparent inconsistencies kw parsing keyval pairs inside parentheses inconsistent parsing tuple keyword args inside vs outside dot calls tuple tuple kw mixtures calls nested parameter ast parses strangely horrible tuple parameters parameters form anonymous functions argument lists parsed tuples blocks argument lists mess appears papered lowering example function parsed block leads inconsistency kw keywords oddities operators suffices parsed consistently operator suffix unclear design mistake example hcat y hcat call global const normalized parser const global suppose somewhat useful ast consumers reversing source pretty weird inconvenient moving lossless parser bindings stored block depending special special block block block block block block block block block elseif condition block condition presumably add line node flisp parser xx elseif yy block xx elseif block block yy spaces allowed import dots import allowed parsed import import produces import arguably nonsensical normal identifier raw string escaping rules super confusing backslashes near string raw contains backslashes whereas raw contains intentional feature allow strings represented unclear situation improved braces macrocall invalid parse conversely parses macro names invocations postprocessed output parseatom parsecall leads surprising questionable constructs absurdities macrocall infix macros macrocall ok kinda cute weird logic similarly additional parentheses allowed macrocall allowing macro module paths eg instead unnecessary variation syntax makes parsing valid macro module paths complex leads oddities macrocall quote parsed macro name module name parsed valid module name normal julia code makes sense triple quoted var identifiers allowed required desired complex triplequoted string deindentation rules deindentation triple quoted strings mismatched whitespace weird whitespace example middle line whitespace dedented lines consistent middle line deindented completely lines dedented character matching prefix parsing anonymous function arguments somewhat inconsistent function xs body parses argument list xs whereas function body parses argument list tuple difference multidimensional vs flattened iterators subtle syntactically permissive example multidimensional iterator flattened iterator flattened iterator problematic require form explicit indicate flattening pretty printed correctly julia exprfilter character written escaping requiring form comparisons packages official julia compiler differences flisp parser section official julia compiler frontend lives julia source tree contained files parser srcjuliaparserscm macro expansion srcast srcmacroexpandscm syntax lowering srcjuliasyntaxscm flisp runtime extensions julia srcflisp supporting utility functions scm files issues official reference frontend suggest rewrite support precise source locations existing data structures bare flisp lists easily extended add fixing require changes nearly code written flisp aestheically pleasing minimal obscure implementation scheme learning scheme actually appreciate julia design inspiration barrier developers julia language tooling flisp userlevel documentation schemers refer racket documentation compatible basic addition social factors embedded flisp interpreter runtime separate data structures ffi complex inefficient juliaparserjl juliaparserjl direct port julia flisp reference parser abandoned julia furthermore support lossless parsing adding feature amount rewrite divergence flisp reference parser julia start anew reference parser instead tokenizejl tokenizejl fast lexer julia code code tokenize imported juliasyntax major modifications discussed lexer implementation section cstparserjl cstparserjl lossless parser goals similar juliaparser extensively vscode languageserver juliaformatter ecosystem cstparser useful implementation hard understand try fresh approach focus production readiness docs tests diagnostics maximum similarity flisp parser goal getting parser core learning ideas composable parsing data structures outside julia particular implementation rustanalyzer clean documented source inspiration composability tree data structures feel trees layered somehow lightweight green tree basic level similar roslyn rustanalyzer comparison cstparser heavyweight layered data structure alternatively additionally common tree api concrete taskspecific implementations benefit juliasyntax parser separates parser code tree data structures entirely lot flexibility experimenting various tree representations juliasyntax tackle macro expansion lowering steps provide apis core language editor tooling treesitterjulia using modern productionready parser generator treesitter option progress treesitterjulia feel grammars parser generators marginally expressive writing parser hand accounting effort spent weird edge real language writing parser tests supporting code hand handwritten parser completely flexible mutually understood reference implementation chose approach juliasyntax resources julia issues links relevant julia issues macro expansion automatic hygiene macros julialangjulia implement frontend lowering partial implementation lowering julia julialangjulia ported commit closure capture julialangjulia tackle harder implementation roslyn persistence faades roslyn redgreen trees roslyn optimization overview literate usage example rustanalyzer rustanalyzer close building conclusions green tree layout explicit trivia nodes document internals note trees green trees exactly pretty design decisions including trivia storage note team toying idea using roslyn model trivia untyped red syntax trees somewhat minimal example attempt reorder children typed ast layer type expression head ast searches children dynamically traversing child list time single canonical remembering placement children parser parser whitespace nodes instead attached tree treesink layer relevant pain attach whitespace otherwise significant tokens inefficient allocate pass dynamic list whitespace trivia practice incremental reparsing actually matter ide parsing scratch fast wonder ve implemented incremental parsing various comments macros rust macro expansion julia appears interleaved parsing unclear typed asts julia particularly deal expr existing public interface expr wrap syntaxnode related useful set blog posts discuss using rust syntax tree library rowan representing rust toy language design decisions rustanalyzer finalized architecture document fantastic source design inspiration highlights parser independent particular tree structure particular representation tokens transforms flat stream events flat stream events adopt todo rslint rslint linter javascript built rust parsing infrastructure green tree libraries rustanalyzer excellent friendly level overview rslint parsing devdocs note backtracking restarting parser error actually simple architecture share rustanalyzer events allow cheaply backtrack parser simply draining events resetting token source cursor section error recovery talk various error recovery strategies diagnostics paper p concepts error messages humans centric nice review quality error reporting various compilers including elm reasonml flow rust rustspecific resources rustcerrorsdiagnostic source rust compiler diagnostics system println macro emitted macros parser resources parsing modern parser generator lot practical notes writing parsers highlights encourages writing tests handwritten parsers inline comments mentions pratt parsers simple operator precedence parsing articles aleksey kladov matklad main rustanalyzer author etc bob nystrom munificent dart devs etc discussion error recovery notes stateful lexers parsing shell string interpolations design notes following fairly disorganized design notes covering mixture musings prototyping approach tree datastructure design tricky symbolic compilation compiler frontend incrementally abstracts transforms source text errors refer source tree lossless representation source text aspects source text comments whitespace irrelevant parsing aspects source text irrelevant abstract syntax tree surface syntax examples parentheses explicit vs implicit multiplication symbol vs x various type analyses useful augment syntax tree depending analysis algorithms able act tree type ignoring carrying augmentations suggests tree types common interface main abstract syntax tree type useful figure prototyping flows syntax transformations choose macros implement basic test mixing source trees files preserving precise source locations testsyntaxinterpolationjl formatting reindent file tests handling syntax trivia refactoring pass rename local variables tests information compilation pipeline attached syntax tree modify source code precise error reporting lowering syntax desugaring report invalid assignment location precise source location try layers deeper inside lowering example macro definition allowed inside local scope incremental reparsing reparse source file byte range replacement tree design raw syntax tree green tree raw syntax tree green tree terminology roslyn greennode structurally minimal efficiency generality immutable efficiency thread safety complete preserve parser knowledge token agnostic allow source language simplest idea leaf nodes single token children source call represents challenge ast vs green tree terms node placement iteration infix operators vs normal prefix function calls normal vs worse vs ast interface abstract placement example normal julia ast iteration abstract syntax tree green tree nodes ast nodes traceable original source unlike languages designing ast tricky existing expr public api macro expansion userdefined macro expansions interpose source text lowering using expr looses source information forward maybe expr semihidden fields green tree nodes expr args list existing expr macro expansion try recover source information macro expansion using heuristics presence correct hygiene help introducing ast opt hypothetical style macros fixing hygiene design challenge manipulating expressions reasonable literals carry source location option help bridge locationless asts wrappers literal types cover example sourcesymbol abstractsymbol sourceint integer sourcestring abstractstring source location attached symbols potentially solve hygiene macro helper functions symbol literals changing meaning trick try capturing current module location interpolation syntax eg lowering expands coreexprcall expand coreexprcall addsourcesymbolmoduleweareloweringinto parsing error recovery disorganized musings error recovery types errors occur disallowed syntax lack spaces conditional expressions reasonably continue parsing emit node error flag otherwise formed parsing infix expressions missing tail emitting zero width error token lead formed parse tree productions stack participate recovery token disallowed current context eg parseatom closing token inside infix expression emit error descend parse tree pop recursive frames tricky typical structure follows function parsefoo ps mark position ps parsebar ps fails peek ps token bump ps parsebaz ps fails emit ps mark foo emitting plain error tokens unfinished infix expressions begin missing tricky intermediate syntax valid obvious eof missing function begin indentation wrong inner function function ideal error recovery backtrack example pop frame parsing backtrack parse events function indentation mismatched nesting parent reset parsestream parsing checkpoint called emit error exit function parsing restart parsing somehow result infinite recursion missing commas closing brackets nested structures existing parser missing comma local indentation tell story missing closing missing closing particularly difficult diagnostics current system broken parentheses double quotes string interpolations especially nested fun research questions parser recovery learn fast reasonably accurate recovery heuristics parser encounters broken syntax handcoding set parser training injecting model nonintrusive model embedded parser compact training fast model tiny formatting source syntax tree regresslearn generative model indentation syntax tree source formatting involves pile heuristics looks nice ml systems heuristics huge piles training data choose quality tastefully handformatted libraries getting involved people help improve julia error messages contributing juliasyntax suggest looking issue list choosing issue familiarize code marked labels intro issue bug start watching juliacon talk reading document probably overview march positional tracking source juliasyntax system parser recovery errors nice requires research example read rustanalyzer recovery rslint eventbased recursive decent parsers similar structure juliasyntax rust investigate datadriven parser recovery using ml technique research project