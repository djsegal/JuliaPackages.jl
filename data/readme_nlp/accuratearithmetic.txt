accuratearithmeticjl floating math errorfree faithful compensated transforms errorfree faithful transforms accuratearithmeticjl provides set errorfree transforms efts allow getting rounded result floating computation accompanying rounding error julia using accuratearithmetic warning value representable float similarly julia julia accuratearithmetic twosum e example result floating addition rounded nearest representable floating exactly standard addition rounding error associated words guaranteed strict mathematical sense operate real rounded similar efts provided binary subtraction twodiff multiplication twoprod operations arity supported threesum foursum threeprod compensated algorithms efts leveraged build compensated algorithms compute result basic algorithm run using precision construction vector sums julia randn exp randn sortperm rand length julia sum standard summation algorithms computes sum inaccurately sign correct julia sum compensated summation algorithms compute accurately julia using accuratearithmetic algorithm ogita rump oishi julia sumoro algorithm kahan babuska neumaier julia sumkbn graphs relative error vary function condition loglog scale errors lower arbitrarily set conversely relative error digit correctly computed anymore error capped avoid affecting scale graph left pairwise summation algorithm implemented basesum starts losing accuracy soon condition increases computing noise condition exceeds goes naive summation algorithm contrast compensated algorithms kahanbabuskaneumaier ogitarumpoishi accurately compute result start losing accuracy computing meaningless results condition nuber reaches effect simply compensated algorithms produce results naive summation performed twice precision bits rounded bit floats comments dot product implementations shown uncompensated algorithms implemented accuratearithmeticdotnaive basedot internally calls blas exhibit typical loss accuracy contrast implementation ogita rump oishi compentated algorithm effectively doubles precision performancewise compensated algorithms perform lot alternatives arbitrary precision bigfloat rational arithmetic rational julia using benchmarktools julia length julia btime sum s allocations bytes julia btime sumnaive s allocations bytes julia btime sumoro s allocations bytes julia btime sumkbn s allocations bytes julia btime sum s allocations bytes julia btime sum rational bigint ms allocations mib compensated algorithms perform larger elementary operations naive floating counterparts usually perform worse leveraging power modern architectures via vectorization slow kept value benchmarks graphs obtained intel xeon gold cpu ghz time spent summation renormalized element plotted vector size standard summation vectors start significant sizes thousands elements implementation memory bound expected typical blas operation significant decreases performance vector fit l l l cache avxenabled system kahanbabuskaneumaier implementation tends little efficient ogitarumpoishi algorithm opposite avx systems implemented suitable unrolling level cache prefetching implementations cpubound vectors fit inside l l cache vectors fit l cache implementation memorybound system means performance standard summation dot product calculations graph implementations accuratearithmeticjl compete mkl dot product words improved accuracy free sufficiently vectors vectors accuracy comes slow factor approximately l cache mixedprecision algorithms singleprecision floating float efficient rely possibility internally doubleprecision accuracy mixedprecision implementations provided package convenience generate illconditioned sum float requested condition f julia generatesum f reference result julia sum standard algorithm error julia sum f mixedprecision implementation julia summixed mixedprecision summation implementations perform approximately naive ones julia randfloat julia btime sum s allocations bytes f julia using accuratearithmetic julia btime summixed s allocations bytes depending system mixedprecision implementations dot product competitive especially avx systems avx cpus faster compensated algorithms julia randfloat julia randfloat julia using linearalgebra julia btime dot s allocations bytes f julia using accuratearithmetic julia btime dotmixed s allocations bytes julia btime dotoro s allocations bytes f tests graphs reproduced using testperftestsjl script repository running aware takes hours generate performance graphs benchmark machine lowloaded avoid perturbing performance measurements references elrod fvotte accurate efficient sums dot products julia preprint ogita rump oishi accurate sum dot product siam journal scientific computing doi