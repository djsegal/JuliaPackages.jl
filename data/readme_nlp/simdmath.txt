simdmathjl lightweight module explicit vectorization simple math functions focus mainly vectorizing polynomial evaluation main evaluating polynomials similar length evaluating single polynomial primary vectorizing bessel function evaluation besselsjl module statically functions coefficients unrolled size tuples compilation advanced simdjl loopvectorizationjl simdpolyjl similar package utilizing simdjl experimental support complex provided package requires julia v evaluating polynomials evaluation special functions compute polynomials example structure look const nt const ntuple rand nt ntuple rand nt ntuple rand nt ntuple rand nt function test x x x p evalpoly x p evalpoly x p evalpoly x p evalpoly x return muladd p p muladd x p p structure advantageous vectorizing p p p p independent require evaluations coefficients statically relying autovectorizer happens fragile polynomials autovectorizer depending values reliable check function vectorizing architectures using codellvm test codenative test benchmark function compare time compute single polynomial julia btime test setup rand ns allocations bytes julia btime evalpoly setup rand ns allocations bytes test x polynomial evaluations happening sequentially polynomials vectorize using coefficients julia using simdmath const packp packpoly inline function testsimd x x x hornersimd x packp return muladd data value data value muladd x data value data value julia btime testsimd setup rand ns allocations bytes evaluating single polynomial improving performance evaluating single polynomial larger degree horner scheme latency bound polynomials total runtime test performance using straight horner scheme using base library function evalpoly horner schemes hornertimes hornertimes hornertimes hornertimes hornertimes hornertimes poly ntuple rand polypacked packhorner poly val polypacked packhorner poly val polypacked packhorner poly val polypacked packhorner poly val polypacked packhorner poly val t benchmark evalpoly poly setup rand t benchmark horner polypacked setup rand t benchmark horner polypacked setup rand t benchmark horner polypacked setup rand t benchmark horner polypacked setup rand t benchmark horner polypacked setup rand push hornertimes round minimum t time digits push hornertimes round minimum t time digits push hornertimes round minimum t time digits push hornertimes round minimum t time digits push hornertimes round minimum t time digits push hornertimes round minimum t time digits using plots plot hornertimes hornertimes lw label nd xlabel degree polynomial ylabel relative speedup evalpoly legend topleft plot hornertimes hornertimes lw label th plot hornertimes hornertimes lw label th plot hornertimes hornertimes lw label th plot hornertimes hornertimes lw label nd mentioned horner scheme requires sequential multiplyadd instructions performed parallel estrin method discuss improve structure break polynomial odd polynomials horner scheme larger powers fourth eighth horner scheme allow computing polynomials similar length simultaneously regard rearranging coefficients using method additional arithmetic add polynomials method considered fastmath approach rearranges floating arithmetic actually increasing total amount arithmetic operations increasing amount operations happen parallel increased operations advantages approach straightforward superior floating arithmetic associative approaches slightly results adding multiplying slightly differnet asymptotically method approaches x increase respecitively degrees degrees advanges complex encouraged test performance individual course depends statically knowing polynomial size compilation allows packing coefficients efficient horner method depend degree polynomial evaluate scheme fastest degrees faster standard evalpoly degrees th th degree polynomial preferred th nd scheme preferred polynomials benchmark run desired computer measured static degree fastest approach evaluating polynomial chebyshev basis similar evaluating polynomials using chebyshev basis particularly d simple comparison following define scalar version function clenshawchebyshev x c c length c c c c c x return c c scalar version evaluating single polynomial julia benchmark clenshawchebyshev setup rand benchmarktools trial samples evaluations range min max ns ns gc min max time median ns gc median time mean ns ns gc mean ns histogram frequency time ns memory estimate bytes allocs estimate simd version evaluating polynomials julia const p simdmath packhorner vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float vecelement float julia benchmark simdmath clenshawsimd p setup rand benchmarktools trial samples evaluations range min max ns ns gc min max time median ns gc median time mean ns ns gc mean ns histogram log frequency time ns memory estimate bytes allocs estimate computing chebyshev polynomials actually faster single polynomial coefficients packed efficiently operations leads speed associativity floating arithmetic slightly neccessarily accurate test