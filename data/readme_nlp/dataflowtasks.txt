dataflowtasksjl dataflowtasksjl julia package dedicated parallel programming multicore shared memory cpus user annotations read write readwrite program data dataflowtasksjl automatically infers dependencies parallel tasks readme available notebook form installation using pkg pkd add basic usage package defines dataflowtask type behaves julia native task except allows user specify explicit data dependencies information automatically infer task dependencies constructing analyzing directed acyclic graph based tasks access underlying data premise sometimes simpler specify tasks depend data specify tasks depend dataflowtask object intended similar julia native task api implements macros dspawn dtask dasync behave base counterparts except additional annotations declare task affects data accesses read read write write readwrite rw readwrite task body annotation example implies data accessed read mode task look simple example using dataflowtasks vector float undef result dspawn fill task accesses dspawn rw view task modifies half dspawn rw view task modifies half dspawn task result fetch result annotations describing taskdata dependencies dataflowtasksjl infers dependencies tasks internally set dependencies represented directed acyclic graph reconstructing dag parallalel traces using log macro using graphviz triggers additional code loading powered requiresjl loginfo dataflowtasks log dspawn fill label write dspawn rw view label write dspawn rw view label write res dspawn label read fetch res dag dataflowtasks plotdag loginfo example tasks write write access array independant shown dag example parallel cholesky factorization contrived example illustrate dataflowtasks parallelize tiled cholesky factorization implementation shown delibarately simple complex efficient implementation found tiledfactorization package cholesky factorization algorithm takes symmetric positive definite matrix lower triangular matrix ll tiled version algorithm decomposes matrix tiles sizes simplified version step algorithm cholesky factorization diagonal tile triangular solve update tiles diagonal tile finally update tiles submatrix schur complement matrix decomposed tiles algorithm steps th step perform cholesky factorization block triangular solves block th row matrix multiplications update submatrix following image illustrates nd step algorithm sequential tiled factorization algorithm implemented using linearalgebra tilerange ti ts ti ts ti ts function choleskytiled ts size assert size ts error tilesize fit matrix ts tiles dimension view tilerange ts tilerange ts diagonal cholesky serial factorization cholesky left blocks update uppertriangular ldiv submatrix update mul construct factorized object return cholesky zero linearalgebra blasint parallelizing code dataflowtasksjl easy wrapping function calls dspawn adding annotations describing data access modes using dataflowtasks function choleskydft ts size assert size ts error tilesize fit matrix ts tiles dimension view tilerange ts tilerange ts diagonal cholesky serial factorization dspawn cholesky rw label chol left blocks update uppertriangular dspawn ldiv rw label ldiv submatrix update dspawn mul rw label schur construct factorized object dspawn cholesky zero linearalgebra blasint label result return fetch note extra annotations added code attach meaningful labels tasks useful interpret output debugging profiling tools code choleskytiled function profile program information tasks scheduled dataflowtasks environnement setup context ts rand adjoint run trigger compilation choleskydft copy ts check results err norm inf max norm norm debugging profiling dataflowtasks comes debugging profiling tools help understanding task dependencies inferred tasks scheduled execution usual profiling code recommended start code compiled previous profiling information discarded manually call gc avoid noise previous runs gc gc profile code return loginfo object loginfo dataflowtasks log choleskydft ts visualizing dag helpful debugging representation dependencies tasks inferred dataflowtasks help identify missing erroneous data dependency annotations profiling identifying critical path plotted red dag help understand performances implementation complex example quickly dag complexity increases test x blocks dag dataflowtasks plotdag loginfo parallel trace plot timeline tasks execution available threads helps understanding tasks scheduled window carries information allowing understand performance limiting factors using cairomakie glmakie interactivity trace dataflowtasks plottraces loginfo categories chol ldiv schur execution time bounded length critical path block size matrix size algorithm expose parallelism occupy threads waiting periods cover details usage possibilities visualization documentation note debugging profiling tools additional dependencies makie graphviz meant interactively development process packages considered optional depdendencies assuming available environment calling using graphviz load additional code dataflowtasks documentation dataflowtasksusingopt prefer alternative handling extra dependencies performances performance example improved using implementations sequential building blocks operating tiles loopvectorizationjl improve performance sequential cholesky factorization diagonal blocks schurcomplement triangularsolvejl provides performance ldiv implementation approach pursued tiledfactorizationjl mentioned building blocks combined parallelization strategy create pure julia implementation matrix factorizations performances implementation assessed following plot comparison mkl x matrix decomposed tiles size x figure generated running script machine x intel xeon silver cores ghz following topology page generated using literatejl