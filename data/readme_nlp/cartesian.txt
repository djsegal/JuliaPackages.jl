cartesianjl fast multidimensional algorithms julia language package provides macros currently appear performant implement numerous multidimensional algorithms julia news cartesian base backwards compatibility re using prerelease version julia recommend using version base access using basecartesian recommend base documentation purpose package provide basecompatible implementation cartesian julia implemented release package unfortunately changed features including naming convention variables i i directly names break code sorry pin package release changes code legacy documentation following documentation applies package series julia documentation using recent version package caution practice cartesian effectively introduces separate dialect julia reason hope main language eventually support functionality happens obsolete meantime package appears powerful write efficient multidimensional algorithms installation install package manager pkgaddcartesian principles usage macros package nloops begin nref generates following code i size i size i size iii basic syntax nloops follows argument integer variable specifying loops argument symbolprefix iterator variable variables i i i generated third argument specifies range iterator variable variable symbol sizedim flexibly anonymousfunction expression syntax described argument body loop appears begin additional features described nref follows similar pattern generating iii nref practice read left nloops nloops expr i size i left range whereas nref nref iii array comes re developing code cartesian debugging easier generated code via unexported underscorefunction variants julia cartesiannref exprescape iii similarly cartesiannloops additional described supplying dimensionality functions argument macros dimensionality integer re writing function intend multiple dimensions hardcode fortunately straightforward eval construct eval begin function laplacianarray similar nloops begin generate versions laplacian dimensions somewhat awkward generate truly arbitrarydimension functions using wrapper track compiled version function dimensionalities data types mysumdefined dict bool global mysum function mysumstridedarray def mysumdefined typeof false def ex quote function mysumstridedarray zero nloops begin nref evalcurrentmodule ex mysumdefinedtypeof true mysum addition version performance price checking dictionary anonymousfunction expressions macro arguments single powerful feature cartesian ability supply anonymousfunction expressions macros consider implementing laplacian function mentioned discrete laplacian dimensional array calculated lap a obvious issue formula handle edges exist illustration anonymousfunction expressions easy avoid dealing handle properly d write code i size i size lapii note range size omits index cartesian written following nloops size begin nref lap note range argument supplied anonymous function key anonymous function evaluated macro runs whatever symbol appears variable anonymous function looped dimensionality effectively expression inlined hence generates exactly code extra runtime overhead bit extra syntax associated expressions expression id translated i suppose sets variables main indices i i i offset indices j j j expression nref idjd translated ij ij ij notation mimics subscript notation latex latex curlybraces subexpressions example ppd generates p p complete example implementing imfilter machinery implement simple multidimensional function imfilter computes correlation similar convolution array filtering kernel kern require kernel oddvalued sizes dimension size suppose function padarray pads width edge dimension using whatever boundary conditions user desires complete implementation imfilter eval begin function imfilterarray kernarray boundaryargs divsizekern sizekern errorkernel odd size dimension apad padarray boundaryargs similar nloops begin compute filtered value tmp zero nloops kern begin tmp nref apad idjdnref kern store result nref tmp note line tmp nref apad idjdnref kern translated tmp apadij ij kernj j note assignment requires parenthesis nref otherwise expression tmp passed final argument nref macro complete example implementing laplacian implement laplacian imfilter wasteful corners xx grid edges center consequently write considerably faster algorithm advantage imfilter grow rapidly dimensionality implementing algorithm illustrate flexibility anonymousfunction range expressions key macro nexprs dimensions generate following code replicating boundary conditions handle edges gracefully function laplacianarray similar i size i size tmp zero tmp i size ii ii tmp i size ii ii tmp i ii ii tmp i ii ii ii tmp ii generate terms indices unaltered anonymous function dd d id id shifts d d macro nexprs documented generate expressions complete implementation dimensions eval begin function laplacianarray similar nloops begin tmp zero shift nexprs dbegin tmp id sized nref dddidid nref shift nexprs dbegin tmp id nref dddidid nref subtract center store result nref tmp nref reductions broadcasting cartesian makes easy implement reductions broadcasting using pre post expression syntax described suppose implement function compute maximum usersupplied dimensions array maxoverdims computes max dimensions allow user choose dimensions arbitrarily dimensional arrays handwrite code following function maxoverdimsabstractmatrix region szout size size szoutregion output unitsize chosen dimensions filltypemin szoutarray julia infer dimensionality szout szout szout szout i size j szout i i size j szout i inbounds jj maxjj ii code generated arbitrary dimensions following eval begin function maxoverdimsabstractarray region szout size szoutregion filltypemin szoutarray cartesiannextract szout szout cartesiannloops jd szoutd id begin inbounds cartesiannref maxcartesiannref cartesiannref slightly concerned conditional expression inside inner loop influence performance fortunately impact modest author tests percent reason execution function branches resolves consequently cpu learn predict accuracy branch computation time dominated cachemisses generated traversing array macro reference core macros nloops itersym rangeexpr bodyexpr nloops itersym rangeexpr preexpr bodyexpr nloops itersym rangeexpr preexpr postexpr bodyexpr generate nested loops using itersym prefix iteration variables rangeexpr anonymousfunction expression simple symbol var range sizevar dimension optionally provide pre post expressions executed respectively body loop example nloops jdminid begin nref generate i size j mini i size j mini j j postexpression supply preexpression using parenthesis semicolons supply multistatement expressions nref indexexpr generate expressions ii indexexpr iterationsymbol prefix anonymousfunction expression nexpr expr generate expressions expr anonymousfunction expression laplacian example nextract esym isym tuple vector length nextract generate expression i i i thereby extracting element separate variable nall expr nall id generate expression i i i convenient boundschecking nlinear indexexpr array subarray nlinear indexexpr generates array linear index equivalent nref indexexpr convenient implement algorithm using linearindexing particularly useful anonymousfunction expression evaluated compiletime example using example images suppose iterate pixel perform calculation base color dimension array particular function rgb generates rgb color pixel array following sz sizeimg ndimsimg cd colordimimg determine dimension img represents color szcd iterate color separately strd strideimg cd nextract sz sz dataimg nloops szd begin nlinear rgbval rgb strd strd appears difficult generate code using nref expression cd evaluated compiletime additional macros ntuple itersym ntuple expr generates tuple symbol prefix ii anonymousfunction expression nrefshift generates ijij legacy nref accepted anonymousfunction expressions nlookup generates ii ii easily achieved nref indexedvariable generates expression indexedvariable generate i forcartesian itersym sz bodyexpr macro collection outlier terms functionality sz forcartesian sz begin println generates following output simple example forcartesian generates block code isempty sz prod sz length sz ones int sz sz isdone false isdone println whatever code inside loop sz idim idim szidim idim idim idim idim isdone sz overhead direct loop approach nloops algorithms matter advantage dimensionality compiletime performance improvements subarrays julia currently lacks efficient linearindexing generic subarrays consequently cartesian indexing performance address elements subarray simple algorithms sum performance boosted immensely implementing subarray using cartesian example d easy boost scale fold