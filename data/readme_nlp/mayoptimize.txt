conditionally optimize julia code writing performance julia code reference code perform bound checking version assumes valid indices avoid bound checking heavily optimized version requires loop vectorization mayoptimize package variants available single version code documentation usage mayoptimize summarized following short example using mayoptimize function foo type abstractarray real optimlevel zero loop compute sum values maybeinbounds eachindex loop fill sum values maybevectorized eachindex return note loops preceded macros maybeinbounds maybevectorized arguments parameter expression block code nd argument simple loop maybevectorized macro compiled expression block code determined type parameter debug debugging reference code performs bound checking vectorization inbounds code assumes valid indices avoids bound checking vectorize code assumes valid indices requires vectorization block code provided maybeinbounds macro compiled bound checking vectorization debug bound checking inbounds specified inbounds vectorize inbounds specifying vectorize maybeinbounds avoid bound checking block code provided maybevectorized macro compiled bound checking vectorization debug bound checking inbounds inbounds specified bound checking vectorization vectorize inbounds simd specified hence version foo called decided julia method dispatcher according abstract types debug inbounds vectorize exported mayoptimize calling foo debug executes version checks bounds vectorization calling foo inbounds executes version avoids bound checking loops finally calling foo vectorize executes version avoids bound checking loops vectorizes loop easy provide default version users bother choosing version instance assuming checked code issues indexing vectorization makes difference write foo abstractarray real foo inbounds decide change default optimization level installation julia hit key switch package manager repl pkg prompt type add mayoptimize packages examples left divison triangular matrix mayoptimize extends base linear algebra methods ldiv method perform left division vector matrix called using mayoptimize linearalgebra ldiv opt ldiv opt operation overwritten stored argument opt mayoptimizestandard julia standard method probably blas debug inbounds vectorize compile julia code mayoptimize optimization settings following figures obtained julia amd ryzen threadripper x core processor efficient julia code compiled chosen optimization settings note gain compared standard implementation simd innermost loop level look srclinalgjl realize code identical debug inbounds vectorize settings opt argument changes code pretty straightforward cholesky decomposition mayoptimize extends cholesky cholesky methods perform cholesky decomposition pivoting hermitian matrix regular julia code optimization level opt using mayoptimize linearalgebra cholesky opt cholesky opt decomposition uopper lower triangular overwritten factor cholesky decomposition returned left unchanged apart opt argument avoids typepiracy rounding errors result standard method provided linearalgebra calls blas illustrated julia code faster blas matrices size equal spite blas run threads whereas optimized julia code executed single thread opt argument specifies optimization level debug inbounds vectorize algorithm decomposition choleskybanachiewiczloweri choleskybanachiewiczlowerii choleskybanachiewiczupper choleskycroutlower choleskycroutupperi choleskycroutupperii instance choose op choleskybanachiewiczlowervectorize compute cholesky factorization lower triangular choleskybanachiewicz rowsize algorithm loop vectorization algorithm specified optimization level optimization level algorithm conversely optimization level specified fastest algorithm default choices optimal testing machine following figures obtained julia float values amd ryzen threadripper x core processor efficient julia code compiled chosen optimization settings note gain compared blas implementation simd innermost loop levels matric