bitpermutationsjl efficient routines repeated bit permutations introduction permutations bits performed log operations reshuffle individual bits parallel reshuffling layer efficient chosen sets operations efficient cpu precomputing operations slighly trivial package useful compute application permutation words installation bitpermutations julia language package install package please julia interactive session repl press key repl package mode type following command pkg add bitpermutations usage define permutation bits type construct bitpermutation example uint bits lsb msb using bitpermutations bitpermutation uint apply permutation bitstring type uint using bitpermute functional approach jam equivalently call bitpermutation directly x lsb msb bitpermute x idem inspect result bitstring bits defined package basically faster bitvector defined base size fixed mutable bits bits bits bits bitpermute neat underlying network inverse permutation computed cost performed using invbitpermute calling adjoint permutation invbitpermute bits invperm bits invbitpermute internally vector bit masks shifts stored applied sequentially call bitpermute apply permutation array data following syntax xs rand xs regular permutation elementwise bitpermutexs bitpermute xs idem bitpermute xs idem xs inverse permutation elementwise invbitpermutexs invbitpermute xs idem invbitpermute xs idem internally broadcasted loop slices stage performed parallel leads significant performance increase usual original vector permutation step version faster saves allocations benchmarks functionalities mentioned summarized plot results obtained intel caskadelake processor running julia single thread accurately measure repeatedly perform permutation times similarly rand bitpermute broadcasted permutation performed array elementwise fashion xs rand bitpermute xs choose divide median execution time considering single permutations bene networks consistently faster nave permutations bitvector factor approximately discussed types uint uint choosing grpnetwork lead significant speedups processors support bmi instructions indeed leads speedup compared bitvector exploits advanced processor intrinsincs stage types fallback implementation primitive operations slow avoided benchmark performed random permutations somewhat worst scenario network typically stages permutations completely random structure achieve larger speedups dramatic speedup arraywise permutations benesnetwork permute bitstrings couple nanoseconds yielding speedups magnitude uint uint respectively operations rearranged single layers network applied sequence bit string applied globally element allows processor operation potentially avx instructions speedups observed apple silicon unclear grpnetwork faster benesnetwork uint uint investigate uint bitstrings exceed processor word size bit slower speedup depend choice mileage vary especially depending array fits cache benchmark routine found benchmarkbenchmarksjl script plotting results benchmarkplotjl details depth explanation wonderful worth reading performing permutation implemented rearranged bene networks grp networks latter faster cpus support bmi instruction set hence permutation constructed using benesnetwork unless unionuintuint bmi instructions supported grpnetwork bmi intrinsics disabled setting envbpusebmi false loading package setting export bpusebmifalse launching julia bene networks bene network series butterfly deltaswap operations node swapped corresponding node shifted fixed amount operations arranged pairs nested fashion shifts chosen powers example network nodes stages pairs reshuffling respectively innermost operations fused single somewhat remarkably perform arbitrary permutation relatively efficient deltaswap cycles modern processors construction masks swaps explained donald knuth art computer programming vol fascicle a addisonwesley stanford available prefascicle idea view stage pair masks repartition nodes sets construct graph edge corresponds constraint nodes partitions input output color graph route node corresponding partition color fortunately graph bipartite easy iterate cycles graph assign alternating colors nodes visit wish optimize network masks trivial swaps unfortunately exhaustively checking log arrangements disabled passing keyword argument rearragefalse constructor grp networks grp networks similar bene network except layer reshuffling grp sheepsgoats taocp grp networks typically shallower reshuffling operation efficient specific instructions available hardware performed cycles pextpdep instructions grp reshuffling supported intel starting haswell architecture released amd zen architecture released amd architectures pextpdep implemented microcode reportedly slower machines experiment method faster possibly disable calls bmi envpbusebmi false fallback operations implemented typically slower butterfly operations construction masks follows algorithm lee shi yang efficient permutation instructions fast software cryptography ieee micro explained enhancements improvements list ones top head armspecific instructions nice improve performance arm processors exploiting intrinsics processors specifically apple silicon sve pextpdep equivalent grp operations unfortunately supported apple possibilities described preconditioning simple reducing depth network try cheap operations bitreverse bitshift network try save masks lookup tables permutations benefit subpermutations precomputed table pext extract bits time look permutation table elements join results approach fast scales linearly size time space permutations uint uint possibly uint pshufb pshufb instruction sse perform arbitrary byte reshufflings compress bunch layers combined lookup tables promising speedups rearrangement finding arrangement stages bene network masks trivial currently exhaustive search constructing masks aware fallbacks faster software fallbacks pextpdep exist zp x intrinsics anyway code refactoring functional approach define permutation series transformations preserving type inference performance allow generic algorithms extensions compatibility package compatible julia