squaresymmetries squaresymmetries julia package allows applying elements symmetry square dihedral matrices symmetry consists operations rotations flipping elements axis installation install package julia repl enter pkg mode typing execute following pkg add squaresymmetries usage apply provided operations elements matrices simple function julia using squaresymmetries julia rand matrixfloat julia rotate matrixfloat julia flipx matrixfloat compose operations using julia function composition syntax julia rotate flipdiag equivalent flipadiag matrixfloat elements package provides eight elements element represented julia function unit rotate rotate rotate flipx flipy flipdiag flipadiag julia a a a a matrixstring a a a a julia unit identity matrixstring a a a a julia rotate rotate matrix matrixstring a a a a julia rotate rotate reverse elements matrixstring a a a a julia rotate rotate left matrixstring a a a a julia flipx flip elements axis matrixstring a a a a julia flipy flip elements axis matrixstring a a a a julia flipdiag flip elements main diagonal transpose matrixstring a a a a julia flipadiag flip elements anti diagonal matrixstring a a a a obtain eight symmetries symmetries function julia symmetries symmetry sometimes useful advantage structure consists elements binary operation unary operation inv operations directly elements julia rotate rotate rotate generic function method julia rotate rotate unit generic function method julia inv rotate rotate generic function method julia inv flipdiag flipdiag generic function method elements transformation replaced single element improve performance effectively replace computations single computation consider example validate rotating twice indeed yields original matrix julia rand huge test matrix julia time rotate rotate rotates huge matrix twice allocations gib gc time true julia time rotate rotate efficient rotate rotate unit id true admittedly example somewhat artificial nevertheless note huge difference allocated memory whenever situation apply multiple elements consecutively beneficial composition apply afterwards useful inverse element example consider algorithm performs matrix transformation transformation invariant elements following code verify julia myalg super clever matrix transformation julia rand test matrix julia squaresymmetries d assert inv myalg myalg code checks applying myalg applying inv output yields result applying myalg direct