kip kip alternative module system julia goal robust easier kip packages names instead modules identified file versions package overwriting favours putting dependency info inline require file reduces indirection repl final key difference installs dependencies runtime package installed run kipupdate occasionally update kip local cache packages plain git repositories installation pkg clone add code juliaconfigstartupjl import pkg using kip haskey env atomhome kip built julia available repl files run api kip api consists macro import modules function update rd party repositories pkgstring importssymbol takes path package list symbols import package name locally symbols pass pair symbols import local package available explain syntax path parameter example using relative path resolved relative repl pwd editing file dirname file familiar people unix machines assuming repl hood check file called joinpathpwd exists load otherwise tries paths joinpathpwd jl joinpathpwd mainjl joinpathpwd srcjl enables save bit typing feel couple types paths pass absolute usersjkroso github syntax actually pretty complex enable specify ref tagcommitbranch specified ref commit specify reponame prefixed looks semver query run tags repo tag matches query finally module repository called mainjl srcreponamejl specify path path completion applied relative absolute paths update runs git fetch repositories past time version native julia module support module require registered pkgdirmetadata installed loaded using built module system compare exactly equivalent import benchmark compare reduces likelihood duplicate modules loaded kip pkg respective caches especially julia provide load registered modules kip supports registered modules looking contents file requiring module unbox wrapper kip normally julia provides support registered modules kip pkgclone module import match handling registered modules running arbitrary code machine dependencies declared code pipe arbitrary code machine running julia results piped hand curl url julia run remote code local machine example running code docker instance btw docker installed run echo encode encode docker run jkrosokipjl c example projects jest demonstrates mixed native modules kip modules nice kip writing cli programs dependencies installed runtime jest cli script downloaded user path uri parser benchmark kip enabled benchmark code directly projects readmeipynb file worry installing dependencies prospective features automatic reloading modules repl listen changes modules require automatically reload workspace dependency tree linting kips ability load multiple versions module time double edged sword upside package developers breaking changes api instantly breaking dependent projects downside dependencies dependencies common load versions modules run issues passing type instances fourth direct dependencies subtle hard recognise especially aware happen solution static analysis tool check dependency tree potential instances sense linting tool