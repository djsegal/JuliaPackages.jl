julia expression julia convertor quickstart pkgclone julia import sexpr sexprmain usage sexprjl lines output extension files program port clojure expression syntax julia default program takes clojure syntax outputs julia version flip direction positional arguments files file output directory dump stdout directory multiple files eg sjulia file dir file output directory specified output files optional arguments invert julia code print expression code instead cat cat input stdin read file ignores positional args program lines lines blank lines exist top level forms default type int default output output write files multiple positional arguments file empty argument program throw error extension extension add extension qualifies lisp file multiple times defaults clj cljs cl lisp wisp hy help help message exit julia import sexpr sexprmain testoutput testprograms transpile clj files testprograms dump testoutput overview project aims expression syntax interoperable julia expr objects seen lispsyntaxjl similar idea imho project bit allow transpile filefile read program transpile convert julia files minus special forms supported clojure syntax makes julia python route pycall via hylang js via wispjs benefit awkward macro syntax languages avoided hy necessitates wrapping hymodel objects ridiculous wispjs module system broken javascript resolving variable names properly final goal interoperability macroexpand operation input clj syntax able folder clj files temp folder jl files created file read macroexpanded converted clj syntax written third folder unfortunately write jl files intermediary step able resolve imports alternatively write clj files jl files macro cljstr makes file string breaks syntax highlighters annoying re probably thinking project learn julia muck internals learned bit mission accomplished cljs selfhosting means hopefully js package soon dealing google closure compiler leiningen javajvm dependencies larger solved consider unwieldy practical effectively reader portion implementing lisp julia else using inbuilt mechanisms syntax overview atoms nil translates julia exactly true true false false surprises constants compile int float types rational constants supported julia character atom starting character newline space tab formfeed backspace return escapes unicodeoctal support handled strict giving literal silently character probably term strategy eg xyz string sequence characters inside double quotes multiline strings allowed padding subtracted keyword basically symbol starts julia confusingly called symbols symbols called variables keywords clojure keywords colons resolved current namespace behavior compiles normal symbol julia namespacing probably issues symbol identifier variable character converted julia eg modulefunction modulefunction identifier relatively consistent clojure semantics clojure lenient symbol characters julia limitation default output unicode characters regular ones suffice allowed inside symbol todo option escaped ascii names available ugly avoids unicode pain depending unicode extension defined symbol identifier compiles type eg int compiles int tt compiles union tt t t collections list quoted evaluated transpiled quoted lists evaluate tuples vector transpiles julia array map transpiles julia dict form todo set map set julia julia special forms short circuit expect special form short circuiting julia defines forms purpose expect family gettingsettingslicing arrays aget exprref aget exprref aget aget preferred aget preferred typing int int form defines types int in unionint int autounion types defined useful function type defintions curly array int arrayint allow parameterized types dot call form dot access form note equivalent modules import module creates module visually annoying indent file spaces call module figured option module special hash dispatch wraps file meh consider priority importusing contrary expectations import separate import statement functionfile todo cartesian productable import expand import import import instead shorten writing ideally system macro systemclj file define call import export export makes sense julia view modules flat level definitions export special forms empty list compiles empty tuple lisps equivalent nil eg common lisp clojure following convention exprs expression returns results test true false standard evaluates form branches var value var value exprs binds pairs variables values evaluates exprs implicit fn name params exprs defines function function name expr body converted form eg fn defn name docstring params exprs named defined function docstrings ignored def var expr defines variable throw function julia special form dedicated include function julia dedicated special form todos looprecur julia equivalent trycatchfinally vars expr useful lazy iterators destructuring rest param fn rest defmulti related mean julia multipledispatch deftype type julia macro forms call macro prepend name unfortunately julia requires distinction resolve macros involve writing entire compiler simple leaving requirement todo means deref clojure choose symbol denote macrocall future maybe idea abusing dispatch macro html div helloworld calls form macro regular function hash dispatch worse defmacro defines macro expected macros macro definition passed clojure expression passed julia equivalent macro output clojure expression translated reader julia expression means whatever program write include reader module project produce desired output macro call sexprrehydrate translate expression julia native ast quote literal list following expression quote form properly escape symbols eg equal julia stop gensym pass running actually esc equivalent unclear translation desired results quote syntaxquote changed putting esc calls compile function call code syntaxquote backtick character quoting form julia actually syntax quote autogensym pain return original name obfuscation unquote julia inside expressions evaluate variable macro evaluated value unquotesplice unquotes expands form layer form returned ie julia