settheoretic types toy type system intersections complements julia inspired discourse discussion speculative excerpt jeff bezanson juliacon talk module implements bits settheoretic type system extend julia type system separate serving proof concept intersection complement types stt begin abstract type smart abstract type organic struct computer smart struct fruit organic struct brain smart organic intersection type smart value thinking smart value complement type notably concrete type subtyped including intersections settheoretic types instances julia computer deepthought deepthought thinking julia fruit quince quince actual data type instance relationship settheoretic type merely wrapper julia fruit pineapple value typeof regex theory formal type theory figure project particular don consistent settheoretic types sets runtime values picture concrete abstract types sets combined boolean operations stt abstract type stt abstract type stt abstract type stt abstract type assert assert assert assert little structure value belongs exactly concrete type concrete types partition set values top don care sets don respect partition type containing int values particular means concrete types subtypes empty set top intersection distinct concrete types top stt struct alpha stt struct beta assert alpha beta top intersection types abstract types helpful picture settheoretic types sets equivalence classes values concrete type equivalent picture concrete types singleton sets abstract types sets arbitrary extent core julia parametric types indexed sets types type parameters invariant merely type name stt struct box assert boxalpha box assert boxalpha stt box assert boxalpha box notation t t represents union parameter values note tuples types invariant parameters product type settheoretic picture tuplekind cartesian product supertype tuplekindalphabeta alpha beta syntax convenience macros clever overload julia actual type system settheoretic versions core julia type mechanisms names syntax clean separation probably makes clearer means duplication syntax chosen arbitrarily julia types settheoretic types abstract type stt abstract type struct stt struct isa stt top stt tuple tuplekind union union top macro stt et heoretic ypes allows declare types methods using familiar declarative syntax example block stt begin abstract type animal struct cat animal struct box boxcat box animal pack box unpack box value equivalent following code directly constructs kinds functions quote animal animal top false abstract cat cat animal true concrete box kindvar unionallkind box top true boxcat kindvar top animal unionallkind box pack kindfunction pack kindmethod kindvar unionallkind tuplekind box unpack kindfunction unpack kindmethod tuplekind box value notice gizmos core julia type system type typevar unionall union tuple typeof supertype analogous versions kindvar unionallkind unionkind tuplekind kindof superkind alongside additional intersectionkind complementkind traits traits stt begin abstract type hasduckbill abstract type layseggs abstract type mammal abstract type bird struct platypus hasduckbill layseggs mammal struct canadiangoose hasduckbill layseggs bird foo hasduckbill layseggs platypus goose disadvantage introduce trait stt abstract type isalive existing types don mammal bird isalive changing definitions animal types settheoretically equivalent isalive mammal bird indeed declare supertype haven seen reason disallow stt abstract type isdead mammal bird isalive isdead miraculously julia platypus isalive true trick ergonomic allowing syntax stt abstract type isalive mammal bird mean type system appears allow declaration supertypes cool huh