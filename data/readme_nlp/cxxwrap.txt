cxxwrap package aims provide boostpython wrapping types functions julia idea write code julia wrapper liner julia wrapped library available mechanism package functions types registered code compiled dynamic library dynamic library loaded julia julia package data provided interface generate functions accessible julia functions passed julia raw function pointers regular functions argument return type conversion stdfunctions lambda expressions automatic conversion arguments return types julia package wraps julia methods automatically user compiler installed supports gcc clang macos users means xcode difference cxxjl cxxjl directly access using cxx macro julia facing task wrapping library julia package authors options cxxjl write wrapper package julia code ccall wrapping library cxxwrap write wrapper completely line julia code load boostpython latter approach translating existing python bindings based boostpython easier using cxxwrap features support functions functions lambdas classes single inheritance using abstract base classes julia trivial classes converted julia isbits immutable template classes map parametric types instantiations listed wrapper automatic wrapping default copy constructor mapped copy defined wrapped class facilitate calling julia functions installation registered package pkg mode repl add cxxwrap cxxwrap v depends libcxxwrapjuliajll jll package manage libcxxwrapjulia binaries libcxxwrapjulia readme information build library force cxxwrap version boost python hello world example try reproduce example boostpython tutorial suppose expose following function julia module called cpphello stdstring greet return hello world using cxxwrap exposed follows include jlcxxjlcxxhpp jlcxxmodule definejuliamodule jlcxxmodule mod mod method greet greet code compiled shared library julia follows load module generate functions module cpphello using cxxwrap wrapmodule joinpath pathbuiltlib libhello function init initcxx call greet result cpphello greet code example found hellocpp examples directory libcxxwrapjulia project testhellojl note init function support precompilation default julia compiling code recommended compile code cmake discover libcxxwrapjulia julia libraries example testlib directory libcxxwrapjulia following sequence commands build mkdir build cd build cmake dcmakebuildtyperelease dcmakeprefixpathpathlibcxxwrapjuliaprefix pathsourcedirectory cmake build config release path cmakeprefixpath obtained julia using julia using cxxwrap julia cxxwrap prefixpath windows msvc default binaries installed cxxwrap crosscompiled using gcc incompatible visual studio msvc msvc easy check libcxxwrapjulia git build wrapper module source details provided readme module entry defined module entry function jlcxxmodule definejuliamodulejlcxxmodule mod multiple modules defined single library entry called appropriate module jlcxxmodule definemodulea jlcxxmodule mod add stuff jlcxxmodule definemoduleb jlcxxmodule mod add stuff julia name entry specified explicitly module using cxxwrap wrapmodule definemodulea module using cxxwrap wrapmodule definemoduleb specific specify dlopen flags rtldglobal supplied third optional argument wrapmodule wrapmodule cxxwrapcore libcxxwrapjuliastl definecxxwrapstlmodule libdl rtldglobal extensive example function call performance extensive example including wrapping lambda conversion arrays found examplesfunctionscpp testfunctionsjl test includes performance measurements function call overhead using ccall function function regular function require argument conversion stdfunction lambdas extra overhead appears expected exposing classes consider following class wrapped struct world world const stdstring message default hello msgmessage void set const stdstring msg msg msg stdstring greet return msg stdstring msg world stdcout destroying world message msg stdendl wrapped entry function defining module cpptypes code exposing type methods julia typesaddtypeworld world constructor const stdstring method set worldset method greet worldgreet line adds type line adds default constructor taking string finally method calls add functions using pointer functions free functions julia taking object argument julia cpptypes world test cpptypes greet default hello cpptypes set hello test cpptypes greet hello manually added constructor using constructor function creates finalizer disabled adding argument false typesaddtypeworld world constructor const stdstring false addtype function actually builds julia types related world abstract type abstract type world mutable type allocated boxed type following structure mutable struct worldallocated world cppobject ptrcvoid type mutable finalizer attached deletes held object means variable example concrete type worldallocated letting scope trigger finalizer delete object calling constructor responsibility caller manage lifetime resulting variable types method generation follows considering example greet method taking world argument greet world ccall fpointer ptrcvoid worldref thunk cconvert worldref cconvert worldallocated worldref defined automatically creating type warning code matters types function arguments return types added function code example info immutables bits types found examplestypescpp testtypesjl checking null values returned checked null using isnull function setting module methods added add methods directly julia base module using setoverridemodule calling methods added specified module revert default behavior adding methods current module call unsetoverridemodule modaddtype jlcxxjuliatype abstractfloat base constructor double modsetoverridemodulemodjuliamodule wrapped module modmethod return modsetoverridemodulejlbasemodule following methods base modmethod return modmethod float return getval revert default behavior modunsetoverridemodule modmethod val return getval inheritance encapsulate inheritance types inherit staticcast base type struct virtual stdstring message const stdstring data mydata struct virtual stdstring message const return adding type add supertype argument typesaddtype method message message typesaddtype jlcxxjuliabasetype supertype type jldatatypet using template function jlcxxjuliabasetype looks abstract type associated concrete arguments ccall reference types convert bref aref allow cxxwrap figure correct staticcast hierarchy defined compile time follows namespace jlcxx template struct supertype typedef type variant taking string type name optional julia module name argument useful inheriting type defined julia modaddtypeteuchosparameterlist parameterlist jlcxxjuliatype abstractdict base value returned addtype dt method useful template types auto multivectorbase modaddtypeparametrictypevar multivectorbase auto vectorbase modaddtypeparametrictypevar vectorbase multivectorbasedt test examplesinheritancecpp testinheritancejl enum types enum types converted stronglytyped bits types julia consider enum enum myenum enumvala enumvalb registered follows jlcxxmodule definetypesmodule jlcxxmodule types types addbits myenum myenum jlcxxjuliatype cppenum types setconst enumvala enumvala types setconst enumvalb enumvalb enum constants available julia cpptypesenumvala cpptypesenumvalb type cpptypesmyenum wrapped functions taking myenum accept value type cpptypesmyenum julia template parametric types natural julia equivalent template class parametric type mapping complicated parameter values compiled advance requiring deviation syntax adding regular class consider following template class template typename typename struct templatetype typedef typename valtype firstvaltype typedef typename valtype secondvaltype firstvaltype getfirst return value secondvaltype getsecond return value code wrapping typesaddtypeparametrictypevar typevar templatetype applytemplatetypepp templatetypepp auto wrapped typedef typename decltype wrappedtype wrappedt wrapped method getfirst wrappedtgetfirst wrapped method getsecond wrappedtgetsecond line adds parametric type using generic placeholder parametric typevar parameter line instantiations created calling apply result addtype allow templatetypepp templatetypepp exist p p classes wrapped fulfill requirements parameter templatetype argument apply functor generic lambda takes wrapped instantiated type called wrapped argument object define methods generic lambda actual type wrapped obtained using decltype shown th line julia import parametrictypes templatetype parametrictypes p parametrictypes p p templatetype p p p templatetype p p test parametrictypes getfirst p test parametrictypes getsecond p applycombination method applying combinations parameters shorter write example test including type parameters examplesparametriccpp testparametricjl constructors destructors default constructor manually added constructor using constructor function automatically create julia object finalizer attached calls delete free memory write function returns object garbagecollected julia jlcxxcreate function jlcxxcreateclassconstructorarg return object wrapped jlvaluet finalizer copy constructor copy constructor mapped julia standard copy function using notation easily create julia arrays elements stdvector wvec cppfunctionreturningvector juliaarray copy wvec call operator overload julia supports overloading function call operator wrap operator omitting method name struct calloperator int operator const return typesaddtypecalloperator calloperator method calloperatoroperator julia callop calloperator test callop function operator course logical automatic argument conversion default overloaded signatures wrapper methods generated method taking double called int julia wrapping function modmethod halflambda const double return yields methods halflambda arg int halflambda arg float template parameter depends type desired behavior disabled argument basis using strictlytypednumber type wrapping function modmethod stricthalf const jlcxxstrictlytypednumber double return value yield julia method stricthalf arg float note value accessed using value strictlytypednumber customization automatic overloading customized example allow passing int uint normally expected following method added cxxwrap argumentoverloads typeuint int integer types due built integer types imposed size mapped julia integer types platform cxxwrap following approach fixedsize types intt mapped directly julia equivalents built types mapped named type type cxxlong julia implementation intt julia cxxlong alias int otherwise bits type following table overview mapping cxx types actually aliases julia type julia intt int uintt uint intt int uintt uint intt int uintt uint intt int uintt uint bool cxxbool char cxxchar wchart cxxwchar signed char cxxsignedchar unsigned char cxxuchar short cxxshort unsigned short cxxushort int cxxint unsigned int cxxuint cxxlong unsigned cxxulong cxxlonglong unsigned cxxulonglong pointers references simple pointers references treated wrapped struct single pointer object references pointers reference pointer allows changing referred object void writepointerref mydata ptrref delete ptrref ptrref mydata called julia ptrmodif mydata writepointerref ref note modifies mydataallocated details pointermodification example reference bool julia calling convention boolean cuchar pass reference boolean bref ref cuchar boolref bref boolref modmethod boolref bool strictly speaking representation bool implementationdefined conversion relies undefined behavior passing references boolean recommended sidestep writing wrapper function returns boolean value smart pointers currently stdsharedptr stduniqueptr stdweakptr supported transparently returning pointer types return object inheriting smartpointer typesmethod sharedworldfactory return stdsharedptrworld world shared factory hello shared pointer function taking object type world module named cpptypes swf cpptypes sharedworldfactory cpptypes greet swf adding custom smart pointer suppose smart pointer type defined follows template typename struct mysmartpointer mysmartpointer ptr mptrptr mysmartpointer stdsharedptr ptr mptrptr operator const return mptr mptr specializing jlcxx namespace namespace jlcxx template typename struct issmartpointertype cpptypesmysmartpointer stdtruetype template typename struct constructorpointertype cpptypesmysmartpointer typedef stdsharedptr type line marks type smart pointer enabling automatic conversion pointer referenced type adding dereferencing pointer type inheritance hierarchy defined using supertype automatic conversion pointer reference base type supported line indicates smart pointer constructed stdsharedptr adding autoconversion useful relation stdweakptr stdsharedptr example function arguments functions return references pointers writing julia functions operate types tricky example writing function juliagreet world greetcpp world type objects constructed directly returned value references pointers additional method juliagreet cxxwrapcxxbaserefworld greetcpp note signature implementation change cumbersome functions enter cxxdereference macro declaring function makes accept values references cxxdereference juliagreet world greetcpp cxxdereference macro changes function function juliagreet cxxwrapreferencetypeunion world cxxwrap dereferenceargument greetcpp type calculated cxxwrapreferencetypeunion function resolves unionworld cxxwrapcxxbaserefworld cxxwrapsmartpointerworld behavior macro customized adding methods cxxwrapreferencetypeunion cxxwrapdereferenceargument exceptions directly adding regular free function method called directly using ccall exception abort julia program avoid force wrapping stdfunction intercept exception automatically setting forceconvert argument method true modmethod testexception testexception true functions lambdas automatically wrapped stdfunction exceptions thrown intercepted converted julia exception tuples tuples converted julia tuples including containerstuplehpp header include jlcxxjlcxxhpp include jlcxxtuplehpp jlcxxmodule definetypesmodule jlcxxmodule containers containers method testtuple return stdmaketuple julia using cxxwrap using base test module containers wrapmodule libcontainers export testtuple using containers test testtuple f arrays reference native julia arrays arrayref type provided conveniently array data julia defining function void testarrayset jlcxxarrayref double const intt const double called julia ta testarrayset ta arrayref type provides basic functionality iterators size readwrite accessor pushback appending elements note arrayref primitive types boxed type array type arrayrefjlvaluet const arrays sometimes function returns const pointer array fixed size size determined elsewhere api example const double constvector static double return simple logical translate tuple mymodulemethod constptrarg return stdmaketuple constvector ptr constvector ptr constvector ptr larger blob heapallocated data makes sense convert constarray implements read julia array interface exposes data safely julia natively mymodulemethod constvector return jlcxxmakeconstarray constvector multidimensional arrays makeconstarray function takes multiple sizes const double constmatrix static double return module definition skipped mymodulemethod constmatrix return jlcxxmakeconstarray constmatrix note columnmajor convention julia sizes reversed julia code display constmatrix x constarrayfloat extra file included constant array functionality include jlcxxconstarrayhpp mutable arrays replacing makeconstarray examples makejuliaarray creates mutable regular julia array memory owned calling julia functions direct call julia directly calling julia functions jlcall julia convenient syntax automatic argument conversion boxing juliafunction functor invoked directly example calling max function base mymodulemethod juliamax double double jlcxxjuliafunction max max return max internally arguments return value boxed method convenient slower calling regular function safe cfunction macro cxxwrapsafecfunction provides wrapper basecfunction checks type function pointer example function mymodulemethod callsafefunction double double double throw stdruntimeerror incorrect callback result expected julia testf cfunc safecfunction testf float floatfloat mymodule callsafefunction cfunc using types expected function pointer call result error check incurs runtime overhead idea function converted applied times result safecfunction stored calling signature direct conversion created structure type safecfunction converted using jlcxxmakefunctionpointer mymodulemethod callsafefunction jlcxxsafecfunction fdata auto jlcxxmakefunctionpointer double double double fdata throw stdruntimeerror incorrect callback result expected method calling julia function convenient call overhead larger calling regular function pointer adding julia code module sometimes write additional julia code module built call wrapmodule method inside appropriately named julia module module extendedtypes using cxxwrap wrapmodule libextended export extendedworld greet extendedtypes name matches module name passed createmodule wrapmodule call functions types defined existing extendedtypes module additional julia code exports macros defined replace wrapmodule call call readmodule separately call wraptypes wrapfunctions allows using types functions called useful overloading argumentoverloads types defined overriding finalization behavior default objects allocated julia destroyed finalizer calls delete override behavior specialize jlcxxfinalizer class follows example special tye getimpl function namespace jlcxx template typename struct finalizer specializedfinalizer static void finalize todelete constexpr bool hasgetimpl requires const getimpl constexpr hasgetimpl stdcout calling specialized delete stdendl delete todelete else delete todelete specialize specific behavior depending concrete type stl support version introduces basic support standard library mappings stdvector stdvector stdstring stdstring add support vectors type world add methods stdvectorworld argument manually wrap using jlcxxstlapplystlworldmod add include jlcxxstlhpp file type world contains methods return std collections type world world complete type cxxwrap generate type template specializations std collections add methods type jlcxxstlapplystlworldmod modmethodgetsecondaryworldvector const world const stdvectorworld return getsecondaries linking wrappers using stl support requires adding jlcxxcxxwrapjuliastl targetlinklibraries command cmakeliststxt release procedure releases cxxwrap require release component libcxxwrapjulia rebuild jll package tested properly following procedure followed release requires changing julia component merge changes cxxwrap testjll branch create pr libcxxwrapjulia required changes passes tests tests run using cxxwraptestjll branch merge libcxxwrapjulia pr build publish jll available cxxwraptestregistry pr cxxwrap merge testjll prerelease verify tests pass rerun push testjll jll version merge pr tag libcxxwrapjulia release update release yggdrasil wait jll appear registry merge pr verify tests running prerelease branch pass merging pr difference tests testjll branch prerelease branch tests using jll julia repository merge cxxwrap prerelease branch main create release using registrator breaking changes cxxwrap juliacppmodulebegin juliacppmoduleend exists define function return type jlcxxmodule global namespace instead default julia expects function named definejuliamodule name chosen passed argument wrapmodule wrapmodules removed replace wrapmoduleslibfilepath module foo using cxxwrap wrapmodule libfilepath exportsymbols removed modules wrapped corresponding module declared julia regular julia export statement safecfunction macro cfunction macro julia precompilation add function wrapmodule macro function init initcxx breaking changes v automatic conversion julia string stdstring stdstring maps stdstring implements julia abstractstring interface automatic dereference const ref arrayref supports boxed values custom smart pointer jlcxxaddsmartpointermysmartpointermodule mysmartpointer ismirroredtype instead isimmutable isbits added using maptype default ismirroredtype true trivial standard layout types wrap normally unexpected error mirrored types marked ismirroredtype added using addtype map directly struct instead maptype explicitly disable mirroring type template struct ismirroredtype foo stdfalsetype box function takes explicit template argument introduction specific integer types cxxbool map equivalent transparent except template parameters defining supertype casting base class previous implementation wrong multiple inheritance refcxxptr pointer reference pointer cxxptrmydatacnull instead nullptrmydata defining supertype using jlcxxjuliabasetype function instead jlcxxjuliatype breaking changes v requires julia jll packages reorganized integer types fixedsize types map built julia types breaking changes v automatic dereferencing smart pointers removed code require adding dereferencing operator explicitly pr references juliacon talk julia technical overview cxxwrapjl juliacon workshop wrapping library using cxxwrapjl