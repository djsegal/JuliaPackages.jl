abstractppljl lightweight package factor interfaces associated apis modelling languages probabilistic programming level goals definition interface abstract types set functions supported probabilistic programs trace types provision commonly functionality data structures managing variable names traces facilitate reuse functions modelling languages allow users handle models consistent simplify interaction languages sampler implementations rich dynamic languages turingjl highly constrained simplified models gps glms plain logdensity short term goal start process cleanly refactoring justifying dynamicppljl design hopefully closer terms sossjl abstractprobabilisticprogram interface somewhat drafty somewhat incompatible conventions term model none particularly exact turingjl write model function call arguments model object paired possibly empty set observations treated instantiated conditioned object fixed values parameters observations sossjl model symbolic generative object concrete functions densities sampling functions derived condition conditional density etc relevant discussions tldr interrelating aspects interface intends standardize density calculation sampling conversions conditionings models interface consists abstractprobabilisticprogram supertype functions conditionmodel trace conditionedmodel deconditionconditionedmodel generativemodel samplemodel sampler exact int abstractmcmcsample logdensityofmodel trace densityofmodel trace densityinterfacejl traces probability expressions infrastructural requirement write kinds models consider theoretical sense distributions traces types carry collections values names existing realizations varinfo turingjl choice maps genjl usage named tuples sossjl traces solve name random variables function calls samples models essence concrete trace type fancy dictionary variable names ideally varname values mapping lot specification interface choose arbitrary macro syntax following ideas object found conversions purpose provide common names model instance understood seen modelling languages model instances primarily generative parameters fixed instance types pair model instances conditioned observations call conversions interface transform views unify involved objects language start generative model parameter hypothetical generative spec la soss generativemodel function foogen normal normal normal applying constructor foogen means fix parameter return concrete object generative type foogen somegenerativemodel object able sample calculate joint logdensities combined trace space directly deriving respective functions converting form symbolic representation model types contain structural information condition observed values obtain conditioned model condition someconditionedmodel operation probably exist syntactic sugar form start turingjl model instead observation specified situation observations fixed instantiation conditioned spec la dppl model function foo normal normal normal foo someconditionedmodel supported generative form via decondition via condition decondition somegenerativemodel condition equality distribution turingjl object time contain information generative posterior distribution condition decondition simply return kinds tagged model types model specification context sossjl pretty examples model object jointmodel conditionedmodel syntax sugar latter hypothetical densitymodel types logdensityproblemsjl model type support structural operations condition decondition invariances operations follow normal rules probability theory methods directions supported modelling language methoderror runtime error raised strict requirement generative models conditioned models types tagged variable names etc choice concrete implementation decomposing models prior observation distributions specified former easy marginal generative distribution latter requires structural information generalized query function discuss sampling sampling refers producing values distribution specified model instance following distribution exactly approximating monte carlo algorithm sampleable model instances assumed implement abstractmcmc interface step accordingly sample steps samples aspect sample plays role rand distributions results sample generalize rand rand assumed iid samples sample sampler returns sample sequence chain mcmc length approximating distribution specific sampling algorithm course subsumes sampled exactly chain actually iid depending sampling supported methods supported posterior conditioned model sampling procedure abstractmcmc sample rng sampler args chain length using sampler generative model posterior model exact solution methods specify sampler sample rng args random sample sample rng args iid samples equivalent rand implement special sampler exact name discussed reused generative sampling step spl exact iid sample exact distribution trivial sample exact dispatch failing models types exact sampling implemented useful monte carlo methods based markov chains particlebased sampling using return type weights rejection sampling variants supported example posterior model support sample exact sampling sample alg markov chains rand special trivial exact sampling model joint model density evaluation versions model understood generative conditioned expressed type dispatch support separate functions logjoint loglikelihood etc force semantic distinctions implementor adapt interface densityinterfacejl main function logdensityof suffice variants distinction capabilities concrete model instance densityinterfacejl requires trait function densitykind set hasdensity abstractprobabilisticprogram type additional functions densityinterfacedensityof explogdensityof densityinterfacelogdensityof basefixlogdensityof densityinterfacedensityof basefixdensityof provided automatically repeated clarity note logdensityof strictly generalizes logpdf posterior density course unnormalized hence probability density evaluation usually internal concrete trace type varinfo turingjl logdensityof vi user interface using probability expressions logdensityof note replace current prob string macro turingjl densities usually normalized implementation notes able fall internal method definition implementation maketrace logdensityof probabilityexpression logdensityof maketrace question normalized unnormalized densities able distinguished dispatch caller normalization logdensityof normalizedvaltrue proably traits maybe arrays normalizationstyle isnormalized probability expressions note macro written keys complex symbols indexed variables don hang name draft idea standardize construction manipulation abstract probability expressions plus interface concrete traces specific model formula applyschema statsmodelsjl maybe following suffice maketrace tracetype maketrace produces concrete trace corresponding model tracetype corresponding eltype function giving concrete trace type model probability expression combination extensions idea pearlstyle notation allowing free variables specify model transformations query graph queries parents nice express gibbs conditionals predicate style measure queries latter applications reason originally liked idea macro called look bayesian probability expression meaningful representing trace instance coexist produce kinds probabilityexpression objects nb exact details schema application results specified interface abstractmodeltrace aka varinfo abstractmodeltrace varinfo interface draft draftier ll try dynamicppljl background aspects varinfo complex data structure currently insane amount complexity implementation details dynamicppljl varinfojl rewritten multiple times concerns mind times improve concrete turingjl type stability requirements specific samplers unfortunately makes varinfo extremely opaque hard refactor breaking dares touching lot knowledge turingjldynamicppljl internals judge effects changes design choices recently torfjelde shown simpler implementation feasible basically wrapped namedtuple minimal interface purpose proposal twofold sufficient interface abstractmodeltrace abstract supertype varinfo allow multiple specialized variants refactor existing ones typeduntyped simple view design abstract data type specification construction modification mechanisms dictionary structure related previous discussions discussion varname abstractvarinfo representation additionally closely related tries formalize subsumption mechanism varname interaction using varname keysindices discussions bit fuzzy zone abstract meant wider purpuse abstractppljl implementation probabilistic programming systems concrete dppl hope stay abstract reusable couple candidates appl clients dppl hopefully focused simulation based calibration simpleppl bugs frontend paretosmoothingjl change user turingjl usually don varinfo raw evaluator interface anyways data structures userfriendly occur future people look code using varinfo starting hack turingjldppljl huge reduction cognitive complexity varinfo implementations readable implemented functions layed usages look nice normal data structure core dppljl implementors previous plus standard improve test varinfo defined design space data structures abstractppljl clientsppl implementors interface program rest appl existing set specified flexible trace data types characteristics terms implementation dppljl interface fixed fixing varinfojl undergo heavy refactoring simpler getter functions slightly semantics etc property interface basic idea varinfo behave dictionaries varname keys common operations special fancy indexing varname structured varinfo bit trie sense prefixes stored keys retrievable subsumption varname respected document vi varname vi varname vi varname vi varname generalizations beyond simple imagine storing individual setfield tree implemented beginning vi varname vi varname keys vi vi varname keys vi discussed information sampled values flags metadata pointwise likelihoods etc principle stored multiple varinfo dicts parallel structure efficiency thinkable devise design multiple fields stored indexing structure vi varname vi varname meta bla false direction logically equivalent dictionary named tuple values maybe dicttable field indicating position evaluator function variable added essentially counter insertions actually left completely dictionary specified insertion question joint data structure behave dictionary namedtuple eltypevi namedtuplevalue float meta struct dicts shared keys eltypevivalue eltypevi float required dictionary functions following pure functions iterate yielding pairs varname stored value iteratoreltype haseltype iteratorsize haslength keys values pairs length consistent iterate eltype keytype valuetype getindex haskey indexing varname merge join varinfo mutating functions insert set merge add join elements todo merge setindex empty delete unset makes persistent implementations easier believe adopting interface dictionariesjl baseabstractdict ideal approach key sharing operations naturally easy particularly broadcaststyle transformations values keys base functions enumerate follow length appear weird definitely consistent iterator cool merge supported combination distinct types implementations dynamic tuplebased support mutable immutablepersistent implementations require consistent bangbangjl style mutators throughout transformationsbijectors transformations ideally handled explicitely outside automatically compiler macro required samplers implementationwise probably expressed folds map link dist value vi linearization multiple approaches handle special conversion vectorvi copyvalsarray vi fold mapreduce vecvalue append vi initfloat implementation fold variants additionally provided syntactic sugar varname based axioms follows attempt formalize subsumption remember turingjl concretized varname begin boolean indexing form concrete cartesian array indexing assuming suggestion implemented makes index comparisons static varname compositional structure built composing root variable lenses varname starts identitylens julia vn varname setfield indexlens setfield indexlens note composition function wrong heritage setfieldjl subsumption mean notion varname expressing nested path subsumes varname varname varname varname sqsupseteq varname varname nsqsubseteq following axioms varname variables varname variables distinct variables incomparable asymp variables lenses axiom define subsumption individual composed lenses propertylens propertylens symbols functionlens functionlens extensional equality mentioning generalize bijectored variables varnamelog indexlens indexlens index tuple covers indices example bit fuzzy corner considered identitylens identitylens otherwise varname subsumption reflexive poset fundamental requirement varinfo vi vi following automatically vi insert vi vn vivn trivial set set vi insert vi vn vivn vivn vn subsumes vn vn opposite supported depend implementation complicated unification vi insert vi vn vi insert vi vn vivn vivn vn vn recognized children common parent vn