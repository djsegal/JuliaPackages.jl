monadfunctions experimental package functions following types monads maybe result list usage maybe fmap function map maybe monad none input wrapped object output automatically wrapped none singleton constant none unlike implementations fmap ed function ordinary values monads apply function usual return ordinary result result elevated wrapped monad fmap fmap none fmap none orelse switch useful value none encountered orelse orelse none orelse cata execute left function value function value useful cata none cata extend none types implementing maybetypetrait note isnone trait default type capture left object create object simply left function leftvalue rightvalue extract wrapped value isleft isright check object left discrimination special result exception handling result constructor create result object default subtypes errorexception considered left else considered julia result monadresultvalue julia result argumenterror bad input monadresulterror argumenterror bad input convenient isleft isright functions check object left extract value object leftvalue rightvalue julia isright result true julia isleft result argumenterror bad input true julia rightvalue result julia leftvalue result error methoderror method matching leftvalue result list list monad essentially dimensional array list constructor create list monad fmap elements flatten nested list julia list element arrayint julia list element arrayint julia fmap element arrayint julia flatten element arrayint examples using maybe monad handle maybe monad contains useful useful sometimes functions returns throwing exception indicate negative condition example match hello bit unfortunate test condition using result matched match hello result matched matched match world else notion maybe functional style hello match matched concat world happen following create composable functions single arguments base match re regex base fix match re matched rm regexmatch rm match concat string base fix string type piracy define match function convince julia core developers addition base library fine julia hello match matched concat world hello world close condition julia abc match matched concat world error methoderror method matching matched help fmap function julia abc fmap match fmap matched fmap concat world true getting little hard read compose functions process fmap match matched concat world using test test process hello hello world test process abc look ma data flow pipeline conditional statement using result monad exception handling monad contains data left useful track scenarios examples julia goingtoparty left sick monadeitherleft sick julia isleft goingtoparty true julia playbadminton weekend monadeitherright weekend julia isright playbadminton true julia rightvalue playbadminton weekend result monad special convention stay track normal conditions switch left track encounter error condition left track stay ignore computation error condition captured switch left track tell wrong computation monad useful handling errors simple example run database query process establish connection obtain database cursor run query trouble throw exception database api calls try conn getconnection url cursor getcursor conn sql select somehwere return query cursor sql catch ex error unable run query due ex ex rethrow ex nice error flows using trycatch statement anonymous function composable runquery sql cursor query cursor sql error handler handlequeryresult err lefteither error leftvalue err result set handler handlequeryresult rs dataframe job establish pipeline result fmap url getconnection getcursor runquery select sometable handlequeryresult returned result runquery value error bad calling isright isleft respectively dispatch based resulteither erroreither typ