plutodevmacros package containing macrosfunctions help develop packages using pluto notebooks building blocks frompackage macro frompackage target importblock macro basically taking local package derived target loading submodule current pluto workspace process various importusing statements inside importblock extract varablesfunctions local package notebook changes code local package cell containing call frompackage reexecuted reload recent version module allowing pluto workflow similar revise added advantage limitations revise requiring restart julia session redefining structs avoided main purpose able create packages starting pluto notebooks building blocks approach package development disadvantages convenient speed workflow especially beginning development thanks avoiding restart julia redefining structs exploiting reactivity pluto quickly assess automagically code update indeed fix issues cells depend changed functions notebook mentioned achievable single pluto notebook requiring macro notebooks complex containing cells start sluggish unresponsive conveniente able split code various notebook able access functionality defined notebooks single cell notebook simply import notebooks ingredients plutohooks plutoinclude inspired ingredients plutodevmacros exist found limitations concerns directly using notebooks building blocks package note explained current implementation frompackage supports target files contained inside package folder moreover package containing target file correctly resolved manifest file target package correctly resolved calling pkgresolve package environment frompackage properly arguments details arguments expected macro target argument target string containing path absolute relative file calling macro local package path file subfolder package folder specific file included package target file appears package module definition inside include call target directly file included package code module defining package parsed loaded pluto workspace notebook calling macro target actually file included inside package macro parse package module code excluding inclusion target discard rest code loading inside pluto reduced package mimicking behavior include package included file visibility code loaded inclusion behavior essential using macro notebook included target package avoid variable redefinitions pluto notebook original usecase macro importblock argument macro supposed single usingimport statement multiple usingimport statements wrapped inside begin block statements conveniently select loaded package names te imported notebook import statements relevant called pluto frompackage simply avoid loading target package deletes import statements called oustide pluto specific type import statement relative import relevant applicable outside pluto statement maintained macro output outside pluto macro respects differentiation using import normal julia statements containing using module variable name specifier import exported names module supported usingimport statements supported statements allow following catch notation import module imports notebook variables created imported module useful avoid export module file directly specify names module importing notebook import statement contain module statements import module module supported multiple imports multiple statements begin block type import statements supported macro types relative imports imports package module import parent module submodule direct dependency import relative imports relative imports ones module name starts dot relevant loaded module contains multiple submodules supported statement kept outside pluto catch notation supported relative imports import siblingmodule extraction names desired relative module requires loading inspecting package module functional inside pluto statement deleted frompackage called outside pluto imports package module import statements name packagemodule identifier using packagemodulesubmodule import packagemodule varname import packagemodulesubmodulesubsubmodule statements processed macro transformed packagemodule actually module loaded macro alternative represent packagemodule write expressions interchangeably fromparent import packagemodule varname fromparent import varname avoid triggering pkg statusmark pluto appears valid name package typed valid create status mark image imports parent module submodule statements similar previous imports package module ones main difference target file actually file included loaded package giving error otherwise parentmodule loaded package module contains line calls includetarget target loaded package main module submodules parentmodule module packagemodule catch special parent module import form import equivalent import fromparent tries reproduce namespace calling notebook namespace visible notebook file loaded package module outside pluto imports direct dependencies import direct dependencie target package frompackage macro prepend package name example load benchmarktools package macro assuming indeed direct dependency target package frompackage target begin using benchmarktools modification trying frompackage combination pluto pkgmanager explained statements importusing direct dependencies supported inside outside pluto means example following code effectively translate using benchmarktools inside outside pluto frompackage target begin using benchmarktools statements combination catch imported name feature useful trying combine frompackage integrated pluto pkgmanager preferable pluto notebook environment packages loaded package environment load eventual packages direct dependencies loaded package directly frompackage importblock minimizes risk issues caused versions collision dependencies shared notebook environment loaded package environment combining frompackage pluto pkgmanager experimental feature comes significant caveats please read related section readme skipping package macro allows specify source code target package skipped loading pluto achieved adding statement inside importblock following skiplines lines skiplines macro defined package processed parsing frompackage macro lines expected single string strings begin block string represent file skipped following formats supported filpeathfirstlinelastline specifies lines firstline lastline extrema included file filepath skipped loading package module filepathline single line skipped filepath file located filepath ignored loading module line ignores line line package entry file srcpackagenamejl folder packagename firstlinelastline ignores range lines examples filepath provided absolute path relative path starting src subfolder package folder functionality skipping lines frompackage called inside pluto calling macro outside pluto eventual statement skiplines discarded example example consider source file testpackagejl defined test subfolder contents shown notebook called outnotebookjl located main folder testpackage example functionality following call fromparent import testpackage notebook workspace removing code original source testpackage fromparent begin import testpackage skiplines begin skip line main file testpackagejl testmacrojl skips file testmacrojl skips line main file including extrema testmacrojl skips testmacrojl output notebook pasted reference reload button macro called pluto creates convenient button reexecute cell calling macro reloade package code due change quickly navigate position cell containing macro using ctrlclick reload button change appearance getting red border macrocall encountered error due incorrect import statement fromparent import proper target due error encountered loading package code short video reload button window left specificimportsjl notebook specificimportsjl included testpackage using tests follows plutodevmacrosjltesttestpackagesrctestpackagejl lines ef module specificimport include specificimportsjl include specificimportsjl baedcdcdmp fromparent macro fromparent macro accepts importblock single argument calling file target fromparent importblock frompackage file importblock addmethod macro fromparent frompackage functions rely ingredients plutoinclude generating temporary modules importing variables modules causes pluto currently support directly adding methods functions imported modules circumvent plutodevmacros exports addmethod function simply takes care prepending correct module name function signature code addmethod func args kwargs simply translated definingmodule func args kwargs definingmodule module func defined called outside pluto addmethod simply returns expression modifying useful avoid multiple definition errors inside pluto caveat defining method addmethod trigger reactive run cells call modified function mean removing cell addmethod call actual method added definingmodule automatically erased pluto accessible overwritten method signature easy fix adding methods modules loaded frompackage fromparent reloading module sufficient remove hanging method video example bddbebcabccfaamp fromparentfrompackage pluto pkgmanager module package loadedevaluated macro inside notebook workspace notebook environment contain packages target package inside environment ideally achieved deactivating pluto pkgmanger activating environment contains local package dependency sometime inconvenient pluto pkgmanager advantages maintain pkgmanager notebook contain cell import packages loaded module macro currently hack allow loading target package module direct dependencies add dependencies notebook environment adding package environment loadpath attempting load removing loadpath evaluating various import statements macro tries catch exceptions thrown macro compilation resulting expression evaluation using try catch correctly clean loadpath macro executed approach brittle cause issues notebook package environment share dependencies version loaded actual version notebook package module loaded notebook adding package environment position loadpath notebook environment minimize potential issues notebook environment parsed packages prevent package example dataframes loaded package added notebook target package loaded version dataframes notebook version loaded package installed notebook environment restarting notebook situation flip dataframes notebook environment notebook version loaded notebook package module potentially causing issues packagecode depending version dataframes due issues mentioned macro knowing break pluto pkgmanager manually adding depending packages notebook environment plutoinclude macro plutoinclude macro aimed simplifying development packages multiple connected notebooks building blocks creating package functionality divided various notebooks included main package file plutoinclude inside notebook serially chain code definition notebook notebook except contain plutoinclude call preceding include notebooks main package source called inside pluto notebook plutoinclude takes care including variables function definitions included notebook including called notebook path include variables function explicitly marked export string argument macrocall import variables functions defined included notebook including lastly macro creates button notebook front clicked trigger recomputation inclusion modifying imported variables definition following modification included notebook video example check plutoincludemacro plutoincludetest basic usage test test test chained inclusion examples fbcddcfebfmp onlyinnb onlyoutnb exported macro onlyinnb ensures content cell executed ran notebook defined similarly macro onlyoutnb executes code cell included calling include notebook file julia file useful especially create test functionality standalone notebook import pkg using cells beginning notebook code cells executed notebook file included else code inspired heavily based skipasscript onlyasscript macros found inside pluto main package plutotest separate macros reasons original pluto macros limiting execution specific notebook pluto session include notebook notebook skipasscript macros executed issue original pluto macros requires requires developing personal package macro solve issue note functionality originally intended onlyinnb onlyoutnb directly achieavable pluto using skipasscript implemented pr