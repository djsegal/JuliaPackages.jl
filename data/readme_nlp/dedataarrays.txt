dedataarraysjl note functionality deprecated bottom details dedataarray type allows add continuous variables array useful modeling situations involving lots events define dedataarray type subtypes dedataarray field array continuous variables differential equation treat directly fields treated discrete variables example mutable struct mydataarray dedataarray array symbol example resultant array simtype data differential equation solver array array differential equation solver allowed field including dedataarray add whatever fields please whatever type please extra fields carried differential equation solver user equation modify via callbacks example inside update function safe function du update discrete variables unless algorithm notes step endpoint callback update appropriately note aliases dedatavector dedatamatrix cover dimensional example control example dedataarray solve control parameters change various timepoints build mutable struct simtype dedatavector array f dedatavector extra field f control variable ode function field follows function du du f du setup control mechanism simple setup set timepoints change f increase value f decrease value f using discretecallback interfaceref discretecallback code conditions follows const tstop const tstop function condition integrator tstop function condition integrator tstop apply effect conditions reached condition hit increase f condition reached decrease f via functions function affect integrator fullcache integrator f function affect integrator fullcache integrator f notice loop fullcache array provided integrator interface ensure internal caches updated functions build callbacks savepositions true true cb discretecallback condition affect savepositions savepositions savepositions false true cb discretecallback condition affect savepositions savepositions cbs callbackset cbcb define initial condition start f u simtype prob odeproblem u lastly solve note pass tstop values ensure solver hits timepoints exactly const tstop sol solve prob tsit callback cbs tstops tstop plot controls affected outcome data arrays vs parameterized functions reason using dedataarray solution save control parameters example control parameter timepoint checking sol f length sol similar solution achieved using parameterizedfunction instead created function function du du du u simtype prob odeproblem u const tstop sol solve prob tsit callback cbs tstops tstop change callbacks changing parameter function affect integrator integrator function affect integrator integrator solve equation similar result slightly faster equation solved manner record parameter timepoint tradeoff dedataarray parameterizedfunction downsides dedataarrays dedataarray idea explains repo stay alive people note ordinarydiffeq v explicit support dedataarrays functionmap removed pr scimlordinarydiffeqjl support evaluate function function ordinarydiffeq performstep integratorcache ordinarydiffeqfunctionmapcache repeatstep false ordinarydiffeq unpack uprevdt integrator alg ordinarydiffeq unwrapalg integrator ordinarydiffeq unpack tmp cache integrator ordinarydiffeq diffeqbase discreteinplacedefault typeof integrator ordinarydiffeqdiffeqbaseevalfunc integrator ordinarydiffeq diffeqbase discreteinplacedefault ordinarydiffeq functionmapscalebytime alg tmp uprev dt ordinarydiffeq muladd ordinarydiffeq broadcast false uprev dt tmp else uprev dt integrator destats nf typeof dedataarraysdedataarray fields updated uprev dedataarrays copyfields uprev risk