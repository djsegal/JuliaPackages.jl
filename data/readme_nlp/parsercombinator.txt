parsercombinator example install manual parsers design releases parser combinator library julia similar languages haskell parsec python pyparsing parse iterable type strings except regexp matchers course parsercombinator main advantage flexible design separates matchers evaluation strategy makes easy plug memoization debug traces restrict backtracking similar parsec using grammar contains prebuilt parsers graph modelling language dot example using parsercombinator ast nodes construct evaluation via calc abstract type node base n node n node n val n val calc float struct inv node val calc inv calc val struct prd node val calc prd base prod map calc val struct neg node val calc neg calc val struct sum node val calc sum base sum map calc val grammar combinators sum delayed val sum pfloat neg delayed allow multiple negations eg neg matcher val neg neg mul neg div neg inv prd neg mul div prd add prd sub prd neg sum matcher prd add sub sum sum eos test prints calc parseone prints sumprdprd parseone explanation lot syntactic sugar verbose parser combinator style prefer example seq instead app instead matcher xyz matches discards string xyz matcher returns list matched values empty list match succeeded matched operator matches expressions appends resulting lists similarly matches alternatives operator calls function passing results matchers left similar interpolates arguments ie instead passing list values calls function multiple arguments delayed define loop grammar syntax greedy repeat matcher left alternative star match values supports packrat parsing exactly memoize results avoid repeating matches parsing tasks eg parsing source code compiler probably wrapper external parser generator anltr note issue compat library means code assignment delayedmatcher calcjl uglier hopefully temporary version install julia pkg add parsercombinator manual evaluation basic matchers equality sequences empty values alternates regular expressions repetition match transforms lookahead negation backtracking controlling memory spaces pre postfixes locating errors coding style adding matchers debugging information evaluation grammar evaluate input various parseone simple recursive decent parser backtracking memoization returns single result throws parserexception parseall packrat parser memoization returns iterator evaluated lazily parses input parselines parser source parsed line line pre julia copies strings passed regex reduces memory using regular expressions parsetry similar haskell parsec backtracking inside try matcher info parsedbg parseone prints trace evaluation matchers children trace matchers matchers via keword delegate example parsedbg delegatecache provide tracing packrat parser parseall info implemented providing config subtypes information design typesjl parsersjl basic matchers follows remember power parser combinators comes combine nested refer etc etc equality julia parseone abc equal ab element array ab julia parseone abc equal abx error parsercombinator parserexception parse common corresponding string literal equal corresponding matcher julia parseone abc ab element array ab sequences matchers return lists values multiple matchers return lists lists results flattened level usually useful julia parseone abc series equal equal element array julia parseone abc series equal equal flatten false element array julia parseone abc seq equal equal element array julia parseone abc equal equal element array julia parseone abc element array julia parseone abc element array series implemented seq depending value flatten default true warning sugared syntax follow standard operator precedence binds tightly means matcher matcher matcher error means matcher matcher matcher intended matcher matcher matcher empty values match discard empty discarded value empty list help explain flattening lists useful julia parseone abc drop equal equal element array julia parseone abc seq drop equal equal element array julia parseone abc element array julia parseone abc element array note tilde home directory capital examples respectively alternates julia parseone abc alt element array julia parseone abc element array warning sugared syntax follow standard operator precedence binds tightly means matcher matcher matcher error means matcher matcher matcher intended matcher matcher matcher regular expressions julia parseone abc pattern element array abc julia parseone abc element array abc julia parseone abc element array bc equality capital prefix string literal pattern implies value dropped note regular expresions backtrack typical greedy regular expression match input time backtracking exists library matchers duplicate regular expression functionality repetition julia parseone abc repeat element array julia parseone abc repeat element array julia collect parseall abc repeat element array julia parseone abc repeat flatten false element array julia collect parseall abc repeat element array julia collect parseall abc repeat greedy false element array depth breadth greedy greedy repeats directly repeat readable sugared version looks julia parseone abc element array julia parseone abc element array julia parseone abc element array julia parseone abc element array symbol equivalent greedyfalse flattenfalse compare special julia collect parseall abc plus element array julia collect parseall abc star element array match ensure input matched add eos grammar julia parseone abc equal abc eos element array abc julia parseone abc equal ab eos error parsercombinator parserexception parse transforms app pass current results function datatype constructor individual values julia parseone abc app star tuple element array julia parseone abc star string element array abc action appl similar passed single argument list julia type node children julia parseone abc appl star node element array node julia parseone abc star map uppercase element array lookahead negation sometimes write clean grammar consumes data check ahead avoid check ahead julia parseone c lookahead pint dot element array julia parseone c lookahead pint dot element array replaces match failure failure empty match ie empty list backtracking default matchers backtrack unusual useful disable backtracking example pcre possessive matching basis adding backtrackfalse repeat alternatives series appending matchers functions generate depth breadth alt seq example collect parseall abc seq single match seq trailing backtrack repeat child matchers regular expressions backtrack simpler faster write collect parseall abc using backtrackfalse disables backtracking direct children matchers disable backtracking change matchers grammar example theory following grammars backtracking behaviour series repeat backtrack false series repeat backtrack false backtrack false practice identical contrived example backtrack anyway makes grammar efficient specific reduce memory consumed parser guarantee resources released section approach reducing memory controlling memory haskell parsec understand correctly backtrack default exactly allow input consumed matched read reduces memory consumption parsing files read data discarded accepts ll grammars allow parsing wider range grammars parsec introduces try combinator enables backtracking portion grammar approach library using parsetry filetxt abcdefghijklmnopqrstuvwxyz testtxt io throws execption requires backtracking parsetry io string testtxt io try fine parsetry io try string backtracking error messages using error matcher useful parsec provide error messages julia try parsetry alt error letter catch println msg letter line column failed character line finally note implemented source level restricting text visible matchers matchers backtrack attempt disable backtracking matchers efficient grammar spaces pre postfixes lack lexer complicate handling whitespace using parser combinators library includes ability add arbitrary matchers named matchers grammar useful matching discarding whitespace example spc drop star space withpre spc begin sum delayed val spc sum spc pfloat neg delayed allow multiple negations eg neg matcher nullable matcher val neg neg mul neg div neg inv prd neg mul div prd add prd sub prd neg sum matcher nullable matcher prd add sub sum sum spc eos extends parser earlier discard whitespace symbols automatc addition spc prefix named matchers assigned variable sum val neg etc means added explicitly locating errors sometimes useful report user input text wrong recursive descent parser useful indicator maximum depth reached source retrieved using debug config simple example delegates nocache default confg parseone grammar eos source abc parser task debug task debug source grammar delegate nocache task parsing throws exception debug config contains maxiter println sourcedebug maxiter error location abc little complex predefine function cf parseone please email currently unclear features support directly leave advanced users information parsersjl debugjl alternative approach error messages parsetry error matcher coding style reinventing regexps built regexp engine efficient library call regexps liberally syntax makes easy regular expressions backtrack matched drop stuff transform containers result nice types look example understand format parsing motivated person designed format compare gml dot parsers return results format authors cared gml elegant data format dot sequential description program encodes graph layouts adding matchers add matcher lot transforms started equal matchersjl example simple single returns success failure matchers call submatcher implemented transforms insist example jl write complex stateful matchers afraid re learn code repeat series enjoy debugging debugging grammar frustrating experience times helps simple view inside happening supported parsedbg print record messages execute response design matchers inside trace matcher addition grammar defined inside withnames macro symbols identify various grammar variable names displayed appropriate example view applying trace matchers care withnames begin sum delayed val sum pfloat neg delayed allow multiple negations eg neg matcher val neg neg mul neg div neg inv prd neg mul div prd add prd sub prd neg sum matcher prd add sub sum sum eos parsedbg trace trace sum transformseq seqprd prdseq seqneg altseq seqdrop dropequal drop seq alt alttransform transformpattern transform alt seq seqdepth depthalt altmul muldrop dropequal drop mul alt altdiv divseq seqdrop dropequal drop seq div alt depth seq prd seqprd seqdepth depthalt altadd adddrop dropequal drop add addprd prdseq seqneg altseq seqdrop dropequal drop seq alt alttransform transformpattern transform alt seq seqdepth depthalt altmul muldrop dropequal drop mul mulneg altseq seqdrop dropequal drop seq alt alttransform transformpattern transform alt mul alt depth depthalt altmul muldrop dropequal drop mul alt altdiv divseq seqdrop dropequal drop seq seqneg altseq seqdrop dropequal drop seq alt alttransform transformpattern transform alt seq div altinv depthinv depthalt altmul muldrop dropequal drop mul alt altdiv divseq seqdrop dropequal drop seq div alt depth seqinv prdinv addprdinv altprdinv depthprdinv depthalt altadd adddrop dropequal drop add alt altsub subseq seqdrop dropequal drop seq sub alt depth seqprdinv transformprdprdinv sumprdprdinv eos tracesumprdprdinv note left current iterator followed source current offset column depth relative trace indentation messages reflects wraps levels message flow execute response matcher names replaced variable names eg sum appropriate functionality implemented separate parser config instance performance penalty debugjl details finally printing matcher useful tree view grammar loops elided println sum transsuccess seq prd seq neg alt seq drop equal sum drop equal transsuccess pattern ee transsuccess seq drop equal neg depth alt mul drop equal neg div seq drop equal neg lo hi flattentrue depth alt add drop equal prd sub seq drop equal prd lo hi flattentrue eos parsexxx debugtrue strack trace main parse loop information source error information details afraid bet source code typesjl introduces types throughout code matchersjl defines seq repeat sugarjl adds etc extrasjl parsers int float etc parsersjl info creating parseone parseall functions transformsjl defines results manipulated testsjl pile liner tests useful debugjl enable debug mode jl example userdefined combinator parsers graph modelling language gml describes graph using dict list format json parseraw returns lists tuples directly match gml structure parsedict data nested dicts vectors keys symbols access file using syntax dictfield parsedict keyword arguments lists list keys stored lists default graph node edge unsafe set true mutiple values keys discarded default false underlying issue file format keys lists user specify default error thrown information incomplete unsafe set user care attributes note parser conform specifications iso entities decoded parser accept utf integers floats bit strings length check required fields example print node ids edge connections graph using parsercombinator parsers gml mygraph graph node id node id node id edge source target edge source target edge source target root parsedict mygraph graph root graph multiple graphs node graph node println node node id edge graph edge println edge edge source edge target giving node node node edge edge edge details please read gmljl dot dot describes graph using complex format resembles program mutable specification comments source parsedot returns list structured ast types dotjl graph file keyword argument debug takes bool enables usual debugging output nodesgraph extracts set node names structured ast edgesgraph extracts set edge names node name pairs structured ast example print node ids edge connections graph using parsercombinator parsers dot mygraph graph root parsedot mygraph node nodes root println node node node node edges root println edge node node giving node node edge edge edge nodes edges unordered returned set graph specification undirected cf digraph nodes edge canonical sorted form design discussion design parsercombinatorjl please blog post available overview parser combinators written afaik functional languages tail calls consume stack packrat parsers easiest implement lazy languages shared cached results free julia neither tail recursion optimisation lazy evaluation hand tail call optimisation support backtracking combine results child parsers implement combinators repeated matches using iteration recursion short life complicated parser features costs particular implementation choice defended detailed analysis ideally approach supports features low overhead default extended accomodate expensive features library defines grammar static graph interpreted using explicit trampoline described detail main advantages describing grammar static graph types mutually recursive functions integration julia method dispatch example overload operators sequence matchers macros modify grammar compile time execution grammar simple using dispatch graph nodes semantics parser modified changing trampoline implementation method dispatch configuration type allows example choice memoization separated grammar explicitly identified encapsulated simplifying backtracking resumption current memoization main disadvantages defining combinators complex behaviour matcher defined methods correspond transitions machine hand dispatch grammar nodes implementation remains idiomatic compact feel result library similar parser combinator libraries grammar types handled expected example argue matchers real combinators written user graph types set recursive functions final execution logic equivalent trampoline protocol matcher invoked call execute config matcher message include minimum field source follows iterator protocol example source returns value source plus iter initial call ie time value backtracking equal clean matcher returns message indicates trampoline processing continue failure indicates match failed probably depending parent matcher configuration triggers backtracking single instance type failure success indicates match succeeded contains result type value type alias updated iter matcher look matchers dirty globally indicate matches fail execute results nested call child matcher execute method failure success messages processed trampoline typically trampoline implementation cached values result calls failure config matcher message success config matcher value message parent matcher clean resulting message note child returned parent responsibility parent save recall child source input text protocol source text read using standard julia iterator protocol extended methods defined sourcesjl iterators means dot returns characters strings practice matcher rarely particularly strings regular expressions pattern example construct string multiple characters using string releases added dot parser changed added support fast regex patch clarified source handling improved gml speed added gml parser related parsetry fixes added parsetry trampoline rewritten execution modes fixed calc example debug mode rewriting feature complet