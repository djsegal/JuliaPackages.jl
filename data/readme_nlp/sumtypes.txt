sumtypesjl basics destructuring sum types using fulltype concrete type sum type avoiding namespace clutter custom printing performance basics sum types sometimes called tagged unions type system equivalent disjoint union operation union traditional sense rust programming language called enums julia calls enum day sum type fancy word container store data predeclared types labelled instantiated users statically typed programming languages prefer sum types unions makes type checking easier dynamic language julia benefit objects obvious helpful performance sensitive branching heterogeneous types enforcing handling simplest version sum type list constant variants basically julia enum julia sumtype fruit begin apple banana orange julia apple apple fruit julia banana banana fruit julia orange brange fruit julia typeof apple typeof banana typeof orange fruit true particularly intesting sum types enclose data explore fundamental sum type fundamental sense sum types derived julia using sumtypes julia sumtype begin left sum type hold value type type constructors called left exist essentially instances carry record constructed wrapped dummy structs named left constructors behave julia left left int uninit julia uninit float notice left carry fewer type parameter simply writing left specify type unspecified field sumtypesuninit default rely implicit conversion initialized type julia int float left left int float typically enforcing return type function julia function foo int float randomly return left rand bool left julia foo left int float julia foo int float particularly useful foo type stable julia base returntypes foo tuple element vector int float uint julia isconcretetype ans true note unlike union false distinct destructuring sum types okay actually access data enclosed fruit answer destructuring sumtypesjl exposes macro efficiently unwrapping branching contents sum type julia myfruit orange orange fruit julia myfruit begin apple apple orange orange banana throw error allergic bananas orange julia banana begin apple apple orange orange banana throw error allergic bananas error allergic bananas automatically detect exhaustive set runtime penalty throw error julia myfruit begin apple apple orange orange error inexhaustive specification apple orange expected apple banana orange furthermore destructure sum types hold data julia int float rand bool left begin left example intfloat contained left wrapped data int bound variable added whereas float bound variable subtracted macro falls short pattern matching system lacking features advanced recommend using match mlstylejl using fulltype concrete type sum type click expand sumtypesjl generates structs compactified memory layout computed demand parametric types sumtypes actually extra type parameters related memory layout means instance int int julia sumtype begin left julia isconcretetype int int false proper concrete type corresponding int int fulltype function exported sumtypesjl julia fulltype int int int int uint julia fulltype int string int string uint julia fulltype tupleint int int string tupleint int int string uint julia isconcretetype ans true avoiding extra parameters require julialangjulia implemented avoiding namespace clutter click expand common complaint enums sum types sometimes contribute clutter namespace avoid variants available toplevel constant variables hidden option julia sumtype foo hidden begin julia error undefvarerror defined julia error undefvarerror defined hidden variants accessed applying operator type foo returns named tuple variants julia foo foouninit varfoo access named tuple normal julia foo foouninit julia foo fooint fancy julia foo fooint note propertydestructuring syntax available julia version julialangjulia custom printing click expand sumtypesjl automatically overloads baseio yourtype baseio mimetextplain yourtype type create sum type forwards call internal function sumtypesshowsumtype wish customize printing sum type overload sumtypesshowsumtype julia sumtype fruit begin apple orange banana julia apple apple fruit julia sumtypes showsumtype io io fruit begin apple print io apple orange print io orange banana print io banana julia apple apple julia sumtypes showsumtype io io mimetextplain fruit begin apple print io apple orange print io orange banana print io banana julia apple apple overload base directly inside package annoying method deletion warnings precompilation performance unityperjl able provide dramatic speedup versus manual union splitting sumtypesjl branching abstractly typed data benchmark code module abstracttypetest using benchmarktools abstract type base kwdef struct commonfield int bool true int base kwdef struct commonfield int int float complex im isbits base kwdef struct commonfield int float bool false float complexreal im isbits base kwdef struct commonfield int hi isbits foo xs eachindex xs inbounds xs inbounds xs isa isa isa isa error xs rand display benchmark foo xs benchmarktoolstrial samples evaluation range min max s ms gc min max time median s gc median time mean s s gc mean s histogram logfrequency time ms memory estimate kib allocs estimate sumtypesjl benchmark code module sumtypetest using sumtypes benchmarktools sumtype begin commonfield int bool int commonfield int int float complex commonfield int float bool float complexreal commonfield int commonfield true commonfield commonfield im commonfield commonfield false complex real im commonfield commonfield hi commonfield foo xs eachindex xs xs xs begin xs rand display benchmark foo xs benchmarktoolstrial samples evaluation range min max s s gc min max time median s gc median time mean s ns gc mean s histogram frequency time s memory estimate bytes allocs estimate unityperjl benchmark code module unitypertest using unityper benchmarktools compactify begin abstract struct commonfield int struct bool true int struct int float complex im isbits struct float bool false float complexreal im isbits struct hi isbits foo xs eachindex xs inbounds xs inbounds xs compactified begin xs rand display benchmark foo xs benchmarktoolstrial samples evaluation range min max s s gc min max time median s gc median time mean s ns gc mean s histogram frequency time s memory estimate bytes allocs estimate sumtypesjl unityperjl equal benchmark differences sumtypesjl advantages relative unityperjl sumtypesjl allows parametric types container flexibility sumtypesjl require default values field struct sumtypesjl macro powerful flexible unityper compactified sumtypesjl allows hide variants namespace opt advantage unityperjl unityperjl allow parameterized types type information macroexpansion time structs fixed layout boxed variables avoid allocation storing heap allocated objects allocation addition heap allocation object commonfield hi benchmarks sumtypesjl incurred allocation whereas unityperjl requre julialangjulia avoid sumtypesjl